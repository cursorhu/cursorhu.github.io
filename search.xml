<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++面向对象笔记：从C到C++</title>
    <url>/2020/03/14/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%8EC%E5%88%B0C/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>本章介绍C++语言和C语言相近的部分基础用法，包括</p>
<ul>
<li>引用: &amp;</li>
<li>常关键字: const</li>
<li>动态内存分配: new delete</li>
<li>函数内联: inline</li>
<li>函数重载</li>
</ul>
<h1 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h1><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。</p>
<pre><code>类型名 &amp; 引用名 = 某变量名;
</code></pre>
<p>某个变量的引用，等价于这个变量，相当于该变量起了一个别名。别名类似于操作系统的文件链接或快捷方式的概念，访问它变量本身的存储空间。</p>
<pre><code>int n = 4;
int &amp; r = n; // r引用了 n, r的类型是int &amp;
r = 4;
cout &lt;&lt; r; //输出 4
cout &lt;&lt; n; //输出 4
n = 5;
cout &lt;&lt; r; //输出5
</code></pre>
<p>注意：<br>1.定义引用时一定要将其初始化成引用某个变量。<br>2.初始化后，它就一直引用该变量，不会再引用别<br>的变量了。<br>3.引用只能引用变量，不能引用常量和表达式。</p>
<h2 id="引用的示例"><a href="#引用的示例" class="headerlink" title="引用的示例"></a>引用的示例</h2><p>引用常用于函数传参和返回值<br>1.引用作为函数入参<br>C语言写一个swap函数，交换两个变量的值，要传指针而不能传值，因为直接传值实际修改的是函数局部作用域的一份拷贝。</p>
<pre><code>void swap( int * a, int * b)
&#123;
    int tmp;
    tmp = * a; * a = * b; * b = tmp;
&#125;
int n1, n2;
swap(&amp; n1,&amp; n2) ; // n1,n2的值被交换
</code></pre>
<p>C++中，除了传指针，也可以传引用</p>
<pre><code>void swap( int &amp; a, int &amp; b)
&#123;
    int tmp;
    tmp = a; a = b; b = tmp;
&#125;
int n1, n2;
swap(n1,n2) ; // n1,n2的值被交换
</code></pre>
<p>2.引用作为函数返回值</p>
<pre><code>int n = 4;
int &amp; SetValue() &#123; return n; &#125;
int main()
&#123;
SetValue() = 40;
cout &lt;&lt; n;
return 0;
&#125; //输出： 40
</code></pre>
<h2 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h2><p>看上去引用和指针的功能相同，那区别在哪？<br>1.存储类型不同</p>
<ul>
<li>指针是一种变量，存储指向变量的地址值，通常占内存4字节（64位系统8字节）</li>
<li>引用只是变量的别名，它本身不另外占存储空间，对其求大小（sizeof）就是变量本身的大小</li>
</ul>
<p>指针是变量，因此可以为空（0x0）,而引用是标签（别名），不可为空，先有变量才能有其引用。<br>2.作用方式不同</p>
<ul>
<li>指针作为函数入参本质上还是是值传递，只不过传递的是变量的地址值，函数局部拷贝的也是地址。</li>
<li>引用作为函数入参，被调函数的形参作为局部变量在栈中开辟了内存空间，但存放的是主调函数的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。</li>
</ul>
<p>对于函数传参，形参都是用地址值达成对实参的修改，但传指针是显式的，而传引用是编译器隐式处理的。<br>指针和引用在内存中的示意图：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081643838.png" alt="image-20221208164349783"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081644997.png"></p>
<p>指针和引用的应用比较：<br>引用比指针使用起来形式上更为美观，使用引用指向的内容时可以之间用引用变量名，而不像指针一样要使用*；定义引用的时候也不用像指针一样使用&amp;取址。<br>引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针)。</p>
<h1 id="常量关键字const"><a href="#常量关键字const" class="headerlink" title="常量关键字const"></a>常量关键字const</h1><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>常量：不可被修改的内存单元<br>    const int MAX_VAL &#x3D; 23；<br>    const string SCHOOL_NAME &#x3D; “Peking University”；</p>
<h2 id="定义常引用"><a href="#定义常引用" class="headerlink" title="定义常引用"></a>定义常引用</h2><p>定义引用时，前面加const关键字，即为“常引用”。不能<strong>通过常引用修改</strong>其引用的变量，但可直接修改变量的值，引用本身也不能改变</p>
<pre><code>int n;
const int &amp; r = n;
r = 5; //error
n = 4; //ok
</code></pre>
<p><strong>const T &amp; 和T &amp; 是不同的数据类型!!!</strong><br>T &amp; 类型的引用或T类型的变量可以用来初始化const T &amp; 类型的引用，const T 类型的常变量和const T &amp; 类型的引用则不能用来初始化T &amp;类型的引用，除非进行强制类型转换<br>一句话，常指针和常引用不能出现在“&#x3D;”左边</p>
<h2 id="定义常指针"><a href="#定义常指针" class="headerlink" title="定义常指针"></a>定义常指针</h2><p>常指针也叫常量指针。但指针不是常量，指向的也不是常量，只是限制了改写方式：不可<strong>通过常量指针修改</strong>其指向变量的值，但可直接修改变量的值，也可以改变常量指针的指向地址值。</p>
<pre><code>int n,m;
const int * p = &amp; n;
* p = 5; //编译出错
n = 4; //ok
p = &amp;m; //ok, 常量指针的指向可以变化
</code></pre>
<p>不能把常量指针赋值给非常量指针，反过来可以</p>
<pre><code>const int * p1; int * p2;
p1 = p2; //ok
p2 = p1; //error
p2 = (int * ) p1; //ok,强制类型转换
</code></pre>
<p>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容</p>
<pre><code>void MyPrintf( const char * p )
&#123;
strcpy( p,&quot;this&quot;); //编译出错
printf(&quot;%s&quot;,p); //ok
&#125;
</code></pre>
<h2 id="定义指针常量"><a href="#定义指针常量" class="headerlink" title="定义指针常量"></a>定义指针常量</h2><p>定义：本质是一个不可修改指向地址的指针 </p>
<pre><code>int* const p;
</code></pre>
<h2 id="定义指向常量的常指针"><a href="#定义指向常量的常指针" class="headerlink" title="定义指向常量的常指针"></a>定义指向常量的常指针</h2><p>定义：指针指向的地址值不可修改，且该地址中的值也不可修改</p>
<pre><code>const int* const p;
</code></pre>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>动态内存分配是分配内存空间中堆（heap）的内存，实际上是程序内手动的内存分配与释放。并非堆栈中局部变量的入栈出栈，由操作系统控制的动态分配。</p>
<h2 id="new分配内存"><a href="#new分配内存" class="headerlink" title="new分配内存"></a>new分配内存</h2><p>分配一个变量:</p>
<pre><code>P = new T;
</code></pre>
<p>T是任意类型名， P是类型为T * 的指针。<br>动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P：</p>
<pre><code>int * pn = new int;
* pn = 5;
</code></pre>
<p>分配一个数组：</p>
<pre><code>P = new T[N];
</code></pre>
<p>T :任意类型名<br>P :类型为T * 的指针<br>N :要分配的数组元素的个数，可以是整型表达式<br>动态分配出一片大小为 sizeof(T)*N字节的内存空间，并且将该内存空间的起始地址赋值给P</p>
<pre><code>int * pn;
int i = 5;
pn = new int[i * 20];
pn[0] = 20;
pn[100] = 30; //编译没问题。运行时导致数组越界
</code></pre>
<h2 id="delete释放内存"><a href="#delete释放内存" class="headerlink" title="delete释放内存"></a>delete释放内存</h2><p>用“new”动态分配的内存空间用完后，一定要用“delete”运算符进行释放，否则操作系统无法再次使用这块内存，造成内存泄露<br>注意：不能对内存空间delete两次！</p>
<pre><code>#delete 指针； //该指针必须指向new出来的空间
int * p = new int;
* p = 5;
delete p;
delete p; //导致异常， 一片空间不能被delete多次
</code></pre>
<p>用“delete”释放动态分配的数组，要加“[]”</p>
<pre><code>#delete [] 指针； //该指针必须指向new出来的数组
int * p = new int[20];
p[0] = 1;
delete [] p;
</code></pre>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>普通函数：编译出来的可执行程序加载到内存后，代码段只有一份函数的指令序列，函数的调用处就用一个类似jump的语句跳转到函数指令序列的入口地址<br>内联函数：函数的每个调用处都存在整个函数指令序列的拷贝<br>简单讲就是增加编译出来的代码占用空间，换取运行时频繁入栈出栈的时间开销<br>使用场景：简单函数体且多次调用可以定义为内联<br>函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</p>
<pre><code>inline int Max(int a,int b)
&#123;
if( a &gt; b) return a;
return b;
&#125;
</code></pre>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="函数重载概念"><a href="#函数重载概念" class="headerlink" title="函数重载概念"></a>函数重载概念</h2><p>重载不是重新载入，更贴切的含义是重复定义，因为重定义是种错误，重载可以理解为编译器能理解的“重定义”，因此能正常加载。<br>C++重载主要有：</p>
<ul>
<li>函数重载</li>
<li>运算符重载</li>
</ul>
<p>C++的类没有重载一说，本节讲函数重载<br>函数重载：一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。</p>
<pre><code>int Max(double f1,double f2) &#123; &#125;
int Max(int n1,int n2) &#123; &#125;
int Max(int n1,int n2,int n3) &#123; &#125;
</code></pre>
<p>Q1.重载有什么用？<br>C语言定义以上几个函数，不能用同名，但是其功能都是相同的，仅参数类型和值不同。如果用MaxDouble(),MaxInt2(),MaxInt3()过于麻烦。<br>因此函数重载使得函数命名变得简单。<br>Q2.编译器怎么知道调用的是哪个？<br>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数，注意重载函数不会把入参自动类型转换，调用二义性会报错。</p>
<pre><code>Max(3.4,2.5); //调用 (1)
Max(2,4); //调用 (2)
Max(1,2,3); //调用 (3)
Max(3,2.4); //error,二义性
</code></pre>
<p>Q3.函数仅返回值类型不同是不是重载？<br>不是，函数重载的区分在于入参。但是有个例外，返回const T和非const T的两个函数是是重载的，其他情况的入参相同，返回类型不同的函数，视为重定义。</p>
<h2 id="缺省参数与可拓展性"><a href="#缺省参数与可拓展性" class="headerlink" title="缺省参数与可拓展性"></a>缺省参数与可拓展性</h2><p>C++函数支持缺省参数（默认参数值）。定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。</p>
<pre><code>void func( int x1, int x2 = 2, int x3 = 3)
&#123; &#125;
func(10 ) ; //等效于 func(10,2,3)
func(10,8) ; //等效于 func(10,8,3)
func(10, , 8) ; //不行,只能最右边的连续若干个参数缺省
</code></pre>
<p>函数参数可缺省的目的在于提高程序的可扩充性。<br>如果某个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，那么为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。<br>在C语言中，如果函数新增一个入参，所有调用该函数的地方都要传入该入参值；C++支持缺省参数，只需要改函数定义即可，调用处不需要动。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：模板、泛型与STL</title>
    <url>/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++除了支持面向对象，也支持函数的扩展和重用。继承类和多态充分支持了扩展，即基类进行概括抽象的设计，派生类实现具体的设计。那么重用呢，如何写一个函数，能在多种情况不加修改的套用？<br>考虑以下问题：</p>
<pre><code>交换两个整型变量的值的Swap函数：
void Swap(int &amp; x,int &amp; y)
&#123;
    int tmp = x;
    x = y;
    y = tmp;
&#125;
交换两个double型变量的值的Swap函数:
void Swap(double &amp; x,double &amp; y)
&#123;
    double tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>这两个函数除了入参类型不同，函数名，参数个数，返回类型都相同。函数体的处理流程也完全一样。能否只写一个Swap，就能交换各种类型的变量？<br>模板（template）将解决这种问题。</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="函数模板的概念"><a href="#函数模板的概念" class="headerlink" title="函数模板的概念"></a>函数模板的概念</h2><p>用函数模板，设计仅数据类型不同的一组函数的通用模板：</p>
<pre><code>template &lt;class 类型参数1，class 类型参数2,……&gt;
返回值类型 模板名 (形参表)
&#123;
    函数体
&#125;;

template &lt;class T&gt; //在函数前声明模板，参数类型（class）是T
void Swap(T &amp; x,T &amp; y)
&#123;
    T tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>在普通函数前，先用template&lt; class T &gt;声明参数类型T，就可以在函数体使用T，就像使用普通变量一样。在运行时，T传入的类型不同，函数处理的数据类型也不同。<br>函数模板是如何实现的？它是一种函数吗？</p>
<pre><code>int main()
&#123;
    int n = 1,m = 2;
    Swap(n,m); //编译器自动生成 void Swap(int &amp; ,int &amp; )函数
    double f = 1.2,g = 2.3;
    Swap(f,g); //编译器自动生成 void Swap(double &amp; ,double &amp; )函数
    return 0;
&#125;
</code></pre>
<p>函数模板只是个模子，编译器通过模板和具体参数类型产生不同的函数。编译器会进行两次编译，第一次检测模板代码，第二次检测加参数后的具体函数代码。<br>在调用以上函数模板时，实际会生成两个具体函数：</p>
<pre><code>void Swap(int &amp; x,int &amp; y)
&#123;
    int tmp = x;
    x = y;
    y = tmp;
&#125;
void Swap(double &amp; x,double &amp; y)
&#123;
    double tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>函数模板，可以理解为一种函数的宏，编译期在宏被调用的地方，全部替换成宏所对应的具体值。<br>函数模板和运行时函数，也类似于类和对象的关系，类只是类型，对象是给类分配了内存的实例。函数模板只是通用的类型，函数实例是函数模板的实例化对象。</p>
<h2 id="函数模板的特性"><a href="#函数模板的特性" class="headerlink" title="函数模板的特性"></a>函数模板的特性</h2><p>函数模板中可以有不止一个类型参数</p>
<pre><code>template &lt;class T1, class T2&gt;
T2 print(T1 arg1, T2 arg2)
&#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
    return arg2;
&#125;
</code></pre>
<p>不通过参数也能实例化函数模板</p>
<pre><code>template &lt;class T&gt;
T Inc(T n)
&#123;
    return 1 + n;
&#125;
int main()
&#123;
    cout &lt;&lt; Inc&lt;double&gt;(4)/2; //显式实例化模板，输出 2.5
    return 0;
&#125;
</code></pre>
<h2 id="函数模板与重载"><a href="#函数模板与重载" class="headerlink" title="函数模板与重载"></a>函数模板与重载</h2><p>函数模板和函数重载，在写法上很接近，都是一组参数不同的同名函数。它们有什么联系和区别？</p>
<ul>
<li>函数重载，关键在参数个数</li>
<li>函数模板，关键在参数类型</li>
</ul>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<pre><code>template&lt;class T1, class T2&gt;
void print(T1 arg1, T2 arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
template&lt;class T&gt;
void print(T arg1, T arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
template&lt;class T,class T2&gt;
void print(T arg1, T arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
</code></pre>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一条函数调用语句:</p>
<ol>
<li><p>先找参数完全匹配的普通函数(非由模板实例化而得的函数)</p>
</li>
<li><p>再找参数完全匹配的模板函数。</p>
</li>
<li><p>再找实参数经过自动类型转换后能够匹配的普通函数。</p>
</li>
</ol>
<ol start="4">
<li><p>上面的都找不到，则报错<br>如果有函数重载，在第（1）步就找到，如果没有，才找（2）的函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"> T Max( T a, T b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> template &lt;class T,class T2&gt;</span><br><span class="line"> T Max( T a, T2 b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax2&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> double Max(double a, double b)&#123;</span><br><span class="line">     cout &lt;&lt; &quot;MyMax&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main() &#123;</span><br><span class="line">     int i=4, j=5;</span><br><span class="line">     Max( 1.2,3.4); // 输出MyMax</span><br><span class="line">     Max(i, j); //输出TemplateMax</span><br><span class="line">     Max( 1.2, 3); //输出TemplateMax2</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意上文的步骤（2）（3）是分开的，匹配模板函数时，是不进行类型自动转换的，不匹配就是不匹配。输入参数有二义性时。编译器不会为开发者做决定</p>
<pre><code>template&lt;class T&gt;
T myFunction( T arg1, T arg2)
&#123; cout&lt;&lt;arg1&lt;&lt;&quot; &quot;&lt;&lt;arg2&lt;&lt;&quot;\n&quot;; return arg1;&#125;
……
myFunction( 5, 7); //ok： replace T with int
myFunction( 5.8, 8.4); //ok： replace T with double
myFunction( 5, 8.4); //error， no matching function for call to &#39;myFunction(int, double)&#39;
</code></pre>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="类模板的概念"><a href="#类模板的概念" class="headerlink" title="类模板的概念"></a>类模板的概念</h2><p>类也能使用模板，来生成不同成员类型的类<br>类模板：在定义类的时候，加上一个&#x2F;多个类型参数。在使用类模板时，指定类型参数应该如何替换成具体类型，编译器据此生成相应的模板类</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
class 类模板名
&#123;
    成员函数和成员变量
&#125;;
</code></pre>
<p>类模板的成员函数的定义写法：</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名（ 参数表）
&#123;
    ……
&#125;
</code></pre>
<p>用类模板实例化对象的写法：</p>
<pre><code>类模板名 &lt;真实类型参数表&gt; 对象名(构造函数实参表);
</code></pre>
<p>一个例子：map类型中的pair类的实现：</p>
<pre><code>template &lt;class T1,class T2&gt;    //pair是类模板
class Pair
&#123;
public:
    T1 key; //关键字
    T2 value; //值
    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;; //构造函数
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const; //运算符重载函数
&#125;;

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
//Pair的运算符重载函数的定义
&#123;
    return key &lt; p.key;
&#125;

 int main()
&#123;
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,19); //实例化出一个类 Pair&lt;string,int&gt;
    cout &lt;&lt; student.key &lt;&lt; &quot; &quot; &lt;&lt; student.value;
    return 0;
&#125;
</code></pre>
<p>输出：Tom 19<br>编译器由类模板生成类的过程叫类模板的实例化。 由类模板实例化得到的类， 叫模板类<br>同一个类模板的两个模板类是不兼容的，即两个不同的类</p>
<pre><code>Pair&lt;string,int&gt; * p;
Pair&lt;string,double&gt; a;
p = &amp; a; //错误，不是同类也不是继承类，不能赋值
</code></pre>
<p>函数模版可以作为类模板成员</p>
<pre><code>template &lt;class T&gt;
class A
&#123;
public:
    template&lt;class T2&gt;
    void Func( T2 t) &#123; cout &lt;&lt; t; &#125; //成员函数模板
&#125;;
int main()
&#123;
    A&lt;int&gt; a;
    a.Func(&#39;K&#39;); //成员函数模板 Func被实例化
    a.Func(&quot;hello&quot;); //成员函数模板 Func再次被实例化
    return 0;
&#125; //输出： KHello
</code></pre>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数：</p>
<pre><code>template &lt;class T, int size&gt;
class CArray&#123;
    T array[size];
    public:
    void Print( )
    &#123;
        for( int i = 0;i &lt; size; ++i)
        cout &lt;&lt; array[i] &lt;&lt; endl;
    &#125;
&#125;;

CArray&lt;double,40&gt; a2;
CArray&lt;int,50&gt; a3;
</code></pre>
<h2 id="类模板的派生"><a href="#类模板的派生" class="headerlink" title="类模板的派生"></a>类模板的派生</h2><p>类模板也支持类的派生：<br>• 类模板从类模板派生<br>• 类模板从模板类派生<br>• 类模板从普通类派生<br>• 普通类从模板类派生</p>
<p>(1)类模板从类模板派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A &#123;
    T1 v1; T2 v2;
&#125;;

template &lt;class T1,class T2&gt;
class B:public A&lt;T2,T1&gt; &#123;
    T1 v3; T2 v4;
&#125;;

template &lt;class T&gt;
class C:public B&lt;T,T&gt; &#123;
    T v5;
&#125;;

int main() &#123;
    B&lt;int,double&gt; obj1;
    C&lt;int&gt; obj2;
    return 0;
&#125;
</code></pre>
<p>(2)类模板从模板类派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A &#123;
    T1 v1; T2 v2;
&#125;;

template &lt;class T&gt;
class B:public A&lt;int,double&gt; &#123;
    T v;
&#125;;

int main() &#123;
    B&lt;char&gt; obj1; //自动生成两个模板类：A&lt;int,double&gt; 和 B&lt;char&gt;
    return 0;
&#125;
</code></pre>
<p>(3)类模板从普通类派生</p>
<pre><code>class A &#123;
    int v1;
&#125;;

template &lt;class T&gt;
class B:public A &#123; //所有从B实例化得到的类， 都以A为基类
    T v;
&#125;;

int main() &#123;
    B&lt;char&gt; obj1;
    return 0;
&#125;
</code></pre>
<p>(4)普通类从模板类派生</p>
<pre><code>template &lt;class T&gt;
class A &#123;
    T v1;
    int n;
&#125;;

class B:public A&lt;int&gt; &#123;
    double v;
&#125;;
int main() &#123;
    B obj1;
    return 0;
&#125;
</code></pre>
<h2 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h2><p>• 函数、类、类的成员函数作为类模板的友元<br>• 函数模板作为类模板的友元<br>• 函数模板作为类的友元<br>• 类模板作为类模板的友元</p>
<p>(1)函数、类、类的成员函数作为类模板的友元</p>
<pre><code>void Func1() &#123; &#125;
class A &#123; &#125;;
class B
&#123;
    public:
    void Func() &#123; &#125;
&#125;;

template &lt;class T&gt;
class Tmpl
&#123;
    friend void Func1();
    friend class A;
    friend void B::Func();
&#125;; //任何从Tmp1实例化来的类， 都有以上三个友元
</code></pre>
<p>(2)函数模板作为类模板的友元</p>
<pre><code>template &lt;class T1,class T2&gt;
class Pair
&#123;
private:
    T1 key; //关键字
    T2 value; //值
public:
    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;;
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const;
    template &lt;class T3,class T4&gt;
    friend ostream &amp; operator&lt;&lt; ( ostream &amp; o,
    const Pair&lt;T3,T4&gt; &amp; p);
&#125;;

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
&#123; //&quot;小&quot;的意思就是关键字小
    return key &lt; p.key;
&#125;
template &lt;class T1,class T2&gt;
ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)
&#123;
    o &lt;&lt; &quot;(&quot; &lt;&lt; p.key &lt;&lt; &quot;,&quot; &lt;&lt; p.value &lt;&lt; &quot;)&quot; ;
    return o;
&#125;

int main()
&#123;
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,29);
    Pair&lt;int,double&gt; obj(12,3.14);
    cout &lt;&lt; student &lt;&lt; &quot; &quot; &lt;&lt; obj;
    return 0;
&#125;

输出：
(Tom,29) (12,3.14)
</code></pre>
<p>任意从 <code>template &lt;class T1,class T2&gt; ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)</code>生成的函数，都是任意Pair摸板类的友元</p>
<p>(3)函数模板作为类的友元</p>
<pre><code>class A
&#123;
    int v;
    public:
    A(int n):v(n) &#123; &#125;
    template &lt;class T&gt;
    friend void Print(const T &amp; p);
&#125;;
template &lt;class T&gt;
void Print(const T &amp; p)
&#123;
    cout &lt;&lt; p.v;
&#125;

int main() &#123;
    A a(4);
    Print(a);
    return 0;
&#125;

输出：
4
</code></pre>
<p>所有从 <code>template &lt;class T&gt; void Print(const T &amp; p)</code><br>生成的函数，都成为 A 的友元</p>
<p>(4)类模板作为类模板的友元</p>
<pre><code>template &lt;class T&gt;
class B &#123;
    T v;
    public:
    B(T n):v(n) &#123; &#125;
    template &lt;class T2&gt;
    friend class A;
&#125;;

template &lt;class T&gt;
class A &#123;
public:
    void Func( ) &#123;
        B&lt;int&gt; o(10);
        cout &lt;&lt; o.v &lt;&lt; endl;
    &#125;
&#125;;

int main()
&#123;
    A&lt; double &gt; a;
    a.Func ();
    return 0;
&#125;

输出：
10
</code></pre>
<p>A&lt; double&gt;类，成了B<int>类的友元。任何从A模版实例化出来的类，都是任何B实例化出来的类的友元</p>
<h2 id="类模板与静态成员"><a href="#类模板与静态成员" class="headerlink" title="类模板与静态成员"></a>类模板与静态成员</h2><p>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员</p>
<pre><code>template &lt;class T&gt;
class A
&#123;
private:
    static int count;
    public:
    A() &#123; count ++; &#125;
    ~A() &#123; count -- ; &#125;;
    A( A &amp; ) &#123; count ++ ; &#125;
    static void PrintCount() &#123; cout &lt;&lt; count &lt;&lt; endl; &#125;
&#125;;

template&lt;&gt; int A&lt;int&gt;::count = 0;
template&lt;&gt; int A&lt;double&gt;::count = 0;
int main()
&#123;
    A&lt;int&gt; ia;
    A&lt;double&gt; da;
    ia.PrintCount();
    da.PrintCount();
    return 0;
&#125;

输出：
1 1
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：类和对象</title>
    <url>/2020/03/18/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++，加的到底是什么？<br>除了基础语法的补充和优化，C++另外几个核心特点是：</p>
<ul>
<li><p>面向对象设计的支持：</p>
<p> 类和对象对变量和函数的封装<br> 类和类之间的继承<br> 继承关系的类之间的函数调用的多态</p>
</li>
<li><p>数据结构和算法的支持<br> STL和各种常用数据类型</p>
</li>
<li><p>高可复用、可拓展的支持<br> 类模板，函数模板<br> 函数、运算符的重载</p>
</li>
</ul>
<p>本文内容：</p>
<ul>
<li>面向对象设计的概念</li>
<li>类和对象的概念及使用</li>
<li>类的几种构造函数</li>
<li>类的析构函数</li>
<li>类对象的this指针</li>
<li>类的嵌套：封闭类</li>
<li>成员的属性：友元和常量成员</li>
</ul>
<h1 id="面向对象设计的概念"><a href="#面向对象设计的概念" class="headerlink" title="面向对象设计的概念"></a>面向对象设计的概念</h1><h2 id="面向过程设计的不足"><a href="#面向过程设计的不足" class="headerlink" title="面向过程设计的不足"></a>面向过程设计的不足</h2><p>程序 &#x3D; 数据结构 + 算法<br>程序由全局变量以及众多相互调用的函数组成，算法以函数的形式实现，用于对数据结构进行操作。<br>结构化程序设计风格中，变量和函数的关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081646566.png" alt="image-20221208164648489"><br>其缺陷在于：</p>
<ul>
<li>结构化程序设计中，函数和其所操作的数据结构，没有直观的联系</li>
<li>随着程序规模的增加，程序逐渐难以理解:<br> 某个数据结构到底有哪些函数可以对它进行操作?<br> 某个函数到底是用来操作哪些数据结构的?<br> 任何两个函数之间存在怎样的调用关系?</li>
<li>结构化程序设计难以维护:<br>由于没有“封装”和“隐藏”的概念，要访问某个数据结构中的某个变量，就可以直接访问，那么当该变量的定义有改动的时候，就要把所有访问该变量的语句找出来修改，不利于程序的维护、扩充。</li>
<li>结构化程序设计难以查错:<br>当某个数据结构的值不正确时，难以找出到底是那个函数导致的。</li>
<li>结构化程序设计难以重用：<br>在编写某个程序时，发现其需要的某项功能，在现有的某个程序里已经有了相同或类似的实现，那么自然希望能够将那部分代码抽取出来，在新程序中使用。在结构化程序设计中，随着程序规模的增大，由于程序大量函数、变量之间的关系错综复杂，要抽取这部分代码，会变得十分困难。<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2>面向对象的程序设计方法，能够较好解决上述问题<br>面向对象的程序 &#x3D; 类 + 类 + …+ 类<br>设计程序的过程，就是设计类（class）的过程<br>面向对象的程序设计方法:</li>
<li>将某类客观事物共同特点（<strong>属性</strong>）归纳出来，形成一个数据结构（可以用多个变量描述事物的属性）</li>
<li>将这类事物所能进行的<strong>行为</strong>也归纳出来，形成一个个函数，这些函数可以用来操作数据结构(这一步叫“ <strong>抽象</strong>”）</li>
<li>然后，通过某种语法形式，将数据结构和操作该数据结构的函数“捆绑”在一起，形成一个“ 类”，从而使得数据结构和操作该数据结构的算法呈现出显而易见的紧密关系，这就是“<strong>封装</strong>”</li>
<li>类与类直接又形成<strong>继承、多态</strong>等关系</li>
<li>面向对象的程序设计具有“抽象”，“封装”“继承”“多态”四个基本特点。</li>
</ul>
<p>面向对象设计风格中，变量和函数的关系;<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081647726.png" alt="image-20221208164703654"></p>
<h2 id="语言和风格的无关性"><a href="#语言和风格的无关性" class="headerlink" title="语言和风格的无关性"></a>语言和风格的无关性</h2><p>注意面向过程、面向对象以及其他的风格（如函数式编程等），只是编程风格，其本质都是组织数据结构（事物属性）和算法（对事物的操作）。<br>C++有原生的类的概念，更方便写出面向对象风格的程序<br>Q. C语言没有类，能不能写出面向对象？<br>可以，C的结构体就是对数据的封装，配合函数指针，也能包含函数成员。利用带函数指针的结构体能实现属性和方法的封装，在Linux内核和设备驱动程序中充满了这种面向对象设计风格。事实上，C++的class在编译器处理后就是类似于C的结构体。<br>Q. 什么时候应该面向对象？<br>面向对象对于人的抽象概括的能力要求较高，需要花较多精力在top-down的顶层设计中，通常用于大型的长期维护的程序设计。<br>面向对象的优势在于数据结构组织化，程序时间和空间的开销可能不如面向过程。例如一个对象里的各个数据的生命周期都是捆绑分配和释放的，而面向过程可以更精细管理。在极端资源紧缺的情况，如部分嵌入式开发，面向过程不论代码设计速度和性能都比面向对象好。</p>
<h1 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a>类和对象的概念</h1><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>设计一个程序，接受输入矩形的长和宽，输出面积和周长<br>如何用类来封装？</p>
<ul>
<li>矩形的属性就是长和宽。因此需要两个变量，分别代表长和宽</li>
<li>矩形的操作方法可以有设置长和宽，算面积，算周长。每个操作各用一个函数来实现，且函数都需要用到长和宽这两个属性</li>
<li>将以上属性和方法组合就能形成一个“矩形类”。长、宽变量成为该“矩形类”的“成员变量”，三个函数成为该类的“成员函数”。成员变量和成员函数统称为类的成员。“类”看上去就像“带函数的结构”</li>
</ul>
<p>类的声明：</p>
<pre><code>class CRectangle
&#123;
    public:
        int w, h;
        int Area() &#123;
        return w * h;
    &#125;
    int Perimeter()&#123;
        return 2 * ( w + h);
    &#125;
    void Init( int w_,int h_ ) &#123;
        w = w_; h = h_;
    &#125;
&#125;; //必须有分号
</code></pre>
<p>类的实例化：</p>
<pre><code>int main( )
&#123;
    int w,h;
    CRectangle r; //r是一个对象
    cin &gt;&gt; w &gt;&gt; h;
    r.Init( w,h);
    cout &lt;&lt; r.Area() &lt;&lt; endl &lt;&lt;
    r.Perimeter();
    return 0;
&#125;
</code></pre>
<p>通过类，可以定义变量。类定义出来的变量，也称为类的实例，就是“<strong>对象</strong>”，对象的本质是在内存中分配了一个存放类这个结构的空间。<br>C++中，类的名字就是用户自定义的类型的名字。可以像使用基本类型那样来使用。 CRectangle就是一种用户自定义的类型。</p>
<h2 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h2><ul>
<li><p>和结构变量一样，对象所占用的内存空间的大小，等于所有成员变量的大小之和（考虑内存对齐可能更大）。对于上面的CRectangle类，sizeof(CRectangle)<br>&#x3D; 8</p>
</li>
<li><p>每个对象各有自己的存储空间。一个对象的某个成员变量被改变了，不会影响到另一个对象</p>
</li>
<li><p>和结构变量一样，对象之间可以用 “&#x3D;”进行赋值，但是不能用 “&#x3D;&#x3D;”“!&#x3D;”“&gt;”“&lt;”“&gt;&#x3D;”“&lt;&#x3D;”进行比较，除非这些运算符经过了“重载”。</p>
</li>
</ul>
<p>Q.类分配内存产生对象后，成员变量占用空间，成员函数占不占用空间?<br>普通成员函数不在对象生成时分配函数空间，因为函数是静态绑定的，即函数体指令只占用代码段的一处空间，对象调用该函数之间跳到该空间入口地址，在对象分配时不会在堆或栈再开辟空间存放函数体。<br>但是当类中定义了虚函数，分配对象时要分配4字节（多个虚函数也是4个字节）的指针指向虚函数表。函数跳转地址依赖于运行时才产生的对象里的虚函数表，称为动态绑定，对象调用虚函数时不知道准确的跳转地址，只跳转到虚函数表查找跳转地址，再根据查找结果跳转。</p>
<h2 id="对象访问其成员"><a href="#对象访问其成员" class="headerlink" title="对象访问其成员"></a>对象访问其成员</h2><p>类似于C结构体实例访问其成员的方法，用实例.成员，实例指针-&gt;成员，除此之外C++特有的通过引用访问：实例引用.成员<br>用法1：对象名.成员名</p>
<pre><code>CRectangle r1,r2;
r1.w = 5;
r2.Init(5,4);
</code></pre>
<p>Init函数作用在 r2 上，即Init函数执行期间访问的w 和 h是属于r2 这个对象的, 执行r2.Init 不会影响到r1<br>用法2. 指针-&gt;成员名</p>
<pre><code>CRectangle r1,r2;
CRectangle * p1 = &amp; r1;
CRectangle * p2 = &amp; r2;
p1-&gt;w = 5;
p2-&gt;Init(5,4); //Init作用在p2指向的对象上
</code></pre>
<p>用法3：引用名.成员名</p>
<pre><code>CRectangle r2;
CRectangle &amp; rr = r2;
rr.w = 5;
rr.Init(5,4); //rr的值变了， r2的值也变
</code></pre>
<h1 id="类成员的访问方式"><a href="#类成员的访问方式" class="headerlink" title="类成员的访问方式"></a>类成员的访问方式</h1><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><p>Q. C++将数据和函数封装成类的成员，那么类内成员、内间成员的访问权限如何控制？<br>用下列访问范围关键字来说明类成员可被访问的范围：</p>
<ul>
<li>private: 私有成员，只能在成员函数内访问</li>
<li>public : 公有成员，可以在任何地方访问</li>
<li>protected: 保护成员，用于继承关系的类的成员访问控制</li>
</ul>
<p>定义一个带访问控制的类：</p>
<pre><code>class className &#123;
    private:
    私有属性和函数
    public:
    公有属性和函数
    protected:
    保护属性和函数
&#125;;
</code></pre>
<p>如过某个成员前面没有上述关键字，则缺省地被认为是private私有成员:</p>
<pre><code>class Man &#123;
    int nAge;       //私有成员
    char szName[20]; // 私有成员
public:
    void SetName(char * szName)&#123;
    strcpy( Man::szName,szName);
    &#125;
&#125;;
</code></pre>
<p>在类的成员函数内部，能够访问：</p>
<ul>
<li>当前对象的全部属性、 函数；</li>
<li>同类其它对象的全部属性、函数。</li>
</ul>
<p>在类的成员函数以外的地方，只能够访问该类对象的公有成员<br>注意：<br>通过对象的成员函数，可以访问同类其他对象的任意成员（即使是private）。private、public、protected真正的作用是限制成员变量的直接访问，而通过成员函数来访问成员变量是不受影响的。</p>
<h2 id="访问控制与隐藏"><a href="#访问控制与隐藏" class="headerlink" title="访问控制与隐藏"></a>访问控制与隐藏</h2><p>成员访问控制可以定义类的成员变量能否被任意访问、或通过成员函数访问、能否被继承的子类访问等。这种机制称为对成员变量的<strong>隐藏</strong><br>隐藏的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则所有直接访问成员变量的语句都需要修改<br>一个类成员变量隐藏的例子：</p>
<pre><code> //类定义
    class CEmployee &#123;
    private:
        char szName[30]; //名字
    public :
        int salary; //工资
        void setName(char * name);
        void getName(char * name);
        void averageSalary(CEmployee e1,CEmployee e2);
    &#125;;
    
    //成员函数定义
    void CEmployee::setName( char * name) &#123;
        strcpy( szName, name); //ok
    &#125;
    void CEmployee::getName( char * name) &#123;
        strcpy( name,szName); //ok
    &#125;
    void CEmployee::averageSalary(CEmployee e1,CEmployee e2)&#123;
        cout &lt;&lt; e1.szName; //ok，访问同类其他对象私有成员
        salary = (e1.salary + e2.salary )/2;
    &#125;
    
    //使用类和对象
    int main()
    &#123;
        CEmployee e;
        strcpy(e.szName,&quot;Tom1234567889&quot;); //编译错，不能访问私有成员
        e.setName( &quot;Tom&quot;);  // ok
        e.salary = 5000;    //ok
        return 0;
    &#125;
</code></pre>
<p>如果将上面的程序移植到内存空间紧张的设备上，希望将szName改为char szName[5]，若szName不是私有，就要找出所有类似strcpy(e.szName,”Tom1234567889”);这样的语句进行修改，以防止数组越界。如果将szName变为私有，那么程序中就不可能出现（除非在类的内部）strcpy(e.szName,”Tom1234567889”);这样的语句，所有对szName的访问都是通过成员函数来进行，比如：e.setName( “Tom12345678909887”);如果szName改短了，上面的语句也不需要找出来修改，只要改setName成员函数，在里面确保不越界就可以了<br>除了使用类和隐藏机制，C++兼容C的struct结构体，也称为类。和用”class”的唯一区别是未说明是公有还是私有的成员，struct类的所有成员都是公有的。</p>
<pre><code>struct CEmployee &#123;
    char szName[30]; //公有!!
    public :
    int salary; //工资
    void setName(char * name);
    void getName(char * name);
    void averageSalary(CEmployee
    e1,CEmployee e2);
&#125;;
</code></pre>
<h2 id="类成员函数的重载和缺省参数"><a href="#类成员函数的重载和缺省参数" class="headerlink" title="类成员函数的重载和缺省参数"></a>类成员函数的重载和缺省参数</h2><p>同普通函数一样，类封装后的成员函数可以重载，可以有缺省参数</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x=0 , int y = 0 );
    void valueX( int val ) &#123; x = val ;&#125;
    int valueX() &#123; return x; &#125;
&#125;;

void Location::init( int X, int Y)
&#123;
    x = X;
    y = Y;
&#125;

int main() &#123;
    Location A,B;
    A.init(5);  //使用init缺省y=0
    A.valueX(5);    //重载，使用valueX(int)
    cout &lt;&lt; A.valueX();     //重载，使用valueX()
    return 0;
&#125;
</code></pre>
<p>输出：5<br>注意：重载和缺省的函数在调用时可能冲突，存在二义性：</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x =0, int y = 0 );
    void valueX( int val = 0) &#123; x = val; &#125;
    int valueX() &#123; return x; &#125;
&#125;;

Location A;
A.valueX(); //错误，编译器无法判断调用哪个valueX
</code></pre>
<h1 id="类对象的创建与释放"><a href="#类对象的创建与释放" class="headerlink" title="类对象的创建与释放"></a>类对象的创建与释放</h1><h2 id="普通构造函数"><a href="#普通构造函数" class="headerlink" title="普通构造函数"></a>普通构造函数</h2><p>定义一个类只是定义一种数据结构类型，类实例化后在内存中才存在改类的对象。类实例化成对象可以在函数的栈中，或者动态分配在堆中</p>
<pre><code>ClassA a;   //该语句在函数内（如main）时，在main的堆栈中分配内存
ClassA *pa = new ClassA;    //在堆中分配，需要delete手动释放
</code></pre>
<p>那么问题来了，分配的内存里的内容是什么？<br>不知道是什么值，只知道这块内存是被其他进程释放过，当前程序可以读写，释放时不会把值清零。<br>在C语言创建一个结构体变量，可以顺便初始化为全0</p>
<pre><code>StructA a = &#123;0&#125;; //单层结构体
StructB b = &#123;&#123;0&#125;&#125;； //嵌套的结构体
</code></pre>
<p>C++也支持创建类时自动初始化，采用与类同名的成员函数的方法。这就是<strong>构造函数（constructor）</strong><br>构造函数：</p>
<ul>
<li>成员函数的一种，名字与类名相同，可以有参数，不能有返回值(void也不行)</li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作</li>
<li>如果定义了构造函数，则编译器不生成默认的无参数构造函数</li>
<li>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</li>
<li>一个类可以有多个构造函数，即构造函数也可以重载</li>
</ul>
<p>注意：构造函数不负责对象的内存分配，其关键作用是对象成员的值初始化。真正做对象分配的语句通常是new，new做两件事：给类分配内存形成对象，调用对象的构造函数。考虑一下也可知道，连对象都没有的情况，怎么能调用对象的构造函数分配内存呢？注意构造函数不给自身对象分配内存，但是构造函数可以做分配内存操作，比如对指针成员指向的空间分配内存。<br>使用默认构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i);
&#125;; //编译器自动生成默认构造函数
Complex c1; //默认构造函数被调用
Complex * pc = new Complex; //默认构造函数被调用
</code></pre>
<p>使用自定义的带参构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    Complex( double r, double i = 0);
&#125;;
    Complex::Complex( double r, double i) &#123;
    real = r; imag = i;
&#125;

Complex c1; // error, 缺少构造函数的参数
Complex * pc = new Complex; // error, 没有参数
Complex c1(2); // OK
Complex c1(2,4), c2(3,5);
Complex * pc = new Complex(3,4);
</code></pre>
<p>使用重载的构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i );
    Complex(double r, double i );
    Complex (double r );
    Complex (Complex c1, Complex c2);
&#125;;

Complex::Complex(double r, double i)
&#123;
    real = r; imag = i;
&#125;
Complex::Complex(double r)
&#123;
    real = r; imag = 0;
&#125;
Complex::Complex (Complex c1, Complex c2);
&#123;
    real = c1.real+c2.real;
    imag = c1.imag+c2.imag;
&#125;

Complex c1(3) , c2 (1,0), c3(c1,c2);
// c1 = &#123;3, 0&#125;, c2 = &#123;1, 0&#125;, c3 = &#123;4, 0&#125;;
</code></pre>
<p>构造函数应该是public的， private构造函数不能直接用来初始化对象</p>
<pre><code>class CSample&#123;
private:
    CSample() &#123;&#125;
&#125;;

int main()&#123;
    CSample Obj; //err. 唯一构造函数是private
    return 0;
&#125;
</code></pre>
<p>对于多个对象的实例化，可以用对象数组,构造函数的调用次数&#x3D;对象个数，重载哪一个构造函数取决于每个对象的初始化方式。</p>
<pre><code>class CSample &#123;
    int x;
    public:
    CSample() &#123;
        cout &lt;&lt; &quot;Constructor 1 Called&quot; &lt;&lt; endl;
    &#125;
    CSample(int n) &#123;
        x = n;
        cout &lt;&lt; &quot;Constructor 2 Called&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main()&#123;
    CSample array1[2];  //两次默认构造函数
    cout &lt;&lt; &quot;step1&quot;&lt;&lt;endl;
    CSample array2[2] = &#123;4,5&#125;;  //两次带参构造函数
    cout &lt;&lt; &quot;step2&quot;&lt;&lt;endl;
    CSample array3[2] = &#123;3&#125;;    //第一个带参构造，第二个默认构造
    cout &lt;&lt; &quot;step3&quot;&lt;&lt;endl;
    CSample * array4 = new CSample[2];  //两次默认构造
    delete []array4;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Constructor 1 Called
Constructor 1 Called
step1
Constructor 2 Called
Constructor 2 Called
step2
Constructor 2 Called
Constructor 1 Called
step3
Constructor 1 Called
Constructor 1 Called
</code></pre>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>定义：拷贝构造函数(copy constructor)是构造函数的一种，特点是：</p>
<ul>
<li>只有一个参数:对同类对象的引用</li>
<li>入参必须是对象的引用，形如 X::X( X&amp; ) 或 X::X(const X &amp;), 后者以常量对象作为参数</li>
<li>如果用户没有定义拷贝构造函数，编译器生成默认的拷贝构造函数，且它完成复制对象的功能。</li>
</ul>
<p>拷贝构造函数也称为复制构造函数<br>调用形式如下。默认（普通）构造函数和默认拷贝构造函数都是编译生成，且并存的</p>
<pre><code>class Complex &#123;
private :
    double real,imag;
&#125;;
Complex c1; //调用缺省无参构造函数
Complex c2(c1);//调用缺省的复制构造函数,将 c2 初始化成和c1一样
</code></pre>
<p>如果定义的自己的拷贝构造函数，则默认的拷贝构造函数不会生成<br>也就是说，自定义的带参拷贝构造函数和编译器生成的默认拷贝构造函数，不存在重载关系；而一个类有多个自定义的带参拷贝构造函数是允许的，可以重载。这一特点对于普通构造函数一样。</p>
<pre><code>class Complex &#123;
public :
    double real,imag;
    Complex()&#123; &#125;
    Complex( const Complex &amp; c ) &#123;
        real = c.real;
        imag = c.imag;
        cout &lt;&lt; “Copy Constructor called”;
    &#125;
&#125;;
Complex c1;
Complex c2(c1); //调用自己定义的复制构造函数，输出 Copy Constructor called
</code></pre>
<p>注意：拷贝构造函数传入的是同类的引用，而不是同类的对象<br>不允许有形如 X::X( X)的构造函数。因为成员函数入参由实参复制到形参实际会调用拷贝构造函数，拷贝构造函数作为成员函数也是一样，因此会有循环定义，即拷贝构造函数的执行需要调用拷贝构造函数的无限循环，用引用作为入参可以解决此问题。这点类似于C结构体允许有结构体指针成员，指向该结构体类型的实例，而不允许结构体有自身结构体的自接实例，这样会照成分配内存空间上的无限循环。</p>
<pre><code>class CSample &#123;
    CSample( CSample c ) &#123;&#125; //错，不允许这样的构造函数
&#125;
</code></pre>
<h3 id="拷贝构造函数的调用"><a href="#拷贝构造函数的调用" class="headerlink" title="拷贝构造函数的调用"></a>拷贝构造函数的调用</h3><p>以下三种情况会调用类对象的拷贝构造函数<br>1)用一个对象去初始化同类的另一个对象：</p>
<pre><code>Complex c2(c1);
Complex c2 = c1; //初始化语句，非赋值语句
</code></pre>
<p>2)类的对象作为函数入参：如果某函数有参数是类A的对象，那么该函数被调用时，类A的拷贝构造函数将被调用：</p>
<pre><code>class A
&#123;
public:
    A() &#123; &#125;;
    A( A &amp; a) &#123;
        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;
    &#125;
&#125;;

void Func(A a1)&#123; &#125;;
int main()&#123;
    A a2;
    Func(a2);  //传参是类A的对象
    return 0;
&#125;
</code></pre>
<p>输出: Copy constructor called<br>3) 类的对象作为函数返回值：如果函数的返回值是类A的对象，函数返回时，A的拷贝构造函数被调用：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int v;</span><br><span class="line">    A(int n) &#123; v = n; &#125;;</span><br><span class="line">    A( const A &amp; a) &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A Func() &#123;</span><br><span class="line">    A a(4);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; Func().v &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>输出：</p>
<pre><code>Copy constructor called
4
</code></pre>
<p>小结：对象作为入参和返回值会调用拷贝构造函数，对象初始化新对象也会调用。</p>
<h3 id="禁用拷贝构造函数"><a href="#禁用拷贝构造函数" class="headerlink" title="禁用拷贝构造函数"></a>禁用拷贝构造函数</h3><p>Q. 调用拷贝构造函数会形成对象的复制品，开销较大，如何禁用拷贝构造函数？<br>使用对象的引用，不自接把对象作为函数的入参出参。<br>Q.对象的引用会导致新问题：函数内修改了引用怎么办，原对象也会改<br>使用const引用，对象实参就不存在被函数修改的可能<br>使用对象的常引用，应用于对象作为函数入参出参，又不希望调用拷贝构造函数的情况</p>
<pre><code>void fun(const CMyclass &amp; obj) &#123;
//函数中任何试图改变 obj值的语句都将是变成非法
&#125;
</code></pre>
<h3 id="对象的赋值和复制"><a href="#对象的赋值和复制" class="headerlink" title="对象的赋值和复制"></a>对象的赋值和复制</h3><p>注意区分对象的赋值和复制：</p>
<ul>
<li><p>对象赋值是类的所有数据成员的一一对应赋值，其本质是对已分配内存的对象，进行数据成员的初始化</p>
</li>
<li><p>对象复制 &#x3D; 分配新对象对象空间 + 对新对象成员的赋值初始化。对象复制是要包含空间分配操作的</p>
</li>
</ul>
<p>两个已分配内存的对象间的赋值并不会导致拷贝构造函数被调用</p>
<pre><code>//声明及初始化，调用拷贝构造函数
Complex c2 = c1; 
//先声明对象，再赋值,不调用拷贝构造函数，调用默认构造函数然后赋值
Complex c2；
c2 = c1;    
</code></pre>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>当类对象有指针成员时，拷贝构造函数遇到一个问题，是只拷贝指针，还是连同指针指向的空间一起拷贝？</p>
<ul>
<li>浅拷贝：只拷贝指针成员</li>
<li>深拷贝：拷贝指针成员，并拷贝其指向的内存空间数据<br> 由于深拷贝的实现用到“&#x3D;”运算符重载，在运算符重载一节详述</li>
</ul>
<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>构造函数是能创建对象并初始化值的函数，将普通变量转换从类对象并分配内存空间的构造函数是转换构造函数。</p>
<ul>
<li>定义转换构造函数的目的是实现类型的自动转换（变量-&gt;对象）</li>
<li>只有一个参数，且不是拷贝构造函数的构造函数，就是转换构造函数</li>
<li>变量被赋值给对象时，编译器会自动调用转换构造函数，建立一个无名的临时对象</li>
</ul>
<p>隐式的转换构造函数：</p>
<pre><code>    class Complex &#123;
    public:
        double real, imag;
        Complex( int i) &#123;//类型转换构造函数
            cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
            real = i; imag = 0;
        &#125;
        Complex(double r,double i) &#123;real = r; imag = i; &#125;
    &#125;;
    
    int main ()
    &#123;
        Complex c1(7,8);
        Complex c2 = 12;
        c1 = 9;     // 9被自动转换成一个临时Complex对象
        cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
        return 0;
    &#125;
</code></pre>
<p>显式的转换构造函数：</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    explicit Complex( int i) &#123;  //显式类型转换构造函数
        cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
        real = i; imag = 0;
    &#125;
    Complex(double r,double i) &#123;real = r; imag = i; &#125;
&#125;;
int main () &#123;
    Complex c1(7,8);
    Complex c2 = Complex(12);
    c1 = 9;         // error, 9不能被自动转换成一个临时Complex对象
    c1 = Complex(9) //ok
    cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><h3 id="析构函数的概念"><a href="#析构函数的概念" class="headerlink" title="析构函数的概念"></a>析构函数的概念</h3><p>**析构函数(destructors)**用于对象生命周期结束前（如函数中的对象在函数返回时消失），释放对象的内存占用，以及其他的准备工作。<br>构造函数和析构函数在对象生命周期的角色从逻辑上讲是开始和结束的关系，但具体操作不一样：构造函数不为对象分配内存，只给成员赋初值；而析构函数一般要释放对象的内存<br>析构函数的特点：</p>
<ul>
<li>名字与类名相同，在前面加‘~’，没有参数和返回值，一个类最多只能有一个析构函数</li>
<li>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。</li>
<li>如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做</li>
<li>如果定义了析构函数，则编译器不生成缺省析构函数</li>
</ul>
<p>析构函数例子：</p>
<pre><code>class String&#123;
private :
    char * p;
    public:
    String () &#123;
        p = new char[10];
    &#125;
    ~ String () ;
&#125;;

String ::~ String()
&#123;
    delete [] p;
&#125;
</code></pre>
<p>对象数组的生命期结束时，每个对象的析构函数都会被调用。</p>
<pre><code>class Ctest &#123;
public:
    ~Ctest() &#123; cout&lt;&lt; &quot;destructor called&quot; &lt;&lt; endl; &#125;
&#125;;

int main () &#123;
    Ctest array[2];
    cout &lt;&lt; &quot;End Main&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>End Main
destructor called
destructor called
</code></pre>
<h3 id="析构函数的调用"><a href="#析构函数的调用" class="headerlink" title="析构函数的调用"></a>析构函数的调用</h3><p>析构函数被调用有以下几种情况<br>1)delete运算导致析构函数调用：</p>
<pre><code>Ctest * pTest;
pTest = new Ctest;  //构造函数调用
delete pTest;       //析构函数调用
---------------------------------------------------------
pTest = new Ctest[3];   //构造函数调用3次
delete [] pTest;        //析构函数调用3次
</code></pre>
<p>若new一个对象数组，那么用delete释放时应该写 []。否则只delete一个对<br>象(调用一次析构函数)<br>2)析构函数在对象作为函数返回值返回后被调用。其原理是，对象作为函数的入参，出参时，都是临时生成的对象，传完就调用析构函数销毁。</p>
<pre><code>class CMyclass &#123;
public:
    ~CMyclass() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125;
&#125;;
CMyclass obj;
CMyclass fun(CMyclass sobj ) &#123; //参数对象消亡也会导致析
                                //构函数被调用
    return sobj;                //函数调用返回时生成临时对象返回
&#125;
int main()&#123;
    obj = fun(obj); //函数调用的返回值（临时对象）被
    return 0;       //用过后，该临时对象析构函数被调用
&#125;
</code></pre>
<p>输出：</p>
<pre><code>destructor
destructor
destructor
</code></pre>
<h2 id="构造与析构的时序"><a href="#构造与析构的时序" class="headerlink" title="构造与析构的时序"></a>构造与析构的时序</h2><p>总体原则：类似堆栈的先入后出原则：先构造的后析构<br>几个关键分类：<br>临时对象：赋值时创建，赋完值就消亡，生命周期似乎就一条指令<br>局部对象：在{}范围内存在，{}结束时消亡<br>全局、静态对象：从创建开始，在程序整个运行期间存在，程序结束时消亡。<br>一个例子：</p>
<pre><code>class Demo &#123;
        int id;
    public:
        Demo(int i) &#123;
            id = i;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;
        &#125;
        ~Demo() &#123;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; destructed&quot; &lt;&lt; endl;
        &#125;
&#125;;

Demo d1(1);
void Func()
&#123;
    static Demo d2(2);
    Demo d3(3);
    cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;
&#125;

int main () &#123;
    Demo d4(4);
    d4 = 6;
    cout &lt;&lt; &quot;main&quot; &lt;&lt; endl;
    &#123; 
        Demo d5(5);
    &#125;
    Func();
    cout &lt;&lt; &quot;main ends&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出结果:</p>
<pre><code>id=1 constructed    //全局对象d1
id=4 constructed    //构造函数d4
id=6 constructed    //转换构造函数d4
id=6 destructed     //临时对象赋值完毕，消亡
main
id=5 constructed    //构造函数d5
id=5 destructed     //d5作用域结束，消亡
id=2 constructed    //Fun构造静态对象d2(等同全局对象)
id=3 constructed    //构造局部对象d3
func
id=3 destructed     //Fun返回，d3消亡
main ends       
id=6 destructed     //Main的局部对象d4消亡（id=6）
id=2 destructed     //整个程序结束，全局对象d2消亡
id=1 destructed     //整个程序结束，全局对象d1消亡
</code></pre>
<h1 id="类对象的指针：this指针"><a href="#类对象的指针：this指针" class="headerlink" title="类对象的指针：this指针"></a>类对象的指针：this指针</h1><p>this指针是在类成员函数内，指向当前类对象的指针。<br>注意：</p>
<ul>
<li>this指针是指向当前对象的，所谓当前，是指调用成员函数时，是通过所在的对象的指针来调用</li>
<li>this指针体现的是成员函数和对象的关系，如果是静态成员函数，没有this指针，因为静态成员函数不从属于对象</li>
</ul>
<p>为什么this指针如此特殊，需要单独命名？这涉及到C++的类的实现原理。</p>
<h2 id="C-的类与C的结构体"><a href="#C-的类与C的结构体" class="headerlink" title="C++的类与C的结构体"></a>C++的类与C的结构体</h2><p>在C++早期，C++代码被编译器翻译成C代码，再由C编译器编译<br>类的实现原理和C的结构体有密切关系，下面是类和结构体的转换：<br>1)C++的类：</p>
<pre><code>class CCar &#123;
    public:
        int price;
        void SetPrice(int p);
&#125;;

void CCar::SetPrice(int p)
&#123; price = p; &#125;

int main()
&#123;
    CCar car;
    car.SetPrice(20000);
    return 0;
&#125;
</code></pre>
<p>2)C的结构体实现类的功能</p>
<pre><code>struct CCar &#123;
    int price;
&#125;;

void SetPrice(struct CCar * this, int p)
&#123; this-&gt;price = p; &#125;

int main() &#123;
    struct CCar car;
    SetPrice( &amp; car,
    20000);
    return 0;
&#125;
</code></pre>
<p>用C实现面向对象(CCar结构体)，方法(SetPrice)传入的参数是结构体对象的指针(struct CCar * this)</p>
<h2 id="C-的this指针"><a href="#C-的this指针" class="headerlink" title="C++的this指针"></a>C++的this指针</h2><p>成员函数（非static）可以直接使用this来代表指向该函数作用的对象的指针</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    void Print() &#123; cout &lt;&lt; real &lt;&lt; &quot;,&quot; &lt;&lt; imag ; &#125;
    Complex(double r,double i):real(r),imag(i)&#123; &#125;   //初始化列表
    Complex AddOne() &#123;
        this-&gt;real ++;  //等价于 real++
        this-&gt;Print();  //等价于 Print()
        return * this;
    &#125;
&#125;;

int main() &#123;
    Complex c1(1,1),c2(0,0);
    c2 = c1.AddOne();
    return 0;
&#125; //输出 2,1
</code></pre>
<p>对象的this指针通常隐式存在：</p>
<ul>
<li>成员函数（非static）的入参实际隐式地有一个this指针参数</li>
<li>成员函数访问成员变量，也是隐式的通过this指针访问</li>
<li>通过对象的指针调用成员函数，本质也是传入this指针</li>
</ul>
<p>如果成员函数不访问成员变量，可以传入NULL的对象指针：</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  //等价于 void Hello(A * this ) &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p)
&#125; // 输出： hello
</code></pre>
<p>如果成员函数访问了成员变量，实际是通过成员函数传入的this指针来访问，此时指针不可为NULL</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  
//等价于void Hello(A * this ) &#123; cout &lt;&lt; this-&gt;i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
//this若为NULL，则出错！！
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p);
&#125; //出错
</code></pre>
<h2 id="静态成员的概念"><a href="#静态成员的概念" class="headerlink" title="静态成员的概念"></a>静态成员的概念</h2><p>静态成员：在定义前面加了static关键字的成员、</p>
<pre><code>class CRectangle
&#123;
    private:
    int w, h;
    static int nTotalArea; //静态成员变量
    static int nTotalNumber;
    public:
    CRectangle(int w_,int h_);
    ~CRectangle();
    static void PrintTotal(); //静态成员函数
&#125;;
</code></pre>
<ul>
<li>普通成员变量每个对象有各自的一份；而静态成员变量是全局共有的一份，为所有对象共享</li>
<li>同一个类的成员函数，不论静不静态都是一份代码段</li>
<li>普通成员函数必须具体作用于某个对象（也可以理解为绑定），而静态成员函数并不具体作用于某个对象</li>
<li>因此静态成员（变量或者函数），不需要通过对象就能访问</li>
</ul>
<p>sizeof求类大小，不会计算静态成员变量，因为不属于类的一部分（从空间占用上讲）。</p>
<pre><code>class CMyclass &#123;
int n;
static int s;
&#125;;  // sizeof(CMyclass) 等于 4
</code></pre>
<h2 id="访问静态成员"><a href="#访问静态成员" class="headerlink" title="访问静态成员"></a>访问静态成员</h2><p>一下几种方法访问,可以归纳为两种：通过类名访问，通过对象访问<br>1)类名::成员名</p>
<pre><code>CRectangle::PrintTotal();
</code></pre>
<p>2)对象名.成员名</p>
<pre><code>CRectangle r; 
r.PrintTotal();
</code></pre>
<p>3)指针-&gt;成员名</p>
<pre><code>CRectangle * p = &amp;r; 
p-&gt;PrintTotal();
</code></pre>
<p>4)引用.成员名</p>
<pre><code>CRectangle &amp; ref = r; 
int n = ref.nTotalNumber;
</code></pre>
<h2 id="静态成员函数与this指针"><a href="#静态成员函数与this指针" class="headerlink" title="静态成员函数与this指针"></a>静态成员函数与this指针</h2><ul>
<li>静态成员函数中不能使用 this 指针！</li>
<li>因为静态成员函数并不具体作用与某个对象!</li>
<li>因此静态成员函数的真实的参数的个数，就是程序中写出的参数个数！</li>
</ul>
<p>前面讲，C++的作用是封装数据，静态成员似乎破坏这一目的，那么静态成员有什么作用？<br>为了兼容C的全局变量与函数</p>
<ul>
<li>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在</li>
<li>静态成员函数本质上是全局函数</li>
<li>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解</li>
</ul>
<h2 id="静态成员函数的使用场景"><a href="#静态成员函数的使用场景" class="headerlink" title="静态成员函数的使用场景"></a>静态成员函数的使用场景</h2><p>对于需要全局维护的数据，可以使用静态成员变量，并通过静态成员函数访问。<br>考虑一个图形处理程序，需要随时知道矩形的总数和总面积</p>
<ul>
<li>每个矩形封装成类的对象</li>
<li>总数和总面积是类的静态成员（等价于全局变量）</li>
</ul>
<p>类定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CRectangle</span><br><span class="line">    &#123;</span><br><span class="line">    private:</span><br><span class="line">        int w, h;</span><br><span class="line">        static int nTotalArea;</span><br><span class="line">        static int nTotalNumber;</span><br><span class="line">    public:</span><br><span class="line">        CRectangle(int w_,int h_);</span><br><span class="line">        ~CRectangle();</span><br><span class="line">        static void PrintTotal();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数定义：</p>
<pre><code>CRectangle::CRectangle(int w_,int h_)
&#123;
    w = w_;
    h = h_;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
CRectangle::~CRectangle()
&#123;
    nTotalNumber --;
    nTotalArea -= w * h;
&#125;
void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl;
&#125;
</code></pre>
<p>类对象的调用：</p>
<pre><code>int CRectangle::nTotalNumber = 0;
int CRectangle::nTotalArea = 0;
// 必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。
int main()
&#123;
    CRectangle r1(3,3), r2(2,2);
    //cout &lt;&lt; CRectangle::nTotalNumber; 
    //错误 , 静态的私有变量也只能通过成员函数访问，静态不等于全局可访问
    CRectangle::PrintTotal();
    r1.PrintTotal();
    return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>2,13
2,13
</code></pre>
<p>注意两点：</p>
<ul>
<li>静态成员变量是全局共有的一份存储，但private的静态成员只能通过类的成员函数访问。注意区分全局存储和全局访问，静态成员只有全局存储特性，没有全局可访问特性。</li>
<li>静态成员函数，不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
<p>以下静态成员函数访问错误：</p>
<pre><code>void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; w &lt;&lt; &quot;,&quot; &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl; //错误
&#125;
CRetangle::PrintTotal(); //解释不通 w 到底是属于那个对象的
</code></pre>
<p> 以上例子还有缺陷：<br> 在使用静态成员时，特别是类的构造和析构会修改该静态成员，如前文的CRectangle类的构造函数有nTotalNumber++操作，析构有nTotalNumber–。这个时候要考虑构造和析构函数是否覆盖到所有类型（普通构造，拷贝构造，转换构造）<br> 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象：</p>
<ul>
<li>调用一个以CRectangle类对象作为参数的函数时</li>
<li>调用一个以CRectangle类对象作为返回值的函数时</li>
</ul>
<p>临时对象在消亡时会调用析构函数，减少nTotalNumber和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber和nTotalArea的值，因为设计类时漏掉了拷贝构造的情况<br>解决办法：为CRectangle类写一个拷贝构造函数：</p>
<pre><code>CRectangle :: CRectangle(CRectangle &amp; r )
&#123;
    w = r.w; h = r.h;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
</code></pre>
<p>这样nTotalNumber和nTotalArea全局计数就是准确的</p>
<h1 id="类的嵌套：封闭类"><a href="#类的嵌套：封闭类" class="headerlink" title="类的嵌套：封闭类"></a>类的嵌套：封闭类</h1><h2 id="封闭类的基本概念"><a href="#封闭类的基本概念" class="headerlink" title="封闭类的基本概念"></a>封闭类的基本概念</h2><p>再来把C++的类和C结构体对比下：</p>
<ul>
<li>C：结构体的成员可以是基础变量，基础变量的指针，结构体的指针，其他复合类型的指针</li>
<li>C++：类的成员变量可以是基础变量，及其指针、引用，可不可以是类对象？类对象的引用和指针？</li>
</ul>
<p>于是引入类嵌套类对象的情况：有成员对象的类叫封闭类（enclosing class)<br>一个示例：写一个汽车类，包含轮胎和引擎类对象<br>轮胎和引擎类：</p>
<pre><code>class CTyre //轮胎类
    &#123;
    private:
        int radius; //半径
        int width; //宽度
    public:
        CTyre(int r,int w):radius(r),width(w) &#123; &#125;   //用初始化列表构造
    &#125;;
    
class CEngine //引擎类
&#123;
&#125;;
</code></pre>
<p>汽车类：</p>
<pre><code>class CCar &#123; //汽车类
private:
    int price; //价格
    CTyre tyre;
    CEngine engine;
public:
    CCar(int p,int tr,int tw );
&#125;;
CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw) //用初始化列表构造
&#123;
&#125;;
</code></pre>
<p>汽车类的使用：</p>
<pre><code>int main()
&#123;
    CCar car(20000,17,225); //传入初始化列表
    return 0;
&#125;
</code></pre>
<h2 id="初始化列表构造封闭类"><a href="#初始化列表构造封闭类" class="headerlink" title="初始化列表构造封闭类"></a>初始化列表构造封闭类</h2><p>对于封闭类，有几个问题就凸显出来：</p>
<ul>
<li>构造一个封闭类，还要构造其嵌套的类</li>
<li>构造时序是怎样的</li>
<li>析构时序是怎样的</li>
</ul>
<p>上例中，如果 CCar类不定义构造函数，下面的语句会编译出错：CCar car;<br>因为CCar不传初始化值给嵌套类CTyre，编译器不知道该如何初始化car.tyre的成员变量<br>而car.engine的初始化没问题，因为不用初始化成员变量，用默认构造函数即可<br>为了解决封闭类的嵌套类成员的初始化问题，构造函数引入新的初始化方法：</p>
<ul>
<li>初始化列表：将成员初始化从构造函数体，移到函数名后面，只是换了形式，但是方便了封闭类各嵌套类的初始化，不用开发者自己到函数体写构造函数内容</li>
<li>成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。</li>
</ul>
<p>封闭类都是通过构造函数的初始化列表，层层传入嵌套类的构造函数：</p>
<pre><code>CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw)&#123;&#125;;
//p, tr, tw是传入的初始化值; price,tyre是CCar对象的两个成员
CCar car(20000,17,225);
//Car的price = 20000, Car的tyre的radius = 17，width = 225
</code></pre>
<p> 上例是普通构造函数，对于封闭类的拷贝构造函数：</p>
<ul>
<li>封闭类对象是用拷贝构造函数初始化的，其成员对象也用拷贝构造函数初始化</li>
</ul>
<p>测试用例：</p>
<pre><code>class A
&#123;
public:
    A() &#123; cout &lt;&lt; &quot;default&quot; &lt;&lt; endl; &#125;
    A(A &amp; a) &#123; cout &lt;&lt; &quot;copy&quot; &lt;&lt; endl;&#125;
&#125;;
class B &#123; A a; &#125;;

int main()
&#123;
    B b1,b2(b1);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>default
Copy
</code></pre>
<p>下面考虑封闭类构造和析构的时序</p>
<ul>
<li>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数、</li>
<li>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关</li>
<li>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反</li>
</ul>
<p>一个测试示例</p>
<pre><code>class CTyre &#123;
    public:
        CTyre() &#123; cout &lt;&lt; &quot;CTyre contructor&quot; &lt;&lt; endl; &#125;
        ~CTyre() &#123; cout &lt;&lt; &quot;CTyre destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CEngine &#123;
    public:
        CEngine() &#123; cout &lt;&lt; &quot;CEngine contructor&quot; &lt;&lt; endl; &#125;
        ~CEngine() &#123; cout &lt;&lt; &quot;CEngine destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CCar &#123;
    private:
        CEngine engine;
        CTyre tyre;
    public:
        CCar( ) &#123; cout &lt;&lt; “CCar contructor” &lt;&lt; endl; &#125;
        ~CCar() &#123; cout &lt;&lt; &quot;CCar destructor&quot; &lt;&lt; endl; &#125;
&#125;;

int main()&#123;
CCar car;
return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>CEngine contructor
CTyre contructor
CCar contructor
CCar destructor
CTyre destructor
CEngine destructor
</code></pre>
<h1 id="类的成员属性：友元和常量成员"><a href="#类的成员属性：友元和常量成员" class="headerlink" title="类的成员属性：友元和常量成员"></a>类的成员属性：友元和常量成员</h1><h2 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h2><p>友元(friend)分为友元函数和友元类两种<br>一个类的private成员，只能通过类自己的成员函数访问，那么其他类的成员函数想访问这个类的private成员怎么办？友元可以解决这种需求</p>
<ol>
<li><p>友元函数: 一个类的友元函数可以访问该类的私有成员<br>即类A内可以声明其他类B的成员函数或者全局函数，加前缀friend，这些以friends开头的函数就可访问类A的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CCar ; //提前声明 CCar类，以便后面的CDriver类使用</span><br><span class="line"> class CDriver</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">         void ModifyCar( CCar * pCar) ; //改装汽车</span><br><span class="line"> &#125;;</span><br><span class="line"> class CCar</span><br><span class="line"> &#123;</span><br><span class="line">     private:</span><br><span class="line">         int price;</span><br><span class="line">         friend int MostExpensiveCar( CCar cars[], int total); //声明友元</span><br><span class="line">         friend void CDriver::ModifyCar(CCar * pCar); //声明友元</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> void CDriver::ModifyCar( CCar * pCar)</span><br><span class="line"> &#123;</span><br><span class="line">     pCar-&gt;price += 1000; //访问CCar成员，汽车改装后加价</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int MostExpensiveCar( CCar cars[],int total)//求最贵汽车的价格</span><br><span class="line"> &#123;</span><br><span class="line">     int tmpMax = -1;</span><br><span class="line">     for( int i = 0;i &lt; total; ++i )</span><br><span class="line">     if( cars[i].price &gt; tmpMax) //访问CCar成员</span><br><span class="line">     tmpMax = cars[i].price;</span><br><span class="line">     return tmpMax;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了普通成员函数，也可以将类构造、析构函数说明为另一个类的友元</p>
<p>2)友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员<br>如果是类的嵌套（封闭类），声明为friend的类A可以调用自己的成员函数访问与它为friend关系的类B的私有成员，而不必调用类B的成员函数。</p>
<pre><code>class CCar
&#123;
private:
    int price;
    friend class CDriver; //声明CDriver为友元类
&#125;;
class CDriver
&#123;
public:
    CCar myCar;
    void ModifyCar() &#123;  //改装汽车
    myCar.price += 1000;   //因CDriver是CCar的友元类，故此处可以访问其私有成员
    &#125;
&#125;;

int main()&#123; return 0; &#125;
</code></pre>
<p>友元类之间的关系不能传递，不能继承。就是说A和B是friend,B和C是friend,但A和C不一定是friend。父类之间的friend关系，子类不一定能传承。</p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>如果不希望某个对象的值被改变，定义该对象的时候可以在前面加 const关键字<br>在类的成员函数说明后面加const关键字，则该成员函数成为常量<br>成员函数。<br>常量成员函数内部不能改变属性的值，也不能调用非常量成员函数<br>在定义常量成员函数和声明常量成员函数时都应该使用const 关键字。</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void PrintValue() const;
&#125;;
void Sample::PrintValue() const &#123;             //此处不使用const会导致编译出错
    cout &lt;&lt; value;
&#125;
void Print(const Sample &amp; o) &#123;
    o.PrintValue(); 
&#125;//若 PrintValue非const则编译错
</code></pre>
<p>以下是错误示例：</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void func() &#123; &#125;;
    Sample() &#123; &#125;
    void SetValue() const &#123;
        value = 0; // wrong
        func(); //wrong
    &#125;
&#125;;
const Sample Obj;
Obj.SetValue (); //常量对象上可以使用常量成员函数
</code></pre>
<p>什么场景定义成常量成员函数？<br>如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，最好将其写成常量成员函数</p>
<p>常量成员函数的重载：<br>两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载关系，而非重定义。</p>
<h1 id="类的运算：运算符重载"><a href="#类的运算：运算符重载" class="headerlink" title="类的运算：运算符重载"></a>类的运算：运算符重载</h1><p>C++定义了类，可以像基本类型那样创建、销毁、初始化。那么类和类之间的运算呢？<br>+、 -、 *、 &#x2F;、 %、 ^、 &amp;、 ~、 !、 |、 &#x3D;、 &lt;&lt; 、&gt;&gt;、 !&#x3D;、<br>考虑以下方法实现类的运算：</p>
<ul>
<li>设计类的成员函数，支持类运算操作</li>
<li>设计某种机制，把运算符关联成函数操作，在函数内定义具体类运算方法。进行类的运算时，形式上可以像基本类型的运算一样</li>
</ul>
<p>例如complex_a和complex_b是两个复数对象；求两个复数的和, 希望能直接写：complex_a + complex_b<br>运算符重载将解决类和对象的运算需求</p>
<h2 id="运算符重载的概念"><a href="#运算符重载的概念" class="headerlink" title="运算符重载的概念"></a>运算符重载的概念</h2><p>运算符重载，就是对已有的运算符(C++中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为<br>运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象<br>期望效果:同一个运算符，对不同类型的操作数，所发生的行为不同</p>
<pre><code>complex_a + complex_b //生成新的复数对象
5 + 4 = 9 //基本运算符操作
</code></pre>
<p>从行为上看，运算符重载类似于把运算符进行了重定义成函数操作（类似C的typedef）<br>运算符重载写法：</p>
<pre><code>返回值类型 operator 运算符（形参表）
&#123;
……  //定义该运算符的运算规则
&#125;
</code></pre>
<p>示例：</p>
<pre><code>class Complex
&#123;
public:
    double real,imag;
    Complex( double r = 0.0, double i= 0.0):real(r),imag(i) &#123; &#125;
    Complex operator-(const Complex &amp; c);
&#125;;
Complex operator+( const Complex &amp; a, const Complex &amp; b)
&#123;
    return Complex( a.real+b.real,a.imag+b.imag); //返回一个临时对象
&#125;
Complex Complex::operator-(const Complex &amp; c)
&#123;
    return Complex(real - c.real, imag - c.imag); //返回一个临时对象
&#125;

int main()
&#123;
    Complex a(4,4),b(1,1),c;
    c = a + b; //等价于c=operator+(a,b);
    cout &lt;&lt; c.real &lt;&lt; &quot;,&quot; &lt;&lt; c.imag &lt;&lt; endl;
    cout &lt;&lt; (a-b).real &lt;&lt; &quot;,&quot; &lt;&lt; (a-b).imag &lt;&lt; endl;
    //a-b等价于a.operator-(b)
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>5,5
3,3
</code></pre>
<p>c &#x3D; a + b; 等价于c&#x3D;operator+(a,b);<br>a-b 等价于a.operator-(b)<br>运算符重载的实现还是成员函数，所以是依赖于对象的。也就是说，运算符重载看上去和类、对象没啥关系，但本质上，重载的运算符是归属于某个类的，因为a-b只是表象现象，真正定义对象运算的，是a.operator-(b)成员函数。<br>因为运算符重载依赖对象的，因此双目运算，如+，-，在运算符重载时只需要传入另一个对象，而不需要传运算符的当前对象。<br>重载为成员函数时， 参数个数为运算符目数减一。<br>重载为普通函数时， 参数个数为运算符目数</p>
<p>运算符重载概念小结：</p>
<ul>
<li>运算符重载的实质是函数重载</li>
<li>可以重载为普通函数，也可以重载为成员函数</li>
<li>把含运算符的表达式转换成对运算符函数的调用</li>
<li>把运算符的操作数转换成运算符函数的参数</li>
<li>运算符被多次重载时，根据实参的类型决定调用哪个运算符函数</li>
</ul>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><p>接下来的几节讲几个代表性的运算符重载。本节讲赋值运算符“&#x3D;”有时候希望赋值运算符两边的类型可以不匹配，比如，把一个int类型变量赋值给一个Complex对象，或把一个 char *类型的字符串赋值给一个字符串对象,此时就需要重载赋值运算符“&#x3D;”。<br>赋值运算符“ &#x3D;”只能重载为成员函数</p>
<p>示例：</p>
<pre><code>class String &#123;
private:
    char * str;
    public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s);
    String::~String( ) &#123; delete [] str; &#125;
&#125;;
String &amp; String::operator = (const char * s)
&#123; //重载“=”以使得 obj = “hello”能够成立
    delete [] str;
    str = new char[strlen(s)+1];
    strcpy( str, s);
    return * this;
&#125;

int main()
&#123;
    String s;
    s = &quot;Good Luck,&quot; ; //等价于 s.operator=(&quot;Good Luck,&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    // String s2 = &quot;hello!&quot;; //这条语句要是不注释掉就会出错
    s = &quot;Shenzhou 8!&quot;; //等价于 s.operator=(&quot;Shenzhou 8!&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Good Luck,
Shenzhou 8!
</code></pre>
<h2 id="赋值运算符与深拷贝"><a href="#赋值运算符与深拷贝" class="headerlink" title="赋值运算符与深拷贝"></a>赋值运算符与深拷贝</h2><p>在类与对象的拷贝构造函数一节讲了拷贝构造函数的作用：用一个已经初始化的对象，去初始化另一个对象，具体操作是讲成员变量一一赋值。<br>那么更深入考虑一下:对于各种类型的成员变量，能不能达到目的？</p>
<ul>
<li>对于基础类型的成员变量，如int,char，直接赋值即可</li>
<li>对于指针类型的成员变量，给指针赋值就Ok?需不需要给指针指向的空间也赋值？</li>
<li>对于引用类型的成员变量，直接赋值OK?</li>
<li>对于类对象类型的成员变量，怎么赋值？嵌套调用拷贝构造函数？</li>
</ul>
<p>引用只是标签，可以直接拷贝，等同变量拷贝。封闭类的构造函数会嵌套调用基础类型的拷贝，直到所有成员赋值完为止。<br>唯一需要考虑的是包含指针类型成员的类如何拷贝<br>如果直接赋值指针而不分配并初始化其指向空间，效果如下:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081648147.png" alt="image-20221208164831061"><br>如不定义自己的赋值运算符，那么S1&#x3D;S2实际上导致 S1.str和 S2.str<br>指向同一地方。<br>如果S1对象消亡，析构函数将释放 S1.str指向的空间，则S2消亡时还<br>要释放一次，就形成两次delete错误!<br>如果执行 S1 &#x3D; “other”；会导致S2.str指向的地方被delete</p>
<p>为了解决以上问题，类的拷贝构造不仅要拷贝指针，还有拷贝指针指向的空间（分配新内存+拷贝）。这种带内存分配的拷贝称为深拷贝</p>
<ul>
<li>浅拷贝：只拷贝成员，对于指针成员，也只拷贝指针变量</li>
<li>深拷贝：拷贝成员，对于指针成员，拷贝指针变量，且拷贝指针指向的内存空间</li>
</ul>
<p>为了实现深拷贝，需要重载“&#x3D;”运算符：</p>
<pre><code>String &amp; operator = (const String &amp; s) &#123;
    delete [] str;  //先释放指针原本指向的空间,因为新空间和原空间大小可能不一样
    str = new char[strlen( s.str)+1];   //分配指针指向的新空间
    strcpy( str,s.str); //新空间赋值初始化
    return * this;  //返回当前对象的指针
&#125;
</code></pre>
<p>还有可优化的，如果传入对象就是当前对象，没必要释放又分配，直接返回即可</p>
<pre><code>String &amp; operator = (const String &amp; s)&#123;
    if( this == &amp; s)
        return * this;
    delete [] str;
    str = new char[strlen(s.str)+1];
    strcpy( str,s.str);
    return * this;
&#125;
</code></pre>
<p>整个类设计如下：</p>
<pre><code>class String &#123;
private:
    char * str;
public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s)&#123;
        delete [] str;
        str = new char[strlen(s)+1];
        strcpy( str, s);
        return * this;
&#125;;
    ~String( ) &#123; delete [] str; &#125;
&#125;;
</code></pre>
<p>再考虑一下运算符重载函数的返回值<br>为什么返回String &amp;<br>原因：对运算符进行重载的时候，好的风格是尽量保留运算符原本的特性<br>例如运算符是可以多个连续运算的</p>
<pre><code>a = b = c;
(a=b)=c; //会修改a的值
</code></pre>
<p>分别等价于：</p>
<pre><code>a.operator=(b.operator=(c));
(a.operator=(b)).operator=(c);
</code></pre>
<p>对于拷贝构造函数，原指针未初始化，不指向任何空间，直接分配空间在拷贝即可，写法如下：</p>
<pre><code>String( String &amp; s)
&#123;
    str = new char[strlen(s.str)+1];
    strcpy(str,s.str);
&#125;
</code></pre>
<h2 id="流运算符的重载"><a href="#流运算符的重载" class="headerlink" title="流运算符的重载"></a>流运算符的重载</h2><p>C++常用的输入输出是怎么实现的？</p>
<pre><code>cout &lt;&lt; 5 &lt;&lt; “this”;
</code></pre>
<ul>
<li>cout是什么?</li>
<li>“&lt;&lt;”原本是位偏移运算，为什么能作用于cout?</li>
<li>“&lt;&lt;”怎么支持连续运算，且支持多种类型</li>
</ul>
<p>原因就是&lt;&lt;被流运算类重载了。</p>
<ul>
<li>cout是在iostream中定义的，ostream类的对象</li>
<li>“&lt;&lt;” 能用在cout上是因为，在iostream里对“ &lt;&lt;” 进行了重载</li>
<li>运算符重载函数返回对象的引用，实现连续运算；多个运算符重载函数的重载，支持多种类型</li>
</ul>
<p>实现方法：</p>
<pre><code>ostream &amp; ostream::operator&lt;&lt;(int n)
&#123;
    …… //输出n的代码
    return * this;
&#125;
ostream &amp; ostream::operator&lt;&lt;(const char * s )
&#123;
    …… //输出s的代码
    return * this;
&#125;
</code></pre>
<p>cout &lt;&lt; 5 &lt;&lt; “this”;<br>等价于： cout.operator&lt;&lt;(5).operator&lt;&lt;(“this”);<br>一个流运算符重载的示例：<br>假定c是Complex复数类的对象，现在希望写“ cout &lt;&lt; c;”，就能以“ a+bi”的形式输出c的值，写“ cin&gt;&gt;c;”，就能从键盘接受“ a+bi”形式的输入，并且使得c.real &#x3D; a,c.imag &#x3D; b</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
using namespace std;
class Complex &#123;
    double real,imag;
    public:
    Complex( double r=0, double i=0):real(r),imag(i)&#123; &#125;;
    friend ostream &amp; operator&lt;&lt;( ostream &amp; os, const Complex &amp; c);
    friend istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c);
&#125;;
ostream &amp; operator&lt;&lt;( ostream &amp; os,const Complex &amp; c)
&#123;
    os &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; //以&quot;a+bi&quot;的形式输出
    return os;
&#125;
   
istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c)
&#123;
    string s;
    is &gt;&gt; s; //将&quot;a+bi&quot;作为字符串读入, “a+bi”中间不能有空格
    int pos = s.find(&quot;+&quot;,0);
    string sTmp = s.substr(0,pos); //分离出代表实部的字符串
    c.real = atof(sTmp.c_str()); //atof库函数能将const char*指针指向的内容转换成 float
    sTmp = s.substr(pos+1, s.length()-pos-2); //分离出代表虚部的字符串
    c.imag = atof(sTmp.c_str());
    return is;
&#125;

int main()
&#123;
    Complex c;
    int n;
    cin &gt;&gt; c &gt;&gt; n;
    cout &lt;&lt; c &lt;&lt; &quot;,&quot; &lt;&lt; n;
    return 0;
&#125;
</code></pre>
<p>运行结果可以如下：</p>
<pre><code>13.2+133i 87    //输入
13.2+133i, 87   //输出
</code></pre>
<h2 id="其他运算符重载"><a href="#其他运算符重载" class="headerlink" title="其他运算符重载"></a>其他运算符重载</h2><p>类型转换运算符”()”重载：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
    double real,imag;
    public:
    Complex(double r=0,double i=0):real(r),imag(i) &#123; &#125;;
    operator double () &#123; return real; &#125;
    //重载强制类型转换运算符 double
&#125;;
int main()
&#123;
    Complex c(1.2,3.4);
    cout &lt;&lt; (double)c &lt;&lt; endl; //输出 1.2
    double n = 2 + c; //等价于 double n=2+c.operator double()
    cout &lt;&lt; n; //输出 3.2
&#125;
</code></pre>
<p>自增自减运算符”++,–”的重载：<br>自增运算符++、自减运算符–有前置&#x2F;后置之分，为了区分所重载的是前置运算符还是后置运算符， C++规定：</p>
<ul>
<li>前置运算符作为一元运算符重载</li>
<li>后置运算符作为二元运算符重载，多写一个没用的参数</li>
</ul>
<p>前置运算符重载形式：</p>
<pre><code>重载为成员函数：
T &amp; operator++();   //不用写入参，当前对象的成员++
T &amp; operator--();
重载为全局函数：
T1 &amp; operator++(T2);
T1 &amp; operator—(T2);
</code></pre>
<p>后置运算符重载形式：    </p>
<pre><code>重载为成员函数：
T operator++(int);  //多写一个入参，用于和前置重载区分
T operator--(int);
重载为全局函数：
T1 operator++(T2,int );
T1 operator—( T2,int);
</code></pre>
<p>调用示例：</p>
<pre><code>int main()
&#123;
    CDemo d(5);
    cout &lt;&lt; (d++ ) &lt;&lt; &quot;,&quot;; //等价于 d.operator++(0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (++d) &lt;&lt; &quot;,&quot;; //等价于 d.operator++();
    cout &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; (d-- ) &lt;&lt; &quot;,&quot;; //等价于 operator--(d,0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (--d) &lt;&lt; &quot;,&quot;; //等价于 operator--(d);
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
&#125;

class CDemo &#123;
private :
    int n;
    public:
    CDemo(int i=0):n(i) &#123; &#125;
    CDemo &amp; operator++(); //用于前置形式
    CDemo operator++( int ); //用于后置形式
    operator int ( ) &#123; return n; &#125;
    friend CDemo &amp; operator--(CDemo &amp; );
    friend CDemo operator--(CDemo &amp; ,int);
&#125;;
CDemo &amp; CDemo::operator++()
&#123; //前置 ++
    n ++;
    return * this;
&#125; // ++s即为: s.operator++();

CDemo CDemo::operator++( int k )
&#123; //后置 ++
    CDemo tmp(*this); //记录修改前的对象
    n ++;
    return tmp; //返回修改前的对象
&#125; // s++即为: s.operator++(0);
CDemo &amp; operator--(CDemo &amp; d)
&#123;//前置--
    d.n--;
    return d;
&#125; //--s即为: operator--(s);
CDemo operator--(CDemo &amp; d,int)
&#123;//后置--
    CDemo tmp(d);
    d.n --;
    return tmp;
&#125; //s--即为: operator--(s, 0);
</code></pre>
<h2 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h2><ul>
<li>C++不允许定义新的运算符</li>
<li>重载后运算符的含义应该符合日常习惯，即保留原运算符的使用风格</li>
<li>运算符重载不改变运算符的优先级</li>
<li>以下运算符不能被重载：“ .” “ .*” “ ::” “ ?:” “sizeof”</li>
<li>重载运算符()、[]、-&gt;、&#x3D;，运算符重载函数必须声明为<br>类的成员函数</li>
</ul>
<h2 id="运算符重载的综合示例"><a href="#运算符重载的综合示例" class="headerlink" title="运算符重载的综合示例"></a>运算符重载的综合示例</h2><p>实现一个可变长数组类型CArray，实现如下用例：</p>
<pre><code>int main() &#123; 
    CArray a; //开始里的数组是空的
    for( int i = 0;i &lt; 5;++i)
        a.push_back(i); //要用动态分配的内存来存放数组元素，需要一个指针成员变量
    CArray a2,a3;
    a2 = a; //要重载“=”
    for( int i = 0; i &lt; a.length(); ++i )
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot; ;  //要重载[]
    a2 = a3; //a2是空的
    for( int i = 0; i &lt; a2.length(); ++i )//a2.length()返回0
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    a[3] = 100;
    CArray a4(a);   //要自己写拷贝构造函数
    for( int i = 0; i &lt; a4.length(); ++i )
        cout &lt;&lt; a4[i] &lt;&lt; &quot; &quot;;
    return 0;
&#125;
</code></pre>
<p>CArray类的设计：</p>
<pre><code>class CArray &#123;
    int size; //数组元素的个数
    int *ptr; //指向动态分配的数组
    public:
    CArray(int s = 0); //s代表数组元素的个数
    CArray(CArray &amp; a);
    ~CArray();
    void push_back(int v); //用于在数组尾部添加一个元素v
    CArray &amp; operator=( const CArray &amp; a);
    //用于数组对象间的赋值
    int length() &#123; return size; &#125; //返回数组元素个数
    int &amp; CArray::operator[](int i) //返回值为 int 不行!不支持 a[i] = 4
    &#123;//用以支持根据下标访问数组元素，如n = a[i] 和a[i] = 4; 这样的语句
        return ptr[i];
    &#125;
&#125;;
</code></pre>
<p>成员函数的实现：</p>
<pre><code>CArray::CArray(int s):size(s)
&#123;
    if( s == 0)
    ptr = NULL;
    else
    ptr = new int[s];
&#125;
CArray::CArray(CArray &amp; a) &#123;
    if( !a.ptr) &#123;
    ptr = NULL;
    size = 0;
    return;
    &#125;
    ptr = new int[a.size];
    memcpy( ptr, a.ptr, sizeof(int ) * a.size);
    size = a.size;
&#125;

CArray::~CArray()
&#123;
    if( ptr) delete [] ptr;
&#125;
CArray &amp; CArray::operator=( const CArray &amp; a)
&#123; //赋值号的作用是使“=”左边对象里存放的数组，大小和内容都和右边的对象一样
    if( ptr == a.ptr) //防止a=a这样的赋值导致出错
    return * this;
    if( a.ptr == NULL) &#123; //如果a里面的数组是空的
    if( ptr ) delete [] ptr;
    ptr = NULL;
    size = 0;
    return * this;
    &#125;
    if( size &lt; a.size) &#123;         //如果原有空间够大，就不用分配新的空间
        if(ptr)
        delete [] ptr;
        ptr = new int[a.size];
    &#125;
    memcpy( ptr,a.ptr,sizeof(int)*a.size);
    size = a.size;
    return * this;
&#125; // CArray &amp; CArray::operator=( const CArray &amp; a)

void CArray::push_back(int v)
&#123; //在数组尾部添加一个元素
    if( ptr) &#123;
        int * tmpPtr = new int[size+1]; //重新分配空间
        memcpy(tmpPtr,ptr,sizeof(int)*size); //拷贝原数组
        内容
        delete [] ptr;
        ptr = tmpPtr;
    &#125;
    else //数组本来是空的
    ptr = new int[1];
    ptr[size++] = v; //加入新的数组元素
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：继承与多态</title>
    <url>/2020/03/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>前文分析了C++类内成员的关系，本文讨论类和类之间的关系。<br>考虑用C++对现实世界的交通工具进行描述。</p>
<ul>
<li>汽车可能包含各种类型，小汽车，公交车，但他们能抽象出四个轮子，烧油这些基本属性</li>
<li>飞机也有各种类型，但也能抽象出机翼，机身等基本属性</li>
<li>轮船…</li>
</ul>
<p>如果自顶向下设计，如何设计这些对象的类？</p>
<ul>
<li>提炼这些交通工具的共有属性，如材质，耗油量，价格，设计成一个交通工具基础类；然后设计一些操作方法，比如制造，启动，停止。</li>
<li>分别设计汽车、飞机、轮船等更具体的类的属性，比如轮子、排水量等，注意，他们也包含基础类的材质，耗油量，价格等基本属性；然后也设计一些方法，比如制造汽车、开汽车和造飞机、开飞机等</li>
<li>然后再设计更细节的类，作为汽车、飞机、轮船类的细化，比如A品牌的汽车，B品牌汽车，作为两个具体类。</li>
</ul>
<p>仔细考虑以上步骤，有以下问题：</p>
<ul>
<li>这些类的属性（成员变量）是相互独立的吗？</li>
<li>这些类的方法（成员函数）是相互独立的吗？</li>
</ul>
<p>C++用类的“继承”描述层层细化的类及其成员变量的关系，用“多态”描述各层方法的实现关系。</p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承关系的概念"><a href="#继承关系的概念" class="headerlink" title="继承关系的概念"></a>继承关系的概念</h2><p>继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个<strong>基类</strong>（也叫父类），而把B作为基类的一个<strong>派生类</strong>(也叫子类)。</p>
<ul>
<li>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数</li>
<li>派生类一经定义后，可以独立使用，不依赖于基类。</li>
<li>派生类拥有基类的全部成员函数和成员变量，不论是private、 protected、 public。但是派生类的成员函数不能访问基类中的private成员</li>
</ul>
<p>一个管理学生的类继承：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651314.png" alt="image-20221208165130260"><br>派生类语法:</p>
<pre><code>class 派生类名： public 基类名
&#123;
&#125;;
</code></pre>
<p>学生类的派生:</p>
<pre><code>class CStudent &#123;
    private:
    string sName;
    int nAge;
    public:
    bool IsThreeGood() &#123; &#125;;
    void SetName( const string &amp; name )
    &#123; sName = name; &#125;
        //......
&#125;;

class CUndergraduateStudent: public CStudent &#123;
    private:
    int nDepartment;
    public:
    bool IsThreeGood() &#123; ...... &#125;; //覆盖
    bool CanBaoYan() &#123; .... &#125;;
&#125;; // 派生类的写法是：类名: public 基类名
</code></pre>
<h2 id="类继承的存储空间"><a href="#类继承的存储空间" class="headerlink" title="类继承的存储空间"></a>类继承的存储空间</h2><p>在类与对象一文讲过，类对象的存储空间，实际就是成员变量的空间，成员函数不在对象空间内（虚函数包含一个虚函数表指针）。那么基类和派生类的对象空间有什么相关性？<br>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。 在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。<br>一个示例：</p>
<pre><code>class CBase
&#123;
    int v1, v2;
&#125;;
class CDerived:public CBase
&#123;
    int v3;
&#125;;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651715.png" alt="image-20221208165140659"></p>
<h2 id="类继承的覆盖"><a href="#类继承的覆盖" class="headerlink" title="类继承的覆盖"></a>类继承的覆盖</h2><p>类内的同名非同参的函数叫函数重载，那么基类与派生类的同名函数呢？<br>派生类可以定义和基类成员同名的成员，这叫<strong>覆盖</strong>。在派生类中访问这类成员时，默认访问派生类中定义的成员，基类的成员函数或变量被“覆盖”掉了。如果要在派生类中访问基类定义的同名成员时，要使用作用域符号::<br>一个例子：</p>
<pre><code>class base &#123;    //基类
    int j;  //默认private
    public:
    int i;
    void func();
&#125;;
class derived : public base&#123;    //派生类
    public:
    int i;  //覆盖基类i
    void access();
    void func(); //覆盖基类func()
&#125;;

void derived::access() &#123; //访问派生类成员
    j = 5; //error
    i = 5; //引用的是派生类的 i
    base::i = 5; //引用的是基类的 i
    func(); //派生类的
    base::func(); //基类的
&#125;
</code></pre>
<p>调用函数:</p>
<pre><code>derived obj;
obj.i = 1;  //访问派生类成员i
obj.base::i = 1; //访问基类成员i
</code></pre>
<p>内存分布:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651894.png" alt="image-20221208165150851"><br>以上只是示例，一般来说，基类和派生类不定义同名成员变量，但经常有同名成员函数，所以覆盖通常用于成员函数覆盖。</p>
<h2 id="类继承的成员访问控制"><a href="#类继承的成员访问控制" class="headerlink" title="类继承的成员访问控制"></a>类继承的成员访问控制</h2><ul>
<li>基类的private成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数</li>
<li>基类的public成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数<br>– 派生类的友元函数<br>– 其他的函数</li>
<li>基类的protected成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数可以访问当前对象的基类的保护成员</li>
</ul>
<p>一个示例：</p>
<pre><code>class Father &#123;
    private: int nPrivate; //私有成员
    public: int nPublic; //公有成员
    protected: int nProtected; // 保护成员
&#125;;
class Son :public Father&#123;
    void AccessFather () &#123;
        nPublic = 1; // ok;
        nPrivate = 1; // wrong
        nProtected = 1; // OK，访问从基类继承的protected成员
        Son f;
        f.nProtected = 1; //wrong ， f不是当前对象
    &#125;
&#125;;

int main()
&#123;
    Father f;
    Son s;
    f.nPublic = 1; // Ok
    s.nPublic = 1; // Ok
    f.nProtected = 1; // error
    f.nPrivate = 1; // error
    s.nProtected = 1; //error
    s.nPrivate = 1; // error
    return 0;
&#125;
</code></pre>
<h2 id="类继承的构造函数"><a href="#类继承的构造函数" class="headerlink" title="类继承的构造函数"></a>类继承的构造函数</h2><p>类似于嵌套类（封闭类）的构造函数，使用初始化列表来实现层层构造，基类和派生类只初始化他们能访问的成员</p>
<pre><code>class Bug &#123;
private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug ()&#123; &#125;;
&#125;;

class FlyBug: public Bug // FlyBug是Bug的派生类
&#123;
    int nWings;
    public:
    FlyBug( int legs,int color, int wings);
&#125;;

Bug::Bug( int legs, int color) //Bug类的构造函数
&#123;
    nLegs = legs;
    nColor = color;
&#125;

//错误的FlyBug构造函数！
FlyBug::FlyBug ( int legs,int color, int wings)
&#123;
    nLegs = legs; // 不能访问
    nColor = color; // 不能访问
    nType = 1; // ok
    nWings = wings;
&#125;

//正确的FlyBug构造函数：使用初始化列表
FlyBug::FlyBug ( int legs, int color, int wings):Bug( legs, color)
&#123;
    nWings = wings;
&#125;

int main() &#123;
    FlyBug fb ( 2,3,4);
    fb.PrintBug();
    fb.nType = 1;
    fb.nLegs = 2 ; // error. nLegs is private
    return 0;
&#125;
</code></pre>
<h2 id="类继承的构造析构时序"><a href="#类继承的构造析构时序" class="headerlink" title="类继承的构造析构时序"></a>类继承的构造析构时序</h2><p>在创建派生类的对象时，需要调用基类的构造函数：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。<br>调用基类构造函数的两种方式:</p>
<ul>
<li><p>显式方式：在派生类的构造函数中，为基类的构造函数提供参数.</p>
<p> derived::derived(arg_derived-list):base(arg_base-list)</p>
</li>
<li><p>隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数</p>
</li>
</ul>
<p>析构函数执行时序:<br>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。<br>一个例子：</p>
<pre><code>class Base &#123;
    public:
    int n;
    Base(int i):n(i)
    &#123; cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;&#125;
    ~Base()
    &#123; cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; destructed&quot; &lt;&lt; endl; &#125;
&#125;;
    
class Derived:public Base &#123;
    public:
    Derived(int i):Base(i)
    &#123; cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl; &#125;
    ~Derived()
    &#123; cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;&#125;
&#125;;
int main() &#123; Derived Obj(3); return 0; &#125;
</code></pre>
<p>输出结果:</p>
<pre><code>Base 3 constructed
Derived constructed
Derived destructed
Base 3 destructed
</code></pre>
<p>##封闭派生类的构造函数<br>封闭类的构造用初始化列表，派生类也用初始化列表，那么封闭派生类呢？<br>还是初始化列表</p>
<pre><code>class Bug &#123;
    private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug ()&#123; &#125;;
&#125;;

class Skill &#123;
    public:
    Skill(int n) &#123; &#125;
&#125;;
class FlyBug: public Bug &#123;
    int nWings;
    Skill sk1, sk2;
    public:
    FlyBug( int legs, int color, int wings);
&#125;;
FlyBug::FlyBug( int legs, int color, int wings):
    Bug(legs,color),sk1(5),sk2(color) ,nWings(wings) &#123; //初始化列表，不能访问的通通交给下层构造函数
&#125;
</code></pre>
<h2 id="封闭派生类的构造析构时序"><a href="#封闭派生类的构造析构时序" class="headerlink" title="封闭派生类的构造析构时序"></a>封闭派生类的构造析构时序</h2><p>在创建派生类的对象时:</p>
<ol>
<li>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员</li>
<li>再执行成员对象类的构造函数，用以初始化派生类对象中成员对象</li>
<li>最后执行派生类自己的构造函数<br>在派生类对象消亡时：</li>
<li>先执行派生类自己的析构函数</li>
<li>再依次执行各成员对象类的析构函数</li>
<li>最后执行基类的析构函数<br>析构函数的调用顺序与构造函数的调用顺序相反<h1 id="类的复合"><a href="#类的复合" class="headerlink" title="类的复合"></a>类的复合</h1>在数学上，两个集合有无关、相交和包含的关系。对于多个类来说，也应该有以上三种关系。无关类&#x3D;两个成员不相关的类；继承类&#x3D;类成员间有继承关系的类；那么相交的类呢？<h2 id="复合关系的概念"><a href="#复合关系的概念" class="headerlink" title="复合关系的概念"></a>复合关系的概念</h2>C++用“复合”表示类的相交关系。</li>
</ol>
<p>1)继承：“是”的关系<br>基类是A， B是基类A的派生类，逻辑上要求：“一个B对象也是一个A对象”<br>2)复合：“有”的关系<br>类C中“有” 成员变量k，k是类D的对象，则C和D是复合关系，逻辑上要求：“D对象是C对象的固有属性或组成部分</p>
<p>下面比较一下继承和复合在具体设计的实例：<br>继承关系顶层设计例子:</p>
<ul>
<li>写了一个 CMan 类代表男人</li>
<li>后来又发现需要一个CWoman类来代表女人</li>
<li>CWoman类和CMan类有共同之处,让CWoman类从CMan类派生而来，是否合适？</li>
<li>错！从一开始就应该设计CHuman类，代表“人” ,然后CMan和CWoman都从<br>CHuman派生</li>
</ul>
<p>继承逻辑关系：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652246.png" alt="image-20221208165210195"></p>
<p>复合关系顶层设计例子：</p>
<ul>
<li>几何形体程序中，需要写“点”类，也需要写“圆”类</li>
<li>每个圆都有圆心，那么点类应该从圆类派生出来吗？</li>
<li>错！”点“不仅在圆内有，在其他图形也有，不是圆独有，非继承关系</li>
<li>实际上，圆和点是复合关系，每一个“圆”对象里都包含(<strong>有</strong>)一个“点”对象</li>
<li>逻辑上，复合关系就是，我的一部分可以看成是你的，但是我的全部东西不都属于你</li>
</ul>
<p>复合关系的类通常用友元实现：</p>
<pre><code>class CPoint
&#123;
    double x,y;
    friend class CCircle;
    //便于Ccirle类操作其圆心
&#125;;

class CCircle
&#123;
    double r;
    CPoint center;
&#125;;
</code></pre>
<h2 id="复合关系的典型示例"><a href="#复合关系的典型示例" class="headerlink" title="复合关系的典型示例"></a>复合关系的典型示例</h2><p>如果要写一个小区养狗管理程序，需要写一个“业主”类，还需要写一个“狗” 类<br>狗是归宿于业主的，一个业主可以有多条狗，狗也可以随时脱离业主<br>考虑以下设计方法：<br>设计人和狗两个类，相互包含对方类</p>
<pre><code>class CDog;
class CMaster
&#123;
    CDog dogs[10];
&#125;;
class CDog
&#123;
    CMaster m;
&#125;;
</code></pre>
<p> 这样有循环定义错误！且逻辑上，狗和人并非相互包含关系<br> 这种关系上相互相关，对象本身又完全独立的情况，用对象指针表示</p>
<pre><code>class CMaster; //CMaster必须提前声明，不能先写CMaster类后写Cdog类
class CDog &#123;
    CMaster * pm;
&#125;;
class CMaster &#123;
    CDog * dogs[10];
&#125;;
</code></pre>
<p>逻辑关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652390.png" alt="image-20221208165220338"></p>
<h1 id="继承的不足"><a href="#继承的不足" class="headerlink" title="继承的不足"></a>继承的不足</h1><h2 id="继承方式的访问限制"><a href="#继承方式的访问限制" class="headerlink" title="继承方式的访问限制"></a>继承方式的访问限制</h2><p>基类和派生类是包含的关系，那么基类对象和派生类对象是什么关系？<br>对于类的public派生方式:</p>
<pre><code>class base &#123; &#125;;
class derived : public base &#123; &#125;;
base b;
derived d;
</code></pre>
<p>1）派生类的对象可以赋值给基类对象<br>b &#x3D; d;<br>2）派生类对象可以初始化基类引用<br>base &amp; br &#x3D; d;<br>3）派生类对象的地址可以赋值给基类指针<br>base * pb &#x3D; &amp; d;<br>如果派生方式是 private或protected，则上述三条不可行</p>
<p>对于类的protected和private派生方式:</p>
<pre><code>class base &#123;&#125;;
class derived : protected base &#123;&#125;;
base b;
derived d;
</code></pre>
<p>• protected继承时，基类的public成员和protected成员成为派生类的protected成员。<br>• private继承时，基类的public成员成为派生类的private成员，基类的protected成员成为派生类的不可访问成员。<br>• protected和private继承不是“是”的关系</p>
<h2 id="派生类的对象指针转换"><a href="#派生类的对象指针转换" class="headerlink" title="派生类的对象指针转换"></a>派生类的对象指针转换</h2><p>public派生的情况下,派生类对象的指针可以直接赋值给基类指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
//ptrBase指向的是一个Derived类的对象；
</code></pre>
<p>*ptrBase可以看作一个Base类的对象，访问它的public成员直接通过ptrBase即可，但不能通过ptrBase访问objDerived对象中属于Derived类而不属于Base类的成员<br>过强制指针类型转换，可以把ptrBase转换成Derived类的指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
Derived *ptrDerived = (Derived * ) ptrBase;
</code></pre>
<p>程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会错</p>
<p>派生类的指针赋值给基类后，基类指针也不能访问派生类的特有成员</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Base &#123;
    protected:
    int n;
    public:
    Base(int i):n(i)&#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; constructed&quot; &lt;&lt; endl; &#125;
    ~Base() &#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; destructed&quot; &lt;&lt; endl;&#125;
    void Print() &#123; cout &lt;&lt; &quot;Base:n=&quot; &lt;&lt; n &lt;&lt; endl;&#125;
&#125;;

class Derived:public Base &#123;
    public:
    int v;
    Derived(int i):Base(i),v(2 * i) &#123;
    cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl;
&#125;

~Derived() &#123;
    cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;
&#125;

void Func() &#123; &#125; ;
    void Print() &#123;
        cout &lt;&lt; &quot;Derived:v=&quot; &lt;&lt; v &lt;&lt; endl;
        cout &lt;&lt; &quot;Derived:n=&quot; &lt;&lt; n &lt;&lt; endl;
    &#125;
&#125;;

int main() &#123;
    Base objBase(5);
    Derived objDerived(3);
    Base * pBase = &amp; objDerived ;
    //pBase-&gt;Func(); //err;Base类没有Func()成员函数
    //pBase-&gt;v = 5; //err; Base类没有v成员变量
    pBase-&gt;Print();
    //Derived * pDerived = &amp; objBase; //error
    Derived * pDerived = (Derived *)(&amp; objBase);
    pDerived-&gt;Print(); //慎用，可能出现不可预期的错误
    pDerived-&gt;v = 128; //往别人的空间里写入数据，会有问题
    objDerived.Print();
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Base 5 constructed
Base 3 constructed
Derived constructed
Base:n=3
Derived:v=1245104 //pDerived-&gt;n 位于别人的空间里
Derived:n=5
Derived:v=6
Derived:n=3
Derived destructed
Base 3 destructed
Base 5 destructed
</code></pre>
<p>从逻辑上来说，派生类指针既然能被赋值给基类指针，那么通过基类指针，应该能调用派生类的成员函数，获取派生类的成员变量。在下一章，继承类的多态将实现这个目的。</p>
<h2 id="多级继承"><a href="#多级继承" class="headerlink" title="多级继承"></a>多级继承</h2><p>类A派生类B，类B派生类C，类C派生类D……<br>– 类A是类B的直接基类<br>– 类B是类C的直接基类，类A是类C的间接基类<br>– 类C是类D的直接基类，类A、 B是类D的间接基类<br>在声明派生类时， 只需要列出它的直接基类<br>– 派生类沿着类的层次自动向上继承它的间接基类<br>– 派生类的成员包括<br>• 派生类自己定义的成员<br>• 直接基类中的所有成员<br>• 所有间接基类的全部成员</p>
<h1 id="多态：在继承上更进一步"><a href="#多态：在继承上更进一步" class="headerlink" title="多态：在继承上更进一步"></a>多态：在继承上更进一步</h1><p>前面派生类的对象指针转换一节，基类指针强转后也不能访问派生类私有对象。考虑一下本文开始讲的交通工具顶层设计思路，在顶层设计时就要设计类的成员函数，在派生类也要设计成员函数，这些函数会有重合的情况吗？如果有重合，基类指针也不能访问派生类成员，这样基类和派生类不就失去联系了吗？多级继承这种情况不是更加严重？<br>为了解决这种问题，本节引入继承类的“多态”<br>多态能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少</p>
<h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><p>在类的定义中，前面有 virtual 关键字的成员函数就是虚函数</p>
<pre><code>class base &#123;
    virtual int get() ;
&#125;;
int base::get()&#123; &#125;
</code></pre>
<p>virtual关键字只用在类定义里的函数声明中使用，定义函数体时不用。<br>使用虚函数，来实现“多态”效果。多态有通过指针和引用两种表现形式:</p>
<ul>
<li>能通过基类的指针调用派生类虚函数，访问其特有成员变量</li>
</ul>
<p>派生类的指针可以赋给基类指针<br>通过基类指针调用基类和派生类中的同名虚函数时:<br>（1）若该指针指向一个基类的对象，那么被调用是<br>基类的虚函数；<br>（2）若该指针指向一个派生类的对象，那么被调用<br>的是派生类的虚函数</p>
<pre><code>class CBase &#123;
public:
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
class CDerived:public CBase &#123;
public :
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
int main() &#123;
    CDerived ODerived;
    CBase * p = &amp; ODerived;
    p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象
    return 0;
&#125; 
</code></pre>
<ul>
<li>能通过基类的引用调用派生类虚函数</li>
</ul>
<p>派生类的对象可以赋给基类引用<br>通过基类引用调用基类和派生类中的同名虚函数时:<br>（1）若该引用引用的是一个基类的对象，那么被调<br>用是基类的虚函数；<br>（2）若该引用引用的是一个派生类的对象，那么被<br>调用的是派生类的虚函数。</p>
<pre><code>class CBase &#123;
public:
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
class CDerived:public CBase &#123;
public :
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
int main() &#123;
    CDerived ODerived;
    CBase &amp; r = ODerived;
    r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象
    return 0;
&#125; 
</code></pre>
<p>是不是所有成员函数加virtual都是多态？不是！</p>
<ul>
<li>在非构造或析构函数的成员函数中调用虚函数，是多态。在运行时才确定到底调用哪一层派生类函数</li>
<li>在构造函数和析构函数中调用虚函数，不是多态。调用的函数是当前类的函数，编译时即确定</li>
</ul>
<p>多层继承实现多态，每一层都要加virtual关键字吗？</p>
<ul>
<li>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</li>
</ul>
<h2 id="多态与对象指针"><a href="#多态与对象指针" class="headerlink" title="多态与对象指针"></a>多态与对象指针</h2><p>一个变量有两方面属性：类型、值<br>那么多态把derived类的地址值，赋值给base类的指针，访问对象成员时是什么效果？<br>以下例子的this指针指向什么？</p>
<pre><code>class Base &#123;
public:
    void fun1() &#123; this-&gt;fun2(); &#125; //this是基类指针， fun2是虚函数，所以是多态
    virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
class Derived:public Base &#123;
public:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
int main() &#123;
    Derived d;
    Base * pBase = &amp; d;
    pBase-&gt;fun1();
    return 0;
&#125;
</code></pre>
<p>pBase被Derived对象的地址赋值后，其值为Derived对象的地址，但类型还是Base的指针（多态指针赋值不会强转）。pBase-&gt;fun1()会先在Base类访问其fun1()，传入this指针（指向fun2）,而this-&gt;fun2()会调用Derived类的fun2()<br>输出： </p>
<pre><code>Derived:fun2()
</code></pre>
<p>虚函数也可以定义为private：</p>
<pre><code>class Base &#123;
private:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
class Derived:public Base &#123;
public:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
Derived d;
Base * pBase = &amp; d;
pBase -&gt; fun2(); // 编译出错
</code></pre>
<p>pBase已经被赋值为指向derived d的指针，不能调用base类的private函数。</p>
<h2 id="多态的实例-游戏开发"><a href="#多态的实例-游戏开发" class="headerlink" title="多态的实例:游戏开发"></a>多态的实例:游戏开发</h2><p>游戏中有很多种怪物，每种怪物都有一个类与之对应。某个玩家创建的具体怪物就是对象<br>怪物的主要动作（成员函数）有：</p>
<ul>
<li>攻击（Attack），针对不同的被攻击者有不同的函数</li>
<li>反击（FightBack），被某个怪物攻击时做出的相应动作</li>
<li>掉血（Hurted），被攻击时会掉血，血量值不同有不同处理，如死亡</li>
</ul>
<p>现在的需求是：已经有CWolf、CGhost两种怪物，需要设计新的怪物CThunderBird，并能满足和其他怪物的交互<br>顶层设计:<br>设置基类 CCreature，并且使CDragon, CWolf等其他类都从CCreature派生而来<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652097.png" alt="image-20221208165241029"><br>非多态的派生类设计：<br>由于每个怪物对于其他怪物的攻击和反击都是不同的，每个怪物类都要设计一组Attack和FightBack：</p>
<pre><code>class class CCreature &#123;
    protected: int nPower ; //代表攻击力
    int nLifeValue ; //代表生命值
&#125;;
class CThunderBird : public CCreature &#123;
    public:
    void Attack(CWolf * pWolf) &#123;
        ．．．表现攻击动作的代码
        pWolf-&gt;Hurted( nPower);
        pWolf-&gt;FightBack( this);
    &#125;
    void Attack( CDragon * pDragon) &#123;
        ．．．表现攻击动作的代码
        pDragon-&gt;Hurted( nPower);
        pDragon-&gt;FightBack( this);
    &#125;
    void FightBack( CWolf * pWolf) &#123;
        ．．．．表现反击动作的代码
        pWolf -&gt;Hurted( nPower / 2);
    &#125;
    void FightBack( CDragon * pDragon) &#123;
        ．．．．表现反击动作的代码
        pDragon-&gt;Hurted( nPower / 2 );
    &#125;
    void Hurted ( int nPower) &#123;
        ．．．．表现受伤动作的代码
        nLifeValue -= nPower;
    &#125;
&#125;
</code></pre>
<p>现有n种怪物，CThunderBird类中就得有n个Attack 和n个FightBack成员函数，对于其他类也得新增针对CThunderBird的Attack和FightBack。这种设计工作量过于巨大。原因就在于要区分传入的对象指针。<br>那么能否传入基类的指针呢，这样就不存在为各种类型写几个函数。基类指针要访问派生类的成员，得用虚函数形成多态。多态实现如下：</p>
<pre><code>//基类 CCreature：
class CCreature &#123;
protected :
    int m_nLifeValue, m_nPower;
    public:
    virtual void Attack( CCreature * pCreature) &#123;&#125;
    virtual void Hurted( int nPower) &#123; &#125;
    virtual void FightBack( CCreature * pCreature) &#123;&#125;
&#125;;
//派生类 CDragon:
class CDragon : public CCreature &#123;
public:
    virtual void Attack( CCreature * pCreature);
    virtual void Hurted( int nPower);
    virtual void FightBack( CCreature * pCreature);
&#125;;

//派生类的成员函数实现具体操作
void CDragon::Attack(CCreature * p) //传入基类指针
&#123; …表现攻击动作的代码
    p-&gt;Hurted(m_nPower); //多态
    p-&gt;FightBack(this); //多态
&#125;
void CDragon::Hurted( int nPower)
&#123; …表现受伤动作的代码
    m_nLifeValue -= nPower;
&#125;
void CDragon::FightBack(CCreature * p)
&#123; …表现反击动作的代码
    p-&gt;Hurted(m_nPower/2); //多态
&#125;

//多态的调用
CDragon Dragon; CWolf Wolf; CGhost Ghost;
CThunderBird Bird；
Dragon.Attack( &amp; Wolf); //调用CWolf::Hurted
Dragon.Attack( &amp; Ghost); //调用CGhost::Hurted
Dragon.Attack( &amp; Bird); //调用CBird::Hurted
</code></pre>
<p>使用多态，新增某个派生类时，已有的类可以原封不动，因为传入基类指针，会“自动”调用正确的派生类函数，开发者只需要设计新增的派生类和其成员函数即可</p>
<h2 id="多态的原理：虚函数表指针"><a href="#多态的原理：虚函数表指针" class="headerlink" title="多态的原理：虚函数表指针"></a>多态的原理：虚函数表指针</h2><p>多态” 的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定，这叫“动态联编”<br>首先分析包含虚函数的类对象的内存分布：</p>
<pre><code>class Base &#123;
public:
int i;
    virtual void Print() &#123; cout &lt;&lt; &quot;Base:Print&quot; ; &#125;
&#125;;

class Derived : public Base&#123;
public:
int n;
    virtual void Print() &#123; cout &lt;&lt;&quot;Drived:Print&quot; &lt;&lt; endl; &#125;
&#125;;

int main() &#123;
    Derived d;
    cout &lt;&lt; sizeof( Base) &lt;&lt; &quot;,&quot;&lt;&lt; sizeof( Derived ) ;
    return 0;
&#125;
</code></pre>
<p>输出：8, 12<br>为什么类对象的size比成员变量int（4字节）还多4字节？<br>因为包含虚函数的基类，实例化的对象除了成员变量，还包含一个指针（一般4字节），指向虚函数的入口地址，如果有多个虚函数，这些地址连续排列形成虚函数表，指针指向首个虚函数地址。如果这个指针指向基类，就能找到基类的所有虚函数入口，如果指针指向派生类，就能找到派生类的的所有虚函数入口。基类和派生类对象的指针赋值，实际会导致虚函数表指针指向的虚函数入口地址不同，从而调用时不同。<br>如果当前指针指向基类，则调用基类自己的虚函数：</p>
<pre><code>Base b;
pBase = &amp;b;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652980.png" alt="image-20221208165259927"><br>如果当前指针指向派生类，则调用派生类的虚函数：</p>
<pre><code>Derived d;
pDerived = &amp;d;
pBase = pDerived;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081653211.png" alt="image-20221208165311145"><br>动态联编的实现：<br>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令<br>而普通函数是编译过程中确定了成员函数的入口地址，不存在运行时根据对象来改变某个函数的入口地址。</p>
<h2 id="虚函数与抽象类"><a href="#虚函数与抽象类" class="headerlink" title="虚函数与抽象类"></a>虚函数与抽象类</h2><p>可以想象得到，前文的游戏使用虚函数的例子是通用的，先设计基类，提炼对象属性，定义虚函数；再派生子类，在子类实现局函数的具体操作。那么问题来了，基类的虚函数有必要实现函数体吗？<br>很多情况，基类只是一个抽象，定义了函数的名称和参数，不需要在基类实现虚函数，全部交给派生类实现。</p>
<ul>
<li>纯虚函数：没有函数体的虚函数</li>
<li>抽象类：包含纯虚函数的类</li>
</ul>
<p>纯虚函数写法：没函数体{}，直接&#x3D;0</p>
<pre><code>class A &#123;
private: int a;
public:
    virtual void Print( ) = 0 ; //纯虚函数
    void fun() &#123; cout &lt;&lt; &quot;fun&quot;; &#125;
&#125;;
</code></pre>
<p>抽象类特点：</p>
<ul>
<li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li>
<li>可以创建抽象类的指针和引用，它们可以指向派生类的对象</li>
</ul>
<p>抽象类的指针：</p>
<pre><code>A a ; // 错， A 是抽象类，不能创建对象
A * pa ; // ok,可以定义抽象类的指针和引用
pa = new A ; //错误, A 是抽象类，不能创建对象
</code></pre>
<p>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类<br>抽象类的成员函数可以调用纯虚函数，但是构造函数或析构函数内不能调用纯虚函数</p>
<pre><code>class A &#123;
public:
    virtual void f() = 0; //纯虚函数
    void g( ) &#123; 
        this-&gt;f( ) ; //ok
    &#125;
    A( )&#123; 
        f( ); // 错误
    &#125;
&#125;;
class B:public A&#123;
public:
    void f()&#123;cout&lt;&lt;&quot;B:f()&quot;&lt;&lt;endl; &#125;
&#125;;
</code></pre>
<h2 id="虚函数与构造析构函数"><a href="#虚函数与构造析构函数" class="headerlink" title="虚函数与构造析构函数"></a>虚函数与构造析构函数</h2><p>前面考虑了普通成员函数加virtual，可以形成虚函数达到继承类的多态效果。那么构造函数和析构函数呢？</p>
<ul>
<li>不允许以虚函数作为构造函数</li>
<li>类继承需要把基类的析构函数设为虚函数</li>
</ul>
<p>对于常规析构函数，通过基类指针删除派生类对象时，只能调用基类的析构函数。但是合理的做法是，应该先调用派生类的析构函数，然后调用基类的析构函数。解决的方法：把析构函数定义为virtual，由于基类析构函数是虚函数，派生类的同名析构函数自然也是虚函数。<br>什么时候定义虚析构函数</p>
<ul>
<li>一个类只要定义了虚函数，则应该将析构函数也定义成虚函数</li>
<li>一个类打算作为基类使用，则应该将析构函数定义成虚函数</li>
</ul>
<p>虚析构函数用法：通过基类的指针删除派生类对象，会首先调用派生类的析构函数，然后调用基类的析构函数</p>
<pre><code>class son&#123;
public:
    virtual ~son() &#123;cout&lt;&lt;&quot;bye from son&quot;&lt;&lt;endl;&#125;;
&#125;;
class grandson:public son&#123;
public:
    ~grandson()&#123;cout&lt;&lt;&quot;bye from grandson&quot;&lt;&lt;endl;&#125;;
&#125;;
int main() &#123;
    son *pson;
    pson= new grandson(); //pson指向派生类grandson
    delete pson;
    return 0;
&#125;
</code></pre>
<p>输出： </p>
<pre><code>bye from grandson
bye from son
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC使用笔记</title>
    <url>/2020/06/22/GCC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="gcc编译选项"><a href="#gcc编译选项" class="headerlink" title="gcc编译选项"></a>gcc编译选项</h1><p>gcc提供了大量的警告选项，对代码中可能存在的问题提出警告，通常可以使用-Wall来开启以下警告:</p>
<pre><code>   -Waddress -Warray-bounds (only with -O2) -Wc++0x-compat
   -Wchar-subscripts -Wimplicit-int -Wimplicit-function-declaration
   -Wcomment -Wformat -Wmain (only for C/ObjC and unless
   -ffreestanding) -Wmissing-braces -Wnonnull -Wparentheses
   -Wpointer-sign -Wreorder -Wreturn-type -Wsequence-point
   -Wsign-compare (only in C++) -Wstrict-aliasing -Wstrict-overflow=1
   -Wswitch -Wtrigraphs -Wuninitialized (only with -O1 and above)
   -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value
   -Wunused-variable

unused-function:警告声明但是没有定义的static函数;
unused- label:声明但是未使用的标签;
unused-parameter:警告未使用的函数参数;
unused-variable:声明但是未使用的本地变量;
unused-value:计算了但是未使用的值;
format:printf和scanf这样的函数中的格式字符串的使用不当;
implicit-int:未指定类型;
implicit-function:函数在声明前使用;
char- subscripts:使用char类作为数组下标(因为char可能是有符号数);
missingbraces:大括号不匹配;
parentheses: 圆括号不匹配;
return-type:函数有无返回值以及返回值类型不匹配;
sequence-point:违反顺序点的代码,比如 a[i] = c[i++];
switch:switch语句缺少default或者switch使用枚举变量为索引时缺少某个变量的case;
strict- aliasing=n:使用n设置对指针变量指向的对象类型产生警告的限制程度,默认n=3;只有在-fstrict-aliasing设置的情况下有效;
unknow-pragmas:使用未知的#pragma指令;
uninitialized:使用的变量为初始化,只在-O2时有效;
</code></pre>
<p>以下是在-Wall中不会激活的警告选项:</p>
<pre><code>cast-align:当指针进行类型转换后有内存对齐要求更严格时发出警告;
sign- compare:当使用signed和unsigned类型比较时;
missing-prototypes:当函数在使用前没有函数原型时;
packed:packed 是gcc的一个扩展,是使结构体各成员之间不留内存对齐所需的空间,有时候会造成内存对齐的问题;
padded:也是gcc的扩展,使结构体成员之间进行内存对齐的填充,会造成结构体体积增大.
unreachable-code:有不会执行的代码时.
inline:当inline函数不再保持inline时 (比如对inline函数取地址);
disable-optimization:当不能执行指定的优化时.(需要太多时间或系统资源).
可以使用 -Werror时所有的警告都变成错误,使出现警告时也停止编译.需要和指定警告的参数一起使用.
</code></pre>
<p>编译的优化级别:<br>gcc默认提供了5级优化选项的集合:</p>
<pre><code>-O0:无优化(默认)
-O和-O1:使用能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化.在编译大型程序的时候会显著增加编译时内存的使用.
-O2: 包含-O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化.编译器不执行循环展开以及函数内联.此选项将增加编译时间和目标文件的执行性能.
-Os:专门优化目标文件大小,执行所有的不增加目标文件大小的-O2优化选项.并且执行专门减小目标文件大小的优化选项.
-O3: 打开所有-O2的优化选项并且增加 -finline-functions, -funswitch-loops,-fpredictive-commoning, -fgcse-after-reload and -ftree-vectorize优化选项.
</code></pre>
<p>-O1包含的选项-O1通常可以安全的和调试的选项一起使用:</p>
<pre><code>   -fauto-inc-dec -fcprop-registers -fdce -fdefer-pop -fdelayed-branch
   -fdse -fguess-branch-probability -fif-conversion2 -fif-conversion
   -finline-small-functions -fipa-pure-const -fipa-reference
   -fmerge-constants -fsplit-wide-types -ftree-ccp -ftree-ch
   -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse
   -ftree-fre -ftree-sra -ftree-ter -funit-at-a-time
</code></pre>
<p>以下所有的优化选项需要在名字前加上-f,如果不需要此选项可以使用-fno-前缀</p>
<pre><code>defer-pop:延迟到只在必要时从函数参数栈中pop参数;
thread- jumps:使用跳转线程优化,避免跳转到另一个跳转;
branch-probabilities:分支优化;
cprop- registers:使用寄存器之间copy-propagation传值;
guess-branch-probability:分支预测;
omit- frame-pointer:可能的情况下不产生栈帧;
</code></pre>
<p>-O2:以下是-O2在-O1基础上增加的优化选项:</p>
<pre><code>    -falign-functions  -falign-jumps -falign-loops  -falign-labels
   -fcaller-saves -fcrossjumping -fcse-follow-jumps  -fcse-skip-blocks
   -fdelete-null-pointer-checks -fexpensive-optimizations -fgcse
   -fgcse-lm -foptimize-sibling-calls -fpeephole2 -fregmove
   -freorder-blocks  -freorder-functions -frerun-cse-after-loop
   -fsched-interblock  -fsched-spec -fschedule-insns
   -fschedule-insns2 -fstrict-aliasing -fstrict-overflow -ftree-pre
   -ftree-vrp
</code></pre>
<p>cpu架构的优化选项,通常是-mcpu(将被取消);-march,-mtune</p>
<p>Debug选项:</p>
<pre><code>在 gcc编译源代码时指定-g选项可以产生带有调试信息的目标代码,gcc可以为多个不同平台上帝不同调试器提供调试信息,默认gcc产生的调试信息是为 gdb使用的,可以使用-gformat 指定要生成的调试信息的格式以提供给其他平台的其他调试器使用.常用的格式有
-ggdb:生成gdb专用的调试信息,使用最适合的格式(DWARF 2,stabs等)会有一些gdb专用的扩展,可能造成其他调试器无法运行.
-gstabs:使用 stabs格式,不包含gdb扩展,stabs常用于BSD系统的DBX调试器.
-gcoff:产生COFF格式的调试信息,常用于System V下的SDB调试器;
-gxcoff:产生XCOFF格式的调试信息,用于IBM的RS/6000下的DBX调试器;
-gdwarf- 2:产生DWARF version2 的格式的调试信息,常用于IRIXX6上的DBX调试器.GCC会使用DWARF version3的一些特性.
</code></pre>
<p>可以指定调试信息的等级:在指定的调试格式后面加上等级:<br>如: -ggdb2 等,0代表不产生调试信息.在使用-gdwarf-2时因为最早的格式为-gdwarf2会造成混乱,所以要额外使用一个-glevel来指定调试信息的等级,其他格式选项也可以另外指定等级.<br>gcc可以使用-p选项指定生成信息以供porf使用.</p>
<h1 id="gcc配置选项"><a href="#gcc配置选项" class="headerlink" title="gcc配置选项"></a>gcc配置选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727329.png" alt="6"></p>
<h1 id="gcc常用选项"><a href="#gcc常用选项" class="headerlink" title="gcc常用选项"></a>gcc常用选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081725642.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726685.png" alt="2"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726022.png" alt="3"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726272.png" alt="4"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727091.png" alt="5"></p>
]]></content>
      <categories>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>Github常用配置笔记</title>
    <url>/2020/08/27/Github%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="初始化git和github仓库"><a href="#初始化git和github仓库" class="headerlink" title="初始化git和github仓库"></a>初始化git和github仓库</h1><h2 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h2><h2 id="2-进入本地源码目录"><a href="#2-进入本地源码目录" class="headerlink" title="2.进入本地源码目录"></a>2.进入本地源码目录</h2><pre><code>git init
</code></pre>
<p>会出现.git目录<br>首次需要配置github账户和邮箱</p>
<pre><code>git config --global user.name &quot;github注册的用户名&quot;
git config --global user.mail &quot;github注册的邮箱&quot;
</code></pre>
<h2 id="3-添加远程仓库"><a href="#3-添加远程仓库" class="headerlink" title="3.添加远程仓库"></a>3.添加远程仓库</h2><p>在github网页新建仓库</p>
<pre><code>git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<p>.git&#x2F;config文件内容会出现remote等内容，ssh方式的url是git开头，http(s)方式是http(s)开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051116187.png" alt="image-20221205111653141"><br>如果是从别人拉过来的仓库，修改后新建仓库，上传遇到<code>fatal: remote origin already exists</code>问题，解决方法:</p>
<pre><code>git remote rm origin
git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<h2 id="4-git-add-commit-push三连"><a href="#4-git-add-commit-push三连" class="headerlink" title="4.git add, commit, push三连"></a>4.git add, commit, push三连</h2><pre><code>git add -A
git commit -m &#39;first commit&#39;
git push -f --set-upstream origin master //首次提交
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117987.png" alt="image-20221205111703940"><br>完成以后远程可以看得到仓库的文件   </p>
<h2 id="5-创建分支"><a href="#5-创建分支" class="headerlink" title="5.创建分支"></a>5.创建分支</h2><p>如果已经有主线，在本地<code>git checkout branchname</code>, 远程创建分支，记录.git链接， 然后关联远程分支即可：</p>
<pre><code>git remote add origin https://github.com/*/*.git
</code></pre>
<p>然后推送</p>
<pre><code>git push origin branchname
</code></pre>
<h2 id="5-首次配置可能的问题："><a href="#5-首次配置可能的问题：" class="headerlink" title="5.首次配置可能的问题："></a>5.首次配置可能的问题：</h2><p>push时有RSA key错误<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117281.png" alt="image-20221205111713234"><br>因为Git使用SSH连接，而SSH第一次连接需要验证GitHub服务器的Key。确认GitHub的Key的指纹信息是否真的来自GitHub的服务器。解决办法是在本地生成key，配置到github服务器<br>（1)创建ssh key</p>
<pre><code>ls -al ~/.ssh
ssh-keygen -t rsa -C &quot;github用户名&quot;
cat ~/.ssh/id_rsa.pub
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117255.png" alt="image-20221205111721197"><br>在push三连过程可以设置global全局配置，以后默认push到github<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117055.png" alt="image-20221205111728996"></p>
<p>（2）配置ssh key到github<br>登陆github,头像-settings-new SSH,复制新生成的SSH配置到服务器<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117386.png" alt="image-20221205111737339"><br>（3）需要重新add origin新建仓库（或者网页上新建仓库)，再push，<code>git status</code>和<code>git log</code>查看分支和日志</p>
<h1 id="Github-clone使用国内镜像"><a href="#Github-clone使用国内镜像" class="headerlink" title="Github clone使用国内镜像"></a>Github clone使用国内镜像</h1><p>国内搞开发最痛苦的就是限速+断开连接，github clone经常失败。推荐国内镜像服务作为代理进行git clone，将原git地址的github.com替换成代理地址即可。参考 <a href="https://zhuanlan.zhihu.com/p/463954956">无需代理直接加速各种 GitHub 资源拉取</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#git clone原地址</span><br><span class="line">$ git clone https://github.com/kubernetes/kubernetes.git</span><br><span class="line"></span><br><span class="line">#手动配置代理地址，任选其一能clone成功即可</span><br><span class="line">$ git clone https://github.com.cnpmjs.org/kubernetes/kubernetes.git</span><br><span class="line">$ git clone https://hub.fastgit.org/kubernetes/kubernetes.git</span><br><span class="line">$ git clone https://gitclone.com/github.com/kubernetes/kubernetes.git</span><br><span class="line"></span><br><span class="line">#配置git自动使用代理，配置以后可以用git clone原地址，自动走代理</span><br><span class="line">git config --global url.&quot;https://hub.fastgit.org&quot;.insteadOf https://github.com</span><br><span class="line">#取消自动代理</span><br><span class="line">$ git config --global --unset url.https://github.com/.insteadof</span><br></pre></td></tr></table></figure>

<p>使用国内镜像并不一定能解决所有clone问题，有的recursive clone对依赖包有版本要求，国内镜像版本不匹配导致clone fail，此时不能使用国内镜像。</p>
<p>解决版本：下载release版本的zip包，绕开git clone操作。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Github项目学习：linked-list-good-taste</title>
    <url>/2023/03/28/Github%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9Alinked-list-good-taste/</url>
    <content><![CDATA[<p>本文转载自 <a href="https://github.com/mkirchner/linked-list-good-taste">linked-list-good-taste</a>，添加了个人理解的注释</p>
<h1 id="Linked-lists-pointer-tricks-and-good-taste"><a href="#Linked-lists-pointer-tricks-and-good-taste" class="headerlink" title="Linked lists, pointer tricks and good taste"></a>Linked lists, pointer tricks and good taste</h1><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-code">The code</a><ul>
<li><a href="#the-cs101-version">The CS101 version</a></li>
<li><a href="#a-more-elegant-solution">A more elegant solution</a></li>
</ul>
</li>
<li><a href="#how-does-it-work">How does it work?</a><ul>
<li><a href="#integrating-the-head-pointer">Integrating the head pointer</a></li>
<li><a href="#maintaining-a-handle">Maintaining a handle</a></li>
</ul>
</li>
<li><a href="#going-beyond">Going beyond</a><ul>
<li><a href="#inserting-before-existing-items">Inserting before existing items</a></li>
<li><a href="#quick-refactor">Quick refactor</a></li>
<li><a href="#implementing-insert_before">Implementing insert_before()</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In a 2016 <a href="https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux">TED interview</a> (14:10) Linus Torvalds speaks about what he considers <em>good taste</em> in coding. As an example, he presents two implementations of item removal in singly linked lists (reproduced below).  In order to remove the first item from a list, one of the implementations requires a special case, the other one does not.  Linus, obviously, prefers the latter.</p>
<p>His comment is:</p>
<blockquote>
<p>[…] I don’t want you to understand why it doesn’t have the if statement.<br>But I want you to understand that sometimes you can see a problem in a<br>different way and rewrite it so that a special case goes away and becomes the<br>normal case, and that’s <em>good code</em>. […] – L. Torvalds</p>
</blockquote>
<p>The code snippets he presents are C-style pseudocode and are simple enough to follow. However, as Linus mentions in the comment, the snippets lack a conceptual explanation and it is not immediately evident how the more elegant solution actually works.</p>
<p>The next two sections look at the technical approach in detail and demonstrate how and why the indirect addressing approach is so neat. The last section extends the solution from item deletion to insertion.</p>
<h2 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h2><p>The basic data structure for a singly linked list of integers is shown in Figure 1.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281032617.png" alt="linked list"></p>
<p>Numbers are arbitrarily chosen integer values and arrows indicate pointers. <code>head</code> is a pointer of type <code>list_item *</code> and each of the boxes is an instance of an <code>list_item</code> struct, each with a member variable (called <code>next</code> in the code) of type <code>list_item *</code> that points to the next item.</p>
<p>The C implementation of the data structure is:</p>
<p><strong>注释：list的item包含两个成员：值和指针变量；list本身是用head指针表示</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> <span class="title">list_item</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We also include a (minimal) API:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The textbook version */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br><span class="line"><span class="comment">/* A more elegant solution */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br></pre></td></tr></table></figure>

<p>With that in place, let’s have a look at the implementations of <code>remove_cs101()</code> and <code>remove_elegant()</code>. The code of these examples is true to the pseudocode from Linus’ example and also compiles and runs.</p>
<h3 id="The-CS101-version"><a href="#The-CS101-version" class="headerlink" title="The CS101 version"></a>The CS101 version</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281919267.png" alt="image-20230328191958119"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item *cur = l-&gt;head, *prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != target) &#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev)</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                l-&gt;head = cur-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释：如果将list理解为(值+指针变量)成员组成的一串数据，那么访问一个成员的前置成员就得用经典的双指针法，因为单链表没有”记忆性”，要额外的前置指针保存前置位置。</strong></p>
<p><strong>考虑边界条件：1.遍历完了都找不到目标成员；2.前置指针在使用前要判空，如果为空，表明第一个节点就是目标节点，这两种情况都属于上述代码的else case处理</strong></p>
<p>The standard CS101 approach makes use of two traversal pointers <code>cur</code> and <code>prev</code>, marking the current and previous traversal position in the list, respectively.  <code>cur</code> starts at the list head <code>head</code>, and advances until the target is found.  <code>prev</code> starts at <code>NULL</code> and is subsequently updated with the previous value of <code>cur</code> every time <code>cur</code> advances. After the target is found, the algorithm tests if <code>prev</code> is non-<code>NULL</code>. If yes, the item is not at the beginning of the list and the removal consists of re-routing the linked list around <code>cur</code>. If <code>prev</code> is <code>NULL</code>, <code>cur</code> is pointing to the first element in the list, in which case, removal means moving the list head forward.</p>
<h3 id="A-more-elegant-solution"><a href="#A-more-elegant-solution" class="headerlink" title="A more elegant solution"></a>A more elegant solution</h3><p>The more elegant version has less code and does not require a separate branch to deal with deletion of the first element in a list.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code uses an indirect pointer <code>p</code> that holds the address of a pointer to a list item, starting with the address of <code>head</code>.  In every iteration, that pointer is advanced to hold the address of the pointer to the next list item, i.e. the address of the <code>next</code> element in the current <code>list_item</code>.<br>When the pointer to the list item <code>*p</code> equals <code>target</code>, we exit the search loop and remove the item from the list.</p>
<h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h2><p>The key insight is that using an indirect pointer <code>p</code> has two conceptual benefits:</p>
<ol>
<li>It allows us to interpret the linked list in a way that makes the <code>head</code> pointer an integral part the data structure. This eliminates the need for a special case to remove the first item.</li>
<li>It also allows us to evaluate the condition of the <code>while</code> loop without having to let go of the pointer that points to <code>target</code>. This allows us to modify the pointer that points to <code>target</code> and to get away with a single iterator as opposed to <code>prev</code> and <code>cur</code>.</li>
</ol>
<p>Let’s look each of these points in turn.</p>
<h3 id="Integrating-the-head-pointer"><a href="#Integrating-the-head-pointer" class="headerlink" title="Integrating the head pointer"></a>Integrating the <code>head</code> pointer</h3><p>The standard model interprets the linked list as a sequence of <code>list_item</code> instances. The beginning of the sequence can be accessed through a <code>head</code> pointer. This leads to the conceptual model illustrated in Figure 2 above. The <code>head</code> pointer is merely considered as a handle to access the start of the list. <code>prev</code> and <code>cur</code> are pointers of type <code>list_item *</code> and always point to an item or <code>NULL</code>.</p>
<p>The elegant implementation uses indirect addressing scheme that yields a different view on the data structure:</p>
<p><strong>注释：核心就是改变对链表数据结构的理解，将链表的最小单元理解为：前置指针 + (值+指针变量)成员，这样需要一个二级指针指向成员内的指针变量，链表也没有特殊性，每个成员一定有非空的前置指针和(值+指针变量)，如下图的蓝色框。</strong></p>
<p><strong>这个方法本质上是双指针的优化，只用一个二级指针就可以同时访问目标节点和前置的节点的指针变量，解决了单链表遍历过程中，找到目标节点后无法反向获得前置节点的指针变量的问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281920824.png" alt="image-20230328192017690"></p>
<p>Here, <code>p</code> is of type <code>list_item **</code> and holds the address of the pointer to the current list item. When we advance the pointer, we forward to the address of the pointer to the next list item.</p>
<p>In code, this translates to <code>p = &amp;(*p)-&gt;next</code>, meaning we</p>
<ol>
<li><code>(*p)</code>: dereference the address to the pointer to the current list item</li>
<li><code>-&gt;next</code>: dereference that pointer again and select the field that holds the address of the next list item</li>
<li><code>&amp;</code>: take the address of that address field (i.e. get a pointer to it)</li>
</ol>
<p>This corresponds to an interpretation of the data structure where the list is a a sequence of pointers to <code>list_item</code>s (cf. Figure 3).</p>
<h3 id="Maintaining-a-handle"><a href="#Maintaining-a-handle" class="headerlink" title="Maintaining a handle"></a>Maintaining a handle</h3><p>An additional benefit of that particular interpretation is that it supports editing the <code>next</code> pointer of the predecessor of the current item throughout the entire traversal.</p>
<p>With <code>p</code> holding the address of a pointer to a list item, the comparison in the search loop becomes</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (*p != target)</span><br></pre></td></tr></table></figure>

<p>The search loop will exit if <code>*p</code> equals <code>target</code>, and once it does, we are still able to modify <code>*p</code> since we hold its address <code>p</code>. Thus, despite iterating the loop until we hit <code>target</code>, we still maintain a handle (the address of the <code>next</code> field or the <code>head</code> pointer) that can be used to directly modify the pointer that points <em>to</em> the item.</p>
<p>This is the reason why we can modify the incoming pointer to an item to point to a different location using <code>*p = target-&gt;next</code> and why we do not need <code>prev</code> and <code>cur</code> pointers to traverse the list for item removal.</p>
<h2 id="Going-beyond"><a href="#Going-beyond" class="headerlink" title="Going beyond"></a>Going beyond</h2><p>It turns out that the idea behind <code>remove_elegant()</code> can be applied to yield a particularly concise implementation of another function in the list API:<code>insert_before()</code>, i.e. inserting a given item before another one.</p>
<h3 id="Inserting-before-existing-items"><a href="#Inserting-before-existing-items" class="headerlink" title="Inserting before existing items"></a>Inserting before existing items</h3><p>First, let’s add the following declaration to the list API in <code>list.h</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span>;</span><br></pre></td></tr></table></figure>

<p>The function will take a pointer to a list <code>l</code>, a pointer <code>before</code> to an item in that list and a pointer to a new list item <code>item</code> that the function will insert before <code>before</code>.</p>
<h3 id="Quick-refactor"><a href="#Quick-refactor" class="headerlink" title="Quick refactor"></a>Quick refactor</h3><p><strong>注释：单链表的删除节点和前向插入节点有共同的痛点：找到目标节点后无法反向获得前置节点的指针变量，此二级指针方法完美解决这类问题。</strong></p>
<p>Before we move on, we refactor the search loop into a separate function</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> list_item **<span class="title function_">find_indirect</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>and use that function in <code>remove_elegant()</code> like so</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, target);</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Implementing-insert-before"><a href="#Implementing-insert-before" class="headerlink" title="Implementing insert_before()"></a>Implementing <code>insert_before()</code></h3><p>Using <code>find_indirect()</code>, it is straightforward to implement <code>insert_before()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, before);</span><br><span class="line">        *p = item;</span><br><span class="line">        item-&gt;next = before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A particularly beautiful outcome is that the implementation has consistent semantics for the edge cases: if <code>before</code> points to the list head, the new item will be inserted at the beginning of the list, if <code>before</code> is <code>NULL</code> or invalid (i.e. the item does not exist in <code>l</code>), the new item will be appended at the end.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The premise of the more elegant solution for item deletion is a single, simple change: using an indirect <code>list_item **</code> pointer to iterate over the pointers to the list items.  Everything else flows from there: there is no need for a special case or branching and a single iterator is sufficient to find and remove the target item.<br>It also turns out that the same approach provides an elegant solution for item insertion in general and for insertion <em>before</em> an existing item in particular.</p>
<p>So, going back to Linus’ initial comment: is it good taste? Hard to say, but it’s certainly a different, creative and very elegant solution to a well-known CS task.</p>
]]></content>
      <categories>
        <category>github项目学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL类使用笔记</title>
    <url>/2020/12/01/C-STL%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><p><strong>查找指定字符串的位置（下标）</strong></p>
<p>string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）</p>
<pre><code>//find函数返回类型 size_type
string s(&quot;1a2b3c4d5e6f7jkg8h9i1a2b3c4d5e6f7g8ha9i&quot;);
int position;
//find 函数 返回jk 在s 中的下标位置
position = s.find(&quot;jk&quot;);
if (position != s.npos)  //如果没找到，返回一个特别的标志c++中用npos表示
&#123;
    printf(&quot;position is : %d\n&quot; ,position);
&#125;
else
&#123;
    printf(&quot;Not found the flag\n&quot;);
&#125;
</code></pre>
<p>##查找某字符首次出现，或最后出现的位置<br>find_first_of() 和 find_last_of()返回子串出现在母串中的首次出现的位置，和最后一次出现的位置<br>查找上面示例的’c’的下标：</p>
<pre><code>flag = &quot;c&quot;;
position = s.find_first_of(flag);
printf(&quot;s.find_first_of(flag) is :%d\n&quot;,position);
position = s.find_last_of(flag);
printf(&quot;s.find_last_of(flag) is :%d\n&quot;,position);
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081711721.png" alt="image-20221208171122674"></p>
<p><strong>查找某给定位置后的子串的位置</strong></p>
<pre><code>//从字符串s 下标5开始，查找字符串b ,返回b 在s 中的下标
position=s.find(&quot;b&quot;,5);
cout&lt;&lt;&quot;s.find(b,5) is : &quot;&lt;&lt;position&lt;&lt;endl;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081711350.png"></p>
<p><strong>查找所有子串在母串中出现的位置</strong></p>
<pre><code>//查找s 中flag 出现的所有位置。
flag=&quot;a&quot;;
position=0;
int i=1;
while((position=s.find(flag,position))!=string::npos)
&#123;
    cout&lt;&lt;&quot;position  &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;position&lt;&lt;endl;
    position++;
    i++;
&#125;
</code></pre>
<h1 id="map与unordered-map的区别"><a href="#map与unordered-map的区别" class="headerlink" title="map与unordered_map的区别"></a>map与unordered_map的区别</h1><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p><strong>map：</strong><br>map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），<strong>红黑树具有自动排序的功能，因此map内部的所有元素都是有序的</strong>，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>
<p><strong>unordered_map:</strong><br>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，<strong>查找的时间复杂度可达到O(1</strong>)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<h2 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h2><p><strong>map</strong><br>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。<br>红黑树结构：内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>
<p>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红&#x2F;黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map：</strong></p>
<p>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结：</strong><br>两种map性能分析的内存占用比较，就是红黑树 VS hash表的性能比较, 还是unorder_map占用的内存要高。<br>但是unordered_map查找的时间复杂度低，执行效率要比map高很多。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>unordered_map的用法和map是一样的，都提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。但其内部实现是不同的，对使用者来说不可见。</p>
<p>示例（map_and_unordered.cpp）：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;unordered_map&gt;  
#include &lt;map&gt;
#include &lt;string&gt;  

using namespace std;  

int main()  
&#123;  
    ////使用&#123;&#125;赋值, 注意：C++11才开始支持括号初始化
    unordered_map&lt;int, string&gt; myMap = &#123;&#123; 3, "C" &#125;,&#123; 4, "D" &#125;&#125;; 
    //使用[ ]进行单个插入，若已存在键值2，则修改其值
    myMap[1] = &quot;A&quot;;  
    myMap.insert(pair&lt;int, string&gt;(2, &quot;B&quot;));//使用insert和pair插入
  
    //遍历输出+迭代器的使用
    //auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator
    auto iter = myMap.begin(); 
    while (iter!= myMap.end())
    &#123;  
        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;  
        ++iter;  
    &#125;  
    
    //查找元素并输出+迭代器的使用
    //find()返回一个指向2的迭代器
    auto iterator = myMap.find(2);
    if (iterator != myMap.end())
        cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iterator-&gt;second &lt;&lt; endl;  
     
    return 0;  
&#125;
</code></pre>
<p>编译：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081713270.png" alt="image-20221208171339229"></p>
<p>结果：<br>unordered_map：没有按值的大小排序，从最近插入的到最早插入的，依次显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081714465.png" alt="image-20221208171412418"><br>把unordered_map改成map: 按值的大小，从小到大显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081713971.png" alt="image-20221208171351937"></p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>sort()函数是STL中的排序函数，由模板函数实现，复杂度N*logN。该函数专门用来对容器或普通数组中指定范围内的元素进行排序，该函数使用频率较高，且其实现综合了几种经典排序方法<br>使用格式如下：</p>
<pre><code>sort (first, last) //排序从first到last的数据，默认从小到大
sort (first, last, rule) //以某种规则排序，rule可使用std定义的，或自定义实现
</code></pre>
<h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><p>几种典型的使用方式：</p>
<ul>
<li>默认：从小到大</li>
<li>greater&lt; Type &gt;()：std提供的从大到小</li>
<li>自定义规则：函数，运算符，Lambda实现，这里规则都是传入两个参数（分别是要比较数组的靠左值，靠右值），返回bool类型，如果左值&lt;右值，即从小到大排序，反之从大到小</li>
</ul>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::sort
#include &lt;vector&gt;       // std::vector
#include &lt;stdlib.h&gt;

using namespace std;

//以普通函数的方式实现自定义排序规则
bool myComp(int i, int j) &#123;
    return (i &lt; j);
&#125;

//以对象的方式实现自定义排序规则
class myCompOper &#123;
public:
    bool operator() (int i, int j) &#123;
        return (i &gt; j);
    &#125;
&#125;;

//打印数组
void print_array(std::vector&lt;int&gt; &amp;a, const char *s)
&#123;
    printf(&quot;%s\n&quot;, s);
    vector&lt;int&gt;::iterator it;
    for (it = a.begin(); it != a.end(); ++it)
    &#123;
        printf(&quot;%d &quot;, *it);
    &#125;
    printf(&quot;\n&quot;);
&#125;

int main() &#123;
    //std::vector&lt;int&gt; array;
    //char num;
    //while(cin.get() != &#39;\n&#39;)
    //&#123;
    //    cin &gt;&gt; num;
    //    array.push_back(num);
    //&#125;

    vector&lt;int&gt; array&#123;1,3,4,2,5,7,6,8,9&#125;;
    print_array(array, &quot;input array:&quot;);

    //默认排序，从小到大
    std::sort(array.begin(), array.end());
    print_array(array, &quot;default sort:&quot;);

    //使用STL标准库提供的其它比较规则, 比如 greater&lt;T&gt;，从大到小
    std::sort(array.begin(), array.end(), std::greater&lt;int&gt;());
    print_array(array, &quot;std::greater&lt;T&gt; sort:&quot;);

    //自定义比较规则: 普通函数
    std::sort(array.begin(), array.end(), myComp);
    print_array(array, &quot;myComp sort:&quot;);

    //自定义比较规则: 类内运算符重载
    std::sort(array.begin(), array.end(), myCompOper());
    print_array(array, &quot;myCompOper sort:&quot;);

    //自定义比较规则: Lambda匿名函数
    std::sort(array.begin(), array.end(), [](int i, int j) &#123;return i &lt; j;&#125;);
    print_array(array, &quot;Lambda sort:&quot;);
</code></pre>
<p>​<br>        return 0;<br>    }</p>
<p>结果如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081715702.png" alt="image-20221208171536663"></p>
<h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p>
<p><strong>(1)普通快排</strong><br>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p>
<ul>
<li>如果S中的元素只有0个或1个，结束。</li>
<li>取S中的任何一个元素作为枢轴pivot。</li>
<li>将S分割为L、R两端，使L内的元素都小于等于pivot，R内的元素都大于等于pivot。 </li>
<li>对L、R递归执行上述过程。</li>
</ul>
<p>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称为median-of-three，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p>
<p>分割的方法通常采用两个迭代器head和tail，head从头端往尾端移动，tail从尾端往头端移动，当head遇到大于等于pivot的元素就停下来，tail遇到小于等于pivot的元素也停下来，若head迭代器仍然小于tail迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p>
<p><strong>(2)内省式排序 Introsort</strong><br>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 O(n2)。David R.Musser于1996年提出一种混合式排序算法：Introspective Sorting（内省式排序），简称IntroSort，其行为大部分与上面所说的median-of-three Quick Sort完全相同，但是当分割行为有恶化为二次方的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 O(nlgn)，又比一开始就使用堆排序来得好。</p>
<p>sort声明：</p>
<pre><code>#include &lt;algorithm&gt;
 
template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );
 
template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );
</code></pre>
<p>sort实现：</p>
<pre><code>template &lt;class _RandomAccessIter&gt;
inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123;
  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,
                 _LessThanComparable);
  if (__first != __last) &#123;
    __introsort_loop(__first, __last,
                     __VALUE_TYPE(__first),
                     __lg(__last - __first) * 2);
    __final_insertion_sort(__first, __last);
  &#125;
&#125;
</code></pre>
<p>__introsort_loop便是上面介绍的内省式排序，其第三个参数中所调用的函数__lg()便是用来控制分割恶化情况，求lg(n)（取下整），意味着快速排序的递归调用最多 2*lg(n) 层。<br>__lg()实现如下</p>
<pre><code>template &lt;class Size&gt;
inline Size __lg(Size n) &#123;
    Size k;
    for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k;
    return k;
&#125;
</code></pre>
<p>__introsort_loop实现：</p>
<ul>
<li>首先判断元素规模是否大于阀值__stl_threshold，__stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。</li>
<li>若元素规模大于__stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。</li>
<li>若没有超过递归调用深度，则调用函数__unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。</li>
<li>经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。</li>
</ul>
<p>递归上述过程，直到元素规模小于__stl_threshold，然后返回sort函数，对整个元素序列调用一次插入排序，此时序列中的元素已基本有序，所以插入排序也很快。至此，整个sort函数运行结束。</p>
<p>__introsort_loop代码：</p>
<pre><code>template &lt;class _RandomAccessIter, class _Tp, class _Size&gt;
void __introsort_loop(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Tp*,
                      _Size __depth_limit)
&#123;
  while (__last - __first &gt; __stl_threshold) &#123;
    if (__depth_limit == 0) &#123;
      partial_sort(__first, __last, __last);
      return;
    &#125;
    --__depth_limit;
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1))));
    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit);
    __last = __cut;
  &#125;
&#125;
</code></pre>
<p>__unguarded_partition()函数</p>
<pre><code>template &lt;class _RandomAccessIter, class _Tp&gt;
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, 
                                        _RandomAccessIter __last, 
                                        _Tp __pivot) 
&#123;
    while (true) &#123;
        while (*__first &lt; __pivot)
            ++__first;
        --__last;
        while (__pivot &lt; *__last)
            --__last;
        if (!(__first &lt; __last))
            return __first;
        iter_swap(__first, __last);
        ++__first;
    &#125;
&#125;
</code></pre>
<p>参考： 《STL源码剖析》–侯捷</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab笔记：CentOS7部署Gitlab服务</title>
    <url>/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>阿里云ECS, CentOS7, RAM 4G</p>
<h1 id="安装Gitlab"><a href="#安装Gitlab" class="headerlink" title="安装Gitlab"></a>安装Gitlab</h1><p>1.安装ssh并配置</p>
<pre><code>#安装
sudo yum install -y curl policycoreutils-python openssh-server
#配置开机启动
sudo systemctl enable sshd
#启动服务
sudo systemctl start sshd
</code></pre>
<p>2.配置防火墙</p>
<pre><code>#启动防火墙
service firewalld start
#添加http服务到firewalld,pemmanent表示永久生效
sudo firewall-cmd --permanent --add-service=http
#重启防火墙
sudo systemctl reload firewalld
</code></pre>
<p>3.安装gitlab</p>
<pre><code>#下载安装脚本
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash
#安装
yum install -y gitlab-ee
</code></pre>
<p>4.配置gitlab</p>
<pre><code>#gitlab配置文件
vim /etc/gitlab/gitlab.rb
#修改以下内容为主机ip和未使用的端口，否则使用默认端口8080
external_url &#39;http://47.100.221.149:9030&#39;
</code></pre>
<p>5.配置生效并重启gitlab</p>
<pre><code>#配置生效，改了配置需要运行
gitlab-ctl reconfigure
#重启服务，没改配置直接重启
gitlab-ctl restart
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061444445.png" alt="image-20221206144455394"><br>似乎服务都正常启动了，实际上可能有各种问题，参考问题记录</p>
<h1 id="问题Debug记录"><a href="#问题Debug记录" class="headerlink" title="问题Debug记录"></a>问题Debug记录</h1><p>按以上步骤配置好后，访问主机ip:端口，直接弹出502服务端错误<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061445877.png" alt="image-20221206144542817"></p>
<h2 id="配置文件权限问题"><a href="#配置文件权限问题" class="headerlink" title="配置文件权限问题?"></a>配置文件权限问题?</h2><p>配置文件生效命令<code>gitlab-ctl reconfigure</code>做了以下事情：</p>
<ul>
<li>配置设置写到gitlab服务直接调用的文件</li>
</ul>
<p>实际生效的配置文件：</p>
<pre><code>vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446719.png" alt="image-20221206144606669"><br>可见配置被自动拷贝到此处，gitlab相关服务读取的是这里的配置项</p>
<ul>
<li>生成服务相关临时文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446110.png" alt="image-20221206144619066"></p>
<p>原因：gitlab服务的配置文件在reconfigure时生成于&#x2F;var&#x2F;log&#x2F;gitlab，这个文件目录默认权限不够，有些子服务不能正常运行。</p>
<p>解决方法：</p>
<pre><code>chmod -R 777 /var/log/gitlab
</code></pre>
<p>restart服务，网页即可正常访问gitlab，如果恢复该目录755权限，重启服务会502</p>
<p>每次重新配置，<code>gitlab-ctl reconfigure</code>似乎会删除该目录再重新写入<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446151.png" alt="image-20221206144636079"></p>
<p>因此每次gitlab-ctl reconfigure之后都要<code>chmod 777</code>改此目录权限</p>
<h2 id="还有502问题"><a href="#还有502问题" class="headerlink" title="还有502问题?"></a>还有502问题?</h2><h3 id="检查阿里云端口"><a href="#检查阿里云端口" class="headerlink" title="检查阿里云端口"></a>检查阿里云端口</h3><p>首先确保主机ip是公网能访问的，不是内网ip<br>其次看端口是否禁用。在阿里云ECS的安全组策略中查看端口是否允许TCP输入输出<br>我把所有端口（1~65535）全部打开了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446454.png" alt="image-20221206144656411"></p>
<h3 id="检查前向端口冲突"><a href="#检查前向端口冲突" class="headerlink" title="检查前向端口冲突"></a>检查前向端口冲突</h3><p>gitlab配置文件的external_url就包含前向端口</p>
<pre><code>netstat -nlp | grep 9030 (我的gitlab前向端口)
</code></pre>
<p>显示的是nginx服务端口，因为gitlab默认被nginx反向代理了，说明gitlab的代理服务确实占用9030。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449545.png" alt="image-20221206144927508"></p>
<h3 id="检查子服务的端口"><a href="#检查子服务的端口" class="headerlink" title="检查子服务的端口"></a>检查子服务的端口</h3><p>注意gitlab不只有一个服务，默认配置只设置了前向端口（nginx代理端口），而子服务都没配置端口，默认用了8080，如果有其他服务已经占用8080，可能子服务起不来<br>例如unicorn子服务：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449220.png" alt="image-20221206144946178"></p>
<p>查看子服务状态</p>
<pre><code>gitlab-ctl status
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449573.png" alt="image-20221206144958510"></p>
<p>如果本地已有8080的服务，最好杀掉或换其他端口，否则要手动配置gitlab子服务端口</p>
<pre><code>unicorn[&#39;port&#39;] = 9032 （随便一个未使用端口）
gitlab_workhorse[&#39;auth_backend&#39;] = &quot;http://localhost:9032&quot;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450285.png" alt="image-20221206145014236"></p>
<h3 id="检查内存资源不足"><a href="#检查内存资源不足" class="headerlink" title="检查内存资源不足"></a>检查内存资源不足</h3><p>阿里云2G以下RAM可能会有因内存不足，导致服务不能正常启动。<br>使用swap交换分区，避免内存不足的可能性。swap分区可以把部分内存分页存储到磁盘，变相“扩大”内存</p>
<pre><code>#查看现有swap分区，若未分配大小为0
cat /proc/swaps
#创建swap文件，大小4G，挂载到/mnt。交换分区可以使用真正的分区，或者以文件形式的分区
dd if=/dev/zero of=/mnt/swap bs=512 count=8388616
#使之成为swap分区
mkswap /mnt/swap
#修改swap分区配置
cat /proc/sys/vm/swappiness
sysctl -w vm.swappiness=60
#swap分区配置永久生效
vim /etc/sysctl.conf
修改vm.swappiness=60
#启动分区
swapon /mnt/swap
echo “/mnt/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab
#停用分区
swapoff /mnt/swap
swapoff -a &gt; /dev/null
</code></pre>
<p>启用分区后运行gitlab，发现已经有一部分数据转移到了swap文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450437.png" alt="image-20221206145023389"></p>
<h1 id="ssh访问配置"><a href="#ssh访问配置" class="headerlink" title="ssh访问配置"></a>ssh访问配置</h1><p>通过ssh上传下载，需要建立ssh key</p>
<pre><code>ssh-keygen   #一路回车
</code></pre>
<p>若创建成功，查看生成的公钥：</p>
<pre><code>cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yXXXXXXXX
</code></pre>
<p>添加公钥至gitlab</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450049.png" alt="image-20221206145031977"></p>
<h1 id="初始化git项目"><a href="#初始化git项目" class="headerlink" title="初始化git项目"></a>初始化git项目</h1><p>配置git全局用户名，邮箱</p>
<pre><code>git config --global user.name &quot;YOUR NAME&quot;
git config --global user.email &quot;YOUR EMAIL@xxx.com&quot;
</code></pre>
<p>初始化git仓库<br>可以通过xftp上传项目文件夹到gitlab服务器，再到目录内初始化.git仓库。</p>
<pre><code>cd project_folder (项目文件夹)
git init
git remote add origin git@YOUR_IP:YOUR_NAME/project_folder.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
</code></pre>
<p>这样在网页上可看到gitlab有首次commit的文件，后续也可以顺利提交和下载。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Git多人协作下的换行符问题</title>
    <url>/2020/09/06/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E4%B8%8B%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目文件中有如下类型文件：</p>
<pre><code>Makefile, .sh, .bat, .cfg, .exe
</code></pre>
<p>源码用git管理，客户端用cygwin实现windows内的linux环境</p>
<p>问题：如何解决git多人协作下的linux、windows换行符差异问题？</p>
<p>(1)什么是换行符<br>LF：”\n”，Linux的换行符, 只包含“换行”；<br>CRLF：”\r\n”，Windows的换行符，包含“回车+换行”;</p>
<p>(2)不同换行符带来什么问题<br>用git管理代码，必定有远程端和本地端两个仓库，两端的操作系统不同，换行符可能有差异;</p>
<p>多人协作时，本地端可能有linux环境和windows, 如果所有人都是linux就不存在换行符差异的问题；如果有windows和linux就有该问题;<br>例如A上传了Linux换行符LF的代码到远程，B 本地环境是windows, B git pull下来，其git-config设置了自动转换成本地换行，将代码换行全成了CRLF，B上传后，远程仓库变成CRLF换行。此时A git diff查看，所有代码都有换行差异，扰乱真正的代码diff。</p>
<p>不仅是影响git diff， 换行差异还影响脚本执行</p>
<ul>
<li>例如LF换行的.sh，git pull到windows环境后换行转换成CRLF, 导致sh无法正常执行；</li>
<li>.bat调用.exe读取.cfg内的一行，.exe是windows程序，其readline方法只能识别CRLF换行，无法读取LF换行的.cfg文件内容</li>
</ul>
<h1 id="git的自动换行符转换配置"><a href="#git的自动换行符转换配置" class="headerlink" title="git的自动换行符转换配置"></a>git的自动换行符转换配置</h1><p>参考：<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git">core.autocrlf</a></p>
<p>假如你正在 Windows 上写程序，而其他人用的是其他系统（或相反），你可能会遇到 CRLF 问题。 这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 macOS 和 Linux 只使用换行（LF）一个字符。 虽然这是小问题，但它会极大地扰乱跨平台协作。许多 Windows 上的编辑器会悄悄把行尾的换行字符转换成回车和换行， 或在用户按下 Enter 键时，插入回车和换行两个字符。</p>
<p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。 你可以用 core.autocrlf 来打开此项功能。 如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<pre><code>$ git config --global core.autocrlf true
</code></pre>
<p>如果使用以换行作为行结束符的 Linux 或 macOS，你不需要 Git 在检出文件时进行自动的转换； 然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p>
<pre><code>$ git config --global core.autocrlf input
</code></pre>
<p>这样在 Windows 上的检出文件中会保留回车和换行，而在 macOS 和 Linux 上，以及版本库中会保留换行。</p>
<p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中：</p>
<pre><code>$ git config --global core.autocrlf false
</code></pre>
<p><strong>使用<code>git config --global core.autocrlf input</code>就可以做到windows的CRLF换行自动转换成LF换行存储在git远程仓库，且git pull&#x2F;clone到本地时维持LF换行，不影响.sh等linux shell script执行。</strong></p>
<h1 id="手动换行符转换"><a href="#手动换行符转换" class="headerlink" title="手动换行符转换"></a>手动换行符转换</h1><ul>
<li><p>dos2unix FilePath</p>
</li>
<li><p>unix2dos FilePath</p>
</li>
<li><p>windows2linux</p>
<p> sed -i ‘s&#x2F;.$&#x2F;&#x2F;‘ FilePath</p>
</li>
<li><p>linux2windows</p>
<p> sed -i ‘s&#x2F;$&#x2F;\r&#x2F;‘ FilePath</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作笔记</title>
    <url>/2020/12/03/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="拉取和同步"><a href="#拉取和同步" class="headerlink" title="拉取和同步"></a>拉取和同步</h2><pre><code>git clone http://xxx.xxx.git //http方式, 从远程clone仓库
git pull //拉取远程分支
git branch //查看本地
git branch -a //查看远程和本地
git checkout xxxbranch //本地切到某分支
git checkout xxx/xxx //仅拉取部分目录或文件
</code></pre>
<h2 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a>推送到远程</h2><pre><code>git add -A //推送所有修改到本地仓库
git commit -m &quot;change logs&quot; //提交到本地仓库（记录修改信息）
git push //推送本地分支到远程的同名分支，需要先关联
git push origin &lt;本地分支名&gt; //推送本地分支到远程同名分支
git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; //推送本地分支到远程指定分支
</code></pre>
<h2 id="加tag-x2F-删tag"><a href="#加tag-x2F-删tag" class="headerlink" title="加tag&#x2F;删tag"></a>加tag&#x2F;删tag</h2><pre><code>git tag -a TAGNAME -m &quot;TAG LOG&quot; //加tag
git push origin TAGNAME //推送tag到远程
git tag -d TAGNAME //删除本地tag
git push origin :refs/tags/TAGNAME //删除远程tag
</code></pre>
<h2 id="创建-x2F-删除-x2F-修改分支"><a href="#创建-x2F-删除-x2F-修改分支" class="headerlink" title="创建&#x2F;删除&#x2F;修改分支"></a>创建&#x2F;删除&#x2F;修改分支</h2><p>创建分支并关联远程</p>
<pre><code>git checkout -b BRANCH_NAME //本地创建分支
git push origin BRANCH_NAME //推送到远程
git push --set-upstream origin BRANCH_NAME //关联远程，便于以后分支pull/push
</code></pre>
<p>删除本地分支    </p>
<pre><code>git branch -d branch_name
git branch -D branch_name //强制删除
</code></pre>
<p>删除远程分支</p>
<pre><code>git push origin -d branch_name
</code></pre>
<p>分支重命名(本地)</p>
<pre><code>git branch -m OLD_NAME NEW_NAME
</code></pre>
<h2 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h2><p>可以用<code>git diff --help</code>直接查看git diff的Manual Page</p>
<pre><code>git diff COMMIT_ID //比较本地和某commit_id的内容
git diff ID1 ID2 //比较两个提交的内容，比较新增时，旧版本在前，新版本在后
git diff &lt;path of file&gt; //比较本地某文件的内容
git diff --name-only ID1 ID2 //只显示有差异的文件名列表
git diff &lt;commit&gt;..&lt;commit&gt; [&lt;path&gt;…​] //比较两个提交中指定文件名或者路径的差异
</code></pre>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre><code>git reset --hard HEAD^ //回退到上个版本
git reset --hard HEAD^^ //回退到上上个版本
git reset --hard COMMIT_ID //回退到指定提交
git push -f //强制提交，覆盖远程，使远程也回退
git push origin master -f //强制推送到远程的master分支
</code></pre>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>两个分支A和B，要把分支B的所有提交合并到A分支上</p>
<pre><code>git checkout &lt;branch A&gt; //切到待合并分支A
git merge &lt;branch B&gt; //拉取分支B，合并到当前分支A
git merge &lt;branch B&gt;  --squash //合并分支，将B的多个提交融合成一个再合并到A，而不是B的所有提交记录都照搬到A（这个更常用）
git merge --abort //终止合并
</code></pre>
<p>如果有<code>merge conflict</code>,手动修改冲突文件-&gt;保存文件-&gt;<code>git add -A</code>提交修改-&gt;<code>git commit -m &quot;xxx&quot;</code>提交该合并</p>
<p>如果本地仓库已经处于待merge状态，又想取消merge,同步成远程仓库状态，只需要reset本地仓库到当前commit-id</p>
<pre><code>git reset --hard HEAD
</code></pre>
<p>也可以reset到指定commit-id:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog &amp;&amp; git reset --hard commit-id</span><br></pre></td></tr></table></figure>

<h2 id="合并提交"><a href="#合并提交" class="headerlink" title="合并提交"></a>合并提交</h2><h3 id="合并当前提交"><a href="#合并当前提交" class="headerlink" title="合并当前提交"></a>合并当前提交</h3><p>如果当前修改还未提交, 想合并到最近的一次提交里，例如最近提交有个错误，可以用<code>--amend</code>修订提交</p>
<pre><code>git add -A
git commit --amend
git push -f //amend后通常强制推送，因为没有新增commit
</code></pre>
<h3 id="合并历史提交"><a href="#合并历史提交" class="headerlink" title="合并历史提交"></a>合并历史提交</h3><p>有时同一个功能分多次提交，提交过于频繁，需要合并成一个提交。<br>如下有三次提交</p>
<pre><code>$git log
commit_3: xxxxx
    message_3 ....
commit_2: xxxxx
    message_2 ....
commit_1: xxxxx
    message_1 ....
</code></pre>
<p>现在想把commit_3 和 commit_2合并成一个commit.</p>
<pre><code>git rebase -i commit_1 //重定位到要合并的前一个提交
</code></pre>
<p>进入commit信息编辑模式：</p>
<pre><code>pick commit_2 message_2...
pick commit_3 message_3...
</code></pre>
<p>将要合并的commit_3前的属性<code>pick</code>（选用）改为<code>squash</code>（压扁），<code>wq</code>保存，进入当前合并commit的信息提交界面，再次<code>wq</code>保存, 查看合并后提交记录如下：</p>
<pre><code>$git log
commit_4: xxxxx
    message_3 ....
    message_2 ....
commit_1: xxxxx
    message_1 ....
</code></pre>
<p>两次提交已合成一次（新的）提交</p>
<h1 id="多人提交的冲突解决办法"><a href="#多人提交的冲突解决办法" class="headerlink" title="多人提交的冲突解决办法"></a>多人提交的冲突解决办法</h1><p>A和B同时开发某项目的同一个分支，A拉取最新版本1.0后，在本地新增功能，此时B也在1.0上修改并提交到了新版本1.1到远程仓库。A在B提交之后再提交，发现自己本地的修改已是旧版本，无法直接提交，如下图是A的add,commit,push三连的结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051005366.png" alt="1631249531971_115"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051006842.png" alt="image-20221205100655798"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051007268.png" alt="image-20221205100726224"></p>
<h3 id="手动解决conflict"><a href="#手动解决conflict" class="headerlink" title="手动解决conflict"></a>手动解决conflict</h3><p><code>git pull</code> 拉取远程仓库最新版本，此时有两种情况</p>
<ul>
<li>代码有冲突，需手动修改冲突区域的代码块，二选一，然后重新add-commit-push三连提交</li>
<li>无冲突，pull代码会自动合并，直接重新三连提交即可</li>
</ul>
<p>以下是有冲突的情况<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051008610.png" alt="image-20221205100836563"></p>
<p>找到冲突源码，冲突的符号定义如下：</p>
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt; HEAD</code>：当前本地的代码块</li>
<li><code>======</code>：分割冲突块</li>
<li><code>&gt;&gt;&gt;&gt;&gt;&gt;b699a7fc</code>：远程最新hash版本号的代码块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051008970.png" alt="image-20221205100855921"></p>
<p>修改方法：先拷贝冲突关键语句，再删除所有冲突域符号，最后只保留如下代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051019814.png" alt="image-20221205101900769"></p>
<p>修改完后，<code>git add, git commit, git push</code>，成功提交<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051020311.png" alt="image-20221205102021265"></p>
<p>查看提交后版本：<code>git log</code></p>
<h3 id="修改某次提交的commit信息"><a href="#修改某次提交的commit信息" class="headerlink" title="修改某次提交的commit信息"></a>修改某次提交的commit信息</h3><p>有时需要修改commit信息便于区分哪个是解决冲突后的提交<br>解决方案：</p>
<ul>
<li>修改最新的commit，只需要amend修改commit信息后，再push</li>
<li>修改历史的commit，需要先rebase修改属性为edit后，再commit –amend</li>
</ul>
<p>下面讲修改历史commit<br>如下图，想修改9877的commit信息<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051023197.png" alt="image-20221205102348131"></p>
<p>先rebase到之前的commit<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051024479.png" alt="image-20221205102432433"><br>显示其后的版本属性如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051024531.png" alt="image-20221205102447476"><br>修改9877的属性为edit(待编辑模式)，将原始commit改成如下内容,<code>:wq</code>保存:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051026868.png" alt="image-20221205102658821"></p>
<p>然后<code>commit --amend, rebase --continue</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051027201.png" alt="image-20221205102751155"><br>再查看下git og修改成功<br>最后<code>git push</code>同步到远程仓库</p>
<h1 id="从另一个分支拉取指定的几个commit内容"><a href="#从另一个分支拉取指定的几个commit内容" class="headerlink" title="从另一个分支拉取指定的几个commit内容"></a>从另一个分支拉取指定的几个commit内容</h1><p>A和B都在git的master分支提交代码，一天发现master某个版本有问题，回退n各版本都找不到是谁提交引起的问题，由于master还要作稳定测试等其他用途，决定先回退master分支到较早的指定版本，而master最新版和稳定版之间提交的内容，分别由各自A和B“认领”，拉取master上自己提交的功能到自己的分支，debug好以后在合并回master。<br>需求：<br>如何在开发者分支上拉取master分支的指定几个commit的内容，注意不是某个commit以前的内容，是commit内的内容？</p>
<h2 id="创建自己分支，回退master"><a href="#创建自己分支，回退master" class="headerlink" title="创建自己分支，回退master"></a>创建自己分支，回退master</h2><p>首先切到master分支上，创建一个自己的分支thomas，自己分支是master的拷贝</p>
<pre><code>git checkout master //当前在那个分支，决定创建分支的内容
git checkout -b thomas //做两件事：在本地创建thomas分支，内容和master一样；切到thomas分支
git push --set-upstream origin thomas //推送分支到远程，这步很容易漏掉
git branch //查看当前在哪个分支
git branch -a //查看所有分支
</code></pre>
<p>以上操作完成后，自己分支就创建好了，注意动作只影响到本地仓库的.git文件，要同步远程仓库还要push到远程<br>下面备份master, 再回退master</p>
<pre><code>git checkout master
git checkout -b master_backup //先备份master,上面有自己分支要拉取的内容
git checkout master //切到master,准备回退
git reset --hard COMMIT_ID //回退到稳定版本commit_id
git push -f //由于是回退，提交比远程的还早，一般需要强制提交，这个操作也会把本地的.git修改一同提交到远程
</code></pre>
<p>这样就有三个分支：</p>
<pre><code>master: 包含稳定版本的旧代码
master_backup: master的备份，包含稳定版和之后的A、B的一些提交
thomas: 开发者A的个人分支，现在和master稳定版完全一样
</code></pre>
<p>下面只需要从master_backup拉取自己相关的提交到thomas分支即可。</p>
<h2 id="cherry-pick拉取指定commit"><a href="#cherry-pick拉取指定commit" class="headerlink" title="cherry-pick拉取指定commit"></a>cherry-pick拉取指定commit</h2><p>先把要拉取的commit id存起来：</p>
<pre><code>git checkout master_backup
git log &gt; ../master_backup.log
</code></pre>
<p>截取commit log片段如图<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051038438.png" alt="image-20221205103857374"></p>
<p>切到thomas分支，拉取master_backup的commit</p>
<pre><code>git checkout thomas
git cherry-pick 3d6b3be
</code></pre>
<p>这种方法只拉了一个commit, 更好的方式是按功能，一次拉多个commit,甚至一次把所有的commit都拉完。<br>cherry-pick支持多个pick一步到位<br>例如git log如下</p>
<pre><code>commit4 id4
commit3 id3
commit2 id2
commit1 id1
</code></pre>
<p>离散拉取：只拉取id1和id4：</p>
<pre><code>git cherry-pick id1 id4
</code></pre>
<p>！注意，提交顺序很重要，旧版本写在前新版本写在后<br>如果是区间拉取,即全部的id1，id2, id3，id4</p>
<pre><code>git cherry-pick id1..id4 //加两个点即为区间拉取
</code></pre>
<p>为了验证是不是真的拉取了多个版本，可以<code>git diff --name-only id1 id4</code>看下拉取后的修改哪些文件，对比被拉取分支的修改，如果一致，说明确实拉取多个commit<br>对于上图的commit，建议按功能多次cherry-pick并commit+push，便于后续debug。</p>
<h2 id="cherry-pick的冲突问题"><a href="#cherry-pick的冲突问题" class="headerlink" title="cherry-pick的冲突问题"></a>cherry-pick的冲突问题</h2><p>cherry-pick也是合并，只要是合并代码，就可能有冲突<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051039238.png" alt="image-20221205103926181"><br>合并单个commit,使用使用常规的冲突解决办法即可：</p>
<ul>
<li>到源码改冲突， <code>&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;</code>三个标记之间代码块二选一</li>
<li><code>git status</code>查看哪些待提交</li>
<li><code>git add -A</code>提交修改后的源码到本地.git</li>
</ul>
<h3 id="单个提交的冲突解决"><a href="#单个提交的冲突解决" class="headerlink" title="单个提交的冲突解决"></a>单个提交的冲突解决</h3><p>由于是从其他分支的commit id合并到当前分支（HEAD）,可以不加考虑的删掉<code>&lt;&lt;&lt;&lt;HEAD</code>和<code>====</code>之间的内容，采用<code>====</code>和<code>commit_id</code>之间的内容，随后删掉三个标记即可。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051039681.png" alt="image-20221205103951579"><br>有可能出现冲突代码块有重叠区的情况</p>
<pre><code>&lt;&lt;&lt;&lt; HEAD
code 1
=====
&lt;&lt;&lt;&lt; commit_id 1
code 2
&gt;&gt;&gt;&gt; commit_id 2
code 3
=====
code 4
&gt;&gt;&gt;&gt; commit_id 3
</code></pre>
<p>只要确定一个原则：&lt;&lt;&lt;&lt;是冲突块的起始点，&#x3D;&#x3D;&#x3D;&#x3D;是分界，&gt;&gt;&gt;&gt;是终止点，分两步删代码就可以了。</p>
<h3 id="多个提交的冲突解决："><a href="#多个提交的冲突解决：" class="headerlink" title="多个提交的冲突解决："></a>多个提交的冲突解决：</h3><p>如果是cherry-pick多个commit，冲突的解决方法就不一样了。<br>其区别在于，多个commit_id的cherry-pick，一旦遇到冲突，就会停下pick,需要手动解决冲突后，用<code>cherry-pick --continue</code>继续接下来的commit合并，直到由遇到冲突，再次手动解决。也就是说冲突会阻塞多个commit的cherry-pick，它不会一次性合并所有commit,让你一次性解决冲突。具体流程如下：</p>
<ul>
<li><code>cherry-pick id1 id2 id3 id4 .... idn</code></li>
<li>冲突报错，到源码手动解决</li>
<li><code>git add -A</code> 添加解决冲突后的文件到.git</li>
<li><code>cherry-pick --continue</code> 继续后面的合并,cherry-pick成功会自动提交commit信息</li>
<li>再遇到冲突，再次解决….</li>
<li>所有id1 … idn全部pick完成</li>
</ul>
<p>批量cherry-pick每次成功后都会有一次commit信息，有时候会报错，需要手动commit之后再continue</p>
<h3 id="特殊的冲突情况"><a href="#特殊的冲突情况" class="headerlink" title="特殊的冲突情况"></a>特殊的冲突情况</h3><p>提示有一个commit是合并的提交，即这个提交是两个分支的交汇，cherry-pick不知道以哪个分支为准<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040545.png" alt="image-20221205104005491"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040453.png" alt="image-20221205104017399"></p>
<p>如何解决：cherry-pick添加-m 1选项</p>
<pre><code>For example, if your commit tree is like below:

- A - D - E - F -   master
   \     /
    B - C           branch one
then git cherry-pick E will produce the issue you faced.

git cherry-pick E -m 1 means using D-E, while git cherry-pick E -m 2 means using B-C-E
</code></pre>
<p>例如选择cherry-pick commid_id -m 1, 结果如下，可手动解决冲突了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040782.png" alt="image-20221205104053730"><br>注意有merge的commit,会包含其他人的更新，如果只是pick自己的代码，不需要pick带merge的commit.</p>
<h1 id="跨仓库合并代码"><a href="#跨仓库合并代码" class="headerlink" title="跨仓库合并代码"></a>跨仓库合并代码</h1><p>假设某公司windows driver主线仓库为storport, 为了某产品定制的driver仓库为gg8, 现在gg8的所有feature已充分测试，准备合并到主线仓库storport, 这两个仓库的代码差异非常大，维护者众多，如何处理？</p>
<p>首先划分代码各部分归谁负责：<br>每个人用git，找出其在gg8仓库的个人修改，用winmerge手动合并到主线仓库storport<br>那么具体如何高效，可靠的合并：</p>
<p>git部分：<br>用git只找差异部分，具体操作：</p>
<pre><code>git diff commit_a commit_b //找所有文件+代码差异
git diff commit_a commit_b --stat //只显示有差异的文件名，这个信息对应winmerge手动合并很重要
git diff commit_a commit_b 指定文件路径 //只显示指定文件的内容差异，这个信息对应winmerge手动合并很重要
</code></pre>
<p>winmerge部分：<br>winmerge可以比较两个仓库所有差异，但是有些差异可能不需要合并，例如换行，修改时间等。总之winmerge的差异有很多“误报”<br>如果只一个个打开有差异的文件去比效率太低，需要借助git定位到哪些该开发者负责的文件有改变，以及文件内哪些代码是该开发者改变的。</p>
<p>找出某开发者A的提交改了哪些文件：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046241.png" alt="image-20221205104623191"></p>
<p>找出具体代码：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046320.png"></p>
<p>winmerge直接合并：<br>只是一句打印差异，但是如果不用git先定位，要从左侧差异栏找出此代码，相当困难<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046886.png" alt="image-20221205104642794"></p>
<p>这样，开发者A在代码合并过程中，完全不受其他开发者B, C的差异代码干扰</p>
<h1 id="强制覆盖本地代码"><a href="#强制覆盖本地代码" class="headerlink" title="强制覆盖本地代码"></a>强制覆盖本地代码</h1><p>git本地代码有时checkout到旧版本代码，想回到最新版本时，直接pull无法成功，且强制pull也不行。有以下两种方式解决：</p>
<h2 id="重新克隆"><a href="#重新克隆" class="headerlink" title="重新克隆"></a>重新克隆</h2><p>最简单是直接删掉本地项目，再重新<code>git clone</code></p>
<h2 id="fetch覆盖"><a href="#fetch覆盖" class="headerlink" title="fetch覆盖"></a>fetch覆盖</h2><pre><code>git fetch --all //拉取远程repo所有branch到本地，但不合并到本地repo
git reset --hard origin/master //本地repo强制同步远程repo的master分支
git pull -f //强制拉取远程repo最新代码
</code></pre>
<p>注意，如果本地旧版本代码有xxx.c，而远程最新代码没这个文件，本地需要手动删掉这个文件。因为以上操作不会删除本地文件，只会拉取本地没有的，或者覆盖不同的文件到本地。为了确保旧版本多出的文件删除，直接删除目录下除了<code>.git</code>以外的所有项目文件，再<code>fetch,reset,pull</code></p>
<h1 id="将本地未初始化git的项目上传到远程已初始化的git仓库"><a href="#将本地未初始化git的项目上传到远程已初始化的git仓库" class="headerlink" title="将本地未初始化git的项目上传到远程已初始化的git仓库"></a>将本地未初始化git的项目上传到远程已初始化的git仓库</h1><p>有一些项目代码是基于开源的庞大项目基础上开发，例如UEFI EDK2, Linux kernel.</p>
<p>项目开发时，可能基于不同的开源项目版本，例如：</p>
<p>远程git仓库是EDK2版本A0 + 自定义功能B0；本地的新功能是基于EDK2版本A1 + 自定义功能B1，且本地项目还没有初始化git。这种情况如何将本地项目直接上传到远程已有的项目上面去？</p>
<p>1.首先在本地建立git仓库</p>
<p>在本地新项目目录初始化git仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit信息&quot;</span><br></pre></td></tr></table></figure>

<p>2.将本地git仓库关联到远程已有的git仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin http://远程仓库地址.git</span><br></pre></td></tr></table></figure>

<p>3.拉取远程仓库到本地 (如果远程仓库为空不需要此步)</p>
<p>注意<code>--allow-unrelated-histories</code>是忽略本地项目和远程项目没有历史关联的关键参数，否则不能pull成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<p>合并代码通常会有冲突，手动解决冲突后再<code>git add, git commit -m &quot;fix merge conflict&quot;</code></p>
<p>4.最后推送本地仓库到远程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<h1 id="链接外部repo作为子模块"><a href="#链接外部repo作为子模块" class="headerlink" title="链接外部repo作为子模块"></a>链接外部repo作为子模块</h1><p>在github的项目仓库中，通常看到如下有@符号的外部仓库链接，点进去可能打开其他的项目仓库。这种外部仓库相当于当前项目仓库的子模块。</p>
<p>类似于Linux的软链接，子模块方式可以链接到其他项目仓库，并自动同步其他仓库最新的代码。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212091106114.png" alt="image-20221209110659056"></p>
<p>1.如何创建外部repo的链接:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add &quot;外部repo地址.git&quot; 外部repo文件夹名</span><br></pre></td></tr></table></figure>

<p>本地就clone了外部仓库到外部repo文件夹名中, 提交本项目和正常的提交流程相同</p>
<p>2.如何clone带外部repo的项目：</p>
<p>git clone 的时候需要加上<code>--recursive</code>，否则外部repo文件夹是空文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --recursive &quot;项目地址.git&quot;</span><br></pre></td></tr></table></figure>

<p>如果已经忘记加<code>--recursive</code>，可以手动初始化子模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h1 id="Git的常用配置"><a href="#Git的常用配置" class="headerlink" title="Git的常用配置"></a>Git的常用配置</h1><h2 id="配置多组用户信息"><a href="#配置多组用户信息" class="headerlink" title="配置多组用户信息"></a>配置多组用户信息</h2><p>git上传代码时会提交用户信息，包括姓名和邮箱，这个配置是本地的git配置文件决定。</p>
<p>如果要按项目配置多组用户信息，例如公司的代码以公司邮箱提交到公司内部的gitlab，个人项目的代码以个人邮箱提交到github，如何配置？</p>
<p>下面分别介绍全局配置、按项目配置和按文件目录配置三种git配置方法。</p>
<p>（1）git配置文件的位置</p>
<p>git配置文件为.gitconfig。对于windows, 一般在’C:\Users\用户名‘目录下，可以用everything查找.gitconfig，对于Linux, 一般在home目录。本文以windows为例。</p>
<p>（2）全局配置</p>
<p>.gitconfig里面默认的user字段就是全局的配置，首次使用git提交会提示用户输入此信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = youName</span><br><span class="line">    email = youEmail@example.com</span><br></pre></td></tr></table></figure>

<p>全局配置的查看和修改使用<code>--global</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name                           // 查询全局用户名</span><br><span class="line">git config --global user.name youName                   // 修改全局用户名</span><br><span class="line">git config --global user.email                          // 查询全局邮箱</span><br><span class="line">git config --global user.email youEmail@example.com     // 修改全局邮箱</span><br></pre></td></tr></table></figure>

<p>（3）对某个git项目自定义配置</p>
<p>这种方法的作用域只是某一个git项目，用的比较少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name                           // 查询项目用户名</span><br><span class="line">git config user.name youName                   // 修改项目用户名</span><br><span class="line">git config user.email                          // 查询项目邮箱</span><br><span class="line">git config user.email youEmail@example.com     // 修改项目邮箱</span><br></pre></td></tr></table></figure>

<p>（3）对某个路径下的所有git项目自定义配置</p>
<p>git的<code>Conditional Includes</code>可以针对文件夹配置，在.gitconfig添加如下格式的includeIf字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:path/to/you/gitdir/&quot;]</span><br><span class="line">    path = ~/.gitconfig_self</span><br></pre></td></tr></table></figure>

<p>其中path&#x2F;to&#x2F;you&#x2F;gitdir&#x2F;是要自定义配置的路径，可以包含很多git项目。注意尾部必须要加&#x2F;</p>
<p>.gitconfig_self是自定义配置的gitconfig文件，在里面指定[user]字段</p>
<p>例如我的自定义路径是F:&#x2F;github-my， 自定义配置文件.gitconfig_mygithub，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:F:/github-my/&quot;]</span><br><span class="line">    path = C:/Users/thomas.hu/.gitconfig_mygithub</span><br></pre></td></tr></table></figure>

<p>注意windows上不能直接右键创建只有后缀名的文件，会提示“必须键入文件名”。</p>
<p>使用CMD或Powershell的命令行创建.gitconfig_mygithub：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\Users\thomas.hu</span><br><span class="line">echo &gt; .gitconfig_mygithub</span><br></pre></td></tr></table></figure>

<p>.gitconfig_mygithub定义我个人项目的信息，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = cursorhu</span><br><span class="line">    email = 2449055512@qq.com</span><br></pre></td></tr></table></figure>

<p>全局的.gitconfig是公司项目信息，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">	name = thomas.hu</span><br><span class="line">	email = thomas.hu@xxx.com</span><br></pre></td></tr></table></figure>

<p>配置.gitconfig_mygithub完成后可见两种配置都生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git config --global user.name</span><br><span class="line">thomas.hu</span><br><span class="line">&gt; git config user.name</span><br><span class="line">cursorhu</span><br></pre></td></tr></table></figure>

<p>（4）三种配置文件的优先级</p>
<p>git使用以上三种配置的优先级为：项目配置 &gt; 路径配置 &gt; 全局配置</p>
<h2 id="换行符的配置"><a href="#换行符的配置" class="headerlink" title="换行符的配置"></a>换行符的配置</h2><p>为了解决跨平台的文件换行符问题，git支持自定义配置换行符规则。</p>
<p>（1）跨平台的文件换行符的相关背景</p>
<p>在各操作系统下，文本文件所使用的换行符是不一样的。UNIX&#x2F;Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是 0x0D（CR），后来的 OS X 版本与 UNIX 保持一致了。但 DOS&#x2F;Windows 使用 0x0D0A（CRLF）作为换行符。也就是说，在不同平台上写代码，其代码文件和一些项目配置文件的换行不一样。</p>
<p>（2）Git工具的autocrlf </p>
<p>Git最开始只支持类Unix的LF换行符，为了支持Windows开发的CRLF换行，Git提供了autocrlf 配置字段autocrlf 。</p>
<p>如果autocrlf enable, Windows 本地的CRLF文件在提交到git时，自动转换为LF换行；从git checkout文件到windows本地时，git将LF换行自动替换为 Windows 的换行符（CRLF）。Linux环境下checkout时文件换行也自动转换为Linux的LF格式。</p>
<p>如果autocrlf disable, Windows 本地的CRLF文件在提交到git时仍然为CRLF换行，如果有其他Linux环境的开发者checkout文件，可能无法在Linux上识别相关的CRLF文件引起项目编译问题。</p>
<p>如果没有跨平台的开发环境，即所有开发者都是Windows或都是Linux环境，则不需要autocrlf enable。</p>
<p>注意：对于windows版本的git, 默认是enable autocrlf，.gitconfig内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	autocrlf = true</span><br></pre></td></tr></table></figure>

<p>可以使用命令修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

<p>（3）同一个项目内，要同时支持LF和CRLF如何设置？</p>
<p>如果是临时的解决某些文件的换行问题，可以手动转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dos2unix #转换dos换行符为unix换行</span><br><span class="line">unix2dos #转换unix换行符为dos换行</span><br></pre></td></tr></table></figure>

<p>对git项目的配置，参考<a href="https://git-scm.com/docs/gitattributes">.gitattributes</a>，可以指定某路径的某文件使用指定的换行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*           text=auto		#set autocrlf manually for all files</span><br><span class="line">*.vcproj	text eol=crlf 	#all .vcproj files have CRLF</span><br><span class="line">*.sh		text eol=lf 	#all .sh files have LF</span><br><span class="line">*.jpg		-text 			#prevent .jpg files from being normalized</span><br></pre></td></tr></table></figure>

<p>eol attribute sets a specific line-ending style to be used in the working directory. This attribute has effect only if the <code>text</code> attribute is set or unspecified</p>
<p>一个项目既有windows的bat脚本又有Linux的sh脚本，在全局的core.autocrlf 为true的基础上，配置如下attribute 使这些文件不自动转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.bat	text eol=crlf</span><br><span class="line">*.sh	text eol=lf</span><br><span class="line">*/*.cfg	text eol=crlf</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux MMC框架下的UHS-II驱动调试</title>
    <url>/2022/03/25/Linux%20MMC%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84UHS-II%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1-Linux-MMC-框架现状"><a href="#1-Linux-MMC-框架现状" class="headerlink" title="1. Linux MMC 框架现状"></a>1. Linux MMC 框架现状</h2><p>Linux MMC driver是支持包括SD卡，eMMC卡等等，属于MultiMediaCard设备和接口的驱动<br>其源码路径位于Kernel source code的drivers&#x2F;mmc路径, 头文件位于include&#x2F;linux&#x2F;mmc<br>mmc源码分为core&#x2F;host两层，是为了解耦：</p>
<ul>
<li>通用的SD&#x2F;eMMC流程(core)</li>
<li>具体的硬件操作流程(host)，在此层又可分为通用的SDHCI框架和非SDHCI框架，各eMMC&#x2F;SD host厂商实现最底层driver时，可以遵循SDHCI框架下的API, 间接实现core层定义的方法(driver称为operations), 也可以不遵循SDHCI框架，直接实现core层定义的方法。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301058425.png"></li>
</ul>
<p>本文重点关注mmc框架对SD卡驱动的支持</p>
<h3 id="1-1-SD卡的类型概述"><a href="#1-1-SD卡的类型概述" class="headerlink" title="1.1 SD卡的类型概述"></a>1.1 SD卡的类型概述</h3><p>SD卡可以分为三种类型：<br>UHS-I, UHS-II, SD express</p>
<p>详细信息参考<a href="https://www.sdcard.org/">https://www.sdcard.org</a></p>
<ul>
<li>Physical Layer Specification Ver.7.10 (从各层描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD Host Controller Specification Ver7.0 (从host控制器角度，描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD_Specifications_Part_1_UHS_II_Addendum(描述SD UHSII的附录规范)</li>
</ul>
<p>UHS即Ultra High Speed, express也表示高速，这三代SD卡的读写速度是依次增加，参考下图：</p>
<ul>
<li>UHSI：50~104MB&#x2F;s</li>
<li>UHSII: 156~624MB&#x2F;s</li>
<li>SD express: 985MB&#x2F;s</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301119947.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301120184.png"></p>
<h3 id="1-2-Linux-MMC框架对SD卡的支持"><a href="#1-2-Linux-MMC框架对SD卡的支持" class="headerlink" title="1.2 Linux MMC框架对SD卡的支持"></a>1.2 Linux MMC框架对SD卡的支持</h3><p>基本概念：只有mmc框架的core层支持某种SD模式，host层才能实现这种模式；如果core层都不支持，只能厂商自己开发core层，以patch补丁的方式发布。</p>
<p>core层对于上述三种SD模式的支持：</p>
<ul>
<li>Linux kernel 5.11 以前，只支持UHS-I及其更低速度的legacy-SD模式</li>
<li>Linux kernel 5.11 开始，在core层添加了SD express的支持</li>
<li>目前没有UHS-II的支持，只有提交待审核的，参考：<a href="https://lore.kernel.org/all/?q=Jason%20Lai">lore.kernel.org&#x2F;Jason Lai&#x2F;patch</a></li>
</ul>
<p>host层对于上述三种SD模式的支持：</p>
<ul>
<li>UHS-I: 基本host目录的大多数SD厂商驱动都支持，很多符合sdhci框架</li>
<li>SD express: Realtek基于Linux kernel 5.11的core层API, 实现了 驱动的host底层部分，参考kernel的host&#x2F;rtsx_pci_sdmmc.c, 其没有使用SDHCI框架。</li>
<li>UHS-II: 只有以patch方式实现的，参考<a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a>，其实现了core&#x2F;host-sdhci&#x2F;host vendor多个层次的UHS-II支持。</li>
</ul>
<p>综上所述，本文参考uhs2-gl8755 patch，实现自己的SD UHSII driver。</p>
<h2 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2. 编译过程"></a>2. 编译过程</h2><p>本节描述编译mmc driver module和整个kernel的过程，同时描述中间踩的坑。</p>
<h3 id="2-1-直接编译整个Kernel-带UHS-II-Patch"><a href="#2-1-直接编译整个Kernel-带UHS-II-Patch" class="headerlink" title="2.1 直接编译整个Kernel(带UHS-II Patch)"></a>2.1 直接编译整个Kernel(带UHS-II Patch)</h3><p>安装Linux Ubuntu 20版本，Ubuntu环境下载和解压待编译的整个Linux kernel 源码：<a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a></p>
<p>注意：一定要在Linux环境下解压待编译源码，不能在windows下解压再拷到Linux编译，因为源码中有些大小写不同的同名文件，例如net&#x2F;netfilter的很多头文件。windows不区分大小，解压时写会让你替换或重命名，这些同名文件的内容不一样，所以不能替换或重命名，强行替换会导致编译Linux报错找不到相关文件。</p>
<ol>
<li><p>编译环境准备<br>gcc&#x2F;make等工具，都需要先安装build-essential才能使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置，编译和安装 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd linux-uhs2-gl9755-v3-patch #进入待编译Kernel源码</span><br><span class="line">make menuconfig #配置内核，生成.config文件</span><br><span class="line">make -j4 #以4线程编译内核，等同于make bzImage，make modules</span><br><span class="line">make modules_install #安装各Driver模块</span><br><span class="line">make install #安装内核(包括更新模块信息)</span><br></pre></td></tr></table></figure>
<p>编译完成后会自动update-grub, 重启后选择编译好的kernel版本启动。</p>
</li>
</ol>
<p>也可以设置默认启动的kernel，编辑&#x2F;etc&#x2F;default&#x2F;grub的<code>GRUB_DEFAULT=&quot;1&gt;X&quot;</code>, 其中1表示从advanced选项启动，X表示从哪个kernel启动(0 based)，例如下图如果默认要从5.19启动，X设置为0，默认从5.8.0-rc4启动，X设置为6.<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202208171414943.png"><br>配置完毕update-grub重启生效</p>
<ol start="3">
<li><p>查看内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r #查看当前运行的kernel版本</span><br><span class="line">cat Makefile #查看待编译kernel源码的内核版本</span><br></pre></td></tr></table></figure>
<p>以linux-uhs2-gl9755-v3-patch为例，其根目录Makefile如下，表示kernel源码版本为 5.8.0-rc4<br>编译完成重启后应该选择5.8.0-rc4启动，进入桌面后用<code>uname -r</code>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VERSION = 5</span><br><span class="line">PATCHLEVEL = 8</span><br><span class="line">SUBLEVEL = 0</span><br><span class="line">EXTRAVERSION = -rc4</span><br><span class="line">NAME = Kleptomaniac Octopus</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译报错记录<br>(1) 生成vmlinux Image时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to generate BTF for vmlinux  </span><br><span class="line">Try to disable CONFIG_DEBUG_INFO_BTF</span><br></pre></td></tr></table></figure>
<p>修改Kernel源码根目录的.config文件，CONFIG_DEBUG_INFO_BTF&#x3D;n 关闭此选项</p>
</li>
</ol>
<p>(2) 编译完成，但运行新kernel时报错<code>out of memory</code><br>解决办法：裁剪module大小，编译模块时使用 <code>make  INSTALL_MOD_STRIP=1 modules_install</code>，.ko被编译时会缩减非必要的debug信息。</p>
<h3 id="2-2-合并UHSII-patch后再编译整个Kernel"><a href="#2-2-合并UHSII-patch后再编译整个Kernel" class="headerlink" title="2.2 合并UHSII patch后再编译整个Kernel"></a>2.2 合并UHSII patch后再编译整个Kernel</h3><p>官方kernel源码可以到<a href="https://www.kernel.org/">kernel.org</a>下载</p>
<p>合并UHSII patch，仅涉及到mmc模块的代码，如果差异不大可以将linux-uhs2-gl9755-v3-patch的drivers&#x2F;mmc和include头文件直接拷到待编译kernel的drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc。</p>
<p>如果是手动合并UHS-II patch，需要考虑以下部分：</p>
<ul>
<li>源码，包括drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc</li>
<li>Makefile, 包括drivers&#x2F;mmc&#x2F;core和drivers&#x2F;mmc&#x2F;host</li>
<li>Kconfig, 包括drivers&#x2F;mmc，及其子目录core和host</li>
</ul>
<p>具体合并方法参考《Linux设备驱动开发详解》<br>合并完后，Kernel编译流程和上节相同</p>
<h3 id="2-3-单独编译MMC模块"><a href="#2-3-单独编译MMC模块" class="headerlink" title="2.3 单独编译MMC模块"></a>2.3 单独编译MMC模块</h3><p>一般的驱动开发，都是可以单独编译成module模块，然后用rmmod和insmod替换原系统的模块</p>
<p>但是UHS-II patch涉及到mmc&#x2F;core层的改动，而core是build-in的，不能作为模块编译，因此只能编译整个kernel。以后如果只修改host层的代码，可以将mmc&#x2F;host单独编译为module后安装。</p>
<p>待编译kernel目录是<code>~/linux-5.8-rc4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#编译模块，&quot;M=&quot;指定待编译源码，编译完拷贝.ko到&quot;-C&quot;指定的目录，此目录为系统存放模块的目录</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc</span><br><span class="line"></span><br><span class="line">#安装模块</span><br><span class="line">make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc modules_install</span><br><span class="line">	</span><br><span class="line">#清除模块,包括.o和.ko文件</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc clean</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.kernel.org/doc/html/latest/kbuild/modules.html"># Building External Modules</a></p>
<p>注意，<code>make xxx modules_install</code>是不能让模块自动加载的，只是安装到了&#x2F;lib&#x2F;modules位置。使用<code>modinfo</code>查看模块信息，似乎是使用了&#x2F;lib&#x2F;modules下的，但没有实际加载和生效。<br>要加载模块，两种方法：</p>
<ol>
<li>rmmod&#x2F;insmod 手动替换, 参考下一节</li>
<li>make modules_install 之后再 make install，更新整个kernel, 此后外部模块才会被内核自动加载（通常使用这种方式）</li>
</ol>
<h3 id="2-4-手动替换MMC模块"><a href="#2-4-手动替换MMC模块" class="headerlink" title="2.4 手动替换MMC模块"></a>2.4 手动替换MMC模块</h3><h4 id="2-4-1-UHS-II相关模块的依赖关系"><a href="#2-4-1-UHS-II相关模块的依赖关系" class="headerlink" title="2.4.1 UHS-II相关模块的依赖关系"></a>2.4.1 UHS-II相关模块的依赖关系</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301640662.png"></p>
<p>可以从mmc&#x2F;host的Kconfig得知依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config MMC_SDHCI_PCI</span><br><span class="line">	tristate &quot;SDHCI support on PCI bus&quot;</span><br><span class="line">	depends on MMC_SDHCI &amp;&amp; PCI</span><br><span class="line">	select MMC_SDHCI_UHS2</span><br><span class="line">	</span><br><span class="line">config MMC_SDHCI_UHS2</span><br><span class="line">	tristate &quot;UHS2 support on SDHCI controller&quot;</span><br><span class="line">	depends on MMC_SDHCI</span><br></pre></td></tr></table></figure>

<p>使用<code>lsmod</code>可以得知module依赖关系，如下图，sdhci_uhs2被sdhci_pci引用1次, sdhci被sdhci_uhs2和sdhci_pci引用2次<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645712.png"><br><code>modinfo</code>可以得知已加载module的.ko路径<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645737.png"></p>
<h4 id="2-4-2-手动卸载和装载module"><a href="#2-4-2-手动卸载和装载module" class="headerlink" title="2.4.2 手动卸载和装载module"></a>2.4.2 手动卸载和装载module</h4><p>卸载和装载都要按依赖顺序处理，shell脚本如下.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">sudo rmmod sdhci_pci</span><br><span class="line">sudo rmmod sdhci_uhs2</span><br><span class="line">sudo rmmod sdhci</span><br><span class="line"></span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-uhs2.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-pci.ko </span><br></pre></td></tr></table></figure>

<h2 id="3-调试过程"><a href="#3-调试过程" class="headerlink" title="3. 调试过程"></a>3. 调试过程</h2><h3 id="3-1-调试工具"><a href="#3-1-调试工具" class="headerlink" title="3.1 调试工具"></a>3.1 调试工具</h3><ol>
<li>printk<br>printk是很常用的driver调试手段，配合dmesg查看kernel log可以定位常见问题。<br>printk如何开启不同打印级别，参考<a href="https://www.kernel.org/doc/html/latest/core-api/printk-basics.html"># Message logging with printk</a></li>
</ol>
<p>例如，使用<code>dmesg -n 6</code>开启KERN_INFO级别，然后在driver中添加pr_info()作为info打印, 在dmesg中查看打印log。</p>
<p>注意KERN_DEBUG比较特殊，不仅要<code>dmesg -n 7</code>开启, 还需要在driver module的makefile添加Debug CFLAGS, 有两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#该Makefile相关模块全部启用debug</span><br><span class="line">EXTRA_CFLAGS += -DDEBUG</span><br><span class="line"></span><br><span class="line">#指定模块启用debug</span><br><span class="line">CFLAGS-xxx-mmc += -DDEBUG</span><br></pre></td></tr></table></figure>
<p>示例：使用<code>pr_info(“enter %s\n”, __FUNCTION__);</code> 打印函数调用流程</p>
<ol start="2">
<li>dmesg<br>示例参考 <a href="https://www.geeksforgeeks.org/how-to-use-the-dmesg-command-on-linux/"># How to use the dmesg Command on Linux</a><br>比较常用的有：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dmesg</span><br><span class="line">sudo dmesg -c </span><br><span class="line">sudo dmesg | head -100</span><br><span class="line">sudo dmesg | tail</span><br><span class="line">sudo dmesg | xxx</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.vscode<br>vscode比vim&#x2F;gedit更方便直接改代码，用.deb安装容易失败，推荐命令行安装方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#更新相关microsoft源</span><br><span class="line">wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] \</span><br><span class="line">https://packages.microsoft.com/repos/code stable main&quot; &gt; /etc/apt/sources.list.d/vscode.list&#x27;</span><br><span class="line"></span><br><span class="line">rm -f packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install code</span><br></pre></td></tr></table></figure>
<h3 id="3-2-UHSII调试"><a href="#3-2-UHSII调试" class="headerlink" title="3.2 UHSII调试"></a>3.2 UHSII调试</h3><ol>
<li><p>模块加载初始化过程中dmesg显示直接dump<br>基本是空指针问题，例如：</p>
<ul>
<li>只编译UHSII host 模块，而不编译kernel的core层，insmod host模块时就会dump, 因为core层相关API不存在。</li>
<li>获取相关数据结构方法不对导致空指针<br>例如获取slot要使用：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  struct sdhci_pci_slot *slot = sdhci_priv(host);</span><br><span class="line"></span><br><span class="line">static inline void *sdhci_priv(struct sdhci_host *host)&#123;</span><br><span class="line">   return host-&gt;private;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
而host-&gt;private实际指向sdhci_host结构体的最后定义的如下0长度数组<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long private[] ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
参考：<a href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct"># <a href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct">Explanation on private variable in c struct</a></a><br>基本含义是可以获取结构体外部的数据，而host指针本身确实属于slot结构体sdhci_pci_slot的一部分，所以host-&gt;private能访问到slot。</li>
</ul>
</li>
<li><p>贴一段dmesg log，包含UHSII初始化过程直到最后一步GO_DORMANT fail<br>具体流程参考UHSII spec:  SD_Specifications_Part_1_UHS_II_Addendum</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  522.171631] sdhci_uhs2 [sdhci_uhs2_do_detect_init()]: sdhci_uhs2_do_detect_init: begin UHS2 init.</span><br><span class="line">[  522.171632] enter sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171632] exit sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171835] sdhci_uhs2 [sdhci_uhs2_interface_detect()]: mmc0: UHS2 Lane synchronized in UHS2 mode, PHY is initialized.</span><br><span class="line">[  522.171855] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171856] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 0</span><br><span class="line">[  522.171858] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171865] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.171874] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.171885] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.171887] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171887] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 1</span><br><span class="line">[  522.171888] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171894] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188184] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188205] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188254] [uhs2_dev_init()]: CF is set, device is initialized!</span><br><span class="line">[  522.188257] [uhs2_enum()]: Begin ENUMERATE, header=0x80, arg=0x392, payload=0xf0.</span><br><span class="line">[  522.188260] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x392</span><br><span class="line">[  522.188262] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=8</span><br><span class="line">[  522.188266] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188277] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188290] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188308] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188318] [uhs2_enum()]: id_f = 6, id_l = 6.</span><br><span class="line">[  522.188320] [uhs2_enum()]: Enumerate Cmd Completed. No. of Devices connected = 1</span><br><span class="line">[  522.188322] [uhs2_config_read()]: INQUIRY_CFG: read Generic Caps.</span><br><span class="line">[  522.188324] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x10.</span><br><span class="line">[  522.188326] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x10</span><br><span class="line">[  522.188328] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188331] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188342] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188363] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188392] mmc0: req done (CMD0): 0: 00010100 00000000 00000000 00000000</span><br><span class="line">[  522.188398] [uhs2_config_read()]: Device Generic Caps (0-31) is: 0x10100.</span><br><span class="line">[  522.188399] [uhs2_config_read()]: INQUIRY_CFG: read PHY Caps.</span><br><span class="line">[  522.188401] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x220.</span><br><span class="line">[  522.188404] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x220</span><br><span class="line">[  522.188410] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188415] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188427] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188447] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188476] mmc0: req done (CMD0): 0: 00008000 00000080 00000000 00000000</span><br><span class="line">[  522.188482] [uhs2_config_read()]: Device PHY Caps (0-31) is: 0x8000.</span><br><span class="line">[  522.188484] [uhs2_config_read()]: Device PHY Caps (32-63) is: 0x80.</span><br><span class="line">[  522.188487] [uhs2_config_read()]: INQUIRY_CFG: read LINK-TRAN Caps.</span><br><span class="line">[  522.188492] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x420.</span><br><span class="line">[  522.188499] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x420</span><br><span class="line">[  522.188504] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188507] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188516] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188554] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188582] mmc0: req done (CMD0): 0: 20024000 00000000 00000000 00000000</span><br><span class="line">[  522.188601] [uhs2_config_read()]: Device LINK-TRAN Caps (0-31) is: 0x20024000.</span><br><span class="line">[  522.188604] [uhs2_config_read()]: Device LINK-TRAN Caps (32-63) is: 0x0.</span><br><span class="line">[  522.188605] [uhs2_config_write()]: SET_COMMON_CFG: write Generic Settings.</span><br><span class="line">[  522.188607] [uhs2_config_write()]: Both Host and device support 2L-HD.</span><br><span class="line">[  522.188609] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0</span><br><span class="line">[  522.188611] [uhs2_config_write()]: UHS2 write Generic Settings 00000000 00000000</span><br><span class="line">[  522.188613] [uhs2_config_write()]: flags=00000005 dev_prop.n_lanes_set=0 host_caps.n_lanes_set=0</span><br><span class="line">[  522.188615] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188618] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188620] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188632] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188650] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188678] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188684] [uhs2_config_write()]: SET_COMMON_CFG: PHY Settings.</span><br><span class="line">[  522.188686] [uhs2_config_write()]: set dev_prop.speed_range_set to SPEED_B</span><br><span class="line">[  522.188689] [uhs2_config_write()]: UHS2 SET PHY Settings  40000000 04000000</span><br><span class="line">[  522.188691] [uhs2_config_write()]: host-&gt;flags=00000015 dev_prop.speed_range_set=1</span><br><span class="line">[  522.188693] [uhs2_config_write()]: dev_prop.n_lss_sync_set=4 host_caps.n_lss_sync_set=4</span><br><span class="line">[  522.188694] [uhs2_config_write()]: dev_prop.n_lss_dir_set=0 host_caps.n_lss_dir_set=8</span><br><span class="line">[  522.188696] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xaa0</span><br><span class="line">[  522.188698] [uhs2_config_write()]: 		payload[0]=0x40000000 payload[1]=0x4000000</span><br><span class="line">[  522.188700] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xaa0</span><br><span class="line">[  522.188703] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=4</span><br><span class="line">[  522.188705] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188715] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188730] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188741] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188746] [uhs2_config_write()]: SET_COMMON_CFG: LINK-TRAN Settings.</span><br><span class="line">[  522.188748] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xca0</span><br><span class="line">[  522.188750] [uhs2_config_write()]: 		payload[0]=0x80320 payload[1]=0x1000000</span><br><span class="line">[  522.188752] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xca0</span><br><span class="line">[  522.188754] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188756] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188766] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188780] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188808] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188813] [uhs2_config_write()]: SET_COMMON_CFG: Set Config Completion.</span><br><span class="line">[  522.188815] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0, payload[0] = 0x0.</span><br><span class="line">[  522.188817] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188819] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=5</span><br><span class="line">[  522.188821] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188831] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188842] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188855] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188862] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 0.</span><br><span class="line">[  522.201612] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 3.</span><br><span class="line">[  522.201614] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 2.</span><br><span class="line">[  522.201616] [uhs2_go_dormant()]: Begin GO_DORMANT_STATE, header=0x86, arg=0x192, payload=0x0.</span><br><span class="line">[  522.201617] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x192</span><br><span class="line">[  522.201618] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=0</span><br><span class="line">[  522.201619] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.201626] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x8c0 is set to UHS2 CMD register.</span><br><span class="line">[  522.218633] mmc0: sdhci: IRQ status 0x00008000</span><br><span class="line">[  522.218636] sdhci_uhs2 [sdhci_uhs2_irq()]: *** mmc0 got UHS2 interrupt: 0x00010000</span><br><span class="line">[  522.218651] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218652] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218652] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218654] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218659] mmc0: req done (CMD0): -110: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.218666] mmc0: uhs2_go_dormant: UHS2 CMD send fail, err= 0xffffff92!</span><br><span class="line">[  522.218668] mmc0: uhs2_change_speed: UHS2 GO_DORMANT_STATE fail, err= 0xfffffffb!</span><br><span class="line">[  522.218669] mmc0: UHS2 uhs2_change_speed() fail!</span><br></pre></td></tr></table></figure>
<p>含义是UHSII初始化接近完成，切换到高速的RangeB时，GO_DORMANT_STATE命令未完成，超时。<br>解决办法：先绕过RangeB模式，使用RangA(较低速度的UHSII模式)，为此要从一开始就上报host不支持RangeB。<br>修改mmc&#x2F;host&#x2F;sdhci-uhs2.c中的上报host能力(capability)的speed_range为不支持RangeB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mmc-&gt;uhs2_caps.speed_range =(caps_phy &amp; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_MASK) &gt;&gt; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_SHIFT;</span><br><span class="line"></span><br><span class="line">mmc-&gt;uhs2_caps.speed_range = 0; //Range-A</span><br></pre></td></tr></table></figure>
<p>重新编译安装module后，UHSII初始化正常，读写正常。</p>
</li>
</ol>
<p>事实上此GO_DORMANT fail issue的根本原因是兼容性问题：<br>UHSII初始化流程中，SD host侧对lane speed的配置最好在卡处在dormant状态下进行，host侧提高速度（从Range-A提高到RangeB）以后，卡侧在退出dormant状态时重新配置速度，和host速度匹配。<br>如果host侧修改lane speed时间点错误，有的SD卡来不及反应，不能同步速度，所以GO_DORMANT fail；而有的SD 卡性能好，随时同步host侧的速度，没有此issue。</p>
<p>另外有的Issue和硬件特性相关，例如上电需要等待一定时间以后，才能启动UHSII设备初始化，这个等待时间取决于SD host厂商的硬件特性。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：SSD的S3/S4/S5压力测试脚本</title>
    <url>/2020/09/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9ASSD%E7%9A%84S3-S4-S5%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>存储设备产品（如SSD&#x2F;eMMC）的读写速度和稳定性测试，是量产前必不可少的步骤。除了常规的两个设备来回拷贝读写，存储设备做系统盘的情况下，反复的启动，睡眠，休眠，也是重要的测试项。本文介绍这几种测试的原理，工具实现，和调试过程</p>
<h1 id="系统电源状态"><a href="#系统电源状态" class="headerlink" title="系统电源状态"></a>系统电源状态</h1><p>ACPI（高级配置与电源接口）是电源配置和接口的规范，供操作系统和应用程序管理所有电源，其定义了几种状态（State）：S1~S6<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051553199.png" alt="image-20221205155311145"></p>
<p>操作系统在ACPI基础上实现各自的电源状态划分<br>Linux电源状态划分为如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554689.png" alt="image-20221205155406635"></p>
<p>其中，常见的几种状态有别称，如S3通常也称Suspend，S4也称Hibernation, S5即shutdown。下面描述这几种状态的区别</p>
<p>S3:<br>1、将系统当前的运行状态等数据保存在内存中，此时仍需要向RAM供电，以保证后续快速恢复至工作状态<br>2、冻结用户态的进程和内核态的任务（进入内核态的进程或内核自己的task）<br>3、关闭外围设备，如显示屏、鼠标等,中断唤醒外设不会关闭，如电源键<br>4、CPU停止工作</p>
<p>S4：<br>挂起到硬盘，俗称休眠（Hibernation）将系统当前的运行状态等数据保存到硬盘上，并自动关机。下次开机时便从硬盘上读取之前保存的数据，恢复到休眠关机之前的状态。<br>譬如在休眠关机时，桌面打开了一个应用，那么下一次开机启动时，该应用也处于打开状态。而正常的关机-开机流程，该应用是不会打开的</p>
<p>S5:<br>关机并断电，实际上，S5在不同场景下，可以指代关机和重启两种操作，关机是彻底power off的，而重启不是彻底断电，只是重新启动了系统，（当然基本所有设备都被reset），重启！&#x3D;关机再启动。</p>
<h1 id="测试工具设计"><a href="#测试工具设计" class="headerlink" title="测试工具设计"></a>测试工具设计</h1><p>需求：设计工具使系统从S0(working)进入S3&#x2F;S4&#x2F;S5状态，维持一段时间，然后退出该状态，在S0维持一段时间，再次进入S3&#x2F;S4&#x2F;S5状态，如此反复循环。用户输入工作模式（S3&#x2F;S4&#x2F;S5）和循环次数，工具输出运行日志，包含已运行次数和时间戳。</p>
<h2 id="Linux测试脚本实现"><a href="#Linux测试脚本实现" class="headerlink" title="Linux测试脚本实现"></a>Linux测试脚本实现</h2><p>Linux环境有现成的工具：rtcwake，参看其man page：</p>
<pre><code>NAME
       rtcwake - enter a system sleep state until specified wakeup time
SYNOPSIS
       rtcwake [options] [-d device] [-m standby_mode] &#123;-s seconds|-t time_t&#125;
DESCRIPTION
       This program is used to enter a system sleep state and to automatically wake from it at a specified time.
       This uses cross-platform Linux interfaces to enter a system sleep state, and leave it no later than a specified time.  It uses any RTC framework driver that supports standard driver model wakeup flags.
       This is normally used like the old apmsleep utility, to wake from a suspend state like ACPI S1 (standby) or S3 (suspend-to-RAM).  Most platforms can implement those without analogues of BIOS, APM, or ACPI.
       On some systems, this can also be used like nvram-wakeup, waking from states like ACPI S4 (suspend to disk).  Not all systems have persistent media that are appropriate for such suspend modes.
       Note that alarm functionality depends on hardware; not every RTC is able to setup an alarm up to 24 hours in the future.
       The suspend setup may be interrupted by active hardware; for example wireless USB input devices that continue to send events for some fraction of a second after the return key is pressed.  rtcwake tries to avoid this problem and it waits to terminal to settle down before entering a system sleep.
</code></pre>
<p>其重要option如下：</p>
<pre><code>      -m, --mode mode
              Go into the given standby state.  Valid values for mode are:

              standby
                     ACPI state S1.  This state offers minimal, though real,
                     power savings, while providing a very low-latency
                     transition back to a working system.  This is the
                     default mode.

              freeze The processes are frozen, all the devices are suspended
                     and all the processors idled.  This state is a general
                     state that does not need any platform-specific support,
                     but it saves less power than Suspend-to-RAM, because
                     the system is still in a running state.  (Available
                     since Linux 3.9.)

              mem    ACPI state S3 (Suspend-to-RAM).  This state offers
                     significant power savings as everything in the system
                     is put into a low-power state, except for memory, which
                     is placed in self-refresh mode to retain its contents.

              disk   ACPI state S4 (Suspend-to-disk).  This state offers the
                     greatest power savings, and can be used even in the
                     absence of low-level platform support for power
                     management.  This state operates similarly to Suspend-
                     to-RAM, but includes a final step of writing memory
                     contents to disk.

              off    ACPI state S5 (Poweroff).  This is done by calling
                     &#39;/sbin/shutdown&#39;.  Not officially supported by ACPI,
                     but it usually works.

              no     Don&#39;t suspend, only set the RTC wakeup time.

              on     Don&#39;t suspend, but read the RTC device until an alarm
                     time appears.  This mode is useful for debugging.

              disable
                     Disable a previously set alarm.

              show   Print alarm information in format: &quot;alarm: off|on
                     &lt;time&gt;&quot;.  The time is in ctime() output format, e.g.,
                     &quot;alarm: on  Tue Nov 16 04:48:45 2010&quot;.
                     
       -s, --seconds seconds
              Set the wakeup time to seconds in the future from now.

       -t, --time time_t
              Set the wakeup time to the absolute time time_t.  time_t is
              the time in seconds since 1970-01-01, 00:00 UTC.  Use the
              date(1) tool to convert between human-readable time and
              time_t.
</code></pre>
<p>只需要写shell script调用rtcwake即可<br>注意要求跨状态记录日志，S3&#x2F;S4很容易，运行信息只是被挪到内存、硬盘，不会丢失，但S5会shutdown, 因此循环次数和时间只能记录在掉电不丢失的硬盘里。<br>S3S4可以用一个脚本完成，而S5需要单独设计<br>S3S4.sh如下：<br>接受用户输入：<br>opt: S3或S4模式；COUNT：循环次数<br>每次执行rtcwake，日志写入LOG</p>
<pre><code>opt=$1
COUNT=$2
interval=30
s3timer=120
s4timer=120

mkdir -p log
DATE=$(date +%Y-%m-%d)
LOG=log/$&#123;opt&#125;_$&#123;DATE&#125;.log
cat /dev/null &gt; $&#123;LOG&#125;

echo &quot;=============================== $opt test start ===============================&quot; |tee -a $&#123;LOG&#125;

for (( i=1; i&lt;=$COUNT; i++ ))
do 
    if [ $opt == &quot;s3&quot; ];then
        echo &quot;************************* S3 Cycle: $i start *************************&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S3, Duration &quot;$s3timer&quot; sec&quot; |tee -a $&#123;LOG&#125;
        sudo rtcwake -m mem -s $s3timer &gt;&gt; $&#123;LOG&#125; 2&gt;&amp;1
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Waitable timer triggered.&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Wake up from S3, Cycle &quot;$i&quot;&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Successfully left sleep state S3...&quot; |tee -a $&#123;LOG&#125;
    elif [ $opt == &quot;s4&quot; ];then
        echo &quot;************************* S4 Cycle: $i start *************************&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S4, Duration &quot;$s4timer&quot; sec&quot; |tee -a $&#123;LOG&#125;
        sudo rtcwake -m disk -s $s4timer &gt;&gt; $&#123;LOG&#125; 2&gt;&amp;1
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Waitable timer triggered.&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Wake up from S4, Cycle &quot;$i&quot;&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Successfully left sleep state S4...&quot; |tee -a $&#123;LOG&#125;
    else
        echo &quot;error input, use s3 or s4 as input&quot;
    fi
    echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;wake up for $interval seconds&quot; |tee -a $&#123;LOG&#125;
    echo &quot;************************* $opt Cycle: $i finish *************************&quot; |tee -a $&#123;LOG&#125;
    #keep wake up time
    sleep $interval
done

echo &quot;=============================== $opt test finished =============================== &quot; |tee -a $&#123;LOG&#125;
</code></pre>
<p>S5必须要解决两个问题：<br>1.每次测试的信息如何跨越重启<br>2.如何使系统自动不断的重启</p>
<p>对于1，可以将日志写入固定文件，每次重启后读该文件并追加，知道S5循环结束<br>对于2，Linux有开机自动启动某些桌面程序、shellscript的机制</p>
<p>S5测试脚本分为三部分：<br>配置自启动并执行首次重启的脚本：s5_start.sh<br>执行单次S5的脚本，即自启动调用的脚本：s5.sh<br>停止S5，清楚自启动配置的脚本：s5_stop.sh</p>
<p>s5_start.sh</p>
<pre><code>#!/bin/bash
USER=$(users)
opt=s5
interval=30
s5timer=180

#config autostart
mkdir -p /home/$USER/.config/autostart
touch /home/$USER/.config/autostart/s5.desktop
echo &quot;
[Desktop Entry]
Type=Application
Exec=gnome-terminal -e /home/$USER/s5.sh
Terminal=true
X-GNOME-Autostart-enabled=true
&quot; &gt; /home/$USER/.config/autostart/s5.desktop
chmod 777 /home/$USER/.config/autostart/s5.desktop
echo &quot;config autostart finished&quot;

#config sudo
echo &quot;$USER ALL=(ALL) NOPASSWD:ALL&quot; &gt;&gt; /etc/sudoers

#config s5 log and temp file 
mkdir -p log
DATE=$(date +%Y-%m-%d)
LOG=log/$&#123;opt&#125;_$&#123;DATE&#125;.log
cat /dev/null &gt; $&#123;LOG&#125;
echo &quot;1&quot; &gt; $&#123;opt&#125;_cycle.txt
echo &quot;$LOG&quot; &gt; $&#123;opt&#125;_log.txt
chmod 777 -R ./*.sh ./log/*.log ./*.txt

echo &quot;System will shutdown after &quot;$interval&quot; sec, then restart after &quot;$s5timer&quot; sec&quot;
echo &quot;*********************** S5 Cycle: 1 *************************&quot; |tee -a $&#123;LOG&#125;
echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S5 after &quot;$interval&quot; sec&quot; |tee -a $&#123;LOG&#125;
sleep $interval

rtcwake -m off -s $s5timer &gt;&gt; $&#123;LOG&#125; 2&gt;&amp;1
</code></pre>
<p>s5.sh</p>
<pre><code>#!/bin/bash
COUNT=&quot;999&quot;
opt=s5
interval=30
s5timer=180
cycle=$(&lt;$&#123;opt&#125;_cycle.txt)
LOG=$(&lt;$&#123;opt&#125;_log.txt)

#update cycle
((cycle++))
echo &quot;$cycle&quot; &gt; $&#123;opt&#125;_cycle.txt 

#keep wake
echo &quot;*********************** S5 Cycle: $cycle *************************&quot; |tee -a $&#123;LOG&#125;
echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S5 after &quot;$interval&quot; sec&quot; |tee -a $&#123;LOG&#125;
sleep $interval

sudo rtcwake -m off -s $s5timer &gt;&gt; $&#123;LOG&#125; 2&gt;&amp;1
</code></pre>
<p>s5_stop.sh</p>
<pre><code>#!/bin/bash
USER=$(users)
opt=s5
rm -f /home/$USER/.config/autostart/s5.desktop
rm -f $&#123;opt&#125;_cycle.txt $&#123;opt&#125;_log.txt
sed -i &#39;/NOPASSWD/d&#39; /etc/sudoers
</code></pre>
<h2 id="测试脚本使用"><a href="#测试脚本使用" class="headerlink" title="测试脚本使用"></a>测试脚本使用</h2><h3 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h3><pre><code>./s3s4.sh s3 999      启动s3测试,运行999次
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554212.png" alt="image-20221205155429129"></p>
<h3 id="S4"><a href="#S4" class="headerlink" title="S4"></a>S4</h3><p>S4在内存和硬盘直接读写运行时映像，硬盘需要指定那一块区域用于和内存交换，即交换分区。Linux一切皆文件，交换分区也可以用swapfile配置。以下配置swapfile</p>
<ol>
<li><p>df –h 查看挂载点为&#x2F;对应的文件系统是&#x2F;dev&#x2F;nvme0n1p2,根据你具体情况记录<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554816.png"></p>
</li>
<li><p><code>blkid</code>查看UUID值，根据1对应的nvme文件系统记录UUID<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554581.png"></p>
</li>
<li><p><code>filefrag –v /swapfile</code>查看swapfile的物理起始地址，记录physical_offset左侧值<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554581.png"></p>
</li>
<li><p>将UUID和physical_offset值写入grub：<br>终端输入gedit &#x2F;etc&#x2F;default&#x2F;grub ，修改以下参数并保存<br><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash resume=UUID=你的UUID值 resume_offset=你的physical_offset值</code>“</p>
<p> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051555015.png" alt="image-20221205155518922"></p>
</li>
<li><p>重新生成grub: 终端输入 <code>update-grub</code> 回车并重启电脑。</p>
</li>
</ol>
<p>启动S4脚本</p>
<pre><code>./s3s4.sh s4 999
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051557197.png" alt="image-20221205155749113"></p>
<h3 id="S5"><a href="#S5" class="headerlink" title="S5"></a>S5</h3><p>自动重启需要先解决账户密码问题<br>设置普通账户自动登录：<br>普通账户为装系统时设置的账户，重启后默认以普通账户登录<br>1.终端输入<code>gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</code>弹出编辑界面<br>设置以下参数，ctrl+s保存后关闭</p>
<pre><code>[Seat:*]
user-session=ubuntu
autologin-user=你的账户名
</code></pre>
<p>2.终端输入<code>gedit /etc/gdm3/custom.conf</code>，设置以下几行的值为如下</p>
<pre><code># Enabling automatic login
AutomaticLoginEnable = true
AutomaticLogin =你的账户名
</code></pre>
<p>重启，确认可免密码登录桌面。</p>
<pre><code>./s5_start.sh 启动s5
./s5_stop.sh 结束S5
</code></pre>
<h1 id="Dmesg分析和调试"><a href="#Dmesg分析和调试" class="headerlink" title="Dmesg分析和调试"></a>Dmesg分析和调试</h1><h2 id="dmesg简介"><a href="#dmesg简介" class="headerlink" title="dmesg简介"></a>dmesg简介</h2><p>dmesg命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备<br>注意：<br>dmesg只记录从启动到当前时间的信息，掉电丢失</p>
<p>使用示例：</p>
<pre><code>dmesg //默认输出
dmesg | less //从头分页显示
dmesg | tail -100 //显示最后100行
dmesg | head  -100 //显示最早100行
dmesg | grep -i usb //包含usb的信息，忽略大小写
dmesg -C //清除log
</code></pre>
<p>输出示例：</p>
<pre><code>[root]# dmesg | grep sda
 
[    1.280971] sd 2:0:0:0: [sda] 488281250 512-byte logical blocks: (250 GB/232 GiB)
[    1.281014] sd 2:0:0:0: [sda] Write Protect is off
[    1.281016] sd 2:0:0:0: [sda] Mode Sense: 00 3a 00 00
[    1.281039] sd 2:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn&#39;t support DPO or FUA
[    1.359585]  sda: sda1 sda2 &lt; sda5 sda6 sda7 sda8 &gt;
[    1.360052] sd 2:0:0:0: [sda] Attached SCSI disk
[    2.347887] EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
[   22.928440] Adding 3905532k swap on /dev/sda6.  Priority:-1 extents:1 across:3905532k FS
[   23.950543] EXT4-fs (sda1): re-mounted. Opts: errors=remount-ro
[   24.134016] EXT4-fs (sda5): mounted filesystem with ordered data mode. Opts: (null)
[   24.330762] EXT4-fs (sda7): mounted filesystem with ordered data mode. Opts: (null)
[   24.561015] EXT4-fs (sda8): mounted filesystem with ordered data mode. Opts: (null)
</code></pre>
<p>输出时间戳是从上电开始，到当前的时间，以秒为单位。</p>
<h2 id="调试S4-hang"><a href="#调试S4-hang" class="headerlink" title="调试S4 hang"></a>调试S4 hang</h2><p>在测试中发现，nvme存储设备，首次进入S4的时间较长，约30s, 且系统处于hang状态，鼠标无法移动。<br>dmesg查看单次S4 enter &amp; resume的过程，log如下</p>
<pre><code>[   43.090180] PM: hibernation entry          //开机43秒进s4流程
[   43.090579] PM: Syncing filesystems ...   
[   43.090682] PM: done.
[   43.090684] Freezing user space processes ... (elapsed 0.003 seconds) done.   //冻结用户进程，这个时候会hang
[   43.093699] OOM killer disabled.
[   43.093876] PM: Marking nosave pages: [mem 0x00000000-0x00000fff]       //准备哪些内存要转存到disk
[   43.093878] PM: Marking nosave pages: [mem 0x0005f000-0x0005ffff]
[   43.093880] PM: Marking nosave pages: [mem 0x000a0000-0x000fffff]
[   43.093887] PM: Marking nosave pages: [mem 0x80185000-0x80186fff]
[   43.093889] PM: Marking nosave pages: [mem 0x88c4f000-0x890acfff]
[   43.093944] PM: Marking nosave pages: [mem 0x89214000-0x89efefff]
[   43.094102] PM: Marking nosave pages: [mem 0x89f00000-0xffffffff]
[   43.098151] PM: Basic memory bitmaps created
[   43.098541] PM: Preallocating image memory... 
[   43.143802] hpet_rtc_timer_reinit: 29 callbacks suppressed
[   43.143803] hpet1: lost 2 rtc interrupts
[   43.197779] hpet1: lost 2 rtc interrupts
[   43.251708] done (allocated 333315 pages)               //分配内存侧的交换页
[   43.251709] PM: Allocated 1333260 kbytes in 0.15 seconds (8888.40 MB/s)
[   43.251710] Freezing remaining freezable tasks ... (elapsed 0.126 seconds) done.
[   43.379023] printk: Suspending console(s) (use no_console_suspend to debug)
[   43.381268] serial 00:02: disabled
[   43.382187] parport_pc 00:01: disabled
[   43.701432] ACPI: Preparing to enter system sleep state S4  //准备进S4, 关CPU, 中断，
[   44.400195] PM: Saving platform NVS memory
[   44.404308] Disabling non-boot CPUs ...
[   44.404935] IRQ 123: no longer affine to CPU1
[   44.404942] IRQ 132: no longer affine to CPU1
[   44.405979] smpboot: CPU 1 is now offline
[   44.410695] smpboot: CPU 2 is now offline
[   44.414738] IRQ 122: no longer affine to CPU3
[   44.415784] smpboot: CPU 3 is now offline
[   44.422078] PM: Creating hibernation image:           //准备创建disk映像
[   44.503241] PM: Need to copy 330336 pages
[   44.503242] PM: Normal pages needed: 330336 + 1024, available pages: 1731140
                                                                                       //磁盘写入操作和时间没有记录
[   44.901845] PM: free pages cleared after restore    //S4已被唤醒，这里不是绝对时间，S4休眠时间未记入
[   44.901889] PM: Restoring platform NVS memory  
[   44.903440] Enabling non-boot CPUs ...
[   44.903474] x86: Booting SMP configuration:
[   44.903474] smpboot: Booting Node 0 Processor 1 APIC 0x2
[   44.904974]  cache: parent cpu1 should not be sleeping
[   44.905085] CPU1 is up
[   44.905101] smpboot: Booting Node 0 Processor 2 APIC 0x4
[   44.905478]  cache: parent cpu2 should not be sleeping
[   44.905602] CPU2 is up
[   44.905618] smpboot: Booting Node 0 Processor 3 APIC 0x6
[   44.905995]  cache: parent cpu3 should not be sleeping
[   44.906125] CPU3 is up
[   44.908816] ACPI: Waking up from system sleep state S4
[   45.003392] usb usb1: root hub lost power or was reset
[   45.003393] usb usb2: root hub lost power or was reset
[   45.006573] sd 0:0:0:0: [sda] Starting disk
[   45.006732] parport_pc 00:01: activated
[   45.008262] serial 00:02: activated
[   45.384656] ata1: SATA link up 3.0 Gbps (SStatus 123 SControl 300)
[   45.384717] ata2: SATA link down (SStatus 4 SControl 300)
[   45.384741] ata3: SATA link down (SStatus 4 SControl 300)
[   45.384758] ata6: SATA link down (SStatus 4 SControl 300)
[   45.384779] ata5: SATA link down (SStatus 4 SControl 300)
[   45.384798] ata4: SATA link down (SStatus 4 SControl 300)
[   45.387712] ata1.00: configured for UDMA/100
[   45.500662] usb 1-9: reset low-speed USB device number 2 using xhci_hcd
[   46.056539] usb 1-10: reset low-speed USB device number 3 using xhci_hcd
[   46.318112] nvme nvme0: 4/0/0 default/read/poll queues
[   46.336791] nvme nvme0: ctrl returned bogus length: 2 for NVME_NIDT_EUI64
[   46.363904] acpi LNXPOWER:07: Turning OFF
[   46.363916] acpi LNXPOWER:06: Turning OFF
[   46.364472] PM: Basic memory bitmaps freed
[   46.364474] OOM killer enabled.
[   46.364475] Restarting tasks ... done.   //恢复进程
[   47.098831] e1000e: eno1 NIC Link is Up 100 Mbps Full Duplex, Flow Control: None
[   47.098837] e1000e 0000:00:1f.6 eno1: 10/100 speed: disabling TSO
[   49.489104] video LNXVIDEO:00: Restoring backlight state
[   49.489109] PM: hibernation exit    //S4退出完成
</code></pre>
<p>比较奇怪的是，dmesg没记录写磁盘的操作,时间戳上也反映不出来。可能这时候IO交给DMA了，kernel就挂起了，所以dmesg无法工作，包括时间戳记录？？<br>为了验证S4 hang原因在于写磁盘，对不同SSD做读写测速：</p>
<pre><code>DISK               :         R/W speed MB/s   :       S4 hang time
Samsung SATA SSD   :         567/529          :       4s
Our SSD            :         170.1/104.7      :       25s
</code></pre>
<p>基本验证读写速度和S4 hang是线性关系。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：判断语句if-then-else-fi</title>
    <url>/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>shell中if-then-else-fi判断语句如下：</p>
<pre><code>a=&quot;abc&quot;

if [ $a = &quot;abc&quot; ]
then
   echo &quot;$a = $b&quot;
else
   echo &quot;$a != $b&quot;
fi
</code></pre>
<p>注意以下几点：</p>
<ul>
<li>shell中的等号：<code>=</code>可用于赋值，也可以用于判断；<code>==</code>只用于判断，更规范</li>
<li>shell中的if语句各符号间都要空格分隔：<code>if</code>和<code>[ ]</code>之间要空格；<code>[ ]</code>和<code>“ ”</code>之间要空格； <code>&quot;</code>和<code>=</code>之间要空格。否则if语句中的符号会解析失败。</li>
<li>shell变量没有数据类型的区分，把任何存储在变量中的值，皆视为“字符串”</li>
<li>对于变量可能为空的情况，需要用双括号<code>[[ $a = &quot;abc&quot; ]]</code></li>
<li>if-then可以写在同一行，用;分隔两个语句：<code>if [ $a = &quot;abc&quot; ];then</code></li>
</ul>
<h1 id="不同类型的判断语句"><a href="#不同类型的判断语句" class="headerlink" title="不同类型的判断语句"></a>不同类型的判断语句</h1><h2 id="关系运算符判断"><a href="#关系运算符判断" class="headerlink" title="关系运算符判断"></a>关系运算符判断</h2><p>-eq    检测两个数是否相等，相等返回 true。    [ $a -eq $b ] 返回 false。</p>
<p>-ne    检测两个数是否不相等，不相等返回 true。    [ $a -ne $b ] 返回 true。</p>
<p>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ] 返回 false。</p>
<p>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ] 返回 true。</p>
<p>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。    [ $a -ge $b ] 返回 false。</p>
<p>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。    [ $a -le $b ] 返回 true。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>
<h2 id="布尔和逻辑运算符判断"><a href="#布尔和逻辑运算符判断" class="headerlink" title="布尔和逻辑运算符判断"></a>布尔和逻辑运算符判断</h2><p>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ] 返回 true。</p>
<p>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ] 返回 true。</p>
<p>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a == $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>
<p>&amp;&amp;    逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</p>
<p>||    逻辑的 OR    [[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<pre><code>#!/bin/bash

a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>
<h2 id="字符串运算符判断"><a href="#字符串运算符判断" class="headerlink" title="字符串运算符判断"></a>字符串运算符判断</h2><p>&#x3D;    检测两个字符串是否相等，相等返回 true。    [ $a &#x3D; $b ] 返回 false。</p>
<p>!&#x3D;    检测两个字符串是否相等，不相等返回 true。    [ $a !&#x3D; $b ] 返回 true。</p>
<p>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。  </p>
<p>-n    检测字符串长度是否不为 0，不为 0 返回 true。    [ -n “$a” ] 返回 true。</p>
<p><code>$</code> 检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。</p>
<pre><code>#!/bin/bash

a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a != $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a = $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n &quot;$a&quot; ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>
<h2 id="文件检查运算符判断"><a href="#文件检查运算符判断" class="headerlink" title="文件检查运算符判断"></a>文件检查运算符判断</h2><p>b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ] 返回 false。</p>
<p>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -c $file ] 返回 false。</p>
<p>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ] 返回 false。</p>
<p>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。</p>
<p>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] 返回 false。</p>
<p>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。</p>
<p>-p file    检测文件是否是有名管道，如果是，则返回 true。    [ -p $file ] 返回 false。</p>
<p>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。</p>
<p>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。</p>
<p>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。</p>
<p>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。</p>
<p>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。</p>
<p>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。</p>
<p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。</p>
<pre><code>#!/bin/bash

file=&quot;/root/test.sh&quot;

if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>
<h1 id="判断语句报错：”unary-operator-expected”"><a href="#判断语句报错：”unary-operator-expected”" class="headerlink" title="判断语句报错：”unary operator expected”"></a>判断语句报错：”unary operator expected”</h1><p>在匹配字符串相等时，用了类似这样的语句：</p>
<pre><code>if [ $STATUS == &quot;OK&quot; ]; then     
echo &quot;OK&quot;
fi
</code></pre>
<p>在运行时出现了 <code>[: =: unary operator expected</code> 的错误</p>
<pre><code>if [[ $STATUS == &quot;OK&quot; ]]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>究其原因，是因为如果变量STATUS值为空，那么就成了 [ &#x3D; “OK”] ，显然 [ 和 “OK” 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。<br>或者用下面的方法也能避免这种错误：</p>
<pre><code>if [ &quot;$STATUS&quot;x == &quot;OK&quot;x ]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>当然，x也可以是其他字符。shell中有没有双引号在很多情况下是一致的,因此x可以不加引号。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：实现芯片固件的批量编译</title>
    <url>/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某软件有不同的配置参数，实现不同功能版本的编译<br>批量测试需要批量编译各种版本，实现方式为：<br>1.将编译参数组合，生成大量配置文件<br>2.编译过程遍历这些配置文件，依次编译对应版本<br>3.有参数加入，修改，删除，只需要更新这些配置文件<br>如何实现这些配置文件的更新？</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某芯片的Firmware批量编译实现：<br>Firmware代码为C, 配置参数用宏实现，后缀为.def<br>目录结构如下</p>
<p>|–project_folder<br>　　|–config<br>　　　|–build.def<br>　　　|–defs<br>　　　　　|–1.def 2.def … n.def<br>　　|–src<br>　　|–Makefile<br>　　|–build_All.sh<br>　　|–update.sh</p>
<h2 id="批量编译脚本"><a href="#批量编译脚本" class="headerlink" title="批量编译脚本"></a>批量编译脚本</h2><p>批量编译脚本如下<br>基本过程：<br>1.依次拷贝def文件夹中的每个def，替换默认的build.def<br>2.编译，接受所有编译参数<br>3.拷贝编译输出的image到包含git tag, def名，时间等信息的文件夹</p>
<pre><code>#!/bin/bash

echo &quot;Batch build support args:&quot;
echo &quot;1. functin version:&quot;
echo &quot;verargs=mp_fpga&quot;
echo &quot;verargs=mpw_asic&quot;
echo &quot;2. boot debug:&quot;
echo &quot;bootargs=debug&quot;

OUTPUT=batch_build_$1$2

mkdir -p $&#123;OUTPUT&#125;
rm -rf ./batch_build_*

build_time=`date +%Y%m%d%H%M%S`

#commit_id=`git rev-parse HEAD`

tag_name=`git describe --exact-match --tags 2&gt;/dev/null`

if [ -z &quot;$&#123;tag_name&#125;&quot; ]; then
    tag_name=&quot;NO_TAG&quot;
fi

mv ./config/build.def ./config/build.def.bak 

for file in `ls ./config/defs/*.def`;
do
    file_name=$&#123;file##*/&#125;
    config_name=$&#123;file_name%.def&#125;
    
    cp -rf $&#123;file&#125; ./config/build.def
    make clean
    make -j4 $@
    #mv ./build/image ./batch_build/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;_cid_$&#123;commit_id&#125;
    mkdir -p ./$&#123;OUTPUT&#125;/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;
    mv ./build/image/* ./$&#123;OUTPUT&#125;/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;
done

mv ./config/build.def.bak ./config/build.def
</code></pre>
<p>def文件内的.def文件即各种参数配置文件，.def文件名即参数功能的别名组合<br>例如：</p>
<pre><code>CQ_emmc_two_card_enhance_hs400_always_l0_MSIx_dllphase14_tuning_on.def
</code></pre>
<p>对应的内容是：</p>
<pre><code>/*0: Non-CQ mode 1:CQ mode enable*/
#define BB_CQ_MODE_ENABLE 1
/*the card number support emmc#0:0 emmc#1:1 two card:2*/
#define BB_CARD_NUMBER 2
/*0:legacy 1:High Speed 50MHz 2:HS200 3:HS400 4:Enhance HS400*/
#define BB_MAX_TRANSFER_MODE 4
/* power mode management: 0: Low Power 1:Balance 2:High Performance 3:Direct HP 4:Always L0*/
#define POWER_MANAGEMENT_MODE 4
/* INT_MODE: 0:MSI_X 1:INTx 2:MSI_MULTIPLE 3:MSI_SINGLE */
#define INT_MODE 0
/* The selection of DLL PHASE COUNT is 11 or 14 */
#define DLL_phase_cnt 14
/* 0: fixed output phase  1: auto output tuning */
#define AUTO_OUTPUT_TUNING 1
</code></pre>
<h2 id="批量编辑配置文件"><a href="#批量编辑配置文件" class="headerlink" title="批量编辑配置文件"></a>批量编辑配置文件</h2><p>配置文件def有两个属性<br>1.文件名每个词代表一个功能，各词用下划线“_”分隔<br>2.内部用宏定义实现功能配置，宏定义的值要和外部文件名匹配</p>
<p>基于以上属性，编辑脚本需求为：<br>1.新增：增加一个宏定义，并增加对应的功能缩写到文件名<br>2.修改：修改一个已存在的宏定义，并修改对应的功能缩写到文件名<br>3.删除：删除一个已存在的宏定义，并删除对应的功能缩写到文件名<br>4.其他功能，如直接删除含某缩写的文件，备份原配置文件</p>
<p>shell实现为update.sh,如下:</p>
<pre><code>#!/bin/bash

DEFS_PATH=&quot;./config/defs&quot;
DEFS_BACKUP_PATH=&quot;./config/defs_backup&quot;
DEFS_TEMP_PATH=&quot;./config/defs_temp&quot;

if [ $# -lt 1 ];then
        echo &quot;usage: ./update.sh [option] [args]&quot;

        echo &quot;example 0:&quot;
        echo &quot;        backup defs files:&quot;
        echo &quot;        ./update.sh -bf&quot;
        echo &quot;&quot;

        echo &quot;example 1:&quot;
        echo &quot;        add a macro name and macro value to defs, and add file postfix:&quot;
        echo &quot;        ./update.sh -b&quot;
        echo &quot;        ./update.sh -a balance POWER_MANAGEMENT_MODE 1 &quot;
        echo &quot;        ./update.sh -a high_performance POWER_MANAGEMENT_MODE 2 &quot;
        echo &quot;        add other values...&quot;
        echo &quot;&quot;

        echo &quot;example 2:&quot;
        echo &quot;        update a macro name and macro value to defs, and update file postfix:&quot;
        echo &quot;        ./update.sh -u balance lowpower POWER_MANAGEMENT_MODE 1 &quot;
        echo &quot;&quot;

        echo &quot;example 3:&quot;
        echo &quot;        delete a macro name and macro value of defs, and delete file postfix:&quot;
        echo &quot;        ./update.sh -d lowpower POWER_MANAGEMENT_MODE&quot;
        echo &quot;&quot;

        echo &quot;example 4:&quot;
        echo &quot;        delete target files:&quot;
        echo &quot;        ./update.sh -df lowpower&quot;
        echo &quot;&quot;

        echo &quot;example 5:&quot;
        echo &quot;        clean backup defs files:&quot;
        echo &quot;        ./update.sh -cf&quot;
        echo &quot;&quot;

        exit;
    fi

if [ $1 = &quot;-bf&quot; ];then #backup defs
    mkdir -p $DEFS_BACKUP_PATH
    mv $DEFS_PATH/*.def $DEFS_BACKUP_PATH

elif [ $1 = &quot;-cf&quot; ];then #clear backup defs
    rm -rf $DEFS_BACKUP_PATH
</code></pre>
<p>​<br>​    #add a macro name and macro value to defs, and add file postfix<br>​    elif [ $1 &#x3D; “-a” ];then<br>​<br>        if [ $# !&#x3D; 4 ];then<br>            echo “usage: .&#x2F;update.sh -a FILE_POSTFIX MACRO_NAME MACRO_VALUE”<br>            exit;<br>        fi</p>
<pre><code>    mkdir -p $DEFS_TEMP_PATH &amp;&amp; cp -rf $DEFS_BACKUP_PATH/*.def $DEFS_TEMP_PATH
    
    FILE_POSTFIX=$2
    MACRO_NAME=$3
    MACRO_VALUE=$4
    # sed -i makes change on original file, otherwise on stream
    # xargs transfer multiple output from stream to multiple args to sed
    find $&#123;DEFS_TEMP_PATH&#125; -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
    
    for file in `ls $&#123;DEFS_TEMP_PATH&#125;/*.def`
    do
     mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
    done
    
    cp -rf $DEFS_TEMP_PATH/*.def $DEFS_PATH
    rm -rf $DEFS_TEMP_PATH

#update a macro name and macro value to defs, and update file postfix
elif [ $1 = &quot;-u&quot; ];then

    if [ $# != 5 ];then
        echo &quot;usage: ./update.sh -u ORIGIN_POSTFIX UPDATED_POSTFIX MACRO_NAME MACRO_UPDATED_VALUE&quot;
        exit;
    fi

    ORIGIN_POSTFIX=$2
    UPDATED_POSTFIX=$3
    MACRO_NAME=$4
    MACRO_UPDATED_VALUE=$5

    #replace all lines that pattern matches $MACRO_NAME
    find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
    #update file postfix
    for file in `ls $&#123;DEFS_PATH&#125;/*$ORIGIN_POSTFIX*.def`
    do
         mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
    done
</code></pre>
<p>​<br>​    #delete a macro name and macro value of defs, and delete file postfix<br>​    elif [ $1 &#x3D; “-d” ];then<br>​<br>        if [ $# !&#x3D; 3 ];then<br>            echo “usage: .&#x2F;update.sh -d DELETE_POSTFIX MACRO_NAME”<br>            exit;<br>        fi</p>
<pre><code>    DELETE_POSTFIX=$2
    MACRO_NAME=$3
    #delete all lines that contain $MACRO_NAME
    find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
    #delete file postfix
    for file in `ls $&#123;DEFS_PATH&#125;/*.def`
    do
         mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
    done

#delete target file by postfix
elif [ $1 = &quot;-df&quot; ];then
    
    if [ $# != 2 ];then
        echo &quot;usage: ./update.sh -df DELETE_POSTFIX&quot;
        exit;
    fi

    DELETE_POSTFIX=$2
    rm -f $&#123;DEFS_PATH&#125;/*$DELETE_POSTFIX*.def

fi
</code></pre>
<p><strong>重点讲下其中的几个sed和文件操作</strong><br>1.多个文件，每个文件最后一行追加内容</p>
<pre><code>find $&#123;DEFS_TEMP_PATH&#125; -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
</code></pre>
<ul>
<li>xargs的作用： find <path> -name <string> 输出的是多个文件名，不能直接传给sed， <strong>xargs将多个文件名转化成多个参数</strong>，每个参数是一个文件名，sed可以接收</li>
<li>-i的作用：sed本身是在文件的拷贝上操作，不直接在文件本身修改，-i（insert）使sed的操作在文件上生效，<strong>如果不加-i，源文件不会被修改</strong></li>
<li>$：表示最后一行，sed ‘a\string’是基础格式</li>
<li>注意sed怎么用带空格和变量的字符串：<strong>空格用转义’\ ‘表示，变量是单引号内加双引号</strong>，即’”$ARG”‘</li>
</ul>
<p>2.找到包含字符串A的所有文件，替换内容：将字符串B替换为C</p>
<pre><code>#replace all lines that pattern matches $MACRO_NAME
find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
</code></pre>
<ul>
<li>find | grep 是常用套路，先找在过滤，注意find -name 可以使用*， grep不要用*，否则grep会把它当成要匹配的字符</li>
<li>sed ‘s&#x2F;stringB&#x2F;stringC’是基础格式，g表示全局，注意要-i</li>
</ul>
<p>3.找到包含字符串A的所有文件，删除内容：包含字符串B的行</p>
<pre><code>#delete all lines that contain $MACRO_NAME
find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
</code></pre>
<p>4.对多个文件的文件名，增加，修改，删除特定字符串</p>
<pre><code>#在原文件名最后，后缀之前，增加字符串“_$FILE_POSTFIX”
for file in `ls $&#123;DEFS_TEMP_PATH&#125;/*.def`
    do
     mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
    done

#替换文件名中匹配的字符
for file in `ls $&#123;DEFS_PATH&#125;/*$ORIGIN_POSTFIX*.def`
do
     mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
done

#删除文件名指定字符
for file in `ls $&#123;DEFS_PATH&#125;/*.def`
do
     mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
done
</code></pre>
<ul>
<li>for &lt; args &gt; in `ls &lt; path &gt;`是把多个文件名依次写入变量args的常用操作，类似于xargs，不过是用循环每次处理一个文件名变量</li>
<li>mv $file `echo $file | sed ‘s&#x2F;stringA&#x2F;stringB&#x2F;g’&#96;实际是两个步骤：先用echo把当前处理的文件名传给sed, sed处理完的输出文件名，作为mv的目标文件名，覆盖了原文件</li>
<li>注意，文件名xargs传给sed,处理的是文件内容，for-in-do一个个mv，才是处理文件名本身</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://linux.cn/article-11367-1.html">使用 sed 命令查找和替换文件中的字符串的 16 个示例</a><br><a href="https://blog.csdn.net/weixin_40572607/article/details/90812959">sed引入变量的几种方法</a><br><a href="https://blog.csdn.net/elong490/article/details/52587171">sed 批量替换文件内容</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：文本编辑利器sed+awk+grep</title>
    <url>/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/</url>
    <content><![CDATA[<h1 id="shell增删改查概述"><a href="#shell增删改查概述" class="headerlink" title="shell增删改查概述"></a>shell增删改查概述</h1><p>Linux Shell环境对文本增删改查，可以通过sed，awk和grep命令完成。</p>
<ul>
<li>sed: 支持特定模式匹配的增加、插入、删除、替换、提取等操作</li>
<li>awk: 支持特定模式匹配的过滤查找，如提取某行列的字符串</li>
<li>grep: 支持包含特定字符串的结果提取，可配合find和awk实现过滤查找</li>
</ul>
<p>这几种命令都支持流输入和文本输入，支持管道传递参数，也可以命令行传参。对于多个步骤的处理，可以几个命令串行使用。</p>
<h1 id="shell的输入参数概述"><a href="#shell的输入参数概述" class="headerlink" title="shell的输入参数概述"></a>shell的输入参数概述</h1><p>Shell的命令，如<code>cat, echo, sed, awk, grep</code>, 管道命令<code>|</code>等，都要有输入参数，即待处理的数据。<br>输入参数有两种类型：</p>
<ul>
<li>标准输入：本质是stdin文件，即读取该文件的内容作为命令的输入参数，该文件内容可由其他命令的输出，或者用户输入来产生</li>
<li>命令行输入：直接接受用户在命令行输入的字符串，一次性使用,不存储在stdin</li>
</ul>
<p>支持标准输入作为参数的命令：<code>cat, sed, awk, grep, |</code> 等<br>只支持命令行输入字符串的命令：<code>echo, ls</code>等<br>标准输入示例：</p>
<pre><code>cat /etc/passwd | grep root
</code></pre>
<p>上面的代码使用了管道命令<code>|</code>，管道命令的作用是将左侧命令<code>cat /etc/passwd</code>的标准输出转换为标准输入，提供给右侧命令<code>grep root</code>作为参数。<br>以上命令也可以写成命令行输入形式：</p>
<pre><code>grep root /etc/passwd
</code></pre>
<p>不支持标准输入的示例：</p>
<pre><code>echo &quot;hello world&quot; | echo
</code></pre>
<p>输出为空，管道右侧的echo不接受管道传来的标准输入作为参数。<br>xargs的作用：将标准输入转为命令行参数</p>
<pre><code>echo &quot;hello world&quot; | xargs echo
</code></pre>
<p>输出“hello world”，xargs和管道配合使用，能使管道也支持非标准输入命令。<br>xargs支持一些选项做进一步细化处理，如-p(打印), -d(分割) 等。</p>
<h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><h2 id="sed命令概述"><a href="#sed命令概述" class="headerlink" title="sed命令概述"></a>sed命令概述</h2><p>sed支持文本编辑，实现增、删、改的功能。<br>sed命令格式：</p>
<pre><code>sed [options] &#39;command&#39; filename
</code></pre>
<p>sed的输入参数可以用命令行，管道和xargs传入：</p>
<pre><code>//命令行传入文件名参数
sed [options] &#39;command&#39; filename 
//管道传入文件名参数
cat filename | sed [options] &#39;command&#39;
//xargs传入文件名参数
cat filename | xargs sed [options] &#39;command&#39;
</code></pre>
<p>sed对文件的编辑在缓冲区，不直接修改文本。要直接修改文本有以下方法：</p>
<ul>
<li>重定向覆盖文本， <code>sed - x &#39;XXX&#39; file.txt &gt; file.txt</code></li>
<li>特定的sed命令支持直接修改文本，如<code>sed -i &#39;XXX&#39; file.txt</code></li>
</ul>
<p>sed的常用选项：</p>
<pre><code>-n ：关闭默认输出,只显示匹配的行
-i ：直接修改读取的文件内容，而不是输出到终端。
-e ：直接在命令列模式上进行sed的动作编辑；
-f ：直接将sed的动作写在一个文件内，-f filename 则可以运行filename内的sed动作；
-r ：启用扩展的正则表达式
</code></pre>
<p>sed的常用命令：</p>
<pre><code>a ：新增行，在指定行的后面附加一行，[address]a\新文本内容
i ：插入行，在指定行的前面插入一行，[address]i\新文本内容
s ：替换特定模式匹配的字符串, [address]s/pattern/replacement/flags
c ：将指定行中的所有内容，替换成该选项后面的字符串, [address]c\用于替换的新文本
d ：删除行，[address]d
p ：打印， 通常与参数 -n 一起用，[address]p
w : 将文本中指定行的内容写入文件, [address]w filename
</code></pre>
<h2 id="sed命令详解"><a href="#sed命令详解" class="headerlink" title="sed命令详解"></a>sed命令详解</h2><p>本节从sed文本操作的“增删改查”举例说明其具体命令用法</p>
<h3 id="新增和插入：a和i"><a href="#新增和插入：a和i" class="headerlink" title="新增和插入：a和i"></a>新增和插入：a和i</h3><p>sed的命令a和i都能实现新增行，其区别在于：</p>
<ul>
<li>a ：append, 指定行后面新增一行</li>
<li>i : insert, 表示在指定行前面插入一行</li>
</ul>
<p>注意区分i命令和i选项<br>a和i命令的基本格式完全相同：</p>
<pre><code>[address]a（或 i）\新文本内容
</code></pre>
<p>将一个新行插入到数据流第三行前：</p>
<pre><code>sed &#39;3i\This is an inserted line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is an inserted line.
This is line number 3.
This is line number 4.
</code></pre>
<p>将一个新行附加到数据流中第三行后:</p>
<pre><code>sed &#39;3a\This is an appended line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is line number 3.
This is an appended line.
This is line number 4.
</code></pre>
<p>将一个多行数据添加到数据流中，只需对要行末尾添加反斜线即可，类似C语言的代码换行</p>
<pre><code>sed &#39;1i\
This is one line of new text.\
This is another line of new text.&#39; data6.txt

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
</code></pre>
<h3 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h3><ul>
<li>d: delete, 删除行</li>
</ul>
<p>格式：</p>
<pre><code>[address]d
</code></pre>
<p>删除第三行：</p>
<pre><code>[root@localhost ~]# cat data6.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
[root@localhost ~]# sed &#39;3d&#39; data6.txt
This is line number 1.
This is line number 2.
This is line number 4.
</code></pre>
<p>删除二、三行：</p>
<pre><code>sed &#39;2,3d&#39; data6.txt
This is line number 1.
This is line number 4.
</code></pre>
<p>删除第三行开始的后续所有行：</p>
<pre><code>[root@localhost ~]# sed &#39;3,$d&#39; data6.txt
This is line number 1.
This is line number 2.
</code></pre>
<p>注意：sed d 命令并不会修改原始文件，这里被删除的行只是从 sed 的缓冲区中消失了，原始文件没做任何改变，若要修改源文件，可重定向sed的输出到源文件，覆盖原内容使修改生效。</p>
<h3 id="匹配定位：-x2F-pattern-x2F"><a href="#匹配定位：-x2F-pattern-x2F" class="headerlink" title="匹配定位：&#x2F;pattern&#x2F;"></a>匹配定位：&#x2F;pattern&#x2F;</h3><p>sed的增删操作，可以针对包含匹配字符串的行进行操作，其原理是活用[address], 支持匹配字符串的定位，以插入命令’i’为例，匹配格式如下：</p>
<pre><code>sed [option] &#39;/匹配字符串/i \插入字符串&#39;
[option] 通常为 -i, 修改直接在源文件生效
</code></pre>
<p>原文件：</p>
<pre><code>cat testfile 
hello
</code></pre>
<p>在包含”hello”的一行的上一行，插入”upline”:</p>
<pre><code>sed -i &#39;/hello/i\upline&#39; testfile
</code></pre>
<p>“hello”下一行插入”upline”:</p>
<pre><code>sed -i &#39;/hello/a\down&#39; testfile
</code></pre>
<p>修改后的文件：</p>
<pre><code>cat testfile 
up
hello
down
</code></pre>
<p>删除匹配到”hello”的行：</p>
<pre><code>sed -i &#39;/hello/d&#39; testfile
</code></pre>
<p>如果匹配字符串有“&#x2F;”，为了和sed命令的分隔符“&#x2F;”，使用“\”转义。<br>例如删除匹配某个路径字符串的行：</p>
<pre><code>匹配&quot;\etc\install.sh&quot;
set -i &#39;/\/etc\/install.sh/d&#39; test.txt
</code></pre>
<p>sed 命令包含一些预定义特殊符号，代表行尾，行首等。<br>删除以A开头的行：</p>
<pre><code>sed -i &#39;/^A.*/d&#39; test.txt
^A表示开头是A, .*表示后跟任意字符串
</code></pre>
<p>在行尾追加一行内容:</p>
<pre><code>sed -i &#39;$a\added-content&#39; test.txt
$表示定位到行尾，a是追加命令，added-content是追加内容
</code></pre>
<h3 id="替换修改-s"><a href="#替换修改-s" class="headerlink" title="替换修改: s"></a>替换修改: s</h3><p>s替换命令内部格式为：</p>
<pre><code>[address]s/pattern/replacement/flags
</code></pre>
<ul>
<li>address 指定要操作的具体行</li>
<li>pattern 指定需要替换的内容</li>
<li>replacement 指定替换的新内容</li>
<li>flags 指定特殊功能</li>
</ul>
<p>常用的flags:</p>
<ul>
<li>n    1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换</li>
<li>g    对数据中所有匹配到的内容进行替换，否则只会在第一次匹配成功时做替换操作</li>
<li>p    会打印与替换命令中指定的模式匹配的行。此标记通常与 -n    选项一起使用</li>
<li>\    转义（转义替换部分包含：&amp;、\ 等）。</li>
</ul>
<p>替换每行第二个匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/2&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the trial script
This is second test of the trial script
</code></pre>
<p>只替换第二行的匹配字符串：</p>
<pre><code>sed &#39;2s/test/trial/&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the test script
This is second test of the trial script
</code></pre>
<p>全局替换所有匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/g&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first trial of the trial script
This is second trial of the trial script
</code></pre>
<h3 id="提取：p"><a href="#提取：p" class="headerlink" title="提取：p"></a>提取：p</h3><p>sed p命令配合字符串匹配，可以输出包含指定字符串的行内容。</p>
<pre><code>sed -n &#39;/string/p&#39; filename
提取filename文件中,所有包含string的行的内容，并打印到标准输出
-n是只打印匹配命中的内容
</code></pre>
<p>sed p和grep都能提取内容，其区别在于：</p>
<ul>
<li><code>sed &#39;/string/p&#39;</code>是提取指定文件的行内容，重点在内容提取</li>
<li><code>grep &quot;string&quot; path</code>是输出包含指定内容的所有文件路径，重点在查找文件位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452182.png" alt="image-20221205145238133"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452191.png" alt="image-20221205145248149"></p>
<h2 id="sed进阶与实战"><a href="#sed进阶与实战" class="headerlink" title="sed进阶与实战"></a>sed进阶与实战</h2><h3 id="多文件批量追加和删除"><a href="#多文件批量追加和删除" class="headerlink" title="多文件批量追加和删除"></a>多文件批量追加和删除</h3><p>背景介绍：<br>底层固件代码有一些功能由宏定义控制，不同功能需要不同的宏定义组合，因此有不同的宏定义文件，命名为.def后缀。批量编译不同版本，编译脚本依次提取def文件夹内的.def文件和源代码一起编译。单个def内容如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453765.png" alt="image-20221205145321718"></p>
<p>每一个宏都有多个取值，因此组合起来，需要生成一堆.def文件，批量编译才能覆盖各自功能。<br>每新增一个宏，都要修改所有.def文件，如果这个宏有两个取值，.def文件数量将翻倍。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453942.png" alt="image-20221205145327892"></p>
<p>人工修改过于低效，使用sed可解决此问题。</p>
<p>查找指定文件，并批量追加一行内容：</p>
<pre><code>find . -name &#39;*.def*&#39; | xargs sed -i &#39;$a\added-content&#39;
</code></pre>
<p>各命令含义：</p>
<pre><code>find [path] -name &quot;*.def&quot;
查找path路径下，以.def结尾的所有文件，结果存储在stdout
|
管道，将查找结果转存到标准输入stdin
xargs
查找结果有很多个，用xargs转成命令行输入，sed才能批量处理
sed -i &#39;$a\added-content&#39;
    -i 直接修改文件，&#39;$a\added-content&#39; 最后一行追加added-content
</code></pre>
<p>查找指定文件，并批量删除匹配某字符串的行：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/deleteString/d&quot;
</code></pre>
<p>查找指定文件，并批量替换匹配某字符串：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/oldString/newString/&quot;
</code></pre>
<p>在实际shell脚本中，通常由用户输入变量，<code>$1, $2, $@</code> 解析变量。a、i、d和s能否在命令中使用双引号解析变量，实现动态编辑？<br>实验如下：</p>
<pre><code>ARGS=&quot;AA BB&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$a\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$i\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/$&#123;ARGS&#125;/d&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/aabb/$ARGS/&quot;
</code></pre>
<ul>
<li>i 和 a 命令不能解析变量，实际追加的就是是${ARGS}</li>
<li>d命令可以解析变量，实际删除的是有”AA BB”的行</li>
<li>s命令可以解析变量，实际替换后的结果是”AA BB”</li>
</ul>
<p>结论：将命令中的单引号改成双引号，理论上可以解析$包含的变量，实际上有的命令支持，有的命令不支持。</p>
<h3 id="提取文件中的关键内容"><a href="#提取文件中的关键内容" class="headerlink" title="提取文件中的关键内容"></a>提取文件中的关键内容</h3><p>背景介绍：<br>底层固件需要将代码段、数据段等关键信息存储在固件头部，编译过程中用编译器的size命令可以获取这些信息，并存储到文本，但是固件头部需要按自己的格式存储起始地址和大小信息，因此需要用sed提取并编辑该文本。</p>
<p>原文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453983.png" alt="image-20221205145348933"></p>
<p>提取后文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453414.png"></p>
<p>sed命令：</p>
<pre><code>sed -n &#39;/string/p&#39; oldFile | awk &#39;&#123;print $3&#125;&#39; &gt;&gt; newFile
提取oldFile内包含string的行，并用awk提取第三列，再写入newFile
</code></pre>
<p>该命令在Makefile实现，需要根据Makefile和shell特性做修改：</p>
<ul>
<li>@：编译过程隐藏命令输出，类似于后台执行</li>
<li>$(shell xxxx): Makefile执行shell命令</li>
<li>$$: Makefile不能直接用shell的“$”解析变量，用“$$”</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051454928.png" alt="image-20221205145409877"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令行笔记</title>
    <url>/2020/02/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="查找包含指定内容的文件"><a href="#查找包含指定内容的文件" class="headerlink" title="查找包含指定内容的文件"></a>查找包含指定内容的文件</h1><pre><code>grep -r 字符串 目录
</code></pre>
<p>示例：查找当前目录的包含“stream”内容的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -r &quot;stream&quot; ./</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux驱动分析：MMC子系统</title>
    <url>/2023/01/31/Linux%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90%EF%BC%9AMMC%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mmc</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC笔记：多线程磁盘读写测试工具</title>
    <url>/2021/03/18/MFC%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MFC（Microsoft Foundation Classes）是微软在win32 API上，用C++封装的GUI框架，在现在，MFC相比其他的GUI框架有些过时，可以参考：<br><a href="https://www.zhihu.com/question/327876401">很多人说 C++ 的 MFC 已经过时了，那新入门的人到底应该学什么？</a><br>不同环境的选择：</p>
<ul>
<li>跨平台： QT</li>
<li>C#: WPF</li>
<li>Web：React，Vue，Electron</li>
</ul>
<p>既然如此，为何本文用MFC？<br>1.部分功能从老MFC项目移植，且VS环境能快速上手<br>2.技术本身不会过时，过时的是应用场景，GUI回调式的交互机制，以及Win32线程和进程的使用都是通用的技术。这是写本文的原因</p>
<p>本文源码：<a href="https://github.com/cursorhu/myMFCForAutoRWTest.git">cursorhu&#x2F;myMFCForAutoRWTest</a></p>
<p>GUI界面：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051510224.png" alt="1"></p>
<h1 id="初识MFC项目"><a href="#初识MFC项目" class="headerlink" title="初识MFC项目"></a>初识MFC项目</h1><p>VS新建MFC项目，例如“myMFC”，目录结构如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514738.png" alt="2"><br>myMFC.cpp是VS自动创建的MFC项目入口，其主要功能是：创建一个窗口实例，注册会话对象（Dialog)<br>界面的交互一定是分层的</p>
<ul>
<li>对用户的是控件层，即各种按钮，输入输出框等可见可操作的东西</li>
<li>处理数据的是逻辑层，例如从输入框输入，底层保存该字符串，点击运行，底层开始执行对应函数</li>
</ul>
<p>在MFC中，会话对象就是处理底层逻辑的类对象，其方法定义在myMFCDlg.cpp<br>也是开发的主要内容</p>
<h2 id="MFC入口"><a href="#MFC入口" class="headerlink" title="MFC入口"></a>MFC入口</h2><p>下面介绍myMFC.cpp的MFC入口：</p>
<pre><code>BOOL CmyMFCApp::InitInstance()
&#123;
    // 如果一个运行在 Windows XP 上的应用程序清单指定要
    // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
    //则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
    INITCOMMONCONTROLSEX InitCtrls;
    InitCtrls.dwSize = sizeof(InitCtrls);
    // 将它设置为包括所有要在应用程序中使用的
    // 公共控件类。
    InitCtrls.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&amp;InitCtrls);

    CWinApp::InitInstance();
    
    AfxEnableControlContainer();

    // 创建 shell 管理器，以防对话框包含
    // 任何 shell 树视图控件或 shell 列表视图控件。
    CShellManager *pShellManager = new CShellManager;

    // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
    CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

    // 标准初始化
    // 如果未使用这些功能并希望减小
    // 最终可执行文件的大小，则应移除下列
    // 不需要的特定初始化例程
    // 更改用于存储设置的注册表项
    // TODO: 应适当修改该字符串，
    // 例如修改为公司或组织名
    SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;));

    CmyMFCDlg dlg;
    m_pMainWnd = &amp;dlg;
    INT_PTR nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    &#123;
        // TODO: 在此放置处理何时用
        //  “确定”来关闭对话框的代码
    &#125;
    else if (nResponse == IDCANCEL)
    &#123;
        // TODO: 在此放置处理何时用
        //  “取消”来关闭对话框的代码
    &#125;
    else if (nResponse == -1)
    &#123;
        TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;);
        TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;);
    &#125;

    // 删除上面创建的 shell 管理器。
    if (pShellManager != nullptr)
    &#123;
        delete pShellManager;
    &#125;

#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)
    ControlBarCleanUp();
#endif

    return FALSE;
&#125;
</code></pre>
<p>只需要关注这几句</p>
<pre><code>CmyMFCDlg dlg;
m_pMainWnd = &amp;dlg;
INT_PTR nResponse = dlg.DoModal();
</code></pre>
<p>CmyMFCDlg类是在myMFCDlg.cpp定义的，即底层逻辑类。m_pMainWnd是myMFC.cpp的CmyMFCApp类(继承win32 API)的成员，表示主窗口，这两句就是把会话对象注册到窗口类，这样窗口运行时可以回调会话对象的方法。dlg.DoModal()是运行会话窗口，运行哪个会话？其调用者CmyMFCDlg类对象dlg。</p>
<h2 id="MFC逻辑层"><a href="#MFC逻辑层" class="headerlink" title="MFC逻辑层"></a>MFC逻辑层</h2><p>VS自动创建myMFC项目的会话逻辑层，myMFCDlg.cpp<br>几个自动生成的方法如下，这里为了作为示例，加了自定义的类成员m_src, m_dst和方法OnBnClickedButtonsrc，OnBnClickedButtondst<br>(1)会话类构造函数</p>
<pre><code>CmyMFCDlg::CmyMFCDlg(CWnd* pParent /*=nullptr*/)
    : CDialogEx(IDD_MYMFC_DIALOG, pParent)
    , m_src(_T(&quot;&quot;)) //初始化为空串，_T是兼容不同编码的转换
    , m_dst(_T(&quot;&quot;))
&#123;
    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
&#125;
</code></pre>
<p>(2)界面和类成员数据关联</p>
<pre><code>void CmyMFCDlg::DoDataExchange(CDataExchange* pDX)
&#123;
    CDialogEx::DoDataExchange(pDX);
    DDX_Text(pDX, IDC_EDIT_src, m_src); //关联m_src和IDC_EDIT_src控件，该控件是界面输入框
    DDX_Text(pDX, IDC_EDIT_dst, m_dst);
&#125;
</code></pre>
<p>(3)界面和类方法的关联</p>
<pre><code>BEGIN_MESSAGE_MAP(CmyMFCDlg, CDialogEx)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_BUTTON_src, &amp;CmyMFCDlg::OnBnClickedButtonsrc) //关联IDC_BUTTON_src按钮和OnBnClickedButtonsrc方法
    ON_BN_CLICKED(IDC_BUTTON_dst, &amp;CmyMFCDlg::OnBnClickedButtondst)
END_MESSAGE_MAP()
</code></pre>
<p>类在头文件的定义：</p>
<pre><code>class CmyMFCDlg : public CDialogEx
&#123;
// 构造
public:
    CmyMFCDlg(CWnd* pParent = nullptr);    // 标准构造函数

// 对话框数据
#ifdef AFX_DESIGN_TIME
    enum &#123; IDD = IDD_MYMFC_DIALOG &#125;;
#endif

    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
    HICON m_hIcon;

    // 生成的消息映射函数
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    DECLARE_MESSAGE_MAP()
    
public:
    CString m_src; //CString: MFC的字符串类型
    CString m_dst;
    afx_msg void OnBnClickedButtonsrc(); //afx_msg: MFC的方法对应的消息响应类型
    afx_msg void OnBnClickedButtondst();
&#125;;
</code></pre>
<p>在VS环境下,这些变量和方法的定义都不需要写代码，在控件资源视图直接配置即可。</p>
<h2 id="界面资源层"><a href="#界面资源层" class="headerlink" title="界面资源层"></a>界面资源层</h2><p>注意项目文件有个Resource.h，包含界面相关的资源，如每个按钮有个ID，这个不要手动配置，在编辑UI控件时自动生成</p>
<pre><code>//&#123;&#123;NO_DEPENDENCIES&#125;&#125;
// Microsoft Visual C++ 生成的包含文件。
// 供 myMFC.rc 使用
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MYMFC_DIALOG                102
#define IDR_MAINFRAME                   128
#define IDC_BUTTON_src                  1000
#define IDC_BUTTON_dst                  1001
</code></pre>
<p>myMFC.rc是UI的资源文件，打开就是UI界面<br><img src="C:\Users\thomas.hu\Desktop\3.png" alt="3"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514703.png" alt="4"><br>可以看到界面的按钮，右键查看属性，可以修改标题和控件ID，会映射到Resource.h。双击按钮，myMFCDlg.cpp会自动创建方法<code>CmyMFCDlg::OnBnClickedButtondst()</code>，头文件自动加方法声明。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514147.png" alt="5"></p>
<p>前文的Dlg.cpp中的控件ID, dlg类的方法，变量，从一开始就可以从资源界面配置，自动生成：</p>
<ul>
<li>在资源界面选按钮或其他控件</li>
<li>右键配置控件ID</li>
<li>右键添加值变量或控件变量</li>
<li>双击添加方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515208.png" alt="6"><br>关于值变量和控件变量：<br>值变量用于关联界面和类成员，值变量就是类成员名，例如点击dst按钮调用其方法后，获得的路径，会写入m_dst值变量<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051512803.png" alt="7"><br>控件变量代表控件本身，用于底层逻辑中，直接调用控件的方法，例如控件变量叫dst_ctrl，可以在某个方法中<code>ctrl_dst.SetWindowText(_T(&quot;&quot;))</code>清空界面的字符串<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051512701.png" alt="8"></p>
<h1 id="简单拷贝校验的实现"><a href="#简单拷贝校验的实现" class="headerlink" title="简单拷贝校验的实现"></a>简单拷贝校验的实现</h1><p>实现从src目录拷贝所有文件到dst目录，并比较拷贝前后的文件是否一致</p>
<h2 id="获取文件路径"><a href="#获取文件路径" class="headerlink" title="获取文件路径"></a>获取文件路径</h2><p>两个路径选择按钮和对应的编辑框显示路径，一个Start按钮<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051513686.png" alt="9"></p>
<p>button src的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonsrc()
&#123;
    CString SrcPath;
    SrcPath = GetFolderPath(); //获取文件夹路径
    ctrl_src.SetWindowText(SrcPath); //显示获取的路径字符串
    m_src = SrcPath; //保存路径到会话对象的变量
&#125;
</code></pre>
<p>GetFolderPath打开一个目录框，让用户选择：<br>SHBrowseForFolder是win32 API，专用于打开目录</p>
<pre><code>CString CmyMFCDlg::GetFolderPath(void)
&#123;
    CString strPath;
    BROWSEINFO bInfo;
    ZeroMemory(&amp;bInfo, sizeof(bInfo));
    bInfo.hwndOwner = m_hWnd;
    bInfo.lpszTitle = _T(&quot;Select Folder: &quot;);
    bInfo.ulFlags = BIF_RETURNONLYFSDIRS;

    LPITEMIDLIST lpDlist;                    
    lpDlist = SHBrowseForFolder(&amp;bInfo); //win32 API, 打开目录    
    if (lpDlist != NULL)                        
    &#123;
        TCHAR chPath[255];                    
        SHGetPathFromIDList(lpDlist, chPath);
        strPath = chPath;                    
    &#125;
    return strPath;
&#125;
</code></pre>
<p>如果是打开文件，用CFileDialog</p>
<pre><code>CString CmyMFCDlg::GetFilePath(void)
&#123;
    CFileDialog mFileDlg(TRUE, NULL, NULL,
        OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_NOCHANGEDIR,
        _T(&quot;All Files(*.*)|*.*||&quot;), AfxGetMainWnd());
    CString str(&quot; &quot;, 10000);
    mFileDlg.m_ofn.lpstrFile = str.GetBuffer(10000);
    mFileDlg.m_ofn.lpstrTitle = _T(&quot;Select File&quot;);
    str.ReleaseBuffer();
    mFileDlg.DoModal();
    POSITION mPos = mFileDlg.GetStartPosition();
    CFileStatus status;
    CString strPath;
    while (mPos != NULL)
    &#123;
        strPath = mFileDlg.GetNextPathName(mPos);
        CFile::GetStatus(strPath, status);
    &#125;
    return strPath;
&#125;
</code></pre>
<p>不管哪一种，效果如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515196.png" alt="10"><br>选择完后，路径会在编辑框显示，这就是控件语句<code>ctrl_src.SetWindowText(SrcPath)</code>的效果<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515342.png" alt="11"></p>
<h2 id="拷贝和比较"><a href="#拷贝和比较" class="headerlink" title="拷贝和比较"></a>拷贝和比较</h2><p>拷贝函数如下，只需关注几个函数：</p>
<ul>
<li>CFileFind类的CFileFind(), FindNextFile(), GetFilePath(), GetFilePath()，这些都是afx.h定义，属于MFC库的类</li>
<li>CopyFile()， 执行拷贝，这个也是继承自MFC类</li>
</ul>
<p>代码：</p>
<pre><code>BOOL CmyMFCDlg::ModeTestCopyFileFromSRCtoDST(CString SRC, CString DST, CString&amp; StrResult)
&#123;

    CFileFind ff, ff_DST;
    CString SRCDir = SRC;                 //source folder path
    CString DSTDir = DST;
    UINT copyFileResult = 0;
    int i = 0;

    BOOL bmakedir = MakeDirectory(DSTDir);

    if (SRCDir.Right(1) != _T(&quot;\\&quot;))
        SRCDir += _T(&quot;\\&quot;);
    SRCDir += _T(&quot;*.*&quot;);

    if (DSTDir.Right(1) != _T(&quot;\\&quot;))
        DSTDir += _T(&quot;\\&quot;);
</code></pre>
<p>​<br>​        SetLastError(0);<br>​        CString DST_tmp &#x3D; DSTDir + _T(“<em>.</em>“);<br>​        BOOL res_DST &#x3D; ff_DST.FindFile(DST_tmp);<br>​        if (res_DST &#x3D;&#x3D; 0)<br>​        {<br>​            StrResult.Format(_T(“Access DST folder error, error code is %d. “), GetLastError());<br>​        }<br>​        BOOL res &#x3D; ff.FindFile(SRCDir);<br>​<br>        while (res)<br>        {<br>            res &#x3D; ff.FindNextFile();<br>            if (!ff.IsDirectory() &amp;&amp; !ff.IsDots())<br>            {<br>                CString DSTFildPath;<br>                CString SRCFilePath &#x3D; ff.GetFilePath();<br>                DSTFildPath &#x3D; DSTDir + ff.GetFileName();<br>                copyFileResult &#x3D; CopyFile(ff.GetFilePath(), DSTFildPath, FALSE);</p>
<pre><code>            Sleep(2000);

            if (copyFileResult == 0)
            &#123;
                DWORD ErrCode = GetLastError();
                StrResult.Format(_T(&quot;CopyFile failed! The ErrCode is %d. &quot;), ErrCode);

                for (i = 0; i &lt; 10; i++)
                &#123;
                    copyFileResult = CopyFile(ff.GetFilePath(), DSTFildPath, FALSE);
                    Sleep(2000);
                    if (copyFileResult == 0)
                    &#123;
                        ErrCode = GetLastError();
                        StrResult.Format(_T(&quot;Retry CopyFile failed! The ErrCode is %d. &quot;), ErrCode);
                    &#125;
                    else
                    &#123;
                        break;
                    &#125;
                &#125;

                if (copyFileResult == 0)
                &#123;
                    ff.Close();
                    return FALSE;
                &#125;
            &#125;
        &#125;
        else if (ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFildPath;
            DSTFildPath = DSTDir + ff.GetFileName();
            copyFileResult = ModeTestCopyFileFromSRCtoDST(ff.GetFilePath(), DSTFildPath, StrResult);
            if (copyFileResult == 0)
                break;
        &#125;
    &#125;

    ff.Close();
    if (copyFileResult == 0)
        return FALSE;
    else
        return TRUE;
&#125;
</code></pre>
<p>比较两个路径的文件：<br>其方法是，文件读到buffer, 再用memcmp比较buffer, 其FindNextFile也是如何从目录搜索到文件的关键方法</p>
<pre><code>BOOL CmyMFCDlg::ModeTestCompareFilesBetweenSRCandDST(CString SRC, CString DST, CString&amp; StrResult)
&#123;
    CFileFind ff;
    CString SRCDir = SRC;
    CString DSTDir = DST;
    BOOL bRes = TRUE;
    HANDLE hSrcFile, hDstFile;
    DWORD dwSRCFile, dwDSTFile, dwCB;

    if (SRCDir.Right(1) != _T(&quot;\\&quot;))
        SRCDir += _T(&quot;\\&quot;);
    SRCDir += _T(&quot;*.*&quot;);

    if (DSTDir.Right(1) != _T(&quot;\\&quot;))
        DSTDir += _T(&quot;\\&quot;);
    hSrcFile = hDstFile = NULL;
    BYTE* pSrcBuffer = new BYTE[M_BUFSIZE];
    BYTE* pDstBuffer = new BYTE[M_BUFSIZE];
    memset(pSrcBuffer, 0, M_BUFSIZE);
    memset(pSrcBuffer, 0, M_BUFSIZE);

    BOOL res = ff.FindFile(SRCDir);

    while (res)
    &#123;
        res = ff.FindNextFile();
        if (!ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFilePath;
            DSTFilePath = DSTDir + ff.GetFileName();
            CString SRCFilePath = ff.GetFilePath();

            if (hSrcFile)
            &#123;
                CloseHandle(hSrcFile);
                hSrcFile = NULL;
            &#125;

            if (hDstFile)
            &#123;
                CloseHandle(hDstFile);
                hSrcFile = NULL;
            &#125;

            hSrcFile = CreateFile(SRCFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
            if (hSrcFile == INVALID_HANDLE_VALUE)
            &#123;
                StrResult.Format(_T(&quot;\n Create Source file failed!! Error code = %d \n&quot;), GetLastError());
                bRes = FALSE;
                break;
            &#125;

            hDstFile = CreateFile(DSTFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
            if (hDstFile == INVALID_HANDLE_VALUE)
            &#123;
                StrResult.Format(_T(&quot;\n Create Destination file failed!! Error code = %d \n&quot;), GetLastError());
                bRes = FALSE;
                break;
            &#125;

            LARGE_INTEGER SrcFileSize, DstFileSize;

            dwSRCFile = GetFileSizeEx(hSrcFile, &amp;SrcFileSize);
            dwDSTFile = GetFileSizeEx(hDstFile, &amp;DstFileSize);

            if (SrcFileSize.LowPart != DstFileSize.LowPart)
            &#123;
                StrResult.Format(_T(&quot;\n Compare file is different!! Src Length = %d, Dest Length = %d \n&quot;), SrcFileSize.LowPart, DstFileSize.LowPart);
                bRes = FALSE;
                break;
            &#125;

            while (SrcFileSize.LowPart &gt; 0)
            &#123;
                BOOL bCmpResult;
                bCmpResult = ReadFile(hSrcFile, pSrcBuffer, M_BUFSIZE, &amp;dwCB, NULL);
                if (bCmpResult == 0)
                &#123;
                    bRes = FALSE;
                    break;
                &#125;
                bCmpResult = ReadFile(hDstFile, pDstBuffer, M_BUFSIZE, &amp;dwCB, NULL);
                if (bCmpResult == 0)
                &#123;
                    bRes = FALSE;
                    break;
                &#125;
                bCmpResult = memcmp(pSrcBuffer, pDstBuffer, dwCB);

                if (bCmpResult != 0)
                &#123;
                    bRes = FALSE;
                    CString DiffByte;

                    CString PostCmpErrorStr;
                    CString SrcDumpData, DstDumpData;
                    StrResult.Format(_T(&quot;\n Fatal_Error: Src Data from %d to %d.\n&quot;), (DstFileSize.LowPart - SrcFileSize.LowPart), (DstFileSize.LowPart - SrcFileSize.LowPart + dwCB));

                    PostCmpErrorStr = _T(&quot;SourceFilePath: &quot;) + SRCFilePath + _T(&quot; To \r\n&quot;) + _T(&quot;DstFilePath: &quot;) + DSTFilePath;
                    StrResult = PostCmpErrorStr + _T(&quot;  has compare error! \r\n&quot;);
                    //HugoPostMessageAndShowSD1(PostCmpErrorStr,1);
                    //HugoPostMessageAndShowSD2(PostCmpErrorStr,1);

                    ::MessageBox(
                        NULL,
                        (LPCWSTR)L&quot;Compare error happened!!&quot;,
                        (LPCWSTR)L&quot;Fatal Error!&quot;,
                        MB_OK
                    );

                    break;
                &#125;
                SrcFileSize.LowPart -= dwCB;
            &#125;

            if (bRes == FALSE)
                break;
            else
                ReadFile(hDstFile, pDstBuffer, 512, &amp;dwCB, NULL);
        &#125;
        else if (ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFildPath;
            DSTFildPath = DSTDir + ff.GetFileName();
            bRes = ModeTestCompareFilesBetweenSRCandDST(ff.GetFilePath(), DSTFildPath, StrResult);
            if (bRes == FALSE)
                break;
        &#125;
    &#125;

    if (hSrcFile)
    &#123;
        CloseHandle(hSrcFile);
        hSrcFile = NULL;
    &#125;

    if (hDstFile)
    &#123;
        CloseHandle(hDstFile);
        hSrcFile = NULL;
    &#125;

    if (bRes == FALSE)
    &#123;
        delete[]pSrcBuffer;
        delete[]pDstBuffer;
        ff.Close();
        return FALSE;
    &#125;
    else
    &#123;
        delete[]pSrcBuffer;
        delete[]pDstBuffer;
        ff.Close();
        return TRUE;
    &#125;
&#125;
</code></pre>
<p>关于CString的格式化输出：<a href="https://blog.csdn.net/wangkaishou/article/details/5846152">MFC中CString.Format的详细用法</a><br>关于CFile文件操作：<a href="https://blog.csdn.net/perfectguyipeng/article/details/60148222">MFC——文件操作（CFile）</a></p>
<h2 id="开始按钮"><a href="#开始按钮" class="headerlink" title="开始按钮"></a>开始按钮</h2><p>一般操作顺序：选择src和dst，再点击Start按钮<br>start按钮的方法调用已保存的m_src和m_dst路径，传入拷贝和比较，再输出结果即可，大致流程如下</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonrun()
&#123;
    //读入所有界面数据
    UpdateData(true);
    
    BOOL ret;
    CString outStr;
    
    ret = ModeTestCopyFileFromSRCtoDST(m_src, m_dst, outStr);
    if (!ret)
            MessageBox(NULL, _T(outStr), _T(&quot;ERROR&quot;), MB_OK);
    
    ret = ModeTestCompareFilesBetweenSRCandDST(m_src, m_dst, outStr);
    if (!ret)
            MessageBox(NULL, _T(outStr), _T(&quot;ERROR&quot;), MB_OK);
&#125;
</code></pre>
<p>这里用messagebox输出结果，即弹窗，弹窗是阻塞式的。也可以用编辑框，写文件输出。<br>关于messagebox，参考：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox">MessageBox function (winuser.h)</a><br>关于updateData：<a href="https://www.cnblogs.com/lidabo/archive/2012/07/17/2595464.html">MFC中UpdateData()函数的使用</a><br>以上完成一个简单的文件拷贝和比较功能</p>
<h1 id="多线程文件拷贝和写日志"><a href="#多线程文件拷贝和写日志" class="headerlink" title="多线程文件拷贝和写日志"></a>多线程文件拷贝和写日志</h1><p>将简单拷贝扩展，支持：</p>
<ul>
<li>多线程拷贝和比较，每个线程完成简单拷贝比较的功能</li>
<li>在每个工作线程，输出打印到界面文本框，同时写到同一个日志文件</li>
<li>界面主线程需要等待所有工作线程完成后，输出测试完成信息到文本框和日志</li>
</ul>
<h2 id="线程列表获取各自路径"><a href="#线程列表获取各自路径" class="headerlink" title="线程列表获取各自路径"></a>线程列表获取各自路径</h2><p>add和delete配置几个工作线程，每个线程配置其src和dst路径</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516636.png" alt="12"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516611.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516530.png" alt="14"></p>
<p>这种动态增删的列表，在资源界面新建listbox类型变量和方法：</p>
<pre><code>CListBox m_rwlist;
afx_msg void OnLbnSelchangeListrwlist();
</code></pre>
<p>Add和Delete对应的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonadd()
void CmyMFCDlg::OnBnClickedButtondelete()
</code></pre>
<p>Add和Delete的方法控制listbox变量m_rwlist，选中任意m_rwlist后又会调用其方法OnLbnSelchangeListrwlist，获取每个线程各自的src、dst。</p>
<p>按键控制m_rwlist的实现：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonadd()
&#123;
    CString Threadtest = _T(&quot;TestThread&quot;);
    UINT ThreadCount = m_rwlist.GetCount();
    if (ThreadCount == 0)
    &#123;
        m_rwlist.AddString(_T(&quot;TestThread1&quot;));
    &#125;
    else if (ThreadCount &lt; MAX_THREAD_COUNT)
    &#123;
        CString ThreadNum;
        ThreadNum.Format(_T(&quot;%d&quot;), ThreadCount + 1);
        Threadtest = Threadtest + ThreadNum;
        m_rwlist.AddString(Threadtest);
    &#125;
    else if (ThreadCount == MAX_THREAD_COUNT)
    &#123;
        CString str;
        str.Format(_T(&quot;Only support %d threads at most!!&quot;), MAX_THREAD_COUNT);
        MessageBox(str);
    &#125;
    m_rwlist.SetCurSel(ThreadCount);
    if (ThreadCount &lt; MAX_THREAD_COUNT)
        totalThreadCount++;
&#125;

void CmyMFCDlg::OnBnClickedButtondelete()
&#123;
    UINT ThreadCount = m_rwlist.GetCount();
    if (ThreadCount != 0)
    &#123;
        m_rwlist.DeleteString(ThreadCount - 1);
        m_rwlist.SetCurSel(0);
    &#125;
    if (ThreadCount &gt; 0)
        totalThreadCount--;
&#125;
</code></pre>
<p>线程列表m_rwlist的方法读取路径到会话对象成员变量：</p>
<pre><code>void CmyMFCDlg::OnLbnSelchangeListrwlist()
&#123;
    UpdateData(true); //update true: 从界面读入值到变量（使上次编辑生效）
    if (m_rwlist.GetCount() != 0)
    &#123;
        UINT selectNum = m_rwlist.GetCurSel();
        RWTestParamArray[selectNum].ThreadNum = m_rwlist.GetCount();
        RefreshRWParam(RWTestParamArray, selectNum);
    &#125;
&#125;

void CmyMFCDlg::RefreshRWParam(TabDialogRWTestParam(&amp;Array)[MAX_THREAD_COUNT], UINT CSel)
&#123;
    ctrl_src.SetWindowText(Array[CSel].SRCFolder_Path);
    ctrl_dst.SetWindowText(Array[CSel].DSTFolder_Path);

    UpdateData(false); //update false: 把变量写入到界面（实时显示）
&#125;
</code></pre>
<p>真正读入路径的是dst、src按钮的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonsrc()
&#123;
    CString SrcPath;
    UINT ThreadCSelNum = m_rwlist.GetCurSel();
    SrcPath = GetFolderPath();
    ctrl_src.SetWindowText(SrcPath);
    RWTestParamArray[ThreadCSelNum].SRCFolder_Path = SrcPath;
&#125;

void CmyMFCDlg::OnBnClickedButtondst()
&#123;
    CString DstPath;
    UINT ThreadCSelNum = m_rwlist.GetCurSel();
    DstPath = GetFolderPath();
    ctrl_dst.SetWindowText(DstPath);
    RWTestParamArray[ThreadCSelNum].DSTFolder_Path = DstPath;
&#125;
</code></pre>
<p>线程数组定义在会话类，存储每个工作线程要用的数据</p>
<pre><code>TabDialogRWTestParam RWTestParamArray[MAX_THREAD_COUNT];
typedef struct TabRWParam
&#123;
    CString SRCFolder_Path;
    CString DSTFolder_Path;
    UINT ThreadNum;
    UINT TestTimes;
&#125;TabDialogRWTestParam;
</code></pre>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>创建线程参考MS文档：<a href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-160">beginthread、_beginthreadex</a><br>关注2点：</p>
<ul>
<li>传入线程内要执行的函数，和参数(可为NULL)</li>
<li>返回线程句柄，如果是多个线程则是个数组</li>
</ul>
<p>创建线程的部分代码：</p>
<pre><code>void CmyMFCDlg::RunModeTestInstance()
&#123;
    ....
    
    //线程内除了对象，还需要知道自己是哪个线程，因此打包this和ThreadCount
    pTransParam ThreadTransPArray[MAX_THREAD_COUNT];

    for (int i = 0; i &lt; totalThreadCount; i++)
    &#123;
        ThreadTransPArray[i] = new(TransParam);
        ThreadTransPArray[i]-&gt;i = i;
        ThreadTransPArray[i]-&gt;translpParam = this;

        unsigned int rwThreadID;

        //hThread defined as global data
        hThread[i] = (HANDLE)_beginthreadex(
            NULL,
            0,
            DoThreadProc,
            ThreadTransPArray[i],
            0,
            &amp;rwThreadID);

        if (hThread[i] == NULL)
            MessageBox(_T(&quot;CreateThread Fail!!&quot;), MB_OK);
        
        ....
        
        //release resource
        for (int i = 0; i &lt; totalThreadCount; i++)
        &#123;
            delete ThreadTransPArray[i];
            ThreadTransPArray[i] = NULL;
            CloseHandle(hThread[i]);
        &#125;
    &#125;
</code></pre>
<p>由于要在线程内打印当前是哪个线程，这个从Dlg对象的this指针是获取不到的，因此把this指针和线程id打包结构体，传入DoThreadProc线程函数，结构体如下</p>
<pre><code>typedef struct transParam
&#123;
    LPVOID translpParam;
    int i;
&#125;TransParam, *pTransParam;

#define MAX_THREAD_COUNT 6
</code></pre>
<p>注意使用完后释放线程句柄和其他相关资源</p>
<h2 id="主线程和工作线程的通信：Message机制"><a href="#主线程和工作线程的通信：Message机制" class="headerlink" title="主线程和工作线程的通信：Message机制"></a>主线程和工作线程的通信：Message机制</h2><p>先明白几点：</p>
<ul>
<li>所有工作线程都共享主线程（界面线程）的数据，即会话类对象的成员</li>
<li>界面控件的操作函数，都是主线程独有的，工作线程不能调用</li>
<li>主线程如果要等待工作线程，一般会阻塞</li>
</ul>
<p>问题：<br>如何将工作线程的打印输出到主线程界面控件？</p>
<p>Windows消息机制可以解决工作线程和主线程通信问题，简单的讲，主线程有消息队列，工作线程可以发送消息到消息队列中，主线程用FIFO原则处理队列中的消息，在阻塞等待动作线程时，也支持消息队列的处理。<br>关于消息队列：<a href="https://www.jianshu.com/p/5fd5bdaac69c">windows消息机制（MFC）</a></p>
<p>（1）工作线程函数</p>
<pre><code>unsigned int WINAPI DoThreadProc(void *threadTransParam)
&#123;
    pTransParam pTrans = (pTransParam)threadTransParam;
    CString strResult;
    BOOL res = 0;

    CmyMFCDlg* pDlg = (CmyMFCDlg *)pTrans-&gt;translpParam;
    int thread_id = pTrans-&gt;i;

    for (int i = 0; i &lt; (int)pDlg-&gt;rwtime; i++)
    &#123;
        
        res = pDlg-&gt;ModeTestCopyFileFromSRCtoDST(pDlg-&gt;RWTestParamArray[thread_id].SRCFolder_Path, pDlg-&gt;RWTestParamArray[thread_id].DSTFolder_Path, strResult);

        res = pDlg-&gt;ModeTestCompareFilesBetweenSRCandDST(pDlg-&gt;RWTestParamArray[thread_id].SRCFolder_Path, pDlg-&gt;RWTestParamArray[thread_id].DSTFolder_Path, strResult);
        if (res)
        &#123;
            criticalSec.Lock();
            ::PostMessage(pDlg-&gt;GetSafeHwnd(), WM_USER_MSG, WPARAM(thread_id + 1), LPARAM(i + 1));
            criticalSec.Unlock();
        &#125;
    &#125;

    return res;
&#125;
</code></pre>
<p>几点说明：</p>
<ul>
<li>线程函数要用WINAPI实现，不属于会话类内的方法，因此需要this指针显式调用</li>
<li>rwtime是测试次数，每个线程执行多次拷贝比较</li>
<li>PostMessage是发布消息到主线程消息队列，可以传参：WPARAM和LPARAM</li>
<li>由于不确定PostMessage是不是线程安全，这里加了锁：CCriticalSection类型的criticalSec</li>
</ul>
<p>(2)消息处理函数<br>来看message处理函数：</p>
<pre><code>LRESULT CmyMFCDlg::OnMsg(WPARAM wp, LPARAM lp)
&#123;
    strAppend.Format(_T(&quot;Thread %d src:%s ---&gt; des:%s, Copy&amp;Compare Pass: test loop: %d \n&quot;), wp, RWTestParamArray[wp-1].SRCFolder_Path, RWTestParamArray[wp-1].DSTFolder_Path, lp);
    ShowLogInEditBox(); //字符串显示到界面
    return 0;
&#125;
</code></pre>
<p>主界面字符串显示函数</p>
<pre><code>/* call by message handler, for multiple child thread*/
void CmyMFCDlg::ShowLogInEditBox()
&#123;
    CString str;
    UINT i;

    /*message 队列只在主线程内处理，无需加锁*/
    //criticalSec.Lock();
        WriteLogFile(this-&gt;strAppend); //only write append str
    //criticalSec.Unlock();

    this-&gt;GetDlgItemText(IDC_EDIT_logbox, str);
    str += this-&gt;strAppend; //update old+append str
    str += &quot;\r\n&quot;; //这里换行没用，要在控件设置中允许换行

    this-&gt;SetDlgItemText(IDC_EDIT_logbox, str);

    i = ((CEdit*)GetDlgItem(IDC_EDIT_logbox))-&gt;GetLineCount();
    ((CEdit*)GetDlgItem(IDC_EDIT_logbox))-&gt;LineScroll(++i, 0); //定位到下一行

&#125;
</code></pre>
<p>写日志的相关方法如下：</p>
<pre><code>BOOL CmyMFCDlg::CreateLogFile()
&#123;
    CString strName;
    SYSTEMTIME st;

    GetLocalTime(&amp;st);
    strName.Format(_T(&quot;UtilityLogFile_%4d-%d-%d_%d-%d-%d.log&quot;), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);

    if (!m_File.Open(strName, (CFile::modeCreate | CFile::modeReadWrite), 0))
    &#123;
        ::AfxMessageBox(_T(&quot;Create Utility Log File Error!!&quot;));
        return FALSE;
    &#125;

    m_logCreated = 1;
    return TRUE;
&#125;

void CmyMFCDlg::WriteLogFile(CString str)
&#123;
    BOOL CreateRes = TRUE;

    if (m_logCreated == 0)
        CreateRes = CreateLogFile();

    if (CreateRes)
    &#123;
        str += _T(&quot;\r\n&quot;);
        int length = str.GetLength();
        length *= 2;
        m_File.Write(str, length);
        m_File.Flush();
    &#125;
&#125;

void CmyMFCDlg::CloseLogFile()
&#123;
    if (m_logCreated == 1)
    &#123;
        m_File.Close();
        m_logCreated = 0;
    &#125;
&#125;
</code></pre>
<p>注意message处理函数的关键点：</p>
<ul>
<li>只在主线程中处理，不存在其他线程操作，无临界区问题。因此上述的窗口输出，日志文件写入都是线程安全的。</li>
</ul>
<p>编辑框作为输出要注意几点：</p>
<ul>
<li>换行要在设置里配置，字符串换行没用</li>
<li>设置输出滚动显示</li>
</ul>
<p>效果如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516097.png" alt="15"></p>
<p>（3）线程同步<br>日志完成的输出是主线程等待所有工作线程函数返回后才执行，如何实现？<br>参考：<a href="https://www.cnblogs.com/shangdawei/p/4015772.html">WaitForMultipleObject与MsgWaitForMultipleObjects用法</a><br>我们的需求是主线程在阻塞等待时要处理消息，因此用MsgWaitForMultipleObjects方法。<br>代码如下：</p>
<pre><code>//wait all child threads return

    /*
    //主线程阻塞，不能处理消息
    DWORD dwWaitResult = WaitForMultipleObjects(
        totalThreadCount,
        hThread,
        TRUE,
        INFINITE);
    */
    //主线程阻塞，但不阻塞消息
    int nWaitCount = totalThreadCount;
    int nExitThreadCount = 0;      //标记已经有几个线程退出了
    BOOL bWaitAll = FALSE;        //不等待所有线程完成，实时处理。如果TRUE, 会阻塞到所有线程完成
    DWORD result;
    MSG msg;

    while (TRUE)
    &#123;
        /*该函数等待：多个线程的完成信号，或其他消息信号,有任意一种就返回
        *返回值为[WAIT_OBJECT_0, WAIT_OBJECT_0 + nWaitCount - 1]表示对应下标的线程已完成
        *返回值为WAIT_OBJECT_0 + nWaitCount表示有其他信号，如线程内发送的message
        *WAIT_OBJECT_0值为0
        */
        result = MsgWaitForMultipleObjects(nWaitCount, hThread, bWaitAll, INFINITE, QS_ALLINPUT);

        if (result == WAIT_OBJECT_0 + nWaitCount) //表示收到消息
        &#123;
            while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) //处理所有已入队的消息
            &#123;
                TranslateMessage(&amp;msg); //message translat and format, add into message queue
                DispatchMessage(&amp;msg); //call message handler
            &#125;
        &#125;
        else if (result &gt;= WAIT_OBJECT_0 &amp;&amp; result &lt; WAIT_OBJECT_0 + nWaitCount) //表示收到了线程结束信号
        &#123;
            nExitThreadCount++;
            if (nExitThreadCount &lt; totalThreadCount)
            &#123;
                /*必须更新hThread，否则已退出的线程一直被检测到*/
                int nIndex = result - WAIT_OBJECT_0; //退出线程的index
                hThread[nIndex] = hThread[nWaitCount - 1]; //更新等待列表：hThread, 交换退出的成员和尾部成员
                hThread[nWaitCount - 1] = NULL;

                nWaitCount--; //更新要等待的线程数
            &#125;
            else
            &#123;
                break; //等待的所有线程都已完成
            &#125;
        &#125;
    &#125;

    //All threads returned
</code></pre>
<p>MsgWaitForMultipleObjects的MS说明文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects">MsgWaitForMultipleObjects function (winuser.h)</a><br>返回值的含义是重点，这个文档说的很隐晦：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051517122.png" alt="16"></p>
<p>大意是：等待n个线程</p>
<ul>
<li>如果返回的值i是属于0~n-1，说明第i个工作线程结束了</li>
<li>如果返回值是n，不是线程结束，而是收了到消息，例如工作线程内发送的消息。</li>
</ul>
<p>因此代码逻辑是：<br>1.如果有消息，就处理消息<br>关于message的peek,translate和dispatch:<br><a href="https://blog.csdn.net/caimagic/article/details/50629570">PeekMessage使用方法</a><br><a href="https://blog.csdn.net/wang15061955806/article/details/52066559">消息循环中TranslateMessage和Dispatch函数的作用</a></p>
<p>2.如果有线程结束，要更新线程句柄数组，只保留未等待到的线程；<br>当所有线程都等待到，退出等待循环</p>
<p>以上完成了主线程和多个工作线程的同步机制</p>
<h1 id="再进一步：调用其他进程"><a href="#再进一步：调用其他进程" class="headerlink" title="再进一步：调用其他进程"></a>再进一步：调用其他进程</h1><p>现需求如下：<br>有多个功能的FW需要测试，要求测试工具遍历每个FW, 调用其他的程序，更新到磁盘固件后，做之前的多进程读写比较流程<br>重点关注如何调用其他程序。假设FW更新程序是FirwmareUpdateTool.exe，接受FW相关的参数<br>需要实现：</p>
<ul>
<li>界面接收参数</li>
<li>调用其他程序，传参，且注意与主线程的同步</li>
</ul>
<p>代码：</p>
<pre><code>BOOL CmyMFCDlg::DoUpdateFirmware(CString filename)
&#123;
    TCHAR szFilePath[MAX_PATH + 1] = &#123; 0 &#125;;
    GetModuleFileName(NULL, szFilePath, MAX_PATH);
    (_tcsrchr(szFilePath, _T(&#39;\\&#39;)))[1] = 0;

    CString strToolPath(szFilePath);
    strToolPath = strToolPath + _T(&quot;FirwmareUpdateTool.exe&quot;);
    CString strPath;
    strPath.Format(_T(&quot;%s %s %s %d&quot;), strToolPath.GetBuffer(0), m_str_VendorID.GetBuffer(0), filename.GetBuffer(0), m_SlotID);
    
    strAppend = strPath;
    ShowLogInEditBox();

    if (!PathFileExists(strToolPath))
    &#123;
        strAppend.Format(_T(&quot;The %s is not exist!&quot;), strToolPath.GetBuffer(0));
        ShowLogInEditBox();
        MessageBox(strAppend, MB_OK);
        return FALSE;
    &#125;

    STARTUPINFO si = &#123; sizeof(STARTUPINFO) &#125;;//在产生子进程时，子进程的窗口相关信息
    PROCESS_INFORMATION pi;                  //子进程的ID/线程相关信息
    memset(&amp;pi, 0, sizeof(PROCESS_INFORMATION));
    DWORD returnCode = -1;              //用于保存子程进的返回值;

    BOOL bRet = CreateProcess(              //调用失败，返回0；调用成功返回非0；
        NULL,                               //一般都是空；（另一种批处理情况：此参数指定&quot;cmd.exe&quot;,下一个命令行参数 &quot;/c otherBatFile&quot;)
        strPath.GetBuffer(0),              //命令行参数         
        NULL,                               //_In_opt_    LPSECURITY_ATTRIBUTES lpProcessAttributes,
        NULL,                               //_In_opt_    LPSECURITY_ATTRIBUTES lpThreadAttributes,
        FALSE,                              //_In_        BOOL                  bInheritHandles,
        CREATE_NEW_CONSOLE,                 //新的进程使用新的窗口。
        NULL,                               //_In_opt_    LPVOID                lpEnvironment,
        NULL,                               //_In_opt_    LPCTSTR               lpCurrentDirectory,
        &amp;si,                                //_In_        LPSTARTUPINFO         lpStartupInfo,
        &amp;pi);                               //_Out_       LPPROCESS_INFORMATION lpProcessInformation

    if (bRet)
    &#123;
        while (TRUE) //这里也是为了输出打印和日志而等待进程，同时也阻塞了主线程
        &#123;
            DWORD result;
            MSG msg;
            result = MsgWaitForMultipleObjects(1, &amp;pi.hProcess, FALSE, INFINITE, QS_ALLINPUT);
            if (result == (WAIT_OBJECT_0))
            &#123;
                //获取子进程的返回值
                GetExitCodeProcess(pi.hProcess, &amp;returnCode);
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                break;
            &#125;
            else
            &#123;
                PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE);
                DispatchMessage(&amp;msg);
            &#125;
        &#125;
        strAppend.Format(_T(&quot;%s returnCode : %d &quot;), strToolPath.GetBuffer(0), returnCode);
        ShowLogInEditBox();
    &#125;
    else
    &#123;
        strAppend.Format(_T(&quot;Start the %s failed!&quot;), strToolPath.GetBuffer(0));
        ShowLogInEditBox();
        MessageBox(strAppend, MB_OK);
    &#125;

    if (!returnCode)
    &#123;
        return TRUE;
    &#125;
    return FALSE;
&#125;
</code></pre>
<p>CreateProcess创建进程，执行第三方程序<br>MsgWaitForMultipleObjects等待第三方进程返回，阻塞了当前主进程</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文涉及的知识点：</p>
<ul>
<li>界面控件与底层类的数据交互</li>
<li>MFC的文件，字符串操作</li>
<li>线程创建和线程同步</li>
<li>线程通信：消息机制</li>
<li>进程创建与同步</li>
</ul>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile使用笔记</title>
    <url>/2020/06/10/Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="文件名替换"><a href="#文件名替换" class="headerlink" title="文件名替换"></a>文件名替换</h1><p>1.wildcard<br>展开多个文件为使用空格分开的、匹配此模式的列表参数<br>格式<br><code>$(wildcard PATTERN...)</code></p>
<p>示例：</p>
<pre><code>SRC=$(wildcard *.c)
</code></pre>
<p>2.patsubst<br>替换通配符<br>格式</p>
<pre><code>$(patsubst %.c,%.o,$(dir))
</code></pre>
<p>示例：</p>
<pre><code>obj := $(patsubst %.c,%.o,$(wildcard *.c))
</code></pre>
<p>3.替换引用<br>patsubst的示例等价于：</p>
<pre><code>obj=$(dir:%.c=%.o)
</code></pre>
<p>引用替换：</p>
<pre><code>$(var:a=b) 或 $&#123;var:a=b&#125;
</code></pre>
<p>含义是把变量var中的每一个值，用b替换掉a</p>
<h1 id="PHONY"><a href="#PHONY" class="headerlink" title="PHONY"></a>PHONY</h1><p>Makefile执行的规则是A:B，表示A依赖于B</p>
<ul>
<li>有B才能执行A对应的编译操</li>
<li>B有更新(检测文件时间)，则A会执行，若B没有更新，不执行A</li>
</ul>
<p>问题来了，clean: 不需要依赖任何对象，如何执行<br>PHONY定义伪目标,可以解决源文件不是最终目标直接依赖（即间接依赖）带来的不能自动检查更新规则, 示例如下</p>
<pre><code>.PHONY: clean
clean:
    rm -f *.o
</code></pre>
<p>PHONY不仅用于clean，对于间接依赖也有用，例如A:B， B:C ，有时C为空，就需要把B定义为PHONY</p>
<pre><code>OBJS = *.o
program:  $(OBJS)
        gcc *.o -o program
 
.PHONY : $(OBJS)
$(OBJS):
        make -C $(dir $@)
</code></pre>
<p>不过一般情况，obj依赖于%.c，总之，对于没有依赖项的对象，需要定义为PHONY</p>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>常见通配符</p>
<pre><code>$@, $^, $&lt;, $?

$@  表示目标文件
$^  表示所有的依赖文件
$&lt;  表示第一个依赖文件
$?  表示比目标还要新的依赖文件列表
</code></pre>
<p>示例：<br>编译Test目录下的.cpp文件，输出test可执行程序<br>直接指定依赖文件名的makefile写法：</p>
<pre><code>test: $(wildcard Test/*.cpp)
    $(CXX) $(CFLAGS) -o test $(wildcard Test/*.cpp) 
</code></pre>
<p>虽然wildcard实现了所有依赖的.cpp的通配，编译语句再用wildcard写一次依赖文件不优雅，而且test在依赖中已经写了，编译语句又写一遍 -o test。<br>编译语句使用通配, 称为通用格式：</p>
<pre><code>test: $(wildcard Test/*.cpp)
    $(CXX) $(CFLAGS) -o $@ $^
</code></pre>
<h1 id="多个源文件分别编译"><a href="#多个源文件分别编译" class="headerlink" title="多个源文件分别编译"></a>多个源文件分别编译</h1><p>目录下有很多源文件，每个单独编译和执行的，将每一个文件编译成可执行文件，不用单独命名如：gcc -c xxx.c -o xxx<br>(1)Makefile实现</p>
<pre><code>SRC=$(wildcard *.c)
OBJ=$(SRC:%.c=%.o)
BIN=$(OBJ:%.o=%)
 
CC=gcc
CFLAGS=-Wall -g -c
 
all:$(BIN)

$(BIN):%:%.o
        $(CC) $^ -o $@
$(OBJ):%.o:%.c
        $(CC) $(CFLAGS) $^ -o $@

.PHONY: clean
clean:
        rm -rf $(OBJ) $(BIN)
</code></pre>
<p>(2)Shell实现</p>
<pre><code>#! /bin/bash
for file in ./*.c
do
if [ -f $file ]
then
file=$&#123;file#./&#125;
target=$&#123;file%.c&#125;
gcc -o $target $file
echo $target
fi
if [ -d $file ]
then
echo $file is mu lu
fi
done
</code></pre>
<p>(2)Makefile编译指定目录<br>Makefile可以输入参数，直接在make命令的后面加上参数，如:</p>
<pre><code>make BUILD_DIR=./foldername/
</code></pre>
<p>传入的变量将会覆盖相应Makefile中的<code>BUILD_DIR</code></p>
]]></content>
      <categories>
        <category>makefile</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用笔记</title>
    <url>/2020/12/12/Markdown%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>有的文字或代码和markdown解析有冲突<br>如$, @等<br>在这些字符前加转义字符即可：$, @</p>
<h1 id="tab缩进"><a href="#tab缩进" class="headerlink" title="tab缩进"></a>tab缩进</h1><p>markdown本身不支持tab缩进，有以下方法：<br>1.可以用全角输入+2个空格实现缩进<br>2.输入<code>&amp;emsp</code>，就是全角空格符号<br>3.输入<code>&gt;</code></p>
<h1 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h1><pre><code>[标题](URL)
</code></pre>
<h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><pre><code>- line
* line
</code></pre>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><pre><code>#
##
###
</code></pre>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><pre><code>|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>NVMe设备的Firmware Update全栈分析（一）：基于Windows Storport环境</title>
    <url>/2022/11/30/NVMe%E8%AE%BE%E5%A4%87%E7%9A%84Firmware%20Update%E5%85%A8%E6%A0%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EWindows%20Storport%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update"><a href="#1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update" class="headerlink" title="1.1 Windows Storport Driver环境下的NVMe设备Firmware Update"></a>1.1 Windows Storport Driver环境下的NVMe设备Firmware Update</h2><p>Windows系统下，NVMe设备的Firmware Update都是基于以下Microsoft API文档 ：</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/upgrading-firmware-for-an-nvme-device">upgrading-firmware-for-an-nvme-device</a></p>
]]></content>
      <categories>
        <category>NVMe</category>
      </categories>
      <tags>
        <tag>NVMe</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs笔记：使用pm2部署项目</title>
    <url>/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>nodejs服务可以用<code>nohup node xxx.js &amp;</code>后台启动，但是实际使用发现不太稳定，使用专门的node后台服务管理工具：pm2解决此问题</p>
<h1 id="pm2特性"><a href="#pm2特性" class="headerlink" title="pm2特性"></a>pm2特性</h1><p>1、内建负载均衡（使用Node cluster 集群模块）<br>2、后台运行<br>3、0秒停机重载<br>4、具有Ubuntu和CentOS 的启动脚本<br>5、停止不稳定的进程（避免无限循环）<br>6、控制台检测<br>7、提供 HTTP API<br>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p>
<h1 id="pm2安装"><a href="#pm2安装" class="headerlink" title="pm2安装"></a>pm2安装</h1><pre><code>npm install -g pm2
</code></pre>
<h1 id="pm2用法"><a href="#pm2用法" class="headerlink" title="pm2用法"></a>pm2用法</h1><pre><code>pm2 start app.js        //启动进程
pm2 start app.js -i 4   // 后台运行pm2，启动4个app.js
pm2 start app.js -i max //启动，使用所有CPU核心
pm2 start app.js --name my-api // 命名进程
pm2 list               // 显示所有进程状态
pm2 monit              // 监视所有进程
pm2 logs               //  显示所有进程日志
pm2 stop all           // 停止所有进程
pm2 restart all        // 重启所有进程
pm2 reload all         // 0秒停机重载进程 (用于 NETWORKED 进程)
pm2 stop 0             // 停止指定的进程
pm2 restart 0          // 重启指定的进程
pm2 startup            // 产生 init 脚本 保持进程活着
pm2 web                // 运行健壮的 computer API endpoint 
pm2 delete 0           // 杀死指定的进程
pm2 delete all         // 杀死全部进程
</code></pre>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>部署Github项目NodeMail，每天给指定邮箱发邮件。</p>
<p>后台启动main.js并监测状态：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427417.png" alt="image-20221206142729375"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427110.png" alt="image-20221206142743066"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427682.png" alt="image-20221206142752627"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061428280.png" alt="image-20221206142800236"></p>
]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>Office常用操作笔记</title>
    <url>/2019/07/06/Office%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h1><h2 id="Word设置自动推导的标题列表"><a href="#Word设置自动推导的标题列表" class="headerlink" title="Word设置自动推导的标题列表"></a>Word设置自动推导的标题列表</h2><p>word自动标题列表的是写文档必不可少的，自动标题能自动推导更新各级标题的序号，增删改查任何标题都不需要手动的写标题序号。</p>
<p>（1）创建多级列表<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423943.png" alt="image-20221206142307899"></p>
<p>（2）设置一级标题</p>
<ul>
<li>设置一级标题的序号样式为1,2,3</li>
<li>链接一级标题的字体样式到word文档的一级标题字体样式<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423121.png" alt="image-20221206142315070"></li>
</ul>
<p>（2）设置二级、三级、n级标题</p>
<p>需要设置列表序号，标题字体两部分。注意列表序号的正确设置是序号自动推导的关键。<br>以二级标题为例，其他子级类推。</p>
<ul>
<li><p>设置二级标题中的一级序号来自于level1。这一步保证二级标题中的一级序号是自动推导的。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423795.png" alt="image-20221206142327739"></p>
</li>
<li><p>设置二级标题中的二级序号的样式，二级标题中的一、二级序号用.号隔开<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424185.png" alt="image-20221206142401132"></p>
</li>
<li><p>二级标题最终的序号样式如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424492.png" alt="image-20221206142411436"></p>
</li>
<li><p>然后设置二级标题的字体风格，直接链接到word的二级标题字体风格<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424730.png" alt="image-20221206142420685"></p>
</li>
<li><p>二级标题列表的所有设置完毕，如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424880.png" alt="image-20221206142428828"></p>
</li>
</ul>
<p>(3)依次完成所有标题列表设置，例如三级标题，前两级的值来自于level1,level2，第三级设置数字格式即可，中间用.号隔开。完成以后各级标题就可以自动推导。</p>
<h2 id="Word导出原图"><a href="#Word导出原图" class="headerlink" title="Word导出原图"></a>Word导出原图</h2><p>Word默认图片如果直接复制出来，不是原图是压缩后的图。<br>保存原图方法： 文档另存为html网页格式，会把word文档转换成资源文件夹，里面有原始图片。</p>
<h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><h2 id="excel设置筛选"><a href="#excel设置筛选" class="headerlink" title="excel设置筛选"></a>excel设置筛选</h2><p>参考<a href="https://support.microsoft.com/zh-cn/office/%E7%AD%9B%E9%80%89%E5%8C%BA%E5%9F%9F%E6%88%96%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE-01832226-31b5-4568-8806-38c37dcc180e#:~:text=%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E7%AD%9B%E9%80%89%201%20%E9%80%89%E6%8B%A9%E8%A6%81%E7%AD%9B%E9%80%89%20%E5%88%97%E7%9A%84%E5%88%97%E6%A0%87%E9%A2%98%E7%AE%AD%E5%A4%B4%E3%80%82%202%20%E5%8F%96%E6%B6%88%20%28%E9%80%89%E6%8B%A9%22%29%20%22%EF%BC%8C,%E5%8D%95%E5%87%BB%E2%80%9C%20%E7%A1%AE%E5%AE%9A%20%E2%80%9D%E3%80%82%20%E5%88%97%E6%A0%87%E9%A2%98%E7%AE%AD%E5%A4%B4%20%22%E7%AD%9B%E9%80%89%20%E6%9B%B4%E6%94%B9%20%E3%80%82%20%E9%80%89%E6%8B%A9%E6%AD%A4%E5%9B%BE%E6%A0%87%E5%8F%AF%E6%9B%B4%E6%94%B9%E6%88%96%E6%B8%85%E9%99%A4%E7%AD%9B%E9%80%89%E3%80%82">筛选区域或表中的数据</a></p>
<ol>
<li><p>选中列，点击筛选</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302091144706.png" alt="image-20230209114432580"></p>
</li>
<li><p>可以按文字或者颜色筛选</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302091145967.png" alt="image-20230209114508910"></p>
</li>
</ol>
<h2 id="冻结首行"><a href="#冻结首行" class="headerlink" title="冻结首行"></a>冻结首行</h2><p>筛选行一般需要固定显示，因此设置冻结首行：</p>
<p>选中要固定显示行的下一行, 视图 -&gt; 冻结窗格 -&gt; 冻结首行</p>
]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记：RGB调色器</title>
    <url>/2022/04/18/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ARGB%E8%B0%83%E8%89%B2%E5%99%A8/</url>
    <content><![CDATA[<p>本文基于Qt官方示例<a href="https://doc.qt.io/qt-5/designer-quick-start.html#:~:text=%20Using%20Qt%20Designer%20involves%20four%20basic%20steps%3A,the%20slots%204%20Preview%20the%20form%20More%20"> A Quick Start to Qt Designer</a>, 实现自定义的slot函数，新增RGB色彩窗口显示色彩。</p>
<ul>
<li>本文源码：<a href="https://github.com/cursorhu/QtSampleTest/tree/master/1.rgbSlider">QtSampleTest&#x2F;1.rgbSlider</a></li>
<li>环境：基于Qt5.9 + Qt creater</li>
</ul>
<p>本文只记录项目过程中的注意事项，以及增量开发，其他部分参考Qt官方示例。</p>
<h2 id="1-UI部分"><a href="#1-UI部分" class="headerlink" title="1.UI部分"></a>1.UI部分</h2><ul>
<li>建立带UI的项目rgbSlider, 基于Qwidget生成默认自定义类名widget</li>
<li>双击widget.ui进入UI编辑</li>
</ul>
<p>UI 编辑模式下使用两种模式：widget编辑模式， slot&#x2F;signal编辑模式</p>
<ol>
<li><p>widget编辑模式如下：使用水平、网格布局<br>RGB数值控制部分，使用Label,  spinBox和scrollBar三种控件，按先竖直，后水平排列<br>RGB颜色显示部分，使用 graphicsView窗口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181201206.png"><br>注意调整布局的比例需要先选中，然后在layout属性调整<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181202783.png"></p>
</li>
<li><p>slot&#x2F;signal编辑模式<br>直接拖拽起始控件和目标控件，设置控件的信号和槽<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181203784.png"></p>
</li>
</ol>
<h2 id="2-自定义槽"><a href="#2-自定义槽" class="headerlink" title="2.自定义槽"></a>2.自定义槽</h2><p>graphicsView窗口预期效果是：只要调整RGB数值，自动显示对应的颜色<br>UI界面不能设置控件信号触发自定义槽，需要在代码中实现信号和槽的连接。</p>
<ol>
<li>右键转到graphicsView窗口的槽函数，自定义为 <code>Widget::on_rgbChanged()</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181400431.png"><br>函数实现如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;QColor&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;QPalette&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_rgbChanged()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> QPalette pal = QPalette();</span><br><span class="line"></span><br><span class="line"> QColor color;</span><br><span class="line"></span><br><span class="line"> //分别设置R,G,B,透明度</span><br><span class="line"></span><br><span class="line"> color.setRgb(ui-&gt;spinBoxRed-&gt;value(), ui-&gt;spinBoxGreen-&gt;value(), ui-&gt;spinBoxBlue-&gt;value(), 255);</span><br><span class="line"></span><br><span class="line"> //QPalette::Base</span><br><span class="line"></span><br><span class="line"> //Used mostly as the background color for text entry widgets, It is usually white or another light color.</span><br><span class="line"></span><br><span class="line"> pal.setColor(QPalette::Base, color);</span><br><span class="line"></span><br><span class="line"> ui-&gt;graphicsView-&gt;setPalette(pal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在UI基础上使用控件对象的方法，只需要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ui-&gt;控件名-&gt;控件的方法</span><br></pre></td></tr></table></figure>

<p>注意<code>setColor</code>可以给不同图层上色，这里使用<code>QPalette::Base</code>，而不能是<code>QPalette::Window</code>或<code>QPalette::Background</code></p>
<p>代码设置信号与槽, 注意，手动设置的代码要在<code>ui-&gt;setupUi(this);</code>的后面添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line"></span><br><span class="line"> QWidget(parent),</span><br><span class="line"></span><br><span class="line"> ui(new Ui::Widget)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxRed, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxGreen, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxBlue, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3.测试效果"></a>3.测试效果</h2><ul>
<li>拖动滑块，对应数值会更新，颜色同步更新</li>
<li>修改数值，对应滑块更新，颜色更新<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181410181.png"></li>
</ul>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Samba配置笔记</title>
    <url>/2023/01/30/Ubuntu%20Samba%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Samba基本概念"><a href="#Samba基本概念" class="headerlink" title="Samba基本概念"></a>Samba基本概念</h2><p>Samba是SMB protocol的应用程序实现，分为服务端和客户端；</p>
<p>Samba通常的使用场景：在同一局域网内的的Linux主机安装Samba服务，windows主机可以访问Linux Samba服务指定的共享目录。</p>
<p>在嵌入式开发中通常在windows 上编辑Samba共享目录下的代码，通过 Linux环境编译代码，而无需在两个主机间拷贝代码文件。</p>
<h2 id="Ubuntu安装Samba服务"><a href="#Ubuntu安装Samba服务" class="headerlink" title="Ubuntu安装Samba服务"></a>Ubuntu安装Samba服务</h2><p>Ubuntu 20.04和22.04 版本，安装Samba服务参考：</p>
<p><a href="https://www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux/#:~:text=Steps%20to%20install%20SAMBA%20on%20Ubuntu%2022.04%20LTS,...%206%206.%20Access%20the%20shared%20folder%20">www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux</a><br>主要流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#install and run samba service</span><br><span class="line">sudo apt install samba -y</span><br><span class="line"></span><br><span class="line">#enable auto start samba service</span><br><span class="line">sudo systemctl enable --now smbd</span><br><span class="line"></span><br><span class="line">#firewall allow samba</span><br><span class="line">sudo ufw allow samba</span><br><span class="line"></span><br><span class="line">#add system user to sambashare group</span><br><span class="line">sudo usermod -aG sambashare $USER</span><br><span class="line"></span><br><span class="line">#set passwd for sambashare</span><br><span class="line">sudo smbpasswd -a $USER</span><br><span class="line"></span><br><span class="line">#check samba service is running</span><br><span class="line">systemctl status smbd</span><br><span class="line"></span><br><span class="line">#share the folder in ubuntu GUI checkbox</span><br><span class="line">右键要共享的home文件夹properties -&gt; local Network Share -&gt; share this folder -&gt;share name不能直接用用户名，可以用&#x27;用户名+Home&#x27;</span><br></pre></td></tr></table></figure>

<p>显示无权共享：非root用户要共享&#x2F;home，需要修改smb.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br><span class="line">在[global]新增usershare owner only = false</span><br><span class="line">sudo systemctl restart smbd</span><br></pre></td></tr></table></figure>



<h2 id="Windows访问Samba共享目录"><a href="#Windows访问Samba共享目录" class="headerlink" title="Windows访问Samba共享目录"></a>Windows访问Samba共享目录</h2><p>windows下可以在文件浏览器直接访问Linux主机ip查看共享的Linux目录</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301103020.png" alt="image-20230130110305978"></p>
<p>首次windows访问共享目录有权限问题（不能写入），需要在Linux修改共享目录&#x2F;home的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /home -R </span><br></pre></td></tr></table></figure>

<p>为了以后方便连接，可以创建网络位置，参考：<a href="www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux">6. Access the shared folder On Windows 11 or 10</a></p>
<p>如果一个主机有两个samba共享目录，windows不允许多重连接；</p>
<p>要更改连接目录，操作如下：</p>
<p>win10系统在搜索框搜索【凭据管理器】，然后删除已有的windows samba网络连接凭据</p>
<p><code>win+R</code> CMD输入 <code>net use * /del /y</code>断开所有远程链接，包括samba网络连接</p>
<p>重新配置windows samba网络连接</p>
<h2 id="重装Samba"><a href="#重装Samba" class="headerlink" title="重装Samba"></a>重装Samba</h2><p>Samba的配置文件位于&#x2F;etc&#x2F;samba&#x2F;smb.conf，如果此文件被错误配置或者误删除，需要重装Samba，流程如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove samba --purge //删掉samba服务</span><br><span class="line">sudo apt-get remove samba-common --purge //这一步是关键，只重装samba不会恢复smb.conf</span><br><span class="line">sudo apt-get autoremove //删掉其他samba依赖库</span><br><span class="line">sudo apt-get install samba //重装，包括samba和samba-common等</span><br></pre></td></tr></table></figure>

<h2 id="Samba使用示例"><a href="#Samba使用示例" class="headerlink" title="Samba使用示例"></a>Samba使用示例</h2><p>Samba最重要的特性是两个主机之间直接共享目录，不需要用户去拷贝文件。</p>
<p>在代码开发中，在windows主机的VSCode或其他编辑器直接打开Linux主机共享目录的代码，然后SSH远程Linux主机去编译。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu SSH服务配置笔记</title>
    <url>/2023/02/02/Ubuntu-SSH%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h1><h2 id="SSH基本概念"><a href="#SSH基本概念" class="headerlink" title="SSH基本概念"></a>SSH基本概念</h2><ul>
<li>SSH是Secure Shell缩写，实现安全远程登录</li>
</ul>
<p>​    SSH的安全性好，原因是其对数据进行加密，方式主要有两种：对称加密（密钥加密）和非对称加密（公钥加密）<br>​    对称加密指加密解密使用的是同一套秘钥。Client端把密钥加密后发送给Server端，Server用同一套密钥解密。对称加密的加密强度比较高，很难破解。但是如果有一个Client端的密钥泄漏，那么整个系统的安全性就存在严重的漏洞。<br>​    为了解决对称加密的漏洞，于是就产生了非对称加密。<br>​    非对称加密有两个密钥：“公钥”和“私钥”。公钥加密后的密文，只能通过对应的私钥进行解密。想从公钥推理出私钥几乎不可能，所以非对称加密的安全性比较高。</p>
<ul>
<li>SSH的加密原理中，使用了RSA非对称加密算法。</li>
</ul>
<p>​    整个过程：</p>
<p>​    （1）远程主机收到用户的登录请求，把自己的公钥发给用户。</p>
<p>​    （2）用户使用这个公钥，将登录密码加密后，发送回来。</p>
<p>​    （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<ul>
<li>关于中间人攻击（Man-in-the-middle attack）</li>
</ul>
<p>​    中间人攻击的概念：如果有人冒充远程主机将伪造的公钥发给用户，用户很难辨别公钥真伪，用户    会和伪造主机通信而不是真正的主机。</p>
<p>​    因为SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，是主机和用户之间自己签    发的，所有SSH从原理上无法彻底防止中间人攻击</p>
<ul>
<li><p>SSH使用首次验证方式减少中间人攻击的概率：</p>
<p>SSH首次连接会下载服务端的公钥，用户确认后公钥将被保存并信任。</p>
<p>下次访问时客户端将会核对服务端发来的公钥和本地保存的是否相同，如果不同就发出中间人攻击的警告拒绝连接，除非用户手动清除已保存的公钥。</p>
<p>所以，只要SSH首次连接没有中间人攻击，之后的SSH连接就无需担心中间人攻击</p>
</li>
</ul>
<h2 id="Ubuntu安装SSH服务"><a href="#Ubuntu安装SSH服务" class="headerlink" title="Ubuntu安装SSH服务"></a>Ubuntu安装SSH服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ssh -y</span><br><span class="line">sudo service ssh start</span><br><span class="line">sudo service ssh status</span><br></pre></td></tr></table></figure>

<p>在系统重启后ssh service会自启动，不需要<code>systemctl enable</code>去配置自启动</p>
<h2 id="Windows访问SSH服务"><a href="#Windows访问SSH服务" class="headerlink" title="Windows访问SSH服务"></a>Windows访问SSH服务</h2><ul>
<li><p>使用win+R CMD验证SSH连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh 远程主机用户名@远程主机IP</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用putty，xshell等工具访问主机</p>
</li>
</ul>
<p>参考：<a href="https://www.how2shout.com/how-to/how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7.html#:~:text=How%20do%20I%20SSH%20into%20Ubuntu%20from%20Windows%3F,to%20Ubuntu%20server%20via%20Putty%20SSH%20client%20">how2shout.com&#x2F;how-to&#x2F;how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7</a></p>
<p>首次登陆会验证RSA公钥（1024位）的MD5 fingerprint（128位）</p>
<blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当首次连接的公钥被接受以后，会保存在本地文件。下次再连接这台主机会跳过公钥警告，直接提示输入密码。如果以后的连接是中间人攻击，其公钥和本地的首次公钥不同，从而保证安全性。</p>
<ul>
<li>使用xftp, filezilla工具传输文件</li>
</ul>
<p>和putty，xshell配置类似</p>
<ul>
<li>使用scp命令传输文件</li>
</ul>
<p>在linux主机之间可以用scp传输文件和目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#从远程cp到本地</span><br><span class="line">scp username@ip_address:/home/username/filename .</span><br><span class="line">#从本地cp到远程</span><br><span class="line">scp filename username@ip_address:/home/username</span><br><span class="line">#拷贝目录</span><br><span class="line">scp -r source_dir username@ip_address:/home/username/target_dir</span><br></pre></td></tr></table></figure>

<h2 id="SSH远程开发"><a href="#SSH远程开发" class="headerlink" title="SSH远程开发"></a>SSH远程开发</h2><p>示例一：在SSH server和客户端建立后，可以使用VSCode和source insight等代码编辑工具改代码，用xftp传输代码到SSH Linux主机，用xshell远程编译。</p>
<p>示例二：VSCode安装SSH远程开发插件，可以直接远程SSH Linux主机完成代码编辑、编译，<a href="https://www.how2shout.com/how-to/how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7.html#:~:text=How%20do%20I%20SSH%20into%20Ubuntu%20from%20Windows%3F,to%20Ubuntu%20server%20via%20Putty%20SSH%20client%20">visualstudio.com&#x2F;Remote Development using SSH</a></p>
<h1 id="远程连接相关的Ubuntu配置"><a href="#远程连接相关的Ubuntu配置" class="headerlink" title="远程连接相关的Ubuntu配置"></a>远程连接相关的Ubuntu配置</h1><h2 id="Ubuntu设置静态IP"><a href="#Ubuntu设置静态IP" class="headerlink" title="Ubuntu设置静态IP"></a>Ubuntu设置静态IP</h2><p>在使用SSH和Samba连远程Ubuntu PC时，发现IP有时候会改变，因此需要配置Ubuntu PC为静态IP</p>
<p>1.ifconfig查看ethernet接口和当前IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~$ ifconfig</span><br><span class="line">eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.52.4.71  netmask 255.255.255.0  broadcast 10.52.4.255</span><br></pre></td></tr></table></figure>

<p>2.编辑Ubuntu的netplan配置文件&#x2F;etc&#x2F;netplan&#x2F;*.yaml，用tab补全找到具体的yaml，制定静态IP和DNS</p>
<p>参考 <a href="https://linuxconfig.org/netplan-network-configuration-tutorial-for-beginners">Netplan network configuration tutorial for beginners</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">    eno1:</span><br><span class="line">      addresses:</span><br><span class="line">        - 10.52.4.71/24</span><br><span class="line">      nameservers:</span><br><span class="line">         addresses:</span><br><span class="line">            - 10.52.1.1</span><br><span class="line">            - 10.52.1.2</span><br><span class="line">      #gateway4: 10.52.0.1</span><br><span class="line">      routes:</span><br><span class="line">         - to: default</span><br><span class="line">           via: 10.52.0.1</span><br></pre></td></tr></table></figure>

<p>以上IP和nameservers(DNS)是必须的，gateway4是网关，在ubuntu22被废弃（ubuntu22显示 &#96;&#96;gateway4<code> has been deprecated, use default routes instead.</code>）使用routes配置网关，参考 <a href="https://askubuntu.com/questions/1410750/netplan-gateway-has-been-deprecated">netplan-gateway-has-been-deprecated</a>。怎么获取这三个值，参考以下网络命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有</span><br><span class="line">nmcli</span><br><span class="line">#查看gateway</span><br><span class="line">netstat -rn 或 route -n</span><br><span class="line">#DNS配置文件</span><br><span class="line">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>例如nmcli输出如下，其中 <code> inet4 10.52.4.71/24</code>即当前IP&#x2F;mask， <code>route4 default via 10.52.0.1</code>即默认网关，<code>DNS configuration servers: 10.52.1.1 10.52.1.2</code>即nameservers</p>
<blockquote>
<p>eno1: connected to netplan-eno1<br>        “Intel I219-V”<br>        ethernet (e1000e), 18:C0:4D:1F:BA:B7, hw, mtu 1500<br>        ip4 default<br>        inet4 10.52.4.71&#x2F;24<br>        route4 10.52.4.0&#x2F;24 metric 100<br>        route4 10.52.0.1&#x2F;32 metric 100<br>        route4 default via 10.52.0.1 metric 100<br>        inet6 fe80::1ac0:4dff:fe1f:bab7&#x2F;64<br>        route6 fe80::&#x2F;64 metric 256</p>
<p>virbr0: connected (externally) to virbr0<br>        “virbr0”<br>        bridge, 52:54:00:13:EB:68, sw, mtu 1500<br>        inet4 192.168.122.1&#x2F;24<br>        route4 169.254.0.0&#x2F;16 metric 1000<br>        route4 192.168.122.0&#x2F;24 metric 0</p>
<p>lo: unmanaged<br>        “lo”<br>        loopback (unknown), 00:00:00:00:00:00, sw, mtu 65536</p>
<p>DNS configuration:<br>        servers: 10.52.1.1 10.52.1.2<br>        interface: eno1</p>
</blockquote>
<p>3.生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<p>ping确认网络正常：</p>
<blockquote>
<p>ubuntu@ubuntu-Z390-GAMING-X:~$ ping <a href="http://www.bing.com/">www.bing.com</a><br>PING china.bing123.com (202.89.233.101) 56(84) bytes of data.<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;1 ttl&#x3D;117 time&#x3D;27.1 ms<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;2 ttl&#x3D;117 time&#x3D;27.2 ms<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;3 ttl&#x3D;117 time&#x3D;27.2 ms</p>
</blockquote>
<p>如果DNS server或gateway不符合当前网络状况，ping会失败，输出：</p>
<blockquote>
<p>Name or service not known</p>
</blockquote>
<h2 id="Ubuntu禁止自动登出"><a href="#Ubuntu禁止自动登出" class="headerlink" title="Ubuntu禁止自动登出"></a>Ubuntu禁止自动登出</h2><p>自动登出会使SSH断开链接，按如下禁用</p>
<blockquote>
<p>setting-&gt;Privacy-&gt;Screen-&gt;Automatic Screen Lock (OFF)</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu使用笔记</title>
    <url>/2023/04/28/Ubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文基于Ubuntu 22.04 LTS</p>
<h2 id="软件下载源"><a href="#软件下载源" class="headerlink" title="软件下载源"></a>软件下载源</h2><p>使用国内软件源下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">software&amp;updates -&gt; Ubuntu Software -&gt; download from -&gt; cn99.com或aliyun.com</span><br></pre></td></tr></table></figure>

<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>安装中文输入法(pinyin)的步骤：</p>
<p>安装中文支持：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Install/Remove Languages -&gt; 安装chinese simplified</span><br></pre></td></tr></table></figure>

<p>设置系统语言为中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成Chinese</span><br></pre></td></tr></table></figure>

<p>安装Fcitx框架和中文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-bin #安装fcitx框架</span><br><span class="line">sudo apt-get install fcitx-table #安装输入法栏，其中自动安装拼音输入法</span><br><span class="line">fcitx --version</span><br></pre></td></tr></table></figure>

<p>使用Fcitx框架，重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Keyboard input method system 选择Fcitx 4</span><br></pre></td></tr></table></figure>

<p>添加输入法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ubuntu右上角的小键盘图标 -&gt; configure -&gt; 添加pinyin（只有系统语言为中文时才能添加中文输入法）</span><br></pre></td></tr></table></figure>

<p>切换中英文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + space</span><br></pre></td></tr></table></figure>

<p>设置系统语言改回英文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成English</span><br></pre></td></tr></table></figure>

<h2 id="snap包管理工具"><a href="#snap包管理工具" class="headerlink" title="snap包管理工具"></a>snap包管理工具</h2><p><a href="https://snapcraft.io/store">Snap</a>是Canonical开发的Linux包管理和软件部署工具。 </p>
<p>安装和使用参考 <a href="https://phoenixnap.com/kb/install-snap-ubuntu#:~:text=1%20Start%20by%20updating%20packages%3A%0Asudo%20apt,update%202%20Enter%20the%20following%20command%3A"><strong>How to Install Snap on Ubuntu</strong></a></p>
<p>特点：丰富的第三方工具库，包括开源工具和闭源工具；二进制安装，不是源码编译</p>
<p>相比apt，其查找工具和安装极为简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap find &lt;keyword&gt; #查找keyword相关的工具，显示可安装的列表</span><br><span class="line">sudo snap install &lt;package&gt; #安装列表中的工具</span><br></pre></td></tr></table></figure>

<p>查看和卸载snap安装的包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snap list</span><br><span class="line">sudo snap remove &lt;package&gt;</span><br></pre></td></tr></table></figure>

<p>示例：安装VSCode和Chrome</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap find vscode #找到&lt;package&gt;为code</span><br><span class="line">sudo snap install code --classic</span><br><span class="line">sudo snap find chrome #找到&lt;package&gt;为chromium</span><br><span class="line">sudo snap install chromium</span><br></pre></td></tr></table></figure>

<h2 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h2><p>setting -&gt; keyboard -&gt; shortcuts -&gt; custom shortcut -&gt; 为应用程序添加快捷键</p>
<p>以截图工具flameshot为例，设置快捷键的command为调用flameshot的命令，截图默认保存到~&#x2F;Pictures</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051055723.png" alt="image-20230505105544618"></p>
<p>要配置其他flameshot命令的快捷键，用 <code>man flameshot</code> 查看，参考 <a href="https://flameshot.org/docs/guide/key-bindings/">Keyboard shortcuts for Flameshot</a></p>
<h2 id="Timeshift系统备份"><a href="#Timeshift系统备份" class="headerlink" title="Timeshift系统备份"></a>Timeshift系统备份</h2><p>22.04系统似乎比较容易挂，进不了系统显示”Oh no… system can’t recover…”，比如：</p>
<p>Nvdia驱动选择开源版本xserver就挂了一次, recovery模式看&#x2F;var&#x2F;log&#x2F;message有nouveau和nvidia module相关问题</p>
<p>学习xv6时安装编译环境时也挂了一次(不能安装到&#x2F;usr&#x2F;local，应该安装到&#x2F;home)，recovery模式dpkg report显示failure log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbol lookup error: /lib/x86_64-linux-gnu/libgnutls.so.30: undefined symbol: __gmpz_limbs_write </span><br></pre></td></tr></table></figure>

<p>都是找遍办法都修复不了，只能重装…</p>
<p>为了解决此问题，使用Timeshift将系统备份，参考: <a href="https://itsfoss.com/backup-restore-linux-timeshift/">How to Backup and Restore Linux System Settings With Timeshift</a></p>
<p>安装timeshift：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install timeshift</span><br></pre></td></tr></table></figure>

<p>备份整个系统，包括&#x2F;root和&#x2F;home&#x2F;user，设置定时备份</p>
<p>如何恢复：</p>
<p>情景一：系统无法进入桌面，但是可以进入recovery模式root操作：</p>
<p>如下图，用<code>timeshift --help</code>查看各种命令，使用<code>timeshift --restore</code>恢复指定snapshot</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305081931009.png" alt="image-20230508193100794"></p>
<p>情景二：系统无法进入recovery模式，但是备份的snapshot数据还在</p>
<p>使用<a href="https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows?ref=itsfoss.com">Ubuntu Live USB</a> ，即装系统的USB进入try ubuntu环境，联网换国内源安装timeshift，再恢复系统盘中的snapshot数据</p>
<p>情景三：磁盘中的snapshot数据损害：只能重装系统，为了避免此情况发生，应该将系统备份到其他硬盘而不仅仅在当前系统盘</p>
<h2 id="关于系统损坏"><a href="#关于系统损坏" class="headerlink" title="关于系统损坏"></a>关于系统损坏</h2><p>&#x2F;usr：系统级的目录，可以理解为C:&#x2F;Windows&#x2F;，apt安装的一般在&#x2F;usr&#x2F;bin和&#x2F;usr&#x2F;lib</p>
<p>&#x2F;usr&#x2F;lib：理解为C:&#x2F;Windows&#x2F;System32</p>
<p>&#x2F;usr&#x2F;local：用户级的程序目录，可以理解为C:&#x2F;Progrem Files&#x2F;，用户自己编译的软件默认安装到这个目录下</p>
<p>&#x2F;opt是用户级的目录用来安装大型的第三方附加软件包，可以理解为D:&#x2F;Software</p>
<p>开发过程中为了避免lib冲突，自己编译的包建议放在&#x2F;home&#x2F;&lt;具体的项目目录&gt;，此外注意自己编译基础库设置的LD_LIBRARY_PATH造成系统库链接冲突</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode配置笔记</title>
    <url>/2022/12/08/VSCode%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><h2 id="修改工作区存储目录workspaceStorage"><a href="#修改工作区存储目录workspaceStorage" class="headerlink" title="修改工作区存储目录workspaceStorage"></a>修改工作区存储目录workspaceStorage</h2><p>VSCode会将每个工作区的一些配置、扩展、缓存等默认保存在C盘的AppData\Code\workspaceStorage，使用一段时间后数据能达到上十GB。</p>
<p>当C盘空间不足，用SpaceSniffer可以找到这些“数据垃圾”，但每隔一段时间清理也不是一劳永逸。</p>
<p>修改workspaceStorage存储路径到非系统盘：</p>
<p>1.首先选择VSCode在开始栏，状态栏，或桌面栏的快捷方式图标，常用哪个就修改哪个，右键属性：</p>
<p>添加启动的命令行选项，指定user-data-dir:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--user-data-dir &quot;目标路径，例如F:\VSCodeWorkspaceStorage&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081200216.png" alt="image-20221208120051137"></p>
<p>2.转移已有的workspaceStorage.</p>
<p>修改完成后，将%AppData%\Code下的所有内容拷贝到设置的目录中;  也可以删除%AppData%\Code，但是需要重新配置VSCode。</p>
<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p>以双斜杠&#x2F;&#x2F;注释和取消注释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">注释：ctrl + / </span><br><span class="line">取消注释：ctrl + /</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法二：</span><br><span class="line">注释：ctrl + k, ctrl + c </span><br><span class="line">取消注释：ctrl + k, ctrl + u</span><br></pre></td></tr></table></figure>

<p>以星号&#x2F;**&#x2F;注释和取消注释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释：shift + alt + a </span><br><span class="line">取消注释：shift + alt + a</span><br></pre></td></tr></table></figure>

<h2 id="更改快捷键"><a href="#更改快捷键" class="headerlink" title="更改快捷键"></a>更改快捷键</h2><p>File-&gt;Preference-&gt;KeyboardShortCuts</p>
<p>例如可以把块注释&#x2F;**&#x2F;快捷键改成<code>ctrl+Alt+/</code>，和行注释<code>ctrl+/</code>达成统一：</p>
<p>选择recording keys，直接录入要修改的快捷键</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302201101988.png" alt="image-20230220110133891"></p>
<h1 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h1>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim使用笔记.</title>
    <url>/2021/04/17/Vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最近在ChromeOS上做一些shell script测试用例开发，ChromeOS基于Debian9，但没有Ubuntu那种GNOME的gedit编辑器，更不谈安装Linux版VSCode，正好借此机会练习一下之前一直不熟悉的vim编辑器。</p>
<p>ChromeOS不方便截图，所以本文以ubuntu上的linux0.11代码为例，整理vim最常用的操作。</p>
<p>关于Linux上的文本编辑器基础概念，可以参考&lt;Linux命令行与shell脚本编程大全.第3版&gt;</p>
<h2 id="1-三种编辑模式"><a href="#1-三种编辑模式" class="headerlink" title="1. 三种编辑模式"></a>1. 三种编辑模式</h2><p>我将vim归为三种编辑模式：</p>
<ul>
<li><p>文本编辑模式<br>文本编辑模式是默认模式，vim编辑器会将按键解释成命令。在任意模式按esc进入此默认模式。</p>
</li>
<li><p>文本插入模式<br>文本插入模式， vim会将你在当前光标位置输入的每个键都插入到缓冲区，即文本输入字符。在普通模式下按下”i 键” 进入(含义:insert)</p>
</li>
<li><p>命令行模式<br>命令行模式和shell命令行类似，在普通模式下按下”: 键”进入(形似shell terminal的冒号)</p>
</li>
</ul>
<p>怎么知道当前处于哪种模式？<br>vim左下角是状态行，以下是三种模式的状态示例：</p>
<ul>
<li><code>vim init/main.c</code>默认进入文本编辑模式，下面显示文件名和行号<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171047554.png"></li>
</ul>
<p>输入i, 进入文本插入模式，下面显示insert状态<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171052433.png"></p>
<p>按esc退出文本编辑，再输入<code>:</code> 进入命令行模式，例如输入<code>:wq</code>保存文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171053124.png"></p>
<p>还有一种visual模式是复制粘贴时会用到：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181032041.png"></p>
<p>下面讲文本编辑模式和命令行模式的常用命令<br>主要分为几类场景：</p>
<ul>
<li>光标移动</li>
<li>增删改查</li>
<li>文件保存</li>
</ul>
<p>光标移动类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>移到第一行 (gg重来)</td>
</tr>
<tr>
<td>G</td>
<td>移到最后一行 (记为大G)</td>
</tr>
<tr>
<td>PageUp&#x2F;PageDown</td>
<td>翻页</td>
</tr>
<tr>
<td>:行号</td>
<td>光标移动到指定行(属于命令行模式)</td>
</tr>
</tbody></table>
<p>增删改查类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>进入insert模式，在当前光标的左侧输入</td>
</tr>
<tr>
<td>a</td>
<td>追加文本（append），在当前光标的右侧输入</td>
</tr>
<tr>
<td>o</td>
<td>插入空行，在空行光标处可输入</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行 (记为双击delete)</td>
</tr>
<tr>
<td>dw</td>
<td>删除当前词（记为delete word）</td>
</tr>
<tr>
<td>delete键，或x键</td>
<td>删除当前字符，注意，Backspace在vim没有删除的作用！</td>
</tr>
<tr>
<td>v+方向键选中+y</td>
<td>复制选中的文本，v: visual，可视光标选中的文本范围， y: yank 复制</td>
</tr>
<tr>
<td>yw</td>
<td>复制当前词</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p</td>
<td>在复制之后，粘贴文本(paste)，注意粘贴内容来自vim缓冲区，而不是外部剪切板的</td>
</tr>
<tr>
<td>dw&#x2F;dd + p</td>
<td>剪切，d操作删除的文本位于缓冲区，可以直接用p粘贴</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>(当前文件内)查找字符串，按n查找下一个</td>
</tr>
<tr>
<td>:s&#x2F;old&#x2F;new&#x2F;g</td>
<td>(当前文件内)全局查找和替换</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步</td>
</tr>
</tbody></table>
<p>文件保存类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:q!</td>
<td>不保存文件退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存文件退出</td>
</tr>
</tbody></table>
<h2 id="2-多文件编辑"><a href="#2-多文件编辑" class="headerlink" title="2.多文件编辑"></a>2.多文件编辑</h2><p>下面讲多个文本的常用命令<br>主要分为几类场景：</p>
<ul>
<li>多文本搜索</li>
<li>多文件编辑</li>
</ul>
<p>多文本搜索类：<br>参考<a href="https://thevaluable.dev/vim-search-find-replace/"># Vim Search and Replace With Examples</a><br>本文只以quickfix方式为例：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>:vimgrep pattern **</code></td>
<td>搜索当前目录和子目录的包含指定pattern的文件，vimgrep可缩写为vim, ** 表示递归子目录</td>
</tr>
<tr>
<td><code>:vimgrep pattern **/*.c</code></td>
<td>同上，只搜索.c文件</td>
</tr>
<tr>
<td>:copen</td>
<td>搜索完后使用此命令打开文件列表，才能用光标选择</td>
</tr>
<tr>
<td>:cn (cnext) 和 :cp (cprev)</td>
<td>上下选择搜索文件列表</td>
</tr>
</tbody></table>
<p>示例：搜索linux0.11下的所有包含main的.c文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171959744.png"></p>
<p>quickfix list即文件列表，copen后可方向键选择打开文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205172002631.png"></p>
<ul>
<li>多文件编辑<br><strong>打开多个文件，分隔并列显示</strong></li>
</ul>
<ol>
<li>用vim打开文件后，命令行输入<code>:vs newfile</code>，竖排并列打开新文件（vs是vertical split缩写，竖排分隔）</li>
<li>特殊用法：<code>:vs ./</code>可以打开当前路径下的所有文件列表</li>
<li>在窗口间切换：<code>ctrl + ww</code></li>
<li>关闭文件只需要先切换到窗口再<code>:q!</code></li>
<li>调整竖排的窗口比例：<br> 先按ctrl+w选择窗口模式，再按&lt;&gt;+-调整。&lt; 左移，&gt; 右移，+ 上移， - 下移。</li>
</ol>
<p>示例：实现类似IDE的界面，左侧是文件列表，下侧是查找栏，右侧文件内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181006035.png"></p>
<p>  <strong>打开多个文件，不并列显示</strong><br>直接<code>:open file</code>打开新文件, 用 <code>:bn 和 :bN</code> (buffer next)切换文件, </p>
<p>  <strong>多文件之间复制粘贴</strong><br>vim的多个文件直接可以直接用 y + p 命令复制粘贴，因为共用vim环境的缓冲区</p>
<p>  退出所有文件<br><code>:qall!</code> 和 <code>:wqall</code></p>
<h2 id="3-类似IDE的跳转功能"><a href="#3-类似IDE的跳转功能" class="headerlink" title="3.类似IDE的跳转功能"></a>3.类似IDE的跳转功能</h2><p>推荐cscope插件，具体参考<a href="http://cscope.sourceforge.net/cscope_vim_tutorial.html">## The Vim&#x2F;Cscope tutorial</a></p>
<p>关键步骤：</p>
<ul>
<li>建立cscope.vim<br>将  <a href="http://cscope.sourceforge.net/cscope_maps.vim">http://cscope.sourceforge.net/cscope_maps.vim</a>  另存到文件<code>~/.vim/plugin/cscope_maps.vim</code></li>
<li>源码目录建立cscope.out<br><code>cscope -R</code> 建立符号索引，<code>ctrl+D</code> 退出</li>
<li>打开某符号的代码<br>例如 <code>vim -t main</code> 打开main所在文件</li>
<li>查找函数的定义和调用<br>如果光标已经在函数上，用 “<code>ctrl +＼</code>“ 再输入s，查找所有调用、定义该函数的列表，输入索引号回车<br>更推荐用cscope的命令行，<code>:cs f s 函数名</code> 是一样的结果，且光标不需要位于函数上。参数含义 f: find, s: symbol<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181103274.png"></li>
<li>跳转回之前的位置<br>“<code>ctrl + t</code></li>
</ul>
<h2 id="4-vim配置文件修改配色，行号"><a href="#4-vim配置文件修改配色，行号" class="headerlink" title="4.vim配置文件修改配色，行号"></a>4.vim配置文件修改配色，行号</h2><p>在有的Linux服务器上，Vim默认深蓝色亮瞎眼，修改配色为流行的Molokai.</p>
<p>效果对比:</p>
<p>默认配色看不清注释内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061435384.png" alt="image-20221206143528332"><br>Molokai配色<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061437401.png" alt="image-20221206143701354"></p>
<p>配置过程：</p>
<p>默认的配色方案：</p>
<pre><code>ls /usr/share/vim/vim74/colors
</code></pre>
<p>下载molokai配色文件,拷贝到vim配色文件目录</p>
<pre><code>cd ~
git clone git@github.com:tomasr/molokai.git
cd molokai/colors
cp molokai.vim /usr/share/vim/vim74/colors
</code></pre>
<p>在home下创建.vimrc用于配色详细设置</p>
<pre><code>cd ~
vim .vimrc
</code></pre>
<p>.vimrc设置如下：</p>
<pre><code>  set t_Co=256
  set background=dark
  set ts=4
  set nu!
  syntax on
  colorscheme molokai
</code></pre>
<p><code>:wq</code>保存后即生效<br>如果要全局用户通用，<code>vim /etc/vimrc</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows CMD 常用命令笔记</title>
    <url>/2023/01/30/Windows-CMD-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Tree命令生成目录树"><a href="#Tree命令生成目录树" class="headerlink" title="Tree命令生成目录树"></a>Tree命令生成目录树</h1><blockquote>
<p>tree 命令的目录格式：TREE 【drive：】【path】【&#x2F;F】【&#x2F;A】</p>
<ul>
<li>可在cmd内输入（help tree 或 tree &#x2F; ？）查看</li>
<li>&#x2F;F  显示每个文件夹中文件的名称</li>
<li>&#x2F;A  使用ASCII字符，而不使用拓展字符</li>
</ul>
</blockquote>
<p>示例一：只显示路径名不显示文件名</p>
<p><code>TREE 【drive：】【path】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301049746.png" alt="image-20230130104934713"></p>
<p>示例二：显示路径名和文件名</p>
<p><code>TREE 【drive：】【path】【/F】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301048851.png" alt="image-20230130104835813"></p>
<p>示例三：将目录树存入指定文件</p>
<p><code>TREE 【drive：】【path】 &gt; 文件路径】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301051100.png" alt="image-20230130105102054"></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>Xshell配置笔记</title>
    <url>/2019/12/06/Xshell%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>配置x’shell的默认字体以及一些操作设置</p>
<h1 id="会话设置"><a href="#会话设置" class="headerlink" title="会话设置"></a>会话设置</h1><p>设置主机<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457347.png" alt="1"><br>设置主机账号密码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457719.png" alt="2"><br>设置xshell字体<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457495.png" alt="3"></p>
<h1 id="操作设置"><a href="#操作设置" class="headerlink" title="操作设置"></a>操作设置</h1><p>设置Ctrl+c,Ctrl+v复制粘贴<br>工具-&gt;选项-&gt;编辑按键<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457000.png" alt="4"><br>新建按键，按ctrl+c<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061458030.png" alt="5"><br>设置功能为复制<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061458880.png" alt="6"><br>同理设置ctrl+v为粘贴<br>注意,原shell的ctrl+c终止程序，被替换成了shift+ctrl+c</p>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>esp32笔记之PWM实现LED呼吸灯</title>
    <url>/2023/05/05/esp32%E7%AC%94%E8%AE%B0%E4%B9%8BPWM%E5%AE%9E%E7%8E%B0LED%E5%91%BC%E5%90%B8%E7%81%AF/</url>
    <content><![CDATA[<h2 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h2><p>先从应用上讲讲PWM：</p>
<p>有一盏日光灯，一般我们只能打开它或者关闭它，不存在中间状态；</p>
<p>有另一个LED灯，支持在一秒以内极快速的速度开关开关，其变化超过人眼识别的24帧率，LED灯看上去就像一直开着，但亮度比常开暗一些；如果控制灯快速开关过程中的打开时间和关闭时间的比例，就可以调节人眼看到的灯亮度。</p>
<p>以上就是PWM的大概应用原理：用高频率的开关信号，控制输出信号的平均强度，使输出信号能在0%到100%强度间任意调节。</p>
<p>用电路语句讲PWM原理：用数字信号的占空比来调制模拟信号的幅度(电压)。</p>
<p>PWM详细介绍参考：<a href="https://circuitdigest.com/tutorial/what-is-pwm-pulse-width-modulation">What is PWM: Pulse Width Modulation</a></p>
<p>脉冲宽度(pulse width)是指单位时间的高电平的持续时间，脉冲宽度越大被调制的模拟信号电压越大。</p>
<ul>
<li>在一定的频率下，通过不同的(高电平)占空比即可得到不同脉冲宽度，进而调节输出的模拟电压信号</li>
<li>在一定的占空比下，通过不同的频率实现不同的调节速度；频率要适配不同设备，不能任意设置，例如电机频率50HZ，MCU外设1000Hz。频率不决定被调制电压的幅度。</li>
</ul>
<p>PWM的调制信号如下：</p>
<p><img src="https://circuitdigest.com/sites/default/files/inlineimages/pulse-width-modulation-duty-cycle.gif" alt="img"></p>
<p>PWM调制电路通常用RC filter实现：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051659127.jpg" alt="Converting-PWM-signals-into-Analog"></p>
<p>PWM一般对具体设备使用固定频率，再调整高电平的占空比决定模拟信号的幅度。</p>
<p>如下图，占空比从0%调节到100%，对应输出电压为0V~5V</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305061100234.jpg" alt="Pulse-Width-Modulation"></p>
<p>从原理上讲就是开关控制，在一个周期内调制信号的高电平时间越长，RC电荷积分更多，输出电压越大：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051657299.png" alt="image-20230505165748199"></p>
<h2 id="MicroPython控制PWM"><a href="#MicroPython控制PWM" class="headerlink" title="MicroPython控制PWM"></a>MicroPython控制PWM</h2><p>官方tutorial参考：</p>
<p><a href="https://docs.micropython.org/en/latest/esp32/quickref.html">Quick reference for the ESP32</a> PWM (pulse width modulation)</p>
<p><a href="https://docs.micropython.org/en/latest/esp32/tutorial/pwm.html#esp32-pwm">Pulse Width Modulation</a> 其中有调整频率和占空比的sample code:</p>
<ul>
<li><p>Example of a smooth frequency change:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">F_MIN = 500</span><br><span class="line">F_MAX = 1000</span><br><span class="line"></span><br><span class="line">f = F_MIN</span><br><span class="line">delta_f = 1</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), f)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.freq(f)</span><br><span class="line"></span><br><span class="line">    sleep(10 / F_MIN)</span><br><span class="line"></span><br><span class="line">    f += delta_f</span><br><span class="line">    if f &gt;= F_MAX or f &lt;= F_MIN:</span><br><span class="line">        delta_f = -delta_f</span><br></pre></td></tr></table></figure>
</li>
<li><p>Example of a smooth duty change:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">DUTY_MAX = 2**16 - 1</span><br><span class="line"></span><br><span class="line">duty_u16 = 0</span><br><span class="line">delta_d = 16</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), 1000, duty_u16=duty_u16)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.duty_u16(duty_u16)</span><br><span class="line"></span><br><span class="line">    sleep(1 / 1000)</span><br><span class="line"></span><br><span class="line">    duty_u16 += delta_d</span><br><span class="line">    if duty_u16 &gt;= DUTY_MAX:</span><br><span class="line">        duty_u16 = DUTY_MAX</span><br><span class="line">        delta_d = -delta_d</span><br><span class="line">    elif duty_u16 &lt;= 0:</span><br><span class="line">        duty_u16 = 0</span><br><span class="line">        delta_d = -delta_d</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="呼吸灯示例"><a href="#呼吸灯示例" class="headerlink" title="呼吸灯示例"></a>呼吸灯示例</h2><p>参考：<a href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/03.PWMhuxideng">itproject.cn&#x2F;Python+ESP32快速上手&#x2F;3.PWM呼吸灯</a></p>
<p>esp32的micropython代码以script形式执行，主程序必须命名为main.py(参考 <a href="https://docs.micropython.org/en/v1.9.3/pyboard/pyboard/tutorial/script.html">Running your first script</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from machine import Pin, PWM</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">led2 = PWM(Pin(2))</span><br><span class="line">led2.freq(1000)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    for i in range(0, 1024):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br><span class="line">        </span><br><span class="line">    for i in range(1023, -1, -1):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br></pre></td></tr></table></figure>

<p>LED渐变呼吸闪烁：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305052003803.gif" alt="mmexport1683287925729"></p>
<p>如果将led duty调整为512，最大亮度会变小，验证了最大占空比决定最大电压</p>
<p>如果将led freq调整为50，最大亮度不变，但led渐变过程中会闪烁，也就是说开关调节频率太低，导致人眼都可以观察到led的开关电，看上去就是led闪烁</p>
]]></content>
      <categories>
        <category>esp32</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title>esp32笔记之环境搭建</title>
    <url>/2023/05/04/esp32%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>esp32是乐鑫的SOC，支持Wifi, BLE等IOT功能；官方教程：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html">ESP-IDF编程指南</a></p>
<h1 id="ESP-IDF环境搭建"><a href="#ESP-IDF环境搭建" class="headerlink" title="ESP-IDF环境搭建"></a>ESP-IDF环境搭建</h1><p>按官方教程在Linux ubuntu搭建ESP-IDF开发环境，有clone idf一直失败的问题</p>
<p>本节记录不用翻墙搭建ESP-ID环境的过程，视频参考：<a href="https://b23.tv/VCYbC2m">Linux 如何安装 ESP-IDF ESP32 开发环境搭建</a></p>
<h2 id="版本发布、下载"><a href="#版本发布、下载" class="headerlink" title="版本发布、下载"></a>版本发布、下载</h2><p><a href="https://github.com/espressif/esp-idf/releases">https://github.com/espressif/esp-idf/releases</a></p>
<p>手动下载release版本的idf压缩包，例如下载esp-idf-v5.0.1.zip</p>
<p>解压到 ~&#x2F;esp&#x2F;esp-idf (<code>mv esp-idf-v5.0.1 esp-idf</code>)</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git wget flex bison gperf python3 python3-venv python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0</span><br></pre></td></tr></table></figure>

<h2 id="安装-ESP-IDF"><a href="#安装-ESP-IDF" class="headerlink" title="安装 ESP-IDF"></a>安装 ESP-IDF</h2><p>安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">./install.sh esp32 #esp32 chip,用此命令即可</span><br><span class="line">./install.sh all #所有esp chips</span><br></pre></td></tr></table></figure>

<p>如果安装遇到网络问题，需要设置下载服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">export IDF_GITHUB_ASSETS=&quot;dl.espressif.com/github_assets&quot;</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>如果遇到 Python 包安装问题则需要设置 Python 源</p>
<h2 id="设置环境变量："><a href="#设置环境变量：" class="headerlink" title="设置环境变量："></a>设置环境变量：</h2><p>每次运行都export环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. $HOME/esp/esp-idf/export.sh</span><br></pre></td></tr></table></figure>

<p>或把将以下语句加入 ~&#x2F;.bashrc，每次执行只需要 <code>get_idf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias get_idf=&#x27;. $HOME/esp/esp-idf/export.sh&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="串口相关设置"><a href="#串口相关设置" class="headerlink" title="串口相关设置"></a>串口相关设置</h2><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/establish-serial-connection.html">与 ESP32 创建串口连接</a></p>
<p>查看串口: ls &#x2F;dev&#x2F;tty* (esp32应该是ttyUSB0)</p>
<p>必须将将用户添加到 <code>dialout</code> 组，从而获许串口读写权限，否则串口无法连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br></pre></td></tr></table></figure>

<h2 id="编译和烧录"><a href="#编译和烧录" class="headerlink" title="编译和烧录"></a>编译和烧录</h2><ul>
<li>设置：idf.py menuconfig</li>
<li>编译：idf.py build</li>
<li>烧录：idf.py -p PORT 【-b BAUD】 flash</li>
<li>监视：idf.py -p PORT monitor，使用快捷键 <code>Ctrl+]</code>，退出 IDF 监视器</li>
<li>一次性执行构建、烧录和监视过程：idf.py -p PORT flash monitor</li>
</ul>
<h1 id="MicroPython环境搭建"><a href="#MicroPython环境搭建" class="headerlink" title="MicroPython环境搭建"></a>MicroPython环境搭建</h1><p>分为esp32侧的Firmware和PC侧的IDE两部分。</p>
<p>本文是Linux环境，windows环境参考：<a href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/01.dajianhuanjing">Thonny+MicroPython+ESP32开发环境搭建</a></p>
<h2 id="ESP32安装MicroPython"><a href="#ESP32安装MicroPython" class="headerlink" title="ESP32安装MicroPython"></a>ESP32安装MicroPython</h2><p>Micropython是在嵌入式平台上运行Python的基础库，参考：<a href="https://docs.micropython.org/en/latest/">https://docs.micropython.org/en/latest/</a></p>
<p>下载和安装esp32的Micropython，参考：<a href="https://micropython.org/download/esp32/">Installation instructions</a></p>
<p>先擦除flash, 其中esptool.py已经被esp-idf&#x2F;export.sh导出到环境变量；如果ls &#x2F;dev&#x2F;tty*显示有ttyUSB0，但esptool.py还找不到ttyUSB0，需要重启并用<code>get_idf</code>重新export idf，再插拔esp32就可以找到.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash</span><br></pre></td></tr></table></figure>

<p>烧写支持micropython的 &lt;esp32-firmware.bin&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 &lt;esp32-firmware.bin&gt;</span><br></pre></td></tr></table></figure>

<p>例如我的Firmware使用的是：</p>
<p><strong><a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.bin">v1.20.0 (2023-04-26) .bin</a></strong> [<a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.elf">.elf]</a> [<a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.map">.map]</a> [<a href="https://github.com/micropython/micropython/releases/tag/v1.20.0">Release notes]</a> (latest)</p>
<h2 id="使用VScode-Pymakr搭建Micropython开发环境"><a href="#使用VScode-Pymakr搭建Micropython开发环境" class="headerlink" title="使用VScode+Pymakr搭建Micropython开发环境"></a>使用VScode+Pymakr搭建Micropython开发环境</h2><p>总体的安装流程参考：<a href="https://randomnerdtutorials.com/micropython-esp32-esp8266-vs-code-pymakr/">MicroPython: Program ESP32&#x2F;ESP8266 using VS Code and Pymakr</a></p>
<p>Pymakr如何使用，参考<a href="https://github.com/pycom/pymakr-vsc/blob/next/GET_STARTED.md">Pymakr Getting Started</a></p>
<p>写一个LED闪烁的sample code验证开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from machine import Pin</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">led = Pin(2, Pin.OUT) #GPIO2, output mode</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">  led.value(not led.value())</span><br><span class="line">  sleep(0.5)</span><br></pre></td></tr></table></figure>

<p>LED如何控制，要根据esp32具体开发板的电路图找到LED相关的GPIO，以及配什么输入&#x2F;输出模式使GPIO导通&#x2F;关闭。</p>
<p>如下图，我的esp32 LED连接到GPIO2(IO2)，并且GPIO2输出高电平时LED导通</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042003091.png" alt="image-20230504200335998"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042004848.png" alt="image-20230504200411499"></p>
<p>选择VSCode的Pymakr Project -&gt; connect device -&gt; ’sync project to device‘，上传该LED python代码到esp32上运行；右键Pymakr Project的Hard reset device以后执行python代码</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051116409.png" alt="image-20230505111655320"></p>
<p>esp32 GPIO2的LED不停闪烁</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051156061.gif" alt="mmexport1683202673677"></p>
]]></content>
      <categories>
        <category>esp32</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo和next主题的配置笔记</title>
    <url>/2023/03/15/hexo%E5%92%8Cnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="hexo相关配置"><a href="#hexo相关配置" class="headerlink" title="hexo相关配置"></a>hexo相关配置</h3><p>hexo各页面的配置，参考 <a href="https://www.jianshu.com/p/3a05351a37dc">jianshu-Hexo的Next主题详细配置</a></p>
<p>hexo主页显示摘要，参考 <a href="https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%20Next%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E6%96%87%EF%BC%89/">Hexo Next主题首页配置为只显示部分摘要</a></p>
<h3 id="next设置字体"><a href="#next设置字体" class="headerlink" title="next设置字体"></a>next设置字体</h3><p>参考 <a href="https://tzynwang.github.io/2021/next-theme-edit/#:~:text=Search%20for%20the%20font%20family%20%E2%80%9CRoboto%E2%80%9D%20Click%20%E2%80%9C%2B,as%20the%20value%20for%20%E2%80%9Chost%E2%80%9D%20key%20in%20_config.next.yml">tzynwang.github.io&#x2F;2021&#x2F;next-theme-edit</a></p>
<p>下面重点描述如何使用Google Font来配置next主题的字体，基于next version 8.0.0</p>
<ul>
<li>推荐英文字体使用Roboto，中文字体使用 Noto Serif (注：Noto Serif字符集包含chinese&#x2F;Japanese&#x2F;korea等，参考 <a href="https://github.com/notofonts/noto-cjk">noto-cjk</a>；Noto Serif 是宋体但不是宋体思源，见后文)</li>
<li>在<a href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索框搜索字体英文名添加以上两种字体，产生URI(Uniform Resource Identifier)，复制href字段的引号内容</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151454240.png" alt="image-20230315145422134"></p>
<ul>
<li>在hexo的next配置文件<code>hexo\themes\next\_config.yml</code>的font字段添加host URI和字体名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span><br><span class="line">  host: https://fonts.googlefonts.cn/css?family=Noto+Serif|Roboto</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: x.x`. Use `em` as unit. Default: 1 (16px)</span><br><span class="line"></span><br><span class="line">  # Global font settings used for all elements inside &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Noto Serif</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for site title (.site-title).</span><br><span class="line">  title:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for posts (.post-body).</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto</span><br></pre></td></tr></table></figure>

<ul>
<li>在静态页面的base style配置文件<code>hexo\themes\next\source\css\_variables\base.styl</code>指定中文字体font-family-chinese为’Noto Serif’（注意看这里get_font_family解析到next配置文件_config.yml的字段’global’, ‘title’ … ‘codes’等作为静态页面的配置）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Font families.</span><br><span class="line">$font-family-chinese      = &#x27;Noto Serif&#x27;;</span><br><span class="line"></span><br><span class="line">$font-family-base         = $font-family-chinese, sans-serif;</span><br><span class="line">$font-family-base         = get_font_family(&#x27;global&#x27;), $font-family-chinese, sans-serif if get_font_family(&#x27;global&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-logo         = $font-family-base;</span><br><span class="line">$font-family-logo         = get_font_family(&#x27;title&#x27;), $font-family-base if get_font_family(&#x27;title&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-headings     = $font-family-base;</span><br><span class="line">$font-family-headings     = get_font_family(&#x27;headings&#x27;), $font-family-base if get_font_family(&#x27;headings&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-posts        = $font-family-base;</span><br><span class="line">$font-family-posts        = get_font_family(&#x27;posts&#x27;), $font-family-base if get_font_family(&#x27;posts&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-monospace    = monospace, consolas, Menlo, $font-family-chinese;</span><br><span class="line">$font-family-monospace    = get_font_family(&#x27;codes&#x27;), monospace, consolas, Menlo, $font-family-chinese if get_font_family(&#x27;codes&#x27;);</span><br></pre></td></tr></table></figure>

<p>自此next中英文字体都应该生效，<code>hexo g + hexo s</code> 重新部署验证一下发现中文字体似乎不是思源宋体？</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151606100.png" alt="image-20230315160648032"></p>
<p>原因是Noto Serif !&#x3D; Noto Serif SC (simplified chinese)，Noto Serif SC才是思源宋体</p>
<p><a href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索不到思源宋体，<a href="https://fonts.google.com/">google font原站</a>又打不开，因此需要直接替换URI，将fonts.googlefonts.cn替换为fonts.googleapis.com，Noto Serif替换为Noto Serif SC</p>
<p>next配置文件改动如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo\themes\next\_config.yml:</span><br><span class="line"></span><br><span class="line">font:</span><br><span class="line">    - host: https://fonts.googlefonts.cn/css?family=Noto+Serif|Roboto</span><br><span class="line">    + host: https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto</span><br><span class="line"></span><br><span class="line">    global:</span><br><span class="line">    - family: Noto Serif</span><br><span class="line">    + family: Noto Serif SC</span><br><span class="line">    </span><br><span class="line">hexo\themes\next\source\css\_variables\base.styl:</span><br><span class="line"></span><br><span class="line">// Font families.</span><br><span class="line">- $font-family-chinese = &#x27;Noto Serif&#x27;;</span><br><span class="line">+ $font-family-chinese = &#x27;Noto Serif SC&#x27;;</span><br></pre></td></tr></table></figure>

<p>验证结果为思源宋体：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151559719.png" alt="image-20230315155911647"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用笔记</title>
    <url>/2022/03/09/python%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Python使用正则表达式示例"><a href="#Python使用正则表达式示例" class="headerlink" title="Python使用正则表达式示例"></a>Python使用正则表达式示例</h2><p>Python的正则表达式比较全面的教程，参考<a href="https://www.programiz.com/python-programming/regex"># Python RegEx</a></p>
<p>使用背景：芯片ATE测试中，不同ATE平台的测试模式文件格式有不同，需要匹配字符串并按特定转换<br>转换前：</p>
<blockquote>
<p>Pattern “pll_dll_100m_test” {<br>waveform_start:<br>W pll_dll_100m_wft;</p>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>转后后：</p>
<blockquote>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;} W pll_dll_100m_wft;<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>规则：将以“W_xxx”的字符串放到下一个以“V_xxx”的字符串后面</p>
<p>利用python正则匹配，配合读取文件到字符串数组，实现如下转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">infile_name = <span class="built_in">input</span>(<span class="string">&quot;Please input the name of file in current directory to convert: &quot;</span>)</span><br><span class="line">name_flag = infile_name.find(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> name_flag == -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file name error, need input the suffix of file name&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(infile_name):</span><br><span class="line">        outfile_name = infile_name[<span class="number">0</span>:name_flag] + <span class="string">&quot;_updated&quot;</span> + infile_name[name_flag:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no such file!&quot;</span>)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">infile = <span class="built_in">open</span>(infile_name, <span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(outfile_name, <span class="string">&quot;w&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lines = infile.readlines()</span><br><span class="line">infile.close()</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">    str_obj = re.match(<span class="string">&#x27;[\s]*W[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;W ...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        temp_index = index</span><br><span class="line">        temp_str = str_obj.group()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_obj = re.match(<span class="string">&#x27;[\s]*V[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;V ...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                lines[temp_index] = <span class="string">&#x27;\n&#x27;</span> <span class="comment">#clear last &quot;W ...&quot;</span></span><br><span class="line">                lines[index] = str_obj.group() + <span class="string">&#x27; &#x27;</span> + temp_str + <span class="string">&#x27;\n&#x27;</span> <span class="comment">#add the &quot;W ...&quot; from &quot;V ...&quot; end</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">outfile.writelines(lines)</span><br><span class="line">outfile.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;outputfile is &quot;</span> + outfile_name)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的W和V前面加了额外的匹配项：<code>[\s]*</code>，是因为文件存在不可见的回车换行等引起，如果不加匹配不到</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6笔记之环境搭建</title>
    <url>/2023/05/06/xv6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本文在Ubuntu22.04上搭建xv6(x86版本)的开发环境，用于编译、调试xv6源码。</p>
<ul>
<li>xv6 x86版本参考<a href="https://pdos.csail.mit.edu/6.828/2018/overview.html">MIT6.828&#x2F;2018</a></li>
<li>xv6 riscv版本参考<a href="https://pdos.csail.mit.edu/6.828/2020/">MIT6.S081</a> ，MIT6.828从2019年以后以RISCV指令集实现，并拆分了课程</li>
</ul>
<p>两者的课程内容区别：</p>
<p>6.828 and 6.S081 will be offered as two separate classes. 6.S081 (Introduction to Operating Systems) will be taught as a stand-alone AUS subject for undergraduates, and will provide an introduction to operating systems. 6.828 will be offered as a graduate-level seminar-style class focused on research in operating systems. 6.828 will assume you have taken 6.S081 or an equivalent class.</p>
<p>为什么选用x86版本：</p>
<p>x86版本有更完善的资料和更细节的代码讲解，参考：<a href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p>学完x86版本再学riscv版本，只需要关注指令集差异即可</p>
<h2 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h2><p>主流程参考：<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">Tools Used in 6.828</a></p>
<p>这里只记录我操作过程中和该wiki的差异点</p>
<p>1.下载包有的连接失败，bing搜索到合适的下载源后，最终成功下载的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br></pre></td></tr></table></figure>

<p>2.编译Toolchain中的问题：</p>
<p>(0)<strong>注意!!!</strong> 在编译Toolchain完成以后要恢复默认的LD_LIBRARY_PATH，不要在toolchain配置了LD_LIBRARY_PATH的情况下去完成后续的安装qemu等其他任何操作，否则可能系统损害无法进入桌面且不能recovery，报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libgnutls.so.30 undefined symbol: __gmpz_limbs_write</span><br></pre></td></tr></table></figure>

<p>问题原因和解决办法参考：<a href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined"><a href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined">apt-get wants an older GNUTLS version to be defined</a></a></p>
<p><strong>LIB PATH导致系统损坏的经验：搭建开发环境配置的LD_LIBRARY_PATH不要随便export；在使用时export, 使用完毕后恢复</strong></p>
<p>(1)如果安装在&#x2F;usr&#x2F;local，所有make install都要sudo；安装在home不需要sudo</p>
<p>(2)编译gcc时报错：<code>configure: error: cannot compute suffix of object files: cannot compile</code></p>
<p>需要export PATH，由于所有编译包都安装在&#x2F;usr&#x2F;local&#x2F;，所以export PATH也为&#x2F;usr&#x2F;local&#x2F;，保存为export-path.sh方便重启后使用，也可以加到~&#x2F;.bashrc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>(3)编译gdb时报错：<code>error: no termcap library found</code></p>
<p>要手动下载termcap包并编译，操作过程和toolchain一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>完整的编译脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export PFX=~/xv6/toolchain #这里编译到home,也可以用/usr/local</span><br><span class="line">mkdir -p $PFX</span><br><span class="line">cd $PFX</span><br><span class="line"></span><br><span class="line">#install a development environment.</span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line">sudo apt-get install gcc-multilib</span><br><span class="line"></span><br><span class="line">#Building Your Own Compiler Toolchain</span><br><span class="line">#wget容易失败，因此这部分最好手动执行，确保全部下载成功</span><br><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br><span class="line"></span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">tar xjf gmp-5.0.2.tar.bz2</span><br><span class="line">cd gmp-5.0.2</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf mpfr-3.1.2.tar.bz2</span><br><span class="line">cd mpfr-3.1.2</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xzf mpc-0.9.tar.gz</span><br><span class="line">cd mpc-0.9</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf binutils-2.21.1.tar.bz2</span><br><span class="line">cd binutils-2.21.1</span><br><span class="line">./configure --prefix=$PFX --target=i386-jos-elf --disable-werror</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gcc-core-4.6.4.tar.bz2</span><br><span class="line">cd gcc-4.6.4</span><br><span class="line">mkdir build              # GCC will not compile correctly unless you build in a separate directory</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=$PFX \ </span><br><span class="line">    --with-gmp=$PFX --with-mpfr=$PFX --with-mpc=$PFX \ #指定gmp, mpfr, mpc位置</span><br><span class="line">    --target=i386-jos-elf --disable-werror \</span><br><span class="line">    --disable-libssp --disable-libmudflap --with-newlib \</span><br><span class="line">    --without-headers --enable-languages=c MAKEINFO=missing</span><br><span class="line">make all-gcc</span><br><span class="line">make install-gcc         # This step may require privilege (sudo make install-gcc)</span><br><span class="line">make all-target-libgcc</span><br><span class="line">make install-target-libgcc     # This step may require privilege (sudo make install-target-libgcc)</span><br><span class="line">cd ../..</span><br><span class="line"></span><br><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gdb-7.3.1.tar.bz2</span><br><span class="line">cd gdb-7.3.1</span><br><span class="line">./configure --prefix=$PFX \</span><br><span class="line">    --target=i386-jos-elf --program-prefix=i386-jos-elf- \</span><br><span class="line">    --disable-werror</span><br><span class="line">make all</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">i386-jos-elf-objdump -i</span><br><span class="line"># Should produce output like:</span><br><span class="line"># BFD header file version (GNU Binutils) 2.21.1</span><br><span class="line"># elf32-i386</span><br><span class="line">#  (header little endian, data little endian)</span><br><span class="line">#   i386...</span><br><span class="line"></span><br><span class="line">i386-jos-elf-gcc -v</span><br><span class="line"># Should produce output like:</span><br><span class="line"># Using built-in specs.</span><br><span class="line"># COLLECT_GCC=i386-jos-elf-gcc</span><br><span class="line"># COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/i386-jos-elf/4.6.4/lto-wrapper</span><br><span class="line"># Target: i386-jos-elf</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=&quot;&quot; #恢复系统本身的libpath(默认空)，避免装其他软件有lib冲突造成系统损坏</span><br></pre></td></tr></table></figure>

<h2 id="交叉编译的参数"><a href="#交叉编译的参数" class="headerlink" title="交叉编译的参数"></a>交叉编译的参数</h2><p>在交叉编译configure时，通常会需要设置–build、–host和–target选项。各个选项的含义如下：</p>
<ul>
<li>–build：编译所用的机器的平台。</li>
<li>–host：编译出的代码运行的平台。</li>
<li>–target：编译出来的工具链生成的代码的运行平台。这个选项不常用，一般只在编译gcc、ld等工具链的过程中用到。</li>
</ul>
<p>在不涉及到交叉编译的时候，–build、–host、–target缺省值都是本机平台，不需要特别设置。</p>
<p>在交叉编译的时候，比如需要在x86平台编译arm程序，就需要设置–build和–host选项；其中host的内容为目标平台名称，通常编译器的名字前缀就是目标平台名称，例如用arm-unknown-linux-gnueabi-gcc编译，–host设置为arm-unknown-linux-gnueabi；–build可以缺省不设置就是使用当前平台名称</p>
<h2 id="编译QEMU"><a href="#编译QEMU" class="headerlink" title="编译QEMU"></a>编译QEMU</h2><p>xv6使用的QEMU是patched version，要手动编译，过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/mit-pdos/6.828-qemu.git qemu</span><br><span class="line"></span><br><span class="line">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span><br><span class="line"></span><br><span class="line">#此qemu版本需要python2 (2.7), 由于python2和3不兼容, 且系统只有Python3, 因此需要安装</span><br><span class="line">sudo apt install python2</span><br><span class="line">python2 -V</span><br><span class="line">cd qemu</span><br><span class="line"></span><br><span class="line">./configure --disable-kvm --disable-werror --prefix=$PFX --target-list=&quot;i386-softmmu x86_64-softmmu&quot; --python=/usr/bin/python2</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>qemu编译错误的解决办法：<a href="https://github.com/woai3c/MIT6.828/blob/master/docs/install.md">MIT6.828 实验环境安装教程</a></p>
<p>其中以下错误的解决方法： 在 <code>qga/commands-posix.c</code> 文件中加 <code>#include &lt;sys/sysmacros.h&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qga/commands-posix.c: In function ‘dev_major_minor’:</span><br><span class="line">qga/commands-posix.c:633:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;.</span><br></pre></td></tr></table></figure>

<p>下载6.828的jos lab，make产生kernel.img</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></pre></td></tr></table></figure>

<p>make qemu执行qemu，内容如下表示qemu环境搭建OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit</span><br><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log </span><br><span class="line">VNC server running on `127.0.0.1:5900&#x27;</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：使用GDB调试多线程</title>
    <url>/2021/07/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-GDB简介"><a href="#1-GDB简介" class="headerlink" title="1.GDB简介"></a>1.GDB简介</h1><p>官网文档：<br><a href="https://www.gnu.org/software/gdb/documentation/">GDB: The GNU Project Debugger</a></p>
<p>关于GDB的原理：<br><a href="https://cloud.tencent.com/developer/article/1365186">GDB实现原理和使用范例</a><br><a href="http://oenhan.com/gdb-principle">GDB工作原理和内核实现</a><br><a href="http://www.docin.com/p-18618736.html">GDB的基本工作原理</a></p>
<p>其他教程：<a href="http://c.biancheng.net/gdb/">GDB调试教程</a></p>
<p>几个重点：</p>
<ul>
<li>多种运行方式：gdb启动程序再调试(独立功能程序)，gdb attach进程再调试(服务端程序)，gdb加载core dump调试(离线调试)</li>
<li>GDB的本质是“截获”被调试程序，attach用ptrace截获了OS和应用程序之间的通信, 端点本质是trap中断，截获了CPU正常取指执行流程</li>
</ul>
<p>本文源码：<a href="https://github.com/cursorhu/SimpleMultiThread/tree/master/4.gdb_thread">cursorhu&#x2F;SimpleMultiThread&#x2F;4.gdb_thread&#x2F;</a></p>
<h1 id="2-多线程程序的GDB调试"><a href="#2-多线程程序的GDB调试" class="headerlink" title="2.多线程程序的GDB调试"></a>2.多线程程序的GDB调试</h1><p>待调试代码：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 0;
std::mutex g_mutex;

void thread_func1()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        if(g_mydata == 1024)
            g_mydata = 0;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);
    t1.join();
    t2.join();
    return 0;
&#125;
</code></pre>
<p>编译：</p>
<pre><code>g++ -g -std=c++11 cppthread.cpp -o cppthread -lpthread
</code></pre>
<p>-g: 带debug信息，gdb要用<br>-lpthread：链接pthread库。当应用直接调用POSIX&#x2F;pthread接口，或Linux环境中运行多线程都需要</p>
<h2 id="attach方式调试"><a href="#attach方式调试" class="headerlink" title="attach方式调试"></a>attach方式调试</h2><p>(1)后台运行并获取PID</p>
<ul>
<li>GDB调试已运行的程序，cppthread线程写成死循环，后台运行。</li>
<li>ps -ef | grep NAME 获取PID</li>
<li>pstree可以查看线程关系</li>
<li>LWP:轻量级进程，是用户线程和内核的中间接口。用户级线程连接LWP上便具有内核线程的所有属性。因此可以认为LWP ID对应线程ID</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534342.png" alt="1"></p>
<p>(2)gdb attach，管控进程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051544779.png" alt="2"></p>
<p>(3)查看所有线程信息<br>*表示当前在1号线程，注意这个ID是GDB attach后分配的，真实线程ID参考LWP<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534546.png" alt="3"></p>
<p>(4)查看线程backtrace<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535566.png" alt="4"></p>
<p>(5)切换线程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535346.png" alt="5"></p>
<p>(6)单步调试线程</p>
<ul>
<li>注意，GDB调试时是支持线程切换的，等同正常执行多线程，也可以禁用切换：<code>set scheduler-locking on</code>。本示例有mutex锁,未见到切换</li>
<li><code>next</code>: 单步（一步），<code>next n</code>: 单步n步</li>
<li><code>watch 变量</code>，可见<code>next 6</code>后g_mydata + 1</li>
<li><code>watch</code>会自动隐式的加断点，后文会看到断点信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535751.png" alt="6"></p>
<p>(7)断点</p>
<ul>
<li><code>break i</code>: 在代码i行加断点， <code>break func</code>:在函数加断点</li>
<li><code>clear i</code>: 清除i行的断点， <code>delete id</code>: 清除指定id的断点</li>
<li>注意看watch引入了一个断点11</li>
<li><code>continue</code>：继续执行，通常配合断点使用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535502.png" alt="7"></p>
<p>(8)线程外调试+多断点<br>两个工作线程都加断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535139.png" alt="8"><br>一次运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535180.png" alt="9"><br>继续运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536672.png" alt="10"></p>
<ul>
<li>Thread2和Thread3即工作线程，Thread1为主线程</li>
<li>Thread1会切到工作线程，LWP&#x3D;6080或6081</li>
<li>两次运行,Thread1切到的LWP不一样</li>
</ul>
<p>GDB显示主线程切到哪个工作线程，实际是CPU当前在执行哪个工作线程，因此两次运行到断点时，当前执行线程分别是Thread2和Thread3，主线程实际是阻塞的。</p>
<h2 id="GDB直接运行程序"><a href="#GDB直接运行程序" class="headerlink" title="GDB直接运行程序"></a>GDB直接运行程序</h2><p>用GDB运行程序的调试方式：</p>
<pre><code> gdb &lt; prog_name &gt;
</code></pre>
<p>(1)运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536065.png" alt="11"></p>
<p>(2)加断点和执行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536275.png" alt="12"></p>
<p>(3)查看变量值<br><code>p 变量</code>：打印变量，和<code>watch</code>相比不会加隐含的断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536108.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051537112.png" alt="14"></p>
<h2 id="core-dump文件方式调试"><a href="#core-dump文件方式调试" class="headerlink" title="core dump文件方式调试"></a>core dump文件方式调试</h2><p>有关core dump<br><a href="https://www.cnblogs.com/computer1-2-3/p/11114981.html">Linux 下如何产生core文件（core dump设置）</a><br><a href="https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/">Understand and configure core dumps on Linux</a><br><a href="https://www.cnblogs.com/uhziel/p/cpp_segmentation_fault.html">C++中段错误的常见情况</a><br><a href="https://blog.csdn.net/xuzhina/category_1322964.html">coredump问题原理探究(Linux版)
</a></p>
<p>下面修改前面的程序，制造core dump<br>(1)数组越界<br>cppthread_dump_array.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int g_mydata = 0;
std::mutex g_mutex;

char test_dump_buf[10] = &#123;0&#125;;

void thread_func1()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        char c;
        sprintf(&amp;c, &quot;%d&quot;, g_mydata);
        std::strcat(test_dump_buf, &amp;c); //持续追加g_mydata字符串
        if(g_mydata == 1024)
            g_mydata = 0;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;test_dump_buf: &quot; &lt;&lt; test_dump_buf &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538738.png" alt="15"><br>并未发生段错误，更不谈core dump。因为CPP对数组没有越界限制，这是个“合法”行为</p>
<p>(2)使用空指针<br>cppthread_dump_nullptr.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
&#123;
    public:
        Foo(int m)
        &#123;
            m_data = m;
        &#125;
        ~Foo()&#123;&#125;
        void printval() 
        &#123;
            std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
        &#125;
        void increase()
        &#123;
            ++m_data;
        &#125;
        int getval()
        &#123;
            return m_data;
        &#125;
        void resetval()
        &#123;
            m_data = 0;
        &#125;
        
    private:
        int m_data;
&#125;;

void thread_func1(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.increase();
        if(p.getval() == 1024)
            p.resetval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.printval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;    
    Foo *pFoo = new Foo(0);

    std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
    std::thread t2(thread_func2, std::ref(*pFoo));

    //t1.join();  //这里故意不join
    //t2.join();
    sleep(10);  //sleep等一下thread1,2
    
    delete pFoo; 
    pFoo = NULL;  //这时thread1,2还没执行完，形成了使用空指针的条件
            
    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538644.png" alt="16"></p>
<p>下面gdb调试这个core dump</p>
<ul>
<li><p>设置core dump文件大小限制为不受限<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538876.png" alt="17"><br>最好写入配置文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538835.png" alt="18"></p>
</li>
<li><p>gdb加载程序和core dump文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538139.png" alt="19"><br>可见siganl 6发生，使进程终止</p>
</li>
<li><p>看dump位置，bt或where都可以<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538557.png" alt="20"></p>
</li>
<li><p>看所有线程的栈<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538027.png" alt="21"></p>
</li>
<li><p>直接看dump附近的代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051539217.png"></p>
</li>
</ul>
<p>结论：根据bt&#x2F;where, dump发生时，主进程在在执行67行：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542767.png" alt="image-20221205154207720"></p>
<p>根据源码，具体是工作线程调用对象的方法时发生<br>再看dump打印，正好要打印<code>m_data = 10</code>的时候dump，结合main中sleep(10)和工作线程sleep(1)，dump原因是main把对象指针置空了，而两个工作线程还在调用对象的方法，位置是thread_func2的p.printval()处</p>
<h2 id="一个示例：调试死锁"><a href="#一个示例：调试死锁" class="headerlink" title="一个示例：调试死锁"></a>一个示例：调试死锁</h2><p>最常见的死锁是双重加锁，和双重delete的道理一样，代码复杂了，层层调用的情况下容易出现<br>示例代码cppthread_deadlock.cpp：<br>线程函数和其调用的类方法都加锁了，形成死锁</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
&#123;
    public:
        Foo(int m)
        &#123;
            m_data = m;
        &#125;
        ~Foo()&#123;&#125;
        void printval() 
        &#123;
            std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
        &#125;
        void increase()
        &#123;
            g_mutex.lock(); //故意制造双重加锁
            ++m_data;
            g_mutex.unlock();
        &#125;
        int getval()
        &#123;
            return m_data;
        &#125;
        void resetval()
        &#123;
            m_data = 0;    
        &#125;
        
    private:
        int m_data;
&#125;;

void thread_func1(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.increase();
        if(p.getval() == 1024)
            p.resetval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.printval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;    
    Foo *pFoo = new Foo(0);

    std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
    std::thread t2(thread_func2, std::ref(*pFoo));

    t1.join();
    t2.join();
    
    delete pFoo;
    pFoo = NULL;
            
    return 0;
&#125;
</code></pre>
<p>调试：</p>
<ul>
<li>直接运行方式，要run起来才有线程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542989.png" alt="23"></p>
<ul>
<li>backtrace可见两个线程都停止于lock_wait()，其中thread2回溯看到死锁代码在45行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051546645.png" alt="24"></p>
<p>对于互斥锁推荐用RAII机制的<code>std::lock_guard&lt;mutex&gt; lockGuard(m)</code>，能避免忘记unlock情况。但在此示例中，lock_guard也会双重加锁。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>thread gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：多线程的同步机制</title>
    <url>/2021/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>本文讲解并发环境中的几个线程同步示例<br>线程同步，即多个线程如何协调，谁先谁后<br>本文基于Linux&#x2F;POSIX API<br>本系列源码：<a href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p>生产者&#x2F;消费者模式是并发环境常见的模式，简单地讲，通过中介缓冲，支持多组任务并发执行，避免任务间发生通信阻塞。<br>参考：<a href="https://blog.csdn.net/darkdragonking/article/details/89208124">生产者&#x2F;消费者模式的理解及实现</a></p>
<p>常用的实现方式</p>
<ul>
<li>互斥量(参考<a href="http://47.100.221.149:9010/blog/post/admin/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89">多线程入门（一）</a>)</li>
<li>信号量</li>
<li>条件变量</li>
<li>读写锁</li>
</ul>
<h1 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h1><p>关于LInux信号量：<a href="https://www.jianshu.com/p/6e72ff770244">Linux信号量</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
&#123;
public:
    Task(int taskID)
    &#123;
        this-&gt;taskID = taskID;
    &#125;
    
    void doTask()
    &#123;
        std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
    &#125;
    
private:
    int taskID;
&#125;;

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
sem_t            mysemaphore;

void* consumer_thread(void* param)
&#123;    
    Task* pTask = NULL;
    while (true)
    &#123;
        struct timespec ts;
        ts.tv_sec = 3;
        ts.tv_nsec = 0;
        
        if (sem_timewait(&amp;mysemaphore, &amp;ts) != 0)
        &#123;
            if (errno == ETIMEOUT)
            &#123;
                std::cout &lt;&lt; &quot;ETIMEOUT&quot; &lt;&lt; std::endl;
            &#125;
            continue;
        &#125;
        
        if (tasks.empty())
            continue;
        
        pthread_mutex_lock(&amp;mymutex);    
        pTask = tasks.front();
        tasks.pop_front();
        pthread_mutex_unlock(&amp;mymutex);
        
        pTask-&gt;doTask();
        delete pTask;
    &#125;
    
    return NULL;
&#125;

void* producer_thread(void* param)
&#123;
    int taskID = 0;
    Task* pTask = NULL;
    
    while (true)
    &#123;
        pTask = new Task(taskID);
            
        pthread_mutex_lock(&amp;mymutex);
        tasks.push_back(pTask);
        std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
        
        pthread_mutex_unlock(&amp;mymutex);
        
        //释放信号量，通知消费者线程
        sem_post(&amp;mysemaphore);
        
        taskID ++;

        //休眠1秒
        sleep(1);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_mutex_init(&amp;mymutex, NULL);
    //初始信号量资源计数为0
    sem_init(&amp;mysemaphore, 0, 0);

    //创建5个消费者线程
    pthread_t consumerThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
    &#125;
    
    //创建一个生产者线程
    pthread_t producerThreadID;
    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

    pthread_join(producerThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(consumerThreadID[i], NULL);
    &#125;
    
    sem_destroy(&amp;mysemaphore);
    pthread_mutex_destroy(&amp;mymutex);

    return 0;
&#125;
</code></pre>
<p>说明几点：</p>
<ul>
<li>信号量和锁一样，全局的</li>
<li>sem_post和sem_wait是P(), V()操作的具体实现，即计数+1，-1</li>
</ul>
<h1 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h1><p>关于条件变量(cv)：<a href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量(condition variables)</a><br>条件变量同锁一起使用使得线程可以以一种无竞争的方式等待任意条件的发生。所谓无竞争就是，条件改变这个信号会发送到所有等待这个信号的线程。</p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
&#123;
public:
    Task(int taskID)
    &#123;
        this-&gt;taskID = taskID;
    &#125;
    
    void doTask()
    &#123;
        std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
    &#125;
    
private:
    int taskID;
&#125;;

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
pthread_cond_t   mycv;

void* consumer_thread(void* param)
&#123;    
    Task* pTask = NULL;
    while (true)
    &#123;
        pthread_mutex_lock(&amp;mymutex);
        while (tasks.empty())
        &#123;                
            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
            pthread_cond_wait(&amp;mycv, &amp;mymutex);
        &#125;
        
        pTask = tasks.front();
        tasks.pop_front();

        pthread_mutex_unlock(&amp;mymutex);
        
        if (pTask == NULL)
            continue;

        pTask-&gt;doTask();
        delete pTask;
        pTask = NULL;        
    &#125;
    
    return NULL;
&#125;

void* producer_thread(void* param)
&#123;
    int taskID = 0;
    Task* pTask = NULL;
    
    while (true)
    &#123;
        pTask = new Task(taskID);
            
        pthread_mutex_lock(&amp;mymutex);
        tasks.push_back(pTask);
        std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
        
        pthread_mutex_unlock(&amp;mymutex);
        
        //释放条件信号，通知消费者线程
        pthread_cond_signal(&amp;mycv);
        
        taskID ++;

        //休眠1秒
        sleep(1);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_mutex_init(&amp;mymutex, NULL);
    pthread_cond_init(&amp;mycv, NULL);

    //创建5个消费者线程
    pthread_t consumerThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
    &#125;
    
    //创建一个生产者线程
    pthread_t producerThreadID;
    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

    pthread_join(producerThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(consumerThreadID[i], NULL);
    &#125;
    
    pthread_cond_destroy(&amp;mycv);
    pthread_mutex_destroy(&amp;mymutex);

    return 0;
&#125;
</code></pre>
<h1 id="读写锁实现"><a href="#读写锁实现" class="headerlink" title="读写锁实现"></a>读写锁实现</h1><p>关于读写锁，参考：<a href="https://www.cnblogs.com/love-DanDan/p/8723931.html">Linux：使用读写锁使线程同步</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;

int resourceID = 0;
pthread_rwlock_t myrwlock;

void* read_thread(void* param)
&#123;    
    while (true)
    &#123;
        //请求读锁
        pthread_rwlock_rdlock(&amp;myrwlock);

        std::cout &lt;&lt; &quot;read thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
                
        //使用睡眠模拟读线程读的过程消耗了很久的时间
        sleep(1);
                
        pthread_rwlock_unlock(&amp;myrwlock);
    &#125;
    
    return NULL;
&#125;

void* write_thread(void* param)
&#123;
    while (true)
    &#123;
        //请求写锁
        pthread_rwlock_wrlock(&amp;myrwlock);

        ++resourceID;
        std::cout &lt;&lt; &quot;write thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
                
        //使用睡眠模拟读线程读的过程消耗了很久的时间
        sleep(1);
                
        pthread_rwlock_unlock(&amp;myrwlock);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_rwlock_init(&amp;myrwlock, NULL);

    //创建5个请求读锁线程
    pthread_t readThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);
    &#125;
    
    //创建一个请求写锁线程
    pthread_t writeThreadID;
    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);

    pthread_join(writeThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(readThreadID[i], NULL);
    &#125;
    
    pthread_rwlock_destroy(&amp;myrwlock);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：线程库的使用</title>
    <url>/2021/07/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>多线程概述：应用层的多线程的目的就是让每一个任务（例如一系列函数调用）都认为自己独占CPU资源，即宏观上，多个任务可以同时执行（实际可能是轮转的串行执行）。<br>代码实现：线程库可以由编程语言的标准库或者操作系统的库实现，具体包含的头文件如下：</p>
<ul>
<li>C&#x2F;C++ : &lt; thread &gt;</li>
<li>POSIX(Portable Operating System Interface of UNIX, Linux环境使用较多) ：&lt; pthread.h &gt;</li>
<li>Windows OS : &lt; windows.h &gt;</li>
</ul>
<p>具体环境使用哪个库，有不同的观点，参考<br><a href="https://www.zhihu.com/question/36236334/answer/98422670">c++多线程编程主要用pthread还是c++11中的thread类？</a><br>即使是同一环境，也有不同封装层次的API<br><a href="https://blog.csdn.net/qq_22642239/article/details/90445414">CreateThread()与_beginthread()的区别详细解析</a></p>
<p>主线程与工作线程：<br>一般应用程序都有主要的执行流程，例如C&#x2F;C++的main入口函数，主要执行流程是在进程中执行的，也可以认为main是线程，独占了进程的全部资源，称为主线程。如果在该进程执行时，创建多个线程，用于并行处理其他任务，称为工作线程。</p>
<p>本文讲不同风格的线程创建\销毁，和访问共享数据的锁操作<br>本系列源码：<a href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="Windows风格多线程"><a href="#Windows风格多线程" class="headerlink" title="Windows风格多线程"></a>Windows风格多线程</h1><p>(1)双线程打印</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s &lt;&lt; endl;
    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    CloseHandle(hThread);
    
    return 0;
&#125;
</code></pre>
<p>主线程和工作线程都运行Print()，各线程的栈空间保存自己的局部数据。<br>windows API使用CreateThread和CloseHandle创建线程、释放线程句柄，说明如下</p>
<pre><code>HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD：线程安全相关的属性，常置为NULL
    SIZE_T dwStackSize,//initialstacksize：新线程的初始化栈的大小，可设置为0
    LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction：被线程执行的回调函数，也称为线程函数
    LPVOID lpParameter,//threadargument：传入线程函数的参数，不需传递参数时为NULL
    DWORD dwCreationFlags,//creationoption：控制线程创建的标志
    LPDWORD lpThreadId//threadidentifier：传出参数，用于获得线程ID，如果为NULL则不返回线程ID
    )
 
/*
lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，决定返回的句柄是否可被子进程继承，如果为NULL则表示返回的句柄不能被子进程继承。
dwStackSize：设置初始栈的大小，以字节为单位，如果为0，那么默认将使用与调用该函数的线程相同的栈空间大小。
任何情况下，Windows根据需要动态延长堆栈的大小。
lpStartAddress：指向线程函数的指针，函数名称没有限制，但是必须以下列形式声明：
DWORD WINAPI 函数名 (LPVOID lpParam) ，格式不正确将无法调用成功。
lpParameter：向线程函数传递的参数，是一个指向结构的指针，不需传递参数时，为NULL。
dwCreationFlags：控制线程创建的标志，可取值如下：
（1）CREATE_SUSPENDED(0x00000004)：创建一个挂起的线程（就绪状态），直到线程被唤醒时才调用
（2）0：表示创建后立即激活。
（3）STACK_SIZE_PARAM_IS_A_RESERVATION(0x00010000)：dwStackSize参数指定初始的保留堆栈的大小，
如果STACK_SIZE_PARAM_IS_A_RESERVATION标志未指定，dwStackSize将会设为系统预留的值
lpThreadId:保存新线程的id
返回值：函数成功，返回线程句柄，否则返回NULL。如果线程创建失败，可通过GetLastError函数获得错误信息。
*/
 
BOOL WINAPI CloseHandle(HANDLE hObject);        //关闭一个被打开的对象句柄
/*可用这个函数关闭创建的线程句柄，如果函数执行成功则返回true(非0),如果失败则返回false(0)，
如果执行失败可调用GetLastError.函数获得错误信息。
*/
</code></pre>
<p>LPVOID 与 std::string类型的转换，需要用char*类型作中介，LPVOID接受buffer数组类型的转换<br>注意CloseHandle只是释放句柄资源，线程的资源释放是其函数执行完毕自动销毁的。</p>
<p>2次的运行结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png" alt="image-20221205152628474"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png"></p>
<p>可见，两个线程是随机切换的，导致如下现象：</p>
<ul>
<li>Print()内的<code>cout &lt;&lt; s</code>和<code>&lt;&lt;endl</code>之间线程被切换，导致没有换行+双重换行。</li>
<li>存在工作线程没执行完，主线程就执行完导致main return，整个进程销毁的情况。</li>
</ul>
<p>改进如下：</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s;
    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread\n&quot;;
    std::string s2 = &quot;Main thread\n&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    CloseHandle(hThread);
    Sleep(100);
    return 0;
&#125;
</code></pre>
<p>使用以下方法解决上述问题</p>
<ul>
<li><p>主线程完成Print后，休眠100s，这个时间足够工作线程完成，Sleep结束后，main进程执行完毕</p>
</li>
<li><p>把换行放到字符串中，使该字符串的完整打印成为不可被中途切换的操作，即原子操作</p>
</li>
</ul>
<p>输出如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526645.png" alt="image-20221205152645608"></p>
<p>如果Print有很多句打印，又不希望中途切换线程，如何做？</p>
<ul>
<li>互斥锁可以实现“大块代码的原子操作”</li>
<li>锁是全局变量，因为主线程main和工作线程Print都能看到全局变量，而看不到对方的局部变量</li>
</ul>
<p>代码如下:</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
HANDLE hMutex = NULL;//互斥锁的句柄

DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;

    for (int i = 0; i &lt; 10; i++)
    &#123;
        WaitForSingleObject(hMutex, INFINITE);//请求锁
        cout &lt;&lt; s &lt;&lt; endl;
        ReleaseMutex(hMutex);//释放锁
    &#125;

    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;

    hMutex = CreateMutex(NULL, FALSE, NULL); //创建互斥锁
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    
    CloseHandle(hThread);
    CloseHandle(hMutex);//销毁互斥锁
    
    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526485.png" alt="image-20221205152654439"><br>关于windows的互斥锁：</p>
<pre><code>互斥量：
        采用互斥对象机制。互斥锁，像一个物件，这个物件只能同时被一个线程持有。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。
        一、创建 创建互斥锁的方法是调用函数CreateMutex： CreateMutex(&amp;sa, bInitialOwner, szName);第一个参数是一个指向SECURITY_ATTRIBUTES结构体的指针，一般的情况下，可以是nullptr。 第二个参数类型为BOOL，表示互斥锁创建出来后是否被当前线程持有。 第三个参数类型为字符串（const TCHAR*），是这个互斥锁的名字，如果是nullptr，则互斥锁是匿名的。 例： HANDLE hMutex = CreateMutex(nullptr, FALSE, nullptr);上面的代码创建了一个匿名的互斥锁，创建出来后，当前线程不持有这个互斥锁。

         二、持有 WaitForSingleObject函数可以让一个线程持有互斥锁。用法： WaitForSingleObject(hMutex, dwTimeout);这个函数的作用比较多。这里只介绍第一个参数为互斥锁句柄时的作用。 它的作用是等待，直到一定时间之后，或者，其他线程均不持有hMutex。第二个参数是等待的时间（单位：毫秒），如果该参数为INFINITE，则该函数会一直等待下去。

        三、释放 用ReleaseMutex函数可以让当前线程“放开”一个互斥锁（不持有它了），以便让其他线程可以持有它。用法 ReleaseMutex(hMutex)

         四、销毁 当程序不再需要互斥锁时，要销毁它。 CloseHandle(hMutex)

         五、命名互斥锁 如果CreateMutex函数的第三个参数传入一个字符串，那么所创建的锁就是命名的。当一个命名的锁被创建出来以后，当前进程和其他进程如果试图创建相同名字的锁，CreateMutex会返回原来那把锁的句柄，并且GetLastError函数会返回ERROR_ALREADY_EXISTS。这个特点可以使一个程序在同一时刻最多运行一个实例
</code></pre>
<h1 id="C-风格多线程"><a href="#C-风格多线程" class="headerlink" title="C++风格多线程"></a>C++风格多线程</h1><p>双线程分别实现计算和打印</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 1;
std::mutex g_mutex;

void thread_func1()
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>几点说明：</p>
<ul>
<li>C++使用&lt; thread &gt;调用线程库</li>
<li>std::thread t(thread_func)创建一个thread对象，传入参数为thread_fun，即线程内执行的函数</li>
<li>t.join()的含义是，线程t执行完毕后，join函数才能返回，主线程才能继续向后执行，宏观上就是，主线程被t线程阻塞在join函数处，这也许就是join的含义，t线程“加入”主线程的队伍，主线程必须原地等待t准备好了（执行完了）才能继续向后走。</li>
<li>由于全局数据g_mydata和打印语句都不是原子操作，要保证完整操作，需要加锁，库定义在&lt; mutex &gt;</li>
<li>为什么要sleep? 注意两个工作线程都while循环操作，sleep是手动使当前线程休眠，操作系统会轮换到其他active状态的线程执行，如果不sleep, 一个线程一直执行再被OS切换，间隔可能很久。&lt; chrono &gt;库用于时间</li>
<li>INT_MAX是C++定义的int类最大值，2^31-1</li>
</ul>
<p>运行结果:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051527091.png" alt="image-20221205152705047"></p>
<h1 id="POSIX-x2F-Linux风格"><a href="#POSIX-x2F-Linux风格" class="headerlink" title="POSIX&#x2F;Linux风格"></a>POSIX&#x2F;Linux风格</h1><p>逻辑同上节，代码如下</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;limits.h&gt; //for INT_MAX

int g_mydata = 1;
pthread_mutex_t m;

void* thread_function1(void* args)
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        pthread_mutex_lock(&amp;m);
        ++g_mydata;
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    &#125;
    
    return NULL;
&#125; 

void* thread_function2(void* args)
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;    
        pthread_mutex_lock(&amp;m);
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl;
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    &#125;
    
    return NULL;
&#125; 

int main()
&#123;
    pthread_mutex_init(&amp;m, NULL);
    
    pthread_t threadIDs[2];    
    pthread_create(&amp;threadIDs[0], NULL, thread_function1, NULL);
    pthread_create(&amp;threadIDs[1], NULL, thread_function2, NULL);
    
    for(int i = 0; i &lt; 2; ++i)
    &#123;
        pthread_join(threadIDs[i], NULL);
    &#125;
    
    pthread_mutex_destroy(&amp;m);

    return 0;
&#125;
</code></pre>
<p>win32应用程序使用pthread，需要配置pthread dll库，下载地址和配置方法：<br><a href="http://sourceware.org/pthreads-win32/">pthreads-win32</a><br><a href="https://www.cnblogs.com/lizhigang/p/7326022.html">VS2013 配置pthread</a></p>
<p>pthread的几个锁，参考：<br><a href="https://blog.csdn.net/guotianqing/article/details/80559865">linux线程互斥量pthread_mutex_t使用简介</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：线程池</title>
    <url>/2021/07/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>线程池的概念和相关示例可以参考：<br><a href="https://blog.csdn.net/MOU_IT/article/details/88712090">C++实现线程池</a><br><a href="https://www.cnblogs.com/ailumiyana/p/10016965.html">基于C++11实现线程池的工作原理</a></p>
<p>本代码相关的C++基础，参考：<br><a href="https://www.cnblogs.com/alantu2018/p/8459250.html">c++拷贝构造函数详解</a><br><a href="https://www.cnblogs.com/jiayayao/archive/2016/12/03/6128877.html">智能指针shared_ptr的用法</a><br><a href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量</a></p>
<p>其他相关文章<br><a href="https://www.jianshu.com/u/9456fecb5f96">jorion&#x2F;c++11 多线程（X）</a><br><a href="https://github.com/jorionwen/threadtest">jorionwen&#x2F;threadtest</a></p>
<h1 id="线程池示例"><a href="#线程池示例" class="headerlink" title="线程池示例"></a>线程池示例</h1><h2 id="调用线程池"><a href="#调用线程池" class="headerlink" title="调用线程池"></a>调用线程池</h2><pre><code>#include &quot;TaskPool.h&quot;
#include &lt;chrono&gt;

int main()
&#123;
    TaskPool threadPool;
    threadPool.init(); //初始化线程对象队列

    Task* task = NULL;
    for (int i = 0; i &lt; 10; ++i)
    &#123;
        task = new Task();
        threadPool.addTask(task); //初始化任务对象队列，调度线程时会取出执行
    &#125;
    
    std::this_thread::sleep_for(std::chrono::seconds(2));

    threadPool.stop(); //等待所有工作线程结束

    return 0; //析构
&#125;
</code></pre>
<h2 id="线程池的方法"><a href="#线程池的方法" class="headerlink" title="线程池的方法"></a>线程池的方法</h2><pre><code>#include &quot;TaskPool.h&quot;

TaskPool::TaskPool() : m_bRunning(false)
&#123;

&#125;

TaskPool::~TaskPool()
&#123;
    removeAllTasks();
&#125;

void TaskPool::init(int threadNum/* = 5*/)
&#123;
    if (threadNum &lt;= 0)
        threadNum = 5;

    m_bRunning = true;

    for (int i = 0; i &lt; threadNum; ++i)
    &#123;
        std::shared_ptr&lt;std::thread&gt; spThread;
        //shared_ptr.reset带参数是初始化，指向new出的thread对象
        //bind绑定了thread对象和其执行函数threadFunc
        spThread.reset(new std::thread(std::bind(&amp;TaskPool::threadFunc, this))); 
        m_threads.push_back(spThread); //thread对象入队
    &#125;
&#125;

void TaskPool::threadFunc() //thread对象唤醒时执行
&#123;
    std::shared_ptr&lt;Task&gt; spTask;
    while (true)
    &#123;
        std::unique_lock&lt;std::mutex&gt; guard(m_mutexList); //RAII实现，作用域结束自动解锁
        while (m_taskList.empty())
        &#123;                 
            if (!m_bRunning)
                break;
            
            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
            m_cv.wait(guard);
        &#125;

        if (!m_bRunning)
            break;

        spTask = m_taskList.front(); //取m_taskList的task对象
        m_taskList.pop_front(); //更新m_taskList

        if (spTask == NULL)
            continue;

        spTask-&gt;doIt(); //执行task
        spTask.reset(); //shared_ptr.reset不带参数，指向对象的计数-1
    &#125;

    std::unique_lock&lt;std::mutex&gt; guard(m_mutexList); //为了打印的原子性，再加锁
    &#123;
        std::cout &lt;&lt; &quot;Exit thread, threadID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    &#125;
    
&#125;

void TaskPool::stop()
&#123;
    m_bRunning = false;
    m_cv.notify_all(); //唤醒所有等待条件变量的线程

    //等待所有线程退出
    for (auto&amp; iter : m_threads)
    &#123;
        if (iter-&gt;joinable())   //该线程是否可join
            iter-&gt;join();       //主线程等待该线程
    &#125;
&#125;

void TaskPool::addTask(Task* task)
&#123;
    std::shared_ptr&lt;Task&gt; spTask;
    spTask.reset(task); //shared_ptr初始化，指向task

    &#123;
        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);       
        //m_taskList.push_back(std::make_shared&lt;Task&gt;(task));
        m_taskList.push_back(spTask); //Task对象入队
        std::cout &lt;&lt; &quot;Add a Task.&quot; &lt;&lt; std::endl;
    &#125;
    
    m_cv.notify_one(); //唤醒随机一个等待条件变量的线程
&#125;

void TaskPool::removeAllTasks()   //析构时调用
&#123;
    &#123;
        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);
        for (auto&amp; iter : m_taskList)
        &#123;
            iter.reset();
        &#125;
        m_taskList.clear();
    &#125;
&#125;
</code></pre>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><pre><code>#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt; //for visual studio build

class Task
&#123;
public:
    virtual void doIt()
    &#123;
        std::cout &lt;&lt; &quot;Do a task...&quot; &lt;&lt; std::endl;
    &#125;

    virtual ~Task()
    &#123;
        //为了看到一个task的销毁，这里刻意补上其析构函数
        std::cout &lt;&lt; &quot;A task destructed...&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

class TaskPool final
&#123;
public:
    TaskPool();
    ~TaskPool();
    TaskPool(const TaskPool&amp; rhs) = delete;     //delete: 禁用某函数（C++11），阻止拷贝和赋值构造，C++98用private
    TaskPool&amp; operator=(const TaskPool&amp; rhs) = delete;

public:
    void init(int threadNum = 5);   //默认初始化
    void stop();

    void addTask(Task* task);
    void removeAllTasks();

private:
    void threadFunc();

private:
    std::list&lt;std::shared_ptr&lt;Task&gt;&gt;            m_taskList;
    std::mutex                                  m_mutexList;
    std::condition_variable                     m_cv;
    bool                                        m_bRunning;
    std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt;   m_threads;
&#125;;
</code></pre>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221205152435385.png" alt="image-20221205152435385"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>如何向Linux内核驱动提交和使用patch</title>
    <url>/2023/03/09/%E5%A6%82%E4%BD%95%E5%90%91Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E6%8F%90%E4%BA%A4%E5%92%8C%E4%BD%BF%E7%94%A8patch/</url>
    <content><![CDATA[<p>本文描述：如何参与到Linux kernel社区中，为Linux kernel提交Patch代码；以Linux子系统MMC&#x2F;SD为例介绍如何使用patch。</p>
<h2 id="Linux-kernel提交代码的基本概念"><a href="#Linux-kernel提交代码的基本概念" class="headerlink" title="Linux kernel提交代码的基本概念"></a>Linux kernel提交代码的基本概念</h2><h3 id="如何参与Linux内核开发"><a href="#如何参与Linux内核开发" class="headerlink" title="如何参与Linux内核开发"></a>如何参与Linux内核开发</h3><p>Linux kernel的官方网站：<a href="https://kernel.org/">kernel.org</a></p>
<p>kernel.org内的中文文档：<a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/process/howto.html">如何参与Linux内核开发</a>, 其中最常用的：</p>
<ul>
<li>内核源码库：<a href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a> 在线查看kernel源码而无需git下载</li>
<li>内核子系统(subsystem)的补丁(patch)列表：<a href="https://patchwork.kernel.org/">https://patchwork.kernel.org/</a> 显示正在发布、评论或修订的patch： </li>
<li>内核邮件列表的存档(archive)：<a href="https://lore.kernel.org/lkml/">https://lore.kernel.org/lkml/</a> 所有正在进行或已存档的patchwork都能在此找到邮件记录：</li>
</ul>
<h3 id="如何提交Patch"><a href="#如何提交Patch" class="headerlink" title="如何提交Patch"></a>如何提交Patch</h3><p>Patch是提交到kernel之前的一个阶段，由kernel subsystem maintainer review后<strong>有机会</strong>进入Linux kernel Mainline。事实上绝大所述patch最终未进入Linux kernel Mainline，仅存档到了邮件列表，在lore&#x2F;patchwork.kernel.org可查看这部分patch的内容和提交过程。</p>
<ul>
<li><p>提交Patch的总体规范参考：</p>
<p><a href="https://docs.kernel.org/translations/zh_CN/process/submitting-patches.html">提交补丁：如何让你的改动进入内核</a></p>
</li>
<li><p>具体地讲如何向kernel提交patch和使用patch（需要详细看）: </p>
<p><a href="https://www.kernel.org/doc/html/v4.11/process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></p>
<p><a href="https://www.kernel.org/doc/html/v4.11/process/applying-patches.html?highlight=applying%20patches%20linux%20kernel">Applying Patches To The Linux Kernel</a></p>
</li>
<li><p>关于patch命令如何使用，参考： </p>
<p><a href="https://www.thegeekstuff.com/2014/12/patch-command-examples/">patch-command-examples</a></p>
<p><a href="https://www.man7.org/linux/man-pages/man1/patch.1.html">patch(1) — Linux manual page</a> </p>
<p><a href="https://blog.csdn.net/dl0914791011/article/details/17299103">Linux下生成patch和打patch</a></p>
</li>
</ul>
<h2 id="Linux-MMC子系统中UHS-II-Patch的演化过程"><a href="#Linux-MMC子系统中UHS-II-Patch的演化过程" class="headerlink" title="Linux MMC子系统中UHS-II Patch的演化过程"></a>Linux MMC子系统中UHS-II Patch的演化过程</h2><h3 id="Linux-MMC子系统的现状"><a href="#Linux-MMC子系统的现状" class="headerlink" title="Linux MMC子系统的现状"></a>Linux MMC子系统的现状</h3><p>MMC子系统主要包含SD card, eMMC card, SDIO几部分，Kernel Mainline的支持情况参考：<a href="https://elinux.org/images/9/91/Clement-sd-mmc-high-speed-support-in-linux-kernel_0.pdf#:~:text=%E2%96%B6New%20speed%20modes%20%28name%20are%20base%20on%20the,the%203.3V%20forDS%28Default%20Speed25MHz%29%20andHS%28High%20Speed%20at%2050MHz%29">SD&#x2F;eMMC: new speed modes and their support in Linux</a></p>
<p>这里只关注SD card, Kernel Mainline在当前时间点（kernel 6.2）：</p>
<ul>
<li>不支持UHS-II (SD 4.0 specification)</li>
<li>SD express(SD 7.0 specification)在Kernel 5.11版本以后是支持的</li>
<li>SD UHS-I (SD 3.0 specification)和更老版本的SD协议则在kernel 3.0就已经支持</li>
</ul>
<h3 id="Linux-MMC-UHS-II-patch的演变"><a href="#Linux-MMC-UHS-II-patch的演变" class="headerlink" title="Linux MMC UHS-II patch的演变"></a>Linux MMC UHS-II patch的演变</h3><p>Linux MMC子系统的维护者可以在<a href="https://patchwork.kernel.org/">patchwork.kernel.org</a>的MMC development的about页面看到：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091635752.png" alt="image-20230309163541697"></p>
<p>在patch页面可以搜索以<a href="https://patchwork.kernel.org/project/linux-mmc/list/?q=UHS-II&archive=both&series=&submitter=&delegate=&state=*">UHS-II为关键字的相关patch</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091621148.png" alt="image-20230309162128061">结果如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091623615.png" alt="image-20230309162327522"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091623615.png"> </p>
<p>具体看一下上面这些UHS-II patch的内容和reviewer的评论：</p>
<p>1.首次提交是<a href="https://patchwork.kernel.org/project/linux-mmc/patch/1419672479-30852-2-git-send-email-yi.y.sun@intel.com/">Intel的yisun</a>, 该patch被MMC维护者Ulf Hansson评论：应该split it up，之后就没有再修改和提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RFC,1/2] mmc: core: support UHS-II in core stack.</span><br><span class="line"></span><br><span class="line">Commit Message</span><br><span class="line"></span><br><span class="line">[yisun1](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=102631)Dec. 27, 2014, 9:27 a.m. UTC</span><br><span class="line"></span><br><span class="line">This patch adds the UHS-II support in core layer. This is a RFC patch for</span><br><span class="line">community review.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Yi Sun &lt;yi.y.sun@intel.com&gt;</span><br><span class="line">---</span><br><span class="line"> drivers/mmc/core/Makefile |    3 +-</span><br><span class="line"> drivers/mmc/core/bus.c    |    5 +-</span><br><span class="line"> drivers/mmc/core/core.c   |   89 ++++-</span><br><span class="line"> drivers/mmc/core/sd.c     |   15 +</span><br><span class="line"> drivers/mmc/core/sd_ops.c |   12 +</span><br><span class="line"> drivers/mmc/core/uhs2.c   |  908 +++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> drivers/mmc/core/uhs2.h   |   26 ++</span><br><span class="line"> include/linux/mmc/core.h  |    6 +</span><br><span class="line"> include/linux/mmc/host.h  |   27 ++</span><br><span class="line"> include/linux/mmc/uhs2.h  |  274 ++++++++++++++</span><br><span class="line"> 10 files changed, 1356 insertions(+), 9 deletions(-)</span><br><span class="line"> create mode 100644 drivers/mmc/core/uhs2.c</span><br><span class="line"> create mode 100644 drivers/mmc/core/uhs2.h</span><br><span class="line"> create mode 100644 include/linux/mmc/uhs2.h</span><br><span class="line"></span><br><span class="line">Comments</span><br><span class="line"></span><br><span class="line">[Ulf Hansson](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=45281)Jan. 21, 2015, 10:31 a.m. UTC | [#1](https://patchwork.kernel.org/comment/12007791/)</span><br><span class="line"></span><br><span class="line">Even if this an RFC, me and likely everybody else just stops from</span><br><span class="line">reviewing this patch by looking at the above change log.</span><br><span class="line"></span><br><span class="line">Is there a way to split it up?</span><br><span class="line"></span><br><span class="line">Kind regards</span><br><span class="line">Uffe</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Genesys的Ben Chuang, Jason Lai, Victor.shih 和linaro 的akashi 在Intel的UHS-II patch上不断提交修改后的UHS-II patch（V3~V6）跟随着Kernel版本不断演化，此patch完整内容可在GitLab查看 <a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755">linux-uhs2-gl9755</a>，在patchwork也可以查看commit内容和review意见：<a href="https://patchwork.kernel.org/project/linux-mmc/patch/20221213090047.3805-7-victor.shih@genesyslogic.com.tw/">V6 patch的第6&#x2F;24提交</a>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[V6,06/24] mmc: core: Support UHS-II card control and access</span><br><span class="line"></span><br><span class="line">Commit Message </span><br><span class="line"></span><br><span class="line">[Victor Shih](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=207469) Dec. 13, 2022, 9 a.m. UTC</span><br><span class="line"></span><br><span class="line">Embed UHS-II access/control functionality into the MMC request</span><br><span class="line">processing flow.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Ulf Hansson &lt;ulf.hansson@linaro.org&gt;</span><br><span class="line">Signed-off-by: Jason Lai &lt;jason.lai@genesyslogic.com.tw&gt;</span><br><span class="line">Signed-off-by: Victor Shih &lt;victor.shih@genesyslogic.com.tw&gt;</span><br><span class="line">---</span><br><span class="line"> drivers/mmc/core/block.c   |    6 +-</span><br><span class="line"> drivers/mmc/core/core.c    |   20 +</span><br><span class="line"> drivers/mmc/core/mmc_ops.c |   25 +-</span><br><span class="line"> drivers/mmc/core/mmc_ops.h |    1 +</span><br><span class="line"> drivers/mmc/core/sd.c      |   11 +-</span><br><span class="line"> drivers/mmc/core/sd.h      |    3 +</span><br><span class="line"> drivers/mmc/core/sd_ops.c  |   13 +</span><br><span class="line"> drivers/mmc/core/sd_ops.h  |    3 +</span><br><span class="line"> drivers/mmc/core/sd_uhs2.c | 1171 +++++++++++++++++++++++++++++++++++-</span><br><span class="line"> 9 files changed, 1206 insertions(+), 47 deletions(-)</span><br><span class="line"></span><br><span class="line">Comments</span><br><span class="line"></span><br><span class="line">[Adrian Hunter](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=31052) Jan. 5, 2023, 9:26 p.m. UTC | [#1](https://patchwork.kernel.org/comment/25148889/)</span><br><span class="line"></span><br><span class="line">&gt; +u32 sd_uhs2_select_voltage(struct mmc_host *host, u32 ocr)</span><br><span class="line">&gt; +&#123;</span><br><span class="line">...</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +	if (host-&gt;caps2 &amp; MMC_CAP2_FULL_PWR_CYCLE) &#123;</span><br><span class="line">&gt; +		bit = ffs(ocr) - 1;</span><br><span class="line">&gt; +		ocr &amp;= 3 &lt;&lt; bit;</span><br><span class="line">&gt; +		/* Power cycle */</span><br><span class="line">&gt; +		err = sd_uhs2_power_off(host);</span><br><span class="line">&gt; +		if (err)</span><br><span class="line">&gt; +			return 0;</span><br><span class="line">&gt; +		err = sd_uhs2_reinit(host);</span><br><span class="line"></span><br><span class="line">This looks circular:</span><br><span class="line"></span><br><span class="line">sd_uhs2_select_voltage</span><br><span class="line">-&gt; sd_uhs2_reinit</span><br><span class="line">   -&gt; sd_uhs2_init_card</span><br><span class="line">      -&gt; sd_uhs2_legacy_init</span><br><span class="line">         -&gt; sd_uhs2_select_voltage</span><br><span class="line"></span><br><span class="line">[Ulf Hansson](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=45281) Feb. 8, 2023, 3:30 p.m. UTC | [#2](https://patchwork.kernel.org/comment/25202573/)</span><br><span class="line"></span><br><span class="line">&gt; diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span><br><span class="line">&gt; index 20da7ed43e6d..d3e8ec43cdd5 100644</span><br><span class="line">&gt; --- a/drivers/mmc/core/block.c</span><br><span class="line">&gt; +++ b/drivers/mmc/core/block.c</span><br><span class="line">&gt; @@ -1596,6 +1596,9 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;         struct request *req = mmc_queue_req_to_req(mqrq);</span><br><span class="line">&gt;         struct mmc_blk_data *md = mq-&gt;blkdata;</span><br><span class="line">&gt;         bool do_rel_wr, do_data_tag;</span><br><span class="line">&gt; +       bool do_multi;</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +       do_multi = (card-&gt;uhs2_state &amp; MMC_UHS2_INITIALIZED) ? true : false;</span><br><span class="line">&gt;</span><br><span class="line">&gt;         mmc_blk_data_prep(mq, mqrq, recovery_mode, &amp;do_rel_wr, &amp;do_data_tag);</span><br><span class="line">&gt;</span><br><span class="line">&gt; @@ -1606,7 +1609,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;                 brq-&gt;cmd.arg &lt;&lt;= 9;</span><br><span class="line">&gt;         brq-&gt;cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;</span><br><span class="line">&gt;</span><br><span class="line">&gt; -       if (brq-&gt;data.blocks &gt; 1 || do_rel_wr) &#123;</span><br><span class="line">&gt; +       if (brq-&gt;data.blocks &gt; 1 || do_rel_wr || do_multi) &#123;</span><br><span class="line"></span><br><span class="line">This looks wrong to me. UHS2 can use single block read/writes too. Right?</span><br><span class="line"></span><br><span class="line">&gt;                 /* SPI multiblock writes terminate using a special</span><br><span class="line">&gt;                  * token, not a STOP_TRANSMISSION request.</span><br><span class="line">&gt;                  */</span><br><span class="line">&gt; @@ -1619,6 +1622,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;                 brq-&gt;mrq.stop = NULL;</span><br><span class="line">&gt;                 readcmd = MMC_READ_SINGLE_BLOCK;</span><br><span class="line">&gt;                 writecmd = MMC_WRITE_BLOCK;</span><br><span class="line">&gt; +               brq-&gt;cmd.uhs2_tmode0_flag = 1;</span><br><span class="line"></span><br><span class="line">As &quot;do_multi&quot; is always set for UHS2, setting this flag here seems to</span><br><span class="line">be wrong/redundant.</span><br><span class="line"></span><br><span class="line">Anyway, if I understand correctly, the flag is intended to be used to</span><br><span class="line">inform the host driver whether the so-called 2L_HD_mode (half-duplex</span><br><span class="line">or full-duplex) should be used for the I/O request or not.</span><br><span class="line"></span><br><span class="line">To fix the above behaviour, I suggest we try to move the entire</span><br><span class="line">control of the flag into mmc_uhs2_prepare_cmd(). We want the flag to</span><br><span class="line">be set for multi block read/writes (CMD18 and CMD25), but only if the</span><br><span class="line">host and card supports the 2L_HD_mode too. According to my earlier</span><br><span class="line">suggestions, we should be able to check that via the bits we set</span><br><span class="line">earlier in the ios-&gt;timing.</span><br><span class="line"></span><br><span class="line">Moreover, by making mmc_uhs2_prepare_cmd() responsible for setting the</span><br><span class="line">flag, I think we can also move the definition of the flag into the</span><br><span class="line">struct uhs2_command. While at it, I suggest we also rename the flag</span><br><span class="line">into &quot;tmode_half_duplex&quot;, to better describe its purpose, which also</span><br><span class="line">means the interpretation of the flag becomes inverted.</span><br></pre></td></tr></table></figure>

<h2 id="详解Patch的使用"><a href="#详解Patch的使用" class="headerlink" title="详解Patch的使用"></a>详解Patch的使用</h2><h3 id="Patch与git-diff"><a href="#Patch与git-diff" class="headerlink" title="Patch与git diff"></a>Patch与git diff</h3><p>Patch文件的内容实际是<code>git diff</code>命令的输出，git diff的输出定义为.diff文件或.patch文件，即可作为patch使用。打patch实际上就是按diff规则，解析diff&#x2F;patch文件，去改变本地的代码树和内容。</p>
<p>git diff说明文档参考 <a href="https://git-scm.com/docs/git-diff">git-diff</a>，比较常用的是使用<code>git diff [&lt;path&gt;…]</code>输出某个路径&#x2F;文件的差异；如果path为空，则输出当前git仓库所有文件的差异。</p>
<p>如下示例：在drivers&#x2F;mmc&#x2F;core&#x2F;block.c增加修改了<code>//AAAAAAAAA</code>，在drivers&#x2F;mmc&#x2F;core&#x2F;block.h增加了<code>//BBBBBBBBB</code>，以下详细说明git diff 输出的含义：</p>
<ul>
<li>diff –git a&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c b&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c：用git diff命令，比较a和b版本的drivers&#x2F;mmc&#x2F;core&#x2F;block.c，a和b是diff用来区分同名文件的标识，不是实际路径。</li>
<li>index 7fa83e5..8963e57：这个diff如果被commit提交，commit-id将是index值7fa83e5..8963e57。</li>
<li>— a&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c 和+++ b&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c 同时存在：表示是对已存在的block.c文件有内容修改；与之相对的是某个文件只有+++或—，表示是新增文件文件，或者是删除了文件。</li>
<li>@@ -1829,6 +1829,8 @@ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)：该修改代码所在的行数以及所在的函数名。</li>
<li>+&#x2F;&#x2F;AAAAAAAAA：具体的修改内容，+是新增，-是删除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span><br><span class="line">index 7fa83e5..8963e57 100644</span><br><span class="line">--- a/drivers/mmc/core/block.c</span><br><span class="line">+++ b/drivers/mmc/core/block.c</span><br><span class="line">@@ -1829,6 +1829,8 @@ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)</span><br><span class="line">        u32 blocks;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">+//AAAAAAAAA</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">diff --git a/drivers/mmc/core/block.h b/drivers/mmc/core/block.h</span><br><span class="line">index 31153f6..5501895 100644</span><br><span class="line">--- a/drivers/mmc/core/block.h</span><br><span class="line">+++ b/drivers/mmc/core/block.h</span><br><span class="line">@@ -17,4 +17,6 @@ struct work_struct;</span><br><span class="line"></span><br><span class="line"> void mmc_blk_mq_complete_work(struct work_struct *work);</span><br><span class="line"></span><br><span class="line">+//BBBBBBBBB</span><br><span class="line"></span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure>

<p>一般提交给Kernel社区的patch需要按功能和文件拆分成多个patch提交，也就是说应该对某个文件或者路径git diff, 而不建议直接对所有文件git diff。例如以上示例可以分为两个diff：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff drivers/mmc/core/block.c</span><br><span class="line"></span><br><span class="line">git diff drivers/mmc/core/block.h</span><br></pre></td></tr></table></figure>

<h3 id="Patch与kernel版本"><a href="#Patch与kernel版本" class="headerlink" title="Patch与kernel版本"></a>Patch与kernel版本</h3><p>为了正确打一个补丁，你需要知道这个补丁是从哪个基础代码版本(base)产生的，以及这个补丁会使源码树升级成哪个版本。</p>
<h4 id="用于Kernel升级的官方patch"><a href="#用于Kernel升级的官方patch" class="headerlink" title="用于Kernel升级的官方patch"></a>用于Kernel升级的官方patch</h4><p>在kernel.org可以看到有很多Kernel版本之间有patch可以用于升级kernel，例如从kernel 4.19.275升级到5.4.234，可以下载并安装patch-5.4.234.xz</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091942357.png" alt="image-20230309194230288"></p>
<h4 id="patchwork社区的第三方patch"><a href="#patchwork社区的第三方patch" class="headerlink" title="patchwork社区的第三方patch"></a>patchwork社区的第三方patch</h4><p>可以下载diff或者series去获取patch文件，根据patch提交时间和代码上下文大致估计当时的Kernel版本</p>
<ul>
<li>diff: 当前patch的diff, 由于一个大patch可能被拆分为多个小patch，此文件通常为某个小patch</li>
<li>mbox: 在diff基础上包含了邮件信息（MIME信息）</li>
<li>series: 整个功能的所有patch系列的mbox合并内容，包括邮件信息（MIME信息）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091945285.png" alt="image-20230309194559245"></p>
<p>Patch命令一般使用以上的diff文件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c</span><br><span class="line">index 86d2711..6565754 100644</span><br><span class="line">--- a/drivers/mmc/core/bus.c</span><br><span class="line">+++ b/drivers/mmc/core/bus.c</span><br><span class="line">@@ -308,8 +308,9 @@ int mmc_add_card(struct mmc_card *card)</span><br><span class="line"> 	&#125; else &#123;</span><br><span class="line"> 		pr_info(&quot;%s: new %s%s%s%s%s card at address %04x\n&quot;,</span><br><span class="line"> 			mmc_hostname(card-&gt;host),</span><br><span class="line">-			mmc_card_uhs(card) ? &quot;ultra high speed &quot; :</span><br><span class="line">-			(mmc_card_hs(card) ? &quot;high speed &quot; : &quot;&quot;),</span><br><span class="line">+			mmc_card_uhs2(card) ? &quot;ultra high speed 2 &quot; :</span><br><span class="line">+			(mmc_card_uhs(card) ? &quot;ultra high speed 1&quot; :</span><br><span class="line">+			(mmc_card_hs(card) ? &quot;high speed &quot; : &quot;&quot;)),</span><br><span class="line"> 			mmc_card_hs400(card) ? &quot;HS400 &quot; :</span><br><span class="line"> 			(mmc_card_hs200(card) ? &quot;HS200 &quot; : &quot;&quot;),</span><br><span class="line"> 			mmc_card_ddr52(card) ? &quot;DDR &quot; : &quot;&quot;,</span><br></pre></td></tr></table></figure>

<p>对于一个大功能的多个patch series，需要分别下载各diff文件； 或者一次下载series后手动删除所有MIME信息。</p>
<h4 id="如何寻找Patch对应的kernel版本"><a href="#如何寻找Patch对应的kernel版本" class="headerlink" title="如何寻找Patch对应的kernel版本"></a>如何寻找Patch对应的kernel版本</h4><p>如果Patch和kernel版本不匹配，patch命令无法合并patch到此kernel中，导致patch失败，因此打patch首先要确定其对应哪个kernel版本。</p>
<p>（1）如果patch commit是已提交到kernel的官方patch，则可以根据commit-id查找包含此commit的kernel版本，参考：<a href="https://lwn.net/Articles/392293/">Finding a patch’s kernel version with git</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git describe --contains &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>

<p>（2）大多数patch是没提交到kernel的第三方patch，因此patch中的index在kernel是找不到的，所以只能通过提交邮件的信息确定适用的kernel版本。</p>
<p>以前文提到的 <a href="https://lore.kernel.org/all/20201106022726.19831-2-takahiro.akashi@linaro.org/T/#u">RFC PATCH v3.1 16&#x2F;27</a>为例，patch是在提交时间点的kernel master版本或tag版本上测试的。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[auto build test WARNING on linus/master]</span><br><span class="line">[also build test WARNING on v5.10-rc2]</span><br><span class="line">[cannot apply to v3.1 next-20201105]</span><br><span class="line">[If your patch is applied to the wrong git tree, kindly drop us a note</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另外一个示例：提交者在提交信息中写了基于哪个kernel版本：<a href="https://lore.kernel.org/all/20221213090047.3805-24-victor.shih@genesyslogic.com.tw/T/#u">Add support UHS-II for GL9755</a></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes in v6 (Dec. 12, 2022)</span><br><span class="line">* rebased to the linux-kernel-v6.1.0-rc8 in Ulf Hansson next branch.</span><br><span class="line"></span><br><span class="line">Changes in v5 (Oct. 19, 2022)</span><br><span class="line">* rebased to the linux-kernel-v6.1-rc1 in Ulf Hansson next branch.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果一个第三方patch没有任何kernel版本的信息，只能通过提交时间来尝试kernel，一般情况下不建议这种尝试，因为提交者使用的可能是当时最新的kernel, 也可能是一两个月前的kernel, 中间可能有很多-rc版本。</p>
<p>下面以<a href="https://lore.kernel.org/all/525EAED47491124EB5123A51BD2FC79101A30EE2@SHSMSX101.ccr.corp.intel.com/">RFC 0&#x2F;2 mmc: UHS-II implementation</a>为例，尝试寻找此patch可应用的kernel版本，此patch提交信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* RE: [RFC 0/2] mmc: UHS-II implementation</span><br><span class="line">  2014-12-27  9:27 [RFC 0/2] mmc: UHS-II implementation Yi Sun</span><br><span class="line">  2014-12-27  9:27 ` [RFC 1/2] mmc: core: support UHS-II in core stack Yi Sun</span><br><span class="line">  2014-12-27  9:27 ` [RFC 2/2] mmc: sdhci: support UHS-II in SDHCI host Yi Sun</span><br></pre></td></tr></table></figure>

<p>（1）首先在linux kernel git tag时间记录找到接近此patch提交时间的kernel版本：</p>
<p>在<a href="https://github.com/torvalds/linux">linux kernel github</a> 下拉tag列表，找接近patch申请时间的kernel release版本，可见kernel version &lt; 4.0是此patch可能适用的版本</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131133722.png" alt="image-20230313113324650"></p>
<p>（2）patch内容的函数名和上下文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@ -248,6 +252,12 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)</span><br><span class="line"> 			mrq-&gt;stop-&gt;mrq = mrq;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">+</span><br><span class="line">+	if (host-&gt;flags &amp; MMC_UHS2_SUPPORT &amp;&amp;</span><br><span class="line">+	    host-&gt;flags &amp; MMC_UHS2_INITIALIZED)</span><br><span class="line">+		if (mrq-&gt;cmd-&gt;uhs2_cmd == NULL)</span><br><span class="line">+			uhs2_prepare_sd_cmd(host, mrq);</span><br><span class="line">+</span><br><span class="line"> 	mmc_host_clk_hold(host);</span><br><span class="line"> 	led_trigger_event(host-&gt;led, LED_FULL);</span><br><span class="line"> 	host-&gt;ops-&gt;request(host, mrq);</span><br></pre></td></tr></table></figure>

<p>（3）在 <a href="https://elixir.bootlin.com/linux/v4.9/source/drivers/mmc/core/core.c#L264">bootlin</a> 找到kernel的同函数并对比上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mrq-&gt;data) &#123;</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">	mrq-&gt;cmd-&gt;data = mrq-&gt;data;</span><br><span class="line">	mrq-&gt;data-&gt;error = 0;</span><br><span class="line">	mrq-&gt;data-&gt;mrq = mrq;</span><br><span class="line">	if (mrq-&gt;stop) &#123;</span><br><span class="line">		mrq-&gt;data-&gt;stop = mrq-&gt;stop;</span><br><span class="line">		mrq-&gt;stop-&gt;error = 0;</span><br><span class="line">		mrq-&gt;stop-&gt;mrq = mrq;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///// 此处为patch添加处</span><br><span class="line"></span><br><span class="line">led_trigger_event(host-&gt;led, LED_FULL);</span><br><span class="line">__mmc_start_request(host, mrq);</span><br><span class="line"></span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<p>在stable kernel版本上尝试此patch (跳过-rc版本)，首先找kernel tag早于此patch邮件的时间，尝试了kernel 3.18, 3.17都有patch fail，如下可见patch和kernel有少量代码offset能自动匹配，但是有些差异patch搞不定，例如有merge代码冲突会导致对应的Hunk # FAILED，hunk是patch中的diff –git的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~/linux-4.9$ patch -p1 &lt; RFC-1-2-mmc-core-support-UHS-II-in-core-stack..diff </span><br><span class="line">patching file drivers/mmc/core/Makefile</span><br><span class="line">Hunk #1 FAILED at 7.</span><br><span class="line">1 out of 1 hunk FAILED -- saving rejects to file drivers/mmc/core/Makefile.rej</span><br><span class="line">patching file drivers/mmc/core/bus.c</span><br><span class="line">Hunk #1 succeeded at 334 with fuzz 2 (offset 26 lines).</span><br><span class="line">patching file drivers/mmc/core/core.c</span><br><span class="line">Hunk #2 FAILED at 36.</span><br><span class="line">Hunk #3 succeeded at 63 with fuzz 2 (offset 6 lines).</span><br><span class="line">Hunk #4 FAILED at 250.</span><br><span class="line">Hunk #5 succeeded at 503 (offset 116 lines).</span><br><span class="line">Hunk #6 succeeded at 518 (offset 116 lines).</span><br><span class="line">Hunk #7 FAILED at 425.</span><br><span class="line">...</span><br><span class="line">6 out of 17 hunks FAILED -- saving rejects to file drivers/mmc/core/core.c.rej</span><br></pre></td></tr></table></figure>

<p>在kernel 3.18打此patch，只有一个fail，可以根据此fail进一步定位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hunk #13 FAILED at 2339.</span><br><span class="line">1 out of 17 hunks FAILED -- saving rejects to file drivers/mmc/core/core.c.rej</span><br></pre></td></tr></table></figure>

<p>core.c.rej 内容如下，注意这里的行号是已经经过patch操作被偏移的代码的行号，实际行号应该去patch原文件查看此hunk的行号，这里只看是什么函数名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- drivers/mmc/core/core.c</span><br><span class="line">+++ drivers/mmc/core/core.c</span><br><span class="line">@@ -2339,7 +2391,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Set initial state and call mmc_set_ios */</span><br><span class="line">-       mmc_set_initial_state(host);</span><br><span class="line">+       /* TODO: need verify this for UHS2. */</span><br><span class="line">+       if (!host-&gt;flags &amp; MMC_UHS2_SUPPORT)</span><br><span class="line">+               mmc_set_initial_state(host);</span><br><span class="line"></span><br><span class="line">        mmc_host_clk_release(host);</span><br></pre></td></tr></table></figure>

<p>patch原文件drivers&#x2F;mmc&#x2F;core&#x2F;core.c搜索函数名对应的hunk内容，得知代码行数是2287：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@ -2287,7 +2339,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	/* Set initial state and call mmc_set_ios */</span><br><span class="line">-	mmc_set_initial_state(host);</span><br><span class="line">+	/* TODO: need verify this for UHS2. */</span><br><span class="line">+	if (!host-&gt;flags &amp; MMC_UHS2_SUPPORT)</span><br><span class="line">+		mmc_set_initial_state(host);</span><br><span class="line"> </span><br><span class="line"> 	mmc_host_clk_release(host);</span><br></pre></td></tr></table></figure>

<p>去bootlin.com查找<a href="https://elixir.bootlin.com/linux/v3.18/source/drivers/mmc/core/core.c">kernel 3.18的core.c代码</a>如下(直接搜索drivers&#x2F;mmc&#x2F;core&#x2F;core.c定位到文件，然后在core.c文件ctrl+F查找行数2287)，2287行对不上当然patch fail。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131921412.png" alt="image-20230313192134365"></p>
<p>根据patch提交时间，其大概率是使用3.18~4.0之间的kernel版本，因此搜寻3.18以后，且符合上面fail点的代码，首先就是<a href="https://elixir.bootlin.com/linux/v3.19/source/drivers/mmc/core/core.c">3.19版本</a>对比代码如下，可见2287开始的几行和patch完全对应：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131917802.png" alt="image-20230313191733743"></p>
<p>打patch也全部通过未报错，所以3.19是此patch可适配的kernel版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~/linux-3.19$ patch -p1 &lt; RFC-1-2-mmc-core-support-UHS-II-in-core-stack..diff</span><br><span class="line">patching file drivers/mmc/core/Makefile</span><br><span class="line">patching file drivers/mmc/core/bus.c</span><br><span class="line">patching file drivers/mmc/core/core.c</span><br><span class="line">patching file drivers/mmc/core/sd.c</span><br><span class="line">patching file drivers/mmc/core/sd_ops.c</span><br><span class="line">patching file drivers/mmc/core/uhs2.c</span><br><span class="line">patching file drivers/mmc/core/uhs2.h</span><br><span class="line">patching file include/linux/mmc/core.h</span><br><span class="line">patching file include/linux/mmc/host.h</span><br><span class="line">patching file include/linux/mmc/uhs2.h</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何看懂UML类图</title>
    <url>/2020/12/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。<br>统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。<br>UML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图<br>本文介绍开发中常用的类图</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。<br>首先讲解关系, 先来看一个例子：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148263.png" alt="image-20221205114810203"></p>
<p>分析一下上面的图, 首先从动物开始<br>动物是一个类 动物依赖氧气和水<br>然后鸟继承了动物，所以鸟的父类是动物 所以鸟是属于动物<br>然后鸟和翅膀是组合关系 一只鸟有两个翅膀<br>大雁鸭子和企鹅都是鸟所以继承了鸟类<br>大雁会有大雁群，大雁群是由大雁组成所以是聚合关系<br>企鹅和气候是关联关系因为企鹅需要依赖气候<br>然后再看大雁 大雁会飞翔 所以就实现了飞翔接口<br>唐老鸭是属于鸭子的 所以唐老鸭继承了鸭子这个类<br>上图是借鉴了大话设计模式里面的图。下面具体介绍各个符号的作用</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类一般是用三层矩形框表示，第一层表示类的名称，第二层表示的是字段和属性，第三层则是类的方法。第一层中，如果是抽象类，需用斜体显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148740.png" alt="image-20221205114819689"></p>
<h2 id="类符号"><a href="#类符号" class="headerlink" title="类符号"></a>类符号</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148030.png" alt="image-20221205114830981"><br>看上面的学生类里面有五个属性和两个方法</p>
<pre><code>+号表示公共的 public
-表示 私有的 private
#表示protected
</code></pre>
<p>带下划线表示静态属性，一般表示方法: +属性:类型。<br>括号内表示参数，后面是返回类型, 没有表示无返回值</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包(Package)： 是一种常规用途的组合机制。在UML中用一个Tab框表示，Tab里写上包的名称，框里则用来放一些其他子元素，比如类，子包等等。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148985.png" alt="image-20221205114837947"></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口(interface)：接口包含操作但不包含属性，且它没有对外界可见的关联<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148968.png" alt="image-20221205114843929"></p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>依赖(Dependency) 表示的是类之间的调用关系。UML中用带箭头的虚线表示依赖关系，而箭头所指的则是被依赖的类。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148704.png" alt="image-20221205114849672"></p>
<h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>泛化(Generalization)： 表示的是类之间的继承关系，注意是子类指向父类。UML中用带空心三角箭头的实线表示泛化关系，箭头指向的是一般个体。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148143.png" alt="image-20221205114855112"></p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联(Association) 表示的是类与类之间存在某种特定的对应关系。UML中用双向带箭头的虚线表示关联关系，箭头两端为相互关联的两个类<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051149187.png" alt="image-20221205114902153"></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合(Aggregation)： 是关联关系的一种特例，表示的是整体与部分之间的关系，部分不能离开整体单独存在。UML中用空心菱形头的实线表示聚合关系，菱形头指向整体<br><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221205114909206.png" alt="image-20221205114909206"></p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合(Composition)： 是聚合的一种特殊形式，表示的是类之间更强的组合关系。UML中用实心菱形头的实线来表示组合，菱形头指向整体。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051149567.png" alt="image-20221205114949528"></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目学习：Tinyhttpd</title>
    <url>/2020/12/03/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9ATinyhttpd/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Tinyhttpd是一个C + CGI实现的简单http server，适合初学者学习。代码许可协议：GPL，copyright 1999, by J. David Blackstone.<br>本文对Tinyhttp稍作注释和改动，验证并理解其主要流程, 本文源码：<br>Github: <a href="https://github.com/cursorhu/myTinyHttpd">cursorhu&#x2F;myTinyHttpd</a></p>
<h1 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2.背景知识"></a>2.背景知识</h1><h2 id="TCP套接字的通信流程"><a href="#TCP套接字的通信流程" class="headerlink" title="TCP套接字的通信流程"></a>TCP套接字的通信流程</h2><p>网络协议栈的核心是TCP&#x2F;IP协议，HTTP本质上是对TCP的应用层封装，要理解HTTP服务程序，首先要理解TCP层的通信机制，在Linux环境中TCP采用socket接口通信，流程如下图<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121451104.png" alt="image-20221212145149039"><br>关于Linux网络编程相关知识，参考《Linux网络编程-第二版》<br>TinyHttpd实现服务端的流程。</p>
<h2 id="HTTP的请求方式"><a href="#HTTP的请求方式" class="headerlink" title="HTTP的请求方式"></a>HTTP的请求方式</h2><p>参考：<br><a href="https://www.cnblogs.com/williamjie/p/9099940.html">浅谈HTTP中GET、POST用法以及它们的区别</a><br><a href="https://blog.csdn.net/eson_15/article/details/88083280">99%的人都理解错了HTTP中GET与POST的区别</a><br>理解以下几点：</p>
<ul>
<li>GET，POST，PUT，DELETE是http层对数据操作的封装，底层本质还是TCP的read&#x2F;write过程</li>
<li>http server处理请求的基本流程：读取-拆解-处理-封装-回写，拆解和封装的就是http层的请求和数据格式，处理是指TCP层能理解的数据。就像快递退货时的流程：取件-拆包-查看-装包-寄出</li>
</ul>
<h2 id="CGI的时代背景"><a href="#CGI的时代背景" class="headerlink" title="CGI的时代背景"></a>CGI的时代背景</h2><p>参考：<a href="https://www.jianshu.com/p/c4dc22699a42">CGI是什么</a></p>
<ul>
<li>CGI是2000年的web接口标准，后端部署perl-CGI脚本，连接server处理程序和web客户端</li>
<li>CGI目前还应用在嵌入式web等C-based环境，这个和当前web主流的Java Spring + Vue(JS)是完全不同的应用场景，所以CGI技术本身并无过时一说。</li>
</ul>
<h1 id="3-调试httpd"><a href="#3-调试httpd" class="headerlink" title="3.调试httpd"></a>3.调试httpd</h1><h2 id="部署httpd服务"><a href="#部署httpd服务" class="headerlink" title="部署httpd服务"></a>部署httpd服务</h2><p>Aliyun CentOS环境，运行如下deploy.sh：</p>
<pre><code>#!/bin/bash
chmod +x htdocs/*.cgi
yum install -y perl perl-CGI
make clean &amp;&amp; make
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452836.png" alt="image-20221212145206784"></p>
<h2 id="浏览器访问httpd"><a href="#浏览器访问httpd" class="headerlink" title="浏览器访问httpd"></a>浏览器访问httpd</h2><p>服务端直接运行httpd，会分配随机可用端口，本地chrome浏览器访问该服务所在的ip:端口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452831.png" alt="image-20221212145218796"></p>
<p>这里ip即为httpd所在主机ip，默认访问资源是htdocs&#x2F;index.html，原因可见httpd.c的http Get请求解析url的处理<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452854.png" alt="image-20221212145227807"></p>
<p>index.h调用color.cgi脚本：</p>
<pre><code>&lt;HTML&gt;
&lt;TITLE&gt;Index&lt;/TITLE&gt;
&lt;BODY&gt;
&lt;P&gt;Welcome to J. David&#39;s webserver.
&lt;H1&gt;CGI demo: get color
&lt;FORM ACTION=&quot;color.cgi&quot; METHOD=&quot;POST&quot;&gt;
Enter color(example: red, pink, blue): &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;color&quot;&gt;
&lt;INPUT TYPE=&quot;submit&quot;&gt;
&lt;/FORM&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p>color.cgi内容：</p>
<pre><code>#!/usr/bin/perl -Tw

use strict;
use CGI;

my($cgi) = new CGI;

print $cgi-&gt;header;
my($color) = &quot;blue&quot;;
$color = $cgi-&gt;param(&#39;color&#39;) if defined $cgi-&gt;param(&#39;color&#39;);

print $cgi-&gt;start_html(-title =&gt; uc($color),
                       -BGCOLOR =&gt; $color); 
print $cgi-&gt;h1(&quot;This is $color&quot;);
print $cgi-&gt;end_html;
</code></pre>
<p>干了两件事：</p>
<ul>
<li>html页面的bgcolor参数设置成了用户输入的color变量字符串</li>
<li>显示字符串：This is $color</li>
</ul>
<p>输入“red”, 浏览器显示效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452042.png" alt="image-20221212145241997"></p>
<p>F12打开浏览器调试窗口，可见：</p>
<ul>
<li>访问资源为color.cgi</li>
<li>查看http head内容，浏览器客户端的请求是POST，类型是text文本，表单数据(Form data):color的值是red</li>
<li>查看http response内容，即httpd返回的内容。返回了html文本，即浏览器可见的红色页面</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452614.png" alt="image-20221212145258548"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121455408.png" alt="image-20221212145533364"></p>
<p>现在理解以下整个流程：</p>
<ul>
<li>服务器上httpd先运行，处于监听(listen)客户端请求的状态</li>
<li>本地浏览器输入服务器ip：端口，访问httpd，发送的http请求类型是GET,即获取文本</li>
<li>httpd收到请求，在处理过程中调用cgi脚本，生成response的内容</li>
<li>httpd打包内容成http层的格式(head+body+…)，返回浏览器客户端</li>
<li>浏览器客户端解析html文本并显示成可见的页面。</li>
</ul>
<p>再看另外一个获取时间的功能：<br>浏览器输入<code>ip:port/date.html</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453695.png" alt="image-20221212145316645"><br>访问的资源是date.cgi，返回了显示当前时间的页面<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453222.png" alt="image-20221212145338163"><br>看下http请求和响应<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453850.png" alt="image-20221212145345780"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453273.png" alt="image-20221212145353230"></p>
<p>date.cgi的实现：shell直接调用linux <code>date</code>命令</p>
<pre><code>#!/bin/bash
echo &quot;Content-Type: text/html&quot;
echo
echo &quot;&lt;HTML&gt;&lt;BODY&gt;&quot;
echo &quot;&lt;CENTER&gt;Today is:&lt;/CENTER&gt;&quot;
echo &quot;&lt;CENTER&gt;&lt;B&gt;&quot;
date
echo &quot;&lt;/B&gt;&lt;/CENTER&gt;&quot;
echo &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;
</code></pre>
<h2 id="TCP-socket访问httpd-测试"><a href="#TCP-socket访问httpd-测试" class="headerlink" title="TCP socket访问httpd(测试)"></a>TCP socket访问httpd(测试)</h2><p>client.c直接使用socket接口访问httpd，这是个测试功能，因此用编译参数控制了该功能, <code>make test_sock=y</code>编译该版本的httpd<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454984.png" alt="image-20221212145401934"><br>client和httpd在同一主机，直接访问回环地址127.0.0.1，可见httpd返回了client发送的字符’A’</p>
<h1 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h1><h2 id="1-httpd的处理http请求的主要流程"><a href="#1-httpd的处理http请求的主要流程" class="headerlink" title="(1) httpd的处理http请求的主要流程"></a>(1) httpd的处理http请求的主要流程</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454501.png" alt="image-20221212145417431"></p>
<ol>
<li>服务器启动，在指定端口或随机选取端口绑定 httpd 服务</li>
<li>收到一个 HTTP 请求时（其实就是 listen 的端口 accpet 的时候），派生一个线程运行 accept_request 函数</li>
<li>取出 HTTP 请求中的 method (GET 或 POST) 和 url,。对于 GET 方法，如果有携带参数，则 query_string 指针指向 url 中 ？ 后面的 GET 参数</li>
<li>格式化 url 到 path 数组，表示浏览器请求的服务器文件路径，在 tinyhttpd 中服务器文件是在 htdocs 文件夹下。当 url 以 &#x2F; 结尾，或 url 是个目录，则默认在 path 中加上 index.html，表示访问主页</li>
<li>如果文件路径合法，对于无参数的 GET 请求，直接输出服务器文件到浏览器，即用 HTTP 格式写到套接字上，然后跳到（10）。其他情况（带参数 GET，POST 方式，url 为可执行文件），则调用 excute_cgi 函数执行 cgi 脚本</li>
<li>读取整个 HTTP 请求并丢弃，如果是 POST 则找出 Content-Length. 把 HTTP 200 状态码写到套接字</li>
<li>建立两个管道，cgi_input 和 cgi_output, 并 fork 一个进程</li>
<li>在子进程中，把 STDOUT 重定向到 cgi_outputt 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端，设置 request_method 的环境变量，GET 的话设置 query_string 的环境变量，POST 的话设置 content_length 的环境变量，这些环境变量都是为了给 cgi 脚本调用，接着用 execl 运行 cgi 程序</li>
<li>在父进程中，关闭 cgi_input 的读取端 和 cgi_output 的写入端，如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT。接着关闭所有管道，等待子进程结束。管道状态参考下图。</li>
<li>关闭与浏览器的连接，完成了一次 HTTP 请求与回应， HTTP是无连接的。</li>
</ol>
<p>管道初始状态：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454140.png" alt="image-20221212145427091"><br>管道最终状态：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454591.png" alt="image-20221212145432542"></p>
<p>主要函数：</p>
<ul>
<li>startup: 初始化httpd服务，包括建立服务端的套接字，绑定端口，进行监听等</li>
<li>accept_request: 处理从套接字上监听到的一个 HTTP 请求，是服务器处理请求的主流程</li>
<li>execute_cgi: 运行cgi程序的处理，对应POST请求</li>
<li>sever_file: 调用cat把服务器文件返回给浏览器，对应GET请求</li>
</ul>
<p>辅助功能函数：</p>
<ul>
<li>get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束</li>
<li>unimplemented: 返回给浏览器表明收到的HTTP请求所用的method不支持，httpd只支持GET和POST</li>
<li>headers: 把HTTP响应的头部写到套接字</li>
<li>cat: 读取服务器上的指定文件写到socket套接字</li>
</ul>
<h2 id="2-httpd处理client的socket请求"><a href="#2-httpd处理client的socket请求" class="headerlink" title="(2)httpd处理client的socket请求"></a>(2)httpd处理client的socket请求</h2><p>参考TCP套接字流程，注意一点，server端回写数据后，要close掉，client才能正常close。<br>编译选项的实现讲一下：<br>Makefile根据输入参数，定义宏, 如果编译输入带参<code>make test_sock=y</code>，则定义宏TEST_SOCK，等价于在源码<code>#define TEST_SOCK</code></p>
<pre><code>#用编译选项定义宏
ifeq ($(test_sock), y)
CFLAGS+= -D TEST_SOCK
endif
</code></pre>
<p>httpd.c对宏的处理：</p>
<pre><code>#ifdef TEST_SOCK
void test_sock(int);
#else
#define test_sock(...)  do&#123;&#125;while(0)
#endif
</code></pre>
<p>这里如果没定义TEST_SOCK，直接把test_sock函数声明成do{}while(0)形式，这种控制在linux kernel源码中很常见，好处是不需要在调用处加宏控制，若TEST_SOCK未定义，调用test_sock()等价于空语句。<code>...</code>代表所有入参</p>
<p>扩展：httpd能否同时支持浏览器和client程序访问?<br>一个socket描述符只能对应一个客户端，如果server想要一对多的IO复用，需要select-poll机制，参考：<br><a href="https://www.cnblogs.com/feily/articles/14030297.html">IO多路复用之select、poll、epoll</a><br><a href="https://blog.csdn.net/zouli415/article/details/79696766">linux下socket编程实现一个服务器连接多个客户端</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/nengm1988/p/7816618.html">Tinyhttpd精读解析</a><br><a href="https://github.com/EZLippi/Tinyhttpd">EZLippi&#x2F;Tinyhttpd</a></p>
]]></content>
      <categories>
        <category>open source</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派笔记：使用ALSA+A2DP+PulseAudio自制蓝牙音箱</title>
    <url>/2021/09/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8ALSA-A2DP-PulseAudio%E8%87%AA%E5%88%B6%E8%93%9D%E7%89%99%E9%9F%B3%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>树莓派4B自带蓝牙和Wifi, 无需外接 USB dongle；<br>蓝牙最常见的应用是近距离传输数据，比如蓝牙传文件，蓝牙音箱等。正好家里有个普通的usb供电的便携音箱；</p>
<p>本文用树莓派蓝牙+普通音箱，实现简单的蓝牙音箱。</p>
<p>首先需要了解Linux音频系统的整体框架：<br><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221208194352559.png" alt="image-20221208194352559"></p>
<p>大致分为三个部分：</p>
<ul>
<li>kernel&#x2F;driver层的ALSA驱动框架</li>
<li>蓝牙音频协议栈：A2DP, 这是使蓝牙具有传输音频流能力的基石; Linux官方的bluez包实现了A2DP</li>
<li>音频应用层, Linux最常用的音频服务器是Pulse Audio</li>
</ul>
<p>怎样理解这三层：可以类比Linux网络层：<br>ALSA 类似网络驱动框架<br>A2DP 类似TCP&#x2F;UDP层<br>PulseAudio 类似HTTP层的服务器，类比Apache</p>
<p>而蓝牙连接类似http连接和会话；<br>声卡(输入、输出)类似网卡(Ethernet和wifi)，音频设备(音箱，麦克风)类似具体的网口设备</p>
<p>深入了解 ALSA 音频驱动和 A2DP 蓝牙音频协议，参考：<br><a href="https://www.alsa-project.org/wiki/Main_Page">Advanced Linux Sound Architecture (ALSA) project homepage</a><br><a href="http://www.dslreports.com/r0/download/2285126~a70eb148e16b921dc323dbb977d4b4b1/A2DP_SPEC.pdf">A2DP Spec</a></p>
<p>本文的环境<br>树莓派4B, 系统: ubuntu-server raspberry pi版本<br>音箱：usb供电，音频线<br>安卓手机：用于配对树莓派的蓝牙音频服务</p>
<p>连接示意图</p>
<pre><code> Audio source (i.e. smartphone) 
                |
                v
 (((  Wireless Bluetooth Channel  )))
                |
                v
  Raspberry PI (with A2DP service)
                |
                v
         Audio Interface
                |
                v
             Speakers
</code></pre>
<h1 id="使用alsa-utils测试音频设备"><a href="#使用alsa-utils测试音频设备" class="headerlink" title="使用alsa-utils测试音频设备"></a>使用alsa-utils测试音频设备</h1><p>首先测试Linux上如何使用普通音箱<br>将音箱USB连到树莓派USB, 音频线连到音频接口</p>
<h2 id="查看音频设备"><a href="#查看音频设备" class="headerlink" title="查看音频设备"></a>查看音频设备</h2><p>ALSA在应用层提供了alsa-utils包，其含有arecord、aplay等工具来查看和使用音频设备。</p>
<pre><code>apt-get install alsa-utils
</code></pre>
<p>查看声卡列表：</p>
<pre><code>cat /proc/asound/cards
</code></pre>
<p>可以看到当前有两张声卡</p>
<p>card 0是树莓派的bcm2835集成声卡，card 1 是另外接的USB麦克风</p>
<p>注意区分声卡和音频设备，一个声卡可以管理多个音频设备，类似于”总线”和”设备”的关系。</p>
<p>音频设备可以细分为输入和输出两种：例如音箱是播放音频，属于输出；麦克风是录入音频，属于输入。下面分别查看这两类设备。</p>
<p>查看音频输入设备：</p>
<pre><code>arecord -l
</code></pre>
<p>查看音频输出设备：</p>
<pre><code>aplay -l
</code></pre>
<h2 id="使用音频设备"><a href="#使用音频设备" class="headerlink" title="使用音频设备"></a>使用音频设备</h2><p>(1)测试音频输出：</p>
<pre><code>aplay test.wav -D plughw:CARD=0,DEV=0
</code></pre>
<p>音频设备用 CARD 和 DEV 指定，来自于前文<code>aplay -l</code>查看音频设备的输出<br>测试音频(wav格式)可以在此下载：<a href="https://www.ape8.cn/wav/">ape8.cn</a></p>
<p>(2)测试音频输入：</p>
<p>使用arecord录制音频输入<br>-f 录制音频格式。例如 cd 表示 (16 bit little endian, 44100, stereo)<br>-d 录制时间，单位秒<br>-c 输入通道的个数，如果是麦克风阵列可能有多通道<br>-D 使用的设备：-D hw:1,0 表示使用 card 1 下的device 0设备</p>
<p>测试如下：</p>
<pre><code>arecord -f cd -d 5 -c 1 -D hw:1,0 &gt; test.pcm
</code></pre>
<p>然后播放此音频：</p>
<pre><code>aplay test.pcm
</code></pre>
<h1 id="蓝牙服务相关配置"><a href="#蓝牙服务相关配置" class="headerlink" title="蓝牙服务相关配置"></a>蓝牙服务相关配置</h1><h2 id="蓝牙协议栈和服务的安装"><a href="#蓝牙协议栈和服务的安装" class="headerlink" title="蓝牙协议栈和服务的安装"></a>蓝牙协议栈和服务的安装</h2><p>首先确保系统软件是最新：</p>
<pre><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>安装 bluez，pulseaudio 等蓝牙基础组件，对于树莓派还要安装pi-bluetooth</p>
<pre><code>sudo apt-get install pi-bluetooth bluez bluez-tools pulseaudio pulseaudio-module-bluetooth
</code></pre>
<p>bluez 是Linux官方的蓝牙协议栈，其内部实现 A2DP 蓝牙音频协议，参考<a href="http://www.bluez.org/about/">bluez.org</a></p>
<p>PulseAudio 是Linux音频服务器, 其最主要的作用是：<br>PulseAudio clients can send audio to “sinks” and receive audio from “sources”</p>
<p>参考<a href="https://www.freedesktop.org/wiki/Software/PulseAudio/About/">PulseAudio&#x2F;About</a></p>
<p>简单说明下蓝牙的发送、接收的概念：<br>蓝牙的Source端为发送码流的端，Sink端为接收码流的端；可类比生产者和消费者模型</p>
<h2 id="启动音频服务"><a href="#启动音频服务" class="headerlink" title="启动音频服务"></a>启动音频服务</h2><p>PulseAudio服务需要创建用户名和用户组，示例如下：</p>
<pre><code>sudo usermod -G bluetooth -a ubuntu
</code></pre>
<p>启动服务器</p>
<pre><code>pulseaudio --start
</code></pre>
<h2 id="启动蓝牙配对"><a href="#启动蓝牙配对" class="headerlink" title="启动蓝牙配对"></a>启动蓝牙配对</h2><p>蓝牙首次连接需要配对，使用 bluez 的 <code>bluetoothctl</code>工具</p>
<p>参考：<a href="https://www.makeuseof.com/manage-bluetooth-linux-with-bluetoothctl/">How to Manage Bluetooth Devices on Linux Using bluetoothctl</a></p>
<pre><code>bluetoothctl //进入蓝牙配置模式，会显示用户为[bluetooth]#
[bluetooth]# list //列出树莓派的蓝牙控制器列表
[bluetooth]# agent on //注册蓝牙代理
[bluetooth]# default-agent //使用默认代理
[bluetooth]# discoverable on //树莓派的蓝牙可被其他设备发现
[bluetooth]# scan on //开始扫描可连接蓝牙设备
</code></pre>
<p>此后选择要连接的蓝牙设备，手机蓝牙打开，<code>scan on</code>列表找到手机的 MAC地址 进行连接配对。<br>手机的MAC可在设置-&gt;系统信息查看</p>
<pre><code>[bluetooth]# pair &lt;dev&gt; //配对设备，首次需要密码
[bluetooth]# trust &lt;dev&gt; //信任该设备，此后可以自动配对无需密码
[bluetooth]# connect &lt;dev&gt; //建立连接
</code></pre>
<p>现在可以退出 bluetoothctl模式，然后测试蓝牙音频播放：</p>
<pre><code>[bluetooth]# quit
aplay test.wav
</code></pre>
<p>关于蓝牙的agent，参考<a href="https://askubuntu.com/questions/763939/bluetoothctl-what-is-a-bluetooth-agent">bluetoothctl - What is a bluetooth agent?</a></p>
<h2 id="设置自动配对连接"><a href="#设置自动配对连接" class="headerlink" title="设置自动配对连接"></a>设置自动配对连接</h2><p>为了避免每次pair都要指定设备，可以配置蓝牙打开时，自动pair上次的设备。</p>
<p>编辑PulseAudio配置文件 <code>/etc/pulse/default.pa</code> </p>
<pre><code># automatically switch to newly-connected devices
load-module module-switch-on-connect
</code></pre>
<p>编辑bluez配置文件 <code>/etc/bluetooth/main.conf</code></p>
<pre><code>[Policy]
AutoEnable=true
</code></pre>
<p>系统重启后只需要重启PulseAudio服务：</p>
<pre><code>pulseaudio --start
</code></pre>
<h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><h2 id="找不到蓝牙controller"><a href="#找不到蓝牙controller" class="headerlink" title="找不到蓝牙controller"></a>找不到蓝牙controller</h2><p>最开始bluetoothctl list显示的蓝牙控制器列表是空的，我一度怀疑买了假的raspi-4B</p>
<p>原因是树莓派需要安装专门的蓝牙包 pi-bluetooth，参考<a href="https://raspberrypi.stackexchange.com/questions/114586/rpi-4b-bluetooth-unavailable-on-ubuntu-20-04">rpi-4b-bluetooth-unavailable-on-ubuntu</a></p>
<p>树莓派很多功能都要求系统有定制包，大多数硬件失效都是定制包未安装。</p>
<h2 id="蓝牙连接正常，播放没声音"><a href="#蓝牙连接正常，播放没声音" class="headerlink" title="蓝牙连接正常，播放没声音"></a>蓝牙连接正常，播放没声音</h2><p>首先确认音频设备物理连接是否正常；</p>
<p>然后确认PulseAudio音频服务是否正常，检查服务状态和配置文件；</p>
<pre><code>pacmd info
pactl info
</code></pre>
<p>问题仍没有解决，仔细听似乎有很小的声音，检测音量配置：</p>
<pre><code>pacmd list-sinks //找到sink设备，即音箱
pacmd set-sink-volume &lt;sink&gt; &lt;value&gt; //设置音量，value取值 [0, 65536] 代表标准音量 0~100%
</code></pre>
<p>参考：<a href="https://askubuntu.com/questions/219739/adjust-max-possible-volume-in-pulseaudio#:~:text=pactl%20set-sink-volume%200%20100%25%20Where%200%20is%20the,100%25%20to%20get%20audio%20boost%20%28200%25%20for%20example%29.">adjust max possible volume in pulseaudio</a></p>
<p>此时播放音乐可以听到但声音极小；<br>检查音箱的线控音量调节，调到最大；<br>此时蓝牙音乐只有正常音箱大概 30% 的播放音量。</p>
<p>原因是树莓派的USB供电驱动能力有限，同一音箱，在PC-USB供电下30%的音量大小等同于树莓派上100%的音量大小。</p>
<p>自此蓝牙播放音量可以达到正常水平，需要更高音量和音质建议220V供电的音箱。</p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p><a href="https://www.jianshu.com/p/1b79537da86d">Ubuntu音频设备检测</a><br><a href="https://www.nicolabs.net/2020/Make-RPi-bluetooth-speaker-part-1">Make-RPi-bluetooth-speaker-part-1</a><br><a href="https://gist.github.com/actuino/9548329d1bba6663a63886067af5e4cb">actuino&#x2F;bt_speaker-raspberry_pi-zero_w</a><br><a href="https://gist.github.com/oleq/24e09112b07464acbda1#file-a2dp-autoconnect-L17">A2DP audio streaming using Raspberry PI</a></p>
]]></content>
      <categories>
        <category>raspi</category>
      </categories>
      <tags>
        <tag>raspi</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建高可移植的Markdown写作和博客环境：Obsidian+PicGo+Hexo+Github</title>
    <url>/2022/02/28/%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84Markdown%E5%86%99%E4%BD%9C%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%EF%BC%9AObsidian+PicGo+Hexo+Github/</url>
    <content><![CDATA[<h2 id="0-背景"><a href="#0-背景" class="headerlink" title="0.背景"></a>0.背景</h2><p>写技术笔记并发布博客，通常有以下方式：</p>
<ul>
<li>第三方平台CSDN&#x2F;cnblogs，最简单但是最不可控，例如我写过一篇如何使用shadow-sock，直接被删掉，各种广告也是技术洁癖症不能忍的。</li>
<li>使用云服务器自建Leanote博客系统，我用过几年，最大缺点是服务器续费太贵，且文章数据存在数据库很难导出，优点是自建的Leanote写作发布一体化体验极好。</li>
<li>使用github+picgo+hexo， github作为图床和博客的云服务，picgo用于建立图床通道，hexo用于发布博客。缺点是github访问慢，用开源CDN可以很好解决；优点是全部免费，数据可移植(图片链接都在github图床)，可长期使用（只要github不倒闭不锁区）</li>
</ul>
<p>最终我选择github+picgo+hexo方案。<br>为什么不用gitee: gitee上传图片限制1M, github有25M。有了CDN, github的速度也不是问题</p>
<p>现在只需要确定Markdown编辑器</p>
<p>VSCode加Markdown插件试过，体验并不完美<br><a href="https://www.typora.io/">Typora</a>是很不错的选择，除了收费<br><a href="https://obsidian.md/">Obsidian</a>免费且优雅：</p>
<ul>
<li>支持动态渲染，即写出的Markdown语句自动显示预览</li>
<li>支持各种快捷键，无需手动输入Markdown语法格式（<a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法</a>）。比如标题，链接，列表，引用，可以设置标准的Markdown快捷键。</li>
<li>支持关联PicGo实现粘贴图片即上传到云端图床，这一点对于写作体验和文章的可迁移性很重要</li>
<li>特色的Zettelkasten笔记管理方法，本文不描述这部分，参考<a href="https://sspai.com/post/62414#!">玩转 Obsidian 01：打造知识循环利器</a></li>
</ul>
<h2 id="1-搭建可移植的Markdown写作环境"><a href="#1-搭建可移植的Markdown写作环境" class="headerlink" title="1. 搭建可移植的Markdown写作环境"></a>1. 搭建可移植的Markdown写作环境</h2><p>Markdown文档本身是可移植的，但是其图片资源不是, 因为图片不是以二进制嵌入文档，而只是个图片地址的链接。</p>
<p>如果只是在本地写写Markdown，完全不需要考虑图片的可移植，只需要存本地固定路径即可。<br>如果想在本地写Markdown，且这个文档拿到别的机器，或者放到博客论坛发布，别人都可以看到图片，就要一个云端的图片存储服务，即图床。</p>
<p>本节讲如何实现一个“一处写作，到处可见”的Markdown写作环境，并优化工具设置，让写作顺滑流程</p>
<h3 id="1-1-Github-PicGo搭建图床"><a href="#1-1-Github-PicGo搭建图床" class="headerlink" title="1.1 Github+PicGo搭建图床"></a>1.1 Github+PicGo搭建图床</h3><p>完整流程参考<a href="https://blog.csdn.net/yefcion/article/details/88412025">PicGo + GitHub 搭建个人图床工具</a></p>
<p>流程包含以下部分：</p>
<ul>
<li>一个public的Github仓库，用来存放文章链接的图片，注意单仓库最大容量1GB。</li>
<li>一个personal access token，用于PicGo免密访问github实现自动上传图片</li>
<li>一个图片上传工具：PicGo及其插件，用它上连Github图床仓库，下连本地markdown编辑器，实现“图片粘贴即上传”</li>
<li>一个CDN(推荐，很好用)：使用开源CDN jsdelivr加速Github访问，避免因访问速度造成图片上传失败</li>
</ul>
<p>最终我的配置如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281014786.png"></p>
<p>单元测试：<br>手动上传本地图片，如果上传成功，且图片可预览，则功能正常<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024870.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024344.png"></p>
<p>遇到的坑：<br>仓库名必须填&lt;用户名&gt;&lt;仓库名&gt;，不是完整的http或git仓库链接！否则上传图片error404</p>
<p>PicGo支持log调试，参考：<br><a href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html"><a href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html">PicGo上传图片到GitHub总是失败的特殊解决办法</a></a></p>
<p>2022&#x2F;5&#x2F;17更新：<br>最近发现jsdelivr在大陆挂了，那么只能放弃使用CDN, 直接使用github图床的raw链接</p>
<p>将Picgo默认图床路径从jsdelivr的<br><a href="https://cdn.jsdelivr.net/gh/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D@master">https://cdn.jsdelivr.net/gh/账户名/图床仓库名@master</a><br>改为：<br><a href="https://raw.githubusercontent.com/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D/master">https://raw.githubusercontent.com/账户名/图床仓库名/master</a></p>
<p>对于已发布的博客的图床链接，直接用VSCode全局查找替换以上前缀即可，后面的图片id是不变的。</p>
<p><strong>如何删除Github图床的图片：</strong><br>PicGo默认的Github图床不能通过相册删除github仓库的图片，需要使用第三方插件github-plus，建议作为默认图床工具，支持相册删除同步到github仓库:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281208516.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281209075.png"></p>
<h3 id="1-2-Obsidian链接图床"><a href="#1-2-Obsidian链接图床" class="headerlink" title="1.2 Obsidian链接图床"></a>1.2 Obsidian链接图床</h3><p>流程参考<a href="https://www.jianshu.com/p/4c30495f4325"># 在Obsidian中使用图床实现“一次上传、多次搬运”省心又省力</a></p>
<p>重点部分：配置自动上传插件。写Markdown文章时粘贴的图片自动上传到Github+PicGo图床，无需手动上传和写链接<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029686.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029586.png"></p>
<p>可以看到，此插件相当于一个PicGo客户端，而本地运行的PicGo Server已开启端口36677的监听。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281033479.png"></p>
<p>单元测试：<br>以上配置好后，Obsidian新建一个Markdown文档，粘贴图片会显示updating… ，成功后可在github图床仓库看到该图片，且Markdown本地预览也可以看到。</p>
<p>遇到的坑：<br>一开始上传的图片，github可预览，Obsidian预览失败<br>在PicGo客户端查看刚才上传图片预览也不正常，PicGo客户端手动上传一张后才正常预览。<br>此后Obsidian再粘贴上传图片，预览正常。<br>可能是PicGo首次链接Obsidian插件的bug。</p>
<h3 id="1-3-优化Obsidian写作体验"><a href="#1-3-优化Obsidian写作体验" class="headerlink" title="1.3 优化Obsidian写作体验"></a>1.3 优化Obsidian写作体验</h3><h4 id="1-3-1-Markdown快捷键"><a href="#1-3-1-Markdown快捷键" class="headerlink" title="1.3.1 Markdown快捷键"></a>1.3.1 Markdown快捷键</h4><p>很多Markdown编辑器支持各种快捷键，写作时不需要手动输入Markdown语法，例如一个ctrl+h形成标题，一个ctrl+k形成代码格式。<br>Obsidian默认快捷键不完整，需要补全优化<br>我之前用的Leanote写博客，Obsidian也快捷键设置如下。</p>
<blockquote>
<p>提升标题 Ctrl + H (header)<br>有序列表 Ctrl + O (Ordered)<br>无序列表 Ctrl + U (Un-Ordered)<br>插入链接 Ctrl + L (Link)<br>插入代码 Ctrl + K (K &#x3D; Code, 因为ctrl+C用于粘贴)<br>加粗 Ctrl + B (Bold)<br>斜体 Ctrl + I (Italian体)<br>引用 Ctrl + Q (Quote)<br>插入图片 Ctrl + G (Graph, 有了“粘贴即上传”，这个实际上用不上)</p>
</blockquote>
<p>其他我基本不用的就没设置，例如表格，删除线，分割线等等。<br>如果经常用表格，推荐 Advanced Tables插件。<br>读者也可以参考VS Code的Markdown插件设置。</p>
<h4 id="1-3-2-实时预览和标题大纲"><a href="#1-3-2-实时预览和标题大纲" class="headerlink" title="1.3.2 实时预览和标题大纲"></a>1.3.2 实时预览和标题大纲</h4><p>实时预览是你写一句Markdown，自动转换成预览格式，而不显示Markdown源码。这样不需要开两个窗口，一个写源码一个看预览。在设置-&gt;编辑器里开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281103907.png"></p>
<p>标题大纲是侧边栏显示文章标题列表，就像word的导航窗口一样。在设置-核心插件开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281104255.png"></p>
<h2 id="2-搭建hexo博客发布环境"><a href="#2-搭建hexo博客发布环境" class="headerlink" title="2. 搭建hexo博客发布环境"></a>2. 搭建hexo博客发布环境</h2><h3 id="2-1-环境安装"><a href="#2-1-环境安装" class="headerlink" title="2.1 环境安装"></a>2.1 环境安装</h3><p>整体流程参考：<a href="https://zhuanlan.zhihu.com/p/105715224"># 个人博客第5篇——安装node.js和Hexo</a><br>官方文档参考：<a href="https://hexo.io/zh-cn/docs/">hexo.io</a></p>
<p>简单总结一下：</p>
<ul>
<li>hexo是一个基于nodeJS的博客框架，nodeJS提供JavaScript实现后端服务的能力。</li>
<li>hexo可以将本地写好的Markdown文本和图片资源，以JavaScript网页资源的方式打包。hexo可以在本机运行服务，通过浏览器可以在网页访问。</li>
<li>如果要使博客外网可访问，需要一个云服务存放hexo生成的博客，我们使用github仓库作为博客云端。前面已经搭建了github图床仓库，因此图片并不需要放到此hexo仓库。</li>
<li>使用git实现hexo博客部署到github仓库</li>
</ul>
<p>遇到的坑：<br>如果你以前用过hexo，之后nodeJS升级了版本，一定不要用以前的hexo博客目录，必须新建博客目录，重新<code>hexo init</code>安装相关hexo插件。否则nodeJS和hexo插件可能不兼容导致部署失败。</p>
<p>hexo插件版本是根据nodeJS版本自动安装的，配置文件是package.json。以nodeJS 16.3为例，自动生成的依赖版本如下：</p>
<p><code>&#123;   &quot;name&quot;: &quot;hexo-site&quot;,   &quot;version&quot;: &quot;0.0.0&quot;,   &quot;private&quot;: true,   &quot;scripts&quot;: &#123;     &quot;build&quot;: &quot;hexo generate&quot;,     &quot;clean&quot;: &quot;hexo clean&quot;,     &quot;deploy&quot;: &quot;hexo deploy&quot;,     &quot;server&quot;: &quot;hexo server&quot;   &#125;,   &quot;hexo&quot;: &#123;     &quot;version&quot;: &quot;6.0.0&quot;   &#125;,   &quot;dependencies&quot;: &#123;     &quot;hexo&quot;: &quot;^6.0.0&quot;,     &quot;hexo-deployer-git&quot;: &quot;^3.0.0&quot;,     &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,     &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,     &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,     &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,     &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,     &quot;hexo-renderer-marked&quot;: &quot;^5.0.0&quot;,     &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;,     &quot;hexo-server&quot;: &quot;^3.0.0&quot;,     &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot;   &#125; &#125;</code></p>
<p>博客的github仓库，主题等关键配置都在<code>hexo init</code>对应目录下的<code>_config.yml</code><br>我修改了几个关键配置如下：<br>博客框架的语言一定要配，否则默认德语阿拉伯语…</p>
<blockquote>
<p>title: ThinkNotes<br>   subtitle: Simple is not easy<br>   author: Cursorhu<br>   language: zh-CN</p>
</blockquote>
<p>Github部署配置</p>
<blockquote>
<p>url: <a href="https://cursorhu.github.io/">https://cursorhu.github.io</a><br>deploy:<br>      type: git<br>      repo: <a href="https://github.com/cursorhu/cursorhu.github.io">https://github.com/cursorhu/cursorhu.github.io</a><br>      branch: master</p>
</blockquote>
<h3 id="2-2-发布博客"><a href="#2-2-发布博客" class="headerlink" title="2.2 发布博客"></a>2.2 发布博客</h3><p>hexo new命令可以从0新建markdown写博客，一般不用这么麻烦。</p>
<p>我们直接将Obsidian写好的Markdown（图片资源是图床链接）放到hexo博客目录的post文件夹，例如我的本地目录是：</p>
<blockquote>
<p>F:\HexoBlog\source_posts</p>
</blockquote>
<p>在Markdown文件前添加hexo博客特有的头，说明博客的标题时间，分类等属性。这个头如果用<code>hexo new</code>命令会自动生成，可以先new一个然后拷过来。</p>
<blockquote>
<p>title: 博客文章名<br>date: 2022-02-28 15:04:18<br>tags: markdown<br>categories: markdown</p>
</blockquote>
<p>最后使用git生成网页文件并发布到github博客仓库, 注意不是用node命令行！<br>在hexo博客目录下运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-博客主题"><a href="#2-3-博客主题" class="headerlink" title="2.3 博客主题"></a>2.3 博客主题</h3><p>博客主题(theme)取决于不同人喜好，github有大量的hexo主题，按需配置<br>推荐几个主流的：<br><a href="https://github.com/theme-next/hexo-theme-next">Next</a><br><a href="https://github.com/bollnh/hexo-theme-material">hexo-theme-material</a></p>
<p>以Next主题为例，安装：</p>
<blockquote>
<p>$ cd hexo博客目录<br>   $ git clone <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> themes&#x2F;next</p>
</blockquote>
<p>已我的配置为例，就会在F:\HexoBlog\themes\next看到next主题的源码和配置文件config.yml</p>
<p>Next配置可以自定义各种设置，例如子主题:</p>
<blockquote>
<p> scheme: Muse<br>#scheme: Mist<br>#scheme: Pisces<br>#scheme: Gemini</p>
</blockquote>
<p>我们前面已经用jsdelivr开源CDN为PicGo上传图片加速，可以配置Next主题的网页静态文件的相关库也用jsdelivr加速。最好用到才开启，例如motion enable, 其依赖库velocity就可以设置jsdelivr加速：</p>
<blockquote>
<p>motion:<br>      enable: true<br>    velocity: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.min.js<br>    velocity_ui: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.ui.min.js</p>
</blockquote>
<p>注意这些配置文件也是Markdown格式，<code># </code> 注释一定要带空格</p>
<p>hexo要使用next, 在hexo配置文件设置:</p>
<blockquote>
<p>theme: next</p>
</blockquote>
<p>hexo clean, hexo g, hexo s 跑本地服务，看一下效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203041651883.png"></p>
<p>最后hexo clean, g, d 命令三连部署到github</p>
<h3 id="2-4-速度优化"><a href="#2-4-速度优化" class="headerlink" title="2.4 速度优化"></a>2.4 速度优化</h3><p>参考<a href="https://ednovas.gitee.io/2021/09/23/speeduphexo/"># Hexo 网站访问速度优化</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派笔记：使用mjpg-streamer+Apache+SSH自制网络摄像头</title>
    <url>/2021/08/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8mjpg-streamer-Apache+SSH%E8%87%AA%E5%88%B6%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h1><ul>
<li>为什么用树莓派4：</li>
</ul>
<p>资料多遇到容易解决问题；<br>性能较强适合作为终端服务器；<br>自带WIFI, BT5.0，GPIO 方便拓展开发IOT相关项目；<br>适配系统丰富，基本PC上linux版本树莓派都有对应版本</p>
<ul>
<li>为什么用USB摄像头：</li>
</ul>
<p>为了快速实现，Linux对USB设备支持非常好，USB设备基本都是免驱；<br>USB摄像头支持高分辨率，带麦克风，满足其他项目拓展应用；<br>当然CSI接口摄像头也有优势，同等条件下其CPU占用率比USB低；不过本地测试中CPU并不是USB摄像头性能瓶颈<br>关于CSI和USB 摄像头区别：<a href="https://blog.csdn.net/ZhaoDongyu_AK47/article/details/103981905">CSI摄像头 vs USB摄像头</a></p>
<ul>
<li>树莓派用什么系统：</li>
</ul>
<p>看个人喜好，我用的ubuntu server的树莓派版本，软件源基本最新；</p>
<ul>
<li>用什么云服务器：</li>
</ul>
<p>看个人喜好和价格；云服务器最大价值在于公网IP<br>我目前用的Aliyun + CentOS7 系统</p>
<p>系统实拍：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081944910.png" alt="image-20221208194427802"></p>
<h1 id="树莓派系统安装"><a href="#树莓派系统安装" class="headerlink" title="树莓派系统安装"></a>树莓派系统安装</h1><p>准备：电源，网线，SD卡<br>安装步骤：</p>
<ul>
<li>1.下载ubuntu server for raspi</li>
</ul>
<p>注意一定要下载raspi版本的镜像，普通ubuntu server版本安装完不能直接使用SSH<br><a href="https://ubuntu.com/download/raspberry-pi">Install Ubuntu on a RaspberryPi</a></p>
<ul>
<li>2.Win32DiskImager写.img镜像到SD卡，作为系统盘</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/bhniunan/article/details/104790090">使用win32DiskImager为树莓派4B安装系统</a></p>
<ul>
<li>3.SSH 登陆</li>
</ul>
<p>ubuntu server for raspi系统装机启动后，连接网线到主机局域网后就可以SSH登陆<br>树莓派连到主机网段路由器的LAN口，树莓派系统默认开了dhcp, 用Advanced IP Scanner扫描树莓派IP</p>
<p>树莓派4b：mac地址“dc-a6-32”开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081944582.png" alt="image-20221208194446543"></p>
<p>SSH 软件看个人喜好，putty, SecureCRT, Xshell都可以，我个人使用的SecureCRT</p>
<p>ubuntu server for raspi系统的SSH会话初始化如下：<br>新建会话-&gt; SSH2链接-&gt; 树莓派ip -&gt; 账户名(默认ubuntu)<br>初始密码：ubuntu，登陆成功后需要重设密码。</p>
<p>wifi配置方式参考 <a href="https://blog.csdn.net/weixin_42378324/article/details/114631521">树莓派安装ubuntu server, 无显示屏和键盘</a></p>
<ul>
<li>4.固定树莓派IP</li>
</ul>
<p>DHCP方式每次启动树莓派IP可能不一样，有两种方式固定IP</p>
<ul>
<li>MAC绑定IP<br>参考<a href="https://blog.csdn.net/Echozi/article/details/104210167">TL-WR886N路由器+树莓派绑定IP地址</a></li>
<li>手动配置固定ip<br><a href="https://blog.csdn.net/u010169607/article/details/111316624">Pi4B 树莓派 ubuntu20.04 设置固定IP地址</a></li>
</ul>
<h1 id="USB摄像头测试"><a href="#USB摄像头测试" class="headerlink" title="USB摄像头测试"></a>USB摄像头测试</h1><ul>
<li>首先主机win10上验证摄usb像头功能正常</li>
</ul>
<p>设备管理器禁用笔记本原装摄像头驱动，搜索相机-&gt; 打开视频，视频流应该正常</p>
<ul>
<li>在树莓派上验证摄像头设备</li>
</ul>
<p>usb摄像头设备既是usb设备又是v4l2设备，应该挂载在&#x2F;dev&#x2F;videoX</p>
<pre><code>ls /dev/video*
ls /dev | grep video
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945191.png" alt="image-20221208194510165"><br>插拔摄像头确认usb摄像头对应设备是video0</p>
<h1 id="树莓派安装mjpg-streamer"><a href="#树莓派安装mjpg-streamer" class="headerlink" title="树莓派安装mjpg-streamer"></a>树莓派安装mjpg-streamer</h1><p>mjpg-streamer的作用是将摄像头采集的YUV&#x2F;JPEG数据，封装成流服务，其他设备可以通过http方式获取图片或视频流。<br>mjpg-streamer属于应用层实现流媒体服务端，其底层调用的是Linux V4L2框架接口。</p>
<p>安装过程：</p>
<ol>
<li><p>依赖库安装</p>
<p>sudo apt-get install subversion libjpeg8-dev imagemagick libv4l-dev cmake git</p>
</li>
<li><p>安装mjpg-streamer</p>
<p>git clone <a href="https://github.com/jacksonliam/mjpg-streamer.git">https://github.com/jacksonliam/mjpg-streamer.git</a><br>cd mjpg-streamer&#x2F;mjpg-streamer-experimental&#x2F;<br>make all<br>sudo make install</p>
</li>
</ol>
<h1 id="局域网测试mjpg-streamer"><a href="#局域网测试mjpg-streamer" class="headerlink" title="局域网测试mjpg-streamer"></a>局域网测试mjpg-streamer</h1><p>mjpg-streamer&#x2F;mjpg-streamer-experimental目录下有测试脚本：<code>start.sh</code><br>环境变量添加依赖库路径：</p>
<pre><code>export LD_LIBRARY_PATH=&quot;$(pwd)&quot; 
</code></pre>
<p>运行示例：</p>
<pre><code>./mjpg_streamer -i &quot;./input_uvc.so&quot; -o &quot;./output_http.so -w ./www&quot; 
</code></pre>
<p>其YUV&#x2F;MJPEG的输入使用 input_uvc.so， 输出流到 http依赖于 output_http.so，<code>-w ./www</code> 表示http客户端访问时返回www文件夹下的资源，即对应的浏览器页面。</p>
<p>可以自定义参数，参考：</p>
<pre><code>mjpg_streamer -i &quot;input_uvc.so --help&quot;
</code></pre>
<p>修改start.sh的自定义启动语句如下：</p>
<pre><code>./mjpg_streamer -i &quot;./input_uvc.so -n -f 30 -r 640x480 -d /dev/video0&quot;  -o &quot; ./output_http.so -w ./www&quot;
</code></pre>
<p>-n 用于跳过一些ioctrl请求，我的摄像头如果不用-n，有一些ioctrl会返回错误，尽管不影响流传输功能，还是跳过。<br>-f 设置fps，如果有卡顿考虑降低该值<br>-r 分辨率，1080P摄像头可以支持到1920x1080<br>-d 设备名，默认&#x2F;dev&#x2F;video0</p>
<p>一般USB摄像头支持直接输出压缩后的MJPEG格式图像，有的只支持YUV格式图像；<br>摄像头优先使用MJPEG格式，因为不用mjpg-streamer软件边采集边做压缩，减少CPU使用</p>
<p>启动信息：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945245.png" alt="image-20221208194525192"></p>
<p>此时流服务已运行，在局域网任意设备用浏览器访问<code>树莓派ip:流服务端口</code>即可获取www目录的网页资源<br>192.168.0.105是我树莓派固定ip, 8080是mjpg-streamer服务默认端口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945636.png" alt="image-20221208194549504"><br>局域网下即使是1080p 30fps也非常流畅，看不出卡顿</p>
<h1 id="公网服务器搭建反向代理"><a href="#公网服务器搭建反向代理" class="headerlink" title="公网服务器搭建反向代理"></a>公网服务器搭建反向代理</h1><h2 id="反向代理的概念"><a href="#反向代理的概念" class="headerlink" title="反向代理的概念"></a>反向代理的概念</h2><p>正向代理和反向代理的概念图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946618.png" alt="image-20221208194609572"></p>
<p>正向代理：代理的是客户端，例如GFW禁止某用户直接访问目标服务器的8080端口，但没有禁止访问正向代理服务器，客户端访问正向代理服务器，代理服务将用户请求转发给目标服务器，实现“蛙跳式”访问。对于目标服务器来说，正向代理服务器才是其客户端，用户ip对其是不可见的。<br>反向代理：代理的是服务端，应用于以下场景：</p>
<ul>
<li>出于安全考虑，目标服务器不直接暴露其ip和端口，用户通过访问反向代理服务器来间接访问目标服务器</li>
<li>保证系统稳定性：反向代理服务器可以代理多个目标服务器，当用户请求量大时作为负载均衡(<a href="https://blog.csdn.net/ywd1992/article/details/112858537">负载均衡和反向代理的区别</a>); 支持目标服务器作为集群管理，当某个目标服务器失效时将请求转发到其他服务器, 参考<a href="https://www.cnblogs.com/jkko123/p/6426857.html">centos7下apache2.4反向代理</a></li>
</ul>
<p>对于本项目，树莓派的mjpg-streamer进程是真正提供流媒体服务的目标服务器，阿里云公网服务器上安装apache服务，实现反向代理。</p>
<h2 id="安装apache服务"><a href="#安装apache服务" class="headerlink" title="安装apache服务"></a>安装apache服务</h2><p>Apache实现http web服务器；没有apache, 客户浏览器页面没办法访问对应服务。<br>阿里云主机 cent-OS 7 上的安装过程：</p>
<pre><code>//安装Apache
yum install httpd
//设置服务器开机自动启动Apache
systemctl enable httpd.service
//启动Apache
systemctl start httpd.service
//重启
systemctl restart httpd.service
//停止
systemctl stop httpd.service    
</code></pre>
<p>启动apache后，直接访问阿里云ip，默认端口 80 即为 apache 进程端口，得到如下页面说明服务正常<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946493.png" alt="image-20221208194622426"></p>
<h2 id="配置apache为反向代理"><a href="#配置apache为反向代理" class="headerlink" title="配置apache为反向代理"></a>配置apache为反向代理</h2><p>apache相关配置路径在&#x2F;etc&#x2F;httpd的几个conf目录<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946576.png" alt="image-20221208194635517"></p>
<p><code>vim /etc/httpd/conf/httpd.conf</code> 查看关键内容如下:</p>
<pre><code>Listen 80 //监听80端口
Include conf.modules.d/*.conf //包含module.d目录的所有conf
DocumentRoot &quot;/var/www/html&quot; //默认返回该目录的html资源
IncludeOptional conf.d/*.conf //包含conf.d目录的所有conf
</code></pre>
<p><code>/etc/httpd/conf.modules.d</code>目录下的<code>00-proxy.conf</code>是针对代理的配置项，其中有大量LoadModule加载proxy模块。<br>配置内容是XML格式，在此自定义反向代理，追加以下内容：</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ProxyRequests off
    &lt;Proxy raspi&gt;
        Order allow,deny
        Allow from all
    &lt;/Proxy&gt;
    ProxyPass /raspi http://127.0.0.1:9020
    ProxyPassReverse /raspi http://127.0.0.1:9020
&lt;/VirtualHost&gt;
</code></pre>
<p>含义：<br><code>&lt;VirtualHost *:80&gt;</code> 定义一个虚拟主机，<em>表示任意命名，端口80<br><code>ProxyRequests off</code> 关闭正向代理<br><code>&lt;Proxy raspi&gt;</code>定义一个代理对象，可以命名为</em>，这里命名为raspi因为后端服务是raspi流服务<br><code>ProxyPass</code> 和 <code>ProxyPassReverse</code> 内容要完全一样，<code>ProxyPassReverse /raspi http://127.0.0.1:9020</code> 表示用户访问&#x2F;raspi资源实际访问的是本地（apache所在云主机）的9020端口。</p>
<p>注意阿里云端口要支持外部可访问，需要在控制台配置安装组，参考：<a href="https://developer.aliyun.com/article/767328">阿里云服务器开放端口教程</a></p>
<p>我个人的配置是直接(1~65535)全部端口打开（不推荐，有风险）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946296.png" alt="image-20221208194652256"></p>
<p>配置完毕重启apache服务</p>
<h2 id="配置SSH反向隧道"><a href="#配置SSH反向隧道" class="headerlink" title="配置SSH反向隧道"></a>配置SSH反向隧道</h2><p>树莓派的mjpg-streamer服务如何连接到阿里云的apache服务？<br>使用SSH连通。关于SSH，参考<a href="https://www.ssh.com/academy/ssh">SSH (Secure Shell) Home Page</a></p>
<p>前文的SecureCRT登陆树莓派就是使用SSH2协议，下面将树莓派的mjpg-streamer服务端口通过SSH反向隧道连接到apache的代理端口</p>
<pre><code>ssh -fN -R &lt;阿里云apache代理端口&gt;:&lt;树莓派localhost&gt;:&lt;树莓派mjpg-streamer服务端口&gt; &lt;阿里云服务器用户名&gt;@&lt;服务器IP&gt;
</code></pre>
<p>例如 <code>ssh -fN -R 9020:localhost:8080 root@47.100.221.149</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947690.png" alt="image-20221208194724640"></p>
<p>输入服务器的登录密码完成通道建立，在阿里云可以查看：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947971.png" alt="image-20221208194733933"></p>
<h1 id="验证公网可访问-mjpg-streamer-服务"><a href="#验证公网可访问-mjpg-streamer-服务" class="headerlink" title="验证公网可访问 mjpg-streamer 服务"></a>验证公网可访问 mjpg-streamer 服务</h1><ul>
<li><p>1.验证树莓派到apache的视频流通道：</p>
<ol>
<li>阿里云服务器启动apache</li>
<li>树莓派建立SSH反向隧道</li>
<li>树莓派启动mjpg-streamer</li>
<li>在阿里云curl访问本地的代理端口</li>
</ol>
<p> curl 127.0.0.1:9020&#x2F;?action&#x3D;stream</p>
</li>
</ul>
<p>如果有大量数据输出，说明连接没问题</p>
<ul>
<li>2.验证apache到客户端浏览器的反向代理通道：</li>
</ul>
<p>使用处于任意网络的设备的浏览器，访问：</p>
<pre><code>http://云服务器IP / Apache代理名 / ?action=stream
</code></pre>
<p>本文中配置对应的输入是：<code>47.100.221.149/raspi/?action=stream</code>，注意<code>?action=stream</code>不能掉，直接访问<code>/raspi</code>得到的是静态页面，跳转不到<code>action=stream</code>的页面<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947462.png" alt="image-20221208194745374"></p>
<p>直接访问 SSH 通道的 9020 端口支持主页面访问和跳转到<code>action=stream</code>页面：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947787.png" alt="image-20221208194754703"></p>
<p>自此验证完毕公网可访问树莓派的视频流服务</p>
<h1 id="性能测试与优化"><a href="#性能测试与优化" class="headerlink" title="性能测试与优化"></a>性能测试与优化</h1><p>实测发现mjpg-streamer启动时使用 640x480分辨率, 30fps，MJPEG格式，延迟卡顿严重</p>
<p>树莓派 ping 阿里云延迟很小：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081948699.png" alt="image-20221208194803656"><br>可能是阿里云带宽不足以支撑大数据量，只能降低分辨率和帧率</p>
<p>我的阿里云服务器只有 3M 带宽，计算一下合适的配置：</p>
<pre><code>3 * 1M/8 = 3 * 128KB = 384KB
</code></pre>
<p>理论上当分辨率 640x480 &#x3D; 300KB, fps 要设置为 1 才几乎无延迟</p>
<p>测试一： 分辨率&#x3D;640x480, fps&#x3D;5<br>结果：初始延迟在 1s 以内，之后延迟增加到几秒；</p>
<p>测试二： 分辨率&#x3D;640x480, fps&#x3D;1<br>结果：初始延迟在 0.5s 左右，半小时后延迟也稳定在1s以内，效果明显比 fps&#x3D;5 好；<br>测试符合理论预期，分辨率 和 FPS 要满足带宽</p>
<p>延迟的测试方法：手机计时，网页视频显示，放一起拍照，时间差即视频延迟<br>以下显示都在1分47秒，延迟小于 1s<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081948279.png" alt="image-20221208194813177"></p>
<p>注意: 树莓派长时间运行发热较明显，需要配散热片。</p>
]]></content>
      <categories>
        <category>raspi</category>
      </categories>
      <tags>
        <tag>raspi</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C++实现单例模式</title>
    <url>/2020/11/20/%E6%B5%85%E8%B0%88C-%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>相信大家面试都逃不开设计模式话题，本节将阐述面试中的最常用的设计模式(单例模式)，从分类，线程安全，不基于C++11标准的角度与基于C++11标准的角度，有哪些解决线程安全的单例模式方案，相信认真看完本篇文章，在以后面试中就不用担忧了。</p>
<p>众所周知的单例：<br>在一般书籍中或者大家比较是熟知的单例模式是下面这样：</p>
<pre><code>class singleton &#123;
private:
    singleton() &#123;&#125;
    static singleton *p;
public:
    static singleton *instance();
&#125;;

singleton *singleton::p = nullptr;

singleton* singleton::instance() &#123;
    if (p == nullptr)
        p = new singleton();
    return p;
&#125;
</code></pre>
<p>这是一个非常简单的实现，将构造函数声明为private或protect防止被外部函数实例化，内部有一个静态的类指针保存唯一的实例，实例的实现由一个public方法来实现，该方法返回该类的唯一实例。</p>
<p>当然这个代码只适合在单线程下，当多线程时，是不安全的。考虑两个线程同时首次调用instance方法且同时检测到p是nullptr，则两个线程会同时构造一个实例给p，这将违反了单例的准则。</p>
<h1 id="2-懒汉与饿汉"><a href="#2-懒汉与饿汉" class="headerlink" title="2.懒汉与饿汉"></a>2.懒汉与饿汉</h1><p>单例分为两种实现方法：</p>
<p>懒汉:第一次用到类实例的时候才会去实例化，上述就是懒汉实现。<br>饿汉:单例类定义的时候就进行了实例化。</p>
<p>这里也给出饿汉的实现：</p>
<pre><code>class singleton &#123;
private:
    singleton() &#123;&#125;
    static singleton *p;
public:
    static singleton *instance();
&#125;;

singleton *singleton::p = new singleton();
singleton* singleton::instance() &#123;
    return p;
&#125;
</code></pre>
<p>当然这个是线程安全的，对于我们通常阐述的线程不安全，为懒汉模式，下面会阐述懒汉模式的线程安全代码优化。</p>
<h1 id="3-多线程加锁"><a href="#3-多线程加锁" class="headerlink" title="3.多线程加锁"></a>3.多线程加锁</h1><p>在C++中加锁有个类实现原理采用RAII，不用手动管理unlock，那就是lock_guard，这里采用其进行加锁。</p>
<pre><code>class singleton &#123;
private:
    singleton() &#123;&#125;
    static singleton *p;
    static mutex lock_;
public:
    static singleton *instance();
&#125;;

singleton *singleton::p = nullptr;

singleton* singleton::instance() &#123;
    lock_guard&lt;mutex&gt; guard(lock_);
    if (p == nullptr)
        p = new singleton();
    return p;
&#125;
</code></pre>
<p>这种写法不会出现上面两个线程都执行到p&#x3D;nullptr里面的情况，当线程A在执行p &#x3D; new Singleton()的时候，线程B如果调用了instance()，一定会被阻塞在加锁处，等待线程A执行结束后释放这个锁。从而是线程安全的。</p>
<p>但是这种写法性能非常低下，因为每次调用instance()都会加锁释放锁，而这个步骤只有在第一次new Singleton()才是有必要的，只要p被创建出来了，不管多少线程同时访问，使用if (p &#x3D;&#x3D; nullptr)进行判断都是足够的（只是读操作，不需要加锁），没有线程安全问题，加了锁之后反而存在性能问题。</p>
<p>因此引出**双重检查锁(DCL)**。</p>
<h1 id="4-双重检查锁模式"><a href="#4-双重检查锁模式" class="headerlink" title="4.双重检查锁模式"></a>4.双重检查锁模式</h1><p>上面写法是不管任何情况都会去加锁，然后释放锁，而对于读操作是不存在线程安全的，故只需要在第一次实例创建的时候加锁，以后不需要。下面先看一下DCLP的实现：</p>
<pre><code>singleton* singleton::instance() &#123;
    if(p == nullptr) &#123;  // 第一次检查
        Lock lock;
        if(p == nullptr)&#123; // 第二次检查
            p = new singleton;
        &#125;
    &#125;
    return p;
&#125;
</code></pre>
<p>基于上述，我们可以写出<strong>双重检查锁+自动回收(DCLP)</strong></p>
<pre><code>class singleton &#123;
private:
    singleton() &#123;&#125;

    static singleton *p;
    static mutex lock_;
public:
    singleton *instance();

    // 实现一个内嵌垃圾回收类
    class CGarbo
    &#123;
    public:
        ~CGarbo()
        &#123;
            if(singleton::p)
                delete singleton::p;
        &#125;
    &#125;;
    static CGarbo Garbo; // 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象
&#125;;

singleton *singleton::p = nullptr;
singleton::CGarbo Garbo;

singleton* singleton::instance() &#123;
    if (p == nullptr) &#123;
        lock_guard&lt;mutex&gt; guard(lock_);
        if (p == nullptr)
            p = new singleton();
    &#125;
    return p;
&#125;
</code></pre>
<p>DCLP的关键在于，大多数对instance的调用会看到p是非空的，因此甚至不用尝试去初始化它。因此，DCLP在尝试获取锁之前检查p是否为空。只有当检查成功（也就是p还没有被初始化）时才会去获得锁，然后再次检查p是否仍然为空（因此命名为双重检查锁）。第二次检查是必要，因为就像我们刚刚看到的，很有可能另一个线程偶然在第一次检查之后，获得锁成功之前初始化p。</p>
<p>看起来上述代码非常美好，可是过了相当一段时间后，才发现这个漏洞，原因是：<strong>内存读写的乱序执行(编译器问题)。</strong></p>
<p>再次考虑初始化p的那一行：</p>
<pre><code>p = new singleton;
</code></pre>
<p>这条语句会导致三个事情的发生：</p>
<ul>
<li>分配能够存储singleton对象的内存；</li>
<li>在被分配的内存中构造一个singleton对象；</li>
<li>让p指向这块被分配的内存。</li>
</ul>
<p>可能会认为这三个步骤是按顺序执行的，但实际上只能确定步骤1是最先执行的，步骤2，3却不一定。问题就出现在这。</p>
<ol>
<li>线程A调用instance，执行第一次p的测试，获得锁，按照1,3,执行，然后被挂起。此时p是非空的，但是p指向的内存中还没有Singleton对象被构造。</li>
<li>线程B调用instance，判定p非空，</li>
<li>将其返回给instance的调用者。调用者对指针解引用以获得singleton，噢，一个还没有被构造出的对象。bug就出现了。</li>
</ol>
<p>DCLP能够良好的工作仅当步骤一和二在步骤三之前被执行，但是并没有并没有方法在C或C++中表达这种限制。这就像是插在DCLP心脏上的一把匕首：我们需要在相对指令顺序上定义限制，但是我们的语言没有给出表达这种限制的方法。</p>
<h1 id="5-memory-barrier指令"><a href="#5-memory-barrier指令" class="headerlink" title="5.memory barrier指令"></a>5.memory barrier指令</h1><p>DCLP问题在C++11中，这个问题得到了解决。</p>
<p>因为新的C++11规定了新的内存模型，保证了执行上述3个步骤的时候不会发生线程切换，相当这个初始化过程是“原子性”的的操作，DCL又可以正确使用了，不过在C++11下却有更简洁的多线程singleton写法了，这个留在后面再介绍。</p>
<p>C++11之前解决方法是barrier指令。要使其正确执行的话，就得在步骤2、3直接加上一道memory barrier。强迫CPU执行的时候按照1、2、3的步骤来运行。</p>
<p>第一种实现：</p>
<p>基于operator new + placement new，遵循1,2,3执行顺序依次编写代码。</p>
<pre><code>// method 1 operator new + placement new
singleton *instance() &#123;
    if (p == nullptr) &#123;
        lock_guard&lt;mutex&gt; guard(lock_);
        if (p == nullptr) &#123;
            singleton *tmp = static_cast&lt;singleton *&gt;(operator new(sizeof(singleton)));
            new(p)singleton();
            p = tmp;
        &#125;
    &#125;
    return p;
&#125;
</code></pre>
<p>第二种实现：</p>
<p>基于直接嵌入ASM汇编指令mfence，uninx的barrier宏也是通过该指令实现的。</p>
<pre><code>#define barrier() __asm__ volatile (&quot;lwsync&quot;)
singleton *singleton::instance() &#123;
    if (p == nullptr) &#123;
        lock_guard&lt;mutex&gt; guard(lock_);
        barrier();
        if (p == nullptr) &#123;
            p = new singleton();
        &#125;
    &#125;
    return p;
&#125;
</code></pre>
<p>通常情况下是调用cpu提供的一条指令，这条指令的作用是会阻止cpu将该指令之前的指令交换到该指令之后，这条指令也通常被叫做barrier。 </p>
<p>上面代码中的asm表示这个是一条汇编指令，volatile是可选的，如果用了它，则表示向编译器声明不允许对该汇编指令进行优化。lwsync是POWERPC提供的barrier指令。</p>
<h1 id="6-静态局部变量"><a href="#6-静态局部变量" class="headerlink" title="6.静态局部变量"></a>6.静态局部变量</h1><p>Scott Meyer在《Effective C++》中提出了一种简洁的singleton写法</p>
<pre><code>singleton *singleton::instance() &#123;
    static singleton p;
    return &amp;p;
&#125;
</code></pre>
<ul>
<li>单线程下，正确。</li>
<li>C++11及以后的版本（如C++14）的多线程下，正确。</li>
<li>C++11之前的多线程下，不一定正确。</li>
</ul>
<p>原因在于在C++11之前的标准中并没有规定local static变量的内存模型。于是乎它就是不是线程安全的了。但是在C++11却是线程安全的，这是因为新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它。</p>
<p>上述使用的内存序：</p>
<p>memory_order_relaxed：松散内存序，只用来保证对原子对象的操作是原子的<br>memory_order_acquire：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见<br>memory_order_release：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</p>
<h1 id="7-Atomic"><a href="#7-Atomic" class="headerlink" title="7.Atomic"></a>7.Atomic</h1><p>在C++11之前的版本下，除了通过锁实现线程安全的Singleton外，还可以利用各个编译器内置的atomic operation来实现。</p>
<p>java和c#发现乱序问题后，就加了一个关键字volatile，在声明p变量的时候，要加上volatile修饰，编译器看到之后，就知道这个地方不能够reorder（一定要先分配内存，在执行构造器，都完成之后再赋值）。</p>
<p>而对于c++标准却一直没有改正，所以VC++在2005版本也加入了这个关键字，但是这并不能够跨平台（只支持微软平台）。</p>
<p>而到了c++ 11版本，为了从根本上消除这些漏洞，引入了适合多线程的内存模型。终于有了这样的机制帮助我们实现跨平台的方案。</p>
<pre><code>mutex singleton::lock_;
atomic&lt;singleton *&gt; singleton::p;

/*
* std::atomic_thread_fence(std::memory_order_acquire); 
* std::atomic_thread_fence(std::memory_order_release);
* 这两句话可以保证他们之间的语句不会发生乱序执行。
*/
singleton *singleton::instance() &#123;
    singleton *tmp = p.load(memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    if (tmp == nullptr) &#123;
        lock_guard&lt;mutex&gt; guard(lock_);
        tmp = p.load(memory_order_relaxed);
        if (tmp == nullptr) &#123;
            tmp = new singleton();
            atomic_thread_fence(memory_order_release);
            p.store(tmp, memory_order_relaxed);
        &#125;
    &#125;
    return p;
&#125;
</code></pre>
<p>值得注意的是，上述代码使用两个比较关键的术语，获得与释放：</p>
<ul>
<li>获得是一个对内存的读操作，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去。</li>
<li>释放是一个对内存的写操作，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去。</li>
</ul>
<p>acquire 和 release 通常都是配对出现的，目的是保证如果对同一个原子对象的 release 发生在 acquire 之前的话，release 之前发生的内存修改能够被 acquire 之后的内存读取全部看到。</p>
<h1 id="8-pthread-once"><a href="#8-pthread-once" class="headerlink" title="8.pthread_once"></a>8.pthread_once</h1><p>如果是在unix平台的话，除了使用atomic operation外，在不适用C++11的情况下，还可以通过pthread_once来实现Singleton。</p>
<p>原型如下：</p>
<pre><code>int pthread_once(pthread_once_t once_control, void (init_routine) (void))；
</code></pre>
<p>实现：</p>
<pre><code>class singleton &#123;
private:
    singleton(); //私有构造函数，不允许使用者自己生成对象
    singleton(const singleton &amp;other);

    //要写成静态方法的原因：类成员函数隐含传递this指针（第一个参数）
    static void init() &#123;
        p = new singleton();
    &#125;

    static pthread_once_t ponce_;
    static singleton *p; //静态成员变量 
public:
    singleton *instance() &#123;
        // init函数只会执行一次
        pthread_once(&amp;ponce_, &amp;singleton::init);
        return p;
    &#125;
&#125;;
</code></pre>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>本文讲解了几种单例模式，并讲解了线程安全的单例模式，以及不用C++11实现的几种线程安全的单例模式：memory barrier，静态局部变量，pthread_once方式，C++11的atomic实现等。</p>
<p>最后值得注意的是，针对上述单例类的析构函数请参考双重锁检查模式+自动回收实现，必须在类中声明一个静态局部变量，静态局部变量可以理解为全局变量，在程序结束时，自动调用该静态局部变量的析构函数，这就是为什么要在类中声明与定义嵌套类，而不是直接编写单例的析构函数。</p>
<p>本文参考：<a href="https://light-city.club/sc/design_pattern/singleton/singleton/">C++那些事-&gt;设计模式-&gt;单例模式</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C++的RAII机制</title>
    <url>/2020/11/08/%E6%B5%85%E8%B0%88C-%E7%9A%84RAII%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-资源与内存分配"><a href="#1-资源与内存分配" class="headerlink" title="1.资源与内存分配"></a>1.资源与内存分配</h1><p>资源的概念:资源是数量有限且对系统正常运转具有一定作用的元素。比如，内存，文件句柄，网络套接字（network sockets），互斥锁（mutex locks）等等<br>对于进程，这些资源都作为某种数据结构存储在内存中。<br>程序运行需要分配内存来管理以上资源，内存分配可以分为三类：</p>
<ul>
<li>静态分配：如创建一个进程执行某段代码，需要加载该代码的代码段，数据段等数据到内存中，其中数据段包含已初始化的全局数据，可以称为是静态的内存分配</li>
<li>自动分配：进程内函数的调用和返回，以及其内部的局部变量创建和销毁，对应该进程高地址的入栈出栈，这个是操作系统自动处理的，无需应用程序控制</li>
<li>动态分配：静态数据和堆栈之前的空间（称为堆），可由应用程序动态分配，同时，也必须由应用程序释放。所谓的内存的动态分配与释放，通常讨论的是这种情况</li>
</ul>
<p>以32位Linux环境的应用程序为例，每个进程可见的（虚拟）内存分布如下，C&#x2F;C++常用的malloc&#x2F;free, new&#x2F;delete对应的内存分配释放都在.heap段内<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081658341.png" alt="image-20221208165846274"></p>
<h1 id="2-动态内存管理的缺陷"><a href="#2-动态内存管理的缺陷" class="headerlink" title="2.动态内存管理的缺陷"></a>2.动态内存管理的缺陷</h1><p>我们在使用资源时必须严格遵循的步骤是：</p>
<ol>
<li>获取资源</li>
<li>使用资源</li>
<li>释放资源</li>
</ol>
<p>代码形式：</p>
<pre><code>void UseResources()    
&#123;  
    // 获取资源1  
    // ...  
    // 获取资源n  
     
    // 使用这些资源  
     
    // 释放资源n  
    // ...  
    // 释放资源1  
&#125; 
</code></pre>
<p>当代码量和复杂度达到一定程度，这种手动资源管理容易出错，且难以避免<br>例如C++使用new和delete时可能发生的一些错误是：</p>
<ul>
<li>内存泄漏：例如，使用new分配对象，而忘记删除该对象，打开文件，忘记关闭文件等等</li>
<li>过早删除（或悬挂引用）：持有指向对象的另一个指针，删除该对象，但是还有其他指针在引用它。</li>
<li>双重删除：尝试两次删除一个对象</li>
</ul>
<h1 id="3-RAII：将资源管理交给系统"><a href="#3-RAII：将资源管理交给系统" class="headerlink" title="3.RAII：将资源管理交给系统"></a>3.RAII：将资源管理交给系统</h1><ul>
<li>自动内存管理，局部变量能在调用函数时分配，退出函数时释放</li>
<li>类是 C++ 中的主要抽象工具，将资源抽象为类，用局部对象来表示资源，把管理资源的任务转化为管理局部对象的任务</li>
</ul>
<p>RAII 就是基于以上思想，折中了全手动和全自动的内存管理，手动的选择管理哪些资源，自动的分配和释放资源。有效地实现了 C++ 资源管理的自动化</p>
<p>RAII（Resource Acquisition Is Initialization, 资源获取即初始化）:<br>是80年代，Bjarne Stroustrup为C++发明了的范例。<br>具体实现方法：将资源的声明周期，绑定到对象的生命周期，即将资源分配和释放操作，包含到指定对象的构造函数和析构函数中，这些构造函数和析构函数在适当的时候由编译器自动调用，资源数据包含到对象的成员中。</p>
<p>一个简单示例：</p>
<p>（1）常规内存管理</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std; 
int main() 
&#123; 
    int *testArray = new int [10]; 
    // Here, you can use the array 
    delete [] testArray; 
    testArray = NULL ; 
    return 0; 
&#125;
</code></pre>
<p>（2）RAII方式</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std; 

class ArrayOperation 
&#123; 
public : 
    ArrayOperation() 
    &#123; 
        m_Array = new int [10]; //构造函数包含资源的分配
    &#125; 
 
    void InitArray()  //使用资源
    &#123; 
        for (int i = 0; i &lt; 10; ++i) 
        &#123; 
            *(m_Array + i) = i; 
        &#125; 
    &#125; 
 
    void ShowArray() //使用资源
    &#123; 
        for (int i = 0; i &lt;10; ++i) 
        &#123; 
            cout&lt;&lt;m_Array[i]&lt;&lt;endl; 
        &#125; 
    &#125; 
 
    ~ArrayOperation()  //析构函数包含资源的释放
    &#123; 
        cout&lt;&lt; &quot;~ArrayOperation is called&quot; &lt;&lt;endl; 
        if (m_Array != NULL ) 
        &#123; 
            delete[] m_Array;  
            m_Array = NULL ; 
        &#125; 
    &#125; 
 
private : 
    int *m_Array;  //成员变量包含资源
&#125;; 
 
int main() 
&#123; 
    ArrayOperation arrayOp; //资源自动分配
    arrayOp.InitArray(); 
    arrayOp.ShowArray(); 
    return 0;           //资源自动释放
&#125;
</code></pre>
<p>根据RAII对资源的所有权控制，分为常性类型和外部初始化类型<br>上述示例即为常性类型，也是最纯粹的RAII形式，最容易理解，最容易编码。获取资源的地点是构造函数，释放点是析构函数，并且在这两点之间的一段时间里，任何对该RAII类型实例的操纵都不应该从它手里夺走资源的所有权<br>外部初始化类型是指资源在外部被创建，并被传给RAII实例的构造函数，后者进而接管了其所有权。boost::shared_ptr&lt;&gt;和std::auto_ptr&lt;&gt;都是此类型</p>
<h1 id="4-RAII的应用场景"><a href="#4-RAII的应用场景" class="headerlink" title="4.RAII的应用场景"></a>4.RAII的应用场景</h1><p>常见的应用有：</p>
<ul>
<li>文件操作</li>
<li>智能指针</li>
<li>互斥量</li>
</ul>
<h2 id="4-1文件操作"><a href="#4-1文件操作" class="headerlink" title="4.1文件操作"></a>4.1文件操作</h2><p>（1）常规形式</p>
<pre><code>void UseFile(char const* fn)  
&#123;  
    FILE* f = fopen(fn, &quot;r&quot;);        // 获取资源  
    // 在此处使用文件句柄f...代码          // 使用资源  
    fclose(f);                       // 释放资源  
&#125;  
</code></pre>
<p>（2）RAII<br>文件类：</p>
<pre><code>class FileHandle &#123;  
public:  
    FileHandle(char const* n, char const* a) &#123; p = fopen(n, a); &#125; 
    ~FileHandle() &#123; fclose(p); &#125;  
private:   
    FileHandle(FileHandle const&amp;);  
    FileHandle&amp; operator= (FileHandle const&amp;); // 禁止拷贝操作  
    FILE *p;  
&#125;; 
</code></pre>
<p> FileHandle 类的构造函数调用 fopen() 获取资源；FileHandle类的析构函数调用 fclose()释放资源。请注意，考虑到FileHandle对象代表一种资源，它并不具有拷贝语义，因此将拷贝构造函数和赋值运算符声明为私有成员<br> 使用：</p>
<pre><code>void UseFile(char const* fn)  
&#123;  
    FileHandle file(fn, &quot;r&quot;);  
    // 在此处使用文件句柄  
    // 超出此作用域时，系统会自动调用file的析构函数，从而释放资源
&#125;  
</code></pre>
<h2 id="4-2互斥量"><a href="#4-2互斥量" class="headerlink" title="4.2互斥量"></a>4.2互斥量</h2><p>C++标准库提供lock_guard类实现mutex分配与释放，其实现就是RAII方式。</p>
<pre><code>template&lt;class... _Mutexes&gt;
    class lock_guard
    &#123;    // class with destructor that unlocks mutexes
public:
    explicit lock_guard(_Mutexes&amp;... _Mtxes)
        : _MyMutexes(_Mtxes...)
        &#123;    // construct and lock
        _STD lock(_Mtxes...);
        &#125;
 
    lock_guard(_Mutexes&amp;... _Mtxes, adopt_lock_t)
        : _MyMutexes(_Mtxes...)
        &#123;    // construct but don&#39;t lock
        &#125;
 
    ~lock_guard() _NOEXCEPT
        &#123;    // unlock all
        _For_each_tuple_element(
            _MyMutexes,
            [](auto&amp; _Mutex) _NOEXCEPT &#123; _Mutex.unlock(); &#125;);
        &#125;
 
    lock_guard(const lock_guard&amp;) = delete;
    lock_guard&amp; operator=(const lock_guard&amp;) = delete;
private:
    tuple&lt;_Mutexes&amp;...&gt; _MyMutexes;
    &#125;;
</code></pre>
<p>使用多线程时，经常会涉及到共享数据的问题，C++中通过实例化std::mutex创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。不过这意味着必须记住在每个函数出口都要去调用unlock()，也包括异常的情况，这非常麻烦，而且不易管理。C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，其会在构造函数的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。上面的代码属于mutex头文件</p>
<h2 id="4-3智能指针"><a href="#4-3智能指针" class="headerlink" title="4.3智能指针"></a>4.3智能指针</h2><p>先看一个例子，用RAII管理指针</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;fstream&gt;
using namespace std;

enum class shape_type &#123;
    circle,
    rectangle,
&#125;;

class shape &#123;
public:
    shape() &#123; cout &lt;&lt; &quot;shape&quot; &lt;&lt; endl; &#125;
    virtual void print() &#123;
        cout &lt;&lt; &quot;I am shape&quot; &lt;&lt; endl;
    &#125;
    virtual ~shape() &#123;&#125;
&#125;;

class circle : public shape &#123;
public:
    circle() &#123; cout &lt;&lt; &quot;circle&quot; &lt;&lt; endl; &#125;
    void print() &#123;
        cout &lt;&lt; &quot;I am circle&quot; &lt;&lt; endl;
    &#125;
&#125;;

class rectangle : public shape &#123;
public:
    rectangle() &#123; cout &lt;&lt; &quot;rectangle&quot; &lt;&lt; endl; &#125;
    void print() &#123;
        cout &lt;&lt; &quot;I am rectangle&quot; &lt;&lt; endl;
    &#125;
&#125;;

// 利用多态上转,如果返回值为shape,会存在对象切片问题。
shape *create_shape(shape_type type) &#123;
    switch (type) &#123;
        case shape_type::circle:
            return new circle();
        case shape_type::rectangle:
            return new rectangle();
    &#125;
&#125;

class shape_wrapper &#123;
public:
    explicit shape_wrapper(shape *ptr = nullptr) : ptr_(ptr) &#123;&#125;

    ~shape_wrapper() &#123;
        delete ptr_;
    &#125;

    shape *get() const &#123;
        return ptr_;
    &#125;

private:
    shape *ptr_;
&#125;;
</code></pre>
<p>​<br>​<br>    int main() {</p>
<pre><code>    // 第一种方式, 手动管理指针
    shape *sp = create_shape(shape_type::circle);
    sp-&gt;print();
    delete sp; //显式delete

    // 第二种方式， RAII管理指针，一般封装到函数，更快释放
    shape_wrapper ptr(create_shape(shape_type::circle));
    ptr.get()-&gt;print();

    return 0;
&#125;
</code></pre>
<p>C++标准库的智能指针：auto_ptr(C++11弃用), unique_ptr,shared_ptr, weak_ptr<br>可以参考<a href="https://www.cnblogs.com/WindSun/p/11444429.html">WindSun:详解C++11智能指针</a></p>
<h2 id="4-4实现自己的RAII类"><a href="#4-4实现自己的RAII类" class="headerlink" title="4.4实现自己的RAII类"></a>4.4实现自己的RAII类</h2><p>一般情况下，RAII临时对象不允许复制和赋值，当然更不允许在heap上创建，所以先写下一个RAII的base类，使子类私有继承Base类来禁用这些操作：</p>
<pre><code>class RAIIBase  
&#123;  
public:  
    RAIIBase()&#123;&#125;  
    ~RAIIBase()&#123;&#125;//由于不能使用该类的指针，定义虚函数是完全没有必要的  
      
    RAIIBase (const RAIIBase &amp;);  
    RAIIBase &amp; operator = (const RAIIBase &amp;);  
    void * operator new(size_t size);   
    // 不定义任何成员  
&#125;;
</code></pre>
<p>要写自己的RAII类时就可以直接继承该类的实现</p>
<pre><code>template&lt;typename T&gt;  
class ResourceHandle: private RAIIBase //私有继承 禁用Base的所有继承操作  
&#123;  
public:  
    explicit ResourceHandle(T * aResource):r_(aResource)&#123;&#125;//获取资源  
    ~ResourceHandle() &#123;delete r_;&#125; //释放资源  
    T *get()    &#123;return r_ ;&#125; //访问资源  
private:  
    T * r_;  
&#125;;
</code></pre>
<p>将Handle类做成模板类，这样就可以将class类型放入其中。另外，ResourceHandle可以根据不同资源类型的释放形式来定义不同的析构函数。由于不能使用该类的指针，所以不使用虚函数。</p>
<h1 id="5-GC和RAII"><a href="#5-GC和RAII" class="headerlink" title="5.GC和RAII"></a>5.GC和RAII</h1><p>在没有RAII的时代，GC和非GC语言是水火不容，GC追求开发效率和稳健设计，非GC如C++最求极致性能和绝对控制。RAII的设计机制，兼顾了两者的优点。<br>如果用三个等级代表程序员对系统资源的使用权限，如下：</p>
<ul>
<li>动态分配：C++的new&#x2F;delete之类，程序员100%负责内存使用和释放，编译器、操作系统不额外干预</li>
<li>垃圾回收(GC)：java&#x2F;go语言之类，程序员只负责要内存，而不用管，也管不了内存释放，其由该语言运行环境管理，规则可以描述成：如果一个资源没被任何对象使用(例如没有指针指向它)，运行环境定时或者其他方式检测到后，自动释放该资源，该过程对程序员不可控。可以说程序员有50%的权限，即想要就能要，但想甩却不能甩</li>
<li>RAII：程序员负责资源编排，运行时的分配与释放由系统自动完成，可以说程序员有90%的权限，放权10%给系统</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>RAII的本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来，从而确保在对象的生存期内资源始终有效，对象销毁时资源必被释放。换句话说，拥有对象就等于拥有资源，对象存在则资源必定存在。<br>具体实现：</p>
<ul>
<li>资源在构造函数中获取</li>
<li>资源在析构函数中释放</li>
<li>资源是类的成员变量</li>
<li>类的实例是堆栈分配的</li>
</ul>
<p>相关文章<br><a href="https://light-city.club/sc/codingStyleIdioms/RAII/">C++那些事：RAII</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的函数指针</title>
    <url>/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="1-函数指针基本概念"><a href="#1-函数指针基本概念" class="headerlink" title="1. 函数指针基本概念"></a>1. 函数指针基本概念</h2><p>C语言调用函数的本质是什么？</p>
<ol>
<li>CPU PC指针(program counter)跳转到函数的入口地址，传入参数，传入返回位置</li>
<li>在函数栈内生成临时变量并执行函数内容指令，执行完毕后返回参数</li>
<li>CPU返回原调用处执行</li>
</ol>
<p>这里，函数的入口地址实际上就存储在函数名中，也就是说，C代码中的函数名就是函数的入口地址。<br>既然是地址，就可以用来初始化一个指针，使指针指向该地址。<br>函数指针，就是存放函数首地址的指针。</p>
<h3 id="1-2-函数指针变量"><a href="#1-2-函数指针变量" class="headerlink" title="1.2 函数指针变量"></a>1.2 函数指针变量</h3><p>首先声明普通函数是如下格式：<br><code>void Func(int);</code><br>定义一个同类型函数的函数指针变量，只需要用<code>*p</code>表示函数名即可：<br><code>void (*p)(int);</code><br>注意，上面是定义了函数指针变量，而不是声明函数指针类型。</p>
<p>函数指针变量的定义，和普通变量格式不一样。</p>
<ul>
<li>普通变量： &lt;类型&gt; &lt;变量名&gt;</li>
<li>函数指针：&lt;函数类型 变量名&gt;，按函数声明的格式定义，变量是包含在类型内部</li>
</ul>
<p>那么此函数指针的类型是什么：<br><code>void (*)(int);</code></p>
<p>怎么使用此函数指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Func(int x) // 声明一个函数*/</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line">void (*p)(int); // 定义一个函数指针*/</span><br><span class="line">p = Func; // 将Func函数的首地址赋给函数指针变量p*/</span><br><span class="line">(*p)(100);  // 通过函数指针调用Func函数</span><br></pre></td></tr></table></figure>

<h3 id="1-3-函数指针类型"><a href="#1-3-函数指针类型" class="headerlink" title="1.3 函数指针类型"></a>1.3 函数指针类型</h3><p>typedef可以定义某种类型的别名，例如将unsigned char定义为u8<br><code>typedef unsigned char u8;</code><br>可见其格式是：typedef &lt;原类型&gt; &lt;别名类型&gt;</p>
<p>那么如何定义函数指针类型：<br>只需要在函数指针声明的格式前加typedef, p就定义为函数指针类型而不是变量:<br><code>typedef void (*p)(int);</code></p>
<p>这里定义了<code>void (*)(int)</code>类型的函数指针类型，其别名为p</p>
<p>怎么使用此函数指针类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义类型</span><br><span class="line">typedef void (*pFuncType)(int); </span><br><span class="line">//定义变量  </span><br><span class="line">pFuncType p;   </span><br><span class="line"></span><br><span class="line">void Func(int x)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%d&quot;,x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main()   </span><br><span class="line">&#123;   </span><br><span class="line">    p = Func; //初始化变量   </span><br><span class="line">    (*p)(100);   //使用变量</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-函数指针的应用"><a href="#2-函数指针的应用" class="headerlink" title="2. 函数指针的应用"></a>2. 函数指针的应用</h2><h3 id="2-1-Linux驱动软件设计的分层"><a href="#2-1-Linux驱动软件设计的分层" class="headerlink" title="2.1 Linux驱动软件设计的分层"></a>2.1 Linux驱动软件设计的分层</h3><p>C++中有多态的概念，父类定义某种函数类型，子类实现具体的函数内容，之后父类对象就可以调用子类的实现内容。<br>这样实现“父类定义格式，子类实现细节”的软件分层设计。</p>
<p>Linux驱动中也大量使用这种分层设计，C使用结构体和函数指针，分别对应C++的类和方法。<br>例如某驱动模块，顶层框架定义open, read, write, 而底层驱动根据具体硬件，实现xxx_open, xxx_read, xxx_write，然后按结构体成员赋值实现上下层联通：</p>
<p>以s3c的SDHCI驱动为例：<br>sdhci_ops即父类框架结构体，sdhci_s3c_ops为s3c芯片的具体实现结构体。<br><code>.set_clock = sdhci_s3c_set_clock</code>就实现了父类的set_clock方法被子类sdhci_s3c_set_clock实现的效果。<br>其本质是函数指针的赋值，父类和子类的函数名都指向同一个函数地址，所以父类可以通过调用set_clock来实现调用sdhci_s3c_set_clock的效果。<br>这样，父类设计者根本不关心底层用什么函数名实现set_clock的功能，只需要调用set_clock这个函数名即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct sdhci_ops sdhci_s3c_ops = &#123;</span><br><span class="line">	.get_max_clock		= sdhci_s3c_get_max_clk,</span><br><span class="line">	.set_clock		= sdhci_s3c_set_clock,</span><br><span class="line">	.get_min_clock		= sdhci_s3c_get_min_clock,</span><br><span class="line">	.set_bus_width		= sdhci_set_bus_width,</span><br><span class="line">	.reset			= sdhci_reset,</span><br><span class="line">	.set_uhs_signaling	= sdhci_set_uhs_signaling,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数指针实现指令跳转"><a href="#2-2-函数指针实现指令跳转" class="headerlink" title="2.2 函数指针实现指令跳转"></a>2.2 函数指针实现指令跳转</h3><p>调用一个函数，其内部就包含跳转操作(jump指令)<br>那么，如何用C语言实现跳转到某个绝对地址去执行？具体场景：<br>在Bootloader过程中，加载完kernel到RAM后，要跳转到kernel首地址开始执行，如何实现？</p>
<p>方案一：C嵌入汇编<br>以下是基于SPARC CPU的汇编，跳转到0x40000000, 即RAM首地址执行firmware.<br>对于其他CPU，汇编实现也不同，因此此方法不能跨平台。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void boot_exit()</span><br><span class="line">&#123;</span><br><span class="line">    /* jump to RAM entry to execute firmware. */</span><br><span class="line"></span><br><span class="line">    asm(</span><br><span class="line">        &quot;set 0x40000000, %g2\n&quot;</span><br><span class="line">        &quot;jmp %g2\n&quot;</span><br><span class="line">        &quot;nop&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：函数指针<br>Bootloader中很常用的一种跳转方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef void (*pFuncType)(); //定义无入参无返回类型的函数指针类型</span><br><span class="line">pFuncType Reset = (pFuncType)0xF000FFF0; //函数指针指向待跳转地址</span><br><span class="line">Reset(); //调用函数，实际上执行了跳转</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的宏函数</title>
    <url>/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="1-连接操作符"><a href="#1-连接操作符" class="headerlink" title="1. 连接操作符:##"></a>1. 连接操作符:##</h1><pre><code>#define Conn(x,y) x##y
</code></pre>
<p><code>##</code> 表示连接 , <code>x##y</code> 表示x连接y</p>
<p>示例：</p>
<pre><code>int n = Conn(123,456);
     ==&gt; int n=123456;
char* str = Conn(&quot;asdf&quot;, &quot;adf&quot;);
     ==&gt; char* str = &quot;asdfadf&quot;;
</code></pre>
<p><code>##</code> 的左右符号必须能够组成一个有意义的符号，否则预处理器会报错</p>
<h1 id="2-字符串化和字符化"><a href="#2-字符串化和字符化" class="headerlink" title="2.字符串化和字符化: #, #@"></a>2.字符串化和字符化: #, #@</h1><p>(1) # 把任意类型的宏入参转化成字符串：</p>
<pre><code>#define ToString(x) #x
</code></pre>
<p>符号 # 表示字符串化操作符（stringification）。<br>其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。<br>其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</p>
<p>示例：</p>
<pre><code> char* str = ToString(123132);
 ==&gt; char* str=&quot;123132&quot;;
</code></pre>
<p>如果要对展开后的宏参数进行字符串化，则需要使用两层宏。</p>
<pre><code>#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
     ==&gt; &quot;foo&quot;
xstr (foo)
     ==&gt; xstr (4)
     ==&gt; str (4)
     ==&gt; &quot;4&quot;
</code></pre>
<p>(2) #@ 把任意类型的宏入参转化成单字符：</p>
<pre><code>#define ToChar(x) #@x
</code></pre>
<p>示例：</p>
<pre><code>char a = ToChar(1);
     ==&gt; char a=&#39;1&#39;
</code></pre>
<h1 id="3-不定参数宏-VA-ARGS"><a href="#3-不定参数宏-VA-ARGS" class="headerlink" title="3. 不定参数宏: __VA_ARGS__"></a>3. 不定参数宏: <code>__VA_ARGS__</code></h1><p><code>__VA_ARGS__</code>宏用来接受不定数量的参数。例如：</p>
<pre><code>#define eprintf(...) fprintf (stderr, __VA_ARGS__)

eprintf (&quot;%s:%d: &quot;, input_file, lineno)
==&gt;  fprintf (stderr, &quot;%s:%d: &quot;, input_file, lineno)
</code></pre>
<p>当<code>__VA_ARGS__</code>宏前面加 <code>##</code> 时，可以省略参数输入。<br>例如：</p>
<pre><code>#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

eprintf (&quot;success!\n&quot;)
==&gt; fprintf(stderr, &quot;success!\n&quot;);
</code></pre>
<h1 id="4-宏函数定义-do-while-0-与换行"><a href="#4-宏函数定义-do-while-0-与换行" class="headerlink" title="4. 宏函数定义: do-while(0)与换行"></a>4. 宏函数定义: do-while(0)与换行</h1><p>(1) 用 do{}while(0) 定义宏函数</p>
<pre><code>#define foo() do&#123;...&#125;while(0)
</code></pre>
<p>宏函数可能在任意地方被调用，如果在if-else语句中，为了确保宏函数作为整体单元被编译器替换后不产生歧义，一般用do-while(0)包起来定义<br>这种定义有点像其他语言的“闭包函数”，纯粹是C语言中为了避免语法歧义的可靠性定义。</p>
<p>(2) 用显式换行符</p>
<p>宏函数定义不能直接回车换行，需要在回车换行前，用\（反斜线）表示下一行继续此宏的定义<br>预处理器在编译之前会自动将\与换行回车去掉。</p>
<p>例如：</p>
<pre><code>#define PRINT_INT(a)    \
do&#123;                     \
    printf(&quot;%d \n&quot;, a); \
&#125;while(0)
</code></pre>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的结构体与面向对象</title>
    <url>/2020/02/29/%E6%B5%85%E8%B0%88C%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>结构体（Struct）：存放一组不同类型的数据的数据结构。<br>数组（Array）：存放一组相同类型的数据的数据结构。<br>结构体和int,char，指针等基础数据类型一样，也是一种数据类型。格式定义如下：</p>
<pre><code>struct 结构体名&#123;
    成员类型1 成员名1;
    成员类型2 成员名2；
&#125;实例1，实例2;
</code></pre>
<p>结构体的成员（Member）可以为任意类型，如int,char，指针，甚至结构体类型。<br>结构体可以配合结构体数组、普通指针、函数指针、以及自身嵌套的使用方法，实现复杂数据结构，以及面向对象的代码风格。</p>
<h1 id="1-结构体声明"><a href="#1-结构体声明" class="headerlink" title="1.结构体声明"></a>1.结构体声明</h1><p>声明是告诉编译器某个数据结构的定义。一般在头文件对结构体、函数等类型声明。声明过程不分配内存。<br>一个结构体类型的声明：</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125;;
</code></pre>
<p>注意：<br>1.结构体声明类似于函数声明，是一个语句，末尾加；<br>2.结构体声明只声明了类型，不实例化变量，因此不分配内存。<br>3.结构体成员的变量只在实例结构体才分配内存。</p>
<h1 id="2-结构体实例"><a href="#2-结构体实例" class="headerlink" title="2.结构体实例"></a>2.结构体实例</h1><h2 id="2-1基础方法"><a href="#2-1基础方法" class="headerlink" title="2.1基础方法"></a>2.1基础方法</h2><p>结构体变量是结构体类型的实例，实例化就是在内存分配一个结构体类型的变量空间。<br>方法一：先声明结构体类型stu，再实例变量stu1,stu2。<br>该方法结构体类型声明和实例化分离。声明一次，到处实例化。注意实例变量要带struct关键字。</p>
<pre><code>struct stu stu1, stu2;
</code></pre>
<p>方法二：声明的时候也实例变量stu1,stu2。</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<p>方法三：不声明接头体名，直接实例变量。<br>适用于只需要 stu1、stu2两个变量，后面不需要再使用结构体名定义其他变量的情况</p>
<pre><code>struct&#123;             //没有写stu
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<h2 id="2-2重定义方法"><a href="#2-2重定义方法" class="headerlink" title="2.2重定义方法"></a>2.2重定义方法</h2><p>结构体类型通常配合typedef重定义后声明。<br>声明一次，到处实例化。不需要带struct关键字。</p>
<pre><code>    typedef struct stu&#123; //stu可省略
        char *name;     //姓名
        int num;        //学号
        int age;        //年龄
        char group;     //所在小组
        float score;    //成绩
    &#125;stu_t, *stu_p;    //声明stu_t为stu类型，stu_p为stu类型的指针
</code></pre>
<p>实例变量：</p>
<pre><code>stu_t stu1,stu2;    //实例两个stu结构体变量
stu_p *stu1_p, *stu2_p; //实例两个指向stu结构体指针
stu1_p = &amp;stu1; //指向实例stu1
stu2_p = &amp;stu2; //指向实例stu2
</code></pre>
<h1 id="3-结构体初始化"><a href="#3-结构体初始化" class="headerlink" title="3.结构体初始化"></a>3.结构体初始化</h1><p>初始化&#x3D;赋初始值。<br>结构体的实例只分配了内存，其成员的值要手动赋值后才能确定。否则直接拿来用会得到不确定的值（取决于分配到的内存原本的值）。<br>以重定义的结构体类型stu_t为例，实例变量时顺便初始化所有成员为0：</p>
<pre><code>stu_t stu1,stu2 = &#123;0&#125;;
</code></pre>
<p>有的编译器可能要求这种写法：</p>
<pre><code>stu_t stu1,stu2 = &#123;&#123;0&#125;&#125;;
</code></pre>
<p>如果各成员有默认初始值，初始化如下：</p>
<pre><code>stu_t stu1, stu2 = &#123; &quot;Tom&quot;, 9527, 18, &#39;A&#39;, 136.5 &#125;;
</code></pre>
<h1 id="4-结构体的赋值"><a href="#4-结构体的赋值" class="headerlink" title="4.结构体的赋值"></a>4.结构体的赋值</h1><p>结构体赋值是对结构体变量内的成员赋值。<br>两种方式访问成员：</p>
<pre><code>结构体变量.成员名;
stu1.name = &#39;Tom&#39;;
结构体指针-&gt;成员名
stu1_p-&gt;name = &#39;Tom&#39;;
</code></pre>
<p>这两种方法的选择取决于使用情况。如果结构体作为参数在函数之间频繁传递和赋值，建议使用传指针，而不是传结构体变量，这样减少函数为结构体频繁分配局部内存，但要注意结构体已被释放，形成空指针的判断。<br>注意是对实例的成员赋值（已分配内存），而不能对结构体类型的成员赋值（只是个标签）。例如如下操作是错误的：</p>
<pre><code>stu_t.name = &quot;Tom&quot;  //错，stu_t是类型
stu1_p = &amp;stu_t     //错，stu_t没地址
</code></pre>
<p>可以对结构体类型进行sizeof操作，而不需要分配内存。</p>
<pre><code>sizeof(stu_t);      //获取结构体（将）占用的内存空间
</code></pre>
<h1 id="5-结构体的内存分配"><a href="#5-结构体的内存分配" class="headerlink" title="5.结构体的内存分配"></a>5.结构体的内存分配</h1><p><strong>理论上</strong>结构体的内存占用是成员占用的和。各成员在内存中连续存储的，和数组非常类似，例如结构体变量 stu1、stu2的内存分布如下，共占用 4+4+4+1+4&#x3D;17字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061515193.jpeg" alt="1"><br>但实际上，编译器会遵循<strong>内存对齐</strong>规则。实际内存占用大于各成员占用的和。如下图，stu1、stu2 其实占用了 17+3&#x3D;20 字节<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516336.jpeg" alt="2"></p>
<h2 id="5-1内存对齐概述"><a href="#5-1内存对齐概述" class="headerlink" title="5.1内存对齐概述"></a>5.1内存对齐概述</h2><p>1.CPU怎么访问内存中的数据最高效？<br>答：用最少的访问次数，获取该数据所在的内存空间的值。<br>2.怎么做到对某类型数据的最少访问？<br>答：编译器设置数据的存放地址的单位为数据占用空间的长度，CPU以数据长度为单位查询偏移地址，找到数据空间首地址后，根据数据类型取出其占用空间大小的数据。<br>如int数据，就存放在以4字节为单位的偏移地址，如0，4，8…,CPU取数据就按0，4，8…的地址查询，找到该数据地址后取4字节。这样做到一次性访问获取int数据。如果CPU按单字节访问int,就要查询4次，如int首字节地址为0x00001024, CPU要分4次查询0x00001024~0x00001027才能得到一个int。<br>3.对于结构体，包含多种数据类型，怎么对齐？<br>答：各成员按各自的类型对齐，即对于成员来说不存在结构体的概念，它认为它就是基本的数据类型int、char、指针等。</p>
<h2 id="5-2结构体与内存对齐"><a href="#5-2结构体与内存对齐" class="headerlink" title="5.2结构体与内存对齐"></a>5.2结构体与内存对齐</h2><p>结构体是不同类型数据的集合，因此内存对齐问题就特别突出。一个例子：</p>
<pre><code>#include &quot;stdio.h&quot;
typedef struct &#123;
    int a;
    double b;
    char c;
&#125;A; 

typedef struct &#123;
    int a;
    char b;
    double c;
&#125;B;

int main()
&#123;
    printf(&quot;sizeof A: %d, sizeof B: %d\n&quot;, sizeof(A), sizeof(B));
&#125;
</code></pre>
<p>A和B的内存占用：A&#x3D;24字节，B&#x3D;16字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516111.png" alt="3"><br>结构体内存对齐的计算规则：<br>1.默认首地址已对齐（或认为是0地址)<br>2.各成员按自己的类型对齐<br>3.整个结构体分配的空间是期中最大成员占用空间的整数倍<br>对于A：<br>int a占用4字节，地址byte[0<del>3]<br>double b占8字节，起始地址必须是8的倍数，占用byte[7</del>15]<br>char c占1字节，因此占byte[16]<br>目前共占用17字节。编译器会按照规则3，将byte[17~13]也分配给结构体，因此最终结构体占用3<em>8&#x3D;24字节。<br>对于B, int a和char b加起来都不够8字节，double c再占用8字节，共占用2</em>8&#x3D;16字节。<br>因此<strong>结构体的内存分配&#x3D;各成员按类型对齐+总空间是最大成员空间的倍数</strong><br>注意，结构体不仅成员间要对齐，最后一个成员后面的空余空间可能也分配给结构体。<br>查看下面的测试程序：</p>
<pre><code>typedef struct &#123;
    int a;
    double b;
    char c;
    char d;         //d作为成员
&#125;C;

typedef struct &#123;
    int a;
    double b;
    char c;
    struct &#123;        //d作为嵌套结构体的成员
        char d; 
    &#125;;
&#125;D;

printf(&quot;sizeof C: %d, sizeof D: %d\n&quot;, sizeof(C), sizeof(D));
</code></pre>
<p>C和D的内存占用：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517211.png" alt="4"><br>新增的char d作为C的成员被分配在第三个8byte区域的第二个字节（byte[17])，嵌套的结构体并不从第四个8byte开始分配，它占用空间还是byte[17]。可见编译器对结构体内存分配不区分成员类型，只根据成员大小来处理。</p>
<h1 id="6-联合、位域、枚举"><a href="#6-联合、位域、枚举" class="headerlink" title="6.联合、位域、枚举"></a>6.联合、位域、枚举</h1><p>这几种数据结构体和结构体相关联，通常混合使用。</p>
<h2 id="6-1联合"><a href="#6-1联合" class="headerlink" title="6.1联合"></a>6.1联合</h2><p>联合(Union)也称共用体，和结构体的区别：<br>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。<br>声明格式：</p>
<pre><code>union 共用体名&#123;
    成员列表
&#125;;
</code></pre>
<p>共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>联合的一个示例：</p>
<pre><code>#include &lt;stdio.h&gt;
union data&#123;
    int n;
    char ch;
    short m;
&#125;;
int main()&#123;
    union data a;
    printf(&quot;%d, %d\n&quot;, sizeof(a), sizeof(union data) );
    a.n = 0x40;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.ch = &#39;9&#39;;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.m = 0x2059;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.n = 0x3E25AD54;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>4, 4
40, @, 40
39, 9, 39
2059, Y, 2059
3E25AD54, T, AD54
</code></pre>
<p>在内存中数据分布如下（以大端，低字节存高位为例）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517262.jpeg" alt="5"><br>可见数据会相互覆盖，联合可以理解为分时复用的结构体，其空间占用定长，为最大的成员长度，在不同时间，值的含义不同。</p>
<h2 id="6-2位域"><a href="#6-2位域" class="headerlink" title="6.2位域"></a>6.2位域</h2><p>有的结构体成员在存储时并不占用一个完整的字节，只需要按二进制位为单位分配空间即可。可以指定该成员所占用的二进制位数（Bit），这就是位域。</p>
<pre><code>#include &quot;stdio.h&quot;
struct &#123;
        unsigned char a;    //a占完整的8bit
        unsigned char b: 2; //b占2bit
        unsigned char c: 6; //C占6bit
&#125;bs;

int main()
&#123;
    printf(&quot;sizeof bs: %d\n&quot;, sizeof(bs));
&#125;
</code></pre>
<p>输出2字节，可见b和c刚好拼成一个unsigned char(8 bit)：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517807.png" alt="6"><br>位域将结构体成员占用的空间从基本数据类型为单位，变成了以二进制位为单位，是更精细的结构体内存分配。<br>位域不能超过对应基本类型的二进制位数。</p>
<h2 id="6-3枚举"><a href="#6-3枚举" class="headerlink" title="6.3枚举"></a>6.3枚举</h2><p>枚举可以理解为计数宏的结构体。</p>
<pre><code>#include &lt;stdio.h&gt;
int main()&#123;
    enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125; day;
    scanf(&quot;%d&quot;, &amp;day);
    switch(day)&#123;
        case Mon: puts(&quot;Monday&quot;); break;
        case Tues: puts(&quot;Tuesday&quot;); break;
        case Wed: puts(&quot;Wednesday&quot;); break;
        case Thurs: puts(&quot;Thursday&quot;); break;
        case Fri: puts(&quot;Friday&quot;); break;
        case Sat: puts(&quot;Saturday&quot;); break;
        case Sun: puts(&quot;Sunday&quot;); break;
        default: puts(&quot;Error!&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
<p>枚举值默认从0开始，往后逐个加 1（递增）；如果第一个成员赋值，从那个成员值往后递增。也就是说，week中的 Mon、Tues …… Sun 对应的值分别为 1、2… 7。<br>宏在编译的预处理阶段将名字替换成对应的值，而枚举在编译阶段将名字替换成对应的值。在编译过程中，Mon、Tues、Wed 名字都被替换成了对应的数字。这意味着Mon、Tues、Wed 等都不是变量，不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是被编译到指令里面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。<br>枚举类型实例的内存占用通常&#x3D;int类型占用&#x3D;4字节。</p>
<h1 id="7-结构体常见用法"><a href="#7-结构体常见用法" class="headerlink" title="7.结构体常见用法"></a>7.结构体常见用法</h1><h2 id="7-1结构体数组"><a href="#7-1结构体数组" class="headerlink" title="7.1结构体数组"></a>7.1结构体数组</h2><p>结构体数组是将多个同类型结构体按数组的方式存储，其成员访问方式为：先访问数组元素，再访问结构体成员。<br>结构体数组本质还是数组，但数组成员是结构体，结构体内可以包含各种类型的成员。<br>一个Linux NandFlash驱动的结构体数组如下：</p>
<pre><code>    static struct mtd_partition s3c_nand_parts[] = &#123;
    [0] = &#123;
        .name   = &quot;bootloader&quot;,
        .size   = 0x00040000,
        .offset    = 0,
    &#125;,
    [1] = &#123;
        .name   = &quot;params&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00020000,
    &#125;,
    [2] = &#123;
        .name   = &quot;kernel&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00200000,
    &#125;,
    [3] = &#123;
        .name   = &quot;root&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = MTDPART_SIZ_FULL,
    &#125;
&#125;;
</code></pre>
<p> 该数组名为s3c_nand_parts，成员为mtd_partition结构体，包含分区名，分区大小和分区偏移地址。每个结构体成员分别初始化赋值。注意结构体数组实例没写结构体名，只有数组下标[]，结构体成员没写结构体名,只有.符号。这是Linux kernel常见的精简写法。<br> 访问一个结构体数组的成员：</p>
<pre><code>s3c_nand_parts[0].name = &quot;bootloader_2&quot;
</code></pre>
<p>结构体数组的内存占用&#x3D;数组成员数*单个结构体内存占用。</p>
<h2 id="7-2结构体指针"><a href="#7-2结构体指针" class="headerlink" title="7.2结构体指针"></a>7.2结构体指针</h2><p>结构体指针本质是指针变量，其值是结构体的地址。<br>前面结构体重定义一节已经定义和初始化过结构体指针，需要注意的是，结构体指针的初始化值来源于结构体实例，结构体类型名只是标签，不代表结构体地址，注意和”数组名&#x3D;数组地址“区分。</p>
<pre><code>struct stu&#123;         
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;

struct stu *stu_p = stu;    //错，stu只是符号，不占内存
struct stu *stu_p = &amp;stu1;  //对，stu1是结构体实例，占内存  //对，stu1是stu实例变量，有内存占用
</code></pre>
<p>结构体指针的常见用途：malloc分配结构体空间</p>
<pre><code>stu_p =(stu_t *)malloc(sizeof(stu_t));  //分配结构体空间，返回地址给结构体指针
</code></pre>
<p>结构体指针最重要的用途：函数传参<br>结构体变量作为函数参数时传递的是整个结构体内存空间，也就是所有成员空间，而不是像数组一样被编译器转换成一个指针。如果结构体成员较多，传送的时间和空间开销会很大，影响程序的运行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。</p>
<h2 id="7-2结构体嵌套"><a href="#7-2结构体嵌套" class="headerlink" title="7.2结构体嵌套"></a>7.2结构体嵌套</h2><p>结构体嵌套是结构体的成员也是结构体。有两种情况：<br>1.成员是其他类型的结构体<br>2.成员是同类型的结构体</p>
<h3 id="7-2-1-嵌套其他类型"><a href="#7-2-1-嵌套其他类型" class="headerlink" title="7.2.1.嵌套其他类型"></a>7.2.1.嵌套其他类型</h3><p>在协议开发中，一个命令的数据可以用结构体来表达，在命令的内部又分为很多个数据域，每个数据域又用结构体来表达，因此需要结构体嵌套。对于同一块数据，根据命令的不同，解析为不同的结构体,因此存在多类命令公用一块数据域的情况，因此需要联合（Union）。以NVMe协议为例，结构体嵌套和联合一起使用的例子：</p>
<pre><code>typedef struct  //nvme命令结构体
&#123;
     union      //命令中dword10空间的联合
    &#123;
        u32 command_dw10;
        struct
        &#123;
            u32 cntid:16;   //16 bit位域
            u32 resv1:8;    //8 bit位域
            u32 cns:8;      //8 bit位域
        &#125;identify;          //当命令为identify时
        struct
        &#123;
            u32 save:1;
            u32 resv1:20;
            u32 select:3;
            u32 feature_identifier:8;
        &#125;get_features;      //当命令为get_featuresy时
        struct
        &#123;
            u32 queue_size:16;
            u32 queue_identifier:16;
        &#125;io_queue_create_delete_dw10;
        ...
    &#125;;
    
    union   //命令中dword11空间的联合
    &#123;
        u32 command_dw11;
        struct
        &#123;
            u32 completion:16;
            u32 submission:16;
        &#125;number_of_queues;
        struct
        &#123;
            u32 interrupt_vector:16;
            u32 resv1:14;
            u32 interrupt_enabled:1;
            u32 physically_contiguous:1;
        &#125;create_io_completion_queue_dw11;
        ...
    &#125;;
    
&#125;command_t, *command_p;
</code></pre>
<p>该例子结合了结构体、联合、位域。对每个nvme命令，多个联合并存在结构体command_t实例里，每个联合长度为一个dword(4字节)，分别表示dword0~15中的一个。对于dword内部，根据解析到命令的不同，作为不同含义处理，如解析为identify就按identify的结构体读写成员，如解析为get_features则按get_features的结构体读写成员。在结构体内部，用位域更精细控制这个dword内各bit的含义。</p>
<h3 id="7-2-2嵌套自身类型"><a href="#7-2-2嵌套自身类型" class="headerlink" title="7.2.2嵌套自身类型"></a>7.2.2嵌套自身类型</h3><p>结构体嵌套自身类型的典型应用：链表数据结构体</p>
<pre><code>typedef struct ListNode &#123;
    DataType data;          // 节点数据 
    struct ListNode *next;  // 指向下一个结点的指针 
&#125; ListNode_t;
</code></pre>
<p>这个结构体有两个成员：DataType类型的数据，和指向 struct ListNode类型(&#x3D;ListNode_t类型)的实例的指针。有多个ListNode_t类型的结构体被实例化且依次指向后续节点后，可以依次node1-&gt;next-&gt;next…-&gt;data访问链表中的节点数据。<br>注意：结构体体能嵌套自身类型的指针，而不能嵌套自身类型的实例。因为指针分配内存是定长（通常4字节），而循环嵌套结构体变量是无穷的。以下写法是错的</p>
<pre><code>typedef struct ListNode &#123;
    DataType data;           
    struct ListNode next;  // 错，嵌套的是实例 
&#125; ListNode_t;
</code></pre>
<h1 id="8-结构体高级用法：面向对象"><a href="#8-结构体高级用法：面向对象" class="headerlink" title="8.结构体高级用法：面向对象"></a>8.结构体高级用法：面向对象</h1><h2 id="8-1函数指针"><a href="#8-1函数指针" class="headerlink" title="8.1函数指针"></a>8.1函数指针</h2><p>程序中定义的函数，在编译时会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的入口地址。函数名表示的就是这个地址的值。可以定义一个指针变量来存放函数的入口地址，这个指针变量就叫作函数指针变量，简称函数指针。<br>这段话什么意思？<br>1.函数名&#x3D;函数入口地址<br>2.可以用指针变量的值取代函数名，函数的调用和该指针变量的调用等价<br>3.可以把这个指针变量当参数传递给别的函数，也可以把这个指针变量作为结构体的成员，总之，一切指针能做的，函数指针都能做。<br>函数指针的定义：</p>
<pre><code>返回值 函数入口地址(入参1的类型，入参2的类型，...)
int (*p)(int, int);     //p为函数指针，*p为入口地址
</code></pre>
<p>定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数。p 的类型为 int(*)(int，int)<br>函数指针的初始化：</p>
<pre><code>int Func(int x);   /*声明一个函数，包含入参名*/
int (*p) (int);  /*声明一个函数指针，只有入参类型*/
p = Func;         /*将Func函数的入口地址赋给指针变量p*/
</code></pre>
<p>函数指针作为结构体成员的调用如下</p>
<pre><code>struct&#123;
    int (* func)(int);
&#125;stu1, *stu1_p; //分配两个结构体实例：stu1结构体和指针stu1_p

stu1.func(10);  //通过结构体调用函数指针
stu1_p-&gt;func(10);   //通过结构体指针调用函数指针
</code></pre>
<h2 id="8-2回调函数"><a href="#8-2回调函数" class="headerlink" title="8.2回调函数"></a>8.2回调函数</h2><p>回调函数(Callback)就是一个通过函数指针调用的函数。把函数指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由函数的实现方直接调用，而是在特定的事件或条件发生时，由把它当参数的那个函数调用的，用于对该事件或条件进行响应。<br>回调的两个特点：<br>1.函数&#x3D;参数。函数A指针当参数传递B<br>2.异步。特定时间发生时，B才调用A指针指向的函数</p>
<h2 id="8-3结构体与面向对象"><a href="#8-3结构体与面向对象" class="headerlink" title="8.3结构体与面向对象"></a>8.3结构体与面向对象</h2><p>当函数指针作为结构体的成员，可以通过结构体实例调用成员函数，此时可以实现类似其他语言中“类”或“接口”的概念：<br>结构体声明&#x3D;类声明&#x3D;接口声明<br>结构体的函数指针成员&#x3D;类方法&#x3D;接口函数<br>结构体实例调用函数指针成员&#x3D;类实例调用方法&#x3D;接口的实现<br>这种设计思想在Linux内核和驱动框架中很常用。以字符设备驱动为例：<br>字符设备驱动顶层框架将所有字符操作函数作为接口在结构体file_operations中定义，在底层具体的设备驱动中实现file_operations的方法。底层驱动实例化file_operations结构体（分配内存），将各种操作的具体实现函数赋值给接口定义的函数，然后上报（注册）该file_operations实例给顶层驱动框架，顶层驱动框架接收到应用层的系统调用请求时，回调已注册的file_operations实例的函数。<br>上层驱动框架定义的字符文件操作接口如下，这些open、read、write作为文件操作的方法供应用层调用。</p>
<pre><code> struct file_operations &#123;   //字符文件操作的接口定义
　　struct module *owner;   //结构体指针
　　ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);      //函数指针read
　　ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);    //函数指针write
　　int (*open) (struct inode *, struct file *);    //函数指针open
　　int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);   //函数指针ioctl
　　...
&#125;;
</code></pre>
<p>而这些方法具体实现（内部做什么）是由底层驱动代码实现：</p>
<pre><code>static int my_drv_open(struct inode *inode, struct file *file)
&#123;
    //硬件寄存器操作A...
    return 0;
&#125;

static ssize_t my_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)
&#123;
    //硬件寄存器操作B...
    return 0;
&#125;
</code></pre>
<p>那么这些实现怎么关联接口：在底层驱动分配结构体实例，初始化函数指针为实现函数</p>
<pre><code>static struct file_operations my_drv_fops = &#123;
    .owner  =   THIS_MODULE,   
    .open   =   my_drv_open,   //open接口由my_drv_open函数实现  
    .write    =    my_drv_write,     //write接口由my_drv_write函数实现  
&#125;;
</code></pre>
<p>关联完了，上层驱动怎么调用：结构体指针传参+回调<br>my_drv_fops是file_operations的实例，上报给上层驱动，上层驱动有它自己的字符设备结构体cdev，取出my_drv_fops实例的.结构体指针fops的值，赋给cdev实例内的ops指针。之后它就能用ops调用my_drv_open、my_drv_write函数。</p>
<pre><code>//注册结构体
cdev-&gt;owner = fops-&gt;owner;
cdev-&gt;ops = fops;
//回调.open方法
cdev-&gt;ops-&gt;open(inode,file);
</code></pre>
<p>由于my_drv_write是值，open才是结构体成员，因此调用的时候看上去调用的是open函数，本质上执行的还是my_drv_write的流程。函数指针的回调能将接口名暴露，方法名隐藏。因此底层实现的函数名和上层驱动的调用函数名不相关，上层永远都可以用.open .read .write这些接口调用底层驱动，而底层函数可以随便改名（不能改入参出参类型，否则函数指针类型变了），这种特性都是函数指针决定的。<br>对于应用程序，是调用上层驱动提供的系统调用接口，还是如.open .read .write等接口。Linux驱动将设备抽象成了文件，驱动程序实现了文件的各种方法，所以对应用程序，打开文件&#x3D;打开设备，调用文件对应的接口&#x3D;调用设备驱动提供的接口。</p>
<pre><code>fd = open(&quot;/dev/xyz&quot;, O_RDWR);  //打开文件（设备）
read(fd, &amp;val, 1);  //读fd文件（设备）的值到val变量
</code></pre>
<p>除了C语言，在golang中也有类似的结构体+函数指针实现的面向对象方法。<br>NOTE:关于结构体中的函数指针写法易错点：<br>不包含变量名，只能使用基本类型</p>
<pre><code>   #一个结构体
   typedef stru&#123;    //定义结构体名
        int a;
        char b;
   &#125;stru_t, *stru_p; //重定义结构体变量和指针
    
    #普通函数声明
    int func(int a, stru_p p); //参数写类型且写值，可以使用typedef后的结构体指针类型
    
    #函数指针声明
    int (*func)(int, struct stru *);    //参数只写类型不写参数，只能使用C基本类型，不能使用typedef后的类型，只能写struct stru *类型
</code></pre>
<p>函数指针声明使用typedef后的类型名，编译器不认识，产生syntax error。    </p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux的Signal信号</title>
    <url>/2020/11/08/%E6%B5%85%E8%B0%88Linux%E7%9A%84Signal%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<p>本文将从以下几个方面来阐述信号:</p>
<p>(1) 信号的基本知识<br>(2) 信号生命周期与处理过程分析<br>(3) 基本的信号处理函数<br>(4) 保护临界区不被中断<br>(5) 信号的继承与执行<br>(6) 实时信号中锁的研究</p>
<h1 id="第一部分-信号的基本知识"><a href="#第一部分-信号的基本知识" class="headerlink" title="第一部分: 信号的基本知识"></a>第一部分: 信号的基本知识</h1><h2 id="1-信号本质"><a href="#1-信号本质" class="headerlink" title="1.信号本质:"></a>1.信号本质:</h2><p>信号的本质是软件层次上对中断的一种模拟。它是一种异步通信的处理机制，事实上，进程并不知道信号何时到来。</p>
<h2 id="2-信号来源"><a href="#2-信号来源" class="headerlink" title="2.信号来源"></a>2.信号来源</h2><p>(1)程序错误，如非法访问内存<br>(2)外部信号，如按下了CTRL+C<br>(3)通过kill或sigqueue向另外一个进程发送信号</p>
<h2 id="3-信号种类"><a href="#3-信号种类" class="headerlink" title="3.信号种类"></a>3.信号种类</h2><p>信号分为可靠信号与不可靠信号,可靠信号又称为实时信号，非可靠信号又称为非实时信号。<br>信号代码从1到32是不可靠信号,不可靠信号主要有以下问题:<br>(1)每次信号处理完之后，就会恢复成默认处理，这可能是调用者不希望看到的<br>(2)存在信号丢失的问题<br>现在的Linux对信号机制进行了改进，因此，不可靠信号主要是指信号丢失<br>信号代码从SIGRTMIN到SIGRTMAX之间的信号是可靠信号。可靠信号不存在丢失，由sigqueue发送，可靠信号支持排队。</p>
<p>可靠信号注册机制:<br>内核每收到一个可靠信号都会去注册这个信号，在信号的未决信号链中分配sigqueue结构，因此，不会存在信号丢失的问题。</p>
<p>不可靠信号的注册机制:<br>而对于不可靠的信号，如果内核已经注册了这个信号，那么便不会再去注册，对于进程来说，便不会知道本次信号的发生。<br>可靠信号与不可靠信号与发送函数没有关系，取决于信号代码，前面的32种信号就是不可靠信号，而后面的32种信号就是可靠信号。</p>
<h2 id="4-信号响应的方式"><a href="#4-信号响应的方式" class="headerlink" title="4.信号响应的方式"></a>4.信号响应的方式</h2><p>(1)采用系统默认处理SIG_DFL,执行缺省操作<br>(2)捕捉信号处理，即用户自定义的信号处理函数来处理<br>(3)忽略信号SIG_IGN ,但有两种信号不能被忽略SIGKILL，SIGSTOP</p>
<h1 id="第二部分-信号的生命周期与处理过程分析"><a href="#第二部分-信号的生命周期与处理过程分析" class="headerlink" title="第二部分: 信号的生命周期与处理过程分析"></a>第二部分: 信号的生命周期与处理过程分析</h1><h2 id="1-信号的生命周期"><a href="#1-信号的生命周期" class="headerlink" title="1. 信号的生命周期"></a>1. 信号的生命周期</h2><p>信号产生-&gt;信号注册－&gt;信号在进程中注销-&gt;信号处理函数执行完毕</p>
<p>(1)信号的产生是指触发信号的事件的发生</p>
<p>(2)信号注册<br>指的是在目标进程中注册，该目标进程中有未决信号的信息:</p>
<pre><code>struct sigpending pending：
struct sigpending&#123;
struct sigqueue *head, **tail;
sigset_t signal;
&#125;;

struct sigqueue&#123;
struct sigqueue *next;
siginfo_t info;
&#125;
</code></pre>
<p>其中 sigqueue结构组成的链称之为未决信号链，sigset_t称之为未决信号集。<br>*head,**tail分别指向未决信号链的头部与尾部。<br>siginfo_t info是信号所携带的信息。<br>信号注册的过程就是将信号值加入到未决信号集siginfo_t中，将信号所携带的信息加入到未决信号链的某一个sigqueue中去。<br> 因此，对于可靠的信号，可能存在多个未决信号的sigqueue结构，对于每次信号到来都会注册。而不可靠信号只注册一次，只有一个sigqueue结构。<br>只要信号在进程的未决信号集中，表明进程已经知道这些信号了，还没来得及处理，或者是这些信号被阻塞。</p>
<p>(3)信号在目标进程中注销<br> 在进程的执行过程中，每次从系统调用或中断返回用户空间的时候，都会检查是否有信号没有被处理。如果这些信号没有被阻塞，那么就调用相应的信号处理函数来处理这些信号。则调用信号处理函数之前，进程会把信号在未决信号链中的sigqueue结构卸掉。是否从未决信号集中把信号删除掉，对于实时信号与非实时信号是不相同的。<br>非实时信号:由于非实时信号在未决信号链中只有一个sigqueue结构，因此将它删除的同时将信号从未决信号集中删除。<br>实时信号:由于实时信号在未决信号链中可能有多个sigqueue结构，如果只有一个，也将信号从未决信号集中删除掉。如果有多个那么不从未决信号集中删除信号，注销完毕。</p>
<p>(4)信号处理函数执行完毕<br>执行处理函数，本次信号在进程中响应完毕。<br>在第4步，只简单的描述了信号处理函数执行完毕，就完成了本次信号的响应，但这个信号处理函数空间是怎么处理的呢? 内核栈与用户栈是怎么工作的呢? 这就涉及到了信号处理函数的过程。</p>
<h2 id="2-信号处理函数的过程"><a href="#2-信号处理函数的过程" class="headerlink" title="2. 信号处理函数的过程:"></a>2. 信号处理函数的过程:</h2><p>(1)注册信号处理函数<br>信号的处理是由内核来代理的，首先程序通过sigal或sigaction函数为每个信号注册处理函数，而内核中维护一张信号向量表，对应信号处理机制。这样，在信号在进程中注销完毕之后，会调用相应的处理函数进行处理。</p>
<p>(2)信号的检测与响应时机<br>在系统调用或中断返回用户态的前夕，内核会检查未决信号集，进行相应的信号处理。</p>
<p>(3)处理过程:<br>程序运行在用户态时-&gt;进程由于系统调用或中断进入内核-&gt;转向用户态执行信号处理函数-&gt;信号处理函数完毕后进入内核-&gt;返回用户态继续执行程序<br>首先程序执行在用户态，在进程陷入内核并从内核返回的前夕，会去检查有没有信号没有被处理，如果有且没有被阻塞就会调用相应的信号处理程序去处理。首先，内核在用户栈上创建一个层，该层中将返回地址设置成信号处理函数的地址，这样，从内核返回用户态时，就会执行这个信号处理函数。当信号处理函数执行完，会再次进入内核，主要是检测有没有信号没有处理，以及恢复原先程序中断执行点，恢复内核栈等工作，这样，当从内核返回后便返回到原先程序执行的地方了。<br>信号处理函数的过程大概是这样了。<br>具体的可参考<a href="http://www.spongeliu.com/linux/linux%E5%86%85%E6%A0%B8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/">http://www.spongeliu.com/linux/linux内核信号处理机制介绍/</a></p>
<h1 id="第三部分-基本的信号处理函数"><a href="#第三部分-基本的信号处理函数" class="headerlink" title="第三部分: 基本的信号处理函数"></a>第三部分: 基本的信号处理函数</h1><p>首先看一个两个概念: 信号未决与信号阻塞<br>信号未决: 指的是信号的产生到信号处理之前所处的一种状态。确切的说，是信号的产生到信号注销之间的状态。<br>信号阻塞: 指的是阻塞信号被处理，是一种信号处理方式。</p>
<h2 id="1-信号操作"><a href="#1-信号操作" class="headerlink" title="1. 信号操作"></a>1. 信号操作</h2><p> 信号操作最常用的方法是信号的屏蔽，信号屏蔽主要用到以下几个函数:</p>
<pre><code>int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set,int signo);
int sigdelset(sigset_t *set,int signo);
int sigismemeber(sigset_t* set,int signo);
int sigprocmask(int how,const sigset_t*set,sigset_t *oset);
</code></pre>
<p>信号集，信号掩码，未决集<br>信号集: 所有的信号阻塞函数都使用一个称之为信号集的结构表明其所受到的影响。<br>信号掩码:当前正在被阻塞的信号集。<br>未决集: 进程在收到信号时到信号在未被处理之前信号所处的集合称为未决集。<br>可以看出，这三个概念没有必然的联系，信号集指的是一个泛泛的概念，而未决集与信号掩码指的是具体的信号状态。</p>
<p>对于信号集的初始化有两种方法: 一种是用sigemptyset使信号集中不包含任何信号，然后用sigaddset把信号加入到信号集中去。<br>另一种是用sigfillset让信号集中包含所有信号，然后用sigdelset删除信号来初始化。<br>sigemptyset()函数初始化信号集set并将set设置为空。<br>sigfillset()函数初始化信号集，但将信号集set设置为所有信号的集合。<br>sigaddset()将信号signo加入到信号集中去。<br>sigdelset()从信号集中删除signo信号。<br>sigprocmask()将指定的信号集合加入到进程的信号阻塞集合中去。如果提供了oset,那么当前的信号阻塞集合将会保存到oset集全中去。<br>参数how决定了操作的方式:<br>SIG_BLOCK 增加一个信号集合到当前进程的阻塞集合中去<br>SIG_UNBLOCK 从当前的阻塞集合中删除一个信号集合<br>SIG_SETMASK 将当前的信号集合设置为信号阻塞集合</p>
<p>下面看一个例子:</p>
<pre><code>int main()&#123;
    sigset_t initset;
    int i;
    sigemptyset(&amp;initset);//初始化信号集合为空集合
    sigaddset(&amp;initset,SIGINT);//将SIGINT信号加入到此集合中去
    while(1)&#123;
        sigprocmask(SIG_BLOCK,&amp;initset,NULL);//将信号集合加入到进程的阻塞集合中去
        fprintf(stdout,&quot;SIGINT singal blocked/n&quot;);
        for(i=0;i&lt;10;i++)&#123;
        
            sleep(1);//每1秒输出
            fprintf(stdout,&quot;block %d/n&quot;,i);
        &#125;
        //在这时按一下Ctrl+C不会终止
        sigprocmask(SIG_UNBLOCK,&amp;initset,NULL);//从进程的阻塞集合中去删除信号集合
        fprintf(stdout,&quot;SIGINT SINGAL unblokced/n&quot;);
        for(i=0;i&lt;10;i++)&#123;
            sleep(1);
            fprintf(stdout,&quot;unblock %d/n&quot;,i);
        &#125;
    &#125;
    exit(0);
&#125;
</code></pre>
<p>执行结果:</p>
<pre><code>SIGINT singal blocked
block 0
block 1
block 2
block 3
block 4
block 5
block 6
block 7
block 8
block 9
</code></pre>
<p>在执行到block 3时按下了CTRL+C并不会终止，直到执行到block9后将集合从阻塞集合中移除。</p>
<pre><code>[root@localhost C]# ./s1
SIGINT singal blocked
block 0
block 1
block 2
block 3
block 4
block 5
block 6
block 7
block 8
block 9
SIGINT SINGAL unblokced
unblock 0
unblock 1
</code></pre>
<p>由于此时已经解除了阻塞，在unblock1后按下CTRL+C则立即终止。</p>
<h2 id="2-信号处理函数"><a href="#2-信号处理函数" class="headerlink" title="2. 信号处理函数"></a>2. 信号处理函数</h2><p>sigaction</p>
<pre><code>int sigaction(
    int signo,
    const struct sigaction *act,
    struct sigaction *oldact
);
</code></pre>
<p>这个函数主要是用于改变或检测信号的行为。<br>第一个参数是变更signo指定的信号，它可以指向任何值，SIGKILL,SIGSTOP除外<br>第二个参数,第三个参数是对信号进行细粒度的控制。<br>如果<em>act不为空，</em>oldact不为空，那么oldact将会存储信号以前的行为。如果act为空，*oldact不为空，那么oldact将会存储信号现在的行为。</p>
<pre><code>struct sigaction &#123;
    void (*sa_handler)(int);
    void (*sa_sigaction)(int,siginfo_t*,void*);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
&#125;
</code></pre>
<p>参数含义:<br>sa_handler是一个函数指针，主要是表示接收到信号时所要采取的行动。此字段的值可以是SIG_DFL,SIG_IGN.分别代表默认操作与内核将忽略进程的信号。这个函数只传递一个参数那就是信号代码。<br>当SA_SIGINFO被设定在sa_flags中，那么则会使用sa_sigaction来指示信号处理函数，而非sa_handler.<br>sa_mask设置了掩码集，在程序执行期间会阻挡掩码集中的信号。<br>sa_flags设置了一些标志， SA_RESETHAND当该函数处理完成之后，设定为为系统默认的处理模式。SA_NODEFER 在处理函数中，如果再次到达此信号时，将不会阻塞。默认情况下，同一信号两次到达时，如果此时处于信号处理程序中，那么此信号将会阻塞。<br>SA_SIGINFO表示用sa_sigaction指示的函数。<br>sa_restorer已经被废弃。</p>
<p>sa_sigaction所指向的函数原型:</p>
<pre><code>void my_handler(int signo,siginfo_t *si,void *ucontext);
</code></pre>
<p>第一个参数: 信号编号<br>第二个参数:指向一个siginfo_t结构。<br>第三个参数是一个ucontext_t结构。<br>其中siginfo_t结构体中包含了大量的信号携带信息，可以看出，这个函数比sa_handler要强大，因为前者只能传递一个信号代码，而后者可以传递siginfo_t信息。</p>
<pre><code>typedef struct siginfo_t&#123;
    int si_signo;//信号编号
    int si_errno;//如果为非零值则错误代码与之关联
    int si_code;//说明进程如何接收信号以及从何处收到
    pid_t si_pid;//适用于SIGCHLD，代表被终止进程的PID
    pid_t si_uid;//适用于SIGCHLD,代表被终止进程所拥有进程的UID
    int si_status;//适用于SIGCHLD，代表被终止进程的状态
    clock_t si_utime;//适用于SIGCHLD，代表被终止进程所消耗的用户时间
    clock_t si_stime;//适用于SIGCHLD，代表被终止进程所消耗系统的时间
    sigval_t si_value;
    int si_int;
    void * si_ptr;
    void* si_addr;
    int si_band;
    int si_fd;
&#125;;
</code></pre>
<p>sigqueue</p>
<pre><code>sigqueue(pid_t pid,int signo,const union sigval value)
</code></pre>
<p>sigqueue函数类似于kill,也是一个进程向另外一个进程发送信号的。<br>但它比kill函数强大。<br>第一个参数指定目标进程的pid.<br>第二个参数是一个信号代码。<br>第三个参数是一个共用体，每次只能使用一个，用来进程发送信号传递的数据。<br>或者传递整形数据，或者是传递指针。<br>发送的数据被sa_sigaction所指示的函数的siginfo_t结构体中的si_ptr或者是si_int所接收。</p>
<p>sigpending</p>
<pre><code>sigpending(sigset_t set);
</code></pre>
<p>这个函数的作用是返回未决的信号到信号集set中。即未决信号集，未决信号集不仅包括被阻塞的信号，也可能包括已经到达但没有被处理的信号。</p>
<h2 id="示例1-sigaction函数的用法"><a href="#示例1-sigaction函数的用法" class="headerlink" title="示例1: sigaction函数的用法"></a>示例1: sigaction函数的用法</h2><pre><code>void signal_set(struct sigaction *act)
&#123;
switch(act-&gt;sa_flags)&#123;
    case (int)SIG_DFL:
        printf(&quot;using default hander/n&quot;);
        break;
    case (int)SIG_IGN:
        printf(&quot;ignore the signal/n&quot;);
        break;
    default:
        printf(&quot;%0x/n&quot;,act-&gt;sa_handler);
    &#125;
&#125;
void signal_set1(int x)&#123;//信号处理函数
    printf(&quot;xxxxx/n&quot;);
    while(1)&#123;&#125;
&#125;

int main(int argc,char** argv)
&#123;
    int i;
    struct sigaction act,oldact;
    act.sa_handler = signal_set1;
    act.sa_flags = SA_RESETHAND;
    //SA_RESETHANDD 在处理完信号之后，将信号恢复成默认处理
    //SA_NODEFER在信号处理程序执行期间仍然可以接收信号
    sigaction (SIGINT,&amp;act,&amp;oldact) ;//改变信号的处理模式
    for (i=1; i&lt;12; i++)
    &#123;
        printf(&quot;signal %d handler is : &quot;,i);
        sigaction (i,NULL,&amp;oldact) ;
        signal_set(&amp;oldact);//如果act为NULL，oldact会存储信号当前的行为
        //act不为空，oldact不为空，则oldact会存储信号以前的处理模式
    &#125;
    while(1)&#123;
        //等待信号的到来
    &#125;
    return 0;
&#125;
</code></pre>
<p>运行结果:</p>
<pre><code>[root@localhost C]# ./s2
signal 1 handler is : using default hander
signal 2 handler is : 8048437
signal 3 handler is : using default hander
signal 4 handler is : using default hander
signal 5 handler is : using default hander
signal 6 handler is : using default hander
signal 7 handler is : using default hander
signal 8 handler is : using default hander
signal 9 handler is : using default hander
signal 10 handler is : using default hander
signal 11 handler is : using default hander
xxxxx
</code></pre>
<p>解释:</p>
<pre><code>sigaction(i,NULL,&amp;oldact);
signal_set(&amp;oldact);
</code></pre>
<p>由于act为NULL,那么oldact保存的是当前信号的行为，当前的第二个信号的行为是执行自定义的处理程序。<br>当按下CTRL＋C时会执行信号处理程序，输出xxxxxx，再按一下CTRL＋C会停止,是由于SA_RESETHAND恢复成默认的处理模式，即终止程序。<br>如果没有设置SA_NODEFER,那么在处理函数执行过程中按一下CTRL＋C将会被阻塞，那么程序会停在那里。</p>
<h2 id="示例2-sigqueue向本进程发送数据的信号"><a href="#示例2-sigqueue向本进程发送数据的信号" class="headerlink" title="示例2: sigqueue向本进程发送数据的信号"></a>示例2: sigqueue向本进程发送数据的信号</h2><pre><code>int main()&#123;
    union sigval val;//定义一个携带数据的共用体
    struct sigaction oldact,act;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO;//表示使用sa_sigaction指示的函数，处理完恢复默认，不阻塞处理过程中到达下在被处理的信号
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;act,&amp;oldact);
    char data[100];
    int num=0;
    while(num&lt;10)&#123;
        sleep(2);
        printf(&quot;等待SIGUSR1信号的到来/n&quot;);
        sprintf(data,&quot;%d&quot;,num++);
        val.sival_ptr=data;
        sigqueue(getpid(),SIGUSR1,val);//向本进程发送一个信号
    &#125;
&#125;

void myhandler(int signo,siginfo_t *si,void *ucontext)&#123;
    printf(&quot;已经收到SIGUSR1信号/n&quot;);
    printf(&quot;%s/n&quot;,(char*)(si-&gt;si_ptr));
&#125;
</code></pre>
<p>程序执行的结果是:</p>
<pre><code>等待SIGUSR1信号的到来
已经收到SIGUSR1信号
0
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
1
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
2
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
3
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
4
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
5
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
6
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
7
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
8
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
9
</code></pre>
<p>解释: 本程序用sigqueue不停的向自身发送信号,并且携带数据，数据被放到处理函数的第二个参数siginfo_t结构体中的si_ptr指针，当num&lt;10时不再发。</p>
<p>一般而言，sigqueue与sigaction配合使用，而kill与signal配合使用。</p>
<h2 id="示例3-一个进程向另外一个进程发送信号，并携带信息"><a href="#示例3-一个进程向另外一个进程发送信号，并携带信息" class="headerlink" title="示例3: 一个进程向另外一个进程发送信号，并携带信息"></a>示例3: 一个进程向另外一个进程发送信号，并携带信息</h2><p>发送端:</p>
<pre><code>int main()&#123;
    union sigval value;
    value.sival_int=10;
    
    if(sigqueue(4403,SIGUSR1,value)==-1)&#123;//4403是目标进程pid
        perror(&quot;信号发送失败/n&quot;);
    &#125;
    sleep(2);
&#125;
</code></pre>
<p>接收端:</p>
<pre><code>int main()&#123;
    struct sigaction oldact,act;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO|SA_NODEFER;
    //表示执行后恢复，用sa_sigaction指示的处理函数，在执行期间仍然可以接收信号
    sigaction(SIGUSR1,&amp;act,&amp;oldact);
    while(1)&#123;
        sleep(2);
        printf(&quot;等待信号的到来/n&quot;);
    &#125;
&#125;

void myhandler(int signo,siginfo_t *si,void *ucontext)&#123;
    printf(&quot;the value is %d/n&quot;,si-&gt;si_int);
&#125;
</code></pre>
<h2 id="示例4-sigpending的用法"><a href="#示例4-sigpending的用法" class="headerlink" title="示例4: sigpending的用法"></a>示例4: sigpending的用法</h2><p>sigpending(sigset_t *set)将未决信号放到指定的set信号集中去，未决信号包括被阻塞的信号和信号到达时但还没来得及处理的信号</p>
<pre><code>int main()&#123;
    struct sigaction oldact,act;
    sigset_t oldmask,newmask,pendingmask;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO;
    sigemptyset(&amp;act.sa_mask);//首先将阻塞集合设置为空，即不阻塞任何信号
    //注册信号处理函数
    sigaction(SIGRTMIN+10,&amp;act,&amp;oldact);
    //开始阻塞
    sigemptyset(&amp;newmask);
    sigaddset(&amp;newmask,SIGRTMIN+10);
    printf(&quot;SIGRTMIN+10 blocked/n&quot;);
    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask);
    sleep(20);//为了发出信号
    printf(&quot;now begin to get pending mask/n&quot;);
    if(sigpending(&amp;pendingmask)&lt;0)&#123;
        perror(&quot;pendingmask error&quot;);
    &#125;
    if(sigismember(&amp;pendingmask,SIGRTMIN+10))&#123;
        printf(&quot;SIGRTMIN+10 is in the pending mask/n&quot;);
    &#125;
    
    sigprocmask(SIG_UNBLOCK,&amp;newmask,&amp;oldmask);
    printf(&quot;SIGRTMIN+10 unblocked/n&quot;);
&#125;
//信号处理函数
void myhandler(int signo,siginfo_t *si,void *ucontext)&#123;
    printf(&quot;receive signal %d/n&quot;,si-&gt;si_signo);
&#125;
</code></pre>
<p>程序执行,在另一个shell发送信号:</p>
<pre><code> kill -44 4579

SIGRTMIN+10 blocked
now begin to get pending mask
SIGRTMIN+10 is in the pending mask
receive signal 44
SIGRTMIN+10 unblocked
</code></pre>
<p>可以看到SIGRTMIN由于被阻塞所以处于未决信号集中。<br>关于基本的信号处理函数就介绍到这了。</p>
<h1 id="第四部分-保护临界区不被中断"><a href="#第四部分-保护临界区不被中断" class="headerlink" title="第四部分: 保护临界区不被中断"></a>第四部分: 保护临界区不被中断</h1><h2 id="1-函数的可重入性"><a href="#1-函数的可重入性" class="headerlink" title="1. 函数的可重入性"></a>1. 函数的可重入性</h2><p>函数的可重入性是指可以多于一个任务并发使用函数，而不必担心数据错误。相反，不可重入性是指不能多于一个任务共享函数，除非能保持函数互斥(或者使用信号量，或者在代码的关键部分禁用中断)。可重入函数可以在任意时刻被中断，稍后继续执行，而不会丢失数据。</p>
<p>可重入函数：</p>
<ul>
<li>不为连续的调用持有静态数据。</li>
<li>不返回指向静态数据的指针；所有数据都由函数的调用者提供。</li>
<li>使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。</li>
<li>绝不调用任何不可重入函数。</li>
</ul>
<p>不可重入函数可能导致混乱现象，如果当前进程的操作与信号处理程序同时对一个文件进行写操作或者是调用malloc()，那么就可能出现混乱，当从信号处理程序返回时，造成了状态不一致。从而引发错误。<br>因此，信号的处理必须是可重入函数。<br>简单的说，可重入函数是指在一个程序中调用了此函数，在信号处理程序中又调用了此函数，但仍然能够得到正确的结果。<br>printf，malloc函数都是不可重入函数。printf函数如果打印缓冲区一半时，又有一个printf函数，那么此时会造成混乱。而malloc函数使用了系统全局内存分配表。</p>
<h2 id="2-保护临界区不被中断"><a href="#2-保护临界区不被中断" class="headerlink" title="2. 保护临界区不被中断"></a>2. 保护临界区不被中断</h2><p>由于临界区的代码是关键代码，是非常重要的部分，因此，有必要对临界区进行保护，不希望信号来中断临界区操作。这里通过信号屏蔽字来阻塞信号的发生。</p>
<p> 下面介绍两个与保护临界区不被信号中断的相关函数。</p>
<pre><code>int pause(void);
int sigsuspend(const sigset_t *sigmask);
</code></pre>
<p>pause函数挂起一个进程，直到一个信号发生。</p>
<p>sigsuspend函数的执行过程如下:<br>(1)设置新的mask去阻塞当前进程<br>(2)收到信号，调用信号的处理函数<br>(3)将mask设置为原先的掩码<br>(4)sigsuspend函数返回</p>
<p>可以看出，sigsuspend函数是等待一个信号发生，当等待的信号发生时，执行完信号处理函数后就会返回。它是一个原子操作。</p>
<p>保护临界区的中断:<br>(1)首先用sigprocmask去阻塞信号<br>(2)执行后关键代码后,用sigsuspend去捕获信号<br>(3)然后sigprocmask去除阻塞<br>这样信号就不会丢失了，而且不会中断临界区。</p>
<p>上面的程序是用pause去保护临界区，首先用sigprocmask去阻塞SIGINT信号，执行临界区代码，然后解除阻塞。最后调用pause()函数等待信号的发生。但此时会产生一个问题，如果信号在解除阻塞与pause之间发生的话，信号就可能丢失。这将是一个不可靠的信号机制。<br>因此，采用sigsuspend可以避免上述情况发生。</p>
<p>sigsuspend函数的用法：<br>sigsuspend函数是等待的信号发生时才会返回。<br>sigsuspend函数遇到结束时不会返回，这一点很重要。</p>
<p>示例:</p>
<p>下面的例子能够处理信号SIGUSR1,SIGUSR2,SIGSEGV,其它的信号被屏蔽，该程序输出对应的信号，然后继续等待其它信号的出现。</p>
<pre><code>void myhandler(int signo);
int main()&#123;
    struct sigaction action;
    sigset_t sigmask;
    sigemptyset(&amp;sigmask);
    sigaddset(&amp;sigmask,SIGUSR1);
    sigaddset(&amp;sigmask,SIGUSR2);
    sigaddset(&amp;sigmask,SIGSEGV);
    action.sa_handler=myhandler;
    action.sa_mask=sigmask;
    sigaction(SIGUSR1,&amp;action,NULL);
    sigaction(SIGUSR2,&amp;action,NULL);
    sigaction(SIGSEGV,&amp;action,NULL);
    sigfillset(&amp;sigmask);
    sigdelset(&amp;sigmask,SIGUSR1);
    sigdelset(&amp;sigmask,SIGUSR2);
    sigdelset(&amp;sigmask,SIGSEGV);
    while(1)&#123;
        sigsuspend(&amp;sigmask);//不断的等待信号到来
    &#125;
    return 0;
&#125;
    
void myhandler(int signo)&#123;
    switch(signo)&#123;
        case SIGUSR1:
            printf(&quot;received sigusr1 signal./n&quot;);
        break ;
        case SIGUSR2:
            printf(&quot;received sigusr2 signal./n&quot;);
        break;
        case SIGSEGV:
            printf(&quot;received sigsegv signal/n&quot;);
        break;
    &#125;
&#125;
</code></pre>
<p>程序运行结果:</p>
<pre><code>received sigusr1 signal
received sigusr2 signal
received sigsegv signal
received sigusr1 signal
已终止
</code></pre>
<p>另一个终端用于发送信号:<br>先得到当前进程的pid, ps aux|grep 程序名</p>
<pre><code>kill -SIGUSR1 4901
kill -SIGUSR2 4901
kill -SIGSEGV 4901
kill -SIGTERM 4901
kill -SIGUSR1  4901
</code></pre>
<p>解释:<br>第一行发送SIGUSR1，则调用信号处理函数，打印出结果。<br>第二，第三行分别打印对应的结果。<br>第四行发送一个默认处理为终止进程的信号。<br>但此时，但不会终止程序，由于sigsuspend遇到终止进程信号并不会返回，此时并不会打印出”已终止”，这个信号被阻塞了。当再次发送SIGURS1信号时，进程的信号阻塞恢复成默认的值，因此，此时将会解除阻塞SIGTERM信号，所以进程被终止。</p>
<h1 id="第五部分-信号的继承与执行"><a href="#第五部分-信号的继承与执行" class="headerlink" title="第五部分: 信号的继承与执行"></a>第五部分: 信号的继承与执行</h1><p>当使用fork()函数时，子进程会继承父进程完全相同的信号语义，这也是有道理的，因为父子进程共享一个地址空间，所以父进程的信号处理程序也存在于子进程中。</p>
<p>示例: 子进程继承父进程的信号处理函数</p>
<pre><code>void myhandler(int signo,siginfo_t *si,void *vcontext);
int main()&#123;
    union sigval val;
    struct sigaction oldact,newact;
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO|SA_RESETHAND;//表示采用sa_sigaction指示的函数以及执行完处理函数后恢复默认操作
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    
    if(fork()==0)&#123;
        val.sival_int=10;
        printf(&quot;子进程/n&quot;);
        sigqueue(getpid(),SIGUSR1,val);
    &#125;
    else &#123;
        val.sival_int=20;
        printf(&quot;父进程/n&quot;);
        sigqueue(getpid(),SIGUSR1,val);
    &#125;
&#125;

void myhandler(int signo,siginfo_t *si,void *vcontext)&#123;
    printf(&quot;信号处理/n&quot;);
    printf(&quot;%d/n&quot;,(si-&gt;si_int));
&#125;
</code></pre>
<p>输出的结果为:</p>
<pre><code>子进程
信号处理
10
父进程
信号处理
20
</code></pre>
<p>可以看出来，子进程继承了父进程的信号处理函数。</p>
<h1 id="第六部分-实时信号中锁的研究"><a href="#第六部分-实时信号中锁的研究" class="headerlink" title="第六部分: 实时信号中锁的研究"></a>第六部分: 实时信号中锁的研究</h1><h2 id="1-信号处理函数与主函数之间的死锁"><a href="#1-信号处理函数与主函数之间的死锁" class="headerlink" title="1. 信号处理函数与主函数之间的死锁"></a>1. 信号处理函数与主函数之间的死锁</h2><p>当主函数访问临界资源时，通常需要加锁，如果主函数在访问临界区时，给临界资源上锁，此时发生了一个信号，那么转入信号处理函数，如果此时信号处理函数也对临界资源进行访问，那么信号处理函数也会加锁，由于主程序持有锁，信号处理程序等待主程序释放锁。又因为信号处理函数已经抢占了主函数，因此，主函数在信号处理函数结束之前不能运行。因此，必然造成死锁。</p>
<p>示例1: 主函数与信号处理函数之间的死锁</p>
<pre><code>int value=0;
sem_t sem_lock;//定义信号量
void myhandler(int signo,siginfo_t *si,void *vcontext);//进程处理函数声明
int main()&#123;
    union sigval val;
    val.sival_int=1;
    struct sigaction oldact,newact;
    int res;
    res=sem_init(&amp;sem_lock,0,1);
    if(res!=0)&#123;
        perror(&quot;信号量初始化失败&quot;);
    &#125;
    
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    sem_wait(&amp;sem_lock);
    printf(&quot;xxxx/n&quot;);
    value=1;
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);//sigqueue发送带参数的信号
    sem_post(&amp;sem_lock);
    sleep(10);
    exit(0);
&#125;

void myhandler(int signo,siginfo_t *si,void *vcontext)&#123;
    sem_wait(&amp;sem_lock);
    value=0;
    sem_post(&amp;sem_lock);
&#125;
</code></pre>
<p>此程序将一直阻塞在信号处理函数的sem_wait函数处。</p>
<h2 id="2-利用测试锁解决死锁"><a href="#2-利用测试锁解决死锁" class="headerlink" title="2. 利用测试锁解决死锁"></a>2. 利用测试锁解决死锁</h2><p>sem_trywait(&amp;sem_lock);是非阻塞的sem_wait,如果加锁失败或者是超时，则返回－1。<br>示例2: 用sem_trywait来解决死锁</p>
<pre><code>int value=0;
sem_t sem_lock;//定义信号量
void myhandler(int signo,siginfo_t *si,void *vcontext);//进程处理函数声明
int main()&#123;
    union sigval val;
    val.sival_int=1;
    struct sigaction oldact,newact;
    int res;
    res=sem_init(&amp;sem_lock,0,1);
    if(res!=0)&#123;
        perror(&quot;信号量初始化失败&quot;);
    &#125;
    
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    sem_wait(&amp;sem_lock);
    printf(&quot;xxxx/n&quot;);
    value=1;
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);//sigqueue发送带参数的信号
    sem_post(&amp;sem_lock);
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);
    exit(0);
&#125;

void myhandler(int signo,siginfo_t *si,void *vcontext)&#123;
    if(sem_trywait(&amp;sem_lock)==0)&#123;
        value=0;
        sem_post(&amp;sem_lock);
    &#125;
&#125;
</code></pre>
<p>第一次发送sigqueue时，由于主函数持有锁，因此，sem_trywait返回－1，当第二次发送sigqueue时，主函数已经释放锁，此时就可以在信号处理函数中对临界资源加锁了。<br>但这种方法明显丢失了一个信号，不是很好的解决方法。</p>
<h2 id="3-利用双线程来解决主函数与信号处理函数死锁"><a href="#3-利用双线程来解决主函数与信号处理函数死锁" class="headerlink" title="3. 利用双线程来解决主函数与信号处理函数死锁"></a>3. 利用双线程来解决主函数与信号处理函数死锁</h2><p>我们知道，当进程收到一个信号时，会选择其中的某个线程进行处理，前提是这个线程没有屏蔽此信号。因此，可以在主线程中屏蔽信号，另选一个线程去处理这个信号。由于主线程与另外一个线程是平行执行的，因此，等待主线程执行完临界区时，释放锁，这个线程去执行信号处理函数，直到执行完毕释放临界资源。</p>
<p>这里用到一个线程的信号处理函数: pthread_sigmask</p>
<pre><code>int pthread_sigmask(int how,const sigset_t *set,sigset_t *oldset);
</code></pre>
<p>这个函数与sigprocmask很相似。<br>how的取值:<br>SIG_BLOCK 将信号集加入到线程的阻塞集中去<br>SIG_UNBLOCK 将信号集从阻塞集中删除<br>SIG_SETMASK 将当前集合设置为线程的阻塞集</p>
<p>示例: 利用双线程来解决主函数与信号处理函数之间的死锁</p>
<pre><code>void*thread_function(void *arg);//线程处理函数
void myhandler(int signo,siginfo_t *si,void *vcontext);//信号处理函数
int value;
sem_t semlock;
int main()&#123;
    int res;
    pthread_t mythread;
    void *thread_result;
    res=pthread_create(&amp;mythread,NULL,thread_function,NULL);//创建一个子线程
    if(res!=0)&#123;
        perror(&quot;线程创建失败&quot;);
    &#125;

    //在主线程中将信号屏蔽
    sigset_t empty;
    sigemptyset(&amp;empty);
    sigaddset(&amp;empty,SIGUSR1);
    pthread_sigmask(SIG_BLOCK,&amp;empty,NULL);

    //主线程中对临界资源的访问
    if(sem_init(&amp;semlock,0,1)!=0)&#123;
        perror(&quot;信号量创建失败&quot;);
    &#125;
    sem_wait(&amp;semlock);
    printf(&quot;主线程已经执行/n&quot;);
    value=1;
    sleep(10);
    sem_post(&amp;semlock);
    res=pthread_join(mythread,&amp;thread_result);//等待子线程退出
    exit(EXIT_SUCCESS);
&#125;

void *thread_function(void *arg)&#123;
    struct sigaction oldact,newact;
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    union sigval val;
    val.sival_int=1;
    printf(&quot;子线程睡眠3秒/n&quot;);
    sleep(3);
    sigqueue(getpid(),SIGUSR1,val);
    pthread_exit(0);//线程结束
&#125;

void myhandler(int signo,siginfo_t *si,void *vcontext)&#123;
    sem_wait(&amp;semlock);
    value=0;
    printf(&quot;信号处理完毕/n&quot;);
    sem_post(&amp;semlock);
&#125;
</code></pre>
<p>运行结果如下:</p>
<pre><code>主线程已经执行
子线程睡眠3秒
信号处理完毕
</code></pre>
<p>解释一下:<br>在主线线程中阻塞了SIGUSR1信号,首先让子线程睡眠3秒，目的让主线程先运行，然后当主线程访问临界资源时，让线程sleep(10),在这期间，子线程发送信号，此时子线程会去处理信号，而主线程依旧平行的运行，子线程被阻止信号处理函数的sem_wait处，等待主线程10后，信号处理函数得到锁，然后进行临界资源的访问。这就解决了主函数与信号处理函数之间的死锁问题。</p>
<p>扩展: 如果有多个信号到达时，还可以用多线程来处理多个信号，从而达到并行的目的，这个很好实现的，可以尝试一下。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux网络编程: IO多路复用之select、poll、epoll</title>
    <url>/2020/12/07/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>I&#x2F;O多路复用：通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<p>但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>IO多路复用适用如下场合：</p>
<ul>
<li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li>
</ul>
<p>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p>
<h1 id="select实现"><a href="#select实现" class="headerlink" title="select实现"></a>select实现</h1><p>逻辑时序：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401453.png" alt="1"><br>具体实现：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401118.png" alt="2"></p>
<p>fd_set(监听的端口个数)：32位机默认是1024个，64位机默认是2048。</p>
<p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间<br>（2）注册回调函数__pollwait<br>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）<br>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。<br>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。<br>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。<br>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。<br>（8）把fd_set从内核空间拷贝到用户空间。</p>
<p>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024</p>
<h1 id="poll实现"><a href="#poll实现" class="headerlink" title="poll实现"></a>poll实现</h1><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，而使其没有连接数的限制。其他的都差不多。</p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401522.png" alt="3"></p>
<h2 id="epoll的几大改进"><a href="#epoll的几大改进" class="headerlink" title="epoll的几大改进"></a>epoll的几大改进</h2><p>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。<br>每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中。<br>而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。即epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关。</p>
<p>对于第三个缺点，epoll没有这个限制。<br>它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看,一般来说这个数目和系统内存关系很大。</p>
<h2 id="epoll小结："><a href="#epoll小结：" class="headerlink" title="epoll小结："></a>epoll小结：</h2><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。<br>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<h1 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h1><ol>
<li><p>支持一个进程所能打开的最大连接数<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051402990.png" alt="4"></p>
</li>
<li><p>FD剧增后带来的IO效率问题<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051402536.png" alt="5"></p>
</li>
<li><p>消息传递方式<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051403370.png"></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p>
<ul>
<li>连接数多，活跃链接占比不高的场景下，epoll的性能最好</li>
<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>
<li>select低效是因为每次它都需要轮询。但低效也是相对的，可通过良好的设计改善。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux网络编程: Socket基础</title>
    <url>/2020/10/30/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Socket%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="套接字（socket）基础"><a href="#套接字（socket）基础" class="headerlink" title="套接字（socket）基础"></a>套接字（socket）基础</h1><p>套接字是网络编程中，应用层和传输层之间的数据结构，其作用如下:<br>应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字(Socket)的接口，以区分不同应用程序进程间的网络通信和连接。</p>
<h1 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h1><p>通用套接字地址的结构体sockaddr定义如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411648.png" alt="1"><br>在以太网中，不直接使用sockaddr结构体，而使用sockaddr_in,其定义如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411109.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411045.png" alt="3"></p>
<p>通用结构体sockaddr和以太网的sockaddr_in结构体，有点像C++中的父类和子类的关系，sockaddr_in是对sockaddr的细化，其存储结构大小相同，分布如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411360.png" alt="4"><br>由于大小相同，在设置socket地址时，一般先设置sockaddr_in结构体，然后强转为sockaddr类型</p>
<h1 id="套接字地址结构在用户层和内核层的交互"><a href="#套接字地址结构在用户层和内核层的交互" class="headerlink" title="套接字地址结构在用户层和内核层的交互"></a>套接字地址结构在用户层和内核层的交互</h1><p>sockaddr的使用，以socket流程中的bind()函数为例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411733.png" alt="5"><br>bind函数需要传入sockaddr结构体的指针，和sockaddr结构体的长度</p>
<h2 id="向内核传入数据"><a href="#向内核传入数据" class="headerlink" title="向内核传入数据"></a>向内核传入数据</h2><p>向内核传入数据的socket函数有：bind,send<br>传入过程如下：</p>
<ul>
<li>sockaddr结构体的长度，以传值方式传入内核</li>
<li>内核通过sockaddr结构体的指针以及结构体长度，以内存复制的方式，从用户层拷贝sockaddr结构体到内核层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411951.png" alt="6"></p>
<h2 id="从内核获取数据"><a href="#从内核获取数据" class="headerlink" title="从内核获取数据"></a>从内核获取数据</h2><p>从内核得到数据的socket函数有：accept,recv</p>
<ul>
<li>sockaddr结构体的长度，以传值方式传入内核</li>
<li>内核通过sockaddr结构体的指针以及结构体长度，以内存复制的方式，从内核层拷贝sockaddr结构体到用户层。</li>
<li>内核返回内核的结构体的长度<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412551.png" alt="7"><h1 id="Socket编程流程"><a href="#Socket编程流程" class="headerlink" title="Socket编程流程"></a>Socket编程流程</h1><h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2>TCP编程主要为C&#x2F;S模式，即服务器和客户端编程，我们讲socket编程，要区分是服务器端的流程还是客户端的流程。</li>
<li>服务器端：创建服务-等待客户端连接-收到连接请求-处理</li>
<li>客户端：发起对服务器的连接请求-根据服务器的响应做处理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412551.png"></p>
<p>服务端各函数含义:</p>
<ul>
<li>socket：套接字初始化</li>
<li>bind：绑定套接字和端口</li>
<li>listen：配置服务器的请求队列，监测连接请求</li>
<li>accept：接受客户端连接</li>
<li>read&#x2F;write：数据的接收、发送</li>
<li>close：断开连接，释放套接字</li>
</ul>
<p>客户端函数：</p>
<ul>
<li>客户端套接字不需要绑定端口和监听，直接connect发起连接请求，其他函数和服务端一致。</li>
</ul>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>socket函数用于创建socket套接字的文件描述符，</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412223.png" alt="9"></p>
<p>有三个入参：</p>
<ul>
<li>domain：域，区分本地，IPV4 Internet，IPV6 Internet等。有的以PF开头，有的以AF开头，这两者值一样。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412180.png" alt="10"></p>
<ul>
<li>type：通信类型，如流式（TCP）,数据报式（UDP）等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412975.png" alt="11"></p>
<ul>
<li>protocal：协议类型，指定通信类型中的子类型，一般为0</li>
</ul>
<p>socket套接字初始化的一个例子：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412776.png" alt="12"></p>
<h2 id="socket函数在应用层和内核层的交互"><a href="#socket函数在应用层和内核层的交互" class="headerlink" title="socket函数在应用层和内核层的交互"></a>socket函数在应用层和内核层的交互</h2><p>用户调用的socket函数，会调用内核的sys_socket函数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051415958.png" alt="2"></p>
<p>sys_socket做两件事：</p>
<ul>
<li><p>sock_create生成内核的socket结构，和应用层的结构不同，如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413920.png" alt="13"></p>
</li>
<li><p>sock_map_fd将内核socket结构绑定文件描述符fd,用户层可通过fd访问内核socket结构</p>
</li>
</ul>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>服务端用socket函数建立套接字文件描述符后，需要绑定地址和端口到该文件描述符，才能接受客户端请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413732.png" alt="14"></p>
<ul>
<li>sockfd：socket函数创建的文件描述符</li>
<li>sockaddr结构的指针：指向的sockaddr结构，包含ip和port等信息</li>
<li>addrlen：即sizeof(struct sockaddr)</li>
</ul>
<p>bind函数绑定UNIX族的套接字：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413483.png" alt="15"></p>
<p>bind函数绑定AF_INET族的套接字:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413289.png" alt="16"></p>
<h2 id="bind函数在应用层和内核层的交互"><a href="#bind函数在应用层和内核层的交互" class="headerlink" title="bind函数在应用层和内核层的交互"></a>bind函数在应用层和内核层的交互</h2><p>以AF_INET族的套接字绑定为例，不同协议族实际上是调用内核不同的绑定函数<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051418474.png" alt="image-20221205141814380"></p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>listen函数用于初始化服务器的可连接队列，即服务器处理客户的请求，不是并行处理，而是异步的串行处理。服务器建立可连接队列，将当前不能同步处理的新请求放到队列中，等队列前面的请求处理完了，才异步处理这个请求。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051414568.png" alt="18"></p>
<ul>
<li>backlog是服务器可连接队列的最大长度</li>
<li>当前队列没满，即当前队列的请求没超过backlog值，才可以调用accept</li>
<li>listen函数只针对SOCK_STREAM和SOCK_SEQPACKET才能调用，因为TCP请求才需要建立连接。对于SOCK_DGRAM不支持listen，因为UDP是无连接的。</li>
</ul>
<p>TCP连接中，SOCK_STREAM类型的套接字，调用listen的示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419762.png" alt="image-20221205141912644"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419995.png" alt="image-20221205141921877"></p>
<h2 id="listen函数在应用层和内核层的交互"><a href="#listen函数在应用层和内核层的交互" class="headerlink" title="listen函数在应用层和内核层的交互"></a>listen函数在应用层和内核层的交互</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419209.png" alt="image-20221205141934130"></p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>服务端用listen建立连接队列后，客户端以connect发来一个请求，会加入到服务端连接队列的队尾，当这个请求到达队头，会调用accept真正处理该请求。<br>accept会创建一个新的套接字文件描述符，用来描述客户端的连接，这个时候会有两个套接字描述符并存：</p>
<ul>
<li>socket函数创建的老的sockfd，表示正在监听的ip和端口</li>
<li>accept函数创建的新的clientfd，表示当前的客户端连接，后续的客户端的收发和客户端关闭，即send，recv，close函数，都使用clientfd</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420456.png" alt="image-20221205142030402"></p>
<p>流式连接的accept示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420563.png" alt="image-20221205142038423"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420232.png" alt="image-20221205142048069"></p>
<h2 id="accept函数在应用层和内核层的交互"><a href="#accept函数在应用层和内核层的交互" class="headerlink" title="accept函数在应用层和内核层的交互"></a>accept函数在应用层和内核层的交互</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051421941.png" alt="image-20221205142100841"></p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>connect函数是客户端调用的函数，在客户端调用socket函数创建套接字文件sockfd后，可调用connect函数向服务端发起连接请求，请求的ip和端口信息包含在sockaddr结构体内。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051422137.png" alt="image-20221205142256082"></p>
<p>客户端的socket connect示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051422137.png"></p>
<h2 id="connect函数在应用层和内核层的交互"><a href="#connect函数在应用层和内核层的交互" class="headerlink" title="connect函数在应用层和内核层的交互"></a>connect函数在应用层和内核层的交互</h2><p>根据数据流式或数据报式的请求，具体调用inet_stream_connect或inet_dgram_connect<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423142.png" alt="image-20221205142315046"></p>
<h2 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h2><p>服务端和客户端真正建立连接后（socket通信逻辑连接，不是TCP&#x2F;UDP的面向连接&#x2F;无连接的传输层连接），即客户端发起connect，服务端accept完成，双方就可以相互read&#x2F;write，读写对方的数据，通过sockfd文件描述符，就像读写本地文件一样。</p>
<ul>
<li>read：从套接字文件读取数据，写入本地缓冲区，返回非空的有效数据大小<br> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423066.png" alt="image-20221205142328017"></li>
<li>write：向套接字文件写入数据，将本地缓冲区数据写入socket函数创建的socket文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423066.png"></li>
</ul>
<h2 id="close和shutdown函数"><a href="#close和shutdown函数" class="headerlink" title="close和shutdown函数"></a>close和shutdown函数</h2><ul>
<li>close：关闭socket连接，释放内核的套接字资源，不能通过套接字文件来读写操作</li>
<li>shutdown：支持读写的单向关闭，即关闭套接字文件的读、写、或者读写能力（等同于close）</li>
</ul>
<h1 id="Socket客户端和服务端交互的例程"><a href="#Socket客户端和服务端交互的例程" class="headerlink" title="Socket客户端和服务端交互的例程"></a>Socket客户端和服务端交互的例程</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>客户端从标准输入读取用户输入的字符串，发送给服务端，服务端读取数据，回写这些数据到客户端，客户端收到数据后输出到标准输出。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423842.png" alt="image-20221205142345794"></p>
<p>客户端和服务端可以在同一台机器部署，访问回环地址127.0.0.1即可，注意服务端的监听端口不能和其他进程的端口冲突。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>服务端代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
//#define PORT 8088                        /*侦听端口地址*/
#define BACKLOG 2                        /*侦听队列长度*/

int main(int argc, char *argv[])
&#123;
    int ss,sc;        /*ss为服务器的socket描述符，sc为客户端的socket描述符*/
    struct sockaddr_in server_addr;    /*服务器地址结构*/
    struct sockaddr_in client_addr;    /*客户端地址结构*/
    int err;                            /*返回值*/
    pid_t pid;                            /*分叉的进行ID*/

    /*建立一个流式套接字*/
    ss = socket(AF_INET, SOCK_STREAM, 0);
    if(ss &lt; 0)&#123;                            /*出错*/
        printf(&quot;socket error\n&quot;);
        return -1;    
    &#125;
    
    /*设置服务器地址*/
    bzero(&amp;server_addr, sizeof(server_addr));            /*清零*/
    server_addr.sin_family = AF_INET;                    /*协议族*/
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    /*本地地址*/
    //server_addr.sin_port = htons(PORT);
    server_addr.sin_port = htons(atoi(argv[1]));        /*服务器端口*/
    
    /*绑定地址结构到套接字描述符*/
    err = bind(ss, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));
    if(err &lt; 0)&#123;/*出错*/
        printf(&quot;bind error\n&quot;);
        return -1;    
    &#125;
    
    /*设置侦听*/
    err = listen(ss, BACKLOG);
    if(err &lt; 0)&#123;                                        /*出错*/
        printf(&quot;listen error\n&quot;);
        return -1;    
    &#125;
    
        /*主循环过程*/
    for(;;)    &#123;
        socklen_t addrlen = sizeof(struct sockaddr);
        /*接受客户端连接*/
        sc = accept(ss, (struct sockaddr*)&amp;client_addr, &amp;addrlen); 
        if(sc &lt; 0)&#123;                            /*出错*/
            continue;                        /*结束本次循环*/
        &#125;    
        
        /*建立一个新的进程处理到来的连接*/
        pid = fork();                        /*分叉进程*/
        if( pid == 0 )&#123;                        /*子进程中*/
            process_conn_server(sc);        /*处理连接*/
            close(ss);                        /*在子进程中关闭服务器的侦听*/
        &#125;else&#123;
            close(sc);                        /*在父进程中关闭客户端的连接*/
        &#125;
    &#125;
&#125;
</code></pre>
<p>服务端注意几点:</p>
<ul>
<li>accept后处理连接的过程，是在子进程中处理的，使用fork创建子进程用于连接处理。根据fork返回的pid是0还是其他，判断当前调度到子进程还是父进程，从全局上来讲，这个<code>if-else</code>的两种流程分别在父进程和子进程中指向。</li>
<li>服务端有两个套接字：侦听套接字和连接套接字。处理连接传入的是连接套接字。</li>
<li>在父进程（侦听进程）中，要关闭连接套接字；在子进程（连接处理进程）中，要关闭侦听套接字。这是为了避免子父进程相互影响。</li>
<li>对于多进程，一个进程的套接字关闭不会释放该套接字内存，只有所有进程都关闭了这个套接字，内核才会 释放该套接字，所有可以放心在侦听进程和连接处理进程中，关闭对方的套接字。</li>
</ul>
<p>客户端代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
//#define PORT 8088                                /*侦听端口地址*/

int main(int argc, char *argv[])
&#123;
    int s;                                        /*s为socket描述符*/
    struct sockaddr_in server_addr;            /*服务器地址结构*/
    
    s = socket(AF_INET, SOCK_STREAM, 0);         /*建立一个流式套接字 */
    if(s &lt; 0)&#123;                                    /*出错*/
        printf(&quot;socket error\n&quot;);
        return -1;
    &#125;    
    
    /*设置服务器地址*/
    bzero(&amp;server_addr, sizeof(server_addr));    /*清零*/
    server_addr.sin_family = AF_INET;                    /*协议族*/
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    /*本地地址*/
    server_addr.sin_port = htons(atoi(argv[2]));        /*服务器端口*/
    
    /*将用户输入的字符串类型的IP地址转为整型*/
    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);    
    /*连接服务器*/
    connect(s, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr));
    process_conn_client(s);                        /*客户端处理过程*/
    close(s);                                    /*关闭连接*/
    return 0;
&#125;
</code></pre>
<p>建立连接后的读写交互代码，包含服务端的调用和客户端的调用：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
/*客户端的处理过程*/
void process_conn_client(int s)                    /* 传入的是客户端调用socket时创建的s */
&#123;
    ssize_t size = 0;
    char buffer[1024];                            /*数据的缓冲区*/
    
    for(;;)&#123;                                    /*循环处理过程*/
        /*从标准输入中读取数据放到缓冲区buffer中,标准输入：0，标准输出：1，标准错误：2*/
        size = read(0, buffer, 1024);
        if(size &gt; 0)&#123;                            /*读到数据*/
            write(s, buffer, size);                /*发送给服务器*/
            /*客户端阻塞，等待服务器有数据可读*/
            size = read(s, buffer, 1024);        /*从服务器读取数据*/
            write(1, buffer, size);                /*写到标准输出*/
        &#125;
    &#125;    
&#125;
/*服务器对客户端的处理*/
void process_conn_server(int s)                 /* 传入的是服务端调用accept时创建的sc */
&#123;
    ssize_t size = 0;
    char buffer[1024];                            /*数据的缓冲区*/
    
    for(;;)&#123;                                    /*循环处理过程*/        
        size = read(s, buffer, 1024);            /*从套接字中读取数据放到缓冲区buffer中*/
        if(size == 0)&#123;                            /*没有数据*/
            return;    
        &#125;
        
        /*构建响应数据*/
        //sprintf(buffer, &quot;server receive %d bytes from client\n&quot;, size);
        //write(s, buffer, strlen(buffer));
        write(s, buffer, size);                    /*发回给客户端*/
    &#125;    
&#125;
</code></pre>
<p>Makefile编译脚本:</p>
<pre><code>all:client server                    #all规则，它依赖于client和server规则

client:tcp_process.o tcp_client.o    #client规则，生成客户端可执行程序
    gcc -o client tcp_process.o tcp_client.o
server:tcp_process.o tcp_server.o    #server规则，生成服务器端可执行程序
    gcc -o server tcp_process.o tcp_server.o    
tcp_process.o:                        #tcp_process.o规则，生成tcp_process.o
    gcc -c tcp_process.c -o tcp_process.o
clean:                                #清理规则，删除client、server和中间文件
    rm -f client server *.o
</code></pre>
<h2 id="部署和运行"><a href="#部署和运行" class="headerlink" title="部署和运行"></a>部署和运行</h2><p>后台运行server,指定监听端口:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424795.png" alt="image-20221205142401747"><br>运行client，指定服务端的ip, port：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424795.png"><br>客户端每输入一个字符串，服务端返回完全相同的字符串，通信正常<br>如果运行服务端时，有bind error，可能是端口被占用，<code>netstat</code>找到占用端口的PID，kill之后再运行server<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424796.png" alt="image-20221205142416741"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux进程的内存分布和进程IPC</title>
    <url>/2020/11/15/%E6%B5%85%E8%B0%88Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9B%E7%A8%8BIPC/</url>
    <content><![CDATA[<h1 id="Linux虚拟内存空间分布"><a href="#Linux虚拟内存空间分布" class="headerlink" title="Linux虚拟内存空间分布"></a>Linux虚拟内存空间分布</h1><p>（1）虚拟内存空间与物理内存：<br>带MMU控制器的CPU支持将物理内存以分页的方式，细粒度的动态分配给进程，使每个进程只看得到这个虚拟的内存空间，每个进程认为自己可以访问整个内存空间。进程根本不知道其访问的某个内存页的实际物理地址，也许在SDRAM上，或者硬盘的交换分区上。</p>
<p>进程的虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每个进程都拥有一套属于它自己的页表。</p>
<p>（2）下面讨论用户进程能看到什么样的虚拟内存空间：</p>
<p>以32位系统为例，CPU可寻址4GB的内存空间。此时虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分：</p>
<ul>
<li>将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。</li>
<li>将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间</li>
</ul>
<p>因为每个进程可以通过<strong>系统调用</strong>进入内核，因此，Linux内核由系统内的所有进程共享。从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051156842.png" alt="image-20221205115648795"></p>
<p>注意：</p>
<ul>
<li>内核可见的内存空间只有全局的1GB; 用户进程可见的内存空间包括该进程独有的3GB空间，和全局内核的1GB;</li>
<li>用户进程虽然可见内核空间的1GB，但不可直接访问，要通过系统调用（或中断等方式），涉及上下文切换；</li>
<li>当进程访问内核空间时，称为“进入内核态”，返回时称为“进入用户态”；</li>
<li>内核空间分布在虚拟内存空间的高地址，用户空间在低地址</li>
</ul>
<p>（3）用户进程的内部空间详解</p>
<p>编译好的程序都分为几个段(section)，在程序运行过程中的临时变量还产生堆栈，程序手动分配的内存使用堆, 还有命令行参数和环境变量等配置信息，这些东西都属于进程空间的数据。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051159094.png" alt="image-20221205115908003"></p>
<p>详解如下：<br>代码段(Text):存放程序指令，一些只读数据(.rodata)也可归为此类<br>数据段(Data):存放初始化过的全局数据<br>BSS段:存放未初始化(默认为0)的全局数据<br>栈 (Stack): 用于控制函数调用和返回过程中的临时变量，存储函数内的临时变量; 存储函数的返回指针，<br>堆 (Heap):存储动态内存分配, 需要程序员手工分配, 手工释放。注意与数据结构中的堆(优先队列)是不同，分配方式类似于链表。</p>
<h1 id="Linux进程间通信-IPC"><a href="#Linux进程间通信-IPC" class="headerlink" title="Linux进程间通信(IPC)"></a>Linux进程间通信(IPC)</h1><p>进程本身是为了隔离程序的资源，但不同程序间可能有数据通信或调用关系，因此需要进程通信机制。</p>
<p>进程通信最主要的几种方式有：管道(pipe) , 共享内存(shared memory), 消息队列(message queue), socket等。为了进程间的时序同步和资源处理，信号量(semaphore)通常配合使用。</p>
<p>本节重点讲管道和共享内存，关于Linux IPC 的全面内容，参考：<br><a href="http://www.cs.fsu.edu/~zwang/files/cop4610/Fall2016/linux-ipc.pdf">An introduction to Linux IPC</a><br><a href="https://opensource.com/sites/default/files/gated-content/inter-process_communication_in_linux.pdf">inter-process_communication_in_linux</a></p>
<h2 id="进程通信的基本思路"><a href="#进程通信的基本思路" class="headerlink" title="进程通信的基本思路"></a>进程通信的基本思路</h2><p>根据上节的内存空间分布，所有进程共享同一个内核空间，最简单的进程通信就是通过 进程A-&gt;内核-&gt;进程B：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157104.png" alt="1637063328269_12"></p>
<p>以上虽然可以实现，但有两次拷贝以及上下文切换，其总体思路是管道和共享内存方式的基础。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道的实质就是一个内核缓冲区；<br>管道对于管道两端的进程而言就是一个文件，与普通文件的区别是管道只存在于内存中；<br>进程通过读写管道文件，传递数据；</p>
<p>管道依据是否有名字分为匿名管道和命名管道，其功能有以下区别：<br>匿名管道(通常管道就是指匿名管道)：</p>
<ul>
<li>半双工的，即管道设置好后，数据只能从进程A到进程B；如果还需要从B到A,需要创建另外的管道</li>
<li>只能用于父子进程或兄弟进程之间的通信</li>
</ul>
<p>命名管道(FIFO)：</p>
<ul>
<li>可用于无关联进程的通信，其基本原理和匿名管道一样，本节不详细描述</li>
</ul>
<p>管道内部提供了同步机制<br>临界资源： 大家都能访问到的共享资源<br>临界区： 对临界资源进行操作的代码<br>同步： 临界资源访问的可控时序性（一个操作完另一个才可以操作）<br>互斥： 对临界资源同一时间的唯一访问性（保护临界资源安全）</p>
<h3 id="匿名-管道使用三部曲"><a href="#匿名-管道使用三部曲" class="headerlink" title="(匿名)管道使用三部曲"></a>(匿名)管道使用三部曲</h3><p>1.创建本进程的管道<br>使用pipe函数创建管道文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157310.png" alt="image-20221205115729244"></p>
<p>2.fork子进程，共享管道<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157031.png" alt="image-20221205115734973"></p>
<p>3.设置管道为单向<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157508.png" alt="image-20221205115744442"></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>Linux中每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。</p>
<p>两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。</p>
<p>共享内存的通信原理：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157936.png" alt="image-20221205115751869"></p>
<p>共享内存的关键是一份内存资源被两个进程占用，因此需要信号量等同步机制，实现进程同步与资源互斥。</p>
<p>这里简单说明我对信号量的理解：</p>
<ul>
<li>信号量的作用是“流程同步”，这个流程可以是两个进程访问共享内存，也可以是同一进程内的多个线程访问共享数据；</li>
<li>注意，信号量并不一定用于共享资源的情景，可能只是简单的主线程等待工作线程这种情况。这是其和互斥锁的关键区别；</li>
<li>信号量如果用于共享资源，其本质是“引用计数”，即共享资源是否可用的计数，计数为0表示无资源可用。各进程如果获得资源计数-1，释放资源计数+1。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/cl_linux/article/details/80328608">Linux进程地址空间和进程的内存分布</a><br><a href="http://www.cs.fsu.edu/~zwang/files/cop4610/Fall2016/linux-ipc.pdf">An introduction to Linux IPC</a><br><a href="https://opensource.com/sites/default/files/gated-content/inter-process_communication_in_linux.pdf">inter-process_communication_in_linux</a><br><a href="https://www.cnblogs.com/huansky/p/13170125.html#:~:text=Linux%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B8%BB%E8%A6%81%E6%9C%89%EF%BC%9A%E7%AE%A1%E9%81%93%20%28pipe%29,%28%E5%8C%85%E6%8B%AC%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%29%E3%80%81%E4%BF%A1%E5%8F%B7%20%28signal%29%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%28queue%29%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%82">Linux 进程间通信（IPC）总结</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈加密和编码：MD5</title>
    <url>/2022/01/25/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9AMD5/</url>
    <content><![CDATA[<h1 id="1-MD5简介"><a href="#1-MD5简介" class="headerlink" title="1.MD5简介"></a>1.MD5简介</h1><p>MD5的全称是Message-Digest Algorithm 5（<strong>信息摘要算法</strong>），经MD2、MD3和MD4发展而来。<br>所谓信息摘要，就是包含数据关键特性，能（唯一）识别原数据的关键信息。</p>
<p>MD5也称为<strong>单向散列算法</strong>，这是从其实现方式命名，因为：</p>
<ul>
<li>MD5能对大量数据，进行哈希映射，输出固定长度(128bit)的数据，输出数据也称为原数据的信息摘要。</li>
<li>不能由摘要推测出原数据，即MD5算法是单向的，当加密来用的话，只能加密不能解密。</li>
</ul>
<p>MD5的特点：</p>
<ul>
<li>固定长度：输入任意长度的信息，经过MD5处理，输出总是128位的信息。</li>
<li>唯一性：不同的输入得到的不同的结果；同样的输入一定得到相同的结果。</li>
<li>不可逆：根据128位的输出结果不可能反推出输入的信息。</li>
</ul>
<h1 id="2-MD5的应用"><a href="#2-MD5的应用" class="headerlink" title="2.MD5的应用"></a>2.MD5的应用</h1><p>1、防止被篡改：<br>1）比如A和B发送一个电子文档，发送前，A先自己计算出数据的MD5输出结果a。<br>然后在B收到电子文档后，B计算得到一个MD5的输出结果b。<br>如果a与b一样就代表传输中途数据未被篡改。<br>2）比如A提供文件下载，为了防止不法分子在文件中添加木马，伪装成A的文件。A可以在网站上公布由安装文件得到的MD5输出结果。<br>要下载文件的人只需要下载后，验证MD5是否和A一致，如果不一致，就是被其他人修改过。</p>
<p>2、防止暴露明文：<br>基本上存储用户密码的场景，都用到MD5加密明文。<br>1）例如网站服务器在其数据库存储用户的密码，都是存储用户密码的MD5值。就算不法分子得用户密码的MD5值，也无法知道用户的密码。<br>2）在UNIX、Linux系统中，用户密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。</p>
<p>3、防止抵赖（数字签名）：<br>这需要一个存储MD5值的第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。</p>
<h1 id="3-MD5算法实现"><a href="#3-MD5算法实现" class="headerlink" title="3.MD5算法实现"></a>3.MD5算法实现</h1><p>对MD5算法简要的叙述可以为：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<p>第一步、填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N<em>512+448(bit)；<br>第二步、记录信息长度：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N</em>512+448+64&#x3D;(N+1)*512位。<br>第三步、装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A&#x3D;(01234567) 16 ，B&#x3D;(89ABCDEF) 16 ，C&#x3D;(FEDCBA98) 16 ，D&#x3D;(76543210) 16 ）。如果在程序中定义应该考虑大小端（A&#x3D;0X67452301L，B&#x3D;0XEFCDAB89L，C&#x3D;0X98BADCFEL，D&#x3D;0X10325476L）。<br>第四步、四轮循环运算：循环的次数是分组的个数（N+1）。 最终由4个32bit数据拼成128bit的结果。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121430277.png" alt="image-20221212143002209"></p>
<h1 id="4-MD5的安全性"><a href="#4-MD5的安全性" class="headerlink" title="4.MD5的安全性"></a>4.MD5的安全性</h1><p>普遍认为MD5是很安全，因为哈希散列是强抗碰撞的：已知原数据和其MD5值，想通过枚举找到一个相同MD5值的数据，基本不可能。如果暴力破解MD5，其运算时间是不可想象的。</p>
<p>但是实际应用上，如果把用户密码仅仅MD5处理后再存储到数据库，其实是很不安全的。因为用户的密码的固有特征，让枚举集合变小了许多，原因：</p>
<ul>
<li>用户密码是比较短的一般8位左右。</li>
<li>很多用户的密码有规律，例如使用生日，手机号码，或者使用常用数字组合，或某个英文单词。</li>
<li>许多用户的常用密码只有一个，也就是说，泄漏了微信的密码，也很有可能QQ,支付宝密码也泄漏了</li>
</ul>
<p>如果把常用的密码先MD5处理后存储结果，然后再跟用户的MD5结果匹配，这时就有较大概率“碰撞”，得到明文。这种预先存储的MD5表称为rainbow-table。<br>因此MD5作为“信息摘要”的用途多一些，作为加密，还需要配合其他的算法（例如AES等几种公钥算法），或者“加盐”。<br>安全性比较好的网站，都会用一种叫做 “加盐”(salt)的方式来存储密码:</p>
<ul>
<li>先将用户输入的密码进行一次MD5（或其它哈希算法）加密。</li>
<li>将得到的MD5值前后加上一些只有管理员自己知道的随机串，再进行一次MD5加密。</li>
<li>这个随机串中可以包括某些固定的串，也可以包括用户名（用来保证每个用户加密使用的密钥都不一样）。</li>
<li>在管理员和用户的两个salt没有泄露的情况下，黑客拿到加密串，就几乎不可能推算出原始的密码是什么了。</li>
</ul>
<h1 id="5-MD5库"><a href="#5-MD5库" class="headerlink" title="5.MD5库"></a>5.MD5库</h1><p>在涉及到文件传输的场景，通常用MD5校验文件的一致性，openSSL库提供MD5计算函数：</p>
<p><a href="https://www.openssl.org/docs/man3.0/man3/MD5_Update.html">MD5_Update</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int MD5_Init(MD5_CTX *c);</span><br><span class="line">int MD5_Update(MD5_CTX *c, const void *data, unsigned long len);</span><br><span class="line">int MD5_Final(unsigned char *md, MD5_CTX *c);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>encrypt</category>
      </categories>
      <tags>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈加密和编码：base64</title>
    <url>/2022/01/22/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9Abase64/</url>
    <content><![CDATA[<h1 id="1-什么是编码解码"><a href="#1-什么是编码解码" class="headerlink" title="1.什么是编码解码"></a>1.什么是编码解码</h1><p>编码：利用特定的算法，对原始内容进行处理，生成运算后的内容，形成另一种数据的表现形式，可以根据算法，再还原回来，这种操作称之为编码。<br>解码：利用编码使用的算法的逆运算，对经过编码的数据进行处理，还原出原始数据，这种操作称之为解码。</p>
<h1 id="2-什么是Base64编码算法"><a href="#2-什么是Base64编码算法" class="headerlink" title="2.什么是Base64编码算法"></a>2.什么是Base64编码算法</h1><p>将任意的字节数组数据，通过Base64算法，生成只有（大小写英文、数字、+、&#x2F;）（一共64个字符）内容表示的字符串数据。即将任意的内容转换为可见的字符串形式。</p>
<h1 id="3-为什么需要Base64编码"><a href="#3-为什么需要Base64编码" class="headerlink" title="3.为什么需要Base64编码"></a>3.为什么需要Base64编码</h1><p>Base64算法最开始是被用于解决电子邮件数据传输问题。以前发送邮件只支持可见字符的传送，但ASCII码中，有一部分不支持直接显示。由此，需要有一个方法将不可见的字符转换为可见的字符，便产生了Base64编码算法。</p>
<h1 id="4-Base64算法的实现"><a href="#4-Base64算法的实现" class="headerlink" title="4.Base64算法的实现"></a>4.Base64算法的实现</h1><p>特点：</p>
<ul>
<li>将数据按照 3个字节一组的形式进行处理，每三个字节在编码之后被转换为4个字节。即：如果一个数据有6个字节，可编码后将包含6&#x2F;3*4&#x3D;8个字节</li>
<li>当数据的长度无法满足3的倍数的情况下，最后的数据需要进行填充操作，即补“&#x3D;” ，这里“&#x3D;”是填充字符，不要理解为第65个字符。因此我们经常看见base64编码的字符串结尾有几个”&#x3D;”号</li>
</ul>
<p>示例：</p>
<p> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121437191.png" alt="image-20221212143753149"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121438580.png" alt="image-20221212143830525"></p>
<p>上面示例将原始数据的每三个字节分为一组，按位进行分割为每6位一个字节的形式，进行转换，形成新的4个字节。空缺的两个bit用0填补。<br>这四个字节才通过Base64编码表进行映射，形成最后实际的Base64编码结果。<br>如果原始数据最后无法凑成3个字节，则以“&#x3D;”填充。</p>
<p>注：上图中的1234567表示bit的位置，不是bit的值。</p>
<p>将字符串”ABC”进行Base64编码流程如下。</p>
<p>1.使用ASCII编码方式将字符串”ABC”转换成二进制数据 01000001 | 01000010 | 01000011<br>2.将步骤1的二进制数据进行分组，每个分组6bit 010000 | 010100 | 001001 | 000011<br>3.将步骤2的4组6bit二进制编码数据进行补位（高位补0），变成4组8bit二进制 00010000 | 00010100 | 00001001 | 00000011<br>4.将步骤3中的4组8bit转换成十进制。16 | 20 | 9 | 3<br>5.以步骤4的十进制数据为索引，去Base64编码映射表中寻找对应的字符。16在编码表中映射的字符是Q，20映射的字符是U，9映射的字符是J，3映射的字符是D。<br>所以，字符串”ABC”经过Base64编码后的数据是”QUJD”。</p>
<p><strong>Base64编码索引表</strong><br>26个字母 * 2(大小写) + 10个数字 + 2个运算符号 &#x3D; 64个字符<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121438704.png" alt="image-20221212143820653"></p>
<h1 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h1><p>http协议中，GET方式和POST方式是Http请求常用的两种方式，GET方法只能传递ASCII数据，但某些情况下会要求使用GET来传递二进制数据。<br>此时用Base64对Get传输的二进制数据，编码成ASCII数据，例如，客户端和服务器传递JSON数据时，经常会进行base64编解码。</p>
<p>注意：</p>
<ul>
<li>Base64是编码算法，不是加密算法，只是用来编码二进制的字节数组，形成可视的ASCII字符串。</li>
<li>Base64编码实际上是把原数据的3个字节映射成了4个字节，所以相比于原数据长度，编码后的长度会增加1&#x2F;3。会降低传输效率。</li>
</ul>
]]></content>
      <categories>
        <category>encrypt</category>
      </categories>
      <tags>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈信号完整性和ReDriver</title>
    <url>/2023/04/10/%E6%B5%85%E8%B0%88%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8CReDriver/</url>
    <content><![CDATA[<h2 id="信号完整性"><a href="#信号完整性" class="headerlink" title="信号完整性"></a>信号完整性</h2><p>在讨论ReDriver之前，先说明信号完整性（Signal Integrity, SI）的相关背景。<br>电子信号在传输过程中(无线或有线)都会受到环境噪声干扰，信号功率也会随着传输距离衰减(signal attenuation)。<br>通信系统中用信噪比表达的信号的好坏:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信噪比(dB)=10*log（信号/噪音）</span><br></pre></td></tr></table></figure>

<ul>
<li>当信噪比大于设备接收灵敏度时，信号能被正常接收和解析（成逻辑0&#x2F;1）</li>
<li>当信噪比小于设备接收灵敏度时，信号被错误解析（错误的逻辑0&#x2F;1）或者是根本解析不出信号(噪声完全淹没信号，接收端恒为0或1，没有信号变化)。</li>
</ul>
<p>信号完整性（Signal Integrity, SI）一般指PCB电路中的电压信号的信噪比好坏。如果电路中信号能够以要求的时序、持续时间和电压幅度到达接收器，则该电路具有较好的信号完整性。反之当信号不能正常响应时，就出现了信号完整性问题。一般通过眼图观测信号完整性好坏。</p>
<p>信号完整性在高速电路更容易出问题，表现为信号有传输延迟和时序错误、电路串扰（电容性、电感性串扰）等。</p>
<p>高速信号的PCB电路设计和信号完整性密切相关，例如下图是PCB使用FR4材料和Megtron6材料，信号-频率函数显示衰减度不同。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101118830.png" alt="Attenuation versus Frequency as a function of PCB material"></p>
<h2 id="ReDriver"><a href="#ReDriver" class="headerlink" title="ReDriver"></a>ReDriver</h2><p>Redriver能减弱信号在远距离、高噪声环境的传输中的信号完整性问题对接收端的影响。</p>
<p>Redriver类似通信系统中的基站，其接收传输线路中的信号，重新生成原始信号，再转发给远端设备；其输出信号基本和原始信号完全一致以保证接收端能正常解析信号。</p>
<p>(1)PCIe redriver</p>
<p>以典型的高速信号PCIe接口为例，其使用Redriver和Retimer提高信号完整性，参考：<a href="https://www.allaboutcircuits.com/industry-articles/choosing-the-right-redriver-or-retimer-device-to-extend-pcie-protocol-signal-range/">Choosing the Right Redriver or Retimer Device to Extend PCIe Protocol Signal Range</a></p>
<p>其RX, EQ接收PCIe信号源的TX, EQ信号，redrive生成原始信号后再从TX, EQ发送给接收端。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101126665.png" alt="Single lane redriver block diagram"></p>
<p>(2)USB redriver</p>
<p>以多层子设备结构的USB接口为例，其使用Redriver提高子USB host的驱动能力，参考 <a href="https://www.diodes.com/zh/products/connectivity-and-timing/redrivers-repeaters/">信号完整性 - ReDriver&#x2F; 信号中继器 &#x2F; 调节器</a></p>
<p><img src="https://www.diodes.com/assets/Uploads/redrivers-application2__ResizedImageWzYwMCwzNTFd.png" alt="redrivers application2"></p>
<p>(3)SD redriver</p>
<p>即使是较低速的SD接口(MB&#x2F;s级别)也有PCB设计和传输距离引起的信号完整性问题，也需要redriver解决。</p>
<p>如下SD redriver接收SD host的几个信号并重新生成：SD clock, SD cmd, SD data, Vdd power。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101130119.png" alt="image-20230410113046013"></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>ReDriver</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈数字电路之PLL</title>
    <url>/2023/03/01/%E6%B5%85%E8%B0%88%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B9%8BPLL/</url>
    <content><![CDATA[<p>本文PLL的基础内容参考了Digital Integrated Circuits一书，下载方式：在 <a href="https://vdoc.pub/">vdoc</a> 搜索关键字 Digital Integrated Circuits</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303011144938.jpeg" alt="img"></p>
<h2 id="PLL的应用概述"><a href="#PLL的应用概述" class="headerlink" title="PLL的应用概述"></a>PLL的应用概述</h2><p>两个作用：Clock Synthesis（时钟综合）和 Clock Synchronization（时钟同步）</p>
<ul>
<li>Clock Synthesis，Synthesis是综合&#x2F;生成的意思，Clock Synthesis即生成时钟，但此处含义不是作为时钟源，而是在低频晶振时钟的基础上倍频生成高频时钟：其中低频的晶振时钟的特性：10~200MHz， accurate, low-jitter ，高频时钟特性：200MHz ~ GHz级别，通常也称为系统时钟，例如SOC core的基准频率</li>
<li>Clock Synchronization，不同芯片之间传递时钟信号需要同步时钟相位，例如SOC的CPU和外设之间的通信接口一般是：分频后的时钟信号（reference clock）和数据信号（Date），CPU和外设间的信号传递是需要时间的，高速信号传递到外设侧有相位偏移（可以简单理解为延迟），因此需要PLL同步时钟相位以保证对数据采样的正确性（想象一下，如果reference clock相位偏移过大，可能每个采样时刻得到的data数据都是错位的）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031043844.png" alt="image-20230303104354744"></p>
<h2 id="相位的概念"><a href="#相位的概念" class="headerlink" title="相位的概念"></a>相位的概念</h2><p>Digital Integrated Circuits一书对相位的描述：</p>
<p>Periodic signals of known frequency can be discribed exactly by only one parameter, their<br>phase. More accurately a set of two or more periodic signals of the same frequency can be<br>well defined if we know one of them and its phase with respect to the other signals.  </p>
<p>翻译下就是：</p>
<ul>
<li><p>多个已知频率的周期信号只用一个参数就能精确区分：相位</p>
</li>
<li><p>如果这些信号的频率相同，则只需知道相位差就可以从一个信号精确推测另一个信号</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031634330.png" alt="image-20230303163446269"></p>
<p>基于以上概念，下面介绍PLL的两个核心功能：</p>
<ul>
<li>将输入PLL的时钟和PLL输出时钟的频率精确同步：输出时钟信号频率是输入时钟信号频率的精确的N倍</li>
<li>将输入PLL的时钟和PLL输出时钟的相位精确同步：输出时钟信号N分频后，其应该和输入信号完全一致，其上升&#x2F;下降沿应该精确对齐输入时钟信号的上升&#x2F;下降沿</li>
</ul>
<h2 id="PLL内部实现"><a href="#PLL内部实现" class="headerlink" title="PLL内部实现"></a>PLL内部实现</h2><p>PLL内部结构如下，真正核心的只有两个组件：</p>
<ul>
<li>VCO: The voltage-controlled oscillator (VCO) takes an analog control input and generates a clock signal of the desired frequency.  VCO接受电压（模拟信号），转换为频率（数字信号），也就是说，VCO使输出频率是电压的函数(非线性)。Charge pump是控制电压增加和减少的模块，Loop filter是低通滤波器，过滤掉电压信号中的高频正弦噪声，使VCO的输入更“纯粹”（减少毛刺信号，jittery clock）</li>
<li>Phase Detectors: 为什么带s ? 因为可以有两种实现：XOR Phase Detector  和 Phase-Frequency Detector ，Phase Detectors是相位和频率同步的核心，具体原理下面讲</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031635776.png" alt="image-20230303163504732"></p>
<h3 id="XOR-Phase-Detector"><a href="#XOR-Phase-Detector" class="headerlink" title="XOR Phase Detector"></a>XOR Phase Detector</h3><p>用一个异或门(XOR)就能实现相位检测，是最简单但有缺陷的实现：</p>
<p>当ref clock和local clock(反馈时钟)有相位差，异或之后输出的就是相位差信号(phase error)，这个信号经过线性函数转换成Vdd, 作为VCO的控制电压。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031433820.png" alt="image-20230303143346757"></p>
<p>XOR的缺陷：当local clock相位和ref clock相位一致，但local clock频率是ref clock的N倍时，XOR检不输出相位差，但此时PLL输出频率不是预期的频率，而是N倍的预期频率。</p>
<h3 id="Phase-Frequency-Detector-PFD"><a href="#Phase-Frequency-Detector-PFD" class="headerlink" title="Phase-Frequency Detector (PFD)"></a>Phase-Frequency Detector (PFD)</h3><p>为了解决XOR的缺陷，引入了Phase-Frequency Detector (PFD)，看名字就知道，它同时检测相位和频率，以保证PLL输出的正确性</p>
<p>如下图，UP&#x2F;DN是控制VCO的信号，用于给VCO加压&#x2F;降压；A和B是local clock和ref clock；</p>
<p>PFD使用触发器(flip-flops)，将UP&#x2F;DN变成A和B的状态机；关于flip-flops的特性，参考 <a href="https://courses.cs.washington.edu/courses/cse370/03sp/pdfs/lectures/lecture15.pdf">Overview The D latch - University of Washington</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031532421.png" alt="image-20230303153203366"></p>
<p>(1) PFD如何检测相位差</p>
<p>以左侧信号为例，过程如下：</p>
<ol>
<li>信号A相位超前于信号B, A上升沿时会触发UP信号输出(D触发器特性，这里A作为D触发器的CLK输入信号)；</li>
<li>当信号B上升沿变化时, B处的触发器也输出DN脉冲，两个触发器的输出都为1，经过与门后Rst复位信号为1，导致A和B的触发器都被reset, 之后UP和DN都变为低；</li>
<li>综合下来看，UP信号的宽度就等于相位差，线性转换后就可以作为控制VCO的电压</li>
</ol>
<p>右侧波形同理，信号A相位落后于信号B，DN即相位差</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031500042.png" alt="image-20230303150043973"></p>
<p>(2) PFD如何检测频率差</p>
<p>如下图，当B频率比A低，PFD输出更多的UP信号增加VCO电压，提高B的频率；当B频率比A高则相反，PFD输出更多DN信号降低B的频率</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031517323.png" alt="image-20230303151725271"></p>
<h2 id="PLL的指标"><a href="#PLL的指标" class="headerlink" title="PLL的指标"></a>PLL的指标</h2><p>PLL structure is a feedback structure and the addition of extra phase shifts, as is done by a high-order filter, may result in instability. </p>
<p>PLL是能造成相位偏移（矫正）的反馈电路，既然是反馈就得像数学求极限一样不断趋近，这决定PLL不是一上电就能马上稳定工作，因此引入PLL的关键指标如下：</p>
<p>Important properties of a PLL are：</p>
<ul>
<li><p>lock range—the range of input frequencies over which the loop can maintain functionality; PLL能接受的输入时钟不可能太高，一般是OSC晶振低频时钟。想象一下，太高的输入时钟要去同步相位和倍频，对VCO和相位检测器的精度要求也极高</p>
</li>
<li><p>the lock time—the time it takes for the PLL to lock onto a given input signal; PLL是反馈环路电路，需要不断递归趋近于目标时钟信号直到稳定，稳定需要的时间称为PLL锁定时间</p>
</li>
<li><p>jitter.  毛刺信号，在模拟端称为noise(VCO输入电压)，在数字端称为jitter毛刺(VCO输出时钟)，这是时钟信号相关模块必不可少的指标</p>
</li>
</ul>
<h2 id="PLL的稳定过程"><a href="#PLL的稳定过程" class="headerlink" title="PLL的稳定过程"></a>PLL的稳定过程</h2><p>如下图是Spice 仿真将100Mhz reference clock倍频8倍，VCO最终稳定输出800Mhz system clock的过程：</p>
<ul>
<li><p>左侧是VCO控制电压，经过几次反馈调整后最终稳定</p>
</li>
<li><p>右侧是时钟信号，ref是输入的100Mhz reference clock，vco是输出的system clock， div是vco输出8分频后的反馈时钟</p>
</li>
</ul>
<p>可见PLL稳定过程是将ref，vco和div时钟信号的相位、频率都收敛到一致</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031423652.png" alt="image-20230303142344571"></p>
<h2 id="PLL在IC设计IP的实例"><a href="#PLL在IC设计IP的实例" class="headerlink" title="PLL在IC设计IP的实例"></a>PLL在IC设计IP的实例</h2><p>以SMIC的PLL IP S65NLLPLLGS 为例介绍实际IC设计中的PLL模块：</p>
<p>(1) 简介</p>
<p>This PLL is developed as an IP block to reduce time to market, risk and cost in the<br>development of Analog Front –End design. This macro cell is mainly for the clock<br>generator. It can generate stable high-speed clock from a slower clock signal with<br>single power supply. The output frequency is adjustable and can be up to 1500MHz.<br>This PLL integrates a Phase Frequency Detector (PFD), a Low Pass Filter (LPF), a<br>Voltage Controlled Oscillator and other associated circuit. All fundamental building<br>blocks as well as fully programmable dividers are integrated in the core. It is useful<br>for clock multiplication of stable crystal oscillator sources and for de-skew clock<br>signals  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061656462.png" alt="image-20230306165657371"></p>
<p>可见主要模块还是PFD + VCO，输出时钟加了一些逻辑门控制，例如PDRST是PLL时钟复位控制。</p>
<p>(2) 主要参数</p>
<p>Technology: SMIC 65nm logic LL process  </p>
<p>PFD comparison frequency range from 1Mhz to 50Mhz.  </p>
<p>Output clock frequency range from 62.5MHz to 1500MHz  </p>
<p>基本体现了PLL的指标：输入输出时钟频率有限制</p>
<p>(3) PLL reset</p>
<p>PLL作为实际可用的模块，其输出频率一定是可调的，以下PLL IP的pin中的M, N即调整频率；对于固件、驱动软件开发者，M，N分频的访问接口是作为寄存器来动态配置。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061707268.png" alt="image-20230306170709189"></p>
<p>在M，N调整分配时，必须reset PLL并等待PLL再次稳定（PLL lock time），如下图：</p>
<p>LKDT: Lock Detection, 表示目前PLL正在lock，即反映PLL是否处于不稳定状态</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061711496.png" alt="image-20230306171156449"></p>
<h2 id="PLL在外设时钟配置的实例"><a href="#PLL在外设时钟配置的实例" class="headerlink" title="PLL在外设时钟配置的实例"></a>PLL在外设时钟配置的实例</h2><p>SD控制器(SD host)是SOC中常用的外围模块，通过SD specification规定的SD Command通信格式向SD卡通信。</p>
<p>下面以SD host&#x2F;card的时钟初始化为例，介绍PLL的lock time在外设时钟初始化的影响</p>
<p>(1) SD 4.0标准的host和card的物理框图如下图，这里重点关注host侧的时钟相关的模块：</p>
<ul>
<li>OSC: host 的时钟来源，同时也是PLL的输入</li>
<li>PLL: host的倍频器，为了给SD UHS-II card提供更高速的工作时钟(UHS-I低速SD card不需要此PLL)</li>
<li>RCLK: SD card的工作时钟(reference clock)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061954691.png" alt="image-20230306195458581"></p>
<p>(2) SD host和card的时钟初始化</p>
<p>SD host和card的时钟初始化包含三步：</p>
<p>1.使能internal clock: sd host chip自己的工作时钟(即base clock，来源是OSC)，并等待其稳定，如下图(3)~(4)</p>
<p>2.enable PLL，并等待其稳定，这个等待稳定超时时间为150ms ，如下图(5)~(6)。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303062016985.png" alt="image-20230306172758282"></p>
<p>3.待host PLL输出稳定后，即可enable SD clock开始对SD卡供应reference clock时钟, 注意SD clock是下图(1)~(2)就已经计算好的，如下表Base Clock为internal clock，M可理解为PLL倍频后的频率, 经过2^N分频后给SD card作为reference clock。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303062013044.png" alt="image-20230306201345998"></p>
<h2 id="PLL在电源管理的实例"><a href="#PLL在电源管理的实例" class="headerlink" title="PLL在电源管理的实例"></a>PLL在电源管理的实例</h2><p>所谓电源管理，通俗的讲就是按需管理电源：</p>
<ul>
<li>按需，指的是按应用场景的需求，例如在高性能肯定对应高功耗，各种模块全部开启，且时钟频率拉到最大；而睡眠休眠等模式，有时只需要保留能唤醒系统的时钟就行；</li>
<li>管理电源，涉及到供电和时钟：将低功耗情景下不需要用到的模块直接关电，将要用到但速度要求不高的模块进入低速时钟工作。</li>
</ul>
<p>下面以PCIe的电源管理为例，介绍低功耗状态如何影响PLL的状态</p>
<p>（1）PCIe电源管理基本概念</p>
<p>PCIe的电源管理基本概念参考 <a href="https://www.intel.cn/content/www/cn/zh/io/pci-express/pci-express-architecture-power-management-rev-1-1-paper.html">PCI EXPRESS ARCHITECTURE POWER MANAGEMENT</a>, 也可以参考PCIe标准协议PCIe Base Spec</p>
<p>从上到下包含三层：系统电源状态(S)，PCIe链路电源状态(L)，PCIe设备电源状态(D)</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071046331.png" alt="Untitled Diagram"></p>
<ul>
<li>Sleep state</li>
</ul>
<p>S0 (Working): This is the active system state in which the platform appears to be “on.”  </p>
<p>S1&#x2F;POS, S1 (Microsoft* OS Stand By): These are the lowest wake latency sleeping states.  </p>
<p>S3 (Microsoft OS Stand By) and S4 (Microsoft OS Hibernate): S3 is a low wake latency sleeping state in which all device contexts are lost except system memory</p>
<p>S5 (Microsoft OS Soft-off): In this state, the OS does not save any context and requires a complete OS boot when the system wakes  </p>
<ul>
<li>Link States</li>
</ul>
<p>L0: Active state  </p>
<p>L1: This link state is a low exit latency link state that is intended to reduce power when the device becomes aware of a lack of outstanding requests or pending transactions  </p>
<p>L2&#x2F;L3 Ready: This link state prepares the PCI Express link for the removal of power and clock.   </p>
<p>L3 (link off): Power and clock are removed in this link state  </p>
<ul>
<li>Device States</li>
</ul>
<p>D0 (Fully-on): The device is completely active and responsive during this D-state  </p>
<p>D1 and D2: There is no universal definition for these D-states. In general, D1 is expected to save<br>less power but preserve more device context than D2  </p>
<p>D3 (Off): Primary power may be fully removed from the device (D3cold), or not removed from the device (D3hot). </p>
<p>S, L, D 三层状态的对应关系如下表</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071050761.png" alt="image-20230307105034704"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071050372.png" alt="image-20230307105052312"></p>
<p>注意，Link state是Sleep state对Device state作用的结果，即状态变化的过程是：</p>
<p>系统发起S3 -&gt; Device sate进入D3-&gt;Link state进入L2&#x2F;L3</p>
<p>（2）使用PLL控制Device state</p>
<p>Device sate进入D3, 设备内部操作即包含PLL的disable，将PLL模块整个关掉，保留OSC低速时钟作为退出D3状态的唤醒时钟源（软件上可以理解为heart beat），当PLL关掉后，其他依赖PLL的高速模块通常也断电，整个设备接近（或彻底）断电，因此设备功耗极低。</p>
<p>Device sate退出D3并进入D0则是相反过程，设备的PLL模块打开，其他依赖PLL的高速模块也打开，整个设备进入Active状态，功耗自然升高。</p>
<p>（3）使用PLL控制Link state</p>
<p>参考chapter11 of <a href="https://vdoc.pub/download/introduction-to-pci-express-a-hardware-and-software-developers-guide-1r2bcv8l7e6o">Introduction to PCI Express: A Hardware and Software Developer’s Guide</a></p>
<p>当PCIe link改变时，本质是PCIe时钟改变；PCIe host侧（bridge&#x2F;Root Complex）的时钟也是低速clock source经PLL倍频后的2.5GHz，如下图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071202081.png" alt="image-20230307120222026"></p>
<p>L1 link state的本质：The L1 Link state is an idle state with the internal Phase Lock Loop Circuit turned off. The source clock is still feeding a 100-megahertz differential clock signal to the PCI Express component.</p>
<p>L2 link state的本质：The L2 Link state is an optional auxiliary idle state with the internal Phase Lock Loop Circuit, the external clock source, and the main device power turned off (auxiliary power remains on)</p>
<p>总结就是：PCIe Link State本质是通过关闭PCIe host侧的PLL甚至clock source来实现的。</p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>PLL</tag>
      </tags>
  </entry>
  <entry>
    <title>高通平台编译Android系统镜像记录</title>
    <url>/2019/09/26/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91Android%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文记录在高通开发平台HDK845上编译Android系统镜像的过程</p>
<h2 id="一、-搭建Shadowsocks-Privoxy代理"><a href="#一、-搭建Shadowsocks-Privoxy代理" class="headerlink" title="一、 搭建Shadowsocks+Privoxy代理"></a>一、 搭建Shadowsocks+Privoxy代理</h2><h3 id="1-1为什么需要搭代理"><a href="#1-1为什么需要搭代理" class="headerlink" title="1.1为什么需要搭代理"></a>1.1为什么需要搭代理</h3><p>下载Android源码需要访问国外代码源，直接访问会被GFW阻挡，代理服务器（VPS）是未被GFW阻挡的国外服务器，通过代理服务器跳转至目标服务器访问国外代码源。</p>
<h3 id="1-2-shadowsocks-privoxy代理架构"><a href="#1-2-shadowsocks-privoxy代理架构" class="headerlink" title="1.2 shadowsocks+privoxy代理架构"></a>1.2 shadowsocks+privoxy代理架构</h3><p>使用shadowssocks+privoxy搭建客户端代理，如下图客户端进程发送请求（http&#x2F;https&#x2F;git）到privoxy，privoxy将请求转化为socks5请求，发送给shadowsocks客户端，shadowsocks处理socks5请求,将其发送到远端VPS上运行的socks5服务端（shadowsocks server），VPS再将请求转发给目标服务器。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281739480.png" alt="image001"></p>
<h3 id="1-3-shadowsocks-privoxy代理搭建"><a href="#1-3-shadowsocks-privoxy代理搭建" class="headerlink" title="1.3 shadowsocks+privoxy代理搭建"></a>1.3 shadowsocks+privoxy代理搭建</h3><h4 id="1-3-1-shadowsocks"><a href="#1-3-1-shadowsocks" class="headerlink" title="1.3.1 shadowsocks"></a>1.3.1 shadowsocks</h4><p>HOST系统：ubuntu 14.04 LTS<br>安装shadowsock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install python-pip </span><br><span class="line">pip install shadowsocks </span><br></pre></td></tr></table></figure>
<p>配置shadowsocks client</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /etc/ss.json </span><br><span class="line">输入以下内容: </span><br><span class="line">&#123; </span><br><span class="line">&quot;server&quot;:&quot;176.122.xxx.xx&quot;, </span><br><span class="line">&quot;server_port&quot;:8080, </span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;, </span><br><span class="line">&quot;local_port&quot;:1080, </span><br><span class="line">&quot;password&quot;:&quot;xxxxx&quot;, </span><br><span class="line">&quot;timeout&quot;:100, </span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行shadowsocks客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/ss.json &gt; ss.log 2&gt;&amp;1 &amp;  </span><br><span class="line">查看服务是否起来:  </span><br><span class="line">ps -ef | grep sslocal  </span><br></pre></td></tr></table></figure>
<p>若开机启动可写入<code>/etc/rc.local</code></p>
<h4 id="1-3-2-privoxy"><a href="#1-3-2-privoxy" class="headerlink" title="1.3.2 privoxy"></a>1.3.2 privoxy</h4><p>下载privoxy稳定版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz </span><br><span class="line">tar -zxvf privoxy-3.0.26-stable-src.tar.gz </span><br><span class="line">cd privoxy-3.0.26-stable </span><br></pre></td></tr></table></figure>
<p>privoxy服务需要新建privoxy用户,并添加到privoxy用户组来运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd privoxy </span><br><span class="line">groupadd -g 888 privoxy  </span><br><span class="line">gpasswd -a privoxy privoxy  </span><br></pre></td></tr></table></figure>
<p>查看privoxy用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id privoxy </span><br></pre></td></tr></table></figure>
<p>安装provoxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install autoconf </span><br><span class="line">autoheader &amp;&amp; autoconf</span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>
<p>设置privoxy监听http&#x2F;https&#x2F;git的端口，和privoxy面向socks5的端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /usr/local/etc/privoxy/config </span><br><span class="line">下面两行取消注释 </span><br><span class="line">listen-address 127.0.0.1:8118 </span><br><span class="line">forward-socks5t / 127.0.0.1:1080 </span><br></pre></td></tr></table></figure>
<p>启动privoxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privoxy --user privoxy /usr/local/etc/privoxy/config </span><br><span class="line">ps -ef | grep sslocal </span><br></pre></td></tr></table></figure>
<p>若开机启动可写入<code>/etc/rc.local</code></p>
<h4 id="1-3-3-设置代理环境变量"><a href="#1-3-3-设置代理环境变量" class="headerlink" title="1.3.3 设置代理环境变量"></a>1.3.3 设置代理环境变量</h4><p>http&#x2F;https&#x2F;ftp请求的代理端口设置为privoxy的监听端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /etc/profile </span><br><span class="line">export http_proxy=&quot;http://127.0.0.1:8118&quot; </span><br><span class="line">export https_proxy=&quot;http://127.0.0.1:8118&quot; </span><br><span class="line">export ftp_proxy=&quot;http://127.0.0.1:8118&quot; </span><br></pre></td></tr></table></figure>
<p>生效并测试, curl返回大堆json字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile </span><br><span class="line">curl http://www.google.com </span><br></pre></td></tr></table></figure>
<p>系统的http(s)等请求的代理配置完成</p>
<h4 id="1-3-4-设置git代理"><a href="#1-3-4-设置git代理" class="headerlink" title="1.3.4 设置git代理"></a>1.3.4 设置git代理</h4><p>安装并配置git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install git </span><br><span class="line">git config --global user.email &quot;yourname@xxx.com&quot;  </span><br><span class="line">git config --global user.name &quot;yourname&quot; </span><br><span class="line">git config --global http.proxy http://127.0.0.1:8118 </span><br><span class="line">git config --global https.proxy http://127.0.0.1:8118 </span><br></pre></td></tr></table></figure>
<p>设置git使用代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install connect-proxy </span><br><span class="line">mkdir ~/bin </span><br><span class="line">echo &quot;connect-proxy -S 127.0.0.1:1080 \&quot;\$@\&quot;&quot; &gt; ~/bin/socks5proxywrapper </span><br><span class="line">chmod 755 ~/bin/socks5proxywrapper </span><br><span class="line">git config --global core.gitproxy `echo $HOME`/bin/socks5proxywrapper </span><br></pre></td></tr></table></figure>

<h2 id="二、下载编译Android源码"><a href="#二、下载编译Android源码" class="headerlink" title="二、下载编译Android源码"></a>二、下载编译Android源码</h2><h3 id="2-1-交叉编译的概念"><a href="#2-1-交叉编译的概念" class="headerlink" title="2.1 交叉编译的概念"></a>2.1 交叉编译的概念</h3><p>- 1 本地编译：在当前编译平台下，编译出来的程序只能运行在当前平台。常见的应用软件开发的编译都属于本地编译。<br>- 2 交叉编译：在当前编译平台下，编译出来的程序能运行在另一种体系结构不同的目标平台上，但是编译平台本身却不能运行该程序。<br>- 3 交叉编译工具链：编译过程包括了预处理、编译、汇编、链接等过程。每个子过程都是单独的工具来实现。交叉编译链是为了编译跨平台体系结构的程序代码而形成的由多个子工具构成的一套完整的工具集。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281739906.png" alt="image003"><br>如上图，交叉编译工具链中最主要的部分包含编译器（如gcc）,汇编器（如as）,连接器（如ld）。通常as和ld及objcopy等其他工具由GNU打包成了binutils（binary utilitys)工具，再加上编译器组成整个工具链。<br>其中编译器命名规则为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arch-core-kernel-system-compiler </span><br><span class="line"></span><br><span class="line">arch：目标平台架构，如arm, x86_64 </span><br><span class="line">core： 目标平台的CPU Core，如Cortex A8 </span><br><span class="line">kernel： 目标平台所运行的OS，如Linux，Android </span><br><span class="line">systen：交叉编译链所选择的库函数和目标系统的规范，如gnu，gnueabi等 </span><br><span class="line">compiler: 编译器名，如gcc, g++,clang,clang++ </span><br></pre></td></tr></table></figure>

<p>- 4 交叉编译架构：<br>HOST OS 通常为Linux，包含自身的kernel、glibc基础库和Target程序的依赖库。Toolchain包含C&#x2F;C++及其他语言编译器和汇编、链接器等组件。Toolchain依赖于HOST的glibc基础库。Target binary是编译出的目标镜像&#x2F;程序，编译过程依赖于Toolchain及HOST的build essential libs。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740465.png" alt="image005"></p>
<h3 id="2-2-高通Android平台编译概念"><a href="#2-2-高通Android平台编译概念" class="headerlink" title="2.2 高通Android平台编译概念"></a>2.2 高通Android平台编译概念</h3><p>高通平台HDK845推荐的编译环境如下：</p>
<table>
<thead>
<tr>
<th>HOST</th>
<th>Toolchain</th>
<th>Source code repository</th>
<th>build out Android version</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu14.04 LTS</td>
<td>Clang&#x2F;LLVM</td>
<td>CAF</td>
<td>support Android 9 Pie</td>
</tr>
</tbody></table>
<p>高通平台HDK845推荐的编译流程如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740419.png" alt="image006"></p>
<p>Clang&#x2F;LLVM编译器介绍<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281748816.png" alt="clangLLVM"><br>CAF和AOSP的介绍  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAF is Code Aurora repository. It&#x27;s the place where Qualcomm releases source code for their phone processors.  </span><br><span class="line">It&#x27;s directly supported by Qualcomm and it&#x27;s generally a more optimized branch for Snapdragon phones.  </span><br><span class="line">Actually, there are two main baselines for support of Qualcomm devices:  </span><br><span class="line">- 1. CodeAurora (CAF) - These are Qualcomm&#x27;s reference sources for their platform.  </span><br><span class="line">This is what they provide to OEMs, and what nearly all OEMs base their software off of.  </span><br><span class="line">As a result - nearly all non-Nexus devices are running kernels/display HALs/etc. that are derived from a CAF baseline.  </span><br><span class="line">- 2. Google&#x27;s software baseline(AOSP) - Usually when Google starts working on a new Android version, they&#x27;ll fork from CAF at the beginning.  </span><br><span class="line">Very often Google will be adding &quot;new&quot; features specific to the new Android version, while Qualcomm will continue with performance enhancements and bugfixes against the &quot;old&quot; baseline.  </span><br><span class="line">- 3. So when a new Android revision comes out, you have two baselines: CAF which is usually &quot;ahead&quot; in performance but &quot;behind&quot; in features,  while AOSP is “behind” in performance (relatively) but “ahead” in features.  </span><br><span class="line">Nowadays, developers are directly compiling the builds from CAF source code which is really difficult as this is what Google does initially before upgrading to a new version,  </span><br><span class="line">and then they add features and the source by the time gets ‘compilable’, it is easier to compile the one on Google Sources than the one which is there on CAF.  </span><br><span class="line">CAF can be considered as Vanilla version of a Vanilla version of Android.  </span><br></pre></td></tr></table></figure>
<h3 id="2-3-高通Android平台编译流程"><a href="#2-3-高通Android平台编译流程" class="headerlink" title="2.3 高通Android平台编译流程"></a>2.3 高通Android平台编译流程</h3><p>- 1 安装jdk，用于编译Android源码中的java代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add-apt-repository ppa:openjdk-r/ppa </span><br><span class="line">apt-get update </span><br><span class="line">apt-get -y install openjdk-8-jdk </span><br><span class="line">update-alternatives --config java </span><br><span class="line">java -version </span><br></pre></td></tr></table></figure>
<p>- 2 安装HOST(ubuntu14.04)的build essentials，编译过程依赖这些工具和库 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip libssl-dev libc6:i386 libstdc++6:i386</span><br></pre></td></tr></table></figure>
<p>- 3 安装repo，用于下载android源码 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo </span><br><span class="line">chmod +x ~/bin/repo </span><br><span class="line">export PATH=~/bin:$PATH </span><br><span class="line">repo --help </span><br></pre></td></tr></table></figure>
<p>- 4 解压开发板厂商的BSP，其中包含源码下载的脚本、补丁包等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip Open-Q_845_Android-P_v2.1.zip </span><br><span class="line">cd Open-Q_845_Android-P_v2.1/Source_Package </span><br><span class="line">chmod +x getSource_and_build.sh </span><br></pre></td></tr></table></figure>
<p>- 5 用脚本从CAF源下载代码，打补丁后编译 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./getSource_and_build.sh </span><br></pre></td></tr></table></figure>

<p><code>./getSource_and_build.sh</code>内容如下 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNDER=&#x27;\e[4m&#x27; </span><br><span class="line">RED=&#x27;\e[31;1m&#x27; </span><br><span class="line">GREEN=&#x27;\e[32;1m&#x27; </span><br><span class="line">YELLOW=&#x27;\e[33;1m&#x27; </span><br><span class="line">BLUE=&#x27;\e[34;1m&#x27; </span><br><span class="line">MAGENTA=&#x27;\e[35;1m&#x27; </span><br><span class="line">CYAN=&#x27;\e[36;1m&#x27; </span><br><span class="line">WHITE=&#x27;\e[37;1m&#x27; </span><br><span class="line">ENDCOLOR=&#x27;\e[0m&#x27; </span><br><span class="line">ITCVER=&quot;P_v2.1&quot; </span><br><span class="line">WORKDIR=`pwd` </span><br><span class="line">CAFTAG=&quot;LA.UM.7.3.r1-06700-sdm845.0&quot; </span><br><span class="line">BUILDROOT=&quot;$&#123;WORKDIR&#125;/SDA845_Open-Q_845_Android-$&#123;ITCVER&#125;&quot; </span><br><span class="line">PATCH_DIR=&quot;$&#123;WORKDIR&#125;/patches&quot; </span><br><span class="line">DB_PRODUCT_STRING=&quot;Open-Q 845 HDK Development Kit&quot; </span><br><span class="line"></span><br><span class="line">function download_CAF_CODE() &#123; </span><br><span class="line"># Do repo sanity test </span><br><span class="line">if [ $? -eq 0 ] </span><br><span class="line">then </span><br><span class="line">  echo &quot;Downloading code please wait..&quot; </span><br><span class="line">  repo init -q -u git://codeaurora.org/platform/manifest.git -b release -m $&#123;CAFTAG&#125;.xml </span><br><span class="line">  repo sync -q -c -j 4 --no-tags --no-clone-bundle </span><br><span class="line">  if [ $? -eq 0 ] </span><br><span class="line">  then </span><br><span class="line">    echo -e &quot;$GREEN Downloading done..$ENDCOLOR&quot; </span><br><span class="line">  else </span><br><span class="line">    echo -e &quot;$RED!!!Error Downloading code!!!$ENDCOLOR&quot; </span><br><span class="line">  fi </span><br><span class="line">else </span><br><span class="line">  echo &quot;repo tool problem, make sure you have setup your build environment&quot; </span><br><span class="line">  echo &quot;1) http://source.android.com/source/initializing.html&quot; </span><br><span class="line">  echo &quot;2) http://source.android.com/source/downloading.html (Installing Repo Section Only)&quot; </span><br><span class="line">  exit -1 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to check result for failures </span><br><span class="line">check_result() &#123; </span><br><span class="line">if [ $? -ne 0 ] </span><br><span class="line">then </span><br><span class="line">  echo </span><br><span class="line">  echo -e &quot;$RED FAIL: Current working dir:$(pwd) $ENDCOLOR&quot; </span><br><span class="line">  echo </span><br><span class="line">  exit 1 </span><br><span class="line">else </span><br><span class="line">  echo -e &quot;$GREEN DONE! $ENDCOLOR&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to autoapply patches to CAF code </span><br><span class="line">apply_android_patches() </span><br><span class="line">&#123; </span><br><span class="line">  echo &quot;Applying patches ...&quot; </span><br><span class="line">  if [ ! -e $PATCH_DIR ] </span><br><span class="line">  then </span><br><span class="line">    echo -e &quot;$RED $PATCH_DIR : Not Found $ENDCOLOR&quot; </span><br><span class="line">    return </span><br><span class="line">  fi </span><br><span class="line">  cd $PATCH_DIR </span><br><span class="line">  patch_root_dir=&quot;$PATCH_DIR&quot; </span><br><span class="line">  android_patch_list=$(find . -type f -name &quot;*.patch&quot; | sort) &amp;&amp; </span><br><span class="line">  for android_patch in $android_patch_list; do</span><br><span class="line">    android_project=$(dirname $android_patch) </span><br><span class="line">    echo -e &quot;$YELLOW  applying patches on  $android_project ... $ENDCOLOR&quot; </span><br><span class="line">    cd $BUILDROOT/$android_project </span><br><span class="line">    if [ $? -ne 0 ]; then </span><br><span class="line">      echo -e &quot;$RED $android_project does not exist in BUILDROOT:$BUILDROOT $ENDCOLOR&quot; </span><br><span class="line">      exit 1 </span><br><span class="line">    fi </span><br><span class="line">    git am --3way $patch_root_dir/$android_patch </span><br><span class="line">    check_result </span><br><span class="line">  done </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to check whether host utilities exists </span><br><span class="line">check_program() &#123; </span><br><span class="line">for cmd in &quot;$@&quot; </span><br><span class="line">do </span><br><span class="line">  which $&#123;cmd&#125; &gt; /dev/null 2&gt;&amp;1 </span><br><span class="line">  if [ $? -ne 0 ] </span><br><span class="line">  then </span><br><span class="line">    echo </span><br><span class="line">    echo -e &quot;$RED Cannot find command \&quot;$&#123;cmd&#125;\&quot;  $ENDCOLOR&quot; </span><br><span class="line">    echo </span><br><span class="line">    exit 1 </span><br><span class="line">  fi </span><br><span class="line">done </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">#Main Script starts here </span><br><span class="line">#Note: Check necessary program for installation </span><br><span class="line">echo </span><br><span class="line">echo -e &quot;$CYAN Product          : $DB_PRODUCT_STRING $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Intrinsyc Release Version : $ITCVER $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA WorkDir          : $WORKDIR $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Build Root        : $BUILDROOT $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Patch Dir         : $PATCH_DIR $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA CodeAurora TAG      : $CAFTAG $ENDCOLOR&quot; </span><br><span class="line">echo -n &quot;Checking necessary program for installation......&quot; </span><br><span class="line">echo </span><br><span class="line">check_program tar repo git patch </span><br><span class="line">if [ -e $BUILDROOT ] </span><br><span class="line">then </span><br><span class="line">  cd $BUILDROOT </span><br><span class="line">else </span><br><span class="line">  mkdir $BUILDROOT </span><br><span class="line">  cd $BUILDROOT </span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">#1 Download code </span><br><span class="line">download_CAF_CODE </span><br><span class="line">cd $BUILDROOT </span><br><span class="line"></span><br><span class="line">#2 Apply Open-Q 845 HDK Development Kit Patches</span><br><span class="line">apply_android_patches </span><br><span class="line"></span><br><span class="line">#3 Extract the proprietary objs </span><br><span class="line">cd $BUILDROOT </span><br><span class="line">echo -e &quot;$YELLOW  Extracting proprietary binary package to $BUILDROOT ... $ENDCOLOR&quot; </span><br><span class="line">tar -xzvf ../proprietary.tar.gz -C vendor/qcom/ </span><br><span class="line"></span><br><span class="line">#4 Build </span><br><span class="line">echo -e &quot;$YELLOW  Building Source code from $BUILDROOT ... $ENDCOLOR&quot; </span><br><span class="line">if [[ -z &quot;$&#123;BUILD_NUMBER&#125;&quot; ]]; then export BUILD_NUMBER=$(date +%m%d%H%M); fi </span><br><span class="line">. build/envsetup.sh </span><br><span class="line">lunch sdm845-$&#123;BV:=&quot;userdebug&quot;&#125; </span><br><span class="line">ITC_ID=Open-Q_845_$&#123;ITCVER&#125; make -j $(nproc) $@ </span><br></pre></td></tr></table></figure>

<p>编译后生成bootloader和系统等镜像：<br>SDA845_Open-Q_845_Android-P_v2.1&#x2F;out&#x2F;target&#x2F;product&#x2F;sdm845&#x2F;xxx.img<br>后续重新编译只需要注释掉<code>./getSource_and_build.sh</code>的<code>步骤#1 #2 #3</code>，保留<code>#4 Build</code></p>
<h2 id="二、-烧写Android镜像"><a href="#二、-烧写Android镜像" class="headerlink" title="二、 烧写Android镜像"></a>二、 烧写Android镜像</h2><h3 id="3-1-烧写、调试、打印的工具"><a href="#3-1-烧写、调试、打印的工具" class="headerlink" title="3.1 烧写、调试、打印的工具"></a>3.1 烧写、调试、打印的工具</h3><p>开发板通过micro USB和type-C USB连接到主机<br>type-C: 用于开发板接收adb&#x2F;fastboot<br>micro USB： 用于HOST接收开发板的输出打印<br>连接如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740889.png" alt="image007"></p>
<p>HOST端用到的工具：<br>fastboot: 用于烧写Android镜像到开发板<br>adb(Android Debug Bridge): 用于调试Android系统<br>secureCRT: 用于查看开发板串口打印<br>- 1 首先配置fastboot和adb到系统环境变量，windows环境下<code>win + R</code>输入<code>cmd</code>配置<code>PATH</code>变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set PATH=%PATH%;d:\platform-tools\adb.exe</span><br><span class="line">set PATH=%PATH%;d:\platform-tools\fastboot.exe</span><br></pre></td></tr></table></figure>
<p>确认adb和fastboot加到了<code>PATH</code>环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo %PATH%</span><br></pre></td></tr></table></figure>
<p>- 2 查看开发板对应的com口，secureCRT新建会话，设置serial，设置com口和波特率115200</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740486.png" alt="image009"></p>
<h3 id="3-2-烧写镜像"><a href="#3-2-烧写镜像" class="headerlink" title="3.2 烧写镜像"></a>3.2 烧写镜像</h3><p>- 1 首先使开发版进入fastboot模式，连接micro USB，电源选项拨到DC电源, 上电后长按vol-, 然后连接type-C，串口打印出现<code>Fastboot: Processing commands</code>则进入fastboot。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740947.png" alt="image011"><br>- 2 <code>win + R</code>打开<code>cmd</code>，用fastboot烧写编译出来的镜像 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash system system.img </span><br><span class="line">fastboot flash persist persist.img </span><br><span class="line">fastboot flash boot boot.img  </span><br><span class="line">fastboot flash dtbo dtbo.img </span><br><span class="line">fastboot flash vbmeta vbmeta.img </span><br><span class="line">fastboot flash vendor vendor.img </span><br><span class="line">fastboot reboot </span><br></pre></td></tr></table></figure>
<p>可写入flash.bat脚本,放到系统镜像同一目录下运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off </span><br><span class="line"></span><br><span class="line">@echo Reboot bootloader... </span><br><span class="line">adb reboot bootloader </span><br><span class="line"></span><br><span class="line">@echo Flashing device... </span><br><span class="line">fastboot flash system system.img </span><br><span class="line">fastboot flash persist persist.img </span><br><span class="line">fastboot flash boot boot.img </span><br><span class="line">fastboot flash dtbo dtbo.img </span><br><span class="line">fastboot flash vbmeta vbmeta.img </span><br><span class="line">fastboot flash vendor vendor.img </span><br><span class="line"></span><br><span class="line">@echo Flashing finish, rebooting system... </span><br><span class="line">fastboot reboot </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281741449.png" alt="image012"><br>完成后系统重启进入Android桌面。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281741637.png" alt="image014"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
