<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++面向对象笔记：从C到C++</title>
    <url>/2020/03/14/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%8EC%E5%88%B0C/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>本章介绍C++语言和C语言相近的部分基础用法，包括</p>
<ul>
<li>引用: &amp;</li>
<li>常关键字: const</li>
<li>动态内存分配: new delete</li>
<li>函数内联: inline</li>
<li>函数重载</li>
</ul>
<h1 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h1><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。</p>
<pre><code>类型名 &amp; 引用名 = 某变量名;
</code></pre>
<p>某个变量的引用，等价于这个变量，相当于该变量起了一个别名。别名类似于操作系统的文件链接或快捷方式的概念，访问它变量本身的存储空间。</p>
<pre><code>int n = 4;
int &amp; r = n; // r引用了 n, r的类型是int &amp;
r = 4;
cout &lt;&lt; r; //输出 4
cout &lt;&lt; n; //输出 4
n = 5;
cout &lt;&lt; r; //输出5
</code></pre>
<p>注意：<br>1.定义引用时一定要将其初始化成引用某个变量。<br>2.初始化后，它就一直引用该变量，不会再引用别<br>的变量了。<br>3.引用只能引用变量，不能引用常量和表达式。</p>
<h2 id="引用的示例"><a href="#引用的示例" class="headerlink" title="引用的示例"></a>引用的示例</h2><p>引用常用于函数传参和返回值<br>1.引用作为函数入参<br>C语言写一个swap函数，交换两个变量的值，要传指针而不能传值，因为直接传值实际修改的是函数局部作用域的一份拷贝。</p>
<pre><code>void swap( int * a, int * b)
&#123;
    int tmp;
    tmp = * a; * a = * b; * b = tmp;
&#125;
int n1, n2;
swap(&amp; n1,&amp; n2) ; // n1,n2的值被交换
</code></pre>
<p>C++中，除了传指针，也可以传引用</p>
<pre><code>void swap( int &amp; a, int &amp; b)
&#123;
    int tmp;
    tmp = a; a = b; b = tmp;
&#125;
int n1, n2;
swap(n1,n2) ; // n1,n2的值被交换
</code></pre>
<p>2.引用作为函数返回值</p>
<pre><code>int n = 4;
int &amp; SetValue() &#123; return n; &#125;
int main()
&#123;
SetValue() = 40;
cout &lt;&lt; n;
return 0;
&#125; //输出： 40
</code></pre>
<h2 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h2><p>看上去引用和指针的功能相同，那区别在哪？<br>1.存储类型不同</p>
<ul>
<li>指针是一种变量，存储指向变量的地址值，通常占内存4字节（64位系统8字节）</li>
<li>引用只是变量的别名，它本身不另外占存储空间，对其求大小（sizeof）就是变量本身的大小</li>
</ul>
<p>指针是变量，因此可以为空（0x0）,而引用是标签（别名），不可为空，先有变量才能有其引用。<br>2.作用方式不同</p>
<ul>
<li>指针作为函数入参本质上还是是值传递，只不过传递的是变量的地址值，函数局部拷贝的也是地址。</li>
<li>引用作为函数入参，被调函数的形参作为局部变量在栈中开辟了内存空间，但存放的是主调函数的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。</li>
</ul>
<p>对于函数传参，形参都是用地址值达成对实参的修改，但传指针是显式的，而传引用是编译器隐式处理的。<br>指针和引用在内存中的示意图：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081643838.png" alt="image-20221208164349783"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081644997.png"></p>
<p>指针和引用的应用比较：<br>引用比指针使用起来形式上更为美观，使用引用指向的内容时可以之间用引用变量名，而不像指针一样要使用*；定义引用的时候也不用像指针一样使用&amp;取址。<br>引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针)。</p>
<h1 id="常量关键字const"><a href="#常量关键字const" class="headerlink" title="常量关键字const"></a>常量关键字const</h1><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>常量：不可被修改的内存单元<br>    const int MAX_VAL &#x3D; 23；<br>    const string SCHOOL_NAME &#x3D; “Peking University”；</p>
<h2 id="定义常引用"><a href="#定义常引用" class="headerlink" title="定义常引用"></a>定义常引用</h2><p>定义引用时，前面加const关键字，即为“常引用”。不能<strong>通过常引用修改</strong>其引用的变量，但可直接修改变量的值，引用本身也不能改变</p>
<pre><code>int n;
const int &amp; r = n;
r = 5; //error
n = 4; //ok
</code></pre>
<p><strong>const T &amp; 和T &amp; 是不同的数据类型!!!</strong><br>T &amp; 类型的引用或T类型的变量可以用来初始化const T &amp; 类型的引用，const T 类型的常变量和const T &amp; 类型的引用则不能用来初始化T &amp;类型的引用，除非进行强制类型转换<br>一句话，常指针和常引用不能出现在“&#x3D;”左边</p>
<h2 id="定义常指针"><a href="#定义常指针" class="headerlink" title="定义常指针"></a>定义常指针</h2><p>常指针也叫常量指针。但指针不是常量，指向的也不是常量，只是限制了改写方式：不可<strong>通过常量指针修改</strong>其指向变量的值，但可直接修改变量的值，也可以改变常量指针的指向地址值。</p>
<pre><code>int n,m;
const int * p = &amp; n;
* p = 5; //编译出错
n = 4; //ok
p = &amp;m; //ok, 常量指针的指向可以变化
</code></pre>
<p>不能把常量指针赋值给非常量指针，反过来可以</p>
<pre><code>const int * p1; int * p2;
p1 = p2; //ok
p2 = p1; //error
p2 = (int * ) p1; //ok,强制类型转换
</code></pre>
<p>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容</p>
<pre><code>void MyPrintf( const char * p )
&#123;
strcpy( p,&quot;this&quot;); //编译出错
printf(&quot;%s&quot;,p); //ok
&#125;
</code></pre>
<h2 id="定义指针常量"><a href="#定义指针常量" class="headerlink" title="定义指针常量"></a>定义指针常量</h2><p>定义：本质是一个不可修改指向地址的指针 </p>
<pre><code>int* const p;
</code></pre>
<h2 id="定义指向常量的常指针"><a href="#定义指向常量的常指针" class="headerlink" title="定义指向常量的常指针"></a>定义指向常量的常指针</h2><p>定义：指针指向的地址值不可修改，且该地址中的值也不可修改</p>
<pre><code>const int* const p;
</code></pre>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>动态内存分配是分配内存空间中堆（heap）的内存，实际上是程序内手动的内存分配与释放。并非堆栈中局部变量的入栈出栈，由操作系统控制的动态分配。</p>
<h2 id="new分配内存"><a href="#new分配内存" class="headerlink" title="new分配内存"></a>new分配内存</h2><p>分配一个变量:</p>
<pre><code>P = new T;
</code></pre>
<p>T是任意类型名， P是类型为T * 的指针。<br>动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P：</p>
<pre><code>int * pn = new int;
* pn = 5;
</code></pre>
<p>分配一个数组：</p>
<pre><code>P = new T[N];
</code></pre>
<p>T :任意类型名<br>P :类型为T * 的指针<br>N :要分配的数组元素的个数，可以是整型表达式<br>动态分配出一片大小为 sizeof(T)*N字节的内存空间，并且将该内存空间的起始地址赋值给P</p>
<pre><code>int * pn;
int i = 5;
pn = new int[i * 20];
pn[0] = 20;
pn[100] = 30; //编译没问题。运行时导致数组越界
</code></pre>
<h2 id="delete释放内存"><a href="#delete释放内存" class="headerlink" title="delete释放内存"></a>delete释放内存</h2><p>用“new”动态分配的内存空间用完后，一定要用“delete”运算符进行释放，否则操作系统无法再次使用这块内存，造成内存泄露<br>注意：不能对内存空间delete两次！</p>
<pre><code>#delete 指针； //该指针必须指向new出来的空间
int * p = new int;
* p = 5;
delete p;
delete p; //导致异常， 一片空间不能被delete多次
</code></pre>
<p>用“delete”释放动态分配的数组，要加“[]”</p>
<pre><code>#delete [] 指针； //该指针必须指向new出来的数组
int * p = new int[20];
p[0] = 1;
delete [] p;
</code></pre>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>普通函数：编译出来的可执行程序加载到内存后，代码段只有一份函数的指令序列，函数的调用处就用一个类似jump的语句跳转到函数指令序列的入口地址<br>内联函数：函数的每个调用处都存在整个函数指令序列的拷贝<br>简单讲就是增加编译出来的代码占用空间，换取运行时频繁入栈出栈的时间开销<br>使用场景：简单函数体且多次调用可以定义为内联<br>函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</p>
<pre><code>inline int Max(int a,int b)
&#123;
if( a &gt; b) return a;
return b;
&#125;
</code></pre>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="函数重载概念"><a href="#函数重载概念" class="headerlink" title="函数重载概念"></a>函数重载概念</h2><p>重载不是重新载入，更贴切的含义是重复定义，因为重定义是种错误，重载可以理解为编译器能理解的“重定义”，因此能正常加载。<br>C++重载主要有：</p>
<ul>
<li>函数重载</li>
<li>运算符重载</li>
</ul>
<p>C++的类没有重载一说，本节讲函数重载<br>函数重载：一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。</p>
<pre><code>int Max(double f1,double f2) &#123; &#125;
int Max(int n1,int n2) &#123; &#125;
int Max(int n1,int n2,int n3) &#123; &#125;
</code></pre>
<p>Q1.重载有什么用？<br>C语言定义以上几个函数，不能用同名，但是其功能都是相同的，仅参数类型和值不同。如果用MaxDouble(),MaxInt2(),MaxInt3()过于麻烦。<br>因此函数重载使得函数命名变得简单。<br>Q2.编译器怎么知道调用的是哪个？<br>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数，注意重载函数不会把入参自动类型转换，调用二义性会报错。</p>
<pre><code>Max(3.4,2.5); //调用 (1)
Max(2,4); //调用 (2)
Max(1,2,3); //调用 (3)
Max(3,2.4); //error,二义性
</code></pre>
<p>Q3.函数仅返回值类型不同是不是重载？<br>不是，函数重载的区分在于入参。但是有个例外，返回const T和非const T的两个函数是是重载的，其他情况的入参相同，返回类型不同的函数，视为重定义。</p>
<h2 id="缺省参数与可拓展性"><a href="#缺省参数与可拓展性" class="headerlink" title="缺省参数与可拓展性"></a>缺省参数与可拓展性</h2><p>C++函数支持缺省参数（默认参数值）。定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。</p>
<pre><code>void func( int x1, int x2 = 2, int x3 = 3)
&#123; &#125;
func(10 ) ; //等效于 func(10,2,3)
func(10,8) ; //等效于 func(10,8,3)
func(10, , 8) ; //不行,只能最右边的连续若干个参数缺省
</code></pre>
<p>函数参数可缺省的目的在于提高程序的可扩充性。<br>如果某个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，那么为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。<br>在C语言中，如果函数新增一个入参，所有调用该函数的地方都要传入该入参值；C++支持缺省参数，只需要改函数定义即可，调用处不需要动。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL类使用笔记</title>
    <url>/2020/12/01/C-STL%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><p><strong>查找指定字符串的位置（下标）</strong></p>
<p>string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）</p>
<pre><code>//find函数返回类型 size_type
string s(&quot;1a2b3c4d5e6f7jkg8h9i1a2b3c4d5e6f7g8ha9i&quot;);
int position;
//find 函数 返回jk 在s 中的下标位置
position = s.find(&quot;jk&quot;);
if (position != s.npos)  //如果没找到，返回一个特别的标志c++中用npos表示
&#123;
    printf(&quot;position is : %d\n&quot; ,position);
&#125;
else
&#123;
    printf(&quot;Not found the flag\n&quot;);
&#125;
</code></pre>
<p>##查找某字符首次出现，或最后出现的位置<br>find_first_of() 和 find_last_of()返回子串出现在母串中的首次出现的位置，和最后一次出现的位置<br>查找上面示例的’c’的下标：</p>
<pre><code>flag = &quot;c&quot;;
position = s.find_first_of(flag);
printf(&quot;s.find_first_of(flag) is :%d\n&quot;,position);
position = s.find_last_of(flag);
printf(&quot;s.find_last_of(flag) is :%d\n&quot;,position);
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081711721.png" alt="image-20221208171122674"></p>
<p><strong>查找某给定位置后的子串的位置</strong></p>
<pre><code>//从字符串s 下标5开始，查找字符串b ,返回b 在s 中的下标
position=s.find(&quot;b&quot;,5);
cout&lt;&lt;&quot;s.find(b,5) is : &quot;&lt;&lt;position&lt;&lt;endl;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081711350.png"></p>
<p><strong>查找所有子串在母串中出现的位置</strong></p>
<pre><code>//查找s 中flag 出现的所有位置。
flag=&quot;a&quot;;
position=0;
int i=1;
while((position=s.find(flag,position))!=string::npos)
&#123;
    cout&lt;&lt;&quot;position  &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;position&lt;&lt;endl;
    position++;
    i++;
&#125;
</code></pre>
<h1 id="map与unordered-map的区别"><a href="#map与unordered-map的区别" class="headerlink" title="map与unordered_map的区别"></a>map与unordered_map的区别</h1><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p><strong>map：</strong><br>map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），<strong>红黑树具有自动排序的功能，因此map内部的所有元素都是有序的</strong>，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>
<p><strong>unordered_map:</strong><br>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，<strong>查找的时间复杂度可达到O(1</strong>)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<h2 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h2><p><strong>map</strong><br>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。<br>红黑树结构：内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>
<p>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红&#x2F;黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map：</strong></p>
<p>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结：</strong><br>两种map性能分析的内存占用比较，就是红黑树 VS hash表的性能比较, 还是unorder_map占用的内存要高。<br>但是unordered_map查找的时间复杂度低，执行效率要比map高很多。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>unordered_map的用法和map是一样的，都提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。但其内部实现是不同的，对使用者来说不可见。</p>
<p>示例（map_and_unordered.cpp）：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;unordered_map&gt;  
#include &lt;map&gt;
#include &lt;string&gt;  

using namespace std;  

int main()  
&#123;  
    ////使用&#123;&#125;赋值, 注意：C++11才开始支持括号初始化
    unordered_map&lt;int, string&gt; myMap = &#123;&#123; 3, "C" &#125;,&#123; 4, "D" &#125;&#125;; 
    //使用[ ]进行单个插入，若已存在键值2，则修改其值
    myMap[1] = &quot;A&quot;;  
    myMap.insert(pair&lt;int, string&gt;(2, &quot;B&quot;));//使用insert和pair插入
  
    //遍历输出+迭代器的使用
    //auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator
    auto iter = myMap.begin(); 
    while (iter!= myMap.end())
    &#123;  
        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;  
        ++iter;  
    &#125;  
    
    //查找元素并输出+迭代器的使用
    //find()返回一个指向2的迭代器
    auto iterator = myMap.find(2);
    if (iterator != myMap.end())
        cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iterator-&gt;second &lt;&lt; endl;  
     
    return 0;  
&#125;
</code></pre>
<p>编译：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081713270.png" alt="image-20221208171339229"></p>
<p>结果：<br>unordered_map：没有按值的大小排序，从最近插入的到最早插入的，依次显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081714465.png" alt="image-20221208171412418"><br>把unordered_map改成map: 按值的大小，从小到大显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081713971.png" alt="image-20221208171351937"></p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>sort()函数是STL中的排序函数，由模板函数实现，复杂度N*logN。该函数专门用来对容器或普通数组中指定范围内的元素进行排序，该函数使用频率较高，且其实现综合了几种经典排序方法<br>使用格式如下：</p>
<pre><code>sort (first, last) //排序从first到last的数据，默认从小到大
sort (first, last, rule) //以某种规则排序，rule可使用std定义的，或自定义实现
</code></pre>
<h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><p>几种典型的使用方式：</p>
<ul>
<li>默认：从小到大</li>
<li>greater&lt; Type &gt;()：std提供的从大到小</li>
<li>自定义规则：函数，运算符，Lambda实现，这里规则都是传入两个参数（分别是要比较数组的靠左值，靠右值），返回bool类型，如果左值&lt;右值，即从小到大排序，反之从大到小</li>
</ul>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::sort
#include &lt;vector&gt;       // std::vector
#include &lt;stdlib.h&gt;

using namespace std;

//以普通函数的方式实现自定义排序规则
bool myComp(int i, int j) &#123;
    return (i &lt; j);
&#125;

//以对象的方式实现自定义排序规则
class myCompOper &#123;
public:
    bool operator() (int i, int j) &#123;
        return (i &gt; j);
    &#125;
&#125;;

//打印数组
void print_array(std::vector&lt;int&gt; &amp;a, const char *s)
&#123;
    printf(&quot;%s\n&quot;, s);
    vector&lt;int&gt;::iterator it;
    for (it = a.begin(); it != a.end(); ++it)
    &#123;
        printf(&quot;%d &quot;, *it);
    &#125;
    printf(&quot;\n&quot;);
&#125;

int main() &#123;
    //std::vector&lt;int&gt; array;
    //char num;
    //while(cin.get() != &#39;\n&#39;)
    //&#123;
    //    cin &gt;&gt; num;
    //    array.push_back(num);
    //&#125;

    vector&lt;int&gt; array&#123;1,3,4,2,5,7,6,8,9&#125;;
    print_array(array, &quot;input array:&quot;);

    //默认排序，从小到大
    std::sort(array.begin(), array.end());
    print_array(array, &quot;default sort:&quot;);

    //使用STL标准库提供的其它比较规则, 比如 greater&lt;T&gt;，从大到小
    std::sort(array.begin(), array.end(), std::greater&lt;int&gt;());
    print_array(array, &quot;std::greater&lt;T&gt; sort:&quot;);

    //自定义比较规则: 普通函数
    std::sort(array.begin(), array.end(), myComp);
    print_array(array, &quot;myComp sort:&quot;);

    //自定义比较规则: 类内运算符重载
    std::sort(array.begin(), array.end(), myCompOper());
    print_array(array, &quot;myCompOper sort:&quot;);

    //自定义比较规则: Lambda匿名函数
    std::sort(array.begin(), array.end(), [](int i, int j) &#123;return i &lt; j;&#125;);
    print_array(array, &quot;Lambda sort:&quot;);
</code></pre>
<p>​<br>        return 0;<br>    }</p>
<p>结果如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081715702.png" alt="image-20221208171536663"></p>
<h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p>
<p><strong>(1)普通快排</strong><br>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p>
<ul>
<li>如果S中的元素只有0个或1个，结束。</li>
<li>取S中的任何一个元素作为枢轴pivot。</li>
<li>将S分割为L、R两端，使L内的元素都小于等于pivot，R内的元素都大于等于pivot。 </li>
<li>对L、R递归执行上述过程。</li>
</ul>
<p>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称为median-of-three，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p>
<p>分割的方法通常采用两个迭代器head和tail，head从头端往尾端移动，tail从尾端往头端移动，当head遇到大于等于pivot的元素就停下来，tail遇到小于等于pivot的元素也停下来，若head迭代器仍然小于tail迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p>
<p><strong>(2)内省式排序 Introsort</strong><br>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 O(n2)。David R.Musser于1996年提出一种混合式排序算法：Introspective Sorting（内省式排序），简称IntroSort，其行为大部分与上面所说的median-of-three Quick Sort完全相同，但是当分割行为有恶化为二次方的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 O(nlgn)，又比一开始就使用堆排序来得好。</p>
<p>sort声明：</p>
<pre><code>#include &lt;algorithm&gt;
 
template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );
 
template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );
</code></pre>
<p>sort实现：</p>
<pre><code>template &lt;class _RandomAccessIter&gt;
inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123;
  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,
                 _LessThanComparable);
  if (__first != __last) &#123;
    __introsort_loop(__first, __last,
                     __VALUE_TYPE(__first),
                     __lg(__last - __first) * 2);
    __final_insertion_sort(__first, __last);
  &#125;
&#125;
</code></pre>
<p>__introsort_loop便是上面介绍的内省式排序，其第三个参数中所调用的函数__lg()便是用来控制分割恶化情况，求lg(n)（取下整），意味着快速排序的递归调用最多 2*lg(n) 层。<br>__lg()实现如下</p>
<pre><code>template &lt;class Size&gt;
inline Size __lg(Size n) &#123;
    Size k;
    for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k;
    return k;
&#125;
</code></pre>
<p>__introsort_loop实现：</p>
<ul>
<li>首先判断元素规模是否大于阀值__stl_threshold，__stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。</li>
<li>若元素规模大于__stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。</li>
<li>若没有超过递归调用深度，则调用函数__unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。</li>
<li>经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。</li>
</ul>
<p>递归上述过程，直到元素规模小于__stl_threshold，然后返回sort函数，对整个元素序列调用一次插入排序，此时序列中的元素已基本有序，所以插入排序也很快。至此，整个sort函数运行结束。</p>
<p>__introsort_loop代码：</p>
<pre><code>template &lt;class _RandomAccessIter, class _Tp, class _Size&gt;
void __introsort_loop(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Tp*,
                      _Size __depth_limit)
&#123;
  while (__last - __first &gt; __stl_threshold) &#123;
    if (__depth_limit == 0) &#123;
      partial_sort(__first, __last, __last);
      return;
    &#125;
    --__depth_limit;
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1))));
    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit);
    __last = __cut;
  &#125;
&#125;
</code></pre>
<p>__unguarded_partition()函数</p>
<pre><code>template &lt;class _RandomAccessIter, class _Tp&gt;
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, 
                                        _RandomAccessIter __last, 
                                        _Tp __pivot) 
&#123;
    while (true) &#123;
        while (*__first &lt; __pivot)
            ++__first;
        --__last;
        while (__pivot &lt; *__last)
            --__last;
        if (!(__first &lt; __last))
            return __first;
        iter_swap(__first, __last);
        ++__first;
    &#125;
&#125;
</code></pre>
<p>参考： 《STL源码剖析》–侯捷</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：模板、泛型与STL</title>
    <url>/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++除了支持面向对象，也支持函数的扩展和重用。继承类和多态充分支持了扩展，即基类进行概括抽象的设计，派生类实现具体的设计。那么重用呢，如何写一个函数，能在多种情况不加修改的套用？<br>考虑以下问题：</p>
<pre><code>交换两个整型变量的值的Swap函数：
void Swap(int &amp; x,int &amp; y)
&#123;
    int tmp = x;
    x = y;
    y = tmp;
&#125;
交换两个double型变量的值的Swap函数:
void Swap(double &amp; x,double &amp; y)
&#123;
    double tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>这两个函数除了入参类型不同，函数名，参数个数，返回类型都相同。函数体的处理流程也完全一样。能否只写一个Swap，就能交换各种类型的变量？<br>模板（template）将解决这种问题。</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="函数模板的概念"><a href="#函数模板的概念" class="headerlink" title="函数模板的概念"></a>函数模板的概念</h2><p>用函数模板，设计仅数据类型不同的一组函数的通用模板：</p>
<pre><code>template &lt;class 类型参数1，class 类型参数2,……&gt;
返回值类型 模板名 (形参表)
&#123;
    函数体
&#125;;

template &lt;class T&gt; //在函数前声明模板，参数类型（class）是T
void Swap(T &amp; x,T &amp; y)
&#123;
    T tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>在普通函数前，先用template&lt; class T &gt;声明参数类型T，就可以在函数体使用T，就像使用普通变量一样。在运行时，T传入的类型不同，函数处理的数据类型也不同。<br>函数模板是如何实现的？它是一种函数吗？</p>
<pre><code>int main()
&#123;
    int n = 1,m = 2;
    Swap(n,m); //编译器自动生成 void Swap(int &amp; ,int &amp; )函数
    double f = 1.2,g = 2.3;
    Swap(f,g); //编译器自动生成 void Swap(double &amp; ,double &amp; )函数
    return 0;
&#125;
</code></pre>
<p>函数模板只是个模子，编译器通过模板和具体参数类型产生不同的函数。编译器会进行两次编译，第一次检测模板代码，第二次检测加参数后的具体函数代码。<br>在调用以上函数模板时，实际会生成两个具体函数：</p>
<pre><code>void Swap(int &amp; x,int &amp; y)
&#123;
    int tmp = x;
    x = y;
    y = tmp;
&#125;
void Swap(double &amp; x,double &amp; y)
&#123;
    double tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>函数模板，可以理解为一种函数的宏，编译期在宏被调用的地方，全部替换成宏所对应的具体值。<br>函数模板和运行时函数，也类似于类和对象的关系，类只是类型，对象是给类分配了内存的实例。函数模板只是通用的类型，函数实例是函数模板的实例化对象。</p>
<h2 id="函数模板的特性"><a href="#函数模板的特性" class="headerlink" title="函数模板的特性"></a>函数模板的特性</h2><p>函数模板中可以有不止一个类型参数</p>
<pre><code>template &lt;class T1, class T2&gt;
T2 print(T1 arg1, T2 arg2)
&#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
    return arg2;
&#125;
</code></pre>
<p>不通过参数也能实例化函数模板</p>
<pre><code>template &lt;class T&gt;
T Inc(T n)
&#123;
    return 1 + n;
&#125;
int main()
&#123;
    cout &lt;&lt; Inc&lt;double&gt;(4)/2; //显式实例化模板，输出 2.5
    return 0;
&#125;
</code></pre>
<h2 id="函数模板与重载"><a href="#函数模板与重载" class="headerlink" title="函数模板与重载"></a>函数模板与重载</h2><p>函数模板和函数重载，在写法上很接近，都是一组参数不同的同名函数。它们有什么联系和区别？</p>
<ul>
<li>函数重载，关键在参数个数</li>
<li>函数模板，关键在参数类型</li>
</ul>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<pre><code>template&lt;class T1, class T2&gt;
void print(T1 arg1, T2 arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
template&lt;class T&gt;
void print(T arg1, T arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
template&lt;class T,class T2&gt;
void print(T arg1, T arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
</code></pre>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一条函数调用语句:</p>
<ol>
<li><p>先找参数完全匹配的普通函数(非由模板实例化而得的函数)</p>
</li>
<li><p>再找参数完全匹配的模板函数。</p>
</li>
<li><p>再找实参数经过自动类型转换后能够匹配的普通函数。</p>
</li>
</ol>
<ol start="4">
<li><p>上面的都找不到，则报错<br>如果有函数重载，在第（1）步就找到，如果没有，才找（2）的函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"> T Max( T a, T b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> template &lt;class T,class T2&gt;</span><br><span class="line"> T Max( T a, T2 b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax2&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> double Max(double a, double b)&#123;</span><br><span class="line">     cout &lt;&lt; &quot;MyMax&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main() &#123;</span><br><span class="line">     int i=4, j=5;</span><br><span class="line">     Max( 1.2,3.4); // 输出MyMax</span><br><span class="line">     Max(i, j); //输出TemplateMax</span><br><span class="line">     Max( 1.2, 3); //输出TemplateMax2</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意上文的步骤（2）（3）是分开的，匹配模板函数时，是不进行类型自动转换的，不匹配就是不匹配。输入参数有二义性时。编译器不会为开发者做决定</p>
<pre><code>template&lt;class T&gt;
T myFunction( T arg1, T arg2)
&#123; cout&lt;&lt;arg1&lt;&lt;&quot; &quot;&lt;&lt;arg2&lt;&lt;&quot;\n&quot;; return arg1;&#125;
……
myFunction( 5, 7); //ok： replace T with int
myFunction( 5.8, 8.4); //ok： replace T with double
myFunction( 5, 8.4); //error， no matching function for call to &#39;myFunction(int, double)&#39;
</code></pre>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="类模板的概念"><a href="#类模板的概念" class="headerlink" title="类模板的概念"></a>类模板的概念</h2><p>类也能使用模板，来生成不同成员类型的类<br>类模板：在定义类的时候，加上一个&#x2F;多个类型参数。在使用类模板时，指定类型参数应该如何替换成具体类型，编译器据此生成相应的模板类</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
class 类模板名
&#123;
    成员函数和成员变量
&#125;;
</code></pre>
<p>类模板的成员函数的定义写法：</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名（ 参数表）
&#123;
    ……
&#125;
</code></pre>
<p>用类模板实例化对象的写法：</p>
<pre><code>类模板名 &lt;真实类型参数表&gt; 对象名(构造函数实参表);
</code></pre>
<p>一个例子：map类型中的pair类的实现：</p>
<pre><code>template &lt;class T1,class T2&gt;    //pair是类模板
class Pair
&#123;
public:
    T1 key; //关键字
    T2 value; //值
    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;; //构造函数
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const; //运算符重载函数
&#125;;

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
//Pair的运算符重载函数的定义
&#123;
    return key &lt; p.key;
&#125;

 int main()
&#123;
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,19); //实例化出一个类 Pair&lt;string,int&gt;
    cout &lt;&lt; student.key &lt;&lt; &quot; &quot; &lt;&lt; student.value;
    return 0;
&#125;
</code></pre>
<p>输出：Tom 19<br>编译器由类模板生成类的过程叫类模板的实例化。 由类模板实例化得到的类， 叫模板类<br>同一个类模板的两个模板类是不兼容的，即两个不同的类</p>
<pre><code>Pair&lt;string,int&gt; * p;
Pair&lt;string,double&gt; a;
p = &amp; a; //错误，不是同类也不是继承类，不能赋值
</code></pre>
<p>函数模版可以作为类模板成员</p>
<pre><code>template &lt;class T&gt;
class A
&#123;
public:
    template&lt;class T2&gt;
    void Func( T2 t) &#123; cout &lt;&lt; t; &#125; //成员函数模板
&#125;;
int main()
&#123;
    A&lt;int&gt; a;
    a.Func(&#39;K&#39;); //成员函数模板 Func被实例化
    a.Func(&quot;hello&quot;); //成员函数模板 Func再次被实例化
    return 0;
&#125; //输出： KHello
</code></pre>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数：</p>
<pre><code>template &lt;class T, int size&gt;
class CArray&#123;
    T array[size];
    public:
    void Print( )
    &#123;
        for( int i = 0;i &lt; size; ++i)
        cout &lt;&lt; array[i] &lt;&lt; endl;
    &#125;
&#125;;

CArray&lt;double,40&gt; a2;
CArray&lt;int,50&gt; a3;
</code></pre>
<h2 id="类模板的派生"><a href="#类模板的派生" class="headerlink" title="类模板的派生"></a>类模板的派生</h2><p>类模板也支持类的派生：<br>• 类模板从类模板派生<br>• 类模板从模板类派生<br>• 类模板从普通类派生<br>• 普通类从模板类派生</p>
<p>(1)类模板从类模板派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A &#123;
    T1 v1; T2 v2;
&#125;;

template &lt;class T1,class T2&gt;
class B:public A&lt;T2,T1&gt; &#123;
    T1 v3; T2 v4;
&#125;;

template &lt;class T&gt;
class C:public B&lt;T,T&gt; &#123;
    T v5;
&#125;;

int main() &#123;
    B&lt;int,double&gt; obj1;
    C&lt;int&gt; obj2;
    return 0;
&#125;
</code></pre>
<p>(2)类模板从模板类派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A &#123;
    T1 v1; T2 v2;
&#125;;

template &lt;class T&gt;
class B:public A&lt;int,double&gt; &#123;
    T v;
&#125;;

int main() &#123;
    B&lt;char&gt; obj1; //自动生成两个模板类：A&lt;int,double&gt; 和 B&lt;char&gt;
    return 0;
&#125;
</code></pre>
<p>(3)类模板从普通类派生</p>
<pre><code>class A &#123;
    int v1;
&#125;;

template &lt;class T&gt;
class B:public A &#123; //所有从B实例化得到的类， 都以A为基类
    T v;
&#125;;

int main() &#123;
    B&lt;char&gt; obj1;
    return 0;
&#125;
</code></pre>
<p>(4)普通类从模板类派生</p>
<pre><code>template &lt;class T&gt;
class A &#123;
    T v1;
    int n;
&#125;;

class B:public A&lt;int&gt; &#123;
    double v;
&#125;;
int main() &#123;
    B obj1;
    return 0;
&#125;
</code></pre>
<h2 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h2><p>• 函数、类、类的成员函数作为类模板的友元<br>• 函数模板作为类模板的友元<br>• 函数模板作为类的友元<br>• 类模板作为类模板的友元</p>
<p>(1)函数、类、类的成员函数作为类模板的友元</p>
<pre><code>void Func1() &#123; &#125;
class A &#123; &#125;;
class B
&#123;
    public:
    void Func() &#123; &#125;
&#125;;

template &lt;class T&gt;
class Tmpl
&#123;
    friend void Func1();
    friend class A;
    friend void B::Func();
&#125;; //任何从Tmp1实例化来的类， 都有以上三个友元
</code></pre>
<p>(2)函数模板作为类模板的友元</p>
<pre><code>template &lt;class T1,class T2&gt;
class Pair
&#123;
private:
    T1 key; //关键字
    T2 value; //值
public:
    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;;
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const;
    template &lt;class T3,class T4&gt;
    friend ostream &amp; operator&lt;&lt; ( ostream &amp; o,
    const Pair&lt;T3,T4&gt; &amp; p);
&#125;;

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
&#123; //&quot;小&quot;的意思就是关键字小
    return key &lt; p.key;
&#125;
template &lt;class T1,class T2&gt;
ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)
&#123;
    o &lt;&lt; &quot;(&quot; &lt;&lt; p.key &lt;&lt; &quot;,&quot; &lt;&lt; p.value &lt;&lt; &quot;)&quot; ;
    return o;
&#125;

int main()
&#123;
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,29);
    Pair&lt;int,double&gt; obj(12,3.14);
    cout &lt;&lt; student &lt;&lt; &quot; &quot; &lt;&lt; obj;
    return 0;
&#125;

输出：
(Tom,29) (12,3.14)
</code></pre>
<p>任意从 <code>template &lt;class T1,class T2&gt; ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)</code>生成的函数，都是任意Pair摸板类的友元</p>
<p>(3)函数模板作为类的友元</p>
<pre><code>class A
&#123;
    int v;
    public:
    A(int n):v(n) &#123; &#125;
    template &lt;class T&gt;
    friend void Print(const T &amp; p);
&#125;;
template &lt;class T&gt;
void Print(const T &amp; p)
&#123;
    cout &lt;&lt; p.v;
&#125;

int main() &#123;
    A a(4);
    Print(a);
    return 0;
&#125;

输出：
4
</code></pre>
<p>所有从 <code>template &lt;class T&gt; void Print(const T &amp; p)</code><br>生成的函数，都成为 A 的友元</p>
<p>(4)类模板作为类模板的友元</p>
<pre><code>template &lt;class T&gt;
class B &#123;
    T v;
    public:
    B(T n):v(n) &#123; &#125;
    template &lt;class T2&gt;
    friend class A;
&#125;;

template &lt;class T&gt;
class A &#123;
public:
    void Func( ) &#123;
        B&lt;int&gt; o(10);
        cout &lt;&lt; o.v &lt;&lt; endl;
    &#125;
&#125;;

int main()
&#123;
    A&lt; double &gt; a;
    a.Func ();
    return 0;
&#125;

输出：
10
</code></pre>
<p>A&lt; double&gt;类，成了B<int>类的友元。任何从A模版实例化出来的类，都是任何B实例化出来的类的友元</p>
<h2 id="类模板与静态成员"><a href="#类模板与静态成员" class="headerlink" title="类模板与静态成员"></a>类模板与静态成员</h2><p>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员</p>
<pre><code>template &lt;class T&gt;
class A
&#123;
private:
    static int count;
    public:
    A() &#123; count ++; &#125;
    ~A() &#123; count -- ; &#125;;
    A( A &amp; ) &#123; count ++ ; &#125;
    static void PrintCount() &#123; cout &lt;&lt; count &lt;&lt; endl; &#125;
&#125;;

template&lt;&gt; int A&lt;int&gt;::count = 0;
template&lt;&gt; int A&lt;double&gt;::count = 0;
int main()
&#123;
    A&lt;int&gt; ia;
    A&lt;double&gt; da;
    ia.PrintCount();
    da.PrintCount();
    return 0;
&#125;

输出：
1 1
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：类和对象</title>
    <url>/2020/03/18/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++，加的到底是什么？<br>除了基础语法的补充和优化，C++另外几个核心特点是：</p>
<ul>
<li><p>面向对象设计的支持：</p>
<p> 类和对象对变量和函数的封装<br> 类和类之间的继承<br> 继承关系的类之间的函数调用的多态</p>
</li>
<li><p>数据结构和算法的支持<br> STL和各种常用数据类型</p>
</li>
<li><p>高可复用、可拓展的支持<br> 类模板，函数模板<br> 函数、运算符的重载</p>
</li>
</ul>
<p>本文内容：</p>
<ul>
<li>面向对象设计的概念</li>
<li>类和对象的概念及使用</li>
<li>类的几种构造函数</li>
<li>类的析构函数</li>
<li>类对象的this指针</li>
<li>类的嵌套：封闭类</li>
<li>成员的属性：友元和常量成员</li>
</ul>
<h1 id="面向对象设计的概念"><a href="#面向对象设计的概念" class="headerlink" title="面向对象设计的概念"></a>面向对象设计的概念</h1><h2 id="面向过程设计的不足"><a href="#面向过程设计的不足" class="headerlink" title="面向过程设计的不足"></a>面向过程设计的不足</h2><p>程序 &#x3D; 数据结构 + 算法<br>程序由全局变量以及众多相互调用的函数组成，算法以函数的形式实现，用于对数据结构进行操作。<br>结构化程序设计风格中，变量和函数的关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081646566.png" alt="image-20221208164648489"><br>其缺陷在于：</p>
<ul>
<li>结构化程序设计中，函数和其所操作的数据结构，没有直观的联系</li>
<li>随着程序规模的增加，程序逐渐难以理解:<br> 某个数据结构到底有哪些函数可以对它进行操作?<br> 某个函数到底是用来操作哪些数据结构的?<br> 任何两个函数之间存在怎样的调用关系?</li>
<li>结构化程序设计难以维护:<br>由于没有“封装”和“隐藏”的概念，要访问某个数据结构中的某个变量，就可以直接访问，那么当该变量的定义有改动的时候，就要把所有访问该变量的语句找出来修改，不利于程序的维护、扩充。</li>
<li>结构化程序设计难以查错:<br>当某个数据结构的值不正确时，难以找出到底是那个函数导致的。</li>
<li>结构化程序设计难以重用：<br>在编写某个程序时，发现其需要的某项功能，在现有的某个程序里已经有了相同或类似的实现，那么自然希望能够将那部分代码抽取出来，在新程序中使用。在结构化程序设计中，随着程序规模的增大，由于程序大量函数、变量之间的关系错综复杂，要抽取这部分代码，会变得十分困难。<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2>面向对象的程序设计方法，能够较好解决上述问题<br>面向对象的程序 &#x3D; 类 + 类 + …+ 类<br>设计程序的过程，就是设计类（class）的过程<br>面向对象的程序设计方法:</li>
<li>将某类客观事物共同特点（<strong>属性</strong>）归纳出来，形成一个数据结构（可以用多个变量描述事物的属性）</li>
<li>将这类事物所能进行的<strong>行为</strong>也归纳出来，形成一个个函数，这些函数可以用来操作数据结构(这一步叫“ <strong>抽象</strong>”）</li>
<li>然后，通过某种语法形式，将数据结构和操作该数据结构的函数“捆绑”在一起，形成一个“ 类”，从而使得数据结构和操作该数据结构的算法呈现出显而易见的紧密关系，这就是“<strong>封装</strong>”</li>
<li>类与类直接又形成<strong>继承、多态</strong>等关系</li>
<li>面向对象的程序设计具有“抽象”，“封装”“继承”“多态”四个基本特点。</li>
</ul>
<p>面向对象设计风格中，变量和函数的关系;<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081647726.png" alt="image-20221208164703654"></p>
<h2 id="语言和风格的无关性"><a href="#语言和风格的无关性" class="headerlink" title="语言和风格的无关性"></a>语言和风格的无关性</h2><p>注意面向过程、面向对象以及其他的风格（如函数式编程等），只是编程风格，其本质都是组织数据结构（事物属性）和算法（对事物的操作）。<br>C++有原生的类的概念，更方便写出面向对象风格的程序<br>Q. C语言没有类，能不能写出面向对象？<br>可以，C的结构体就是对数据的封装，配合函数指针，也能包含函数成员。利用带函数指针的结构体能实现属性和方法的封装，在Linux内核和设备驱动程序中充满了这种面向对象设计风格。事实上，C++的class在编译器处理后就是类似于C的结构体。<br>Q. 什么时候应该面向对象？<br>面向对象对于人的抽象概括的能力要求较高，需要花较多精力在top-down的顶层设计中，通常用于大型的长期维护的程序设计。<br>面向对象的优势在于数据结构组织化，程序时间和空间的开销可能不如面向过程。例如一个对象里的各个数据的生命周期都是捆绑分配和释放的，而面向过程可以更精细管理。在极端资源紧缺的情况，如部分嵌入式开发，面向过程不论代码设计速度和性能都比面向对象好。</p>
<h1 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a>类和对象的概念</h1><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>设计一个程序，接受输入矩形的长和宽，输出面积和周长<br>如何用类来封装？</p>
<ul>
<li>矩形的属性就是长和宽。因此需要两个变量，分别代表长和宽</li>
<li>矩形的操作方法可以有设置长和宽，算面积，算周长。每个操作各用一个函数来实现，且函数都需要用到长和宽这两个属性</li>
<li>将以上属性和方法组合就能形成一个“矩形类”。长、宽变量成为该“矩形类”的“成员变量”，三个函数成为该类的“成员函数”。成员变量和成员函数统称为类的成员。“类”看上去就像“带函数的结构”</li>
</ul>
<p>类的声明：</p>
<pre><code>class CRectangle
&#123;
    public:
        int w, h;
        int Area() &#123;
        return w * h;
    &#125;
    int Perimeter()&#123;
        return 2 * ( w + h);
    &#125;
    void Init( int w_,int h_ ) &#123;
        w = w_; h = h_;
    &#125;
&#125;; //必须有分号
</code></pre>
<p>类的实例化：</p>
<pre><code>int main( )
&#123;
    int w,h;
    CRectangle r; //r是一个对象
    cin &gt;&gt; w &gt;&gt; h;
    r.Init( w,h);
    cout &lt;&lt; r.Area() &lt;&lt; endl &lt;&lt;
    r.Perimeter();
    return 0;
&#125;
</code></pre>
<p>通过类，可以定义变量。类定义出来的变量，也称为类的实例，就是“<strong>对象</strong>”，对象的本质是在内存中分配了一个存放类这个结构的空间。<br>C++中，类的名字就是用户自定义的类型的名字。可以像使用基本类型那样来使用。 CRectangle就是一种用户自定义的类型。</p>
<h2 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h2><ul>
<li><p>和结构变量一样，对象所占用的内存空间的大小，等于所有成员变量的大小之和（考虑内存对齐可能更大）。对于上面的CRectangle类，sizeof(CRectangle)<br>&#x3D; 8</p>
</li>
<li><p>每个对象各有自己的存储空间。一个对象的某个成员变量被改变了，不会影响到另一个对象</p>
</li>
<li><p>和结构变量一样，对象之间可以用 “&#x3D;”进行赋值，但是不能用 “&#x3D;&#x3D;”“!&#x3D;”“&gt;”“&lt;”“&gt;&#x3D;”“&lt;&#x3D;”进行比较，除非这些运算符经过了“重载”。</p>
</li>
</ul>
<p>Q.类分配内存产生对象后，成员变量占用空间，成员函数占不占用空间?<br>普通成员函数不在对象生成时分配函数空间，因为函数是静态绑定的，即函数体指令只占用代码段的一处空间，对象调用该函数之间跳到该空间入口地址，在对象分配时不会在堆或栈再开辟空间存放函数体。<br>但是当类中定义了虚函数，分配对象时要分配4字节（多个虚函数也是4个字节）的指针指向虚函数表。函数跳转地址依赖于运行时才产生的对象里的虚函数表，称为动态绑定，对象调用虚函数时不知道准确的跳转地址，只跳转到虚函数表查找跳转地址，再根据查找结果跳转。</p>
<h2 id="对象访问其成员"><a href="#对象访问其成员" class="headerlink" title="对象访问其成员"></a>对象访问其成员</h2><p>类似于C结构体实例访问其成员的方法，用实例.成员，实例指针-&gt;成员，除此之外C++特有的通过引用访问：实例引用.成员<br>用法1：对象名.成员名</p>
<pre><code>CRectangle r1,r2;
r1.w = 5;
r2.Init(5,4);
</code></pre>
<p>Init函数作用在 r2 上，即Init函数执行期间访问的w 和 h是属于r2 这个对象的, 执行r2.Init 不会影响到r1<br>用法2. 指针-&gt;成员名</p>
<pre><code>CRectangle r1,r2;
CRectangle * p1 = &amp; r1;
CRectangle * p2 = &amp; r2;
p1-&gt;w = 5;
p2-&gt;Init(5,4); //Init作用在p2指向的对象上
</code></pre>
<p>用法3：引用名.成员名</p>
<pre><code>CRectangle r2;
CRectangle &amp; rr = r2;
rr.w = 5;
rr.Init(5,4); //rr的值变了， r2的值也变
</code></pre>
<h1 id="类成员的访问方式"><a href="#类成员的访问方式" class="headerlink" title="类成员的访问方式"></a>类成员的访问方式</h1><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><p>Q. C++将数据和函数封装成类的成员，那么类内成员、内间成员的访问权限如何控制？<br>用下列访问范围关键字来说明类成员可被访问的范围：</p>
<ul>
<li>private: 私有成员，只能在成员函数内访问</li>
<li>public : 公有成员，可以在任何地方访问</li>
<li>protected: 保护成员，用于继承关系的类的成员访问控制</li>
</ul>
<p>定义一个带访问控制的类：</p>
<pre><code>class className &#123;
    private:
    私有属性和函数
    public:
    公有属性和函数
    protected:
    保护属性和函数
&#125;;
</code></pre>
<p>如过某个成员前面没有上述关键字，则缺省地被认为是private私有成员:</p>
<pre><code>class Man &#123;
    int nAge;       //私有成员
    char szName[20]; // 私有成员
public:
    void SetName(char * szName)&#123;
    strcpy( Man::szName,szName);
    &#125;
&#125;;
</code></pre>
<p>在类的成员函数内部，能够访问：</p>
<ul>
<li>当前对象的全部属性、 函数；</li>
<li>同类其它对象的全部属性、函数。</li>
</ul>
<p>在类的成员函数以外的地方，只能够访问该类对象的公有成员<br>注意：<br>通过对象的成员函数，可以访问同类其他对象的任意成员（即使是private）。private、public、protected真正的作用是限制成员变量的直接访问，而通过成员函数来访问成员变量是不受影响的。</p>
<h2 id="访问控制与隐藏"><a href="#访问控制与隐藏" class="headerlink" title="访问控制与隐藏"></a>访问控制与隐藏</h2><p>成员访问控制可以定义类的成员变量能否被任意访问、或通过成员函数访问、能否被继承的子类访问等。这种机制称为对成员变量的<strong>隐藏</strong><br>隐藏的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则所有直接访问成员变量的语句都需要修改<br>一个类成员变量隐藏的例子：</p>
<pre><code> //类定义
    class CEmployee &#123;
    private:
        char szName[30]; //名字
    public :
        int salary; //工资
        void setName(char * name);
        void getName(char * name);
        void averageSalary(CEmployee e1,CEmployee e2);
    &#125;;
    
    //成员函数定义
    void CEmployee::setName( char * name) &#123;
        strcpy( szName, name); //ok
    &#125;
    void CEmployee::getName( char * name) &#123;
        strcpy( name,szName); //ok
    &#125;
    void CEmployee::averageSalary(CEmployee e1,CEmployee e2)&#123;
        cout &lt;&lt; e1.szName; //ok，访问同类其他对象私有成员
        salary = (e1.salary + e2.salary )/2;
    &#125;
    
    //使用类和对象
    int main()
    &#123;
        CEmployee e;
        strcpy(e.szName,&quot;Tom1234567889&quot;); //编译错，不能访问私有成员
        e.setName( &quot;Tom&quot;);  // ok
        e.salary = 5000;    //ok
        return 0;
    &#125;
</code></pre>
<p>如果将上面的程序移植到内存空间紧张的设备上，希望将szName改为char szName[5]，若szName不是私有，就要找出所有类似strcpy(e.szName,”Tom1234567889”);这样的语句进行修改，以防止数组越界。如果将szName变为私有，那么程序中就不可能出现（除非在类的内部）strcpy(e.szName,”Tom1234567889”);这样的语句，所有对szName的访问都是通过成员函数来进行，比如：e.setName( “Tom12345678909887”);如果szName改短了，上面的语句也不需要找出来修改，只要改setName成员函数，在里面确保不越界就可以了<br>除了使用类和隐藏机制，C++兼容C的struct结构体，也称为类。和用”class”的唯一区别是未说明是公有还是私有的成员，struct类的所有成员都是公有的。</p>
<pre><code>struct CEmployee &#123;
    char szName[30]; //公有!!
    public :
    int salary; //工资
    void setName(char * name);
    void getName(char * name);
    void averageSalary(CEmployee
    e1,CEmployee e2);
&#125;;
</code></pre>
<h2 id="类成员函数的重载和缺省参数"><a href="#类成员函数的重载和缺省参数" class="headerlink" title="类成员函数的重载和缺省参数"></a>类成员函数的重载和缺省参数</h2><p>同普通函数一样，类封装后的成员函数可以重载，可以有缺省参数</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x=0 , int y = 0 );
    void valueX( int val ) &#123; x = val ;&#125;
    int valueX() &#123; return x; &#125;
&#125;;

void Location::init( int X, int Y)
&#123;
    x = X;
    y = Y;
&#125;

int main() &#123;
    Location A,B;
    A.init(5);  //使用init缺省y=0
    A.valueX(5);    //重载，使用valueX(int)
    cout &lt;&lt; A.valueX();     //重载，使用valueX()
    return 0;
&#125;
</code></pre>
<p>输出：5<br>注意：重载和缺省的函数在调用时可能冲突，存在二义性：</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x =0, int y = 0 );
    void valueX( int val = 0) &#123; x = val; &#125;
    int valueX() &#123; return x; &#125;
&#125;;

Location A;
A.valueX(); //错误，编译器无法判断调用哪个valueX
</code></pre>
<h1 id="类对象的创建与释放"><a href="#类对象的创建与释放" class="headerlink" title="类对象的创建与释放"></a>类对象的创建与释放</h1><h2 id="普通构造函数"><a href="#普通构造函数" class="headerlink" title="普通构造函数"></a>普通构造函数</h2><p>定义一个类只是定义一种数据结构类型，类实例化后在内存中才存在改类的对象。类实例化成对象可以在函数的栈中，或者动态分配在堆中</p>
<pre><code>ClassA a;   //该语句在函数内（如main）时，在main的堆栈中分配内存
ClassA *pa = new ClassA;    //在堆中分配，需要delete手动释放
</code></pre>
<p>那么问题来了，分配的内存里的内容是什么？<br>不知道是什么值，只知道这块内存是被其他进程释放过，当前程序可以读写，释放时不会把值清零。<br>在C语言创建一个结构体变量，可以顺便初始化为全0</p>
<pre><code>StructA a = &#123;0&#125;; //单层结构体
StructB b = &#123;&#123;0&#125;&#125;； //嵌套的结构体
</code></pre>
<p>C++也支持创建类时自动初始化，采用与类同名的成员函数的方法。这就是<strong>构造函数（constructor）</strong><br>构造函数：</p>
<ul>
<li>成员函数的一种，名字与类名相同，可以有参数，不能有返回值(void也不行)</li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作</li>
<li>如果定义了构造函数，则编译器不生成默认的无参数构造函数</li>
<li>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</li>
<li>一个类可以有多个构造函数，即构造函数也可以重载</li>
</ul>
<p>注意：构造函数不负责对象的内存分配，其关键作用是对象成员的值初始化。真正做对象分配的语句通常是new，new做两件事：给类分配内存形成对象，调用对象的构造函数。考虑一下也可知道，连对象都没有的情况，怎么能调用对象的构造函数分配内存呢？注意构造函数不给自身对象分配内存，但是构造函数可以做分配内存操作，比如对指针成员指向的空间分配内存。<br>使用默认构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i);
&#125;; //编译器自动生成默认构造函数
Complex c1; //默认构造函数被调用
Complex * pc = new Complex; //默认构造函数被调用
</code></pre>
<p>使用自定义的带参构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    Complex( double r, double i = 0);
&#125;;
    Complex::Complex( double r, double i) &#123;
    real = r; imag = i;
&#125;

Complex c1; // error, 缺少构造函数的参数
Complex * pc = new Complex; // error, 没有参数
Complex c1(2); // OK
Complex c1(2,4), c2(3,5);
Complex * pc = new Complex(3,4);
</code></pre>
<p>使用重载的构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i );
    Complex(double r, double i );
    Complex (double r );
    Complex (Complex c1, Complex c2);
&#125;;

Complex::Complex(double r, double i)
&#123;
    real = r; imag = i;
&#125;
Complex::Complex(double r)
&#123;
    real = r; imag = 0;
&#125;
Complex::Complex (Complex c1, Complex c2);
&#123;
    real = c1.real+c2.real;
    imag = c1.imag+c2.imag;
&#125;

Complex c1(3) , c2 (1,0), c3(c1,c2);
// c1 = &#123;3, 0&#125;, c2 = &#123;1, 0&#125;, c3 = &#123;4, 0&#125;;
</code></pre>
<p>构造函数应该是public的， private构造函数不能直接用来初始化对象</p>
<pre><code>class CSample&#123;
private:
    CSample() &#123;&#125;
&#125;;

int main()&#123;
    CSample Obj; //err. 唯一构造函数是private
    return 0;
&#125;
</code></pre>
<p>对于多个对象的实例化，可以用对象数组,构造函数的调用次数&#x3D;对象个数，重载哪一个构造函数取决于每个对象的初始化方式。</p>
<pre><code>class CSample &#123;
    int x;
    public:
    CSample() &#123;
        cout &lt;&lt; &quot;Constructor 1 Called&quot; &lt;&lt; endl;
    &#125;
    CSample(int n) &#123;
        x = n;
        cout &lt;&lt; &quot;Constructor 2 Called&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main()&#123;
    CSample array1[2];  //两次默认构造函数
    cout &lt;&lt; &quot;step1&quot;&lt;&lt;endl;
    CSample array2[2] = &#123;4,5&#125;;  //两次带参构造函数
    cout &lt;&lt; &quot;step2&quot;&lt;&lt;endl;
    CSample array3[2] = &#123;3&#125;;    //第一个带参构造，第二个默认构造
    cout &lt;&lt; &quot;step3&quot;&lt;&lt;endl;
    CSample * array4 = new CSample[2];  //两次默认构造
    delete []array4;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Constructor 1 Called
Constructor 1 Called
step1
Constructor 2 Called
Constructor 2 Called
step2
Constructor 2 Called
Constructor 1 Called
step3
Constructor 1 Called
Constructor 1 Called
</code></pre>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>定义：拷贝构造函数(copy constructor)是构造函数的一种，特点是：</p>
<ul>
<li>只有一个参数:对同类对象的引用</li>
<li>入参必须是对象的引用，形如 X::X( X&amp; ) 或 X::X(const X &amp;), 后者以常量对象作为参数</li>
<li>如果用户没有定义拷贝构造函数，编译器生成默认的拷贝构造函数，且它完成复制对象的功能。</li>
</ul>
<p>拷贝构造函数也称为复制构造函数<br>调用形式如下。默认（普通）构造函数和默认拷贝构造函数都是编译生成，且并存的</p>
<pre><code>class Complex &#123;
private :
    double real,imag;
&#125;;
Complex c1; //调用缺省无参构造函数
Complex c2(c1);//调用缺省的复制构造函数,将 c2 初始化成和c1一样
</code></pre>
<p>如果定义的自己的拷贝构造函数，则默认的拷贝构造函数不会生成<br>也就是说，自定义的带参拷贝构造函数和编译器生成的默认拷贝构造函数，不存在重载关系；而一个类有多个自定义的带参拷贝构造函数是允许的，可以重载。这一特点对于普通构造函数一样。</p>
<pre><code>class Complex &#123;
public :
    double real,imag;
    Complex()&#123; &#125;
    Complex( const Complex &amp; c ) &#123;
        real = c.real;
        imag = c.imag;
        cout &lt;&lt; “Copy Constructor called”;
    &#125;
&#125;;
Complex c1;
Complex c2(c1); //调用自己定义的复制构造函数，输出 Copy Constructor called
</code></pre>
<p>注意：拷贝构造函数传入的是同类的引用，而不是同类的对象<br>不允许有形如 X::X( X)的构造函数。因为成员函数入参由实参复制到形参实际会调用拷贝构造函数，拷贝构造函数作为成员函数也是一样，因此会有循环定义，即拷贝构造函数的执行需要调用拷贝构造函数的无限循环，用引用作为入参可以解决此问题。这点类似于C结构体允许有结构体指针成员，指向该结构体类型的实例，而不允许结构体有自身结构体的自接实例，这样会照成分配内存空间上的无限循环。</p>
<pre><code>class CSample &#123;
    CSample( CSample c ) &#123;&#125; //错，不允许这样的构造函数
&#125;
</code></pre>
<h3 id="拷贝构造函数的调用"><a href="#拷贝构造函数的调用" class="headerlink" title="拷贝构造函数的调用"></a>拷贝构造函数的调用</h3><p>以下三种情况会调用类对象的拷贝构造函数<br>1)用一个对象去初始化同类的另一个对象：</p>
<pre><code>Complex c2(c1);
Complex c2 = c1; //初始化语句，非赋值语句
</code></pre>
<p>2)类的对象作为函数入参：如果某函数有参数是类A的对象，那么该函数被调用时，类A的拷贝构造函数将被调用：</p>
<pre><code>class A
&#123;
public:
    A() &#123; &#125;;
    A( A &amp; a) &#123;
        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;
    &#125;
&#125;;

void Func(A a1)&#123; &#125;;
int main()&#123;
    A a2;
    Func(a2);  //传参是类A的对象
    return 0;
&#125;
</code></pre>
<p>输出: Copy constructor called<br>3) 类的对象作为函数返回值：如果函数的返回值是类A的对象，函数返回时，A的拷贝构造函数被调用：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int v;</span><br><span class="line">    A(int n) &#123; v = n; &#125;;</span><br><span class="line">    A( const A &amp; a) &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A Func() &#123;</span><br><span class="line">    A a(4);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; Func().v &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>输出：</p>
<pre><code>Copy constructor called
4
</code></pre>
<p>小结：对象作为入参和返回值会调用拷贝构造函数，对象初始化新对象也会调用。</p>
<h3 id="禁用拷贝构造函数"><a href="#禁用拷贝构造函数" class="headerlink" title="禁用拷贝构造函数"></a>禁用拷贝构造函数</h3><p>Q. 调用拷贝构造函数会形成对象的复制品，开销较大，如何禁用拷贝构造函数？<br>使用对象的引用，不自接把对象作为函数的入参出参。<br>Q.对象的引用会导致新问题：函数内修改了引用怎么办，原对象也会改<br>使用const引用，对象实参就不存在被函数修改的可能<br>使用对象的常引用，应用于对象作为函数入参出参，又不希望调用拷贝构造函数的情况</p>
<pre><code>void fun(const CMyclass &amp; obj) &#123;
//函数中任何试图改变 obj值的语句都将是变成非法
&#125;
</code></pre>
<h3 id="对象的赋值和复制"><a href="#对象的赋值和复制" class="headerlink" title="对象的赋值和复制"></a>对象的赋值和复制</h3><p>注意区分对象的赋值和复制：</p>
<ul>
<li><p>对象赋值是类的所有数据成员的一一对应赋值，其本质是对已分配内存的对象，进行数据成员的初始化</p>
</li>
<li><p>对象复制 &#x3D; 分配新对象对象空间 + 对新对象成员的赋值初始化。对象复制是要包含空间分配操作的</p>
</li>
</ul>
<p>两个已分配内存的对象间的赋值并不会导致拷贝构造函数被调用</p>
<pre><code>//声明及初始化，调用拷贝构造函数
Complex c2 = c1; 
//先声明对象，再赋值,不调用拷贝构造函数，调用默认构造函数然后赋值
Complex c2；
c2 = c1;    
</code></pre>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>当类对象有指针成员时，拷贝构造函数遇到一个问题，是只拷贝指针，还是连同指针指向的空间一起拷贝？</p>
<ul>
<li>浅拷贝：只拷贝指针成员</li>
<li>深拷贝：拷贝指针成员，并拷贝其指向的内存空间数据<br> 由于深拷贝的实现用到“&#x3D;”运算符重载，在运算符重载一节详述</li>
</ul>
<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>构造函数是能创建对象并初始化值的函数，将普通变量转换从类对象并分配内存空间的构造函数是转换构造函数。</p>
<ul>
<li>定义转换构造函数的目的是实现类型的自动转换（变量-&gt;对象）</li>
<li>只有一个参数，且不是拷贝构造函数的构造函数，就是转换构造函数</li>
<li>变量被赋值给对象时，编译器会自动调用转换构造函数，建立一个无名的临时对象</li>
</ul>
<p>隐式的转换构造函数：</p>
<pre><code>    class Complex &#123;
    public:
        double real, imag;
        Complex( int i) &#123;//类型转换构造函数
            cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
            real = i; imag = 0;
        &#125;
        Complex(double r,double i) &#123;real = r; imag = i; &#125;
    &#125;;
    
    int main ()
    &#123;
        Complex c1(7,8);
        Complex c2 = 12;
        c1 = 9;     // 9被自动转换成一个临时Complex对象
        cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
        return 0;
    &#125;
</code></pre>
<p>显式的转换构造函数：</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    explicit Complex( int i) &#123;  //显式类型转换构造函数
        cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
        real = i; imag = 0;
    &#125;
    Complex(double r,double i) &#123;real = r; imag = i; &#125;
&#125;;
int main () &#123;
    Complex c1(7,8);
    Complex c2 = Complex(12);
    c1 = 9;         // error, 9不能被自动转换成一个临时Complex对象
    c1 = Complex(9) //ok
    cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><h3 id="析构函数的概念"><a href="#析构函数的概念" class="headerlink" title="析构函数的概念"></a>析构函数的概念</h3><p>**析构函数(destructors)**用于对象生命周期结束前（如函数中的对象在函数返回时消失），释放对象的内存占用，以及其他的准备工作。<br>构造函数和析构函数在对象生命周期的角色从逻辑上讲是开始和结束的关系，但具体操作不一样：构造函数不为对象分配内存，只给成员赋初值；而析构函数一般要释放对象的内存<br>析构函数的特点：</p>
<ul>
<li>名字与类名相同，在前面加‘~’，没有参数和返回值，一个类最多只能有一个析构函数</li>
<li>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。</li>
<li>如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做</li>
<li>如果定义了析构函数，则编译器不生成缺省析构函数</li>
</ul>
<p>析构函数例子：</p>
<pre><code>class String&#123;
private :
    char * p;
    public:
    String () &#123;
        p = new char[10];
    &#125;
    ~ String () ;
&#125;;

String ::~ String()
&#123;
    delete [] p;
&#125;
</code></pre>
<p>对象数组的生命期结束时，每个对象的析构函数都会被调用。</p>
<pre><code>class Ctest &#123;
public:
    ~Ctest() &#123; cout&lt;&lt; &quot;destructor called&quot; &lt;&lt; endl; &#125;
&#125;;

int main () &#123;
    Ctest array[2];
    cout &lt;&lt; &quot;End Main&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>End Main
destructor called
destructor called
</code></pre>
<h3 id="析构函数的调用"><a href="#析构函数的调用" class="headerlink" title="析构函数的调用"></a>析构函数的调用</h3><p>析构函数被调用有以下几种情况<br>1)delete运算导致析构函数调用：</p>
<pre><code>Ctest * pTest;
pTest = new Ctest;  //构造函数调用
delete pTest;       //析构函数调用
---------------------------------------------------------
pTest = new Ctest[3];   //构造函数调用3次
delete [] pTest;        //析构函数调用3次
</code></pre>
<p>若new一个对象数组，那么用delete释放时应该写 []。否则只delete一个对<br>象(调用一次析构函数)<br>2)析构函数在对象作为函数返回值返回后被调用。其原理是，对象作为函数的入参，出参时，都是临时生成的对象，传完就调用析构函数销毁。</p>
<pre><code>class CMyclass &#123;
public:
    ~CMyclass() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125;
&#125;;
CMyclass obj;
CMyclass fun(CMyclass sobj ) &#123; //参数对象消亡也会导致析
                                //构函数被调用
    return sobj;                //函数调用返回时生成临时对象返回
&#125;
int main()&#123;
    obj = fun(obj); //函数调用的返回值（临时对象）被
    return 0;       //用过后，该临时对象析构函数被调用
&#125;
</code></pre>
<p>输出：</p>
<pre><code>destructor
destructor
destructor
</code></pre>
<h2 id="构造与析构的时序"><a href="#构造与析构的时序" class="headerlink" title="构造与析构的时序"></a>构造与析构的时序</h2><p>总体原则：类似堆栈的先入后出原则：先构造的后析构<br>几个关键分类：<br>临时对象：赋值时创建，赋完值就消亡，生命周期似乎就一条指令<br>局部对象：在{}范围内存在，{}结束时消亡<br>全局、静态对象：从创建开始，在程序整个运行期间存在，程序结束时消亡。<br>一个例子：</p>
<pre><code>class Demo &#123;
        int id;
    public:
        Demo(int i) &#123;
            id = i;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;
        &#125;
        ~Demo() &#123;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; destructed&quot; &lt;&lt; endl;
        &#125;
&#125;;

Demo d1(1);
void Func()
&#123;
    static Demo d2(2);
    Demo d3(3);
    cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;
&#125;

int main () &#123;
    Demo d4(4);
    d4 = 6;
    cout &lt;&lt; &quot;main&quot; &lt;&lt; endl;
    &#123; 
        Demo d5(5);
    &#125;
    Func();
    cout &lt;&lt; &quot;main ends&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出结果:</p>
<pre><code>id=1 constructed    //全局对象d1
id=4 constructed    //构造函数d4
id=6 constructed    //转换构造函数d4
id=6 destructed     //临时对象赋值完毕，消亡
main
id=5 constructed    //构造函数d5
id=5 destructed     //d5作用域结束，消亡
id=2 constructed    //Fun构造静态对象d2(等同全局对象)
id=3 constructed    //构造局部对象d3
func
id=3 destructed     //Fun返回，d3消亡
main ends       
id=6 destructed     //Main的局部对象d4消亡（id=6）
id=2 destructed     //整个程序结束，全局对象d2消亡
id=1 destructed     //整个程序结束，全局对象d1消亡
</code></pre>
<h1 id="类对象的指针：this指针"><a href="#类对象的指针：this指针" class="headerlink" title="类对象的指针：this指针"></a>类对象的指针：this指针</h1><p>this指针是在类成员函数内，指向当前类对象的指针。<br>注意：</p>
<ul>
<li>this指针是指向当前对象的，所谓当前，是指调用成员函数时，是通过所在的对象的指针来调用</li>
<li>this指针体现的是成员函数和对象的关系，如果是静态成员函数，没有this指针，因为静态成员函数不从属于对象</li>
</ul>
<p>为什么this指针如此特殊，需要单独命名？这涉及到C++的类的实现原理。</p>
<h2 id="C-的类与C的结构体"><a href="#C-的类与C的结构体" class="headerlink" title="C++的类与C的结构体"></a>C++的类与C的结构体</h2><p>在C++早期，C++代码被编译器翻译成C代码，再由C编译器编译<br>类的实现原理和C的结构体有密切关系，下面是类和结构体的转换：<br>1)C++的类：</p>
<pre><code>class CCar &#123;
    public:
        int price;
        void SetPrice(int p);
&#125;;

void CCar::SetPrice(int p)
&#123; price = p; &#125;

int main()
&#123;
    CCar car;
    car.SetPrice(20000);
    return 0;
&#125;
</code></pre>
<p>2)C的结构体实现类的功能</p>
<pre><code>struct CCar &#123;
    int price;
&#125;;

void SetPrice(struct CCar * this, int p)
&#123; this-&gt;price = p; &#125;

int main() &#123;
    struct CCar car;
    SetPrice( &amp; car,
    20000);
    return 0;
&#125;
</code></pre>
<p>用C实现面向对象(CCar结构体)，方法(SetPrice)传入的参数是结构体对象的指针(struct CCar * this)</p>
<h2 id="C-的this指针"><a href="#C-的this指针" class="headerlink" title="C++的this指针"></a>C++的this指针</h2><p>成员函数（非static）可以直接使用this来代表指向该函数作用的对象的指针</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    void Print() &#123; cout &lt;&lt; real &lt;&lt; &quot;,&quot; &lt;&lt; imag ; &#125;
    Complex(double r,double i):real(r),imag(i)&#123; &#125;   //初始化列表
    Complex AddOne() &#123;
        this-&gt;real ++;  //等价于 real++
        this-&gt;Print();  //等价于 Print()
        return * this;
    &#125;
&#125;;

int main() &#123;
    Complex c1(1,1),c2(0,0);
    c2 = c1.AddOne();
    return 0;
&#125; //输出 2,1
</code></pre>
<p>对象的this指针通常隐式存在：</p>
<ul>
<li>成员函数（非static）的入参实际隐式地有一个this指针参数</li>
<li>成员函数访问成员变量，也是隐式的通过this指针访问</li>
<li>通过对象的指针调用成员函数，本质也是传入this指针</li>
</ul>
<p>如果成员函数不访问成员变量，可以传入NULL的对象指针：</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  //等价于 void Hello(A * this ) &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p)
&#125; // 输出： hello
</code></pre>
<p>如果成员函数访问了成员变量，实际是通过成员函数传入的this指针来访问，此时指针不可为NULL</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  
//等价于void Hello(A * this ) &#123; cout &lt;&lt; this-&gt;i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
//this若为NULL，则出错！！
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p);
&#125; //出错
</code></pre>
<h2 id="静态成员的概念"><a href="#静态成员的概念" class="headerlink" title="静态成员的概念"></a>静态成员的概念</h2><p>静态成员：在定义前面加了static关键字的成员、</p>
<pre><code>class CRectangle
&#123;
    private:
    int w, h;
    static int nTotalArea; //静态成员变量
    static int nTotalNumber;
    public:
    CRectangle(int w_,int h_);
    ~CRectangle();
    static void PrintTotal(); //静态成员函数
&#125;;
</code></pre>
<ul>
<li>普通成员变量每个对象有各自的一份；而静态成员变量是全局共有的一份，为所有对象共享</li>
<li>同一个类的成员函数，不论静不静态都是一份代码段</li>
<li>普通成员函数必须具体作用于某个对象（也可以理解为绑定），而静态成员函数并不具体作用于某个对象</li>
<li>因此静态成员（变量或者函数），不需要通过对象就能访问</li>
</ul>
<p>sizeof求类大小，不会计算静态成员变量，因为不属于类的一部分（从空间占用上讲）。</p>
<pre><code>class CMyclass &#123;
int n;
static int s;
&#125;;  // sizeof(CMyclass) 等于 4
</code></pre>
<h2 id="访问静态成员"><a href="#访问静态成员" class="headerlink" title="访问静态成员"></a>访问静态成员</h2><p>一下几种方法访问,可以归纳为两种：通过类名访问，通过对象访问<br>1)类名::成员名</p>
<pre><code>CRectangle::PrintTotal();
</code></pre>
<p>2)对象名.成员名</p>
<pre><code>CRectangle r; 
r.PrintTotal();
</code></pre>
<p>3)指针-&gt;成员名</p>
<pre><code>CRectangle * p = &amp;r; 
p-&gt;PrintTotal();
</code></pre>
<p>4)引用.成员名</p>
<pre><code>CRectangle &amp; ref = r; 
int n = ref.nTotalNumber;
</code></pre>
<h2 id="静态成员函数与this指针"><a href="#静态成员函数与this指针" class="headerlink" title="静态成员函数与this指针"></a>静态成员函数与this指针</h2><ul>
<li>静态成员函数中不能使用 this 指针！</li>
<li>因为静态成员函数并不具体作用与某个对象!</li>
<li>因此静态成员函数的真实的参数的个数，就是程序中写出的参数个数！</li>
</ul>
<p>前面讲，C++的作用是封装数据，静态成员似乎破坏这一目的，那么静态成员有什么作用？<br>为了兼容C的全局变量与函数</p>
<ul>
<li>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在</li>
<li>静态成员函数本质上是全局函数</li>
<li>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解</li>
</ul>
<h2 id="静态成员函数的使用场景"><a href="#静态成员函数的使用场景" class="headerlink" title="静态成员函数的使用场景"></a>静态成员函数的使用场景</h2><p>对于需要全局维护的数据，可以使用静态成员变量，并通过静态成员函数访问。<br>考虑一个图形处理程序，需要随时知道矩形的总数和总面积</p>
<ul>
<li>每个矩形封装成类的对象</li>
<li>总数和总面积是类的静态成员（等价于全局变量）</li>
</ul>
<p>类定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CRectangle</span><br><span class="line">    &#123;</span><br><span class="line">    private:</span><br><span class="line">        int w, h;</span><br><span class="line">        static int nTotalArea;</span><br><span class="line">        static int nTotalNumber;</span><br><span class="line">    public:</span><br><span class="line">        CRectangle(int w_,int h_);</span><br><span class="line">        ~CRectangle();</span><br><span class="line">        static void PrintTotal();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数定义：</p>
<pre><code>CRectangle::CRectangle(int w_,int h_)
&#123;
    w = w_;
    h = h_;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
CRectangle::~CRectangle()
&#123;
    nTotalNumber --;
    nTotalArea -= w * h;
&#125;
void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl;
&#125;
</code></pre>
<p>类对象的调用：</p>
<pre><code>int CRectangle::nTotalNumber = 0;
int CRectangle::nTotalArea = 0;
// 必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。
int main()
&#123;
    CRectangle r1(3,3), r2(2,2);
    //cout &lt;&lt; CRectangle::nTotalNumber; 
    //错误 , 静态的私有变量也只能通过成员函数访问，静态不等于全局可访问
    CRectangle::PrintTotal();
    r1.PrintTotal();
    return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>2,13
2,13
</code></pre>
<p>注意两点：</p>
<ul>
<li>静态成员变量是全局共有的一份存储，但private的静态成员只能通过类的成员函数访问。注意区分全局存储和全局访问，静态成员只有全局存储特性，没有全局可访问特性。</li>
<li>静态成员函数，不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
<p>以下静态成员函数访问错误：</p>
<pre><code>void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; w &lt;&lt; &quot;,&quot; &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl; //错误
&#125;
CRetangle::PrintTotal(); //解释不通 w 到底是属于那个对象的
</code></pre>
<p> 以上例子还有缺陷：<br> 在使用静态成员时，特别是类的构造和析构会修改该静态成员，如前文的CRectangle类的构造函数有nTotalNumber++操作，析构有nTotalNumber–。这个时候要考虑构造和析构函数是否覆盖到所有类型（普通构造，拷贝构造，转换构造）<br> 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象：</p>
<ul>
<li>调用一个以CRectangle类对象作为参数的函数时</li>
<li>调用一个以CRectangle类对象作为返回值的函数时</li>
</ul>
<p>临时对象在消亡时会调用析构函数，减少nTotalNumber和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber和nTotalArea的值，因为设计类时漏掉了拷贝构造的情况<br>解决办法：为CRectangle类写一个拷贝构造函数：</p>
<pre><code>CRectangle :: CRectangle(CRectangle &amp; r )
&#123;
    w = r.w; h = r.h;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
</code></pre>
<p>这样nTotalNumber和nTotalArea全局计数就是准确的</p>
<h1 id="类的嵌套：封闭类"><a href="#类的嵌套：封闭类" class="headerlink" title="类的嵌套：封闭类"></a>类的嵌套：封闭类</h1><h2 id="封闭类的基本概念"><a href="#封闭类的基本概念" class="headerlink" title="封闭类的基本概念"></a>封闭类的基本概念</h2><p>再来把C++的类和C结构体对比下：</p>
<ul>
<li>C：结构体的成员可以是基础变量，基础变量的指针，结构体的指针，其他复合类型的指针</li>
<li>C++：类的成员变量可以是基础变量，及其指针、引用，可不可以是类对象？类对象的引用和指针？</li>
</ul>
<p>于是引入类嵌套类对象的情况：有成员对象的类叫封闭类（enclosing class)<br>一个示例：写一个汽车类，包含轮胎和引擎类对象<br>轮胎和引擎类：</p>
<pre><code>class CTyre //轮胎类
    &#123;
    private:
        int radius; //半径
        int width; //宽度
    public:
        CTyre(int r,int w):radius(r),width(w) &#123; &#125;   //用初始化列表构造
    &#125;;
    
class CEngine //引擎类
&#123;
&#125;;
</code></pre>
<p>汽车类：</p>
<pre><code>class CCar &#123; //汽车类
private:
    int price; //价格
    CTyre tyre;
    CEngine engine;
public:
    CCar(int p,int tr,int tw );
&#125;;
CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw) //用初始化列表构造
&#123;
&#125;;
</code></pre>
<p>汽车类的使用：</p>
<pre><code>int main()
&#123;
    CCar car(20000,17,225); //传入初始化列表
    return 0;
&#125;
</code></pre>
<h2 id="初始化列表构造封闭类"><a href="#初始化列表构造封闭类" class="headerlink" title="初始化列表构造封闭类"></a>初始化列表构造封闭类</h2><p>对于封闭类，有几个问题就凸显出来：</p>
<ul>
<li>构造一个封闭类，还要构造其嵌套的类</li>
<li>构造时序是怎样的</li>
<li>析构时序是怎样的</li>
</ul>
<p>上例中，如果 CCar类不定义构造函数，下面的语句会编译出错：CCar car;<br>因为CCar不传初始化值给嵌套类CTyre，编译器不知道该如何初始化car.tyre的成员变量<br>而car.engine的初始化没问题，因为不用初始化成员变量，用默认构造函数即可<br>为了解决封闭类的嵌套类成员的初始化问题，构造函数引入新的初始化方法：</p>
<ul>
<li>初始化列表：将成员初始化从构造函数体，移到函数名后面，只是换了形式，但是方便了封闭类各嵌套类的初始化，不用开发者自己到函数体写构造函数内容</li>
<li>成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。</li>
</ul>
<p>封闭类都是通过构造函数的初始化列表，层层传入嵌套类的构造函数：</p>
<pre><code>CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw)&#123;&#125;;
//p, tr, tw是传入的初始化值; price,tyre是CCar对象的两个成员
CCar car(20000,17,225);
//Car的price = 20000, Car的tyre的radius = 17，width = 225
</code></pre>
<p> 上例是普通构造函数，对于封闭类的拷贝构造函数：</p>
<ul>
<li>封闭类对象是用拷贝构造函数初始化的，其成员对象也用拷贝构造函数初始化</li>
</ul>
<p>测试用例：</p>
<pre><code>class A
&#123;
public:
    A() &#123; cout &lt;&lt; &quot;default&quot; &lt;&lt; endl; &#125;
    A(A &amp; a) &#123; cout &lt;&lt; &quot;copy&quot; &lt;&lt; endl;&#125;
&#125;;
class B &#123; A a; &#125;;

int main()
&#123;
    B b1,b2(b1);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>default
Copy
</code></pre>
<p>下面考虑封闭类构造和析构的时序</p>
<ul>
<li>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数、</li>
<li>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关</li>
<li>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反</li>
</ul>
<p>一个测试示例</p>
<pre><code>class CTyre &#123;
    public:
        CTyre() &#123; cout &lt;&lt; &quot;CTyre contructor&quot; &lt;&lt; endl; &#125;
        ~CTyre() &#123; cout &lt;&lt; &quot;CTyre destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CEngine &#123;
    public:
        CEngine() &#123; cout &lt;&lt; &quot;CEngine contructor&quot; &lt;&lt; endl; &#125;
        ~CEngine() &#123; cout &lt;&lt; &quot;CEngine destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CCar &#123;
    private:
        CEngine engine;
        CTyre tyre;
    public:
        CCar( ) &#123; cout &lt;&lt; “CCar contructor” &lt;&lt; endl; &#125;
        ~CCar() &#123; cout &lt;&lt; &quot;CCar destructor&quot; &lt;&lt; endl; &#125;
&#125;;

int main()&#123;
CCar car;
return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>CEngine contructor
CTyre contructor
CCar contructor
CCar destructor
CTyre destructor
CEngine destructor
</code></pre>
<h1 id="类的成员属性：友元和常量成员"><a href="#类的成员属性：友元和常量成员" class="headerlink" title="类的成员属性：友元和常量成员"></a>类的成员属性：友元和常量成员</h1><h2 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h2><p>友元(friend)分为友元函数和友元类两种<br>一个类的private成员，只能通过类自己的成员函数访问，那么其他类的成员函数想访问这个类的private成员怎么办？友元可以解决这种需求</p>
<ol>
<li><p>友元函数: 一个类的友元函数可以访问该类的私有成员<br>即类A内可以声明其他类B的成员函数或者全局函数，加前缀friend，这些以friends开头的函数就可访问类A的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CCar ; //提前声明 CCar类，以便后面的CDriver类使用</span><br><span class="line"> class CDriver</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">         void ModifyCar( CCar * pCar) ; //改装汽车</span><br><span class="line"> &#125;;</span><br><span class="line"> class CCar</span><br><span class="line"> &#123;</span><br><span class="line">     private:</span><br><span class="line">         int price;</span><br><span class="line">         friend int MostExpensiveCar( CCar cars[], int total); //声明友元</span><br><span class="line">         friend void CDriver::ModifyCar(CCar * pCar); //声明友元</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> void CDriver::ModifyCar( CCar * pCar)</span><br><span class="line"> &#123;</span><br><span class="line">     pCar-&gt;price += 1000; //访问CCar成员，汽车改装后加价</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int MostExpensiveCar( CCar cars[],int total)//求最贵汽车的价格</span><br><span class="line"> &#123;</span><br><span class="line">     int tmpMax = -1;</span><br><span class="line">     for( int i = 0;i &lt; total; ++i )</span><br><span class="line">     if( cars[i].price &gt; tmpMax) //访问CCar成员</span><br><span class="line">     tmpMax = cars[i].price;</span><br><span class="line">     return tmpMax;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了普通成员函数，也可以将类构造、析构函数说明为另一个类的友元</p>
<p>2)友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员<br>如果是类的嵌套（封闭类），声明为friend的类A可以调用自己的成员函数访问与它为friend关系的类B的私有成员，而不必调用类B的成员函数。</p>
<pre><code>class CCar
&#123;
private:
    int price;
    friend class CDriver; //声明CDriver为友元类
&#125;;
class CDriver
&#123;
public:
    CCar myCar;
    void ModifyCar() &#123;  //改装汽车
    myCar.price += 1000;   //因CDriver是CCar的友元类，故此处可以访问其私有成员
    &#125;
&#125;;

int main()&#123; return 0; &#125;
</code></pre>
<p>友元类之间的关系不能传递，不能继承。就是说A和B是friend,B和C是friend,但A和C不一定是friend。父类之间的friend关系，子类不一定能传承。</p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>如果不希望某个对象的值被改变，定义该对象的时候可以在前面加 const关键字<br>在类的成员函数说明后面加const关键字，则该成员函数成为常量<br>成员函数。<br>常量成员函数内部不能改变属性的值，也不能调用非常量成员函数<br>在定义常量成员函数和声明常量成员函数时都应该使用const 关键字。</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void PrintValue() const;
&#125;;
void Sample::PrintValue() const &#123;             //此处不使用const会导致编译出错
    cout &lt;&lt; value;
&#125;
void Print(const Sample &amp; o) &#123;
    o.PrintValue(); 
&#125;//若 PrintValue非const则编译错
</code></pre>
<p>以下是错误示例：</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void func() &#123; &#125;;
    Sample() &#123; &#125;
    void SetValue() const &#123;
        value = 0; // wrong
        func(); //wrong
    &#125;
&#125;;
const Sample Obj;
Obj.SetValue (); //常量对象上可以使用常量成员函数
</code></pre>
<p>什么场景定义成常量成员函数？<br>如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，最好将其写成常量成员函数</p>
<p>常量成员函数的重载：<br>两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载关系，而非重定义。</p>
<h1 id="类的运算：运算符重载"><a href="#类的运算：运算符重载" class="headerlink" title="类的运算：运算符重载"></a>类的运算：运算符重载</h1><p>C++定义了类，可以像基本类型那样创建、销毁、初始化。那么类和类之间的运算呢？<br>+、 -、 *、 &#x2F;、 %、 ^、 &amp;、 ~、 !、 |、 &#x3D;、 &lt;&lt; 、&gt;&gt;、 !&#x3D;、<br>考虑以下方法实现类的运算：</p>
<ul>
<li>设计类的成员函数，支持类运算操作</li>
<li>设计某种机制，把运算符关联成函数操作，在函数内定义具体类运算方法。进行类的运算时，形式上可以像基本类型的运算一样</li>
</ul>
<p>例如complex_a和complex_b是两个复数对象；求两个复数的和, 希望能直接写：complex_a + complex_b<br>运算符重载将解决类和对象的运算需求</p>
<h2 id="运算符重载的概念"><a href="#运算符重载的概念" class="headerlink" title="运算符重载的概念"></a>运算符重载的概念</h2><p>运算符重载，就是对已有的运算符(C++中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为<br>运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象<br>期望效果:同一个运算符，对不同类型的操作数，所发生的行为不同</p>
<pre><code>complex_a + complex_b //生成新的复数对象
5 + 4 = 9 //基本运算符操作
</code></pre>
<p>从行为上看，运算符重载类似于把运算符进行了重定义成函数操作（类似C的typedef）<br>运算符重载写法：</p>
<pre><code>返回值类型 operator 运算符（形参表）
&#123;
……  //定义该运算符的运算规则
&#125;
</code></pre>
<p>示例：</p>
<pre><code>class Complex
&#123;
public:
    double real,imag;
    Complex( double r = 0.0, double i= 0.0):real(r),imag(i) &#123; &#125;
    Complex operator-(const Complex &amp; c);
&#125;;
Complex operator+( const Complex &amp; a, const Complex &amp; b)
&#123;
    return Complex( a.real+b.real,a.imag+b.imag); //返回一个临时对象
&#125;
Complex Complex::operator-(const Complex &amp; c)
&#123;
    return Complex(real - c.real, imag - c.imag); //返回一个临时对象
&#125;

int main()
&#123;
    Complex a(4,4),b(1,1),c;
    c = a + b; //等价于c=operator+(a,b);
    cout &lt;&lt; c.real &lt;&lt; &quot;,&quot; &lt;&lt; c.imag &lt;&lt; endl;
    cout &lt;&lt; (a-b).real &lt;&lt; &quot;,&quot; &lt;&lt; (a-b).imag &lt;&lt; endl;
    //a-b等价于a.operator-(b)
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>5,5
3,3
</code></pre>
<p>c &#x3D; a + b; 等价于c&#x3D;operator+(a,b);<br>a-b 等价于a.operator-(b)<br>运算符重载的实现还是成员函数，所以是依赖于对象的。也就是说，运算符重载看上去和类、对象没啥关系，但本质上，重载的运算符是归属于某个类的，因为a-b只是表象现象，真正定义对象运算的，是a.operator-(b)成员函数。<br>因为运算符重载依赖对象的，因此双目运算，如+，-，在运算符重载时只需要传入另一个对象，而不需要传运算符的当前对象。<br>重载为成员函数时， 参数个数为运算符目数减一。<br>重载为普通函数时， 参数个数为运算符目数</p>
<p>运算符重载概念小结：</p>
<ul>
<li>运算符重载的实质是函数重载</li>
<li>可以重载为普通函数，也可以重载为成员函数</li>
<li>把含运算符的表达式转换成对运算符函数的调用</li>
<li>把运算符的操作数转换成运算符函数的参数</li>
<li>运算符被多次重载时，根据实参的类型决定调用哪个运算符函数</li>
</ul>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><p>接下来的几节讲几个代表性的运算符重载。本节讲赋值运算符“&#x3D;”有时候希望赋值运算符两边的类型可以不匹配，比如，把一个int类型变量赋值给一个Complex对象，或把一个 char *类型的字符串赋值给一个字符串对象,此时就需要重载赋值运算符“&#x3D;”。<br>赋值运算符“ &#x3D;”只能重载为成员函数</p>
<p>示例：</p>
<pre><code>class String &#123;
private:
    char * str;
    public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s);
    String::~String( ) &#123; delete [] str; &#125;
&#125;;
String &amp; String::operator = (const char * s)
&#123; //重载“=”以使得 obj = “hello”能够成立
    delete [] str;
    str = new char[strlen(s)+1];
    strcpy( str, s);
    return * this;
&#125;

int main()
&#123;
    String s;
    s = &quot;Good Luck,&quot; ; //等价于 s.operator=(&quot;Good Luck,&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    // String s2 = &quot;hello!&quot;; //这条语句要是不注释掉就会出错
    s = &quot;Shenzhou 8!&quot;; //等价于 s.operator=(&quot;Shenzhou 8!&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Good Luck,
Shenzhou 8!
</code></pre>
<h2 id="赋值运算符与深拷贝"><a href="#赋值运算符与深拷贝" class="headerlink" title="赋值运算符与深拷贝"></a>赋值运算符与深拷贝</h2><p>在类与对象的拷贝构造函数一节讲了拷贝构造函数的作用：用一个已经初始化的对象，去初始化另一个对象，具体操作是讲成员变量一一赋值。<br>那么更深入考虑一下:对于各种类型的成员变量，能不能达到目的？</p>
<ul>
<li>对于基础类型的成员变量，如int,char，直接赋值即可</li>
<li>对于指针类型的成员变量，给指针赋值就Ok?需不需要给指针指向的空间也赋值？</li>
<li>对于引用类型的成员变量，直接赋值OK?</li>
<li>对于类对象类型的成员变量，怎么赋值？嵌套调用拷贝构造函数？</li>
</ul>
<p>引用只是标签，可以直接拷贝，等同变量拷贝。封闭类的构造函数会嵌套调用基础类型的拷贝，直到所有成员赋值完为止。<br>唯一需要考虑的是包含指针类型成员的类如何拷贝<br>如果直接赋值指针而不分配并初始化其指向空间，效果如下:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081648147.png" alt="image-20221208164831061"><br>如不定义自己的赋值运算符，那么S1&#x3D;S2实际上导致 S1.str和 S2.str<br>指向同一地方。<br>如果S1对象消亡，析构函数将释放 S1.str指向的空间，则S2消亡时还<br>要释放一次，就形成两次delete错误!<br>如果执行 S1 &#x3D; “other”；会导致S2.str指向的地方被delete</p>
<p>为了解决以上问题，类的拷贝构造不仅要拷贝指针，还有拷贝指针指向的空间（分配新内存+拷贝）。这种带内存分配的拷贝称为深拷贝</p>
<ul>
<li>浅拷贝：只拷贝成员，对于指针成员，也只拷贝指针变量</li>
<li>深拷贝：拷贝成员，对于指针成员，拷贝指针变量，且拷贝指针指向的内存空间</li>
</ul>
<p>为了实现深拷贝，需要重载“&#x3D;”运算符：</p>
<pre><code>String &amp; operator = (const String &amp; s) &#123;
    delete [] str;  //先释放指针原本指向的空间,因为新空间和原空间大小可能不一样
    str = new char[strlen( s.str)+1];   //分配指针指向的新空间
    strcpy( str,s.str); //新空间赋值初始化
    return * this;  //返回当前对象的指针
&#125;
</code></pre>
<p>还有可优化的，如果传入对象就是当前对象，没必要释放又分配，直接返回即可</p>
<pre><code>String &amp; operator = (const String &amp; s)&#123;
    if( this == &amp; s)
        return * this;
    delete [] str;
    str = new char[strlen(s.str)+1];
    strcpy( str,s.str);
    return * this;
&#125;
</code></pre>
<p>整个类设计如下：</p>
<pre><code>class String &#123;
private:
    char * str;
public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s)&#123;
        delete [] str;
        str = new char[strlen(s)+1];
        strcpy( str, s);
        return * this;
&#125;;
    ~String( ) &#123; delete [] str; &#125;
&#125;;
</code></pre>
<p>再考虑一下运算符重载函数的返回值<br>为什么返回String &amp;<br>原因：对运算符进行重载的时候，好的风格是尽量保留运算符原本的特性<br>例如运算符是可以多个连续运算的</p>
<pre><code>a = b = c;
(a=b)=c; //会修改a的值
</code></pre>
<p>分别等价于：</p>
<pre><code>a.operator=(b.operator=(c));
(a.operator=(b)).operator=(c);
</code></pre>
<p>对于拷贝构造函数，原指针未初始化，不指向任何空间，直接分配空间在拷贝即可，写法如下：</p>
<pre><code>String( String &amp; s)
&#123;
    str = new char[strlen(s.str)+1];
    strcpy(str,s.str);
&#125;
</code></pre>
<h2 id="流运算符的重载"><a href="#流运算符的重载" class="headerlink" title="流运算符的重载"></a>流运算符的重载</h2><p>C++常用的输入输出是怎么实现的？</p>
<pre><code>cout &lt;&lt; 5 &lt;&lt; “this”;
</code></pre>
<ul>
<li>cout是什么?</li>
<li>“&lt;&lt;”原本是位偏移运算，为什么能作用于cout?</li>
<li>“&lt;&lt;”怎么支持连续运算，且支持多种类型</li>
</ul>
<p>原因就是&lt;&lt;被流运算类重载了。</p>
<ul>
<li>cout是在iostream中定义的，ostream类的对象</li>
<li>“&lt;&lt;” 能用在cout上是因为，在iostream里对“ &lt;&lt;” 进行了重载</li>
<li>运算符重载函数返回对象的引用，实现连续运算；多个运算符重载函数的重载，支持多种类型</li>
</ul>
<p>实现方法：</p>
<pre><code>ostream &amp; ostream::operator&lt;&lt;(int n)
&#123;
    …… //输出n的代码
    return * this;
&#125;
ostream &amp; ostream::operator&lt;&lt;(const char * s )
&#123;
    …… //输出s的代码
    return * this;
&#125;
</code></pre>
<p>cout &lt;&lt; 5 &lt;&lt; “this”;<br>等价于： cout.operator&lt;&lt;(5).operator&lt;&lt;(“this”);<br>一个流运算符重载的示例：<br>假定c是Complex复数类的对象，现在希望写“ cout &lt;&lt; c;”，就能以“ a+bi”的形式输出c的值，写“ cin&gt;&gt;c;”，就能从键盘接受“ a+bi”形式的输入，并且使得c.real &#x3D; a,c.imag &#x3D; b</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
using namespace std;
class Complex &#123;
    double real,imag;
    public:
    Complex( double r=0, double i=0):real(r),imag(i)&#123; &#125;;
    friend ostream &amp; operator&lt;&lt;( ostream &amp; os, const Complex &amp; c);
    friend istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c);
&#125;;
ostream &amp; operator&lt;&lt;( ostream &amp; os,const Complex &amp; c)
&#123;
    os &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; //以&quot;a+bi&quot;的形式输出
    return os;
&#125;
   
istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c)
&#123;
    string s;
    is &gt;&gt; s; //将&quot;a+bi&quot;作为字符串读入, “a+bi”中间不能有空格
    int pos = s.find(&quot;+&quot;,0);
    string sTmp = s.substr(0,pos); //分离出代表实部的字符串
    c.real = atof(sTmp.c_str()); //atof库函数能将const char*指针指向的内容转换成 float
    sTmp = s.substr(pos+1, s.length()-pos-2); //分离出代表虚部的字符串
    c.imag = atof(sTmp.c_str());
    return is;
&#125;

int main()
&#123;
    Complex c;
    int n;
    cin &gt;&gt; c &gt;&gt; n;
    cout &lt;&lt; c &lt;&lt; &quot;,&quot; &lt;&lt; n;
    return 0;
&#125;
</code></pre>
<p>运行结果可以如下：</p>
<pre><code>13.2+133i 87    //输入
13.2+133i, 87   //输出
</code></pre>
<h2 id="其他运算符重载"><a href="#其他运算符重载" class="headerlink" title="其他运算符重载"></a>其他运算符重载</h2><p>类型转换运算符”()”重载：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
    double real,imag;
    public:
    Complex(double r=0,double i=0):real(r),imag(i) &#123; &#125;;
    operator double () &#123; return real; &#125;
    //重载强制类型转换运算符 double
&#125;;
int main()
&#123;
    Complex c(1.2,3.4);
    cout &lt;&lt; (double)c &lt;&lt; endl; //输出 1.2
    double n = 2 + c; //等价于 double n=2+c.operator double()
    cout &lt;&lt; n; //输出 3.2
&#125;
</code></pre>
<p>自增自减运算符”++,–”的重载：<br>自增运算符++、自减运算符–有前置&#x2F;后置之分，为了区分所重载的是前置运算符还是后置运算符， C++规定：</p>
<ul>
<li>前置运算符作为一元运算符重载</li>
<li>后置运算符作为二元运算符重载，多写一个没用的参数</li>
</ul>
<p>前置运算符重载形式：</p>
<pre><code>重载为成员函数：
T &amp; operator++();   //不用写入参，当前对象的成员++
T &amp; operator--();
重载为全局函数：
T1 &amp; operator++(T2);
T1 &amp; operator—(T2);
</code></pre>
<p>后置运算符重载形式：    </p>
<pre><code>重载为成员函数：
T operator++(int);  //多写一个入参，用于和前置重载区分
T operator--(int);
重载为全局函数：
T1 operator++(T2,int );
T1 operator—( T2,int);
</code></pre>
<p>调用示例：</p>
<pre><code>int main()
&#123;
    CDemo d(5);
    cout &lt;&lt; (d++ ) &lt;&lt; &quot;,&quot;; //等价于 d.operator++(0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (++d) &lt;&lt; &quot;,&quot;; //等价于 d.operator++();
    cout &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; (d-- ) &lt;&lt; &quot;,&quot;; //等价于 operator--(d,0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (--d) &lt;&lt; &quot;,&quot;; //等价于 operator--(d);
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
&#125;

class CDemo &#123;
private :
    int n;
    public:
    CDemo(int i=0):n(i) &#123; &#125;
    CDemo &amp; operator++(); //用于前置形式
    CDemo operator++( int ); //用于后置形式
    operator int ( ) &#123; return n; &#125;
    friend CDemo &amp; operator--(CDemo &amp; );
    friend CDemo operator--(CDemo &amp; ,int);
&#125;;
CDemo &amp; CDemo::operator++()
&#123; //前置 ++
    n ++;
    return * this;
&#125; // ++s即为: s.operator++();

CDemo CDemo::operator++( int k )
&#123; //后置 ++
    CDemo tmp(*this); //记录修改前的对象
    n ++;
    return tmp; //返回修改前的对象
&#125; // s++即为: s.operator++(0);
CDemo &amp; operator--(CDemo &amp; d)
&#123;//前置--
    d.n--;
    return d;
&#125; //--s即为: operator--(s);
CDemo operator--(CDemo &amp; d,int)
&#123;//后置--
    CDemo tmp(d);
    d.n --;
    return tmp;
&#125; //s--即为: operator--(s, 0);
</code></pre>
<h2 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h2><ul>
<li>C++不允许定义新的运算符</li>
<li>重载后运算符的含义应该符合日常习惯，即保留原运算符的使用风格</li>
<li>运算符重载不改变运算符的优先级</li>
<li>以下运算符不能被重载：“ .” “ .*” “ ::” “ ?:” “sizeof”</li>
<li>重载运算符()、[]、-&gt;、&#x3D;，运算符重载函数必须声明为<br>类的成员函数</li>
</ul>
<h2 id="运算符重载的综合示例"><a href="#运算符重载的综合示例" class="headerlink" title="运算符重载的综合示例"></a>运算符重载的综合示例</h2><p>实现一个可变长数组类型CArray，实现如下用例：</p>
<pre><code>int main() &#123; 
    CArray a; //开始里的数组是空的
    for( int i = 0;i &lt; 5;++i)
        a.push_back(i); //要用动态分配的内存来存放数组元素，需要一个指针成员变量
    CArray a2,a3;
    a2 = a; //要重载“=”
    for( int i = 0; i &lt; a.length(); ++i )
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot; ;  //要重载[]
    a2 = a3; //a2是空的
    for( int i = 0; i &lt; a2.length(); ++i )//a2.length()返回0
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    a[3] = 100;
    CArray a4(a);   //要自己写拷贝构造函数
    for( int i = 0; i &lt; a4.length(); ++i )
        cout &lt;&lt; a4[i] &lt;&lt; &quot; &quot;;
    return 0;
&#125;
</code></pre>
<p>CArray类的设计：</p>
<pre><code>class CArray &#123;
    int size; //数组元素的个数
    int *ptr; //指向动态分配的数组
    public:
    CArray(int s = 0); //s代表数组元素的个数
    CArray(CArray &amp; a);
    ~CArray();
    void push_back(int v); //用于在数组尾部添加一个元素v
    CArray &amp; operator=( const CArray &amp; a);
    //用于数组对象间的赋值
    int length() &#123; return size; &#125; //返回数组元素个数
    int &amp; CArray::operator[](int i) //返回值为 int 不行!不支持 a[i] = 4
    &#123;//用以支持根据下标访问数组元素，如n = a[i] 和a[i] = 4; 这样的语句
        return ptr[i];
    &#125;
&#125;;
</code></pre>
<p>成员函数的实现：</p>
<pre><code>CArray::CArray(int s):size(s)
&#123;
    if( s == 0)
    ptr = NULL;
    else
    ptr = new int[s];
&#125;
CArray::CArray(CArray &amp; a) &#123;
    if( !a.ptr) &#123;
    ptr = NULL;
    size = 0;
    return;
    &#125;
    ptr = new int[a.size];
    memcpy( ptr, a.ptr, sizeof(int ) * a.size);
    size = a.size;
&#125;

CArray::~CArray()
&#123;
    if( ptr) delete [] ptr;
&#125;
CArray &amp; CArray::operator=( const CArray &amp; a)
&#123; //赋值号的作用是使“=”左边对象里存放的数组，大小和内容都和右边的对象一样
    if( ptr == a.ptr) //防止a=a这样的赋值导致出错
    return * this;
    if( a.ptr == NULL) &#123; //如果a里面的数组是空的
    if( ptr ) delete [] ptr;
    ptr = NULL;
    size = 0;
    return * this;
    &#125;
    if( size &lt; a.size) &#123;         //如果原有空间够大，就不用分配新的空间
        if(ptr)
        delete [] ptr;
        ptr = new int[a.size];
    &#125;
    memcpy( ptr,a.ptr,sizeof(int)*a.size);
    size = a.size;
    return * this;
&#125; // CArray &amp; CArray::operator=( const CArray &amp; a)

void CArray::push_back(int v)
&#123; //在数组尾部添加一个元素
    if( ptr) &#123;
        int * tmpPtr = new int[size+1]; //重新分配空间
        memcpy(tmpPtr,ptr,sizeof(int)*size); //拷贝原数组
        内容
        delete [] ptr;
        ptr = tmpPtr;
    &#125;
    else //数组本来是空的
    ptr = new int[1];
    ptr[size++] = v; //加入新的数组元素
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：继承与多态</title>
    <url>/2020/03/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>前文分析了C++类内成员的关系，本文讨论类和类之间的关系。<br>考虑用C++对现实世界的交通工具进行描述。</p>
<ul>
<li>汽车可能包含各种类型，小汽车，公交车，但他们能抽象出四个轮子，烧油这些基本属性</li>
<li>飞机也有各种类型，但也能抽象出机翼，机身等基本属性</li>
<li>轮船…</li>
</ul>
<p>如果自顶向下设计，如何设计这些对象的类？</p>
<ul>
<li>提炼这些交通工具的共有属性，如材质，耗油量，价格，设计成一个交通工具基础类；然后设计一些操作方法，比如制造，启动，停止。</li>
<li>分别设计汽车、飞机、轮船等更具体的类的属性，比如轮子、排水量等，注意，他们也包含基础类的材质，耗油量，价格等基本属性；然后也设计一些方法，比如制造汽车、开汽车和造飞机、开飞机等</li>
<li>然后再设计更细节的类，作为汽车、飞机、轮船类的细化，比如A品牌的汽车，B品牌汽车，作为两个具体类。</li>
</ul>
<p>仔细考虑以上步骤，有以下问题：</p>
<ul>
<li>这些类的属性（成员变量）是相互独立的吗？</li>
<li>这些类的方法（成员函数）是相互独立的吗？</li>
</ul>
<p>C++用类的“继承”描述层层细化的类及其成员变量的关系，用“多态”描述各层方法的实现关系。</p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承关系的概念"><a href="#继承关系的概念" class="headerlink" title="继承关系的概念"></a>继承关系的概念</h2><p>继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个<strong>基类</strong>（也叫父类），而把B作为基类的一个<strong>派生类</strong>(也叫子类)。</p>
<ul>
<li>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数</li>
<li>派生类一经定义后，可以独立使用，不依赖于基类。</li>
<li>派生类拥有基类的全部成员函数和成员变量，不论是private、 protected、 public。但是派生类的成员函数不能访问基类中的private成员</li>
</ul>
<p>一个管理学生的类继承：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651314.png" alt="image-20221208165130260"><br>派生类语法:</p>
<pre><code>class 派生类名： public 基类名
&#123;
&#125;;
</code></pre>
<p>学生类的派生:</p>
<pre><code>class CStudent &#123;
    private:
    string sName;
    int nAge;
    public:
    bool IsThreeGood() &#123; &#125;;
    void SetName( const string &amp; name )
    &#123; sName = name; &#125;
        //......
&#125;;

class CUndergraduateStudent: public CStudent &#123;
    private:
    int nDepartment;
    public:
    bool IsThreeGood() &#123; ...... &#125;; //覆盖
    bool CanBaoYan() &#123; .... &#125;;
&#125;; // 派生类的写法是：类名: public 基类名
</code></pre>
<h2 id="类继承的存储空间"><a href="#类继承的存储空间" class="headerlink" title="类继承的存储空间"></a>类继承的存储空间</h2><p>在类与对象一文讲过，类对象的存储空间，实际就是成员变量的空间，成员函数不在对象空间内（虚函数包含一个虚函数表指针）。那么基类和派生类的对象空间有什么相关性？<br>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。 在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。<br>一个示例：</p>
<pre><code>class CBase
&#123;
    int v1, v2;
&#125;;
class CDerived:public CBase
&#123;
    int v3;
&#125;;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651715.png" alt="image-20221208165140659"></p>
<h2 id="类继承的覆盖"><a href="#类继承的覆盖" class="headerlink" title="类继承的覆盖"></a>类继承的覆盖</h2><p>类内的同名非同参的函数叫函数重载，那么基类与派生类的同名函数呢？<br>派生类可以定义和基类成员同名的成员，这叫<strong>覆盖</strong>。在派生类中访问这类成员时，默认访问派生类中定义的成员，基类的成员函数或变量被“覆盖”掉了。如果要在派生类中访问基类定义的同名成员时，要使用作用域符号::<br>一个例子：</p>
<pre><code>class base &#123;    //基类
    int j;  //默认private
    public:
    int i;
    void func();
&#125;;
class derived : public base&#123;    //派生类
    public:
    int i;  //覆盖基类i
    void access();
    void func(); //覆盖基类func()
&#125;;

void derived::access() &#123; //访问派生类成员
    j = 5; //error
    i = 5; //引用的是派生类的 i
    base::i = 5; //引用的是基类的 i
    func(); //派生类的
    base::func(); //基类的
&#125;
</code></pre>
<p>调用函数:</p>
<pre><code>derived obj;
obj.i = 1;  //访问派生类成员i
obj.base::i = 1; //访问基类成员i
</code></pre>
<p>内存分布:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651894.png" alt="image-20221208165150851"><br>以上只是示例，一般来说，基类和派生类不定义同名成员变量，但经常有同名成员函数，所以覆盖通常用于成员函数覆盖。</p>
<h2 id="类继承的成员访问控制"><a href="#类继承的成员访问控制" class="headerlink" title="类继承的成员访问控制"></a>类继承的成员访问控制</h2><ul>
<li>基类的private成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数</li>
<li>基类的public成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数<br>– 派生类的友元函数<br>– 其他的函数</li>
<li>基类的protected成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数可以访问当前对象的基类的保护成员</li>
</ul>
<p>一个示例：</p>
<pre><code>class Father &#123;
    private: int nPrivate; //私有成员
    public: int nPublic; //公有成员
    protected: int nProtected; // 保护成员
&#125;;
class Son :public Father&#123;
    void AccessFather () &#123;
        nPublic = 1; // ok;
        nPrivate = 1; // wrong
        nProtected = 1; // OK，访问从基类继承的protected成员
        Son f;
        f.nProtected = 1; //wrong ， f不是当前对象
    &#125;
&#125;;

int main()
&#123;
    Father f;
    Son s;
    f.nPublic = 1; // Ok
    s.nPublic = 1; // Ok
    f.nProtected = 1; // error
    f.nPrivate = 1; // error
    s.nProtected = 1; //error
    s.nPrivate = 1; // error
    return 0;
&#125;
</code></pre>
<h2 id="类继承的构造函数"><a href="#类继承的构造函数" class="headerlink" title="类继承的构造函数"></a>类继承的构造函数</h2><p>类似于嵌套类（封闭类）的构造函数，使用初始化列表来实现层层构造，基类和派生类只初始化他们能访问的成员</p>
<pre><code>class Bug &#123;
private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug ()&#123; &#125;;
&#125;;

class FlyBug: public Bug // FlyBug是Bug的派生类
&#123;
    int nWings;
    public:
    FlyBug( int legs,int color, int wings);
&#125;;

Bug::Bug( int legs, int color) //Bug类的构造函数
&#123;
    nLegs = legs;
    nColor = color;
&#125;

//错误的FlyBug构造函数！
FlyBug::FlyBug ( int legs,int color, int wings)
&#123;
    nLegs = legs; // 不能访问
    nColor = color; // 不能访问
    nType = 1; // ok
    nWings = wings;
&#125;

//正确的FlyBug构造函数：使用初始化列表
FlyBug::FlyBug ( int legs, int color, int wings):Bug( legs, color)
&#123;
    nWings = wings;
&#125;

int main() &#123;
    FlyBug fb ( 2,3,4);
    fb.PrintBug();
    fb.nType = 1;
    fb.nLegs = 2 ; // error. nLegs is private
    return 0;
&#125;
</code></pre>
<h2 id="类继承的构造析构时序"><a href="#类继承的构造析构时序" class="headerlink" title="类继承的构造析构时序"></a>类继承的构造析构时序</h2><p>在创建派生类的对象时，需要调用基类的构造函数：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。<br>调用基类构造函数的两种方式:</p>
<ul>
<li><p>显式方式：在派生类的构造函数中，为基类的构造函数提供参数.</p>
<p> derived::derived(arg_derived-list):base(arg_base-list)</p>
</li>
<li><p>隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数</p>
</li>
</ul>
<p>析构函数执行时序:<br>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。<br>一个例子：</p>
<pre><code>class Base &#123;
    public:
    int n;
    Base(int i):n(i)
    &#123; cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;&#125;
    ~Base()
    &#123; cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; destructed&quot; &lt;&lt; endl; &#125;
&#125;;
    
class Derived:public Base &#123;
    public:
    Derived(int i):Base(i)
    &#123; cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl; &#125;
    ~Derived()
    &#123; cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;&#125;
&#125;;
int main() &#123; Derived Obj(3); return 0; &#125;
</code></pre>
<p>输出结果:</p>
<pre><code>Base 3 constructed
Derived constructed
Derived destructed
Base 3 destructed
</code></pre>
<p>##封闭派生类的构造函数<br>封闭类的构造用初始化列表，派生类也用初始化列表，那么封闭派生类呢？<br>还是初始化列表</p>
<pre><code>class Bug &#123;
    private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug ()&#123; &#125;;
&#125;;

class Skill &#123;
    public:
    Skill(int n) &#123; &#125;
&#125;;
class FlyBug: public Bug &#123;
    int nWings;
    Skill sk1, sk2;
    public:
    FlyBug( int legs, int color, int wings);
&#125;;
FlyBug::FlyBug( int legs, int color, int wings):
    Bug(legs,color),sk1(5),sk2(color) ,nWings(wings) &#123; //初始化列表，不能访问的通通交给下层构造函数
&#125;
</code></pre>
<h2 id="封闭派生类的构造析构时序"><a href="#封闭派生类的构造析构时序" class="headerlink" title="封闭派生类的构造析构时序"></a>封闭派生类的构造析构时序</h2><p>在创建派生类的对象时:</p>
<ol>
<li>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员</li>
<li>再执行成员对象类的构造函数，用以初始化派生类对象中成员对象</li>
<li>最后执行派生类自己的构造函数<br>在派生类对象消亡时：</li>
<li>先执行派生类自己的析构函数</li>
<li>再依次执行各成员对象类的析构函数</li>
<li>最后执行基类的析构函数<br>析构函数的调用顺序与构造函数的调用顺序相反<h1 id="类的复合"><a href="#类的复合" class="headerlink" title="类的复合"></a>类的复合</h1>在数学上，两个集合有无关、相交和包含的关系。对于多个类来说，也应该有以上三种关系。无关类&#x3D;两个成员不相关的类；继承类&#x3D;类成员间有继承关系的类；那么相交的类呢？<h2 id="复合关系的概念"><a href="#复合关系的概念" class="headerlink" title="复合关系的概念"></a>复合关系的概念</h2>C++用“复合”表示类的相交关系。</li>
</ol>
<p>1)继承：“是”的关系<br>基类是A， B是基类A的派生类，逻辑上要求：“一个B对象也是一个A对象”<br>2)复合：“有”的关系<br>类C中“有” 成员变量k，k是类D的对象，则C和D是复合关系，逻辑上要求：“D对象是C对象的固有属性或组成部分</p>
<p>下面比较一下继承和复合在具体设计的实例：<br>继承关系顶层设计例子:</p>
<ul>
<li>写了一个 CMan 类代表男人</li>
<li>后来又发现需要一个CWoman类来代表女人</li>
<li>CWoman类和CMan类有共同之处,让CWoman类从CMan类派生而来，是否合适？</li>
<li>错！从一开始就应该设计CHuman类，代表“人” ,然后CMan和CWoman都从<br>CHuman派生</li>
</ul>
<p>继承逻辑关系：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652246.png" alt="image-20221208165210195"></p>
<p>复合关系顶层设计例子：</p>
<ul>
<li>几何形体程序中，需要写“点”类，也需要写“圆”类</li>
<li>每个圆都有圆心，那么点类应该从圆类派生出来吗？</li>
<li>错！”点“不仅在圆内有，在其他图形也有，不是圆独有，非继承关系</li>
<li>实际上，圆和点是复合关系，每一个“圆”对象里都包含(<strong>有</strong>)一个“点”对象</li>
<li>逻辑上，复合关系就是，我的一部分可以看成是你的，但是我的全部东西不都属于你</li>
</ul>
<p>复合关系的类通常用友元实现：</p>
<pre><code>class CPoint
&#123;
    double x,y;
    friend class CCircle;
    //便于Ccirle类操作其圆心
&#125;;

class CCircle
&#123;
    double r;
    CPoint center;
&#125;;
</code></pre>
<h2 id="复合关系的典型示例"><a href="#复合关系的典型示例" class="headerlink" title="复合关系的典型示例"></a>复合关系的典型示例</h2><p>如果要写一个小区养狗管理程序，需要写一个“业主”类，还需要写一个“狗” 类<br>狗是归宿于业主的，一个业主可以有多条狗，狗也可以随时脱离业主<br>考虑以下设计方法：<br>设计人和狗两个类，相互包含对方类</p>
<pre><code>class CDog;
class CMaster
&#123;
    CDog dogs[10];
&#125;;
class CDog
&#123;
    CMaster m;
&#125;;
</code></pre>
<p> 这样有循环定义错误！且逻辑上，狗和人并非相互包含关系<br> 这种关系上相互相关，对象本身又完全独立的情况，用对象指针表示</p>
<pre><code>class CMaster; //CMaster必须提前声明，不能先写CMaster类后写Cdog类
class CDog &#123;
    CMaster * pm;
&#125;;
class CMaster &#123;
    CDog * dogs[10];
&#125;;
</code></pre>
<p>逻辑关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652390.png" alt="image-20221208165220338"></p>
<h1 id="继承的不足"><a href="#继承的不足" class="headerlink" title="继承的不足"></a>继承的不足</h1><h2 id="继承方式的访问限制"><a href="#继承方式的访问限制" class="headerlink" title="继承方式的访问限制"></a>继承方式的访问限制</h2><p>基类和派生类是包含的关系，那么基类对象和派生类对象是什么关系？<br>对于类的public派生方式:</p>
<pre><code>class base &#123; &#125;;
class derived : public base &#123; &#125;;
base b;
derived d;
</code></pre>
<p>1）派生类的对象可以赋值给基类对象<br>b &#x3D; d;<br>2）派生类对象可以初始化基类引用<br>base &amp; br &#x3D; d;<br>3）派生类对象的地址可以赋值给基类指针<br>base * pb &#x3D; &amp; d;<br>如果派生方式是 private或protected，则上述三条不可行</p>
<p>对于类的protected和private派生方式:</p>
<pre><code>class base &#123;&#125;;
class derived : protected base &#123;&#125;;
base b;
derived d;
</code></pre>
<p>• protected继承时，基类的public成员和protected成员成为派生类的protected成员。<br>• private继承时，基类的public成员成为派生类的private成员，基类的protected成员成为派生类的不可访问成员。<br>• protected和private继承不是“是”的关系</p>
<h2 id="派生类的对象指针转换"><a href="#派生类的对象指针转换" class="headerlink" title="派生类的对象指针转换"></a>派生类的对象指针转换</h2><p>public派生的情况下,派生类对象的指针可以直接赋值给基类指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
//ptrBase指向的是一个Derived类的对象；
</code></pre>
<p>*ptrBase可以看作一个Base类的对象，访问它的public成员直接通过ptrBase即可，但不能通过ptrBase访问objDerived对象中属于Derived类而不属于Base类的成员<br>过强制指针类型转换，可以把ptrBase转换成Derived类的指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
Derived *ptrDerived = (Derived * ) ptrBase;
</code></pre>
<p>程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会错</p>
<p>派生类的指针赋值给基类后，基类指针也不能访问派生类的特有成员</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Base &#123;
    protected:
    int n;
    public:
    Base(int i):n(i)&#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; constructed&quot; &lt;&lt; endl; &#125;
    ~Base() &#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; destructed&quot; &lt;&lt; endl;&#125;
    void Print() &#123; cout &lt;&lt; &quot;Base:n=&quot; &lt;&lt; n &lt;&lt; endl;&#125;
&#125;;

class Derived:public Base &#123;
    public:
    int v;
    Derived(int i):Base(i),v(2 * i) &#123;
    cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl;
&#125;

~Derived() &#123;
    cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;
&#125;

void Func() &#123; &#125; ;
    void Print() &#123;
        cout &lt;&lt; &quot;Derived:v=&quot; &lt;&lt; v &lt;&lt; endl;
        cout &lt;&lt; &quot;Derived:n=&quot; &lt;&lt; n &lt;&lt; endl;
    &#125;
&#125;;

int main() &#123;
    Base objBase(5);
    Derived objDerived(3);
    Base * pBase = &amp; objDerived ;
    //pBase-&gt;Func(); //err;Base类没有Func()成员函数
    //pBase-&gt;v = 5; //err; Base类没有v成员变量
    pBase-&gt;Print();
    //Derived * pDerived = &amp; objBase; //error
    Derived * pDerived = (Derived *)(&amp; objBase);
    pDerived-&gt;Print(); //慎用，可能出现不可预期的错误
    pDerived-&gt;v = 128; //往别人的空间里写入数据，会有问题
    objDerived.Print();
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Base 5 constructed
Base 3 constructed
Derived constructed
Base:n=3
Derived:v=1245104 //pDerived-&gt;n 位于别人的空间里
Derived:n=5
Derived:v=6
Derived:n=3
Derived destructed
Base 3 destructed
Base 5 destructed
</code></pre>
<p>从逻辑上来说，派生类指针既然能被赋值给基类指针，那么通过基类指针，应该能调用派生类的成员函数，获取派生类的成员变量。在下一章，继承类的多态将实现这个目的。</p>
<h2 id="多级继承"><a href="#多级继承" class="headerlink" title="多级继承"></a>多级继承</h2><p>类A派生类B，类B派生类C，类C派生类D……<br>– 类A是类B的直接基类<br>– 类B是类C的直接基类，类A是类C的间接基类<br>– 类C是类D的直接基类，类A、 B是类D的间接基类<br>在声明派生类时， 只需要列出它的直接基类<br>– 派生类沿着类的层次自动向上继承它的间接基类<br>– 派生类的成员包括<br>• 派生类自己定义的成员<br>• 直接基类中的所有成员<br>• 所有间接基类的全部成员</p>
<h1 id="多态：在继承上更进一步"><a href="#多态：在继承上更进一步" class="headerlink" title="多态：在继承上更进一步"></a>多态：在继承上更进一步</h1><p>前面派生类的对象指针转换一节，基类指针强转后也不能访问派生类私有对象。考虑一下本文开始讲的交通工具顶层设计思路，在顶层设计时就要设计类的成员函数，在派生类也要设计成员函数，这些函数会有重合的情况吗？如果有重合，基类指针也不能访问派生类成员，这样基类和派生类不就失去联系了吗？多级继承这种情况不是更加严重？<br>为了解决这种问题，本节引入继承类的“多态”<br>多态能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少</p>
<h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><p>在类的定义中，前面有 virtual 关键字的成员函数就是虚函数</p>
<pre><code>class base &#123;
    virtual int get() ;
&#125;;
int base::get()&#123; &#125;
</code></pre>
<p>virtual关键字只用在类定义里的函数声明中使用，定义函数体时不用。<br>使用虚函数，来实现“多态”效果。多态有通过指针和引用两种表现形式:</p>
<ul>
<li>能通过基类的指针调用派生类虚函数，访问其特有成员变量</li>
</ul>
<p>派生类的指针可以赋给基类指针<br>通过基类指针调用基类和派生类中的同名虚函数时:<br>（1）若该指针指向一个基类的对象，那么被调用是<br>基类的虚函数；<br>（2）若该指针指向一个派生类的对象，那么被调用<br>的是派生类的虚函数</p>
<pre><code>class CBase &#123;
public:
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
class CDerived:public CBase &#123;
public :
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
int main() &#123;
    CDerived ODerived;
    CBase * p = &amp; ODerived;
    p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象
    return 0;
&#125; 
</code></pre>
<ul>
<li>能通过基类的引用调用派生类虚函数</li>
</ul>
<p>派生类的对象可以赋给基类引用<br>通过基类引用调用基类和派生类中的同名虚函数时:<br>（1）若该引用引用的是一个基类的对象，那么被调<br>用是基类的虚函数；<br>（2）若该引用引用的是一个派生类的对象，那么被<br>调用的是派生类的虚函数。</p>
<pre><code>class CBase &#123;
public:
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
class CDerived:public CBase &#123;
public :
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
int main() &#123;
    CDerived ODerived;
    CBase &amp; r = ODerived;
    r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象
    return 0;
&#125; 
</code></pre>
<p>是不是所有成员函数加virtual都是多态？不是！</p>
<ul>
<li>在非构造或析构函数的成员函数中调用虚函数，是多态。在运行时才确定到底调用哪一层派生类函数</li>
<li>在构造函数和析构函数中调用虚函数，不是多态。调用的函数是当前类的函数，编译时即确定</li>
</ul>
<p>多层继承实现多态，每一层都要加virtual关键字吗？</p>
<ul>
<li>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</li>
</ul>
<h2 id="多态与对象指针"><a href="#多态与对象指针" class="headerlink" title="多态与对象指针"></a>多态与对象指针</h2><p>一个变量有两方面属性：类型、值<br>那么多态把derived类的地址值，赋值给base类的指针，访问对象成员时是什么效果？<br>以下例子的this指针指向什么？</p>
<pre><code>class Base &#123;
public:
    void fun1() &#123; this-&gt;fun2(); &#125; //this是基类指针， fun2是虚函数，所以是多态
    virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
class Derived:public Base &#123;
public:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
int main() &#123;
    Derived d;
    Base * pBase = &amp; d;
    pBase-&gt;fun1();
    return 0;
&#125;
</code></pre>
<p>pBase被Derived对象的地址赋值后，其值为Derived对象的地址，但类型还是Base的指针（多态指针赋值不会强转）。pBase-&gt;fun1()会先在Base类访问其fun1()，传入this指针（指向fun2）,而this-&gt;fun2()会调用Derived类的fun2()<br>输出： </p>
<pre><code>Derived:fun2()
</code></pre>
<p>虚函数也可以定义为private：</p>
<pre><code>class Base &#123;
private:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
class Derived:public Base &#123;
public:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
Derived d;
Base * pBase = &amp; d;
pBase -&gt; fun2(); // 编译出错
</code></pre>
<p>pBase已经被赋值为指向derived d的指针，不能调用base类的private函数。</p>
<h2 id="多态的实例-游戏开发"><a href="#多态的实例-游戏开发" class="headerlink" title="多态的实例:游戏开发"></a>多态的实例:游戏开发</h2><p>游戏中有很多种怪物，每种怪物都有一个类与之对应。某个玩家创建的具体怪物就是对象<br>怪物的主要动作（成员函数）有：</p>
<ul>
<li>攻击（Attack），针对不同的被攻击者有不同的函数</li>
<li>反击（FightBack），被某个怪物攻击时做出的相应动作</li>
<li>掉血（Hurted），被攻击时会掉血，血量值不同有不同处理，如死亡</li>
</ul>
<p>现在的需求是：已经有CWolf、CGhost两种怪物，需要设计新的怪物CThunderBird，并能满足和其他怪物的交互<br>顶层设计:<br>设置基类 CCreature，并且使CDragon, CWolf等其他类都从CCreature派生而来<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652097.png" alt="image-20221208165241029"><br>非多态的派生类设计：<br>由于每个怪物对于其他怪物的攻击和反击都是不同的，每个怪物类都要设计一组Attack和FightBack：</p>
<pre><code>class class CCreature &#123;
    protected: int nPower ; //代表攻击力
    int nLifeValue ; //代表生命值
&#125;;
class CThunderBird : public CCreature &#123;
    public:
    void Attack(CWolf * pWolf) &#123;
        ．．．表现攻击动作的代码
        pWolf-&gt;Hurted( nPower);
        pWolf-&gt;FightBack( this);
    &#125;
    void Attack( CDragon * pDragon) &#123;
        ．．．表现攻击动作的代码
        pDragon-&gt;Hurted( nPower);
        pDragon-&gt;FightBack( this);
    &#125;
    void FightBack( CWolf * pWolf) &#123;
        ．．．．表现反击动作的代码
        pWolf -&gt;Hurted( nPower / 2);
    &#125;
    void FightBack( CDragon * pDragon) &#123;
        ．．．．表现反击动作的代码
        pDragon-&gt;Hurted( nPower / 2 );
    &#125;
    void Hurted ( int nPower) &#123;
        ．．．．表现受伤动作的代码
        nLifeValue -= nPower;
    &#125;
&#125;
</code></pre>
<p>现有n种怪物，CThunderBird类中就得有n个Attack 和n个FightBack成员函数，对于其他类也得新增针对CThunderBird的Attack和FightBack。这种设计工作量过于巨大。原因就在于要区分传入的对象指针。<br>那么能否传入基类的指针呢，这样就不存在为各种类型写几个函数。基类指针要访问派生类的成员，得用虚函数形成多态。多态实现如下：</p>
<pre><code>//基类 CCreature：
class CCreature &#123;
protected :
    int m_nLifeValue, m_nPower;
    public:
    virtual void Attack( CCreature * pCreature) &#123;&#125;
    virtual void Hurted( int nPower) &#123; &#125;
    virtual void FightBack( CCreature * pCreature) &#123;&#125;
&#125;;
//派生类 CDragon:
class CDragon : public CCreature &#123;
public:
    virtual void Attack( CCreature * pCreature);
    virtual void Hurted( int nPower);
    virtual void FightBack( CCreature * pCreature);
&#125;;

//派生类的成员函数实现具体操作
void CDragon::Attack(CCreature * p) //传入基类指针
&#123; …表现攻击动作的代码
    p-&gt;Hurted(m_nPower); //多态
    p-&gt;FightBack(this); //多态
&#125;
void CDragon::Hurted( int nPower)
&#123; …表现受伤动作的代码
    m_nLifeValue -= nPower;
&#125;
void CDragon::FightBack(CCreature * p)
&#123; …表现反击动作的代码
    p-&gt;Hurted(m_nPower/2); //多态
&#125;

//多态的调用
CDragon Dragon; CWolf Wolf; CGhost Ghost;
CThunderBird Bird；
Dragon.Attack( &amp; Wolf); //调用CWolf::Hurted
Dragon.Attack( &amp; Ghost); //调用CGhost::Hurted
Dragon.Attack( &amp; Bird); //调用CBird::Hurted
</code></pre>
<p>使用多态，新增某个派生类时，已有的类可以原封不动，因为传入基类指针，会“自动”调用正确的派生类函数，开发者只需要设计新增的派生类和其成员函数即可</p>
<h2 id="多态的原理：虚函数表指针"><a href="#多态的原理：虚函数表指针" class="headerlink" title="多态的原理：虚函数表指针"></a>多态的原理：虚函数表指针</h2><p>多态” 的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定，这叫“动态联编”<br>首先分析包含虚函数的类对象的内存分布：</p>
<pre><code>class Base &#123;
public:
int i;
    virtual void Print() &#123; cout &lt;&lt; &quot;Base:Print&quot; ; &#125;
&#125;;

class Derived : public Base&#123;
public:
int n;
    virtual void Print() &#123; cout &lt;&lt;&quot;Drived:Print&quot; &lt;&lt; endl; &#125;
&#125;;

int main() &#123;
    Derived d;
    cout &lt;&lt; sizeof( Base) &lt;&lt; &quot;,&quot;&lt;&lt; sizeof( Derived ) ;
    return 0;
&#125;
</code></pre>
<p>输出：8, 12<br>为什么类对象的size比成员变量int（4字节）还多4字节？<br>因为包含虚函数的基类，实例化的对象除了成员变量，还包含一个指针（一般4字节），指向虚函数的入口地址，如果有多个虚函数，这些地址连续排列形成虚函数表，指针指向首个虚函数地址。如果这个指针指向基类，就能找到基类的所有虚函数入口，如果指针指向派生类，就能找到派生类的的所有虚函数入口。基类和派生类对象的指针赋值，实际会导致虚函数表指针指向的虚函数入口地址不同，从而调用时不同。<br>如果当前指针指向基类，则调用基类自己的虚函数：</p>
<pre><code>Base b;
pBase = &amp;b;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652980.png" alt="image-20221208165259927"><br>如果当前指针指向派生类，则调用派生类的虚函数：</p>
<pre><code>Derived d;
pDerived = &amp;d;
pBase = pDerived;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081653211.png" alt="image-20221208165311145"><br>动态联编的实现：<br>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令<br>而普通函数是编译过程中确定了成员函数的入口地址，不存在运行时根据对象来改变某个函数的入口地址。</p>
<h2 id="虚函数与抽象类"><a href="#虚函数与抽象类" class="headerlink" title="虚函数与抽象类"></a>虚函数与抽象类</h2><p>可以想象得到，前文的游戏使用虚函数的例子是通用的，先设计基类，提炼对象属性，定义虚函数；再派生子类，在子类实现局函数的具体操作。那么问题来了，基类的虚函数有必要实现函数体吗？<br>很多情况，基类只是一个抽象，定义了函数的名称和参数，不需要在基类实现虚函数，全部交给派生类实现。</p>
<ul>
<li>纯虚函数：没有函数体的虚函数</li>
<li>抽象类：包含纯虚函数的类</li>
</ul>
<p>纯虚函数写法：没函数体{}，直接&#x3D;0</p>
<pre><code>class A &#123;
private: int a;
public:
    virtual void Print( ) = 0 ; //纯虚函数
    void fun() &#123; cout &lt;&lt; &quot;fun&quot;; &#125;
&#125;;
</code></pre>
<p>抽象类特点：</p>
<ul>
<li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li>
<li>可以创建抽象类的指针和引用，它们可以指向派生类的对象</li>
</ul>
<p>抽象类的指针：</p>
<pre><code>A a ; // 错， A 是抽象类，不能创建对象
A * pa ; // ok,可以定义抽象类的指针和引用
pa = new A ; //错误, A 是抽象类，不能创建对象
</code></pre>
<p>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类<br>抽象类的成员函数可以调用纯虚函数，但是构造函数或析构函数内不能调用纯虚函数</p>
<pre><code>class A &#123;
public:
    virtual void f() = 0; //纯虚函数
    void g( ) &#123; 
        this-&gt;f( ) ; //ok
    &#125;
    A( )&#123; 
        f( ); // 错误
    &#125;
&#125;;
class B:public A&#123;
public:
    void f()&#123;cout&lt;&lt;&quot;B:f()&quot;&lt;&lt;endl; &#125;
&#125;;
</code></pre>
<h2 id="虚函数与构造析构函数"><a href="#虚函数与构造析构函数" class="headerlink" title="虚函数与构造析构函数"></a>虚函数与构造析构函数</h2><p>前面考虑了普通成员函数加virtual，可以形成虚函数达到继承类的多态效果。那么构造函数和析构函数呢？</p>
<ul>
<li>不允许以虚函数作为构造函数</li>
<li>类继承需要把基类的析构函数设为虚函数</li>
</ul>
<p>对于常规析构函数，通过基类指针删除派生类对象时，只能调用基类的析构函数。但是合理的做法是，应该先调用派生类的析构函数，然后调用基类的析构函数。解决的方法：把析构函数定义为virtual，由于基类析构函数是虚函数，派生类的同名析构函数自然也是虚函数。<br>什么时候定义虚析构函数</p>
<ul>
<li>一个类只要定义了虚函数，则应该将析构函数也定义成虚函数</li>
<li>一个类打算作为基类使用，则应该将析构函数定义成虚函数</li>
</ul>
<p>虚析构函数用法：通过基类的指针删除派生类对象，会首先调用派生类的析构函数，然后调用基类的析构函数</p>
<pre><code>class son&#123;
public:
    virtual ~son() &#123;cout&lt;&lt;&quot;bye from son&quot;&lt;&lt;endl;&#125;;
&#125;;
class grandson:public son&#123;
public:
    ~grandson()&#123;cout&lt;&lt;&quot;bye from grandson&quot;&lt;&lt;endl;&#125;;
&#125;;
int main() &#123;
    son *pson;
    pson= new grandson(); //pson指向派生类grandson
    delete pson;
    return 0;
&#125;
</code></pre>
<p>输出： </p>
<pre><code>bye from grandson
bye from son
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC使用笔记</title>
    <url>/2020/06/22/GCC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="gcc编译选项"><a href="#gcc编译选项" class="headerlink" title="gcc编译选项"></a>gcc编译选项</h1><p>gcc提供了大量的警告选项，对代码中可能存在的问题提出警告，通常可以使用-Wall来开启以下警告:</p>
<pre><code>   -Waddress -Warray-bounds (only with -O2) -Wc++0x-compat
   -Wchar-subscripts -Wimplicit-int -Wimplicit-function-declaration
   -Wcomment -Wformat -Wmain (only for C/ObjC and unless
   -ffreestanding) -Wmissing-braces -Wnonnull -Wparentheses
   -Wpointer-sign -Wreorder -Wreturn-type -Wsequence-point
   -Wsign-compare (only in C++) -Wstrict-aliasing -Wstrict-overflow=1
   -Wswitch -Wtrigraphs -Wuninitialized (only with -O1 and above)
   -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value
   -Wunused-variable

unused-function:警告声明但是没有定义的static函数;
unused- label:声明但是未使用的标签;
unused-parameter:警告未使用的函数参数;
unused-variable:声明但是未使用的本地变量;
unused-value:计算了但是未使用的值;
format:printf和scanf这样的函数中的格式字符串的使用不当;
implicit-int:未指定类型;
implicit-function:函数在声明前使用;
char- subscripts:使用char类作为数组下标(因为char可能是有符号数);
missingbraces:大括号不匹配;
parentheses: 圆括号不匹配;
return-type:函数有无返回值以及返回值类型不匹配;
sequence-point:违反顺序点的代码,比如 a[i] = c[i++];
switch:switch语句缺少default或者switch使用枚举变量为索引时缺少某个变量的case;
strict- aliasing=n:使用n设置对指针变量指向的对象类型产生警告的限制程度,默认n=3;只有在-fstrict-aliasing设置的情况下有效;
unknow-pragmas:使用未知的#pragma指令;
uninitialized:使用的变量为初始化,只在-O2时有效;
</code></pre>
<p>以下是在-Wall中不会激活的警告选项:</p>
<pre><code>cast-align:当指针进行类型转换后有内存对齐要求更严格时发出警告;
sign- compare:当使用signed和unsigned类型比较时;
missing-prototypes:当函数在使用前没有函数原型时;
packed:packed 是gcc的一个扩展,是使结构体各成员之间不留内存对齐所需的空间,有时候会造成内存对齐的问题;
padded:也是gcc的扩展,使结构体成员之间进行内存对齐的填充,会造成结构体体积增大.
unreachable-code:有不会执行的代码时.
inline:当inline函数不再保持inline时 (比如对inline函数取地址);
disable-optimization:当不能执行指定的优化时.(需要太多时间或系统资源).
可以使用 -Werror时所有的警告都变成错误,使出现警告时也停止编译.需要和指定警告的参数一起使用.
</code></pre>
<p>编译的优化级别:<br>gcc默认提供了5级优化选项的集合:</p>
<pre><code>-O0:无优化(默认)
-O和-O1:使用能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化.在编译大型程序的时候会显著增加编译时内存的使用.
-O2: 包含-O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化.编译器不执行循环展开以及函数内联.此选项将增加编译时间和目标文件的执行性能.
-Os:专门优化目标文件大小,执行所有的不增加目标文件大小的-O2优化选项.并且执行专门减小目标文件大小的优化选项.
-O3: 打开所有-O2的优化选项并且增加 -finline-functions, -funswitch-loops,-fpredictive-commoning, -fgcse-after-reload and -ftree-vectorize优化选项.
</code></pre>
<p>-O1包含的选项-O1通常可以安全的和调试的选项一起使用:</p>
<pre><code>   -fauto-inc-dec -fcprop-registers -fdce -fdefer-pop -fdelayed-branch
   -fdse -fguess-branch-probability -fif-conversion2 -fif-conversion
   -finline-small-functions -fipa-pure-const -fipa-reference
   -fmerge-constants -fsplit-wide-types -ftree-ccp -ftree-ch
   -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse
   -ftree-fre -ftree-sra -ftree-ter -funit-at-a-time
</code></pre>
<p>以下所有的优化选项需要在名字前加上-f,如果不需要此选项可以使用-fno-前缀</p>
<pre><code>defer-pop:延迟到只在必要时从函数参数栈中pop参数;
thread- jumps:使用跳转线程优化,避免跳转到另一个跳转;
branch-probabilities:分支优化;
cprop- registers:使用寄存器之间copy-propagation传值;
guess-branch-probability:分支预测;
omit- frame-pointer:可能的情况下不产生栈帧;
</code></pre>
<p>-O2:以下是-O2在-O1基础上增加的优化选项:</p>
<pre><code>    -falign-functions  -falign-jumps -falign-loops  -falign-labels
   -fcaller-saves -fcrossjumping -fcse-follow-jumps  -fcse-skip-blocks
   -fdelete-null-pointer-checks -fexpensive-optimizations -fgcse
   -fgcse-lm -foptimize-sibling-calls -fpeephole2 -fregmove
   -freorder-blocks  -freorder-functions -frerun-cse-after-loop
   -fsched-interblock  -fsched-spec -fschedule-insns
   -fschedule-insns2 -fstrict-aliasing -fstrict-overflow -ftree-pre
   -ftree-vrp
</code></pre>
<p>cpu架构的优化选项,通常是-mcpu(将被取消);-march,-mtune</p>
<p>Debug选项:</p>
<pre><code>在 gcc编译源代码时指定-g选项可以产生带有调试信息的目标代码,gcc可以为多个不同平台上帝不同调试器提供调试信息,默认gcc产生的调试信息是为 gdb使用的,可以使用-gformat 指定要生成的调试信息的格式以提供给其他平台的其他调试器使用.常用的格式有
-ggdb:生成gdb专用的调试信息,使用最适合的格式(DWARF 2,stabs等)会有一些gdb专用的扩展,可能造成其他调试器无法运行.
-gstabs:使用 stabs格式,不包含gdb扩展,stabs常用于BSD系统的DBX调试器.
-gcoff:产生COFF格式的调试信息,常用于System V下的SDB调试器;
-gxcoff:产生XCOFF格式的调试信息,用于IBM的RS/6000下的DBX调试器;
-gdwarf- 2:产生DWARF version2 的格式的调试信息,常用于IRIXX6上的DBX调试器.GCC会使用DWARF version3的一些特性.
</code></pre>
<p>可以指定调试信息的等级:在指定的调试格式后面加上等级:<br>如: -ggdb2 等,0代表不产生调试信息.在使用-gdwarf-2时因为最早的格式为-gdwarf2会造成混乱,所以要额外使用一个-glevel来指定调试信息的等级,其他格式选项也可以另外指定等级.<br>gcc可以使用-p选项指定生成信息以供porf使用.</p>
<h1 id="gcc配置选项"><a href="#gcc配置选项" class="headerlink" title="gcc配置选项"></a>gcc配置选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727329.png" alt="6"></p>
<h1 id="gcc常用选项"><a href="#gcc常用选项" class="headerlink" title="gcc常用选项"></a>gcc常用选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081725642.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726685.png" alt="2"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726022.png" alt="3"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726272.png" alt="4"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727091.png" alt="5"></p>
]]></content>
      <categories>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>Github项目学习：linked-list-good-taste</title>
    <url>/2023/03/28/Github%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9Alinked-list-good-taste/</url>
    <content><![CDATA[<p>本文转载自 <a href="https://github.com/mkirchner/linked-list-good-taste">linked-list-good-taste</a>，添加了个人理解的注释</p>
<h1 id="Linked-lists-pointer-tricks-and-good-taste"><a href="#Linked-lists-pointer-tricks-and-good-taste" class="headerlink" title="Linked lists, pointer tricks and good taste"></a>Linked lists, pointer tricks and good taste</h1><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-code">The code</a><ul>
<li><a href="#the-cs101-version">The CS101 version</a></li>
<li><a href="#a-more-elegant-solution">A more elegant solution</a></li>
</ul>
</li>
<li><a href="#how-does-it-work">How does it work?</a><ul>
<li><a href="#integrating-the-head-pointer">Integrating the head pointer</a></li>
<li><a href="#maintaining-a-handle">Maintaining a handle</a></li>
</ul>
</li>
<li><a href="#going-beyond">Going beyond</a><ul>
<li><a href="#inserting-before-existing-items">Inserting before existing items</a></li>
<li><a href="#quick-refactor">Quick refactor</a></li>
<li><a href="#implementing-insert_before">Implementing insert_before()</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In a 2016 <a href="https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux">TED interview</a> (14:10) Linus Torvalds speaks about what he considers <em>good taste</em> in coding. As an example, he presents two implementations of item removal in singly linked lists (reproduced below).  In order to remove the first item from a list, one of the implementations requires a special case, the other one does not.  Linus, obviously, prefers the latter.</p>
<p>His comment is:</p>
<blockquote>
<p>[…] I don’t want you to understand why it doesn’t have the if statement.<br>But I want you to understand that sometimes you can see a problem in a<br>different way and rewrite it so that a special case goes away and becomes the<br>normal case, and that’s <em>good code</em>. […] – L. Torvalds</p>
</blockquote>
<p>The code snippets he presents are C-style pseudocode and are simple enough to follow. However, as Linus mentions in the comment, the snippets lack a conceptual explanation and it is not immediately evident how the more elegant solution actually works.</p>
<p>The next two sections look at the technical approach in detail and demonstrate how and why the indirect addressing approach is so neat. The last section extends the solution from item deletion to insertion.</p>
<h2 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h2><p>The basic data structure for a singly linked list of integers is shown in Figure 1.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281032617.png" alt="linked list"></p>
<p>Numbers are arbitrarily chosen integer values and arrows indicate pointers. <code>head</code> is a pointer of type <code>list_item *</code> and each of the boxes is an instance of an <code>list_item</code> struct, each with a member variable (called <code>next</code> in the code) of type <code>list_item *</code> that points to the next item.</p>
<p>The C implementation of the data structure is:</p>
<p><strong>注释：list的item包含两个成员：值和指针变量；list本身是用head指针表示</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> <span class="title">list_item</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We also include a (minimal) API:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The textbook version */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br><span class="line"><span class="comment">/* A more elegant solution */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br></pre></td></tr></table></figure>

<p>With that in place, let’s have a look at the implementations of <code>remove_cs101()</code> and <code>remove_elegant()</code>. The code of these examples is true to the pseudocode from Linus’ example and also compiles and runs.</p>
<h3 id="The-CS101-version"><a href="#The-CS101-version" class="headerlink" title="The CS101 version"></a>The CS101 version</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281919267.png" alt="image-20230328191958119"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item *cur = l-&gt;head, *prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != target) &#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev)</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                l-&gt;head = cur-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释：如果将list理解为(值+指针变量)成员组成的一串数据，那么访问一个成员的前置成员就得用经典的双指针法，因为单链表没有”记忆性”，要额外的前置指针保存前置位置。</strong></p>
<p><strong>考虑边界条件：1.遍历完了都找不到目标成员；2.前置指针在使用前要判空，如果为空，表明第一个节点就是目标节点，这两种情况都属于上述代码的else case处理</strong></p>
<p>The standard CS101 approach makes use of two traversal pointers <code>cur</code> and <code>prev</code>, marking the current and previous traversal position in the list, respectively.  <code>cur</code> starts at the list head <code>head</code>, and advances until the target is found.  <code>prev</code> starts at <code>NULL</code> and is subsequently updated with the previous value of <code>cur</code> every time <code>cur</code> advances. After the target is found, the algorithm tests if <code>prev</code> is non-<code>NULL</code>. If yes, the item is not at the beginning of the list and the removal consists of re-routing the linked list around <code>cur</code>. If <code>prev</code> is <code>NULL</code>, <code>cur</code> is pointing to the first element in the list, in which case, removal means moving the list head forward.</p>
<h3 id="A-more-elegant-solution"><a href="#A-more-elegant-solution" class="headerlink" title="A more elegant solution"></a>A more elegant solution</h3><p>The more elegant version has less code and does not require a separate branch to deal with deletion of the first element in a list.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code uses an indirect pointer <code>p</code> that holds the address of a pointer to a list item, starting with the address of <code>head</code>.  In every iteration, that pointer is advanced to hold the address of the pointer to the next list item, i.e. the address of the <code>next</code> element in the current <code>list_item</code>.<br>When the pointer to the list item <code>*p</code> equals <code>target</code>, we exit the search loop and remove the item from the list.</p>
<h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h2><p>The key insight is that using an indirect pointer <code>p</code> has two conceptual benefits:</p>
<ol>
<li>It allows us to interpret the linked list in a way that makes the <code>head</code> pointer an integral part the data structure. This eliminates the need for a special case to remove the first item.</li>
<li>It also allows us to evaluate the condition of the <code>while</code> loop without having to let go of the pointer that points to <code>target</code>. This allows us to modify the pointer that points to <code>target</code> and to get away with a single iterator as opposed to <code>prev</code> and <code>cur</code>.</li>
</ol>
<p>Let’s look each of these points in turn.</p>
<h3 id="Integrating-the-head-pointer"><a href="#Integrating-the-head-pointer" class="headerlink" title="Integrating the head pointer"></a>Integrating the <code>head</code> pointer</h3><p>The standard model interprets the linked list as a sequence of <code>list_item</code> instances. The beginning of the sequence can be accessed through a <code>head</code> pointer. This leads to the conceptual model illustrated in Figure 2 above. The <code>head</code> pointer is merely considered as a handle to access the start of the list. <code>prev</code> and <code>cur</code> are pointers of type <code>list_item *</code> and always point to an item or <code>NULL</code>.</p>
<p>The elegant implementation uses indirect addressing scheme that yields a different view on the data structure:</p>
<p><strong>注释：核心就是改变对链表数据结构的理解，将链表的最小单元理解为：前置指针 + (值+指针变量)成员，这样需要一个二级指针指向成员内的指针变量，链表也没有特殊性，每个成员一定有非空的前置指针和(值+指针变量)，如下图的蓝色框。</strong></p>
<p><strong>这个方法本质上是双指针的优化，只用一个二级指针就可以同时访问目标节点和前置的节点的指针变量，解决了单链表遍历过程中，找到目标节点后无法反向获得前置节点的指针变量的问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281920824.png" alt="image-20230328192017690"></p>
<p>Here, <code>p</code> is of type <code>list_item **</code> and holds the address of the pointer to the current list item. When we advance the pointer, we forward to the address of the pointer to the next list item.</p>
<p>In code, this translates to <code>p = &amp;(*p)-&gt;next</code>, meaning we</p>
<ol>
<li><code>(*p)</code>: dereference the address to the pointer to the current list item</li>
<li><code>-&gt;next</code>: dereference that pointer again and select the field that holds the address of the next list item</li>
<li><code>&amp;</code>: take the address of that address field (i.e. get a pointer to it)</li>
</ol>
<p>This corresponds to an interpretation of the data structure where the list is a a sequence of pointers to <code>list_item</code>s (cf. Figure 3).</p>
<h3 id="Maintaining-a-handle"><a href="#Maintaining-a-handle" class="headerlink" title="Maintaining a handle"></a>Maintaining a handle</h3><p>An additional benefit of that particular interpretation is that it supports editing the <code>next</code> pointer of the predecessor of the current item throughout the entire traversal.</p>
<p>With <code>p</code> holding the address of a pointer to a list item, the comparison in the search loop becomes</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (*p != target)</span><br></pre></td></tr></table></figure>

<p>The search loop will exit if <code>*p</code> equals <code>target</code>, and once it does, we are still able to modify <code>*p</code> since we hold its address <code>p</code>. Thus, despite iterating the loop until we hit <code>target</code>, we still maintain a handle (the address of the <code>next</code> field or the <code>head</code> pointer) that can be used to directly modify the pointer that points <em>to</em> the item.</p>
<p>This is the reason why we can modify the incoming pointer to an item to point to a different location using <code>*p = target-&gt;next</code> and why we do not need <code>prev</code> and <code>cur</code> pointers to traverse the list for item removal.</p>
<h2 id="Going-beyond"><a href="#Going-beyond" class="headerlink" title="Going beyond"></a>Going beyond</h2><p>It turns out that the idea behind <code>remove_elegant()</code> can be applied to yield a particularly concise implementation of another function in the list API:<code>insert_before()</code>, i.e. inserting a given item before another one.</p>
<h3 id="Inserting-before-existing-items"><a href="#Inserting-before-existing-items" class="headerlink" title="Inserting before existing items"></a>Inserting before existing items</h3><p>First, let’s add the following declaration to the list API in <code>list.h</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span>;</span><br></pre></td></tr></table></figure>

<p>The function will take a pointer to a list <code>l</code>, a pointer <code>before</code> to an item in that list and a pointer to a new list item <code>item</code> that the function will insert before <code>before</code>.</p>
<h3 id="Quick-refactor"><a href="#Quick-refactor" class="headerlink" title="Quick refactor"></a>Quick refactor</h3><p><strong>注释：单链表的删除节点和前向插入节点有共同的痛点：找到目标节点后无法反向获得前置节点的指针变量，此二级指针方法完美解决这类问题。</strong></p>
<p>Before we move on, we refactor the search loop into a separate function</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> list_item **<span class="title function_">find_indirect</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>and use that function in <code>remove_elegant()</code> like so</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, target);</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Implementing-insert-before"><a href="#Implementing-insert-before" class="headerlink" title="Implementing insert_before()"></a>Implementing <code>insert_before()</code></h3><p>Using <code>find_indirect()</code>, it is straightforward to implement <code>insert_before()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, before);</span><br><span class="line">        *p = item;</span><br><span class="line">        item-&gt;next = before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A particularly beautiful outcome is that the implementation has consistent semantics for the edge cases: if <code>before</code> points to the list head, the new item will be inserted at the beginning of the list, if <code>before</code> is <code>NULL</code> or invalid (i.e. the item does not exist in <code>l</code>), the new item will be appended at the end.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The premise of the more elegant solution for item deletion is a single, simple change: using an indirect <code>list_item **</code> pointer to iterate over the pointers to the list items.  Everything else flows from there: there is no need for a special case or branching and a single iterator is sufficient to find and remove the target item.<br>It also turns out that the same approach provides an elegant solution for item insertion in general and for insertion <em>before</em> an existing item in particular.</p>
<p>So, going back to Linus’ initial comment: is it good taste? Hard to say, but it’s certainly a different, creative and very elegant solution to a well-known CS task.</p>
]]></content>
      <categories>
        <category>github项目学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Github常用配置笔记</title>
    <url>/2020/08/27/Github%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="初始化git和github仓库"><a href="#初始化git和github仓库" class="headerlink" title="初始化git和github仓库"></a>初始化git和github仓库</h1><p>1.安装git</p>
<p>2.进入本地源码目录</p>
<pre><code>git init
</code></pre>
<p>会出现.git目录<br>首次需要配置github账户和邮箱</p>
<pre><code>git config --global user.name &quot;github注册的用户名&quot;
git config --global user.mail &quot;github注册的邮箱&quot;
</code></pre>
<p>3.添加远程仓库</p>
<p>在github网页新建仓库</p>
<pre><code>git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<p>.git&#x2F;config文件内容会出现remote等内容，ssh方式的url是git开头，http(s)方式是http(s)开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051116187.png" alt="image-20221205111653141"><br>如果是从别人拉过来的仓库，修改后新建仓库，上传遇到<code>fatal: remote origin already exists</code>问题，解决方法:</p>
<pre><code>git remote rm origin
git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<p>4.git add, commit, push三连</p>
<pre><code>git add -A
git commit -m &#39;first commit&#39;
git push -f --set-upstream origin master //首次提交
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117987.png" alt="image-20221205111703940"><br>完成以后远程可以看得到仓库的文件   </p>
<p>5.创建分支</p>
<p>如果已经有主线，在本地<code>git checkout branchname</code>, 远程创建分支，记录.git链接， 然后关联远程分支即可：</p>
<pre><code>git remote add origin https://github.com/*/*.git
</code></pre>
<p>然后推送</p>
<pre><code>git push origin branchname
</code></pre>
<h2 id="首次配置可能的问题："><a href="#首次配置可能的问题：" class="headerlink" title="首次配置可能的问题："></a>首次配置可能的问题：</h2><h3 id="push时有RSA-key错误"><a href="#push时有RSA-key错误" class="headerlink" title="push时有RSA key错误"></a>push时有RSA key错误</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117281.png" alt="image-20221205111713234"><br>因为Git使用SSH连接，而SSH第一次连接需要验证GitHub服务器的Key。确认GitHub的Key的指纹信息是否真的来自GitHub的服务器。解决办法是在本地生成key，配置到github服务器<br>（1)创建ssh key</p>
<pre><code>ls -al ~/.ssh
ssh-keygen -t rsa -C &quot;github用户名&quot;
cat ~/.ssh/id_rsa.pub
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117255.png" alt="image-20221205111721197"><br>在push三连过程可以设置global全局配置，以后默认push到github<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117055.png" alt="image-20221205111728996"></p>
<p>（2）配置ssh key到github<br>登陆github,头像-settings-new SSH,复制新生成的SSH配置到服务器<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117386.png" alt="image-20221205111737339"><br>（3）需要重新add origin新建仓库（或者网页上新建仓库)，再push，<code>git status</code>和<code>git log</code>查看分支和日志</p>
<h3 id="push时不能使用密码登陆"><a href="#push时不能使用密码登陆" class="headerlink" title="push时不能使用密码登陆"></a>push时不能使用密码登陆</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Support for password authentication was removed on August 13, 2021.</span><br></pre></td></tr></table></figure>

<p>使用personal token替代密码登陆：</p>
<p>Github setting -&gt; Developer setting -&gt; Personal access token -&gt; Generate a New Token (classic) -&gt; 设置不过时，所有权限勾上 -&gt; 首次会显示token字符，下次不会显示，记得备份token！-&gt; 再次输入账号密码时用token代替密码即可push</p>
<h3 id="git-clone有HTTP2错误"><a href="#git-clone有HTTP2错误" class="headerlink" title="git clone有HTTP2错误"></a>git clone有HTTP2错误</h3><p>错误码：RPC failed; curl 16 Error in the HTTP2 framing layer</p>
<p>解决办法：Git使用HTTP1.1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.version HTTP/1.1</span><br></pre></td></tr></table></figure>

<h1 id="Github-clone使用国内镜像"><a href="#Github-clone使用国内镜像" class="headerlink" title="Github clone使用国内镜像"></a>Github clone使用国内镜像</h1><p>国内搞开发最痛苦的就是限速+断开连接，github clone经常失败。推荐国内镜像服务作为代理进行git clone，将原git地址的github.com替换成代理地址即可。参考 <a href="https://zhuanlan.zhihu.com/p/463954956">无需代理直接加速各种 GitHub 资源拉取</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#git clone原地址</span><br><span class="line">$ git clone https://github.com/kubernetes/kubernetes.git</span><br><span class="line"></span><br><span class="line">#手动配置代理地址，任选其一能clone成功即可</span><br><span class="line">$ git clone https://github.com.cnpmjs.org/kubernetes/kubernetes.git</span><br><span class="line">$ git clone https://hub.fastgit.org/kubernetes/kubernetes.git</span><br><span class="line">$ git clone https://gitclone.com/github.com/kubernetes/kubernetes.git</span><br><span class="line"></span><br><span class="line">#配置git自动使用代理，配置以后可以用git clone原地址，自动走代理</span><br><span class="line">git config --global url.&quot;https://hub.fastgit.org&quot;.insteadOf https://github.com</span><br><span class="line">#取消自动代理</span><br><span class="line">$ git config --global --unset url.https://github.com/.insteadof</span><br></pre></td></tr></table></figure>

<p>使用国内镜像并不一定能解决所有clone问题，有的recursive clone对依赖包有版本要求，国内镜像版本不匹配导致clone fail，此时不能使用国内镜像。</p>
<p>解决版本：下载release版本的zip包，绕开git clone操作。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab笔记：CentOS7部署Gitlab服务</title>
    <url>/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>阿里云ECS, CentOS7, RAM 4G</p>
<h1 id="安装Gitlab"><a href="#安装Gitlab" class="headerlink" title="安装Gitlab"></a>安装Gitlab</h1><p>1.安装ssh并配置</p>
<pre><code>#安装
sudo yum install -y curl policycoreutils-python openssh-server
#配置开机启动
sudo systemctl enable sshd
#启动服务
sudo systemctl start sshd
</code></pre>
<p>2.配置防火墙</p>
<pre><code>#启动防火墙
service firewalld start
#添加http服务到firewalld,pemmanent表示永久生效
sudo firewall-cmd --permanent --add-service=http
#重启防火墙
sudo systemctl reload firewalld
</code></pre>
<p>3.安装gitlab</p>
<pre><code>#下载安装脚本
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash
#安装
yum install -y gitlab-ee
</code></pre>
<p>4.配置gitlab</p>
<pre><code>#gitlab配置文件
vim /etc/gitlab/gitlab.rb
#修改以下内容为主机ip和未使用的端口，否则使用默认端口8080
external_url &#39;http://47.100.221.149:9030&#39;
</code></pre>
<p>5.配置生效并重启gitlab</p>
<pre><code>#配置生效，改了配置需要运行
gitlab-ctl reconfigure
#重启服务，没改配置直接重启
gitlab-ctl restart
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061444445.png" alt="image-20221206144455394"><br>似乎服务都正常启动了，实际上可能有各种问题，参考问题记录</p>
<h1 id="问题Debug记录"><a href="#问题Debug记录" class="headerlink" title="问题Debug记录"></a>问题Debug记录</h1><p>按以上步骤配置好后，访问主机ip:端口，直接弹出502服务端错误<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061445877.png" alt="image-20221206144542817"></p>
<h2 id="配置文件权限问题"><a href="#配置文件权限问题" class="headerlink" title="配置文件权限问题?"></a>配置文件权限问题?</h2><p>配置文件生效命令<code>gitlab-ctl reconfigure</code>做了以下事情：</p>
<ul>
<li>配置设置写到gitlab服务直接调用的文件</li>
</ul>
<p>实际生效的配置文件：</p>
<pre><code>vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446719.png" alt="image-20221206144606669"><br>可见配置被自动拷贝到此处，gitlab相关服务读取的是这里的配置项</p>
<ul>
<li>生成服务相关临时文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446110.png" alt="image-20221206144619066"></p>
<p>原因：gitlab服务的配置文件在reconfigure时生成于&#x2F;var&#x2F;log&#x2F;gitlab，这个文件目录默认权限不够，有些子服务不能正常运行。</p>
<p>解决方法：</p>
<pre><code>chmod -R 777 /var/log/gitlab
</code></pre>
<p>restart服务，网页即可正常访问gitlab，如果恢复该目录755权限，重启服务会502</p>
<p>每次重新配置，<code>gitlab-ctl reconfigure</code>似乎会删除该目录再重新写入<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446151.png" alt="image-20221206144636079"></p>
<p>因此每次gitlab-ctl reconfigure之后都要<code>chmod 777</code>改此目录权限</p>
<h2 id="还有502问题"><a href="#还有502问题" class="headerlink" title="还有502问题?"></a>还有502问题?</h2><h3 id="检查阿里云端口"><a href="#检查阿里云端口" class="headerlink" title="检查阿里云端口"></a>检查阿里云端口</h3><p>首先确保主机ip是公网能访问的，不是内网ip<br>其次看端口是否禁用。在阿里云ECS的安全组策略中查看端口是否允许TCP输入输出<br>我把所有端口（1~65535）全部打开了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446454.png" alt="image-20221206144656411"></p>
<h3 id="检查前向端口冲突"><a href="#检查前向端口冲突" class="headerlink" title="检查前向端口冲突"></a>检查前向端口冲突</h3><p>gitlab配置文件的external_url就包含前向端口</p>
<pre><code>netstat -nlp | grep 9030 (我的gitlab前向端口)
</code></pre>
<p>显示的是nginx服务端口，因为gitlab默认被nginx反向代理了，说明gitlab的代理服务确实占用9030。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449545.png" alt="image-20221206144927508"></p>
<h3 id="检查子服务的端口"><a href="#检查子服务的端口" class="headerlink" title="检查子服务的端口"></a>检查子服务的端口</h3><p>注意gitlab不只有一个服务，默认配置只设置了前向端口（nginx代理端口），而子服务都没配置端口，默认用了8080，如果有其他服务已经占用8080，可能子服务起不来<br>例如unicorn子服务：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449220.png" alt="image-20221206144946178"></p>
<p>查看子服务状态</p>
<pre><code>gitlab-ctl status
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449573.png" alt="image-20221206144958510"></p>
<p>如果本地已有8080的服务，最好杀掉或换其他端口，否则要手动配置gitlab子服务端口</p>
<pre><code>unicorn[&#39;port&#39;] = 9032 （随便一个未使用端口）
gitlab_workhorse[&#39;auth_backend&#39;] = &quot;http://localhost:9032&quot;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450285.png" alt="image-20221206145014236"></p>
<h3 id="检查内存资源不足"><a href="#检查内存资源不足" class="headerlink" title="检查内存资源不足"></a>检查内存资源不足</h3><p>阿里云2G以下RAM可能会有因内存不足，导致服务不能正常启动。<br>使用swap交换分区，避免内存不足的可能性。swap分区可以把部分内存分页存储到磁盘，变相“扩大”内存</p>
<pre><code>#查看现有swap分区，若未分配大小为0
cat /proc/swaps
#创建swap文件，大小4G，挂载到/mnt。交换分区可以使用真正的分区，或者以文件形式的分区
dd if=/dev/zero of=/mnt/swap bs=512 count=8388616
#使之成为swap分区
mkswap /mnt/swap
#修改swap分区配置
cat /proc/sys/vm/swappiness
sysctl -w vm.swappiness=60
#swap分区配置永久生效
vim /etc/sysctl.conf
修改vm.swappiness=60
#启动分区
swapon /mnt/swap
echo “/mnt/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab
#停用分区
swapoff /mnt/swap
swapoff -a &gt; /dev/null
</code></pre>
<p>启用分区后运行gitlab，发现已经有一部分数据转移到了swap文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450437.png" alt="image-20221206145023389"></p>
<h1 id="ssh访问配置"><a href="#ssh访问配置" class="headerlink" title="ssh访问配置"></a>ssh访问配置</h1><p>通过ssh上传下载，需要建立ssh key</p>
<pre><code>ssh-keygen   #一路回车
</code></pre>
<p>若创建成功，查看生成的公钥：</p>
<pre><code>cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yXXXXXXXX
</code></pre>
<p>添加公钥至gitlab</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450049.png" alt="image-20221206145031977"></p>
<h1 id="初始化git项目"><a href="#初始化git项目" class="headerlink" title="初始化git项目"></a>初始化git项目</h1><p>配置git全局用户名，邮箱</p>
<pre><code>git config --global user.name &quot;YOUR NAME&quot;
git config --global user.email &quot;YOUR EMAIL@xxx.com&quot;
</code></pre>
<p>初始化git仓库<br>可以通过xftp上传项目文件夹到gitlab服务器，再到目录内初始化.git仓库。</p>
<pre><code>cd project_folder (项目文件夹)
git init
git remote add origin git@YOUR_IP:YOUR_NAME/project_folder.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
</code></pre>
<p>这样在网页上可看到gitlab有首次commit的文件，后续也可以顺利提交和下载。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Git多人协作下的换行符问题</title>
    <url>/2020/09/06/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E4%B8%8B%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目文件中有如下类型文件：</p>
<pre><code>Makefile, .sh, .bat, .cfg, .exe
</code></pre>
<p>源码用git管理，客户端用cygwin实现windows内的linux环境</p>
<p>问题：如何解决git多人协作下的linux、windows换行符差异问题？</p>
<p>(1)什么是换行符<br>LF：”\n”，Linux的换行符, 只包含“换行”；<br>CRLF：”\r\n”，Windows的换行符，包含“回车+换行”;</p>
<p>(2)不同换行符带来什么问题<br>用git管理代码，必定有远程端和本地端两个仓库，两端的操作系统不同，换行符可能有差异;</p>
<p>多人协作时，本地端可能有linux环境和windows, 如果所有人都是linux就不存在换行符差异的问题；如果有windows和linux就有该问题;<br>例如A上传了Linux换行符LF的代码到远程，B 本地环境是windows, B git pull下来，其git-config设置了自动转换成本地换行，将代码换行全成了CRLF，B上传后，远程仓库变成CRLF换行。此时A git diff查看，所有代码都有换行差异，扰乱真正的代码diff。</p>
<p>不仅是影响git diff， 换行差异还影响脚本执行</p>
<ul>
<li>例如LF换行的.sh，git pull到windows环境后换行转换成CRLF, 导致sh无法正常执行；</li>
<li>.bat调用.exe读取.cfg内的一行，.exe是windows程序，其readline方法只能识别CRLF换行，无法读取LF换行的.cfg文件内容</li>
</ul>
<h1 id="git的自动换行符转换配置"><a href="#git的自动换行符转换配置" class="headerlink" title="git的自动换行符转换配置"></a>git的自动换行符转换配置</h1><p>参考：<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git">core.autocrlf</a></p>
<p>假如你正在 Windows 上写程序，而其他人用的是其他系统（或相反），你可能会遇到 CRLF 问题。 这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 macOS 和 Linux 只使用换行（LF）一个字符。 虽然这是小问题，但它会极大地扰乱跨平台协作。许多 Windows 上的编辑器会悄悄把行尾的换行字符转换成回车和换行， 或在用户按下 Enter 键时，插入回车和换行两个字符。</p>
<p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。 你可以用 core.autocrlf 来打开此项功能。 如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<pre><code>$ git config --global core.autocrlf true
</code></pre>
<p>如果使用以换行作为行结束符的 Linux 或 macOS，你不需要 Git 在检出文件时进行自动的转换； 然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p>
<pre><code>$ git config --global core.autocrlf input
</code></pre>
<p>这样在 Windows 上的检出文件中会保留回车和换行，而在 macOS 和 Linux 上，以及版本库中会保留换行。</p>
<p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中：</p>
<pre><code>$ git config --global core.autocrlf false
</code></pre>
<p><strong>使用<code>git config --global core.autocrlf input</code>就可以做到windows的CRLF换行自动转换成LF换行存储在git远程仓库，且git pull&#x2F;clone到本地时维持LF换行，不影响.sh等linux shell script执行。</strong></p>
<h1 id="手动换行符转换"><a href="#手动换行符转换" class="headerlink" title="手动换行符转换"></a>手动换行符转换</h1><ul>
<li><p>dos2unix FilePath</p>
</li>
<li><p>unix2dos FilePath</p>
</li>
<li><p>windows2linux</p>
<p> sed -i ‘s&#x2F;.$&#x2F;&#x2F;‘ FilePath</p>
</li>
<li><p>linux2windows</p>
<p> sed -i ‘s&#x2F;$&#x2F;\r&#x2F;‘ FilePath</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作笔记</title>
    <url>/2020/12/03/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="拉取和同步"><a href="#拉取和同步" class="headerlink" title="拉取和同步"></a>拉取和同步</h2><pre><code>git clone http://xxx.xxx.git //http方式, 从远程clone仓库
git pull //拉取远程分支
git branch //查看本地
git branch -a //查看远程和本地
git checkout xxxbranch //本地切到某分支
git checkout xxx/xxx //仅拉取部分目录或文件
</code></pre>
<h2 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a>推送到远程</h2><pre><code>git add -A //推送所有修改到本地仓库
git commit -m &quot;change logs&quot; //提交到本地仓库（记录修改信息）
git push //推送本地分支到远程的同名分支，需要先关联
git push origin &lt;本地分支名&gt; //推送本地分支到远程同名分支
git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; //推送本地分支到远程指定分支
</code></pre>
<h2 id="加tag-x2F-删tag"><a href="#加tag-x2F-删tag" class="headerlink" title="加tag&#x2F;删tag"></a>加tag&#x2F;删tag</h2><pre><code>git tag -a TAGNAME -m &quot;TAG LOG&quot; //加tag
git push origin TAGNAME //推送tag到远程
git tag -d TAGNAME //删除本地tag
git push origin :refs/tags/TAGNAME //删除远程tag
</code></pre>
<h2 id="创建-x2F-删除-x2F-修改分支"><a href="#创建-x2F-删除-x2F-修改分支" class="headerlink" title="创建&#x2F;删除&#x2F;修改分支"></a>创建&#x2F;删除&#x2F;修改分支</h2><p>创建分支并关联远程</p>
<pre><code>git checkout -b BRANCH_NAME //本地创建分支
git push origin BRANCH_NAME //推送到远程
git push --set-upstream origin BRANCH_NAME //关联远程，便于以后分支pull/push
</code></pre>
<p>删除本地分支    </p>
<pre><code>git branch -d branch_name
git branch -D branch_name //强制删除
</code></pre>
<p>删除远程分支</p>
<pre><code>git push origin -d branch_name
</code></pre>
<p>分支重命名(本地)</p>
<pre><code>git branch -m OLD_NAME NEW_NAME
</code></pre>
<h2 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h2><p>可以用<code>git diff --help</code>直接查看git diff的Manual Page</p>
<pre><code>git diff COMMIT_ID //比较本地和某commit_id的内容
git diff ID1 ID2 //比较两个提交的内容，比较新增时，旧版本在前，新版本在后
git diff &lt;path of file&gt; //比较本地某文件的内容
git diff --name-only ID1 ID2 //只显示有差异的文件名列表
git diff &lt;commit&gt;..&lt;commit&gt; [&lt;path&gt;…] //比较两个提交中指定文件名或者路径的差异
</code></pre>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre><code>git reset --hard HEAD^ //回退到上个版本
git reset --hard HEAD^^ //回退到上上个版本
git reset --hard COMMIT_ID //回退到指定提交
git push -f //强制提交，覆盖远程，使远程也回退
git push origin master -f //强制推送到远程的master分支
</code></pre>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>两个分支A和B，要把分支B的所有提交合并到A分支上</p>
<pre><code>git checkout &lt;branch A&gt; //切到待合并分支A
git merge &lt;branch B&gt; //拉取分支B，合并到当前分支A
git merge &lt;branch B&gt;  --squash //合并分支，将B的多个提交融合成一个再合并到A，而不是B的所有提交记录都照搬到A（这个更常用）
git merge --abort //终止合并
</code></pre>
<p>如果有<code>merge conflict</code>,手动修改冲突文件-&gt;保存文件-&gt;<code>git add -A</code>提交修改-&gt;<code>git commit -m &quot;xxx&quot;</code>提交该合并</p>
<p>如果本地仓库已经处于待merge状态，又想取消merge,同步成远程仓库状态，只需要reset本地仓库到当前commit-id</p>
<pre><code>git reset --hard HEAD
</code></pre>
<p>也可以reset到指定commit-id:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog &amp;&amp; git reset --hard commit-id</span><br></pre></td></tr></table></figure>

<h2 id="合并提交"><a href="#合并提交" class="headerlink" title="合并提交"></a>合并提交</h2><h3 id="合并当前提交"><a href="#合并当前提交" class="headerlink" title="合并当前提交"></a>合并当前提交</h3><p>如果当前修改还未提交, 想合并到最近的一次提交里，例如最近提交有个错误，可以用<code>--amend</code>修订提交</p>
<pre><code>git add -A
git commit --amend
git push -f //amend后通常强制推送，因为没有新增commit
</code></pre>
<h3 id="合并历史提交"><a href="#合并历史提交" class="headerlink" title="合并历史提交"></a>合并历史提交</h3><p>有时同一个功能分多次提交，提交过于频繁，需要合并成一个提交。<br>如下有三次提交</p>
<pre><code>$git log
commit_3: xxxxx
    message_3 ....
commit_2: xxxxx
    message_2 ....
commit_1: xxxxx
    message_1 ....
</code></pre>
<p>现在想把commit_3 和 commit_2合并成一个commit.</p>
<pre><code>git rebase -i commit_1 //重定位到要合并的前一个提交
</code></pre>
<p>进入commit信息编辑模式：</p>
<pre><code>pick commit_2 message_2...
pick commit_3 message_3...
</code></pre>
<p>将要合并的commit_3前的属性<code>pick</code>（选用）改为<code>squash</code>（压扁），<code>wq</code>保存，进入当前合并commit的信息提交界面，再次<code>wq</code>保存, 查看合并后提交记录如下：</p>
<pre><code>$git log
commit_4: xxxxx
    message_3 ....
    message_2 ....
commit_1: xxxxx
    message_1 ....
</code></pre>
<p>两次提交已合成一次（新的）提交</p>
<h1 id="多人提交的冲突解决办法"><a href="#多人提交的冲突解决办法" class="headerlink" title="多人提交的冲突解决办法"></a>多人提交的冲突解决办法</h1><p>A和B同时开发某项目的同一个分支，A拉取最新版本1.0后，在本地新增功能，此时B也在1.0上修改并提交到了新版本1.1到远程仓库。A在B提交之后再提交，发现自己本地的修改已是旧版本，无法直接提交，如下图是A的add,commit,push三连的结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051005366.png" alt="1631249531971_115"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051006842.png" alt="image-20221205100655798"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051007268.png" alt="image-20221205100726224"></p>
<h3 id="手动解决conflict"><a href="#手动解决conflict" class="headerlink" title="手动解决conflict"></a>手动解决conflict</h3><p><code>git pull</code> 拉取远程仓库最新版本，此时有两种情况</p>
<ul>
<li>代码有冲突，需手动修改冲突区域的代码块，二选一，然后重新add-commit-push三连提交</li>
<li>无冲突，pull代码会自动合并，直接重新三连提交即可</li>
</ul>
<p>以下是有冲突的情况<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051008610.png" alt="image-20221205100836563"></p>
<p>找到冲突源码，冲突的符号定义如下：</p>
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt; HEAD</code>：当前本地的代码块</li>
<li><code>======</code>：分割冲突块</li>
<li><code>&gt;&gt;&gt;&gt;&gt;&gt;b699a7fc</code>：远程最新hash版本号的代码块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051008970.png" alt="image-20221205100855921"></p>
<p>修改方法：先拷贝冲突关键语句，再删除所有冲突域符号，最后只保留如下代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051019814.png" alt="image-20221205101900769"></p>
<p>修改完后，<code>git add, git commit, git push</code>，成功提交<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051020311.png" alt="image-20221205102021265"></p>
<p>查看提交后版本：<code>git log</code></p>
<h3 id="修改某次提交的commit信息"><a href="#修改某次提交的commit信息" class="headerlink" title="修改某次提交的commit信息"></a>修改某次提交的commit信息</h3><p>有时需要修改commit信息便于区分哪个是解决冲突后的提交<br>解决方案：</p>
<ul>
<li>修改最新的commit，只需要amend修改commit信息后，再push</li>
<li>修改历史的commit，需要先rebase修改属性为edit后，再commit –amend</li>
</ul>
<p>下面讲修改历史commit<br>如下图，想修改9877的commit信息<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051023197.png" alt="image-20221205102348131"></p>
<p>先rebase到之前的commit<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051024479.png" alt="image-20221205102432433"><br>显示其后的版本属性如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051024531.png" alt="image-20221205102447476"><br>修改9877的属性为edit(待编辑模式)，将原始commit改成如下内容,<code>:wq</code>保存:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051026868.png" alt="image-20221205102658821"></p>
<p>然后<code>commit --amend, rebase --continue</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051027201.png" alt="image-20221205102751155"><br>再查看下git og修改成功<br>最后<code>git push</code>同步到远程仓库</p>
<h1 id="从另一个分支拉取指定的几个commit内容"><a href="#从另一个分支拉取指定的几个commit内容" class="headerlink" title="从另一个分支拉取指定的几个commit内容"></a>从另一个分支拉取指定的几个commit内容</h1><p>A和B都在git的master分支提交代码，一天发现master某个版本有问题，回退n各版本都找不到是谁提交引起的问题，由于master还要作稳定测试等其他用途，决定先回退master分支到较早的指定版本，而master最新版和稳定版之间提交的内容，分别由各自A和B“认领”，拉取master上自己提交的功能到自己的分支，debug好以后在合并回master。<br>需求：<br>如何在开发者分支上拉取master分支的指定几个commit的内容，注意不是某个commit以前的内容，是commit内的内容？</p>
<h2 id="创建自己分支，回退master"><a href="#创建自己分支，回退master" class="headerlink" title="创建自己分支，回退master"></a>创建自己分支，回退master</h2><p>首先切到master分支上，创建一个自己的分支thomas，自己分支是master的拷贝</p>
<pre><code>git checkout master //当前在那个分支，决定创建分支的内容
git checkout -b thomas //做两件事：在本地创建thomas分支，内容和master一样；切到thomas分支
git push --set-upstream origin thomas //推送分支到远程，这步很容易漏掉
git branch //查看当前在哪个分支
git branch -a //查看所有分支
</code></pre>
<p>以上操作完成后，自己分支就创建好了，注意动作只影响到本地仓库的.git文件，要同步远程仓库还要push到远程<br>下面备份master, 再回退master</p>
<pre><code>git checkout master
git checkout -b master_backup //先备份master,上面有自己分支要拉取的内容
git checkout master //切到master,准备回退
git reset --hard COMMIT_ID //回退到稳定版本commit_id
git push -f //由于是回退，提交比远程的还早，一般需要强制提交，这个操作也会把本地的.git修改一同提交到远程
</code></pre>
<p>这样就有三个分支：</p>
<pre><code>master: 包含稳定版本的旧代码
master_backup: master的备份，包含稳定版和之后的A、B的一些提交
thomas: 开发者A的个人分支，现在和master稳定版完全一样
</code></pre>
<p>下面只需要从master_backup拉取自己相关的提交到thomas分支即可。</p>
<h2 id="cherry-pick拉取指定commit"><a href="#cherry-pick拉取指定commit" class="headerlink" title="cherry-pick拉取指定commit"></a>cherry-pick拉取指定commit</h2><p>先把要拉取的commit id存起来：</p>
<pre><code>git checkout master_backup
git log &gt; ../master_backup.log
</code></pre>
<p>截取commit log片段如图<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051038438.png" alt="image-20221205103857374"></p>
<p>切到thomas分支，拉取master_backup的commit</p>
<pre><code>git checkout thomas
git cherry-pick 3d6b3be
</code></pre>
<p>这种方法只拉了一个commit, 更好的方式是按功能，一次拉多个commit,甚至一次把所有的commit都拉完。<br>cherry-pick支持多个pick一步到位<br>例如git log如下</p>
<pre><code>commit4 id4
commit3 id3
commit2 id2
commit1 id1
</code></pre>
<p>离散拉取：只拉取id1和id4：</p>
<pre><code>git cherry-pick id1 id4
</code></pre>
<p>！注意，提交顺序很重要，旧版本写在前新版本写在后<br>如果是区间拉取,即全部的id1，id2, id3，id4</p>
<pre><code>git cherry-pick id1..id4 //加两个点即为区间拉取
</code></pre>
<p>为了验证是不是真的拉取了多个版本，可以<code>git diff --name-only id1 id4</code>看下拉取后的修改哪些文件，对比被拉取分支的修改，如果一致，说明确实拉取多个commit<br>对于上图的commit，建议按功能多次cherry-pick并commit+push，便于后续debug。</p>
<h2 id="cherry-pick的冲突问题"><a href="#cherry-pick的冲突问题" class="headerlink" title="cherry-pick的冲突问题"></a>cherry-pick的冲突问题</h2><p>cherry-pick也是合并，只要是合并代码，就可能有冲突<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051039238.png" alt="image-20221205103926181"><br>合并单个commit,使用使用常规的冲突解决办法即可：</p>
<ul>
<li>到源码改冲突， <code>&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;</code>三个标记之间代码块二选一</li>
<li><code>git status</code>查看哪些待提交</li>
<li><code>git add -A</code>提交修改后的源码到本地.git</li>
</ul>
<h3 id="单个提交的冲突解决"><a href="#单个提交的冲突解决" class="headerlink" title="单个提交的冲突解决"></a>单个提交的冲突解决</h3><p>由于是从其他分支的commit id合并到当前分支（HEAD）,可以不加考虑的删掉<code>&lt;&lt;&lt;&lt;HEAD</code>和<code>====</code>之间的内容，采用<code>====</code>和<code>commit_id</code>之间的内容，随后删掉三个标记即可。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051039681.png" alt="image-20221205103951579"><br>有可能出现冲突代码块有重叠区的情况</p>
<pre><code>&lt;&lt;&lt;&lt; HEAD
code 1
=====
&lt;&lt;&lt;&lt; commit_id 1
code 2
&gt;&gt;&gt;&gt; commit_id 2
code 3
=====
code 4
&gt;&gt;&gt;&gt; commit_id 3
</code></pre>
<p>只要确定一个原则：&lt;&lt;&lt;&lt;是冲突块的起始点，&#x3D;&#x3D;&#x3D;&#x3D;是分界，&gt;&gt;&gt;&gt;是终止点，分两步删代码就可以了。</p>
<h3 id="多个提交的冲突解决："><a href="#多个提交的冲突解决：" class="headerlink" title="多个提交的冲突解决："></a>多个提交的冲突解决：</h3><p>如果是cherry-pick多个commit，冲突的解决方法就不一样了。<br>其区别在于，多个commit_id的cherry-pick，一旦遇到冲突，就会停下pick,需要手动解决冲突后，用<code>cherry-pick --continue</code>继续接下来的commit合并，直到由遇到冲突，再次手动解决。也就是说冲突会阻塞多个commit的cherry-pick，它不会一次性合并所有commit,让你一次性解决冲突。具体流程如下：</p>
<ul>
<li><code>cherry-pick id1 id2 id3 id4 .... idn</code></li>
<li>冲突报错，到源码手动解决</li>
<li><code>git add -A</code> 添加解决冲突后的文件到.git</li>
<li><code>cherry-pick --continue</code> 继续后面的合并,cherry-pick成功会自动提交commit信息</li>
<li>再遇到冲突，再次解决….</li>
<li>所有id1 … idn全部pick完成</li>
</ul>
<p>批量cherry-pick每次成功后都会有一次commit信息，有时候会报错，需要手动commit之后再continue</p>
<h3 id="特殊的冲突情况"><a href="#特殊的冲突情况" class="headerlink" title="特殊的冲突情况"></a>特殊的冲突情况</h3><p>提示有一个commit是合并的提交，即这个提交是两个分支的交汇，cherry-pick不知道以哪个分支为准<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040545.png" alt="image-20221205104005491"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040453.png" alt="image-20221205104017399"></p>
<p>如何解决：cherry-pick添加-m 1选项</p>
<pre><code>For example, if your commit tree is like below:

- A - D - E - F -   master
   \     /
    B - C           branch one
then git cherry-pick E will produce the issue you faced.

git cherry-pick E -m 1 means using D-E, while git cherry-pick E -m 2 means using B-C-E
</code></pre>
<p>例如选择cherry-pick commid_id -m 1, 结果如下，可手动解决冲突了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040782.png" alt="image-20221205104053730"><br>注意有merge的commit,会包含其他人的更新，如果只是pick自己的代码，不需要pick带merge的commit.</p>
<h1 id="跨仓库合并代码"><a href="#跨仓库合并代码" class="headerlink" title="跨仓库合并代码"></a>跨仓库合并代码</h1><p>假设某公司windows driver主线仓库为storport, 为了某产品定制的driver仓库为gg8, 现在gg8的所有feature已充分测试，准备合并到主线仓库storport, 这两个仓库的代码差异非常大，维护者众多，如何处理？</p>
<p>首先划分代码各部分归谁负责：<br>每个人用git，找出其在gg8仓库的个人修改，用winmerge手动合并到主线仓库storport<br>那么具体如何高效，可靠的合并：</p>
<p>git部分：<br>用git只找差异部分，具体操作：</p>
<pre><code>git diff commit_a commit_b //找所有文件+代码差异
git diff commit_a commit_b --stat //只显示有差异的文件名，这个信息对应winmerge手动合并很重要
git diff commit_a commit_b 指定文件路径 //只显示指定文件的内容差异，这个信息对应winmerge手动合并很重要
</code></pre>
<p>winmerge部分：<br>winmerge可以比较两个仓库所有差异，但是有些差异可能不需要合并，例如换行，修改时间等。总之winmerge的差异有很多“误报”<br>如果只一个个打开有差异的文件去比效率太低，需要借助git定位到哪些该开发者负责的文件有改变，以及文件内哪些代码是该开发者改变的。</p>
<p>找出某开发者A的提交改了哪些文件：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046241.png" alt="image-20221205104623191"></p>
<p>找出具体代码：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046320.png"></p>
<p>winmerge直接合并：<br>只是一句打印差异，但是如果不用git先定位，要从左侧差异栏找出此代码，相当困难<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046886.png" alt="image-20221205104642794"></p>
<p>这样，开发者A在代码合并过程中，完全不受其他开发者B, C的差异代码干扰</p>
<h1 id="强制覆盖本地代码"><a href="#强制覆盖本地代码" class="headerlink" title="强制覆盖本地代码"></a>强制覆盖本地代码</h1><p>git本地代码有时checkout到旧版本代码，想回到最新版本时，直接pull无法成功，且强制pull也不行。有以下两种方式解决：</p>
<h2 id="重新克隆"><a href="#重新克隆" class="headerlink" title="重新克隆"></a>重新克隆</h2><p>最简单是直接删掉本地项目，再重新<code>git clone</code></p>
<h2 id="fetch覆盖"><a href="#fetch覆盖" class="headerlink" title="fetch覆盖"></a>fetch覆盖</h2><pre><code>git fetch --all //拉取远程repo所有branch到本地，但不合并到本地repo
git reset --hard origin/master //本地repo强制同步远程repo的master分支
git pull -f //强制拉取远程repo最新代码
</code></pre>
<p>注意，如果本地旧版本代码有xxx.c，而远程最新代码没这个文件，本地需要手动删掉这个文件。因为以上操作不会删除本地文件，只会拉取本地没有的，或者覆盖不同的文件到本地。为了确保旧版本多出的文件删除，直接删除目录下除了<code>.git</code>以外的所有项目文件，再<code>fetch,reset,pull</code></p>
<h1 id="将本地未初始化git的项目上传到远程已初始化的git仓库"><a href="#将本地未初始化git的项目上传到远程已初始化的git仓库" class="headerlink" title="将本地未初始化git的项目上传到远程已初始化的git仓库"></a>将本地未初始化git的项目上传到远程已初始化的git仓库</h1><p>有一些项目代码是基于开源的庞大项目基础上开发，例如UEFI EDK2, Linux kernel.</p>
<p>项目开发时，可能基于不同的开源项目版本，例如：</p>
<p>远程git仓库是EDK2版本A0 + 自定义功能B0；本地的新功能是基于EDK2版本A1 + 自定义功能B1，且本地项目还没有初始化git。这种情况如何将本地项目直接上传到远程已有的项目上面去？</p>
<p>1.首先在本地建立git仓库</p>
<p>在本地新项目目录初始化git仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit信息&quot;</span><br></pre></td></tr></table></figure>

<p>2.将本地git仓库关联到远程已有的git仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin http://远程仓库地址.git</span><br></pre></td></tr></table></figure>

<p>3.拉取远程仓库到本地 (如果远程仓库为空不需要此步)</p>
<p>注意<code>--allow-unrelated-histories</code>是忽略本地项目和远程项目没有历史关联的关键参数，否则不能pull成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<p>合并代码通常会有冲突，手动解决冲突后再<code>git add, git commit -m &quot;fix merge conflict&quot;</code></p>
<p>4.最后推送本地仓库到远程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<h1 id="链接外部repo作为子模块"><a href="#链接外部repo作为子模块" class="headerlink" title="链接外部repo作为子模块"></a>链接外部repo作为子模块</h1><p>在github的项目仓库中，通常看到如下有@符号的外部仓库链接，点进去可能打开其他的项目仓库。这种外部仓库相当于当前项目仓库的子模块。</p>
<p>类似于Linux的软链接，子模块方式可以链接到其他项目仓库，并自动同步其他仓库最新的代码。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212091106114.png" alt="image-20221209110659056"></p>
<p>1.如何创建外部repo的链接:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add &quot;外部repo地址.git&quot; 外部repo文件夹名</span><br></pre></td></tr></table></figure>

<p>本地就clone了外部仓库到外部repo文件夹名中, 提交本项目和正常的提交流程相同</p>
<p>2.如何clone带外部repo的项目：</p>
<p>git clone 的时候需要加上<code>--recursive</code>，否则外部repo文件夹是空文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --recursive &quot;项目地址.git&quot;</span><br></pre></td></tr></table></figure>

<p>如果已经忘记加<code>--recursive</code>，可以手动初始化子模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h1 id="Git的常用配置"><a href="#Git的常用配置" class="headerlink" title="Git的常用配置"></a>Git的常用配置</h1><h2 id="配置多组用户信息"><a href="#配置多组用户信息" class="headerlink" title="配置多组用户信息"></a>配置多组用户信息</h2><p>git上传代码时会提交用户信息，包括姓名和邮箱，这个配置是本地的git配置文件决定。</p>
<p>如果要按项目配置多组用户信息，例如公司的代码以公司邮箱提交到公司内部的gitlab，个人项目的代码以个人邮箱提交到github，如何配置？</p>
<p>下面分别介绍全局配置、按项目配置和按文件目录配置三种git配置方法。</p>
<p>（1）git配置文件的位置</p>
<p>git配置文件为.gitconfig。对于windows, 一般在’C:\Users\用户名‘目录下，可以用everything查找.gitconfig，对于Linux, 一般在home目录。本文以windows为例。</p>
<p>（2）全局配置</p>
<p>.gitconfig里面默认的user字段就是全局的配置，首次使用git提交会提示用户输入此信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = youName</span><br><span class="line">    email = youEmail@example.com</span><br></pre></td></tr></table></figure>

<p>全局配置的查看和修改使用<code>--global</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name                           // 查询全局用户名</span><br><span class="line">git config --global user.name youName                   // 修改全局用户名</span><br><span class="line">git config --global user.email                          // 查询全局邮箱</span><br><span class="line">git config --global user.email youEmail@example.com     // 修改全局邮箱</span><br></pre></td></tr></table></figure>

<p>（3）对某个git项目自定义配置</p>
<p>这种方法的作用域只是某一个git项目，用的比较少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name                           // 查询项目用户名</span><br><span class="line">git config user.name youName                   // 修改项目用户名</span><br><span class="line">git config user.email                          // 查询项目邮箱</span><br><span class="line">git config user.email youEmail@example.com     // 修改项目邮箱</span><br></pre></td></tr></table></figure>

<p>（3）对某个路径下的所有git项目自定义配置</p>
<p>git的<code>Conditional Includes</code>可以针对文件夹配置，在.gitconfig添加如下格式的includeIf字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:path/to/you/gitdir/&quot;]</span><br><span class="line">    path = ~/.gitconfig_self</span><br></pre></td></tr></table></figure>

<p>其中path&#x2F;to&#x2F;you&#x2F;gitdir&#x2F;是要自定义配置的路径，可以包含很多git项目。注意尾部必须要加&#x2F;</p>
<p>.gitconfig_self是自定义配置的gitconfig文件，在里面指定[user]字段</p>
<p>例如我的自定义路径是F:&#x2F;github-my， 自定义配置文件.gitconfig_mygithub，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:F:/github-my/&quot;]</span><br><span class="line">    path = C:/Users/thomas.hu/.gitconfig_mygithub</span><br></pre></td></tr></table></figure>

<p>注意windows上不能直接右键创建只有后缀名的文件，会提示“必须键入文件名”。</p>
<p>使用CMD或Powershell的命令行创建.gitconfig_mygithub：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\Users\thomas.hu</span><br><span class="line">echo &gt; .gitconfig_mygithub</span><br></pre></td></tr></table></figure>

<p>.gitconfig_mygithub定义我个人项目的信息，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = cursorhu</span><br><span class="line">    email = 2449055512@qq.com</span><br></pre></td></tr></table></figure>

<p>全局的.gitconfig是公司项目信息，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">	name = thomas.hu</span><br><span class="line">	email = thomas.hu@xxx.com</span><br></pre></td></tr></table></figure>

<p>配置.gitconfig_mygithub完成后可见两种配置都生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git config --global user.name</span><br><span class="line">thomas.hu</span><br><span class="line">&gt; git config user.name</span><br><span class="line">cursorhu</span><br></pre></td></tr></table></figure>

<p>（4）三种配置文件的优先级</p>
<p>git使用以上三种配置的优先级为：项目配置 &gt; 路径配置 &gt; 全局配置</p>
<h2 id="换行符的配置"><a href="#换行符的配置" class="headerlink" title="换行符的配置"></a>换行符的配置</h2><p>为了解决跨平台的文件换行符问题，git支持自定义配置换行符规则。</p>
<p>（1）跨平台的文件换行符的相关背景</p>
<p>在各操作系统下，文本文件所使用的换行符是不一样的。UNIX&#x2F;Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是 0x0D（CR），后来的 OS X 版本与 UNIX 保持一致了。但 DOS&#x2F;Windows 使用 0x0D0A（CRLF）作为换行符。也就是说，在不同平台上写代码，其代码文件和一些项目配置文件的换行不一样。</p>
<p>（2）Git工具的autocrlf </p>
<p>Git最开始只支持类Unix的LF换行符，为了支持Windows开发的CRLF换行，Git提供了autocrlf 配置字段autocrlf 。</p>
<p>如果autocrlf enable, Windows 本地的CRLF文件在提交到git时，自动转换为LF换行；从git checkout文件到windows本地时，git将LF换行自动替换为 Windows 的换行符（CRLF）。Linux环境下checkout时文件换行也自动转换为Linux的LF格式。</p>
<p>如果autocrlf disable, Windows 本地的CRLF文件在提交到git时仍然为CRLF换行，如果有其他Linux环境的开发者checkout文件，可能无法在Linux上识别相关的CRLF文件引起项目编译问题。</p>
<p>如果没有跨平台的开发环境，即所有开发者都是Windows或都是Linux环境，则不需要autocrlf enable。</p>
<p>注意：对于windows版本的git, 默认是enable autocrlf，.gitconfig内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	autocrlf = true</span><br></pre></td></tr></table></figure>

<p>可以使用命令修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

<p>（3）同一个项目内，要同时支持LF和CRLF如何设置？</p>
<p>如果是临时的解决某些文件的换行问题，可以手动转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dos2unix #转换dos换行符为unix换行</span><br><span class="line">unix2dos #转换unix换行符为dos换行</span><br></pre></td></tr></table></figure>

<p>对git项目的配置，参考<a href="https://git-scm.com/docs/gitattributes">.gitattributes</a>，可以指定某路径的某文件使用指定的换行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*           text=auto		#set autocrlf manually for all files</span><br><span class="line">*.vcproj	text eol=crlf 	#all .vcproj files have CRLF</span><br><span class="line">*.sh		text eol=lf 	#all .sh files have LF</span><br><span class="line">*.jpg		-text 			#prevent .jpg files from being normalized</span><br></pre></td></tr></table></figure>

<p>eol attribute sets a specific line-ending style to be used in the working directory. This attribute has effect only if the <code>text</code> attribute is set or unspecified</p>
<p>一个项目既有windows的bat脚本又有Linux的sh脚本，在全局的core.autocrlf 为true的基础上，配置如下attribute 使这些文件不自动转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.bat	text eol=crlf</span><br><span class="line">*.sh	text eol=lf</span><br><span class="line">*/*.cfg	text eol=crlf</span><br></pre></td></tr></table></figure>

<h1 id="合并时有二进制文件冲突如何处理"><a href="#合并时有二进制文件冲突如何处理" class="headerlink" title="合并时有二进制文件冲突如何处理"></a>合并时有二进制文件冲突如何处理</h1><p>Git merge产生冲突：对于文本文件的冲突有强制处理要求，不解决完冲突无法提交；而对二进制文件的冲突只有提醒，没有强制处理要求。</p>
<p>对于文本文件，提交者可以直接修改冲突的内容；而对于二进制文件，提交者不能直接修改二进制冲突的内容，很容易漏过对二进制文件冲突的处理。</p>
<p>二进制文件冲突，git处理不了内容，应该使用覆盖的方式处理。手动覆盖可以解决此问题，但更合理的方法是用git命令自动解决。</p>
<p>git命令方法：在冲突发生后，使用命令<code>git checkout --ours|--theirs &lt;Paths&gt;</code>来选择是使用“Ours，即当前分支”的二进制文件，还是“Theirs，即合并进来的分支”的二进制文件直接替换掉本地的冲突二进制文件，其中<code>&lt;Paths&gt;</code>是冲突二进制文件的路径。</p>
<p>示例如下：</p>
<p>本地版本为branch-A，要合并进来branch-B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge branch-B --squash</span><br></pre></td></tr></table></figure>

<p>项目中的exe文件产生的冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">warning: Cannot merge binary files: fw_parameter_edit_tool/flash_header_parameter_update_tool.exe (HEAD vs. branch-B)</span><br><span class="line">Auto-merging fw_parameter_edit_tool/flash_header_parameter_update_tool.exe</span><br><span class="line">CONFLICT (content): Merge conflict in fw_parameter_edit_tool/flash_header_parameter_update_tool.exe</span><br></pre></td></tr></table></figure>

<p>此时使用checkout –theirs将branch-B版本的二进制覆盖掉本地branch-A版本的二进制。即完成了此exe的合并（使用branch-B版本）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git checkout --theirs fw_parameter_edit_tool/flash_header_parameter_update_tool.exe</span><br><span class="line">Updated 1 path from the index</span><br></pre></td></tr></table></figure>

<p>合并完以后用beyond compare确认一下两个版本的exe是完全一致的，也可以用git diff看一下合并前后二进制文件是否有差异。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux MMC框架下的UHS-II驱动调试</title>
    <url>/2022/03/25/Linux%20MMC%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84UHS-II%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1-Linux-MMC-框架现状"><a href="#1-Linux-MMC-框架现状" class="headerlink" title="1. Linux MMC 框架现状"></a>1. Linux MMC 框架现状</h2><p>Linux MMC driver是支持包括SD卡，eMMC卡等等，属于MultiMediaCard设备和接口的驱动<br>其源码路径位于Kernel source code的drivers&#x2F;mmc路径, 头文件位于include&#x2F;linux&#x2F;mmc<br>mmc源码分为core&#x2F;host两层，是为了解耦：</p>
<ul>
<li>通用的SD&#x2F;eMMC流程(core)</li>
<li>具体的硬件操作流程(host)，在此层又可分为通用的SDHCI框架和非SDHCI框架，各eMMC&#x2F;SD host厂商实现最底层driver时，可以遵循SDHCI框架下的API, 间接实现core层定义的方法(driver称为operations), 也可以不遵循SDHCI框架，直接实现core层定义的方法。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301058425.png"></li>
</ul>
<p>本文重点关注mmc框架对SD卡驱动的支持</p>
<h3 id="1-1-SD卡的类型概述"><a href="#1-1-SD卡的类型概述" class="headerlink" title="1.1 SD卡的类型概述"></a>1.1 SD卡的类型概述</h3><p>SD卡可以分为三种类型：<br>UHS-I, UHS-II, SD express</p>
<p>详细信息参考<a href="https://www.sdcard.org/">https://www.sdcard.org</a></p>
<ul>
<li>Physical Layer Specification Ver.7.10 (从各层描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD Host Controller Specification Ver7.0 (从host控制器角度，描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD_Specifications_Part_1_UHS_II_Addendum(描述SD UHSII的附录规范)</li>
</ul>
<p>UHS即Ultra High Speed, express也表示高速，这三代SD卡的读写速度是依次增加，参考下图：</p>
<ul>
<li>UHSI：50~104MB&#x2F;s</li>
<li>UHSII: 156~624MB&#x2F;s</li>
<li>SD express: 985MB&#x2F;s</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301119947.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301120184.png"></p>
<h3 id="1-2-Linux-MMC框架对SD卡的支持"><a href="#1-2-Linux-MMC框架对SD卡的支持" class="headerlink" title="1.2 Linux MMC框架对SD卡的支持"></a>1.2 Linux MMC框架对SD卡的支持</h3><p>基本概念：只有mmc框架的core层支持某种SD模式，host层才能实现这种模式；如果core层都不支持，只能厂商自己开发core层，以patch补丁的方式发布。</p>
<p>core层对于上述三种SD模式的支持：</p>
<ul>
<li>Linux kernel 5.11 以前，只支持UHS-I及其更低速度的legacy-SD模式</li>
<li>Linux kernel 5.11 开始，在core层添加了SD express的支持</li>
<li>目前没有UHS-II的支持，只有提交待审核的，参考：<a href="https://lore.kernel.org/all/?q=Jason%20Lai">lore.kernel.org&#x2F;Jason Lai&#x2F;patch</a></li>
</ul>
<p>host层对于上述三种SD模式的支持：</p>
<ul>
<li>UHS-I: 基本host目录的大多数SD厂商驱动都支持，很多符合sdhci框架</li>
<li>SD express: Realtek基于Linux kernel 5.11的core层API, 实现了 驱动的host底层部分，参考kernel的host&#x2F;rtsx_pci_sdmmc.c, 其没有使用SDHCI框架。</li>
<li>UHS-II: 只有以patch方式实现的，参考<a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a>，其实现了core&#x2F;host-sdhci&#x2F;host vendor多个层次的UHS-II支持。</li>
</ul>
<p>综上所述，本文参考uhs2-gl8755 patch，实现自己的SD UHSII driver。</p>
<h2 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2. 编译过程"></a>2. 编译过程</h2><p>本节描述编译mmc driver module和整个kernel的过程，同时描述中间踩的坑。</p>
<h3 id="2-1-直接编译整个Kernel-带UHS-II-Patch"><a href="#2-1-直接编译整个Kernel-带UHS-II-Patch" class="headerlink" title="2.1 直接编译整个Kernel(带UHS-II Patch)"></a>2.1 直接编译整个Kernel(带UHS-II Patch)</h3><p>安装Linux Ubuntu 20版本，Ubuntu环境下载和解压待编译的整个Linux kernel 源码：<a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a></p>
<p>注意：一定要在Linux环境下解压待编译源码，不能在windows下解压再拷到Linux编译，因为源码中有些大小写不同的同名文件，例如net&#x2F;netfilter的很多头文件。windows不区分大小，解压时写会让你替换或重命名，这些同名文件的内容不一样，所以不能替换或重命名，强行替换会导致编译Linux报错找不到相关文件。</p>
<ol>
<li><p>编译环境准备<br>gcc&#x2F;make等工具，都需要先安装build-essential才能使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置，编译和安装 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd linux-uhs2-gl9755-v3-patch #进入待编译Kernel源码</span><br><span class="line">make menuconfig #配置内核，生成.config文件</span><br><span class="line">make -j4 #以4线程编译内核，等同于make bzImage，make modules</span><br><span class="line">make modules_install #安装各Driver模块</span><br><span class="line">make install #安装内核(包括更新模块信息)</span><br></pre></td></tr></table></figure>
<p>编译完成后会自动update-grub, 重启后选择编译好的kernel版本启动。</p>
</li>
</ol>
<p>也可以设置默认启动的kernel，编辑&#x2F;etc&#x2F;default&#x2F;grub的<code>GRUB_DEFAULT=&quot;1&gt;X&quot;</code>, 其中1表示从advanced选项启动，X表示从哪个kernel启动(0 based)，例如下图如果默认要从5.19启动，X设置为0，默认从5.8.0-rc4启动，X设置为6.<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202208171414943.png"><br>配置完毕update-grub重启生效</p>
<ol start="3">
<li><p>查看内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r #查看当前运行的kernel版本</span><br><span class="line">cat Makefile #查看待编译kernel源码的内核版本</span><br></pre></td></tr></table></figure>
<p>以linux-uhs2-gl9755-v3-patch为例，其根目录Makefile如下，表示kernel源码版本为 5.8.0-rc4<br>编译完成重启后应该选择5.8.0-rc4启动，进入桌面后用<code>uname -r</code>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VERSION = 5</span><br><span class="line">PATCHLEVEL = 8</span><br><span class="line">SUBLEVEL = 0</span><br><span class="line">EXTRAVERSION = -rc4</span><br><span class="line">NAME = Kleptomaniac Octopus</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译报错记录<br>(1) 生成vmlinux Image时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to generate BTF for vmlinux  </span><br><span class="line">Try to disable CONFIG_DEBUG_INFO_BTF</span><br></pre></td></tr></table></figure>
<p>修改Kernel源码根目录的.config文件，CONFIG_DEBUG_INFO_BTF&#x3D;n 关闭此选项</p>
</li>
</ol>
<p>​      (2) 编译完成，但运行新kernel时报错<code>out of memory</code><br>解决办法：裁剪module大小，编译模块时使用 <code>make  INSTALL_MOD_STRIP=1 modules_install</code>，.ko被编译时会缩减非必要的debug信息。</p>
<h3 id="2-2-合并UHSII-patch后再编译整个Kernel"><a href="#2-2-合并UHSII-patch后再编译整个Kernel" class="headerlink" title="2.2 合并UHSII patch后再编译整个Kernel"></a>2.2 合并UHSII patch后再编译整个Kernel</h3><p>官方kernel源码可以到<a href="https://www.kernel.org/">kernel.org</a>下载</p>
<p>合并UHSII patch，仅涉及到mmc模块的代码，如果差异不大可以将linux-uhs2-gl9755-v3-patch的drivers&#x2F;mmc和include头文件直接拷到待编译kernel的drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc。</p>
<p>如果是手动合并UHS-II patch，需要考虑以下部分：</p>
<ul>
<li>源码，包括drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc</li>
<li>Makefile, 包括drivers&#x2F;mmc&#x2F;core和drivers&#x2F;mmc&#x2F;host</li>
<li>Kconfig, 包括drivers&#x2F;mmc，及其子目录core和host</li>
</ul>
<p>具体合并方法参考《Linux设备驱动开发详解》<br>合并完后，Kernel编译流程和上节相同</p>
<h3 id="2-3-单独编译MMC模块"><a href="#2-3-单独编译MMC模块" class="headerlink" title="2.3 单独编译MMC模块"></a>2.3 单独编译MMC模块</h3><p>一般的驱动开发，都是可以单独编译成module模块，然后用rmmod和insmod替换原系统的模块</p>
<p>但是UHS-II patch涉及到mmc&#x2F;core层的改动，而core是build-in的，不能作为模块编译，因此只能编译整个kernel。以后如果只修改host层的代码，可以将mmc&#x2F;host单独编译为module后安装。</p>
<p>待编译kernel目录是<code>~/linux-5.8-rc4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#编译模块，&quot;M=&quot;指定待编译源码，编译完拷贝.ko到&quot;-C&quot;指定的目录，此目录为系统存放模块的目录</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc</span><br><span class="line"></span><br><span class="line">#安装模块</span><br><span class="line">make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc modules_install</span><br><span class="line">	</span><br><span class="line">#清除模块,包括.o和.ko文件</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc clean</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.kernel.org/doc/html/latest/kbuild/modules.html"># Building External Modules</a></p>
<p>注意，<code>make xxx modules_install</code>是不能让模块自动加载的，只是安装到了&#x2F;lib&#x2F;modules位置。使用<code>modinfo</code>查看模块信息，似乎是使用了&#x2F;lib&#x2F;modules下的，但没有实际加载和生效。<br>要加载模块，两种方法：</p>
<ol>
<li>rmmod&#x2F;insmod 手动替换, 参考下一节</li>
<li>make modules_install 之后再 make install，更新整个kernel, 此后外部模块才会被内核自动加载（通常使用这种方式）</li>
</ol>
<h3 id="2-4-手动替换MMC模块"><a href="#2-4-手动替换MMC模块" class="headerlink" title="2.4 手动替换MMC模块"></a>2.4 手动替换MMC模块</h3><h4 id="2-4-1-UHS-II相关模块的依赖关系"><a href="#2-4-1-UHS-II相关模块的依赖关系" class="headerlink" title="2.4.1 UHS-II相关模块的依赖关系"></a>2.4.1 UHS-II相关模块的依赖关系</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301640662.png"></p>
<p>可以从mmc&#x2F;host的Kconfig得知依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config MMC_SDHCI_PCI</span><br><span class="line">	tristate &quot;SDHCI support on PCI bus&quot;</span><br><span class="line">	depends on MMC_SDHCI &amp;&amp; PCI</span><br><span class="line">	select MMC_SDHCI_UHS2</span><br><span class="line">	</span><br><span class="line">config MMC_SDHCI_UHS2</span><br><span class="line">	tristate &quot;UHS2 support on SDHCI controller&quot;</span><br><span class="line">	depends on MMC_SDHCI</span><br></pre></td></tr></table></figure>

<p>使用<code>lsmod</code>可以得知module依赖关系，如下图，sdhci_uhs2被sdhci_pci引用1次, sdhci被sdhci_uhs2和sdhci_pci引用2次<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645712.png"><br><code>modinfo</code>可以得知已加载module的.ko路径<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645737.png"></p>
<h4 id="2-4-2-手动卸载和装载module"><a href="#2-4-2-手动卸载和装载module" class="headerlink" title="2.4.2 手动卸载和装载module"></a>2.4.2 手动卸载和装载module</h4><p>卸载和装载都要按依赖顺序处理，shell脚本如下.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">sudo rmmod sdhci_pci</span><br><span class="line">sudo rmmod sdhci_uhs2</span><br><span class="line">sudo rmmod sdhci</span><br><span class="line"></span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-uhs2.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-pci.ko </span><br></pre></td></tr></table></figure>

<h2 id="3-调试过程"><a href="#3-调试过程" class="headerlink" title="3. 调试过程"></a>3. 调试过程</h2><h3 id="3-1-调试工具"><a href="#3-1-调试工具" class="headerlink" title="3.1 调试工具"></a>3.1 调试工具</h3><ol>
<li>printk<br>printk是很常用的driver调试手段，配合dmesg查看kernel log可以定位常见问题。<br>printk如何开启不同打印级别，参考<a href="https://www.kernel.org/doc/html/latest/core-api/printk-basics.html"># Message logging with printk</a></li>
</ol>
<p>例如，使用<code>dmesg -n 6</code>开启KERN_INFO级别，然后在driver中添加pr_info()作为info打印, 在dmesg中查看打印log。</p>
<p>注意KERN_DEBUG比较特殊，不仅要<code>dmesg -n 7</code>开启, 还需要在driver module的makefile添加Debug CFLAGS, 有两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#该Makefile相关模块全部启用debug</span><br><span class="line">EXTRA_CFLAGS += -DDEBUG</span><br><span class="line"></span><br><span class="line">#指定模块启用debug</span><br><span class="line">CFLAGS-xxx-mmc += -DDEBUG</span><br></pre></td></tr></table></figure>
<p>示例：使用<code>pr_info(“enter %s\n”, __FUNCTION__);</code> 打印函数调用流程</p>
<ol start="2">
<li>dmesg<br>示例参考 <a href="https://www.geeksforgeeks.org/how-to-use-the-dmesg-command-on-linux/"># How to use the dmesg Command on Linux</a><br>比较常用的有：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dmesg</span><br><span class="line">sudo dmesg -c </span><br><span class="line">sudo dmesg | head -100</span><br><span class="line">sudo dmesg | tail</span><br><span class="line">sudo dmesg | xxx</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.vscode<br>vscode比vim&#x2F;gedit更方便直接改代码，用.deb安装容易失败，推荐命令行安装方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#更新相关microsoft源</span><br><span class="line">wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] \</span><br><span class="line">https://packages.microsoft.com/repos/code stable main&quot; &gt; /etc/apt/sources.list.d/vscode.list&#x27;</span><br><span class="line"></span><br><span class="line">rm -f packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install code</span><br></pre></td></tr></table></figure>
<h3 id="3-2-UHSII调试"><a href="#3-2-UHSII调试" class="headerlink" title="3.2 UHSII调试"></a>3.2 UHSII调试</h3><ol>
<li><p>模块加载初始化过程中dmesg显示直接dump<br>基本是空指针问题，例如：</p>
<ul>
<li>只编译UHSII host 模块，而不编译kernel的core层，insmod host模块时就会dump, 因为core层相关API不存在。</li>
<li>获取相关数据结构方法不对导致空指针<br>例如获取slot要使用：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  struct sdhci_pci_slot *slot = sdhci_priv(host);</span><br><span class="line"></span><br><span class="line">static inline void *sdhci_priv(struct sdhci_host *host)&#123;</span><br><span class="line">   return host-&gt;private;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
而host-&gt;private实际指向sdhci_host结构体的最后定义的如下0长度数组<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long private[] ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
参考：<a href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct"># <a href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct">Explanation on private variable in c struct</a></a><br>基本含义是可以获取结构体外部的数据，而host指针本身确实属于slot结构体sdhci_pci_slot的一部分，所以host-&gt;private能访问到slot。</li>
</ul>
</li>
<li><p>贴一段dmesg log，包含UHSII初始化过程直到最后一步GO_DORMANT fail<br>具体流程参考UHSII spec:  SD_Specifications_Part_1_UHS_II_Addendum</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  522.171631] sdhci_uhs2 [sdhci_uhs2_do_detect_init()]: sdhci_uhs2_do_detect_init: begin UHS2 init.</span><br><span class="line">[  522.171632] enter sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171632] exit sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171835] sdhci_uhs2 [sdhci_uhs2_interface_detect()]: mmc0: UHS2 Lane synchronized in UHS2 mode, PHY is initialized.</span><br><span class="line">[  522.171855] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171856] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 0</span><br><span class="line">[  522.171858] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171865] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.171874] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.171885] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.171887] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171887] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 1</span><br><span class="line">[  522.171888] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171894] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188184] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188205] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188254] [uhs2_dev_init()]: CF is set, device is initialized!</span><br><span class="line">[  522.188257] [uhs2_enum()]: Begin ENUMERATE, header=0x80, arg=0x392, payload=0xf0.</span><br><span class="line">[  522.188260] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x392</span><br><span class="line">[  522.188262] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=8</span><br><span class="line">[  522.188266] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188277] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188290] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188308] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188318] [uhs2_enum()]: id_f = 6, id_l = 6.</span><br><span class="line">[  522.188320] [uhs2_enum()]: Enumerate Cmd Completed. No. of Devices connected = 1</span><br><span class="line">[  522.188322] [uhs2_config_read()]: INQUIRY_CFG: read Generic Caps.</span><br><span class="line">[  522.188324] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x10.</span><br><span class="line">[  522.188326] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x10</span><br><span class="line">[  522.188328] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188331] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188342] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188363] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188392] mmc0: req done (CMD0): 0: 00010100 00000000 00000000 00000000</span><br><span class="line">[  522.188398] [uhs2_config_read()]: Device Generic Caps (0-31) is: 0x10100.</span><br><span class="line">[  522.188399] [uhs2_config_read()]: INQUIRY_CFG: read PHY Caps.</span><br><span class="line">[  522.188401] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x220.</span><br><span class="line">[  522.188404] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x220</span><br><span class="line">[  522.188410] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188415] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188427] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188447] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188476] mmc0: req done (CMD0): 0: 00008000 00000080 00000000 00000000</span><br><span class="line">[  522.188482] [uhs2_config_read()]: Device PHY Caps (0-31) is: 0x8000.</span><br><span class="line">[  522.188484] [uhs2_config_read()]: Device PHY Caps (32-63) is: 0x80.</span><br><span class="line">[  522.188487] [uhs2_config_read()]: INQUIRY_CFG: read LINK-TRAN Caps.</span><br><span class="line">[  522.188492] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x420.</span><br><span class="line">[  522.188499] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x420</span><br><span class="line">[  522.188504] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188507] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188516] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188554] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188582] mmc0: req done (CMD0): 0: 20024000 00000000 00000000 00000000</span><br><span class="line">[  522.188601] [uhs2_config_read()]: Device LINK-TRAN Caps (0-31) is: 0x20024000.</span><br><span class="line">[  522.188604] [uhs2_config_read()]: Device LINK-TRAN Caps (32-63) is: 0x0.</span><br><span class="line">[  522.188605] [uhs2_config_write()]: SET_COMMON_CFG: write Generic Settings.</span><br><span class="line">[  522.188607] [uhs2_config_write()]: Both Host and device support 2L-HD.</span><br><span class="line">[  522.188609] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0</span><br><span class="line">[  522.188611] [uhs2_config_write()]: UHS2 write Generic Settings 00000000 00000000</span><br><span class="line">[  522.188613] [uhs2_config_write()]: flags=00000005 dev_prop.n_lanes_set=0 host_caps.n_lanes_set=0</span><br><span class="line">[  522.188615] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188618] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188620] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188632] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188650] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188678] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188684] [uhs2_config_write()]: SET_COMMON_CFG: PHY Settings.</span><br><span class="line">[  522.188686] [uhs2_config_write()]: set dev_prop.speed_range_set to SPEED_B</span><br><span class="line">[  522.188689] [uhs2_config_write()]: UHS2 SET PHY Settings  40000000 04000000</span><br><span class="line">[  522.188691] [uhs2_config_write()]: host-&gt;flags=00000015 dev_prop.speed_range_set=1</span><br><span class="line">[  522.188693] [uhs2_config_write()]: dev_prop.n_lss_sync_set=4 host_caps.n_lss_sync_set=4</span><br><span class="line">[  522.188694] [uhs2_config_write()]: dev_prop.n_lss_dir_set=0 host_caps.n_lss_dir_set=8</span><br><span class="line">[  522.188696] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xaa0</span><br><span class="line">[  522.188698] [uhs2_config_write()]: 		payload[0]=0x40000000 payload[1]=0x4000000</span><br><span class="line">[  522.188700] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xaa0</span><br><span class="line">[  522.188703] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=4</span><br><span class="line">[  522.188705] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188715] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188730] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188741] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188746] [uhs2_config_write()]: SET_COMMON_CFG: LINK-TRAN Settings.</span><br><span class="line">[  522.188748] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xca0</span><br><span class="line">[  522.188750] [uhs2_config_write()]: 		payload[0]=0x80320 payload[1]=0x1000000</span><br><span class="line">[  522.188752] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xca0</span><br><span class="line">[  522.188754] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188756] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188766] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188780] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188808] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188813] [uhs2_config_write()]: SET_COMMON_CFG: Set Config Completion.</span><br><span class="line">[  522.188815] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0, payload[0] = 0x0.</span><br><span class="line">[  522.188817] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188819] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=5</span><br><span class="line">[  522.188821] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188831] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188842] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188855] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188862] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 0.</span><br><span class="line">[  522.201612] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 3.</span><br><span class="line">[  522.201614] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 2.</span><br><span class="line">[  522.201616] [uhs2_go_dormant()]: Begin GO_DORMANT_STATE, header=0x86, arg=0x192, payload=0x0.</span><br><span class="line">[  522.201617] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x192</span><br><span class="line">[  522.201618] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=0</span><br><span class="line">[  522.201619] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.201626] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x8c0 is set to UHS2 CMD register.</span><br><span class="line">[  522.218633] mmc0: sdhci: IRQ status 0x00008000</span><br><span class="line">[  522.218636] sdhci_uhs2 [sdhci_uhs2_irq()]: *** mmc0 got UHS2 interrupt: 0x00010000</span><br><span class="line">[  522.218651] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218652] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218652] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218654] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218659] mmc0: req done (CMD0): -110: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.218666] mmc0: uhs2_go_dormant: UHS2 CMD send fail, err= 0xffffff92!</span><br><span class="line">[  522.218668] mmc0: uhs2_change_speed: UHS2 GO_DORMANT_STATE fail, err= 0xfffffffb!</span><br><span class="line">[  522.218669] mmc0: UHS2 uhs2_change_speed() fail!</span><br></pre></td></tr></table></figure>
<p>含义是UHSII初始化接近完成，切换到高速的RangeB时，GO_DORMANT_STATE命令未完成，超时。<br>解决办法：先绕过RangeB模式，使用RangA(较低速度的UHSII模式)，为此要从一开始就上报host不支持RangeB。<br>修改mmc&#x2F;host&#x2F;sdhci-uhs2.c中的上报host能力(capability)的speed_range为不支持RangeB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mmc-&gt;uhs2_caps.speed_range =(caps_phy &amp; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_MASK) &gt;&gt; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_SHIFT;</span><br><span class="line"></span><br><span class="line">mmc-&gt;uhs2_caps.speed_range = 0; //Range-A</span><br></pre></td></tr></table></figure>
<p>重新编译安装module后，UHSII初始化正常，读写正常。</p>
</li>
</ol>
<p>事实上此GO_DORMANT fail issue的根本原因是兼容性问题：<br>UHSII初始化流程中，SD host侧对lane speed的配置最好在卡处在dormant状态下进行，host侧提高速度（从Range-A提高到RangeB）以后，卡侧在退出dormant状态时重新配置速度，和host速度匹配。<br>如果host侧修改lane speed时间点错误，有的SD卡来不及反应，不能同步速度，所以GO_DORMANT fail；而有的SD 卡性能好，随时同步host侧的速度，没有此issue。</p>
<p>另外有的Issue和硬件特性相关，例如上电需要等待一定时间以后，才能启动UHSII设备初始化，这个等待时间取决于SD host厂商的硬件特性。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：SSD的S3/S4/S5压力测试脚本</title>
    <url>/2020/09/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9ASSD%E7%9A%84S3-S4-S5%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>存储设备产品（如SSD&#x2F;eMMC）的读写速度和稳定性测试，是量产前必不可少的步骤。除了常规的两个设备来回拷贝读写，存储设备做系统盘的情况下，反复的启动，睡眠，休眠，也是重要的测试项。本文介绍这几种测试的原理，工具实现，和调试过程</p>
<h1 id="系统电源状态"><a href="#系统电源状态" class="headerlink" title="系统电源状态"></a>系统电源状态</h1><p>ACPI（高级配置与电源接口）是电源配置和接口的规范，供操作系统和应用程序管理所有电源，其定义了几种状态（State）：S1~S6<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051553199.png" alt="image-20221205155311145"></p>
<p>操作系统在ACPI基础上实现各自的电源状态划分<br>Linux电源状态划分为如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554689.png" alt="image-20221205155406635"></p>
<p>其中，常见的几种状态有别称，如S3通常也称Suspend，S4也称Hibernation, S5即shutdown。下面描述这几种状态的区别</p>
<p>S3:<br>1、将系统当前的运行状态等数据保存在内存中，此时仍需要向RAM供电，以保证后续快速恢复至工作状态<br>2、冻结用户态的进程和内核态的任务（进入内核态的进程或内核自己的task）<br>3、关闭外围设备，如显示屏、鼠标等,中断唤醒外设不会关闭，如电源键<br>4、CPU停止工作</p>
<p>S4：<br>挂起到硬盘，俗称休眠（Hibernation）将系统当前的运行状态等数据保存到硬盘上，并自动关机。下次开机时便从硬盘上读取之前保存的数据，恢复到休眠关机之前的状态。<br>譬如在休眠关机时，桌面打开了一个应用，那么下一次开机启动时，该应用也处于打开状态。而正常的关机-开机流程，该应用是不会打开的</p>
<p>S5:<br>关机并断电，实际上，S5在不同场景下，可以指代关机和重启两种操作，关机是彻底power off的，而重启不是彻底断电，只是重新启动了系统，（当然基本所有设备都被reset），重启！&#x3D;关机再启动。</p>
<h1 id="测试工具设计"><a href="#测试工具设计" class="headerlink" title="测试工具设计"></a>测试工具设计</h1><p>需求：设计工具使系统从S0(working)进入S3&#x2F;S4&#x2F;S5状态，维持一段时间，然后退出该状态，在S0维持一段时间，再次进入S3&#x2F;S4&#x2F;S5状态，如此反复循环。用户输入工作模式（S3&#x2F;S4&#x2F;S5）和循环次数，工具输出运行日志，包含已运行次数和时间戳。</p>
<h2 id="Linux测试脚本实现"><a href="#Linux测试脚本实现" class="headerlink" title="Linux测试脚本实现"></a>Linux测试脚本实现</h2><p>Linux环境有现成的工具：rtcwake，参看其man page：</p>
<pre><code>NAME
       rtcwake - enter a system sleep state until specified wakeup time
SYNOPSIS
       rtcwake [options] [-d device] [-m standby_mode] &#123;-s seconds|-t time_t&#125;
DESCRIPTION
       This program is used to enter a system sleep state and to automatically wake from it at a specified time.
       This uses cross-platform Linux interfaces to enter a system sleep state, and leave it no later than a specified time.  It uses any RTC framework driver that supports standard driver model wakeup flags.
       This is normally used like the old apmsleep utility, to wake from a suspend state like ACPI S1 (standby) or S3 (suspend-to-RAM).  Most platforms can implement those without analogues of BIOS, APM, or ACPI.
       On some systems, this can also be used like nvram-wakeup, waking from states like ACPI S4 (suspend to disk).  Not all systems have persistent media that are appropriate for such suspend modes.
       Note that alarm functionality depends on hardware; not every RTC is able to setup an alarm up to 24 hours in the future.
       The suspend setup may be interrupted by active hardware; for example wireless USB input devices that continue to send events for some fraction of a second after the return key is pressed.  rtcwake tries to avoid this problem and it waits to terminal to settle down before entering a system sleep.
</code></pre>
<p>其重要option如下：</p>
<pre><code>      -m, --mode mode
              Go into the given standby state.  Valid values for mode are:

              standby
                     ACPI state S1.  This state offers minimal, though real,
                     power savings, while providing a very low-latency
                     transition back to a working system.  This is the
                     default mode.

              freeze The processes are frozen, all the devices are suspended
                     and all the processors idled.  This state is a general
                     state that does not need any platform-specific support,
                     but it saves less power than Suspend-to-RAM, because
                     the system is still in a running state.  (Available
                     since Linux 3.9.)

              mem    ACPI state S3 (Suspend-to-RAM).  This state offers
                     significant power savings as everything in the system
                     is put into a low-power state, except for memory, which
                     is placed in self-refresh mode to retain its contents.

              disk   ACPI state S4 (Suspend-to-disk).  This state offers the
                     greatest power savings, and can be used even in the
                     absence of low-level platform support for power
                     management.  This state operates similarly to Suspend-
                     to-RAM, but includes a final step of writing memory
                     contents to disk.

              off    ACPI state S5 (Poweroff).  This is done by calling
                     &#39;/sbin/shutdown&#39;.  Not officially supported by ACPI,
                     but it usually works.

              no     Don&#39;t suspend, only set the RTC wakeup time.

              on     Don&#39;t suspend, but read the RTC device until an alarm
                     time appears.  This mode is useful for debugging.

              disable
                     Disable a previously set alarm.

              show   Print alarm information in format: &quot;alarm: off|on
                     &lt;time&gt;&quot;.  The time is in ctime() output format, e.g.,
                     &quot;alarm: on  Tue Nov 16 04:48:45 2010&quot;.
                     
       -s, --seconds seconds
              Set the wakeup time to seconds in the future from now.

       -t, --time time_t
              Set the wakeup time to the absolute time time_t.  time_t is
              the time in seconds since 1970-01-01, 00:00 UTC.  Use the
              date(1) tool to convert between human-readable time and
              time_t.
</code></pre>
<p>只需要写shell script调用rtcwake即可<br>注意要求跨状态记录日志，S3&#x2F;S4很容易，运行信息只是被挪到内存、硬盘，不会丢失，但S5会shutdown, 因此循环次数和时间只能记录在掉电不丢失的硬盘里。<br>S3S4可以用一个脚本完成，而S5需要单独设计<br>S3S4.sh如下：<br>接受用户输入：<br>opt: S3或S4模式；COUNT：循环次数<br>每次执行rtcwake，日志写入LOG</p>
<pre><code>opt=$1
COUNT=$2
interval=30
s3timer=120
s4timer=120

mkdir -p log
DATE=$(date +%Y-%m-%d)
LOG=log/$&#123;opt&#125;_$&#123;DATE&#125;.log
cat /dev/null &gt; $&#123;LOG&#125;

echo &quot;=============================== $opt test start ===============================&quot; |tee -a $&#123;LOG&#125;

for (( i=1; i&lt;=$COUNT; i++ ))
do 
    if [ $opt == &quot;s3&quot; ];then
        echo &quot;************************* S3 Cycle: $i start *************************&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S3, Duration &quot;$s3timer&quot; sec&quot; |tee -a $&#123;LOG&#125;
        sudo rtcwake -m mem -s $s3timer &gt;&gt; $&#123;LOG&#125; 2&gt;&amp;1
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Waitable timer triggered.&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Wake up from S3, Cycle &quot;$i&quot;&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Successfully left sleep state S3...&quot; |tee -a $&#123;LOG&#125;
    elif [ $opt == &quot;s4&quot; ];then
        echo &quot;************************* S4 Cycle: $i start *************************&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S4, Duration &quot;$s4timer&quot; sec&quot; |tee -a $&#123;LOG&#125;
        sudo rtcwake -m disk -s $s4timer &gt;&gt; $&#123;LOG&#125; 2&gt;&amp;1
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Waitable timer triggered.&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Wake up from S4, Cycle &quot;$i&quot;&quot; |tee -a $&#123;LOG&#125;
        echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Successfully left sleep state S4...&quot; |tee -a $&#123;LOG&#125;
    else
        echo &quot;error input, use s3 or s4 as input&quot;
    fi
    echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;wake up for $interval seconds&quot; |tee -a $&#123;LOG&#125;
    echo &quot;************************* $opt Cycle: $i finish *************************&quot; |tee -a $&#123;LOG&#125;
    #keep wake up time
    sleep $interval
done

echo &quot;=============================== $opt test finished =============================== &quot; |tee -a $&#123;LOG&#125;
</code></pre>
<p>S5必须要解决两个问题：<br>1.每次测试的信息如何跨越重启<br>2.如何使系统自动不断的重启</p>
<p>对于1，可以将日志写入固定文件，每次重启后读该文件并追加，知道S5循环结束<br>对于2，Linux有开机自动启动某些桌面程序、shellscript的机制</p>
<p>S5测试脚本分为三部分：<br>配置自启动并执行首次重启的脚本：s5_start.sh<br>执行单次S5的脚本，即自启动调用的脚本：s5.sh<br>停止S5，清楚自启动配置的脚本：s5_stop.sh</p>
<p>s5_start.sh</p>
<pre><code>#!/bin/bash
USER=$(users)
opt=s5
interval=30
s5timer=180

#config autostart
mkdir -p /home/$USER/.config/autostart
touch /home/$USER/.config/autostart/s5.desktop
echo &quot;
[Desktop Entry]
Type=Application
Exec=gnome-terminal -e /home/$USER/s5.sh
Terminal=true
X-GNOME-Autostart-enabled=true
&quot; &gt; /home/$USER/.config/autostart/s5.desktop
chmod 777 /home/$USER/.config/autostart/s5.desktop
echo &quot;config autostart finished&quot;

#config sudo
echo &quot;$USER ALL=(ALL) NOPASSWD:ALL&quot; &gt;&gt; /etc/sudoers

#config s5 log and temp file 
mkdir -p log
DATE=$(date +%Y-%m-%d)
LOG=log/$&#123;opt&#125;_$&#123;DATE&#125;.log
cat /dev/null &gt; $&#123;LOG&#125;
echo &quot;1&quot; &gt; $&#123;opt&#125;_cycle.txt
echo &quot;$LOG&quot; &gt; $&#123;opt&#125;_log.txt
chmod 777 -R ./*.sh ./log/*.log ./*.txt

echo &quot;System will shutdown after &quot;$interval&quot; sec, then restart after &quot;$s5timer&quot; sec&quot;
echo &quot;*********************** S5 Cycle: 1 *************************&quot; |tee -a $&#123;LOG&#125;
echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S5 after &quot;$interval&quot; sec&quot; |tee -a $&#123;LOG&#125;
sleep $interval

rtcwake -m off -s $s5timer &gt;&gt; $&#123;LOG&#125; 2&gt;&amp;1
</code></pre>
<p>s5.sh</p>
<pre><code>#!/bin/bash
COUNT=&quot;999&quot;
opt=s5
interval=30
s5timer=180
cycle=$(&lt;$&#123;opt&#125;_cycle.txt)
LOG=$(&lt;$&#123;opt&#125;_log.txt)

#update cycle
((cycle++))
echo &quot;$cycle&quot; &gt; $&#123;opt&#125;_cycle.txt 

#keep wake
echo &quot;*********************** S5 Cycle: $cycle *************************&quot; |tee -a $&#123;LOG&#125;
echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S5 after &quot;$interval&quot; sec&quot; |tee -a $&#123;LOG&#125;
sleep $interval

sudo rtcwake -m off -s $s5timer &gt;&gt; $&#123;LOG&#125; 2&gt;&amp;1
</code></pre>
<p>s5_stop.sh</p>
<pre><code>#!/bin/bash
USER=$(users)
opt=s5
rm -f /home/$USER/.config/autostart/s5.desktop
rm -f $&#123;opt&#125;_cycle.txt $&#123;opt&#125;_log.txt
sed -i &#39;/NOPASSWD/d&#39; /etc/sudoers
</code></pre>
<h2 id="测试脚本使用"><a href="#测试脚本使用" class="headerlink" title="测试脚本使用"></a>测试脚本使用</h2><h3 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h3><pre><code>./s3s4.sh s3 999      启动s3测试,运行999次
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554212.png" alt="image-20221205155429129"></p>
<h3 id="S4"><a href="#S4" class="headerlink" title="S4"></a>S4</h3><p>S4在内存和硬盘直接读写运行时映像，硬盘需要指定那一块区域用于和内存交换，即交换分区。Linux一切皆文件，交换分区也可以用swapfile配置。以下配置swapfile</p>
<ol>
<li><p>df –h 查看挂载点为&#x2F;对应的文件系统是&#x2F;dev&#x2F;nvme0n1p2,根据你具体情况记录<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554816.png"></p>
</li>
<li><p><code>blkid</code>查看UUID值，根据1对应的nvme文件系统记录UUID<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554581.png"></p>
</li>
<li><p><code>filefrag –v /swapfile</code>查看swapfile的物理起始地址，记录physical_offset左侧值<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554581.png"></p>
</li>
<li><p>将UUID和physical_offset值写入grub：<br>终端输入gedit &#x2F;etc&#x2F;default&#x2F;grub ，修改以下参数并保存<br><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash resume=UUID=你的UUID值 resume_offset=你的physical_offset值</code>“</p>
<p> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051555015.png" alt="image-20221205155518922"></p>
</li>
<li><p>重新生成grub: 终端输入 <code>update-grub</code> 回车并重启电脑。</p>
</li>
</ol>
<p>启动S4脚本</p>
<pre><code>./s3s4.sh s4 999
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051557197.png" alt="image-20221205155749113"></p>
<h3 id="S5"><a href="#S5" class="headerlink" title="S5"></a>S5</h3><p>自动重启需要先解决账户密码问题<br>设置普通账户自动登录：<br>普通账户为装系统时设置的账户，重启后默认以普通账户登录<br>1.终端输入<code>gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</code>弹出编辑界面<br>设置以下参数，ctrl+s保存后关闭</p>
<pre><code>[Seat:*]
user-session=ubuntu
autologin-user=你的账户名
</code></pre>
<p>2.终端输入<code>gedit /etc/gdm3/custom.conf</code>，设置以下几行的值为如下</p>
<pre><code># Enabling automatic login
AutomaticLoginEnable = true
AutomaticLogin =你的账户名
</code></pre>
<p>重启，确认可免密码登录桌面。</p>
<pre><code>./s5_start.sh 启动s5
./s5_stop.sh 结束S5
</code></pre>
<h1 id="Dmesg分析和调试"><a href="#Dmesg分析和调试" class="headerlink" title="Dmesg分析和调试"></a>Dmesg分析和调试</h1><h2 id="dmesg简介"><a href="#dmesg简介" class="headerlink" title="dmesg简介"></a>dmesg简介</h2><p>dmesg命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备<br>注意：<br>dmesg只记录从启动到当前时间的信息，掉电丢失</p>
<p>使用示例：</p>
<pre><code>dmesg //默认输出
dmesg | less //从头分页显示
dmesg | tail -100 //显示最后100行
dmesg | head  -100 //显示最早100行
dmesg | grep -i usb //包含usb的信息，忽略大小写
dmesg -C //清除log
</code></pre>
<p>输出示例：</p>
<pre><code>[root]# dmesg | grep sda
 
[    1.280971] sd 2:0:0:0: [sda] 488281250 512-byte logical blocks: (250 GB/232 GiB)
[    1.281014] sd 2:0:0:0: [sda] Write Protect is off
[    1.281016] sd 2:0:0:0: [sda] Mode Sense: 00 3a 00 00
[    1.281039] sd 2:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn&#39;t support DPO or FUA
[    1.359585]  sda: sda1 sda2 &lt; sda5 sda6 sda7 sda8 &gt;
[    1.360052] sd 2:0:0:0: [sda] Attached SCSI disk
[    2.347887] EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
[   22.928440] Adding 3905532k swap on /dev/sda6.  Priority:-1 extents:1 across:3905532k FS
[   23.950543] EXT4-fs (sda1): re-mounted. Opts: errors=remount-ro
[   24.134016] EXT4-fs (sda5): mounted filesystem with ordered data mode. Opts: (null)
[   24.330762] EXT4-fs (sda7): mounted filesystem with ordered data mode. Opts: (null)
[   24.561015] EXT4-fs (sda8): mounted filesystem with ordered data mode. Opts: (null)
</code></pre>
<p>输出时间戳是从上电开始，到当前的时间，以秒为单位。</p>
<h2 id="调试S4-hang"><a href="#调试S4-hang" class="headerlink" title="调试S4 hang"></a>调试S4 hang</h2><p>在测试中发现，nvme存储设备，首次进入S4的时间较长，约30s, 且系统处于hang状态，鼠标无法移动。<br>dmesg查看单次S4 enter &amp; resume的过程，log如下</p>
<pre><code>[   43.090180] PM: hibernation entry          //开机43秒进s4流程
[   43.090579] PM: Syncing filesystems ...   
[   43.090682] PM: done.
[   43.090684] Freezing user space processes ... (elapsed 0.003 seconds) done.   //冻结用户进程，这个时候会hang
[   43.093699] OOM killer disabled.
[   43.093876] PM: Marking nosave pages: [mem 0x00000000-0x00000fff]       //准备哪些内存要转存到disk
[   43.093878] PM: Marking nosave pages: [mem 0x0005f000-0x0005ffff]
[   43.093880] PM: Marking nosave pages: [mem 0x000a0000-0x000fffff]
[   43.093887] PM: Marking nosave pages: [mem 0x80185000-0x80186fff]
[   43.093889] PM: Marking nosave pages: [mem 0x88c4f000-0x890acfff]
[   43.093944] PM: Marking nosave pages: [mem 0x89214000-0x89efefff]
[   43.094102] PM: Marking nosave pages: [mem 0x89f00000-0xffffffff]
[   43.098151] PM: Basic memory bitmaps created
[   43.098541] PM: Preallocating image memory... 
[   43.143802] hpet_rtc_timer_reinit: 29 callbacks suppressed
[   43.143803] hpet1: lost 2 rtc interrupts
[   43.197779] hpet1: lost 2 rtc interrupts
[   43.251708] done (allocated 333315 pages)               //分配内存侧的交换页
[   43.251709] PM: Allocated 1333260 kbytes in 0.15 seconds (8888.40 MB/s)
[   43.251710] Freezing remaining freezable tasks ... (elapsed 0.126 seconds) done.
[   43.379023] printk: Suspending console(s) (use no_console_suspend to debug)
[   43.381268] serial 00:02: disabled
[   43.382187] parport_pc 00:01: disabled
[   43.701432] ACPI: Preparing to enter system sleep state S4  //准备进S4, 关CPU, 中断，
[   44.400195] PM: Saving platform NVS memory
[   44.404308] Disabling non-boot CPUs ...
[   44.404935] IRQ 123: no longer affine to CPU1
[   44.404942] IRQ 132: no longer affine to CPU1
[   44.405979] smpboot: CPU 1 is now offline
[   44.410695] smpboot: CPU 2 is now offline
[   44.414738] IRQ 122: no longer affine to CPU3
[   44.415784] smpboot: CPU 3 is now offline
[   44.422078] PM: Creating hibernation image:           //准备创建disk映像
[   44.503241] PM: Need to copy 330336 pages
[   44.503242] PM: Normal pages needed: 330336 + 1024, available pages: 1731140
                                                                                       //磁盘写入操作和时间没有记录
[   44.901845] PM: free pages cleared after restore    //S4已被唤醒，这里不是绝对时间，S4休眠时间未记入
[   44.901889] PM: Restoring platform NVS memory  
[   44.903440] Enabling non-boot CPUs ...
[   44.903474] x86: Booting SMP configuration:
[   44.903474] smpboot: Booting Node 0 Processor 1 APIC 0x2
[   44.904974]  cache: parent cpu1 should not be sleeping
[   44.905085] CPU1 is up
[   44.905101] smpboot: Booting Node 0 Processor 2 APIC 0x4
[   44.905478]  cache: parent cpu2 should not be sleeping
[   44.905602] CPU2 is up
[   44.905618] smpboot: Booting Node 0 Processor 3 APIC 0x6
[   44.905995]  cache: parent cpu3 should not be sleeping
[   44.906125] CPU3 is up
[   44.908816] ACPI: Waking up from system sleep state S4
[   45.003392] usb usb1: root hub lost power or was reset
[   45.003393] usb usb2: root hub lost power or was reset
[   45.006573] sd 0:0:0:0: [sda] Starting disk
[   45.006732] parport_pc 00:01: activated
[   45.008262] serial 00:02: activated
[   45.384656] ata1: SATA link up 3.0 Gbps (SStatus 123 SControl 300)
[   45.384717] ata2: SATA link down (SStatus 4 SControl 300)
[   45.384741] ata3: SATA link down (SStatus 4 SControl 300)
[   45.384758] ata6: SATA link down (SStatus 4 SControl 300)
[   45.384779] ata5: SATA link down (SStatus 4 SControl 300)
[   45.384798] ata4: SATA link down (SStatus 4 SControl 300)
[   45.387712] ata1.00: configured for UDMA/100
[   45.500662] usb 1-9: reset low-speed USB device number 2 using xhci_hcd
[   46.056539] usb 1-10: reset low-speed USB device number 3 using xhci_hcd
[   46.318112] nvme nvme0: 4/0/0 default/read/poll queues
[   46.336791] nvme nvme0: ctrl returned bogus length: 2 for NVME_NIDT_EUI64
[   46.363904] acpi LNXPOWER:07: Turning OFF
[   46.363916] acpi LNXPOWER:06: Turning OFF
[   46.364472] PM: Basic memory bitmaps freed
[   46.364474] OOM killer enabled.
[   46.364475] Restarting tasks ... done.   //恢复进程
[   47.098831] e1000e: eno1 NIC Link is Up 100 Mbps Full Duplex, Flow Control: None
[   47.098837] e1000e 0000:00:1f.6 eno1: 10/100 speed: disabling TSO
[   49.489104] video LNXVIDEO:00: Restoring backlight state
[   49.489109] PM: hibernation exit    //S4退出完成
</code></pre>
<p>比较奇怪的是，dmesg没记录写磁盘的操作,时间戳上也反映不出来。可能这时候IO交给DMA了，kernel就挂起了，所以dmesg无法工作，包括时间戳记录？？<br>为了验证S4 hang原因在于写磁盘，对不同SSD做读写测速：</p>
<pre><code>DISK               :         R/W speed MB/s   :       S4 hang time
Samsung SATA SSD   :         567/529          :       4s
Our SSD            :         170.1/104.7      :       25s
</code></pre>
<p>基本验证读写速度和S4 hang是线性关系。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：判断语句if-then-else-fi</title>
    <url>/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>shell中if-then-else-fi判断语句如下：</p>
<pre><code>a=&quot;abc&quot;

if [ $a = &quot;abc&quot; ]
then
   echo &quot;$a = $b&quot;
else
   echo &quot;$a != $b&quot;
fi
</code></pre>
<p>注意以下几点：</p>
<ul>
<li>shell中的等号：<code>=</code>可用于赋值，也可以用于判断；<code>==</code>只用于判断，更规范</li>
<li>shell中的if语句各符号间都要空格分隔：<code>if</code>和<code>[ ]</code>之间要空格；<code>[ ]</code>和<code>“ ”</code>之间要空格； <code>&quot;</code>和<code>=</code>之间要空格。否则if语句中的符号会解析失败。</li>
<li>shell变量没有数据类型的区分，把任何存储在变量中的值，皆视为“字符串”</li>
<li>对于变量可能为空的情况，需要用双括号<code>[[ $a = &quot;abc&quot; ]]</code></li>
<li>if-then可以写在同一行，用;分隔两个语句：<code>if [ $a = &quot;abc&quot; ];then</code></li>
</ul>
<h1 id="不同类型的判断语句"><a href="#不同类型的判断语句" class="headerlink" title="不同类型的判断语句"></a>不同类型的判断语句</h1><h2 id="关系运算符判断"><a href="#关系运算符判断" class="headerlink" title="关系运算符判断"></a>关系运算符判断</h2><p>-eq    检测两个数是否相等，相等返回 true。    [ $a -eq $b ] 返回 false。</p>
<p>-ne    检测两个数是否不相等，不相等返回 true。    [ $a -ne $b ] 返回 true。</p>
<p>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ] 返回 false。</p>
<p>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ] 返回 true。</p>
<p>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。    [ $a -ge $b ] 返回 false。</p>
<p>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。    [ $a -le $b ] 返回 true。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>
<h2 id="布尔和逻辑运算符判断"><a href="#布尔和逻辑运算符判断" class="headerlink" title="布尔和逻辑运算符判断"></a>布尔和逻辑运算符判断</h2><p>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ] 返回 true。</p>
<p>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ] 返回 true。</p>
<p>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a == $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>
<p>&amp;&amp;    逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</p>
<p>||    逻辑的 OR    [[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<pre><code>#!/bin/bash

a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>
<h2 id="字符串运算符判断"><a href="#字符串运算符判断" class="headerlink" title="字符串运算符判断"></a>字符串运算符判断</h2><p>&#x3D;    检测两个字符串是否相等，相等返回 true。    [ $a &#x3D; $b ] 返回 false。</p>
<p>!&#x3D;    检测两个字符串是否相等，不相等返回 true。    [ $a !&#x3D; $b ] 返回 true。</p>
<p>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。  </p>
<p>-n    检测字符串长度是否不为 0，不为 0 返回 true。    [ -n “$a” ] 返回 true。</p>
<p><code>$</code> 检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。</p>
<pre><code>#!/bin/bash

a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a != $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a = $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n &quot;$a&quot; ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>
<h2 id="文件检查运算符判断"><a href="#文件检查运算符判断" class="headerlink" title="文件检查运算符判断"></a>文件检查运算符判断</h2><p>b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ] 返回 false。</p>
<p>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -c $file ] 返回 false。</p>
<p>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ] 返回 false。</p>
<p>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。</p>
<p>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] 返回 false。</p>
<p>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。</p>
<p>-p file    检测文件是否是有名管道，如果是，则返回 true。    [ -p $file ] 返回 false。</p>
<p>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。</p>
<p>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。</p>
<p>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。</p>
<p>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。</p>
<p>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。</p>
<p>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。</p>
<p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。</p>
<pre><code>#!/bin/bash

file=&quot;/root/test.sh&quot;

if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>
<h1 id="判断语句报错：”unary-operator-expected”"><a href="#判断语句报错：”unary-operator-expected”" class="headerlink" title="判断语句报错：”unary operator expected”"></a>判断语句报错：”unary operator expected”</h1><p>在匹配字符串相等时，用了类似这样的语句：</p>
<pre><code>if [ $STATUS == &quot;OK&quot; ]; then     
echo &quot;OK&quot;
fi
</code></pre>
<p>在运行时出现了 <code>[: =: unary operator expected</code> 的错误</p>
<pre><code>if [[ $STATUS == &quot;OK&quot; ]]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>究其原因，是因为如果变量STATUS值为空，那么就成了 [ &#x3D; “OK”] ，显然 [ 和 “OK” 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。<br>或者用下面的方法也能避免这种错误：</p>
<pre><code>if [ &quot;$STATUS&quot;x == &quot;OK&quot;x ]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>当然，x也可以是其他字符。shell中有没有双引号在很多情况下是一致的,因此x可以不加引号。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：实现芯片固件的批量编译</title>
    <url>/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某软件有不同的配置参数，实现不同功能版本的编译<br>批量测试需要批量编译各种版本，实现方式为：<br>1.将编译参数组合，生成大量配置文件<br>2.编译过程遍历这些配置文件，依次编译对应版本<br>3.有参数加入，修改，删除，只需要更新这些配置文件<br>如何实现这些配置文件的更新？</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某芯片的Firmware批量编译实现：<br>Firmware代码为C, 配置参数用宏实现，后缀为.def<br>目录结构如下</p>
<p>|–project_folder<br>　　|–config<br>　　　|–build.def<br>　　　|–defs<br>　　　　　|–1.def 2.def … n.def<br>　　|–src<br>　　|–Makefile<br>　　|–build_All.sh<br>　　|–update.sh</p>
<h2 id="批量编译脚本"><a href="#批量编译脚本" class="headerlink" title="批量编译脚本"></a>批量编译脚本</h2><p>批量编译脚本如下<br>基本过程：<br>1.依次拷贝def文件夹中的每个def，替换默认的build.def<br>2.编译，接受所有编译参数<br>3.拷贝编译输出的image到包含git tag, def名，时间等信息的文件夹</p>
<pre><code>#!/bin/bash

echo &quot;Batch build support args:&quot;
echo &quot;1. functin version:&quot;
echo &quot;verargs=mp_fpga&quot;
echo &quot;verargs=mpw_asic&quot;
echo &quot;2. boot debug:&quot;
echo &quot;bootargs=debug&quot;

OUTPUT=batch_build_$1$2

mkdir -p $&#123;OUTPUT&#125;
rm -rf ./batch_build_*

build_time=`date +%Y%m%d%H%M%S`

#commit_id=`git rev-parse HEAD`

tag_name=`git describe --exact-match --tags 2&gt;/dev/null`

if [ -z &quot;$&#123;tag_name&#125;&quot; ]; then
    tag_name=&quot;NO_TAG&quot;
fi

mv ./config/build.def ./config/build.def.bak 

for file in `ls ./config/defs/*.def`;
do
    file_name=$&#123;file##*/&#125;
    config_name=$&#123;file_name%.def&#125;
    
    cp -rf $&#123;file&#125; ./config/build.def
    make clean
    make -j4 $@
    #mv ./build/image ./batch_build/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;_cid_$&#123;commit_id&#125;
    mkdir -p ./$&#123;OUTPUT&#125;/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;
    mv ./build/image/* ./$&#123;OUTPUT&#125;/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;
done

mv ./config/build.def.bak ./config/build.def
</code></pre>
<p>def文件内的.def文件即各种参数配置文件，.def文件名即参数功能的别名组合<br>例如：</p>
<pre><code>CQ_emmc_two_card_enhance_hs400_always_l0_MSIx_dllphase14_tuning_on.def
</code></pre>
<p>对应的内容是：</p>
<pre><code>/*0: Non-CQ mode 1:CQ mode enable*/
#define BB_CQ_MODE_ENABLE 1
/*the card number support emmc#0:0 emmc#1:1 two card:2*/
#define BB_CARD_NUMBER 2
/*0:legacy 1:High Speed 50MHz 2:HS200 3:HS400 4:Enhance HS400*/
#define BB_MAX_TRANSFER_MODE 4
/* power mode management: 0: Low Power 1:Balance 2:High Performance 3:Direct HP 4:Always L0*/
#define POWER_MANAGEMENT_MODE 4
/* INT_MODE: 0:MSI_X 1:INTx 2:MSI_MULTIPLE 3:MSI_SINGLE */
#define INT_MODE 0
/* The selection of DLL PHASE COUNT is 11 or 14 */
#define DLL_phase_cnt 14
/* 0: fixed output phase  1: auto output tuning */
#define AUTO_OUTPUT_TUNING 1
</code></pre>
<h2 id="批量编辑配置文件"><a href="#批量编辑配置文件" class="headerlink" title="批量编辑配置文件"></a>批量编辑配置文件</h2><p>配置文件def有两个属性<br>1.文件名每个词代表一个功能，各词用下划线“_”分隔<br>2.内部用宏定义实现功能配置，宏定义的值要和外部文件名匹配</p>
<p>基于以上属性，编辑脚本需求为：<br>1.新增：增加一个宏定义，并增加对应的功能缩写到文件名<br>2.修改：修改一个已存在的宏定义，并修改对应的功能缩写到文件名<br>3.删除：删除一个已存在的宏定义，并删除对应的功能缩写到文件名<br>4.其他功能，如直接删除含某缩写的文件，备份原配置文件</p>
<p>shell实现为update.sh,如下:</p>
<pre><code>#!/bin/bash

DEFS_PATH=&quot;./config/defs&quot;
DEFS_BACKUP_PATH=&quot;./config/defs_backup&quot;
DEFS_TEMP_PATH=&quot;./config/defs_temp&quot;

if [ $# -lt 1 ];then
        echo &quot;usage: ./update.sh [option] [args]&quot;

        echo &quot;example 0:&quot;
        echo &quot;        backup defs files:&quot;
        echo &quot;        ./update.sh -bf&quot;
        echo &quot;&quot;

        echo &quot;example 1:&quot;
        echo &quot;        add a macro name and macro value to defs, and add file postfix:&quot;
        echo &quot;        ./update.sh -b&quot;
        echo &quot;        ./update.sh -a balance POWER_MANAGEMENT_MODE 1 &quot;
        echo &quot;        ./update.sh -a high_performance POWER_MANAGEMENT_MODE 2 &quot;
        echo &quot;        add other values...&quot;
        echo &quot;&quot;

        echo &quot;example 2:&quot;
        echo &quot;        update a macro name and macro value to defs, and update file postfix:&quot;
        echo &quot;        ./update.sh -u balance lowpower POWER_MANAGEMENT_MODE 1 &quot;
        echo &quot;&quot;

        echo &quot;example 3:&quot;
        echo &quot;        delete a macro name and macro value of defs, and delete file postfix:&quot;
        echo &quot;        ./update.sh -d lowpower POWER_MANAGEMENT_MODE&quot;
        echo &quot;&quot;

        echo &quot;example 4:&quot;
        echo &quot;        delete target files:&quot;
        echo &quot;        ./update.sh -df lowpower&quot;
        echo &quot;&quot;

        echo &quot;example 5:&quot;
        echo &quot;        clean backup defs files:&quot;
        echo &quot;        ./update.sh -cf&quot;
        echo &quot;&quot;

        exit;
    fi

if [ $1 = &quot;-bf&quot; ];then #backup defs
    mkdir -p $DEFS_BACKUP_PATH
    mv $DEFS_PATH/*.def $DEFS_BACKUP_PATH

elif [ $1 = &quot;-cf&quot; ];then #clear backup defs
    rm -rf $DEFS_BACKUP_PATH
</code></pre>
<p>​<br>​    #add a macro name and macro value to defs, and add file postfix<br>​    elif [ $1 &#x3D; “-a” ];then<br>​<br>        if [ $# !&#x3D; 4 ];then<br>            echo “usage: .&#x2F;update.sh -a FILE_POSTFIX MACRO_NAME MACRO_VALUE”<br>            exit;<br>        fi</p>
<pre><code>    mkdir -p $DEFS_TEMP_PATH &amp;&amp; cp -rf $DEFS_BACKUP_PATH/*.def $DEFS_TEMP_PATH
    
    FILE_POSTFIX=$2
    MACRO_NAME=$3
    MACRO_VALUE=$4
    # sed -i makes change on original file, otherwise on stream
    # xargs transfer multiple output from stream to multiple args to sed
    find $&#123;DEFS_TEMP_PATH&#125; -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
    
    for file in `ls $&#123;DEFS_TEMP_PATH&#125;/*.def`
    do
     mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
    done
    
    cp -rf $DEFS_TEMP_PATH/*.def $DEFS_PATH
    rm -rf $DEFS_TEMP_PATH

#update a macro name and macro value to defs, and update file postfix
elif [ $1 = &quot;-u&quot; ];then

    if [ $# != 5 ];then
        echo &quot;usage: ./update.sh -u ORIGIN_POSTFIX UPDATED_POSTFIX MACRO_NAME MACRO_UPDATED_VALUE&quot;
        exit;
    fi

    ORIGIN_POSTFIX=$2
    UPDATED_POSTFIX=$3
    MACRO_NAME=$4
    MACRO_UPDATED_VALUE=$5

    #replace all lines that pattern matches $MACRO_NAME
    find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
    #update file postfix
    for file in `ls $&#123;DEFS_PATH&#125;/*$ORIGIN_POSTFIX*.def`
    do
         mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
    done
</code></pre>
<p>​<br>​    #delete a macro name and macro value of defs, and delete file postfix<br>​    elif [ $1 &#x3D; “-d” ];then<br>​<br>        if [ $# !&#x3D; 3 ];then<br>            echo “usage: .&#x2F;update.sh -d DELETE_POSTFIX MACRO_NAME”<br>            exit;<br>        fi</p>
<pre><code>    DELETE_POSTFIX=$2
    MACRO_NAME=$3
    #delete all lines that contain $MACRO_NAME
    find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
    #delete file postfix
    for file in `ls $&#123;DEFS_PATH&#125;/*.def`
    do
         mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
    done

#delete target file by postfix
elif [ $1 = &quot;-df&quot; ];then
    
    if [ $# != 2 ];then
        echo &quot;usage: ./update.sh -df DELETE_POSTFIX&quot;
        exit;
    fi

    DELETE_POSTFIX=$2
    rm -f $&#123;DEFS_PATH&#125;/*$DELETE_POSTFIX*.def

fi
</code></pre>
<p><strong>重点讲下其中的几个sed和文件操作</strong><br>1.多个文件，每个文件最后一行追加内容</p>
<pre><code>find $&#123;DEFS_TEMP_PATH&#125; -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
</code></pre>
<ul>
<li>xargs的作用： find <path> -name <string> 输出的是多个文件名，不能直接传给sed， <strong>xargs将多个文件名转化成多个参数</strong>，每个参数是一个文件名，sed可以接收</li>
<li>-i的作用：sed本身是在文件的拷贝上操作，不直接在文件本身修改，-i（insert）使sed的操作在文件上生效，<strong>如果不加-i，源文件不会被修改</strong></li>
<li>$：表示最后一行，sed ‘a\string’是基础格式</li>
<li>注意sed怎么用带空格和变量的字符串：<strong>空格用转义’\ ‘表示，变量是单引号内加双引号</strong>，即’”$ARG”‘</li>
</ul>
<p>2.找到包含字符串A的所有文件，替换内容：将字符串B替换为C</p>
<pre><code>#replace all lines that pattern matches $MACRO_NAME
find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
</code></pre>
<ul>
<li>find | grep 是常用套路，先找在过滤，注意find -name 可以使用*， grep不要用*，否则grep会把它当成要匹配的字符</li>
<li>sed ‘s&#x2F;stringB&#x2F;stringC’是基础格式，g表示全局，注意要-i</li>
</ul>
<p>3.找到包含字符串A的所有文件，删除内容：包含字符串B的行</p>
<pre><code>#delete all lines that contain $MACRO_NAME
find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
</code></pre>
<p>4.对多个文件的文件名，增加，修改，删除特定字符串</p>
<pre><code>#在原文件名最后，后缀之前，增加字符串“_$FILE_POSTFIX”
for file in `ls $&#123;DEFS_TEMP_PATH&#125;/*.def`
    do
     mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
    done

#替换文件名中匹配的字符
for file in `ls $&#123;DEFS_PATH&#125;/*$ORIGIN_POSTFIX*.def`
do
     mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
done

#删除文件名指定字符
for file in `ls $&#123;DEFS_PATH&#125;/*.def`
do
     mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
done
</code></pre>
<ul>
<li>for &lt; args &gt; in `ls &lt; path &gt;`是把多个文件名依次写入变量args的常用操作，类似于xargs，不过是用循环每次处理一个文件名变量</li>
<li>mv $file `echo $file | sed ‘s&#x2F;stringA&#x2F;stringB&#x2F;g’&#96;实际是两个步骤：先用echo把当前处理的文件名传给sed, sed处理完的输出文件名，作为mv的目标文件名，覆盖了原文件</li>
<li>注意，文件名xargs传给sed,处理的是文件内容，for-in-do一个个mv，才是处理文件名本身</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://linux.cn/article-11367-1.html">使用 sed 命令查找和替换文件中的字符串的 16 个示例</a><br><a href="https://blog.csdn.net/weixin_40572607/article/details/90812959">sed引入变量的几种方法</a><br><a href="https://blog.csdn.net/elong490/article/details/52587171">sed 批量替换文件内容</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：文本编辑利器sed+awk+grep</title>
    <url>/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/</url>
    <content><![CDATA[<h1 id="shell增删改查概述"><a href="#shell增删改查概述" class="headerlink" title="shell增删改查概述"></a>shell增删改查概述</h1><p>Linux Shell环境对文本增删改查，可以通过sed，awk和grep命令完成。</p>
<ul>
<li>sed: 支持特定模式匹配的增加、插入、删除、替换、提取等操作</li>
<li>awk: 支持特定模式匹配的过滤查找，如提取某行列的字符串</li>
<li>grep: 支持包含特定字符串的结果提取，可配合find和awk实现过滤查找</li>
</ul>
<p>这几种命令都支持流输入和文本输入，支持管道传递参数，也可以命令行传参。对于多个步骤的处理，可以几个命令串行使用。</p>
<h1 id="shell的输入参数概述"><a href="#shell的输入参数概述" class="headerlink" title="shell的输入参数概述"></a>shell的输入参数概述</h1><p>Shell的命令，如<code>cat, echo, sed, awk, grep</code>, 管道命令<code>|</code>等，都要有输入参数，即待处理的数据。<br>输入参数有两种类型：</p>
<ul>
<li>标准输入：本质是stdin文件，即读取该文件的内容作为命令的输入参数，该文件内容可由其他命令的输出，或者用户输入来产生</li>
<li>命令行输入：直接接受用户在命令行输入的字符串，一次性使用,不存储在stdin</li>
</ul>
<p>支持标准输入作为参数的命令：<code>cat, sed, awk, grep, |</code> 等<br>只支持命令行输入字符串的命令：<code>echo, ls</code>等<br>标准输入示例：</p>
<pre><code>cat /etc/passwd | grep root
</code></pre>
<p>上面的代码使用了管道命令<code>|</code>，管道命令的作用是将左侧命令<code>cat /etc/passwd</code>的标准输出转换为标准输入，提供给右侧命令<code>grep root</code>作为参数。<br>以上命令也可以写成命令行输入形式：</p>
<pre><code>grep root /etc/passwd
</code></pre>
<p>不支持标准输入的示例：</p>
<pre><code>echo &quot;hello world&quot; | echo
</code></pre>
<p>输出为空，管道右侧的echo不接受管道传来的标准输入作为参数。<br>xargs的作用：将标准输入转为命令行参数</p>
<pre><code>echo &quot;hello world&quot; | xargs echo
</code></pre>
<p>输出“hello world”，xargs和管道配合使用，能使管道也支持非标准输入命令。<br>xargs支持一些选项做进一步细化处理，如-p(打印), -d(分割) 等。</p>
<h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><h2 id="sed命令概述"><a href="#sed命令概述" class="headerlink" title="sed命令概述"></a>sed命令概述</h2><p>sed支持文本编辑，实现增、删、改的功能。<br>sed命令格式：</p>
<pre><code>sed [options] &#39;command&#39; filename
</code></pre>
<p>sed的输入参数可以用命令行，管道和xargs传入：</p>
<pre><code>//命令行传入文件名参数
sed [options] &#39;command&#39; filename 
//管道传入文件名参数
cat filename | sed [options] &#39;command&#39;
//xargs传入文件名参数
cat filename | xargs sed [options] &#39;command&#39;
</code></pre>
<p>sed对文件的编辑在缓冲区，不直接修改文本。要直接修改文本有以下方法：</p>
<ul>
<li>重定向覆盖文本， <code>sed - x &#39;XXX&#39; file.txt &gt; file.txt</code></li>
<li>特定的sed命令支持直接修改文本，如<code>sed -i &#39;XXX&#39; file.txt</code></li>
</ul>
<p>sed的常用选项：</p>
<pre><code>-n ：关闭默认输出,只显示匹配的行
-i ：直接修改读取的文件内容，而不是输出到终端。
-e ：直接在命令列模式上进行sed的动作编辑；
-f ：直接将sed的动作写在一个文件内，-f filename 则可以运行filename内的sed动作；
-r ：启用扩展的正则表达式
</code></pre>
<p>sed的常用命令：</p>
<pre><code>a ：新增行，在指定行的后面附加一行，[address]a\新文本内容
i ：插入行，在指定行的前面插入一行，[address]i\新文本内容
s ：替换特定模式匹配的字符串, [address]s/pattern/replacement/flags
c ：将指定行中的所有内容，替换成该选项后面的字符串, [address]c\用于替换的新文本
d ：删除行，[address]d
p ：打印， 通常与参数 -n 一起用，[address]p
w : 将文本中指定行的内容写入文件, [address]w filename
</code></pre>
<h2 id="sed命令详解"><a href="#sed命令详解" class="headerlink" title="sed命令详解"></a>sed命令详解</h2><p>本节从sed文本操作的“增删改查”举例说明其具体命令用法</p>
<h3 id="新增和插入：a和i"><a href="#新增和插入：a和i" class="headerlink" title="新增和插入：a和i"></a>新增和插入：a和i</h3><p>sed的命令a和i都能实现新增行，其区别在于：</p>
<ul>
<li>a ：append, 指定行后面新增一行</li>
<li>i : insert, 表示在指定行前面插入一行</li>
</ul>
<p>注意区分i命令和i选项<br>a和i命令的基本格式完全相同：</p>
<pre><code>[address]a（或 i）\新文本内容
</code></pre>
<p>将一个新行插入到数据流第三行前：</p>
<pre><code>sed &#39;3i\This is an inserted line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is an inserted line.
This is line number 3.
This is line number 4.
</code></pre>
<p>将一个新行附加到数据流中第三行后:</p>
<pre><code>sed &#39;3a\This is an appended line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is line number 3.
This is an appended line.
This is line number 4.
</code></pre>
<p>将一个多行数据添加到数据流中，只需对要行末尾添加反斜线即可，类似C语言的代码换行</p>
<pre><code>sed &#39;1i\
This is one line of new text.\
This is another line of new text.&#39; data6.txt

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
</code></pre>
<h3 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h3><ul>
<li>d: delete, 删除行</li>
</ul>
<p>格式：</p>
<pre><code>[address]d
</code></pre>
<p>删除第三行：</p>
<pre><code>[root@localhost ~]# cat data6.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
[root@localhost ~]# sed &#39;3d&#39; data6.txt
This is line number 1.
This is line number 2.
This is line number 4.
</code></pre>
<p>删除二、三行：</p>
<pre><code>sed &#39;2,3d&#39; data6.txt
This is line number 1.
This is line number 4.
</code></pre>
<p>删除第三行开始的后续所有行：</p>
<pre><code>[root@localhost ~]# sed &#39;3,$d&#39; data6.txt
This is line number 1.
This is line number 2.
</code></pre>
<p>注意：sed d 命令并不会修改原始文件，这里被删除的行只是从 sed 的缓冲区中消失了，原始文件没做任何改变，若要修改源文件，可重定向sed的输出到源文件，覆盖原内容使修改生效。</p>
<h3 id="匹配定位：-x2F-pattern-x2F"><a href="#匹配定位：-x2F-pattern-x2F" class="headerlink" title="匹配定位：&#x2F;pattern&#x2F;"></a>匹配定位：&#x2F;pattern&#x2F;</h3><p>sed的增删操作，可以针对包含匹配字符串的行进行操作，其原理是活用[address], 支持匹配字符串的定位，以插入命令’i’为例，匹配格式如下：</p>
<pre><code>sed [option] &#39;/匹配字符串/i \插入字符串&#39;
[option] 通常为 -i, 修改直接在源文件生效
</code></pre>
<p>原文件：</p>
<pre><code>cat testfile 
hello
</code></pre>
<p>在包含”hello”的一行的上一行，插入”upline”:</p>
<pre><code>sed -i &#39;/hello/i\upline&#39; testfile
</code></pre>
<p>“hello”下一行插入”upline”:</p>
<pre><code>sed -i &#39;/hello/a\down&#39; testfile
</code></pre>
<p>修改后的文件：</p>
<pre><code>cat testfile 
up
hello
down
</code></pre>
<p>删除匹配到”hello”的行：</p>
<pre><code>sed -i &#39;/hello/d&#39; testfile
</code></pre>
<p>如果匹配字符串有“&#x2F;”，为了和sed命令的分隔符“&#x2F;”，使用“\”转义。<br>例如删除匹配某个路径字符串的行：</p>
<pre><code>匹配&quot;\etc\install.sh&quot;
set -i &#39;/\/etc\/install.sh/d&#39; test.txt
</code></pre>
<p>sed 命令包含一些预定义特殊符号，代表行尾，行首等。<br>删除以A开头的行：</p>
<pre><code>sed -i &#39;/^A.*/d&#39; test.txt
^A表示开头是A, .*表示后跟任意字符串
</code></pre>
<p>在行尾追加一行内容:</p>
<pre><code>sed -i &#39;$a\added-content&#39; test.txt
$表示定位到行尾，a是追加命令，added-content是追加内容
</code></pre>
<h3 id="替换修改-s"><a href="#替换修改-s" class="headerlink" title="替换修改: s"></a>替换修改: s</h3><p>s替换命令内部格式为：</p>
<pre><code>[address]s/pattern/replacement/flags
</code></pre>
<ul>
<li>address 指定要操作的具体行</li>
<li>pattern 指定需要替换的内容</li>
<li>replacement 指定替换的新内容</li>
<li>flags 指定特殊功能</li>
</ul>
<p>常用的flags:</p>
<ul>
<li>n    1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换</li>
<li>g    对数据中所有匹配到的内容进行替换，否则只会在第一次匹配成功时做替换操作</li>
<li>p    会打印与替换命令中指定的模式匹配的行。此标记通常与 -n    选项一起使用</li>
<li>\    转义（转义替换部分包含：&amp;、\ 等）。</li>
</ul>
<p>替换每行第二个匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/2&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the trial script
This is second test of the trial script
</code></pre>
<p>只替换第二行的匹配字符串：</p>
<pre><code>sed &#39;2s/test/trial/&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the test script
This is second test of the trial script
</code></pre>
<p>全局替换所有匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/g&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first trial of the trial script
This is second trial of the trial script
</code></pre>
<h3 id="提取：p"><a href="#提取：p" class="headerlink" title="提取：p"></a>提取：p</h3><p>sed p命令配合字符串匹配，可以输出包含指定字符串的行内容。</p>
<pre><code>sed -n &#39;/string/p&#39; filename
提取filename文件中,所有包含string的行的内容，并打印到标准输出
-n是只打印匹配命中的内容
</code></pre>
<p>sed p和grep都能提取内容，其区别在于：</p>
<ul>
<li><code>sed &#39;/string/p&#39;</code>是提取指定文件的行内容，重点在内容提取</li>
<li><code>grep &quot;string&quot; path</code>是输出包含指定内容的所有文件路径，重点在查找文件位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452182.png" alt="image-20221205145238133"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452191.png" alt="image-20221205145248149"></p>
<h2 id="sed进阶与实战"><a href="#sed进阶与实战" class="headerlink" title="sed进阶与实战"></a>sed进阶与实战</h2><h3 id="多文件批量追加和删除"><a href="#多文件批量追加和删除" class="headerlink" title="多文件批量追加和删除"></a>多文件批量追加和删除</h3><p>背景介绍：<br>底层固件代码有一些功能由宏定义控制，不同功能需要不同的宏定义组合，因此有不同的宏定义文件，命名为.def后缀。批量编译不同版本，编译脚本依次提取def文件夹内的.def文件和源代码一起编译。单个def内容如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453765.png" alt="image-20221205145321718"></p>
<p>每一个宏都有多个取值，因此组合起来，需要生成一堆.def文件，批量编译才能覆盖各自功能。<br>每新增一个宏，都要修改所有.def文件，如果这个宏有两个取值，.def文件数量将翻倍。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453942.png" alt="image-20221205145327892"></p>
<p>人工修改过于低效，使用sed可解决此问题。</p>
<p>查找指定文件，并批量追加一行内容：</p>
<pre><code>find . -name &#39;*.def*&#39; | xargs sed -i &#39;$a\added-content&#39;
</code></pre>
<p>各命令含义：</p>
<pre><code>find [path] -name &quot;*.def&quot;
查找path路径下，以.def结尾的所有文件，结果存储在stdout
|
管道，将查找结果转存到标准输入stdin
xargs
查找结果有很多个，用xargs转成命令行输入，sed才能批量处理
sed -i &#39;$a\added-content&#39;
    -i 直接修改文件，&#39;$a\added-content&#39; 最后一行追加added-content
</code></pre>
<p>查找指定文件，并批量删除匹配某字符串的行：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/deleteString/d&quot;
</code></pre>
<p>查找指定文件，并批量替换匹配某字符串：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/oldString/newString/&quot;
</code></pre>
<p>在实际shell脚本中，通常由用户输入变量，<code>$1, $2, $@</code> 解析变量。a、i、d和s能否在命令中使用双引号解析变量，实现动态编辑？<br>实验如下：</p>
<pre><code>ARGS=&quot;AA BB&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$a\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$i\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/$&#123;ARGS&#125;/d&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/aabb/$ARGS/&quot;
</code></pre>
<ul>
<li>i 和 a 命令不能解析变量，实际追加的就是是${ARGS}</li>
<li>d命令可以解析变量，实际删除的是有”AA BB”的行</li>
<li>s命令可以解析变量，实际替换后的结果是”AA BB”</li>
</ul>
<p>结论：将命令中的单引号改成双引号，理论上可以解析$包含的变量，实际上有的命令支持，有的命令不支持。</p>
<h3 id="提取文件中的关键内容"><a href="#提取文件中的关键内容" class="headerlink" title="提取文件中的关键内容"></a>提取文件中的关键内容</h3><p>背景介绍：<br>底层固件需要将代码段、数据段等关键信息存储在固件头部，编译过程中用编译器的size命令可以获取这些信息，并存储到文本，但是固件头部需要按自己的格式存储起始地址和大小信息，因此需要用sed提取并编辑该文本。</p>
<p>原文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453983.png" alt="image-20221205145348933"></p>
<p>提取后文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453414.png"></p>
<p>sed命令：</p>
<pre><code>sed -n &#39;/string/p&#39; oldFile | awk &#39;&#123;print $3&#125;&#39; &gt;&gt; newFile
提取oldFile内包含string的行，并用awk提取第三列，再写入newFile
</code></pre>
<p>该命令在Makefile实现，需要根据Makefile和shell特性做修改：</p>
<ul>
<li>@：编译过程隐藏命令输出，类似于后台执行</li>
<li>$(shell xxxx): Makefile执行shell命令</li>
<li>$$: Makefile不能直接用shell的“$”解析变量，用“$$”</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051454928.png" alt="image-20221205145409877"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令行笔记</title>
    <url>/2020/02/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="查找包含指定内容的文件"><a href="#查找包含指定内容的文件" class="headerlink" title="查找包含指定内容的文件"></a>查找包含指定内容的文件</h1><pre><code>grep -r 字符串 目录
</code></pre>
<p>示例：查找当前目录的包含“stream”内容的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -r &quot;stream&quot; ./</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux驱动分析：MMC子系统</title>
    <url>/2023/01/31/Linux%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90%EF%BC%9AMMC%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mmc</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC笔记：多线程磁盘读写测试工具</title>
    <url>/2021/03/18/MFC%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MFC（Microsoft Foundation Classes）是微软在win32 API上，用C++封装的GUI框架，在现在，MFC相比其他的GUI框架有些过时，可以参考：<br><a href="https://www.zhihu.com/question/327876401">很多人说 C++ 的 MFC 已经过时了，那新入门的人到底应该学什么？</a><br>不同环境的选择：</p>
<ul>
<li>跨平台： QT</li>
<li>C#: WPF</li>
<li>Web：React，Vue，Electron</li>
</ul>
<p>既然如此，为何本文用MFC？<br>1.部分功能从老MFC项目移植，且VS环境能快速上手<br>2.技术本身不会过时，过时的是应用场景，GUI回调式的交互机制，以及Win32线程和进程的使用都是通用的技术。这是写本文的原因</p>
<p>本文源码：<a href="https://github.com/cursorhu/myMFCForAutoRWTest.git">cursorhu&#x2F;myMFCForAutoRWTest</a></p>
<p>GUI界面：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051510224.png" alt="1"></p>
<h1 id="初识MFC项目"><a href="#初识MFC项目" class="headerlink" title="初识MFC项目"></a>初识MFC项目</h1><p>VS新建MFC项目，例如“myMFC”，目录结构如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514738.png" alt="2"><br>myMFC.cpp是VS自动创建的MFC项目入口，其主要功能是：创建一个窗口实例，注册会话对象（Dialog)<br>界面的交互一定是分层的</p>
<ul>
<li>对用户的是控件层，即各种按钮，输入输出框等可见可操作的东西</li>
<li>处理数据的是逻辑层，例如从输入框输入，底层保存该字符串，点击运行，底层开始执行对应函数</li>
</ul>
<p>在MFC中，会话对象就是处理底层逻辑的类对象，其方法定义在myMFCDlg.cpp<br>也是开发的主要内容</p>
<h2 id="MFC入口"><a href="#MFC入口" class="headerlink" title="MFC入口"></a>MFC入口</h2><p>下面介绍myMFC.cpp的MFC入口：</p>
<pre><code>BOOL CmyMFCApp::InitInstance()
&#123;
    // 如果一个运行在 Windows XP 上的应用程序清单指定要
    // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
    //则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
    INITCOMMONCONTROLSEX InitCtrls;
    InitCtrls.dwSize = sizeof(InitCtrls);
    // 将它设置为包括所有要在应用程序中使用的
    // 公共控件类。
    InitCtrls.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&amp;InitCtrls);

    CWinApp::InitInstance();
    
    AfxEnableControlContainer();

    // 创建 shell 管理器，以防对话框包含
    // 任何 shell 树视图控件或 shell 列表视图控件。
    CShellManager *pShellManager = new CShellManager;

    // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
    CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

    // 标准初始化
    // 如果未使用这些功能并希望减小
    // 最终可执行文件的大小，则应移除下列
    // 不需要的特定初始化例程
    // 更改用于存储设置的注册表项
    // TODO: 应适当修改该字符串，
    // 例如修改为公司或组织名
    SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;));

    CmyMFCDlg dlg;
    m_pMainWnd = &amp;dlg;
    INT_PTR nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    &#123;
        // TODO: 在此放置处理何时用
        //  “确定”来关闭对话框的代码
    &#125;
    else if (nResponse == IDCANCEL)
    &#123;
        // TODO: 在此放置处理何时用
        //  “取消”来关闭对话框的代码
    &#125;
    else if (nResponse == -1)
    &#123;
        TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;);
        TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;);
    &#125;

    // 删除上面创建的 shell 管理器。
    if (pShellManager != nullptr)
    &#123;
        delete pShellManager;
    &#125;

#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)
    ControlBarCleanUp();
#endif

    return FALSE;
&#125;
</code></pre>
<p>只需要关注这几句</p>
<pre><code>CmyMFCDlg dlg;
m_pMainWnd = &amp;dlg;
INT_PTR nResponse = dlg.DoModal();
</code></pre>
<p>CmyMFCDlg类是在myMFCDlg.cpp定义的，即底层逻辑类。m_pMainWnd是myMFC.cpp的CmyMFCApp类(继承win32 API)的成员，表示主窗口，这两句就是把会话对象注册到窗口类，这样窗口运行时可以回调会话对象的方法。dlg.DoModal()是运行会话窗口，运行哪个会话？其调用者CmyMFCDlg类对象dlg。</p>
<h2 id="MFC逻辑层"><a href="#MFC逻辑层" class="headerlink" title="MFC逻辑层"></a>MFC逻辑层</h2><p>VS自动创建myMFC项目的会话逻辑层，myMFCDlg.cpp<br>几个自动生成的方法如下，这里为了作为示例，加了自定义的类成员m_src, m_dst和方法OnBnClickedButtonsrc，OnBnClickedButtondst<br>(1)会话类构造函数</p>
<pre><code>CmyMFCDlg::CmyMFCDlg(CWnd* pParent /*=nullptr*/)
    : CDialogEx(IDD_MYMFC_DIALOG, pParent)
    , m_src(_T(&quot;&quot;)) //初始化为空串，_T是兼容不同编码的转换
    , m_dst(_T(&quot;&quot;))
&#123;
    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
&#125;
</code></pre>
<p>(2)界面和类成员数据关联</p>
<pre><code>void CmyMFCDlg::DoDataExchange(CDataExchange* pDX)
&#123;
    CDialogEx::DoDataExchange(pDX);
    DDX_Text(pDX, IDC_EDIT_src, m_src); //关联m_src和IDC_EDIT_src控件，该控件是界面输入框
    DDX_Text(pDX, IDC_EDIT_dst, m_dst);
&#125;
</code></pre>
<p>(3)界面和类方法的关联</p>
<pre><code>BEGIN_MESSAGE_MAP(CmyMFCDlg, CDialogEx)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_BUTTON_src, &amp;CmyMFCDlg::OnBnClickedButtonsrc) //关联IDC_BUTTON_src按钮和OnBnClickedButtonsrc方法
    ON_BN_CLICKED(IDC_BUTTON_dst, &amp;CmyMFCDlg::OnBnClickedButtondst)
END_MESSAGE_MAP()
</code></pre>
<p>类在头文件的定义：</p>
<pre><code>class CmyMFCDlg : public CDialogEx
&#123;
// 构造
public:
    CmyMFCDlg(CWnd* pParent = nullptr);    // 标准构造函数

// 对话框数据
#ifdef AFX_DESIGN_TIME
    enum &#123; IDD = IDD_MYMFC_DIALOG &#125;;
#endif

    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
    HICON m_hIcon;

    // 生成的消息映射函数
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    DECLARE_MESSAGE_MAP()
    
public:
    CString m_src; //CString: MFC的字符串类型
    CString m_dst;
    afx_msg void OnBnClickedButtonsrc(); //afx_msg: MFC的方法对应的消息响应类型
    afx_msg void OnBnClickedButtondst();
&#125;;
</code></pre>
<p>在VS环境下,这些变量和方法的定义都不需要写代码，在控件资源视图直接配置即可。</p>
<h2 id="界面资源层"><a href="#界面资源层" class="headerlink" title="界面资源层"></a>界面资源层</h2><p>注意项目文件有个Resource.h，包含界面相关的资源，如每个按钮有个ID，这个不要手动配置，在编辑UI控件时自动生成</p>
<pre><code>//&#123;&#123;NO_DEPENDENCIES&#125;&#125;
// Microsoft Visual C++ 生成的包含文件。
// 供 myMFC.rc 使用
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MYMFC_DIALOG                102
#define IDR_MAINFRAME                   128
#define IDC_BUTTON_src                  1000
#define IDC_BUTTON_dst                  1001
</code></pre>
<p>myMFC.rc是UI的资源文件，打开就是UI界面<br><img src="C:\Users\thomas.hu\Desktop\3.png" alt="3"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514703.png" alt="4"><br>可以看到界面的按钮，右键查看属性，可以修改标题和控件ID，会映射到Resource.h。双击按钮，myMFCDlg.cpp会自动创建方法<code>CmyMFCDlg::OnBnClickedButtondst()</code>，头文件自动加方法声明。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514147.png" alt="5"></p>
<p>前文的Dlg.cpp中的控件ID, dlg类的方法，变量，从一开始就可以从资源界面配置，自动生成：</p>
<ul>
<li>在资源界面选按钮或其他控件</li>
<li>右键配置控件ID</li>
<li>右键添加值变量或控件变量</li>
<li>双击添加方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515208.png" alt="6"><br>关于值变量和控件变量：<br>值变量用于关联界面和类成员，值变量就是类成员名，例如点击dst按钮调用其方法后，获得的路径，会写入m_dst值变量<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051512803.png" alt="7"><br>控件变量代表控件本身，用于底层逻辑中，直接调用控件的方法，例如控件变量叫dst_ctrl，可以在某个方法中<code>ctrl_dst.SetWindowText(_T(&quot;&quot;))</code>清空界面的字符串<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051512701.png" alt="8"></p>
<h1 id="简单拷贝校验的实现"><a href="#简单拷贝校验的实现" class="headerlink" title="简单拷贝校验的实现"></a>简单拷贝校验的实现</h1><p>实现从src目录拷贝所有文件到dst目录，并比较拷贝前后的文件是否一致</p>
<h2 id="获取文件路径"><a href="#获取文件路径" class="headerlink" title="获取文件路径"></a>获取文件路径</h2><p>两个路径选择按钮和对应的编辑框显示路径，一个Start按钮<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051513686.png" alt="9"></p>
<p>button src的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonsrc()
&#123;
    CString SrcPath;
    SrcPath = GetFolderPath(); //获取文件夹路径
    ctrl_src.SetWindowText(SrcPath); //显示获取的路径字符串
    m_src = SrcPath; //保存路径到会话对象的变量
&#125;
</code></pre>
<p>GetFolderPath打开一个目录框，让用户选择：<br>SHBrowseForFolder是win32 API，专用于打开目录</p>
<pre><code>CString CmyMFCDlg::GetFolderPath(void)
&#123;
    CString strPath;
    BROWSEINFO bInfo;
    ZeroMemory(&amp;bInfo, sizeof(bInfo));
    bInfo.hwndOwner = m_hWnd;
    bInfo.lpszTitle = _T(&quot;Select Folder: &quot;);
    bInfo.ulFlags = BIF_RETURNONLYFSDIRS;

    LPITEMIDLIST lpDlist;                    
    lpDlist = SHBrowseForFolder(&amp;bInfo); //win32 API, 打开目录    
    if (lpDlist != NULL)                        
    &#123;
        TCHAR chPath[255];                    
        SHGetPathFromIDList(lpDlist, chPath);
        strPath = chPath;                    
    &#125;
    return strPath;
&#125;
</code></pre>
<p>如果是打开文件，用CFileDialog</p>
<pre><code>CString CmyMFCDlg::GetFilePath(void)
&#123;
    CFileDialog mFileDlg(TRUE, NULL, NULL,
        OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_NOCHANGEDIR,
        _T(&quot;All Files(*.*)|*.*||&quot;), AfxGetMainWnd());
    CString str(&quot; &quot;, 10000);
    mFileDlg.m_ofn.lpstrFile = str.GetBuffer(10000);
    mFileDlg.m_ofn.lpstrTitle = _T(&quot;Select File&quot;);
    str.ReleaseBuffer();
    mFileDlg.DoModal();
    POSITION mPos = mFileDlg.GetStartPosition();
    CFileStatus status;
    CString strPath;
    while (mPos != NULL)
    &#123;
        strPath = mFileDlg.GetNextPathName(mPos);
        CFile::GetStatus(strPath, status);
    &#125;
    return strPath;
&#125;
</code></pre>
<p>不管哪一种，效果如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515196.png" alt="10"><br>选择完后，路径会在编辑框显示，这就是控件语句<code>ctrl_src.SetWindowText(SrcPath)</code>的效果<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515342.png" alt="11"></p>
<h2 id="拷贝和比较"><a href="#拷贝和比较" class="headerlink" title="拷贝和比较"></a>拷贝和比较</h2><p>拷贝函数如下，只需关注几个函数：</p>
<ul>
<li>CFileFind类的CFileFind(), FindNextFile(), GetFilePath(), GetFilePath()，这些都是afx.h定义，属于MFC库的类</li>
<li>CopyFile()， 执行拷贝，这个也是继承自MFC类</li>
</ul>
<p>代码：</p>
<pre><code>BOOL CmyMFCDlg::ModeTestCopyFileFromSRCtoDST(CString SRC, CString DST, CString&amp; StrResult)
&#123;

    CFileFind ff, ff_DST;
    CString SRCDir = SRC;                 //source folder path
    CString DSTDir = DST;
    UINT copyFileResult = 0;
    int i = 0;

    BOOL bmakedir = MakeDirectory(DSTDir);

    if (SRCDir.Right(1) != _T(&quot;\\&quot;))
        SRCDir += _T(&quot;\\&quot;);
    SRCDir += _T(&quot;*.*&quot;);

    if (DSTDir.Right(1) != _T(&quot;\\&quot;))
        DSTDir += _T(&quot;\\&quot;);
</code></pre>
<p>​<br>​        SetLastError(0);<br>​        CString DST_tmp &#x3D; DSTDir + _T(“<em>.</em>“);<br>​        BOOL res_DST &#x3D; ff_DST.FindFile(DST_tmp);<br>​        if (res_DST &#x3D;&#x3D; 0)<br>​        {<br>​            StrResult.Format(_T(“Access DST folder error, error code is %d. “), GetLastError());<br>​        }<br>​        BOOL res &#x3D; ff.FindFile(SRCDir);<br>​<br>        while (res)<br>        {<br>            res &#x3D; ff.FindNextFile();<br>            if (!ff.IsDirectory() &amp;&amp; !ff.IsDots())<br>            {<br>                CString DSTFildPath;<br>                CString SRCFilePath &#x3D; ff.GetFilePath();<br>                DSTFildPath &#x3D; DSTDir + ff.GetFileName();<br>                copyFileResult &#x3D; CopyFile(ff.GetFilePath(), DSTFildPath, FALSE);</p>
<pre><code>            Sleep(2000);

            if (copyFileResult == 0)
            &#123;
                DWORD ErrCode = GetLastError();
                StrResult.Format(_T(&quot;CopyFile failed! The ErrCode is %d. &quot;), ErrCode);

                for (i = 0; i &lt; 10; i++)
                &#123;
                    copyFileResult = CopyFile(ff.GetFilePath(), DSTFildPath, FALSE);
                    Sleep(2000);
                    if (copyFileResult == 0)
                    &#123;
                        ErrCode = GetLastError();
                        StrResult.Format(_T(&quot;Retry CopyFile failed! The ErrCode is %d. &quot;), ErrCode);
                    &#125;
                    else
                    &#123;
                        break;
                    &#125;
                &#125;

                if (copyFileResult == 0)
                &#123;
                    ff.Close();
                    return FALSE;
                &#125;
            &#125;
        &#125;
        else if (ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFildPath;
            DSTFildPath = DSTDir + ff.GetFileName();
            copyFileResult = ModeTestCopyFileFromSRCtoDST(ff.GetFilePath(), DSTFildPath, StrResult);
            if (copyFileResult == 0)
                break;
        &#125;
    &#125;

    ff.Close();
    if (copyFileResult == 0)
        return FALSE;
    else
        return TRUE;
&#125;
</code></pre>
<p>比较两个路径的文件：<br>其方法是，文件读到buffer, 再用memcmp比较buffer, 其FindNextFile也是如何从目录搜索到文件的关键方法</p>
<pre><code>BOOL CmyMFCDlg::ModeTestCompareFilesBetweenSRCandDST(CString SRC, CString DST, CString&amp; StrResult)
&#123;
    CFileFind ff;
    CString SRCDir = SRC;
    CString DSTDir = DST;
    BOOL bRes = TRUE;
    HANDLE hSrcFile, hDstFile;
    DWORD dwSRCFile, dwDSTFile, dwCB;

    if (SRCDir.Right(1) != _T(&quot;\\&quot;))
        SRCDir += _T(&quot;\\&quot;);
    SRCDir += _T(&quot;*.*&quot;);

    if (DSTDir.Right(1) != _T(&quot;\\&quot;))
        DSTDir += _T(&quot;\\&quot;);
    hSrcFile = hDstFile = NULL;
    BYTE* pSrcBuffer = new BYTE[M_BUFSIZE];
    BYTE* pDstBuffer = new BYTE[M_BUFSIZE];
    memset(pSrcBuffer, 0, M_BUFSIZE);
    memset(pSrcBuffer, 0, M_BUFSIZE);

    BOOL res = ff.FindFile(SRCDir);

    while (res)
    &#123;
        res = ff.FindNextFile();
        if (!ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFilePath;
            DSTFilePath = DSTDir + ff.GetFileName();
            CString SRCFilePath = ff.GetFilePath();

            if (hSrcFile)
            &#123;
                CloseHandle(hSrcFile);
                hSrcFile = NULL;
            &#125;

            if (hDstFile)
            &#123;
                CloseHandle(hDstFile);
                hSrcFile = NULL;
            &#125;

            hSrcFile = CreateFile(SRCFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
            if (hSrcFile == INVALID_HANDLE_VALUE)
            &#123;
                StrResult.Format(_T(&quot;\n Create Source file failed!! Error code = %d \n&quot;), GetLastError());
                bRes = FALSE;
                break;
            &#125;

            hDstFile = CreateFile(DSTFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
            if (hDstFile == INVALID_HANDLE_VALUE)
            &#123;
                StrResult.Format(_T(&quot;\n Create Destination file failed!! Error code = %d \n&quot;), GetLastError());
                bRes = FALSE;
                break;
            &#125;

            LARGE_INTEGER SrcFileSize, DstFileSize;

            dwSRCFile = GetFileSizeEx(hSrcFile, &amp;SrcFileSize);
            dwDSTFile = GetFileSizeEx(hDstFile, &amp;DstFileSize);

            if (SrcFileSize.LowPart != DstFileSize.LowPart)
            &#123;
                StrResult.Format(_T(&quot;\n Compare file is different!! Src Length = %d, Dest Length = %d \n&quot;), SrcFileSize.LowPart, DstFileSize.LowPart);
                bRes = FALSE;
                break;
            &#125;

            while (SrcFileSize.LowPart &gt; 0)
            &#123;
                BOOL bCmpResult;
                bCmpResult = ReadFile(hSrcFile, pSrcBuffer, M_BUFSIZE, &amp;dwCB, NULL);
                if (bCmpResult == 0)
                &#123;
                    bRes = FALSE;
                    break;
                &#125;
                bCmpResult = ReadFile(hDstFile, pDstBuffer, M_BUFSIZE, &amp;dwCB, NULL);
                if (bCmpResult == 0)
                &#123;
                    bRes = FALSE;
                    break;
                &#125;
                bCmpResult = memcmp(pSrcBuffer, pDstBuffer, dwCB);

                if (bCmpResult != 0)
                &#123;
                    bRes = FALSE;
                    CString DiffByte;

                    CString PostCmpErrorStr;
                    CString SrcDumpData, DstDumpData;
                    StrResult.Format(_T(&quot;\n Fatal_Error: Src Data from %d to %d.\n&quot;), (DstFileSize.LowPart - SrcFileSize.LowPart), (DstFileSize.LowPart - SrcFileSize.LowPart + dwCB));

                    PostCmpErrorStr = _T(&quot;SourceFilePath: &quot;) + SRCFilePath + _T(&quot; To \r\n&quot;) + _T(&quot;DstFilePath: &quot;) + DSTFilePath;
                    StrResult = PostCmpErrorStr + _T(&quot;  has compare error! \r\n&quot;);
                    //HugoPostMessageAndShowSD1(PostCmpErrorStr,1);
                    //HugoPostMessageAndShowSD2(PostCmpErrorStr,1);

                    ::MessageBox(
                        NULL,
                        (LPCWSTR)L&quot;Compare error happened!!&quot;,
                        (LPCWSTR)L&quot;Fatal Error!&quot;,
                        MB_OK
                    );

                    break;
                &#125;
                SrcFileSize.LowPart -= dwCB;
            &#125;

            if (bRes == FALSE)
                break;
            else
                ReadFile(hDstFile, pDstBuffer, 512, &amp;dwCB, NULL);
        &#125;
        else if (ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFildPath;
            DSTFildPath = DSTDir + ff.GetFileName();
            bRes = ModeTestCompareFilesBetweenSRCandDST(ff.GetFilePath(), DSTFildPath, StrResult);
            if (bRes == FALSE)
                break;
        &#125;
    &#125;

    if (hSrcFile)
    &#123;
        CloseHandle(hSrcFile);
        hSrcFile = NULL;
    &#125;

    if (hDstFile)
    &#123;
        CloseHandle(hDstFile);
        hSrcFile = NULL;
    &#125;

    if (bRes == FALSE)
    &#123;
        delete[]pSrcBuffer;
        delete[]pDstBuffer;
        ff.Close();
        return FALSE;
    &#125;
    else
    &#123;
        delete[]pSrcBuffer;
        delete[]pDstBuffer;
        ff.Close();
        return TRUE;
    &#125;
&#125;
</code></pre>
<p>关于CString的格式化输出：<a href="https://blog.csdn.net/wangkaishou/article/details/5846152">MFC中CString.Format的详细用法</a><br>关于CFile文件操作：<a href="https://blog.csdn.net/perfectguyipeng/article/details/60148222">MFC——文件操作（CFile）</a></p>
<h2 id="开始按钮"><a href="#开始按钮" class="headerlink" title="开始按钮"></a>开始按钮</h2><p>一般操作顺序：选择src和dst，再点击Start按钮<br>start按钮的方法调用已保存的m_src和m_dst路径，传入拷贝和比较，再输出结果即可，大致流程如下</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonrun()
&#123;
    //读入所有界面数据
    UpdateData(true);
    
    BOOL ret;
    CString outStr;
    
    ret = ModeTestCopyFileFromSRCtoDST(m_src, m_dst, outStr);
    if (!ret)
            MessageBox(NULL, _T(outStr), _T(&quot;ERROR&quot;), MB_OK);
    
    ret = ModeTestCompareFilesBetweenSRCandDST(m_src, m_dst, outStr);
    if (!ret)
            MessageBox(NULL, _T(outStr), _T(&quot;ERROR&quot;), MB_OK);
&#125;
</code></pre>
<p>这里用messagebox输出结果，即弹窗，弹窗是阻塞式的。也可以用编辑框，写文件输出。<br>关于messagebox，参考：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox">MessageBox function (winuser.h)</a><br>关于updateData：<a href="https://www.cnblogs.com/lidabo/archive/2012/07/17/2595464.html">MFC中UpdateData()函数的使用</a><br>以上完成一个简单的文件拷贝和比较功能</p>
<h1 id="多线程文件拷贝和写日志"><a href="#多线程文件拷贝和写日志" class="headerlink" title="多线程文件拷贝和写日志"></a>多线程文件拷贝和写日志</h1><p>将简单拷贝扩展，支持：</p>
<ul>
<li>多线程拷贝和比较，每个线程完成简单拷贝比较的功能</li>
<li>在每个工作线程，输出打印到界面文本框，同时写到同一个日志文件</li>
<li>界面主线程需要等待所有工作线程完成后，输出测试完成信息到文本框和日志</li>
</ul>
<h2 id="线程列表获取各自路径"><a href="#线程列表获取各自路径" class="headerlink" title="线程列表获取各自路径"></a>线程列表获取各自路径</h2><p>add和delete配置几个工作线程，每个线程配置其src和dst路径</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516636.png" alt="12"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516611.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516530.png" alt="14"></p>
<p>这种动态增删的列表，在资源界面新建listbox类型变量和方法：</p>
<pre><code>CListBox m_rwlist;
afx_msg void OnLbnSelchangeListrwlist();
</code></pre>
<p>Add和Delete对应的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonadd()
void CmyMFCDlg::OnBnClickedButtondelete()
</code></pre>
<p>Add和Delete的方法控制listbox变量m_rwlist，选中任意m_rwlist后又会调用其方法OnLbnSelchangeListrwlist，获取每个线程各自的src、dst。</p>
<p>按键控制m_rwlist的实现：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonadd()
&#123;
    CString Threadtest = _T(&quot;TestThread&quot;);
    UINT ThreadCount = m_rwlist.GetCount();
    if (ThreadCount == 0)
    &#123;
        m_rwlist.AddString(_T(&quot;TestThread1&quot;));
    &#125;
    else if (ThreadCount &lt; MAX_THREAD_COUNT)
    &#123;
        CString ThreadNum;
        ThreadNum.Format(_T(&quot;%d&quot;), ThreadCount + 1);
        Threadtest = Threadtest + ThreadNum;
        m_rwlist.AddString(Threadtest);
    &#125;
    else if (ThreadCount == MAX_THREAD_COUNT)
    &#123;
        CString str;
        str.Format(_T(&quot;Only support %d threads at most!!&quot;), MAX_THREAD_COUNT);
        MessageBox(str);
    &#125;
    m_rwlist.SetCurSel(ThreadCount);
    if (ThreadCount &lt; MAX_THREAD_COUNT)
        totalThreadCount++;
&#125;

void CmyMFCDlg::OnBnClickedButtondelete()
&#123;
    UINT ThreadCount = m_rwlist.GetCount();
    if (ThreadCount != 0)
    &#123;
        m_rwlist.DeleteString(ThreadCount - 1);
        m_rwlist.SetCurSel(0);
    &#125;
    if (ThreadCount &gt; 0)
        totalThreadCount--;
&#125;
</code></pre>
<p>线程列表m_rwlist的方法读取路径到会话对象成员变量：</p>
<pre><code>void CmyMFCDlg::OnLbnSelchangeListrwlist()
&#123;
    UpdateData(true); //update true: 从界面读入值到变量（使上次编辑生效）
    if (m_rwlist.GetCount() != 0)
    &#123;
        UINT selectNum = m_rwlist.GetCurSel();
        RWTestParamArray[selectNum].ThreadNum = m_rwlist.GetCount();
        RefreshRWParam(RWTestParamArray, selectNum);
    &#125;
&#125;

void CmyMFCDlg::RefreshRWParam(TabDialogRWTestParam(&amp;Array)[MAX_THREAD_COUNT], UINT CSel)
&#123;
    ctrl_src.SetWindowText(Array[CSel].SRCFolder_Path);
    ctrl_dst.SetWindowText(Array[CSel].DSTFolder_Path);

    UpdateData(false); //update false: 把变量写入到界面（实时显示）
&#125;
</code></pre>
<p>真正读入路径的是dst、src按钮的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonsrc()
&#123;
    CString SrcPath;
    UINT ThreadCSelNum = m_rwlist.GetCurSel();
    SrcPath = GetFolderPath();
    ctrl_src.SetWindowText(SrcPath);
    RWTestParamArray[ThreadCSelNum].SRCFolder_Path = SrcPath;
&#125;

void CmyMFCDlg::OnBnClickedButtondst()
&#123;
    CString DstPath;
    UINT ThreadCSelNum = m_rwlist.GetCurSel();
    DstPath = GetFolderPath();
    ctrl_dst.SetWindowText(DstPath);
    RWTestParamArray[ThreadCSelNum].DSTFolder_Path = DstPath;
&#125;
</code></pre>
<p>线程数组定义在会话类，存储每个工作线程要用的数据</p>
<pre><code>TabDialogRWTestParam RWTestParamArray[MAX_THREAD_COUNT];
typedef struct TabRWParam
&#123;
    CString SRCFolder_Path;
    CString DSTFolder_Path;
    UINT ThreadNum;
    UINT TestTimes;
&#125;TabDialogRWTestParam;
</code></pre>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>创建线程参考MS文档：<a href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-160">beginthread、_beginthreadex</a><br>关注2点：</p>
<ul>
<li>传入线程内要执行的函数，和参数(可为NULL)</li>
<li>返回线程句柄，如果是多个线程则是个数组</li>
</ul>
<p>创建线程的部分代码：</p>
<pre><code>void CmyMFCDlg::RunModeTestInstance()
&#123;
    ....
    
    //线程内除了对象，还需要知道自己是哪个线程，因此打包this和ThreadCount
    pTransParam ThreadTransPArray[MAX_THREAD_COUNT];

    for (int i = 0; i &lt; totalThreadCount; i++)
    &#123;
        ThreadTransPArray[i] = new(TransParam);
        ThreadTransPArray[i]-&gt;i = i;
        ThreadTransPArray[i]-&gt;translpParam = this;

        unsigned int rwThreadID;

        //hThread defined as global data
        hThread[i] = (HANDLE)_beginthreadex(
            NULL,
            0,
            DoThreadProc,
            ThreadTransPArray[i],
            0,
            &amp;rwThreadID);

        if (hThread[i] == NULL)
            MessageBox(_T(&quot;CreateThread Fail!!&quot;), MB_OK);
        
        ....
        
        //release resource
        for (int i = 0; i &lt; totalThreadCount; i++)
        &#123;
            delete ThreadTransPArray[i];
            ThreadTransPArray[i] = NULL;
            CloseHandle(hThread[i]);
        &#125;
    &#125;
</code></pre>
<p>由于要在线程内打印当前是哪个线程，这个从Dlg对象的this指针是获取不到的，因此把this指针和线程id打包结构体，传入DoThreadProc线程函数，结构体如下</p>
<pre><code>typedef struct transParam
&#123;
    LPVOID translpParam;
    int i;
&#125;TransParam, *pTransParam;

#define MAX_THREAD_COUNT 6
</code></pre>
<p>注意使用完后释放线程句柄和其他相关资源</p>
<h2 id="主线程和工作线程的通信：Message机制"><a href="#主线程和工作线程的通信：Message机制" class="headerlink" title="主线程和工作线程的通信：Message机制"></a>主线程和工作线程的通信：Message机制</h2><p>先明白几点：</p>
<ul>
<li>所有工作线程都共享主线程（界面线程）的数据，即会话类对象的成员</li>
<li>界面控件的操作函数，都是主线程独有的，工作线程不能调用</li>
<li>主线程如果要等待工作线程，一般会阻塞</li>
</ul>
<p>问题：<br>如何将工作线程的打印输出到主线程界面控件？</p>
<p>Windows消息机制可以解决工作线程和主线程通信问题，简单的讲，主线程有消息队列，工作线程可以发送消息到消息队列中，主线程用FIFO原则处理队列中的消息，在阻塞等待动作线程时，也支持消息队列的处理。<br>关于消息队列：<a href="https://www.jianshu.com/p/5fd5bdaac69c">windows消息机制（MFC）</a></p>
<p>（1）工作线程函数</p>
<pre><code>unsigned int WINAPI DoThreadProc(void *threadTransParam)
&#123;
    pTransParam pTrans = (pTransParam)threadTransParam;
    CString strResult;
    BOOL res = 0;

    CmyMFCDlg* pDlg = (CmyMFCDlg *)pTrans-&gt;translpParam;
    int thread_id = pTrans-&gt;i;

    for (int i = 0; i &lt; (int)pDlg-&gt;rwtime; i++)
    &#123;
        
        res = pDlg-&gt;ModeTestCopyFileFromSRCtoDST(pDlg-&gt;RWTestParamArray[thread_id].SRCFolder_Path, pDlg-&gt;RWTestParamArray[thread_id].DSTFolder_Path, strResult);

        res = pDlg-&gt;ModeTestCompareFilesBetweenSRCandDST(pDlg-&gt;RWTestParamArray[thread_id].SRCFolder_Path, pDlg-&gt;RWTestParamArray[thread_id].DSTFolder_Path, strResult);
        if (res)
        &#123;
            criticalSec.Lock();
            ::PostMessage(pDlg-&gt;GetSafeHwnd(), WM_USER_MSG, WPARAM(thread_id + 1), LPARAM(i + 1));
            criticalSec.Unlock();
        &#125;
    &#125;

    return res;
&#125;
</code></pre>
<p>几点说明：</p>
<ul>
<li>线程函数要用WINAPI实现，不属于会话类内的方法，因此需要this指针显式调用</li>
<li>rwtime是测试次数，每个线程执行多次拷贝比较</li>
<li>PostMessage是发布消息到主线程消息队列，可以传参：WPARAM和LPARAM</li>
<li>由于不确定PostMessage是不是线程安全，这里加了锁：CCriticalSection类型的criticalSec</li>
</ul>
<p>(2)消息处理函数<br>来看message处理函数：</p>
<pre><code>LRESULT CmyMFCDlg::OnMsg(WPARAM wp, LPARAM lp)
&#123;
    strAppend.Format(_T(&quot;Thread %d src:%s ---&gt; des:%s, Copy&amp;Compare Pass: test loop: %d \n&quot;), wp, RWTestParamArray[wp-1].SRCFolder_Path, RWTestParamArray[wp-1].DSTFolder_Path, lp);
    ShowLogInEditBox(); //字符串显示到界面
    return 0;
&#125;
</code></pre>
<p>主界面字符串显示函数</p>
<pre><code>/* call by message handler, for multiple child thread*/
void CmyMFCDlg::ShowLogInEditBox()
&#123;
    CString str;
    UINT i;

    /*message 队列只在主线程内处理，无需加锁*/
    //criticalSec.Lock();
        WriteLogFile(this-&gt;strAppend); //only write append str
    //criticalSec.Unlock();

    this-&gt;GetDlgItemText(IDC_EDIT_logbox, str);
    str += this-&gt;strAppend; //update old+append str
    str += &quot;\r\n&quot;; //这里换行没用，要在控件设置中允许换行

    this-&gt;SetDlgItemText(IDC_EDIT_logbox, str);

    i = ((CEdit*)GetDlgItem(IDC_EDIT_logbox))-&gt;GetLineCount();
    ((CEdit*)GetDlgItem(IDC_EDIT_logbox))-&gt;LineScroll(++i, 0); //定位到下一行

&#125;
</code></pre>
<p>写日志的相关方法如下：</p>
<pre><code>BOOL CmyMFCDlg::CreateLogFile()
&#123;
    CString strName;
    SYSTEMTIME st;

    GetLocalTime(&amp;st);
    strName.Format(_T(&quot;UtilityLogFile_%4d-%d-%d_%d-%d-%d.log&quot;), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);

    if (!m_File.Open(strName, (CFile::modeCreate | CFile::modeReadWrite), 0))
    &#123;
        ::AfxMessageBox(_T(&quot;Create Utility Log File Error!!&quot;));
        return FALSE;
    &#125;

    m_logCreated = 1;
    return TRUE;
&#125;

void CmyMFCDlg::WriteLogFile(CString str)
&#123;
    BOOL CreateRes = TRUE;

    if (m_logCreated == 0)
        CreateRes = CreateLogFile();

    if (CreateRes)
    &#123;
        str += _T(&quot;\r\n&quot;);
        int length = str.GetLength();
        length *= 2;
        m_File.Write(str, length);
        m_File.Flush();
    &#125;
&#125;

void CmyMFCDlg::CloseLogFile()
&#123;
    if (m_logCreated == 1)
    &#123;
        m_File.Close();
        m_logCreated = 0;
    &#125;
&#125;
</code></pre>
<p>注意message处理函数的关键点：</p>
<ul>
<li>只在主线程中处理，不存在其他线程操作，无临界区问题。因此上述的窗口输出，日志文件写入都是线程安全的。</li>
</ul>
<p>编辑框作为输出要注意几点：</p>
<ul>
<li>换行要在设置里配置，字符串换行没用</li>
<li>设置输出滚动显示</li>
</ul>
<p>效果如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516097.png" alt="15"></p>
<p>（3）线程同步<br>日志完成的输出是主线程等待所有工作线程函数返回后才执行，如何实现？<br>参考：<a href="https://www.cnblogs.com/shangdawei/p/4015772.html">WaitForMultipleObject与MsgWaitForMultipleObjects用法</a><br>我们的需求是主线程在阻塞等待时要处理消息，因此用MsgWaitForMultipleObjects方法。<br>代码如下：</p>
<pre><code>//wait all child threads return

    /*
    //主线程阻塞，不能处理消息
    DWORD dwWaitResult = WaitForMultipleObjects(
        totalThreadCount,
        hThread,
        TRUE,
        INFINITE);
    */
    //主线程阻塞，但不阻塞消息
    int nWaitCount = totalThreadCount;
    int nExitThreadCount = 0;      //标记已经有几个线程退出了
    BOOL bWaitAll = FALSE;        //不等待所有线程完成，实时处理。如果TRUE, 会阻塞到所有线程完成
    DWORD result;
    MSG msg;

    while (TRUE)
    &#123;
        /*该函数等待：多个线程的完成信号，或其他消息信号,有任意一种就返回
        *返回值为[WAIT_OBJECT_0, WAIT_OBJECT_0 + nWaitCount - 1]表示对应下标的线程已完成
        *返回值为WAIT_OBJECT_0 + nWaitCount表示有其他信号，如线程内发送的message
        *WAIT_OBJECT_0值为0
        */
        result = MsgWaitForMultipleObjects(nWaitCount, hThread, bWaitAll, INFINITE, QS_ALLINPUT);

        if (result == WAIT_OBJECT_0 + nWaitCount) //表示收到消息
        &#123;
            while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) //处理所有已入队的消息
            &#123;
                TranslateMessage(&amp;msg); //message translat and format, add into message queue
                DispatchMessage(&amp;msg); //call message handler
            &#125;
        &#125;
        else if (result &gt;= WAIT_OBJECT_0 &amp;&amp; result &lt; WAIT_OBJECT_0 + nWaitCount) //表示收到了线程结束信号
        &#123;
            nExitThreadCount++;
            if (nExitThreadCount &lt; totalThreadCount)
            &#123;
                /*必须更新hThread，否则已退出的线程一直被检测到*/
                int nIndex = result - WAIT_OBJECT_0; //退出线程的index
                hThread[nIndex] = hThread[nWaitCount - 1]; //更新等待列表：hThread, 交换退出的成员和尾部成员
                hThread[nWaitCount - 1] = NULL;

                nWaitCount--; //更新要等待的线程数
            &#125;
            else
            &#123;
                break; //等待的所有线程都已完成
            &#125;
        &#125;
    &#125;

    //All threads returned
</code></pre>
<p>MsgWaitForMultipleObjects的MS说明文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects">MsgWaitForMultipleObjects function (winuser.h)</a><br>返回值的含义是重点，这个文档说的很隐晦：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051517122.png" alt="16"></p>
<p>大意是：等待n个线程</p>
<ul>
<li>如果返回的值i是属于0~n-1，说明第i个工作线程结束了</li>
<li>如果返回值是n，不是线程结束，而是收了到消息，例如工作线程内发送的消息。</li>
</ul>
<p>因此代码逻辑是：<br>1.如果有消息，就处理消息<br>关于message的peek,translate和dispatch:<br><a href="https://blog.csdn.net/caimagic/article/details/50629570">PeekMessage使用方法</a><br><a href="https://blog.csdn.net/wang15061955806/article/details/52066559">消息循环中TranslateMessage和Dispatch函数的作用</a></p>
<p>2.如果有线程结束，要更新线程句柄数组，只保留未等待到的线程；<br>当所有线程都等待到，退出等待循环</p>
<p>以上完成了主线程和多个工作线程的同步机制</p>
<h1 id="再进一步：调用其他进程"><a href="#再进一步：调用其他进程" class="headerlink" title="再进一步：调用其他进程"></a>再进一步：调用其他进程</h1><p>现需求如下：<br>有多个功能的FW需要测试，要求测试工具遍历每个FW, 调用其他的程序，更新到磁盘固件后，做之前的多进程读写比较流程<br>重点关注如何调用其他程序。假设FW更新程序是FirwmareUpdateTool.exe，接受FW相关的参数<br>需要实现：</p>
<ul>
<li>界面接收参数</li>
<li>调用其他程序，传参，且注意与主线程的同步</li>
</ul>
<p>代码：</p>
<pre><code>BOOL CmyMFCDlg::DoUpdateFirmware(CString filename)
&#123;
    TCHAR szFilePath[MAX_PATH + 1] = &#123; 0 &#125;;
    GetModuleFileName(NULL, szFilePath, MAX_PATH);
    (_tcsrchr(szFilePath, _T(&#39;\\&#39;)))[1] = 0;

    CString strToolPath(szFilePath);
    strToolPath = strToolPath + _T(&quot;FirwmareUpdateTool.exe&quot;);
    CString strPath;
    strPath.Format(_T(&quot;%s %s %s %d&quot;), strToolPath.GetBuffer(0), m_str_VendorID.GetBuffer(0), filename.GetBuffer(0), m_SlotID);
    
    strAppend = strPath;
    ShowLogInEditBox();

    if (!PathFileExists(strToolPath))
    &#123;
        strAppend.Format(_T(&quot;The %s is not exist!&quot;), strToolPath.GetBuffer(0));
        ShowLogInEditBox();
        MessageBox(strAppend, MB_OK);
        return FALSE;
    &#125;

    STARTUPINFO si = &#123; sizeof(STARTUPINFO) &#125;;//在产生子进程时，子进程的窗口相关信息
    PROCESS_INFORMATION pi;                  //子进程的ID/线程相关信息
    memset(&amp;pi, 0, sizeof(PROCESS_INFORMATION));
    DWORD returnCode = -1;              //用于保存子程进的返回值;

    BOOL bRet = CreateProcess(              //调用失败，返回0；调用成功返回非0；
        NULL,                               //一般都是空；（另一种批处理情况：此参数指定&quot;cmd.exe&quot;,下一个命令行参数 &quot;/c otherBatFile&quot;)
        strPath.GetBuffer(0),              //命令行参数         
        NULL,                               //_In_opt_    LPSECURITY_ATTRIBUTES lpProcessAttributes,
        NULL,                               //_In_opt_    LPSECURITY_ATTRIBUTES lpThreadAttributes,
        FALSE,                              //_In_        BOOL                  bInheritHandles,
        CREATE_NEW_CONSOLE,                 //新的进程使用新的窗口。
        NULL,                               //_In_opt_    LPVOID                lpEnvironment,
        NULL,                               //_In_opt_    LPCTSTR               lpCurrentDirectory,
        &amp;si,                                //_In_        LPSTARTUPINFO         lpStartupInfo,
        &amp;pi);                               //_Out_       LPPROCESS_INFORMATION lpProcessInformation

    if (bRet)
    &#123;
        while (TRUE) //这里也是为了输出打印和日志而等待进程，同时也阻塞了主线程
        &#123;
            DWORD result;
            MSG msg;
            result = MsgWaitForMultipleObjects(1, &amp;pi.hProcess, FALSE, INFINITE, QS_ALLINPUT);
            if (result == (WAIT_OBJECT_0))
            &#123;
                //获取子进程的返回值
                GetExitCodeProcess(pi.hProcess, &amp;returnCode);
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                break;
            &#125;
            else
            &#123;
                PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE);
                DispatchMessage(&amp;msg);
            &#125;
        &#125;
        strAppend.Format(_T(&quot;%s returnCode : %d &quot;), strToolPath.GetBuffer(0), returnCode);
        ShowLogInEditBox();
    &#125;
    else
    &#123;
        strAppend.Format(_T(&quot;Start the %s failed!&quot;), strToolPath.GetBuffer(0));
        ShowLogInEditBox();
        MessageBox(strAppend, MB_OK);
    &#125;

    if (!returnCode)
    &#123;
        return TRUE;
    &#125;
    return FALSE;
&#125;
</code></pre>
<p>CreateProcess创建进程，执行第三方程序<br>MsgWaitForMultipleObjects等待第三方进程返回，阻塞了当前主进程</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文涉及的知识点：</p>
<ul>
<li>界面控件与底层类的数据交互</li>
<li>MFC的文件，字符串操作</li>
<li>线程创建和线程同步</li>
<li>线程通信：消息机制</li>
<li>进程创建与同步</li>
</ul>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile使用笔记</title>
    <url>/2020/06/10/Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="文件名替换"><a href="#文件名替换" class="headerlink" title="文件名替换"></a>文件名替换</h1><p>1.wildcard<br>展开多个文件为使用空格分开的、匹配此模式的列表参数<br>格式<br><code>$(wildcard PATTERN...)</code></p>
<p>示例：</p>
<pre><code>SRC=$(wildcard *.c)
</code></pre>
<p>2.patsubst<br>替换通配符<br>格式</p>
<pre><code>$(patsubst %.c,%.o,$(dir))
</code></pre>
<p>示例：</p>
<pre><code>obj := $(patsubst %.c,%.o,$(wildcard *.c))
</code></pre>
<p>3.替换引用<br>patsubst的示例等价于：</p>
<pre><code>obj=$(dir:%.c=%.o)
</code></pre>
<p>引用替换：</p>
<pre><code>$(var:a=b) 或 $&#123;var:a=b&#125;
</code></pre>
<p>含义是把变量var中的每一个值，用b替换掉a</p>
<h1 id="PHONY"><a href="#PHONY" class="headerlink" title="PHONY"></a>PHONY</h1><p>Makefile执行的规则是A:B，表示A依赖于B</p>
<ul>
<li>有B才能执行A对应的编译操</li>
<li>B有更新(检测文件时间)，则A会执行，若B没有更新，不执行A</li>
</ul>
<p>问题来了，clean: 不需要依赖任何对象，如何执行<br>PHONY定义伪目标,可以解决源文件不是最终目标直接依赖（即间接依赖）带来的不能自动检查更新规则, 示例如下</p>
<pre><code>.PHONY: clean
clean:
    rm -f *.o
</code></pre>
<p>PHONY不仅用于clean，对于间接依赖也有用，例如A:B， B:C ，有时C为空，就需要把B定义为PHONY</p>
<pre><code>OBJS = *.o
program:  $(OBJS)
        gcc *.o -o program
 
.PHONY : $(OBJS)
$(OBJS):
        make -C $(dir $@)
</code></pre>
<p>不过一般情况，obj依赖于%.c，总之，对于没有依赖项的对象，需要定义为PHONY</p>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>常见通配符</p>
<pre><code>$@, $^, $&lt;, $?

$@  表示目标文件
$^  表示所有的依赖文件
$&lt;  表示第一个依赖文件
$?  表示比目标还要新的依赖文件列表
</code></pre>
<p>示例：<br>编译Test目录下的.cpp文件，输出test可执行程序<br>直接指定依赖文件名的makefile写法：</p>
<pre><code>test: $(wildcard Test/*.cpp)
    $(CXX) $(CFLAGS) -o test $(wildcard Test/*.cpp) 
</code></pre>
<p>虽然wildcard实现了所有依赖的.cpp的通配，编译语句再用wildcard写一次依赖文件不优雅，而且test在依赖中已经写了，编译语句又写一遍 -o test。<br>编译语句使用通配, 称为通用格式：</p>
<pre><code>test: $(wildcard Test/*.cpp)
    $(CXX) $(CFLAGS) -o $@ $^
</code></pre>
<h1 id="多个源文件分别编译"><a href="#多个源文件分别编译" class="headerlink" title="多个源文件分别编译"></a>多个源文件分别编译</h1><p>目录下有很多源文件，每个单独编译和执行的，将每一个文件编译成可执行文件，不用单独命名如：gcc -c xxx.c -o xxx<br>(1)Makefile实现</p>
<pre><code>SRC=$(wildcard *.c)
OBJ=$(SRC:%.c=%.o)
BIN=$(OBJ:%.o=%)
 
CC=gcc
CFLAGS=-Wall -g -c
 
all:$(BIN)

$(BIN):%:%.o
        $(CC) $^ -o $@
$(OBJ):%.o:%.c
        $(CC) $(CFLAGS) $^ -o $@

.PHONY: clean
clean:
        rm -rf $(OBJ) $(BIN)
</code></pre>
<p>(2)Shell实现</p>
<pre><code>#! /bin/bash
for file in ./*.c
do
if [ -f $file ]
then
file=$&#123;file#./&#125;
target=$&#123;file%.c&#125;
gcc -o $target $file
echo $target
fi
if [ -d $file ]
then
echo $file is mu lu
fi
done
</code></pre>
<p>(2)Makefile编译指定目录<br>Makefile可以输入参数，直接在make命令的后面加上参数，如:</p>
<pre><code>make BUILD_DIR=./foldername/
</code></pre>
<p>传入的变量将会覆盖相应Makefile中的<code>BUILD_DIR</code></p>
]]></content>
      <categories>
        <category>makefile</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用笔记</title>
    <url>/2020/12/12/Markdown%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>有的文字或代码和markdown解析有冲突<br>如$, @等<br>在这些字符前加转义字符即可：$, @</p>
<h2 id="tab缩进"><a href="#tab缩进" class="headerlink" title="tab缩进"></a>tab缩进</h2><p>markdown本身不支持tab缩进，有以下方法：<br>1.可以用全角输入+2个空格实现缩进<br>2.输入<code>&amp;emsp</code>，就是全角空格符号<br>3.输入<code>&gt;</code></p>
<h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><pre><code>[标题](URL)
</code></pre>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><pre><code>- line
* line
</code></pre>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code>#
##
###
</code></pre>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code>|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>
<h1 id="Typora使用"><a href="#Typora使用" class="headerlink" title="Typora使用"></a>Typora使用</h1><h2 id="导出和打印"><a href="#导出和打印" class="headerlink" title="导出和打印"></a>导出和打印</h2><p>有的markdown文本内容中带换行，而Typora阅读时也有换行，照成换行混乱</p>
<p>如果要打印，导出pdf的换行也混乱</p>
<p>解决办法是导出HTML(without style)，然后打印</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>NVMe设备的Firmware Update全栈分析（一）：基于Windows Storport环境</title>
    <url>/2022/11/30/NVMe%E8%AE%BE%E5%A4%87%E7%9A%84Firmware%20Update%E5%85%A8%E6%A0%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EWindows%20Storport%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update"><a href="#1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update" class="headerlink" title="1.1 Windows Storport Driver环境下的NVMe设备Firmware Update"></a>1.1 Windows Storport Driver环境下的NVMe设备Firmware Update</h2><p>Windows系统下，NVMe设备的Firmware Update都是基于以下Microsoft API文档 ：</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/upgrading-firmware-for-an-nvme-device">upgrading-firmware-for-an-nvme-device</a></p>
]]></content>
      <categories>
        <category>NVMe</category>
      </categories>
      <tags>
        <tag>NVMe</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs笔记：使用pm2部署项目</title>
    <url>/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>nodejs服务可以用<code>nohup node xxx.js &amp;</code>后台启动，但是实际使用发现不太稳定，使用专门的node后台服务管理工具：pm2解决此问题</p>
<h1 id="pm2特性"><a href="#pm2特性" class="headerlink" title="pm2特性"></a>pm2特性</h1><p>1、内建负载均衡（使用Node cluster 集群模块）<br>2、后台运行<br>3、0秒停机重载<br>4、具有Ubuntu和CentOS 的启动脚本<br>5、停止不稳定的进程（避免无限循环）<br>6、控制台检测<br>7、提供 HTTP API<br>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p>
<h1 id="pm2安装"><a href="#pm2安装" class="headerlink" title="pm2安装"></a>pm2安装</h1><pre><code>npm install -g pm2
</code></pre>
<h1 id="pm2用法"><a href="#pm2用法" class="headerlink" title="pm2用法"></a>pm2用法</h1><pre><code>pm2 start app.js        //启动进程
pm2 start app.js -i 4   // 后台运行pm2，启动4个app.js
pm2 start app.js -i max //启动，使用所有CPU核心
pm2 start app.js --name my-api // 命名进程
pm2 list               // 显示所有进程状态
pm2 monit              // 监视所有进程
pm2 logs               //  显示所有进程日志
pm2 stop all           // 停止所有进程
pm2 restart all        // 重启所有进程
pm2 reload all         // 0秒停机重载进程 (用于 NETWORKED 进程)
pm2 stop 0             // 停止指定的进程
pm2 restart 0          // 重启指定的进程
pm2 startup            // 产生 init 脚本 保持进程活着
pm2 web                // 运行健壮的 computer API endpoint 
pm2 delete 0           // 杀死指定的进程
pm2 delete all         // 杀死全部进程
</code></pre>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>部署Github项目NodeMail，每天给指定邮箱发邮件。</p>
<p>后台启动main.js并监测状态：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427417.png" alt="image-20221206142729375"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427110.png" alt="image-20221206142743066"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427682.png" alt="image-20221206142752627"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061428280.png" alt="image-20221206142800236"></p>
]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>Office常用操作笔记</title>
    <url>/2019/07/06/Office%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h1><h2 id="Word设置自动推导的标题列表"><a href="#Word设置自动推导的标题列表" class="headerlink" title="Word设置自动推导的标题列表"></a>Word设置自动推导的标题列表</h2><p>word自动标题列表的是写文档必不可少的，自动标题能自动推导更新各级标题的序号，增删改查任何标题都不需要手动的写标题序号。</p>
<p>（1）创建多级列表<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423943.png" alt="image-20221206142307899"></p>
<p>（2）设置一级标题</p>
<ul>
<li>设置一级标题的序号样式为1,2,3</li>
<li>链接一级标题的字体样式到word文档的一级标题字体样式<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423121.png" alt="image-20221206142315070"></li>
</ul>
<p>（2）设置二级、三级、n级标题</p>
<p>需要设置列表序号，标题字体两部分。注意列表序号的正确设置是序号自动推导的关键。<br>以二级标题为例，其他子级类推。</p>
<ul>
<li><p>设置二级标题中的一级序号来自于level1。这一步保证二级标题中的一级序号是自动推导的。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423795.png" alt="image-20221206142327739"></p>
</li>
<li><p>设置二级标题中的二级序号的样式，二级标题中的一、二级序号用.号隔开<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424185.png" alt="image-20221206142401132"></p>
</li>
<li><p>二级标题最终的序号样式如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424492.png" alt="image-20221206142411436"></p>
</li>
<li><p>然后设置二级标题的字体风格，直接链接到word的二级标题字体风格<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424730.png" alt="image-20221206142420685"></p>
</li>
<li><p>二级标题列表的所有设置完毕，如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424880.png" alt="image-20221206142428828"></p>
</li>
</ul>
<p>(3)依次完成所有标题列表设置，例如三级标题，前两级的值来自于level1,level2，第三级设置数字格式即可，中间用.号隔开。完成以后各级标题就可以自动推导。</p>
<h2 id="Word导出原图"><a href="#Word导出原图" class="headerlink" title="Word导出原图"></a>Word导出原图</h2><p>Word默认图片如果直接复制出来，不是原图是压缩后的图。<br>保存原图方法： 文档另存为html网页格式，会把word文档转换成资源文件夹，里面有原始图片。</p>
<h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><h2 id="excel设置筛选"><a href="#excel设置筛选" class="headerlink" title="excel设置筛选"></a>excel设置筛选</h2><p>参考<a href="https://support.microsoft.com/zh-cn/office/%E7%AD%9B%E9%80%89%E5%8C%BA%E5%9F%9F%E6%88%96%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE-01832226-31b5-4568-8806-38c37dcc180e#:~:text=%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E7%AD%9B%E9%80%89%201%20%E9%80%89%E6%8B%A9%E8%A6%81%E7%AD%9B%E9%80%89%20%E5%88%97%E7%9A%84%E5%88%97%E6%A0%87%E9%A2%98%E7%AE%AD%E5%A4%B4%E3%80%82%202%20%E5%8F%96%E6%B6%88%20%28%E9%80%89%E6%8B%A9%22%29%20%22%EF%BC%8C,%E5%8D%95%E5%87%BB%E2%80%9C%20%E7%A1%AE%E5%AE%9A%20%E2%80%9D%E3%80%82%20%E5%88%97%E6%A0%87%E9%A2%98%E7%AE%AD%E5%A4%B4%20%22%E7%AD%9B%E9%80%89%20%E6%9B%B4%E6%94%B9%20%E3%80%82%20%E9%80%89%E6%8B%A9%E6%AD%A4%E5%9B%BE%E6%A0%87%E5%8F%AF%E6%9B%B4%E6%94%B9%E6%88%96%E6%B8%85%E9%99%A4%E7%AD%9B%E9%80%89%E3%80%82">筛选区域或表中的数据</a></p>
<ol>
<li><p>选中列，点击筛选</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302091144706.png" alt="image-20230209114432580"></p>
</li>
<li><p>可以按文字或者颜色筛选</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302091145967.png" alt="image-20230209114508910"></p>
</li>
</ol>
<h2 id="冻结首行"><a href="#冻结首行" class="headerlink" title="冻结首行"></a>冻结首行</h2><p>筛选行一般需要固定显示，因此设置冻结首行：</p>
<p>选中要固定显示行的下一行, 视图 -&gt; 冻结窗格 -&gt; 冻结首行</p>
]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记：RGB调色器</title>
    <url>/2022/04/18/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ARGB%E8%B0%83%E8%89%B2%E5%99%A8/</url>
    <content><![CDATA[<p>本文基于Qt官方示例<a href="https://doc.qt.io/qt-5/designer-quick-start.html#:~:text=%20Using%20Qt%20Designer%20involves%20four%20basic%20steps%3A,the%20slots%204%20Preview%20the%20form%20More%20"> A Quick Start to Qt Designer</a>, 实现自定义的slot函数，新增RGB色彩窗口显示色彩。</p>
<ul>
<li>本文源码：<a href="https://github.com/cursorhu/QtSampleTest/tree/master/1.rgbSlider">QtSampleTest&#x2F;1.rgbSlider</a></li>
<li>环境：基于Qt5.9 + Qt creater</li>
</ul>
<p>本文只记录项目过程中的注意事项，以及增量开发，其他部分参考Qt官方示例。</p>
<h2 id="1-UI部分"><a href="#1-UI部分" class="headerlink" title="1.UI部分"></a>1.UI部分</h2><ul>
<li>建立带UI的项目rgbSlider, 基于Qwidget生成默认自定义类名widget</li>
<li>双击widget.ui进入UI编辑</li>
</ul>
<p>UI 编辑模式下使用两种模式：widget编辑模式， slot&#x2F;signal编辑模式</p>
<ol>
<li><p>widget编辑模式如下：使用水平、网格布局<br>RGB数值控制部分，使用Label,  spinBox和scrollBar三种控件，按先竖直，后水平排列<br>RGB颜色显示部分，使用 graphicsView窗口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181201206.png"><br>注意调整布局的比例需要先选中，然后在layout属性调整<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181202783.png"></p>
</li>
<li><p>slot&#x2F;signal编辑模式<br>直接拖拽起始控件和目标控件，设置控件的信号和槽<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181203784.png"></p>
</li>
</ol>
<h2 id="2-自定义槽"><a href="#2-自定义槽" class="headerlink" title="2.自定义槽"></a>2.自定义槽</h2><p>graphicsView窗口预期效果是：只要调整RGB数值，自动显示对应的颜色<br>UI界面不能设置控件信号触发自定义槽，需要在代码中实现信号和槽的连接。</p>
<ol>
<li>右键转到graphicsView窗口的槽函数，自定义为 <code>Widget::on_rgbChanged()</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181400431.png"><br>函数实现如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;QColor&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;QPalette&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_rgbChanged()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> QPalette pal = QPalette();</span><br><span class="line"></span><br><span class="line"> QColor color;</span><br><span class="line"></span><br><span class="line"> //分别设置R,G,B,透明度</span><br><span class="line"></span><br><span class="line"> color.setRgb(ui-&gt;spinBoxRed-&gt;value(), ui-&gt;spinBoxGreen-&gt;value(), ui-&gt;spinBoxBlue-&gt;value(), 255);</span><br><span class="line"></span><br><span class="line"> //QPalette::Base</span><br><span class="line"></span><br><span class="line"> //Used mostly as the background color for text entry widgets, It is usually white or another light color.</span><br><span class="line"></span><br><span class="line"> pal.setColor(QPalette::Base, color);</span><br><span class="line"></span><br><span class="line"> ui-&gt;graphicsView-&gt;setPalette(pal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在UI基础上使用控件对象的方法，只需要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ui-&gt;控件名-&gt;控件的方法</span><br></pre></td></tr></table></figure>

<p>注意<code>setColor</code>可以给不同图层上色，这里使用<code>QPalette::Base</code>，而不能是<code>QPalette::Window</code>或<code>QPalette::Background</code></p>
<p>代码设置信号与槽, 注意，手动设置的代码要在<code>ui-&gt;setupUi(this);</code>的后面添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line"></span><br><span class="line"> QWidget(parent),</span><br><span class="line"></span><br><span class="line"> ui(new Ui::Widget)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxRed, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxGreen, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxBlue, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3.测试效果"></a>3.测试效果</h2><ul>
<li>拖动滑块，对应数值会更新，颜色同步更新</li>
<li>修改数值，对应滑块更新，颜色更新<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181410181.png"></li>
</ul>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Samba配置笔记</title>
    <url>/2023/01/30/Ubuntu%20Samba%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Samba基本概念"><a href="#Samba基本概念" class="headerlink" title="Samba基本概念"></a>Samba基本概念</h2><p>Samba是SMB protocol的应用程序实现，分为服务端和客户端；</p>
<p>Samba通常的使用场景：在同一局域网内的的Linux主机安装Samba服务，windows主机可以访问Linux Samba服务指定的共享目录。</p>
<p>在嵌入式开发中通常在windows 上编辑Samba共享目录下的代码，通过 Linux环境编译代码，而无需在两个主机间拷贝代码文件。</p>
<h2 id="Ubuntu安装Samba服务"><a href="#Ubuntu安装Samba服务" class="headerlink" title="Ubuntu安装Samba服务"></a>Ubuntu安装Samba服务</h2><p>Ubuntu 20.04和22.04 版本，安装Samba服务参考：</p>
<p><a href="https://linux.how2shout.com/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux/#:~:text=Steps%20to%20install%20SAMBA%20on%20Ubuntu%2022.04%20LTS,...%206%206.%20Access%20the%20shared%20folder%20">www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux</a><br>主要流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#install and run samba service</span><br><span class="line">sudo apt install samba -y</span><br><span class="line"></span><br><span class="line">#enable auto start samba service</span><br><span class="line">sudo systemctl enable --now smbd</span><br><span class="line"></span><br><span class="line">#firewall allow samba</span><br><span class="line">sudo ufw allow samba</span><br><span class="line"></span><br><span class="line">#add system user to sambashare group</span><br><span class="line">sudo usermod -aG sambashare $USER</span><br><span class="line"></span><br><span class="line">#set passwd for sambashare</span><br><span class="line">sudo smbpasswd -a $USER</span><br><span class="line"></span><br><span class="line">#check samba service is running</span><br><span class="line">systemctl status smbd</span><br><span class="line"></span><br><span class="line">#share the folder in ubuntu GUI checkbox</span><br><span class="line">右键要共享的home文件夹properties -&gt; local Network Share -&gt; share this folder -&gt;share name不能直接用用户名，可以用&#x27;用户名+Home&#x27;</span><br></pre></td></tr></table></figure>

<p>显示无权共享：非root用户要共享&#x2F;home，需要修改smb.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br><span class="line">在[global]新增usershare owner only = false</span><br><span class="line">sudo systemctl restart smbd</span><br></pre></td></tr></table></figure>



<h2 id="Windows访问Samba共享目录"><a href="#Windows访问Samba共享目录" class="headerlink" title="Windows访问Samba共享目录"></a>Windows访问Samba共享目录</h2><p>windows下可以在文件浏览器直接访问Linux主机ip查看共享的Linux目录</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301103020.png" alt="image-20230130110305978"></p>
<p>首次windows访问共享目录有权限问题（不能写入），需要在Linux修改共享目录&#x2F;home的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /home -R </span><br></pre></td></tr></table></figure>

<p>为了以后方便连接，可以创建网络位置，参考：<a href="www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux">6. Access the shared folder On Windows 11 or 10</a></p>
<p>如果一个主机有两个samba共享目录，windows不允许多重连接；</p>
<p>要更改连接目录，操作如下：</p>
<p>win10系统在搜索框搜索【凭据管理器】，然后删除已有的windows samba网络连接凭据</p>
<p><code>win+R</code> CMD输入 <code>net use * /del /y</code>断开所有远程链接，包括samba网络连接</p>
<p>重新配置windows samba网络连接</p>
<h2 id="重装Samba"><a href="#重装Samba" class="headerlink" title="重装Samba"></a>重装Samba</h2><p>Samba的配置文件位于&#x2F;etc&#x2F;samba&#x2F;smb.conf，如果此文件被错误配置或者误删除，需要重装Samba，流程如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove samba --purge //删掉samba服务</span><br><span class="line">sudo apt-get remove samba-common --purge //这一步是关键，只重装samba不会恢复smb.conf</span><br><span class="line">sudo apt-get autoremove //删掉其他samba依赖库</span><br><span class="line">sudo apt-get install samba //重装，包括samba和samba-common等</span><br></pre></td></tr></table></figure>

<h2 id="Samba使用示例"><a href="#Samba使用示例" class="headerlink" title="Samba使用示例"></a>Samba使用示例</h2><p>Samba最重要的特性是两个主机之间直接共享目录，不需要用户去拷贝文件。</p>
<p>在代码开发中，在windows主机的VSCode或其他编辑器直接打开Linux主机共享目录的代码，然后SSH远程Linux主机去编译。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu SSH服务配置笔记</title>
    <url>/2023/02/02/Ubuntu-SSH%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h1><h2 id="SSH基本概念"><a href="#SSH基本概念" class="headerlink" title="SSH基本概念"></a>SSH基本概念</h2><ul>
<li>SSH是Secure Shell缩写，实现安全远程登录</li>
</ul>
<p>​    SSH的安全性好，原因是其对数据进行加密，方式主要有两种：对称加密（密钥加密）和非对称加密（公钥加密）<br>​    对称加密指加密解密使用的是同一套秘钥。Client端把密钥加密后发送给Server端，Server用同一套密钥解密。对称加密的加密强度比较高，很难破解。但是如果有一个Client端的密钥泄漏，那么整个系统的安全性就存在严重的漏洞。<br>​    为了解决对称加密的漏洞，于是就产生了非对称加密。<br>​    非对称加密有两个密钥：“公钥”和“私钥”。公钥加密后的密文，只能通过对应的私钥进行解密。想从公钥推理出私钥几乎不可能，所以非对称加密的安全性比较高。</p>
<ul>
<li>SSH的加密原理中，使用了RSA非对称加密算法。</li>
</ul>
<p>​    整个过程：</p>
<p>​    （1）远程主机收到用户的登录请求，把自己的公钥发给用户。</p>
<p>​    （2）用户使用这个公钥，将登录密码加密后，发送回来。</p>
<p>​    （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<ul>
<li>关于中间人攻击（Man-in-the-middle attack）</li>
</ul>
<p>​    中间人攻击的概念：如果有人冒充远程主机将伪造的公钥发给用户，用户很难辨别公钥真伪，用户    会和伪造主机通信而不是真正的主机。</p>
<p>​    因为SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，是主机和用户之间自己签    发的，所有SSH从原理上无法彻底防止中间人攻击</p>
<ul>
<li><p>SSH使用首次验证方式减少中间人攻击的概率：</p>
<p>SSH首次连接会下载服务端的公钥，用户确认后公钥将被保存并信任。</p>
<p>下次访问时客户端将会核对服务端发来的公钥和本地保存的是否相同，如果不同就发出中间人攻击的警告拒绝连接，除非用户手动清除已保存的公钥。</p>
<p>所以，只要SSH首次连接没有中间人攻击，之后的SSH连接就无需担心中间人攻击</p>
</li>
</ul>
<h2 id="Ubuntu安装SSH服务"><a href="#Ubuntu安装SSH服务" class="headerlink" title="Ubuntu安装SSH服务"></a>Ubuntu安装SSH服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ssh -y</span><br><span class="line">sudo service ssh start</span><br><span class="line">sudo service ssh status</span><br></pre></td></tr></table></figure>

<p>在系统重启后ssh service会自启动，不需要<code>systemctl enable</code>去配置自启动</p>
<h2 id="Windows访问SSH服务"><a href="#Windows访问SSH服务" class="headerlink" title="Windows访问SSH服务"></a>Windows访问SSH服务</h2><ul>
<li><p>使用win+R CMD验证SSH连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh 远程主机用户名@远程主机IP</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用putty，xshell等工具访问主机</p>
</li>
</ul>
<p>参考：<a href="https://www.how2shout.com/how-to/how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7.html#:~:text=How%20do%20I%20SSH%20into%20Ubuntu%20from%20Windows%3F,to%20Ubuntu%20server%20via%20Putty%20SSH%20client%20">how2shout.com&#x2F;how-to&#x2F;how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7</a></p>
<p>首次登陆会验证RSA公钥（1024位）的MD5 fingerprint（128位）</p>
<blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当首次连接的公钥被接受以后，会保存在本地文件。下次再连接这台主机会跳过公钥警告，直接提示输入密码。如果以后的连接是中间人攻击，其公钥和本地的首次公钥不同，从而保证安全性。</p>
<ul>
<li>使用xftp, filezilla工具传输文件</li>
</ul>
<p>和putty，xshell配置类似</p>
<ul>
<li>使用scp命令传输文件</li>
</ul>
<p>在linux主机之间可以用scp传输文件和目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#从远程cp到本地</span><br><span class="line">scp username@ip_address:/home/username/filename .</span><br><span class="line">#从本地cp到远程</span><br><span class="line">scp filename username@ip_address:/home/username</span><br><span class="line">#拷贝目录</span><br><span class="line">scp -r source_dir username@ip_address:/home/username/target_dir</span><br></pre></td></tr></table></figure>

<h2 id="SSH远程开发"><a href="#SSH远程开发" class="headerlink" title="SSH远程开发"></a>SSH远程开发</h2><p>示例一：在SSH server和客户端建立后，可以使用VSCode和source insight等代码编辑工具改代码，用xftp传输代码到SSH Linux主机，用xshell远程编译。</p>
<p>示例二：VSCode安装SSH远程开发插件，可以直接远程SSH Linux主机完成代码编辑、编译，<a href="https://www.how2shout.com/how-to/how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7.html#:~:text=How%20do%20I%20SSH%20into%20Ubuntu%20from%20Windows%3F,to%20Ubuntu%20server%20via%20Putty%20SSH%20client%20">visualstudio.com&#x2F;Remote Development using SSH</a></p>
<h1 id="远程连接相关的Ubuntu配置"><a href="#远程连接相关的Ubuntu配置" class="headerlink" title="远程连接相关的Ubuntu配置"></a>远程连接相关的Ubuntu配置</h1><h2 id="Ubuntu设置静态IP"><a href="#Ubuntu设置静态IP" class="headerlink" title="Ubuntu设置静态IP"></a>Ubuntu设置静态IP</h2><p>在使用SSH和Samba连远程Ubuntu PC时，发现IP有时候会改变，因此需要配置Ubuntu PC为静态IP</p>
<p>1.ifconfig查看ethernet接口和当前IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~$ ifconfig</span><br><span class="line">eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.52.4.71  netmask 255.255.255.0  broadcast 10.52.4.255</span><br></pre></td></tr></table></figure>

<p>2.编辑Ubuntu的netplan配置文件&#x2F;etc&#x2F;netplan&#x2F;*.yaml，用tab补全找到具体的yaml，制定静态IP和DNS</p>
<p>参考 <a href="https://linuxconfig.org/netplan-network-configuration-tutorial-for-beginners">Netplan network configuration tutorial for beginners</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">    eno1:</span><br><span class="line">      addresses:</span><br><span class="line">        - 10.52.4.71/24</span><br><span class="line">      nameservers:</span><br><span class="line">         addresses:</span><br><span class="line">            - 10.52.1.1</span><br><span class="line">            - 10.52.1.2</span><br><span class="line">      #gateway4: 10.52.0.1</span><br><span class="line">      routes:</span><br><span class="line">         - to: default</span><br><span class="line">           via: 10.52.0.1</span><br></pre></td></tr></table></figure>

<p>以上IP和nameservers(DNS)是必须的，gateway4是网关，在ubuntu22被废弃（ubuntu22显示 &#96;&#96;gateway4<code> has been deprecated, use default routes instead.</code>）使用routes配置网关，参考 <a href="https://askubuntu.com/questions/1410750/netplan-gateway-has-been-deprecated">netplan-gateway-has-been-deprecated</a>。怎么获取这三个值，参考以下网络命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有</span><br><span class="line">nmcli</span><br><span class="line">#查看gateway</span><br><span class="line">netstat -rn 或 route -n</span><br><span class="line">#DNS配置文件</span><br><span class="line">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>例如nmcli输出如下，其中 <code> inet4 10.52.4.71/24</code>即当前IP&#x2F;mask， <code>route4 default via 10.52.0.1</code>即默认网关，<code>DNS configuration servers: 10.52.1.1 10.52.1.2</code>即nameservers</p>
<blockquote>
<p>eno1: connected to netplan-eno1<br>        “Intel I219-V”<br>        ethernet (e1000e), 18:C0:4D:1F:BA:B7, hw, mtu 1500<br>        ip4 default<br>        inet4 10.52.4.71&#x2F;24<br>        route4 10.52.4.0&#x2F;24 metric 100<br>        route4 10.52.0.1&#x2F;32 metric 100<br>        route4 default via 10.52.0.1 metric 100<br>        inet6 fe80::1ac0:4dff:fe1f:bab7&#x2F;64<br>        route6 fe80::&#x2F;64 metric 256</p>
<p>virbr0: connected (externally) to virbr0<br>        “virbr0”<br>        bridge, 52:54:00:13:EB:68, sw, mtu 1500<br>        inet4 192.168.122.1&#x2F;24<br>        route4 169.254.0.0&#x2F;16 metric 1000<br>        route4 192.168.122.0&#x2F;24 metric 0</p>
<p>lo: unmanaged<br>        “lo”<br>        loopback (unknown), 00:00:00:00:00:00, sw, mtu 65536</p>
<p>DNS configuration:<br>        servers: 10.52.1.1 10.52.1.2<br>        interface: eno1</p>
</blockquote>
<p>3.生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<p>ping确认网络正常：</p>
<blockquote>
<p>ubuntu@ubuntu-Z390-GAMING-X:~$ ping <a href="http://www.bing.com/">www.bing.com</a><br>PING china.bing123.com (202.89.233.101) 56(84) bytes of data.<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;1 ttl&#x3D;117 time&#x3D;27.1 ms<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;2 ttl&#x3D;117 time&#x3D;27.2 ms<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;3 ttl&#x3D;117 time&#x3D;27.2 ms</p>
</blockquote>
<p>如果DNS server或gateway不符合当前网络状况，ping会失败，输出：</p>
<blockquote>
<p>Name or service not known</p>
</blockquote>
<h2 id="Ubuntu禁止自动登出"><a href="#Ubuntu禁止自动登出" class="headerlink" title="Ubuntu禁止自动登出"></a>Ubuntu禁止自动登出</h2><p>自动登出会使SSH断开链接，按如下禁用</p>
<blockquote>
<p>setting-&gt;Privacy-&gt;Screen-&gt;Automatic Screen Lock (OFF)</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode配置笔记</title>
    <url>/2022/12/08/VSCode%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="修改工作区存储目录"><a href="#修改工作区存储目录" class="headerlink" title="修改工作区存储目录"></a>修改工作区存储目录</h2><p>VSCode会将每个工作区的一些配置、扩展、缓存等默认保存在C盘的AppData\Code\workspaceStorage，使用一段时间后数据能达到上十GB。</p>
<p>当C盘空间不足，用SpaceSniffer可以找到这些“数据垃圾”，但每隔一段时间清理也不是一劳永逸。</p>
<p>修改workspaceStorage存储路径到非系统盘：</p>
<p>1.首先选择VSCode在开始栏，状态栏，或桌面栏的快捷方式图标，常用哪个就修改哪个，右键属性：</p>
<p>添加启动的命令行选项，指定user-data-dir:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--user-data-dir &quot;目标路径，例如F:\VSCodeWorkspaceStorage&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081200216.png" alt="image-20221208120051137"></p>
<p>2.转移已有的workspaceStorage.</p>
<p>修改完成后，将%AppData%\Code下的所有内容拷贝到设置的目录中;  也可以删除%AppData%\Code，但是需要重新配置VSCode。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>以双斜杠&#x2F;&#x2F;注释和取消注释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">注释：ctrl + / </span><br><span class="line">取消注释：ctrl + /</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法二：</span><br><span class="line">注释：ctrl + k, ctrl + c </span><br><span class="line">取消注释：ctrl + k, ctrl + u</span><br></pre></td></tr></table></figure>

<p>以星号&#x2F;**&#x2F;注释和取消注释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释：shift + alt + a </span><br><span class="line">取消注释：shift + alt + a</span><br></pre></td></tr></table></figure>

<h3 id="更改快捷键"><a href="#更改快捷键" class="headerlink" title="更改快捷键"></a>更改快捷键</h3><p>File-&gt;Preference-&gt;KeyboardShortCuts</p>
<p>例如可以把块注释&#x2F;**&#x2F;快捷键改成<code>ctrl+Alt+/</code>，和行注释<code>ctrl+/</code>达成统一：</p>
<p>选择recording keys，直接录入要修改的快捷键</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302201101988.png" alt="image-20230220110133891"></p>
<h2 id="项目文件过滤"><a href="#项目文件过滤" class="headerlink" title="项目文件过滤"></a>项目文件过滤</h2><p>在项目的顶层目录中新建 <strong>.vscode</strong> 文件夹，在该文件夹下面新建 <strong>settings.json</strong> 文件</p>
<p>例如，对于Linux kernel项目，编译过的目录有大量编译输出文件(.o, .ko, .mod等)，只想查看和搜索驱动目录下的源码，过滤示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;files.exclude&quot;: &#123;</span><br><span class="line">        &quot;**/*.cmd&quot;: true, //当前所有目录的所有以.cmd结尾的文件</span><br><span class="line">        &quot;**/*.a&quot;: true,</span><br><span class="line">        &quot;**/*.o&quot;: true,</span><br><span class="line">        &quot;**/*.d&quot;: true,</span><br><span class="line">        &quot;**/*.mod&quot;: true,</span><br><span class="line">        &quot;**/*.mod.c&quot;: true,</span><br><span class="line">        &quot;**/*.ko&quot;: true,</span><br><span class="line"></span><br><span class="line">        &quot;[^drivers]*&quot;: true, //除了包含&#x27;d&#x27;&#x27;r&#x27;&#x27;i&#x27;&#x27;v&#x27;&#x27;e&#x27;&#x27;r&#x27;&#x27;s&#x27;目录以外的所有目录，近似等效于除了&quot;drivers&quot;文件夹以外的文件都被files.exclude</span><br><span class="line">        &quot;[^include]*&quot;: true,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;search.exclude&quot;: &#123;</span><br><span class="line">        &quot;[^driver]*&quot;: true,</span><br><span class="line">        &quot;[^include]*&quot;: true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正则表达式参考 <a href="https://geek-docs.com/regexp/regexp-tutorials/75_regular_expression_exclude_characters.html#:~:text=Regex%20%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%83%BD%E5%A4%9F%E7%94%A8%E9%AB%98%E6%95%88%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2%E7%AD%89%E6%93%8D%E4%BD%9C%E3%80%82%20%E5%9C%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%EF%BC%8C%E6%9C%89%E6%97%B6%E9%9C%80%E8%A6%81%E6%8E%92%E9%99%A4%E6%9F%90%E4%BA%9B%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%82%20%E6%9C%AC%E6%96%87%E5%B0%86%E4%BB%8B%E7%BB%8D%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E6%8E%92%E9%99%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%82%20%E6%8E%92%E9%99%A4%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%20%E5%9C%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20%5E%20%E7%AC%A6%E5%8F%B7%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%8C%B9%E9%85%8D%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%82,%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%20%20a%5D%20%E4%B8%8A%E8%BF%B0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%20%5E%20%E8%A1%A8%E7%A4%BA%E6%8E%92%E9%99%A4%E5%AD%97%E7%AC%A6%EF%BC%8C%20%5B%5D%20%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88%E3%80%82">正则表达式排除字符</a></p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows CMD 常用命令笔记</title>
    <url>/2023/01/30/Windows-CMD-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Tree命令生成目录树"><a href="#Tree命令生成目录树" class="headerlink" title="Tree命令生成目录树"></a>Tree命令生成目录树</h1><blockquote>
<p>tree 命令的目录格式：TREE 【drive：】【path】【&#x2F;F】【&#x2F;A】</p>
<ul>
<li>可在cmd内输入（help tree 或 tree &#x2F; ？）查看</li>
<li>&#x2F;F  显示每个文件夹中文件的名称</li>
<li>&#x2F;A  使用ASCII字符，而不使用拓展字符</li>
</ul>
</blockquote>
<p>示例一：只显示路径名不显示文件名</p>
<p><code>TREE 【drive：】【path】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301049746.png" alt="image-20230130104934713"></p>
<p>示例二：显示路径名和文件名</p>
<p><code>TREE 【drive：】【path】【/F】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301048851.png" alt="image-20230130104835813"></p>
<p>示例三：将目录树存入指定文件</p>
<p><code>TREE 【drive：】【path】 &gt; 文件路径】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301051100.png" alt="image-20230130105102054"></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim使用笔记.</title>
    <url>/2021/04/17/Vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最近在ChromeOS上做一些shell script测试用例开发，ChromeOS基于Debian9，但没有Ubuntu那种GNOME的gedit编辑器，更不谈安装Linux版VSCode，正好借此机会练习一下之前一直不熟悉的vim编辑器。</p>
<p>ChromeOS不方便截图，所以本文以ubuntu上的linux0.11代码为例，整理vim最常用的操作。</p>
<p>关于Linux上的文本编辑器基础概念，可以参考&lt;Linux命令行与shell脚本编程大全.第3版&gt;</p>
<h2 id="1-三种编辑模式"><a href="#1-三种编辑模式" class="headerlink" title="1. 三种编辑模式"></a>1. 三种编辑模式</h2><p>我将vim归为三种编辑模式：</p>
<ul>
<li><p>文本编辑模式<br>文本编辑模式是默认模式，vim编辑器会将按键解释成命令。在任意模式按esc进入此默认模式。</p>
</li>
<li><p>文本插入模式<br>文本插入模式， vim会将你在当前光标位置输入的每个键都插入到缓冲区，即文本输入字符。在普通模式下按下”i 键” 进入(含义:insert)</p>
</li>
<li><p>命令行模式<br>命令行模式和shell命令行类似，在普通模式下按下”: 键”进入(形似shell terminal的冒号)</p>
</li>
</ul>
<p>怎么知道当前处于哪种模式？<br>vim左下角是状态行，以下是三种模式的状态示例：</p>
<ul>
<li><code>vim init/main.c</code>默认进入文本编辑模式，下面显示文件名和行号<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171047554.png"></li>
</ul>
<p>输入i, 进入文本插入模式，下面显示insert状态<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171052433.png"></p>
<p>按esc退出文本编辑，再输入<code>:</code> 进入命令行模式，例如输入<code>:wq</code>保存文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171053124.png"></p>
<p>还有一种visual模式是复制粘贴时会用到：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181032041.png"></p>
<p>下面讲文本编辑模式和命令行模式的常用命令<br>主要分为几类场景：</p>
<ul>
<li>光标移动</li>
<li>增删改查</li>
<li>文件保存</li>
</ul>
<p>光标移动类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>移到第一行 (gg重来)</td>
</tr>
<tr>
<td>G</td>
<td>移到最后一行 (记为大G)</td>
</tr>
<tr>
<td>PageUp&#x2F;PageDown</td>
<td>翻页</td>
</tr>
<tr>
<td>:行号</td>
<td>光标移动到指定行(属于命令行模式)</td>
</tr>
</tbody></table>
<p>增删改查类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>进入insert模式，在当前光标的左侧输入</td>
</tr>
<tr>
<td>a</td>
<td>追加文本（append），在当前光标的右侧输入</td>
</tr>
<tr>
<td>o</td>
<td>插入空行，在空行光标处可输入</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行 (记为双击delete)</td>
</tr>
<tr>
<td>dw</td>
<td>删除当前词（记为delete word）</td>
</tr>
<tr>
<td>delete键，或x键</td>
<td>删除当前字符，注意，Backspace在vim没有删除的作用！</td>
</tr>
<tr>
<td>v+方向键选中+y</td>
<td>复制选中的文本，v: visual，可视光标选中的文本范围， y: yank 复制</td>
</tr>
<tr>
<td>yw</td>
<td>复制当前词</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p</td>
<td>在复制之后，粘贴文本(paste)，注意粘贴内容来自vim缓冲区，而不是外部剪切板的</td>
</tr>
<tr>
<td>dw&#x2F;dd + p</td>
<td>剪切，d操作删除的文本位于缓冲区，可以直接用p粘贴</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>(当前文件内)查找字符串，按n查找下一个</td>
</tr>
<tr>
<td>:s&#x2F;old&#x2F;new&#x2F;g</td>
<td>(当前文件内)全局查找和替换</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步</td>
</tr>
</tbody></table>
<p>文件保存类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:q!</td>
<td>不保存文件退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存文件退出</td>
</tr>
</tbody></table>
<h2 id="2-多文件编辑"><a href="#2-多文件编辑" class="headerlink" title="2.多文件编辑"></a>2.多文件编辑</h2><p>下面讲多个文本的常用命令<br>主要分为几类场景：</p>
<ul>
<li>多文本搜索</li>
<li>多文件编辑</li>
</ul>
<p>多文本搜索类：<br>参考<a href="https://thevaluable.dev/vim-search-find-replace/"># Vim Search and Replace With Examples</a><br>本文只以quickfix方式为例：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>:vimgrep pattern **</code></td>
<td>搜索当前目录和子目录的包含指定pattern的文件，vimgrep可缩写为vim, ** 表示递归子目录</td>
</tr>
<tr>
<td><code>:vimgrep pattern **/*.c</code></td>
<td>同上，只搜索.c文件</td>
</tr>
<tr>
<td>:copen</td>
<td>搜索完后使用此命令打开文件列表，才能用光标选择</td>
</tr>
<tr>
<td>:cn (cnext) 和 :cp (cprev)</td>
<td>上下选择搜索文件列表</td>
</tr>
</tbody></table>
<p>示例：搜索linux0.11下的所有包含main的.c文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171959744.png"></p>
<p>quickfix list即文件列表，copen后可方向键选择打开文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205172002631.png"></p>
<ul>
<li>多文件编辑<br><strong>打开多个文件，分隔并列显示</strong></li>
</ul>
<ol>
<li>用vim打开文件后，命令行输入<code>:vs newfile</code>，竖排并列打开新文件（vs是vertical split缩写，竖排分隔）</li>
<li>特殊用法：<code>:vs ./</code>可以打开当前路径下的所有文件列表</li>
<li>在窗口间切换：<code>ctrl + ww</code></li>
<li>关闭文件只需要先切换到窗口再<code>:q!</code></li>
<li>调整竖排的窗口比例：<br> 先按ctrl+w选择窗口模式，再按&lt;&gt;+-调整。&lt; 左移，&gt; 右移，+ 上移， - 下移。</li>
</ol>
<p>示例：实现类似IDE的界面，左侧是文件列表，下侧是查找栏，右侧文件内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181006035.png"></p>
<p>  <strong>打开多个文件，不并列显示</strong><br>直接<code>:open file</code>打开新文件, 用 <code>:bn 和 :bN</code> (buffer next)切换文件, </p>
<p>  <strong>多文件之间复制粘贴</strong><br>vim的多个文件直接可以直接用 y + p 命令复制粘贴，因为共用vim环境的缓冲区</p>
<p>  退出所有文件<br><code>:qall!</code> 和 <code>:wqall</code></p>
<h2 id="3-类似IDE的跳转功能"><a href="#3-类似IDE的跳转功能" class="headerlink" title="3.类似IDE的跳转功能"></a>3.类似IDE的跳转功能</h2><p>推荐cscope插件，具体参考<a href="http://cscope.sourceforge.net/cscope_vim_tutorial.html">## The Vim&#x2F;Cscope tutorial</a></p>
<p>关键步骤：</p>
<ul>
<li>建立cscope.vim<br>将  <a href="http://cscope.sourceforge.net/cscope_maps.vim">http://cscope.sourceforge.net/cscope_maps.vim</a>  另存到文件<code>~/.vim/plugin/cscope_maps.vim</code></li>
<li>源码目录建立cscope.out<br><code>cscope -R</code> 建立符号索引，<code>ctrl+D</code> 退出</li>
<li>打开某符号的代码<br>例如 <code>vim -t main</code> 打开main所在文件</li>
<li>查找函数的定义和调用<br>如果光标已经在函数上，用 “<code>ctrl +＼</code>“ 再输入s，查找所有调用、定义该函数的列表，输入索引号回车<br>更推荐用cscope的命令行，<code>:cs f s 函数名</code> 是一样的结果，且光标不需要位于函数上。参数含义 f: find, s: symbol<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181103274.png"></li>
<li>跳转回之前的位置<br>“<code>ctrl + t</code></li>
</ul>
<h2 id="4-vim配置文件修改配色，行号"><a href="#4-vim配置文件修改配色，行号" class="headerlink" title="4.vim配置文件修改配色，行号"></a>4.vim配置文件修改配色，行号</h2><p>在有的Linux服务器上，Vim默认深蓝色亮瞎眼，修改配色为流行的Molokai.</p>
<p>效果对比:</p>
<p>默认配色看不清注释内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061435384.png" alt="image-20221206143528332"><br>Molokai配色<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061437401.png" alt="image-20221206143701354"></p>
<p>配置过程：</p>
<p>默认的配色方案：</p>
<pre><code>ls /usr/share/vim/vim74/colors
</code></pre>
<p>下载molokai配色文件,拷贝到vim配色文件目录</p>
<pre><code>cd ~
git clone git@github.com:tomasr/molokai.git
cd molokai/colors
cp molokai.vim /usr/share/vim/vim74/colors
</code></pre>
<p>在home下创建.vimrc用于配色详细设置</p>
<pre><code>cd ~
vim .vimrc
</code></pre>
<p>.vimrc设置如下：</p>
<pre><code>  set t_Co=256
  set background=dark
  set ts=4
  set nu!
  syntax on
  colorscheme molokai
</code></pre>
<p><code>:wq</code>保存后即生效<br>如果要全局用户通用，<code>vim /etc/vimrc</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Xshell配置笔记</title>
    <url>/2019/12/06/Xshell%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>配置x’shell的默认字体以及一些操作设置</p>
<h1 id="会话设置"><a href="#会话设置" class="headerlink" title="会话设置"></a>会话设置</h1><p>设置主机<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457347.png" alt="1"><br>设置主机账号密码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457719.png" alt="2"><br>设置xshell字体<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457495.png" alt="3"></p>
<h1 id="操作设置"><a href="#操作设置" class="headerlink" title="操作设置"></a>操作设置</h1><p>设置Ctrl+c,Ctrl+v复制粘贴<br>工具-&gt;选项-&gt;编辑按键<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457000.png" alt="4"><br>新建按键，按ctrl+c<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061458030.png" alt="5"><br>设置功能为复制<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061458880.png" alt="6"><br>同理设置ctrl+v为粘贴<br>注意,原shell的ctrl+c终止程序，被替换成了shift+ctrl+c</p>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>esp32笔记之PWM实现LED呼吸灯</title>
    <url>/2023/05/05/esp32%E7%AC%94%E8%AE%B0%E4%B9%8BPWM%E5%AE%9E%E7%8E%B0LED%E5%91%BC%E5%90%B8%E7%81%AF/</url>
    <content><![CDATA[<h2 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h2><p>先从应用上讲讲PWM：</p>
<p>有一盏日光灯，一般我们只能打开它或者关闭它，不存在中间状态；</p>
<p>有另一个LED灯，支持在一秒以内极快速的速度开关开关，其变化超过人眼识别的24帧率，LED灯看上去就像一直开着，但亮度比常开暗一些；如果控制灯快速开关过程中的打开时间和关闭时间的比例，就可以调节人眼看到的灯亮度。</p>
<p>以上就是PWM的大概应用原理：用高频率的开关信号，控制输出信号的平均强度，使输出信号能在0%到100%强度间任意调节。</p>
<p>用电路语句讲PWM原理：用数字信号的占空比来调制模拟信号的幅度(电压)。</p>
<p>PWM详细介绍参考：<a href="https://circuitdigest.com/tutorial/what-is-pwm-pulse-width-modulation">What is PWM: Pulse Width Modulation</a></p>
<p>脉冲宽度(pulse width)是指单位时间的高电平的持续时间，脉冲宽度越大被调制的模拟信号电压越大。</p>
<ul>
<li>在一定的频率下，通过不同的(高电平)占空比即可得到不同脉冲宽度，进而调节输出的模拟电压信号</li>
<li>在一定的占空比下，通过不同的频率实现不同的调节速度；频率要适配不同设备，不能任意设置，例如电机频率50HZ，MCU外设1000Hz。频率不决定被调制电压的幅度。</li>
</ul>
<p>PWM的调制信号如下：</p>
<p><img src="https://circuitdigest.com/sites/default/files/inlineimages/pulse-width-modulation-duty-cycle.gif" alt="img"></p>
<p>PWM调制电路通常用RC filter实现：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051659127.jpg" alt="Converting-PWM-signals-into-Analog"></p>
<p>PWM一般对具体设备使用固定频率，再调整高电平的占空比决定模拟信号的幅度。</p>
<p>如下图，占空比从0%调节到100%，对应输出电压为0V~5V</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305061100234.jpg" alt="Pulse-Width-Modulation"></p>
<p>从原理上讲就是开关控制，在一个周期内调制信号的高电平时间越长，RC电荷积分更多，输出电压越大：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051657299.png" alt="image-20230505165748199"></p>
<h2 id="MicroPython控制PWM"><a href="#MicroPython控制PWM" class="headerlink" title="MicroPython控制PWM"></a>MicroPython控制PWM</h2><p>官方tutorial参考：</p>
<p><a href="https://docs.micropython.org/en/latest/esp32/quickref.html">Quick reference for the ESP32</a> PWM (pulse width modulation)</p>
<p><a href="https://docs.micropython.org/en/latest/esp32/tutorial/pwm.html#esp32-pwm">Pulse Width Modulation</a> 其中有调整频率和占空比的sample code:</p>
<ul>
<li><p>Example of a smooth frequency change:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">F_MIN = 500</span><br><span class="line">F_MAX = 1000</span><br><span class="line"></span><br><span class="line">f = F_MIN</span><br><span class="line">delta_f = 1</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), f)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.freq(f)</span><br><span class="line"></span><br><span class="line">    sleep(10 / F_MIN)</span><br><span class="line"></span><br><span class="line">    f += delta_f</span><br><span class="line">    if f &gt;= F_MAX or f &lt;= F_MIN:</span><br><span class="line">        delta_f = -delta_f</span><br></pre></td></tr></table></figure>
</li>
<li><p>Example of a smooth duty change:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">DUTY_MAX = 2**16 - 1</span><br><span class="line"></span><br><span class="line">duty_u16 = 0</span><br><span class="line">delta_d = 16</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), 1000, duty_u16=duty_u16)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.duty_u16(duty_u16)</span><br><span class="line"></span><br><span class="line">    sleep(1 / 1000)</span><br><span class="line"></span><br><span class="line">    duty_u16 += delta_d</span><br><span class="line">    if duty_u16 &gt;= DUTY_MAX:</span><br><span class="line">        duty_u16 = DUTY_MAX</span><br><span class="line">        delta_d = -delta_d</span><br><span class="line">    elif duty_u16 &lt;= 0:</span><br><span class="line">        duty_u16 = 0</span><br><span class="line">        delta_d = -delta_d</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="呼吸灯示例"><a href="#呼吸灯示例" class="headerlink" title="呼吸灯示例"></a>呼吸灯示例</h2><p>参考：<a href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/03.PWMhuxideng">itproject.cn&#x2F;Python+ESP32快速上手&#x2F;3.PWM呼吸灯</a></p>
<p>esp32的micropython代码以script形式执行，主程序必须命名为main.py(参考 <a href="https://docs.micropython.org/en/v1.9.3/pyboard/pyboard/tutorial/script.html">Running your first script</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from machine import Pin, PWM</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">led2 = PWM(Pin(2))</span><br><span class="line">led2.freq(1000)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    for i in range(0, 1024):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br><span class="line">        </span><br><span class="line">    for i in range(1023, -1, -1):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br></pre></td></tr></table></figure>

<p>LED渐变呼吸闪烁：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305052003803.gif" alt="mmexport1683287925729"></p>
<p>如果将led duty调整为512，最大亮度会变小，验证了最大占空比决定最大电压</p>
<p>如果将led freq调整为50，最大亮度不变，但led渐变过程中会闪烁，也就是说开关调节频率太低，导致人眼都可以观察到led的开关电，看上去就是led闪烁</p>
]]></content>
      <categories>
        <category>esp32</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title>esp32笔记之环境搭建</title>
    <url>/2023/05/04/esp32%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>esp32是乐鑫的SOC，支持Wifi, BLE等IOT功能；官方教程：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html">ESP-IDF编程指南</a></p>
<h1 id="ESP-IDF环境搭建"><a href="#ESP-IDF环境搭建" class="headerlink" title="ESP-IDF环境搭建"></a>ESP-IDF环境搭建</h1><p>按官方教程在Linux ubuntu搭建ESP-IDF开发环境，有clone idf一直失败的问题</p>
<p>本节记录不用翻墙搭建ESP-ID环境的过程，视频参考：<a href="https://b23.tv/VCYbC2m">Linux 如何安装 ESP-IDF ESP32 开发环境搭建</a></p>
<h2 id="版本发布、下载"><a href="#版本发布、下载" class="headerlink" title="版本发布、下载"></a>版本发布、下载</h2><p><a href="https://github.com/espressif/esp-idf/releases">https://github.com/espressif/esp-idf/releases</a></p>
<p>手动下载release版本的idf压缩包，例如下载esp-idf-v5.0.1.zip</p>
<p>解压到 ~&#x2F;esp&#x2F;esp-idf (<code>mv esp-idf-v5.0.1 esp-idf</code>)</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git wget flex bison gperf python3 python3-venv python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0</span><br></pre></td></tr></table></figure>

<h2 id="安装-ESP-IDF"><a href="#安装-ESP-IDF" class="headerlink" title="安装 ESP-IDF"></a>安装 ESP-IDF</h2><p>安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">./install.sh esp32 #esp32 chip,用此命令即可</span><br><span class="line">./install.sh all #所有esp chips</span><br></pre></td></tr></table></figure>

<p>如果安装遇到网络问题，需要设置下载服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">export IDF_GITHUB_ASSETS=&quot;dl.espressif.com/github_assets&quot;</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>如果遇到 Python 包安装问题则需要设置 Python 源</p>
<h2 id="设置环境变量："><a href="#设置环境变量：" class="headerlink" title="设置环境变量："></a>设置环境变量：</h2><p>每次运行都export环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. $HOME/esp/esp-idf/export.sh</span><br></pre></td></tr></table></figure>

<p>或把将以下语句加入 ~&#x2F;.bashrc，每次执行只需要 <code>get_idf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias get_idf=&#x27;. $HOME/esp/esp-idf/export.sh&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="串口相关设置"><a href="#串口相关设置" class="headerlink" title="串口相关设置"></a>串口相关设置</h2><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/establish-serial-connection.html">与 ESP32 创建串口连接</a></p>
<p>查看串口: ls &#x2F;dev&#x2F;tty* (esp32应该是ttyUSB0)</p>
<p>必须将将用户添加到 <code>dialout</code> 组，从而获许串口读写权限，否则串口无法连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br></pre></td></tr></table></figure>

<h2 id="编译和烧录"><a href="#编译和烧录" class="headerlink" title="编译和烧录"></a>编译和烧录</h2><ul>
<li>设置：idf.py menuconfig</li>
<li>编译：idf.py build</li>
<li>烧录：idf.py -p PORT 【-b BAUD】 flash</li>
<li>监视：idf.py -p PORT monitor，使用快捷键 <code>Ctrl+]</code>，退出 IDF 监视器</li>
<li>一次性执行构建、烧录和监视过程：idf.py -p PORT flash monitor</li>
</ul>
<h1 id="MicroPython环境搭建"><a href="#MicroPython环境搭建" class="headerlink" title="MicroPython环境搭建"></a>MicroPython环境搭建</h1><p>分为esp32侧的Firmware和PC侧的IDE两部分。</p>
<p>本文是Linux环境，windows环境参考：<a href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/01.dajianhuanjing">Thonny+MicroPython+ESP32开发环境搭建</a></p>
<h2 id="ESP32安装MicroPython"><a href="#ESP32安装MicroPython" class="headerlink" title="ESP32安装MicroPython"></a>ESP32安装MicroPython</h2><p>Micropython是在嵌入式平台上运行Python的基础库，参考：<a href="https://docs.micropython.org/en/latest/">https://docs.micropython.org/en/latest/</a></p>
<p>下载和安装esp32的Micropython，参考：<a href="https://micropython.org/download/esp32/">Installation instructions</a></p>
<p>先擦除flash, 其中esptool.py已经被esp-idf&#x2F;export.sh导出到环境变量；如果ls &#x2F;dev&#x2F;tty*显示有ttyUSB0，但esptool.py还找不到ttyUSB0，需要重启并用<code>get_idf</code>重新export idf，再插拔esp32就可以找到.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash</span><br></pre></td></tr></table></figure>

<p>烧写支持micropython的 &lt;esp32-firmware.bin&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 &lt;esp32-firmware.bin&gt;</span><br></pre></td></tr></table></figure>

<p>例如我的Firmware使用的是：</p>
<p><strong><a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.bin">v1.20.0 (2023-04-26) .bin</a></strong> [<a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.elf">.elf]</a> [<a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.map">.map]</a> [<a href="https://github.com/micropython/micropython/releases/tag/v1.20.0">Release notes]</a> (latest)</p>
<h2 id="使用VScode-Pymakr搭建Micropython开发环境"><a href="#使用VScode-Pymakr搭建Micropython开发环境" class="headerlink" title="使用VScode+Pymakr搭建Micropython开发环境"></a>使用VScode+Pymakr搭建Micropython开发环境</h2><p>总体的安装流程参考：<a href="https://randomnerdtutorials.com/micropython-esp32-esp8266-vs-code-pymakr/">MicroPython: Program ESP32&#x2F;ESP8266 using VS Code and Pymakr</a></p>
<p>Pymakr如何使用，参考<a href="https://github.com/pycom/pymakr-vsc/blob/next/GET_STARTED.md">Pymakr Getting Started</a></p>
<p>写一个LED闪烁的sample code验证开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from machine import Pin</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">led = Pin(2, Pin.OUT) #GPIO2, output mode</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">  led.value(not led.value())</span><br><span class="line">  sleep(0.5)</span><br></pre></td></tr></table></figure>

<p>LED如何控制，要根据esp32具体开发板的电路图找到LED相关的GPIO，以及配什么输入&#x2F;输出模式使GPIO导通&#x2F;关闭。</p>
<p>如下图，我的esp32 LED连接到GPIO2(IO2)，并且GPIO2输出高电平时LED导通</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042003091.png" alt="image-20230504200335998"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042004848.png" alt="image-20230504200411499"></p>
<p>选择VSCode的Pymakr Project -&gt; connect device -&gt; ’sync project to device‘，上传该LED python代码到esp32上运行；右键Pymakr Project的Hard reset device以后执行python代码</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051116409.png" alt="image-20230505111655320"></p>
<p>esp32 GPIO2的LED不停闪烁</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051156061.gif" alt="mmexport1683202673677"></p>
]]></content>
      <categories>
        <category>esp32</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo和next主题的配置笔记</title>
    <url>/2023/03/15/hexo%E5%92%8Cnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="hexo相关配置"><a href="#hexo相关配置" class="headerlink" title="hexo相关配置"></a>hexo相关配置</h3><p>hexo各页面的配置，参考 <a href="https://www.jianshu.com/p/3a05351a37dc">jianshu-Hexo的Next主题详细配置</a></p>
<p>hexo主页显示摘要，参考 <a href="https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%20Next%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E6%96%87%EF%BC%89/">Hexo Next主题首页配置为只显示部分摘要</a></p>
<h3 id="next设置字体"><a href="#next设置字体" class="headerlink" title="next设置字体"></a>next设置字体</h3><p>参考 <a href="https://tzynwang.github.io/2021/next-theme-edit/#:~:text=Search%20for%20the%20font%20family%20%E2%80%9CRoboto%E2%80%9D%20Click%20%E2%80%9C%2B,as%20the%20value%20for%20%E2%80%9Chost%E2%80%9D%20key%20in%20_config.next.yml">tzynwang.github.io&#x2F;2021&#x2F;next-theme-edit</a></p>
<p>下面重点描述如何使用Google Font来配置next主题的字体，基于next version 8.0.0</p>
<ul>
<li>推荐英文字体使用Roboto，中文字体使用 Noto Serif (注：Noto Serif字符集包含chinese&#x2F;Japanese&#x2F;korea等，参考 <a href="https://github.com/notofonts/noto-cjk">noto-cjk</a>；Noto Serif 是宋体但不是宋体思源，见后文)</li>
<li>在<a href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索框搜索字体英文名添加以上两种字体，产生URI(Uniform Resource Identifier)，复制href字段的引号内容</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151454240.png" alt="image-20230315145422134"></p>
<ul>
<li>在hexo的next配置文件<code>hexo\themes\next\_config.yml</code>的font字段添加host URI和字体名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span><br><span class="line">  host: https://fonts.googlefonts.cn/css?family=Noto+Serif|Roboto</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: x.x`. Use `em` as unit. Default: 1 (16px)</span><br><span class="line"></span><br><span class="line">  # Global font settings used for all elements inside &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Noto Serif</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for site title (.site-title).</span><br><span class="line">  title:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for posts (.post-body).</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto</span><br></pre></td></tr></table></figure>

<ul>
<li>在静态页面的base style配置文件<code>hexo\themes\next\source\css\_variables\base.styl</code>指定中文字体font-family-chinese为’Noto Serif’（注意看这里get_font_family解析到next配置文件_config.yml的字段’global’, ‘title’ … ‘codes’等作为静态页面的配置）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Font families.</span><br><span class="line">$font-family-chinese      = &#x27;Noto Serif&#x27;;</span><br><span class="line"></span><br><span class="line">$font-family-base         = $font-family-chinese, sans-serif;</span><br><span class="line">$font-family-base         = get_font_family(&#x27;global&#x27;), $font-family-chinese, sans-serif if get_font_family(&#x27;global&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-logo         = $font-family-base;</span><br><span class="line">$font-family-logo         = get_font_family(&#x27;title&#x27;), $font-family-base if get_font_family(&#x27;title&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-headings     = $font-family-base;</span><br><span class="line">$font-family-headings     = get_font_family(&#x27;headings&#x27;), $font-family-base if get_font_family(&#x27;headings&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-posts        = $font-family-base;</span><br><span class="line">$font-family-posts        = get_font_family(&#x27;posts&#x27;), $font-family-base if get_font_family(&#x27;posts&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-monospace    = monospace, consolas, Menlo, $font-family-chinese;</span><br><span class="line">$font-family-monospace    = get_font_family(&#x27;codes&#x27;), monospace, consolas, Menlo, $font-family-chinese if get_font_family(&#x27;codes&#x27;);</span><br></pre></td></tr></table></figure>

<p>自此next中英文字体都应该生效，<code>hexo g + hexo s</code> 重新部署验证一下发现中文字体似乎不是思源宋体？</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151606100.png" alt="image-20230315160648032"></p>
<p>原因是Noto Serif !&#x3D; Noto Serif SC (simplified chinese)，Noto Serif SC才是思源宋体</p>
<p><a href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索不到思源宋体，<a href="https://fonts.google.com/">google font原站</a>又打不开，因此需要直接替换URI，将fonts.googlefonts.cn替换为fonts.googleapis.com，Noto Serif替换为Noto Serif SC</p>
<p>next配置文件改动如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo\themes\next\_config.yml:</span><br><span class="line"></span><br><span class="line">font:</span><br><span class="line">    - host: https://fonts.googlefonts.cn/css?family=Noto+Serif|Roboto</span><br><span class="line">    + host: https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto</span><br><span class="line"></span><br><span class="line">    global:</span><br><span class="line">    - family: Noto Serif</span><br><span class="line">    + family: Noto Serif SC</span><br><span class="line">    </span><br><span class="line">hexo\themes\next\source\css\_variables\base.styl:</span><br><span class="line"></span><br><span class="line">// Font families.</span><br><span class="line">- $font-family-chinese = &#x27;Noto Serif&#x27;;</span><br><span class="line">+ $font-family-chinese = &#x27;Noto Serif SC&#x27;;</span><br></pre></td></tr></table></figure>

<p>验证结果为思源宋体：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151559719.png" alt="image-20230315155911647"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用笔记</title>
    <url>/2022/03/09/python%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Python使用正则表达式示例"><a href="#Python使用正则表达式示例" class="headerlink" title="Python使用正则表达式示例"></a>Python使用正则表达式示例</h2><p>Python的正则表达式比较全面的教程，参考<a href="https://www.programiz.com/python-programming/regex"># Python RegEx</a></p>
<p>使用背景：芯片ATE测试中，不同ATE平台的测试模式文件格式有不同，需要匹配字符串并按特定转换<br>转换前：</p>
<blockquote>
<p>Pattern “pll_dll_100m_test” {<br>waveform_start:<br>W pll_dll_100m_wft;</p>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>转后后：</p>
<blockquote>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;} W pll_dll_100m_wft;<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>规则：将以“W_xxx”的字符串放到下一个以“V_xxx”的字符串后面</p>
<p>利用python正则匹配，配合读取文件到字符串数组，实现如下转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">infile_name = <span class="built_in">input</span>(<span class="string">&quot;Please input the name of file in current directory to convert: &quot;</span>)</span><br><span class="line">name_flag = infile_name.find(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> name_flag == -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file name error, need input the suffix of file name&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(infile_name):</span><br><span class="line">        outfile_name = infile_name[<span class="number">0</span>:name_flag] + <span class="string">&quot;_updated&quot;</span> + infile_name[name_flag:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no such file!&quot;</span>)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">infile = <span class="built_in">open</span>(infile_name, <span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(outfile_name, <span class="string">&quot;w&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lines = infile.readlines()</span><br><span class="line">infile.close()</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">    str_obj = re.match(<span class="string">&#x27;[\s]*W[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;W ...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        temp_index = index</span><br><span class="line">        temp_str = str_obj.group()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_obj = re.match(<span class="string">&#x27;[\s]*V[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;V ...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                lines[temp_index] = <span class="string">&#x27;\n&#x27;</span> <span class="comment">#clear last &quot;W ...&quot;</span></span><br><span class="line">                lines[index] = str_obj.group() + <span class="string">&#x27; &#x27;</span> + temp_str + <span class="string">&#x27;\n&#x27;</span> <span class="comment">#add the &quot;W ...&quot; from &quot;V ...&quot; end</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">outfile.writelines(lines)</span><br><span class="line">outfile.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;outputfile is &quot;</span> + outfile_name)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的W和V前面加了额外的匹配项：<code>[\s]*</code>，是因为文件存在不可见的回车换行等引起，如果不加匹配不到</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6笔记之环境搭建</title>
    <url>/2023/05/06/xv6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本文在Ubuntu22.04上搭建xv6(x86版本)的开发环境，用于编译、调试xv6源码。</p>
<ul>
<li>xv6 x86版本参考<a href="https://pdos.csail.mit.edu/6.828/2018/overview.html">MIT6.828&#x2F;2018</a></li>
<li>xv6 riscv版本参考<a href="https://pdos.csail.mit.edu/6.828/2020/">MIT6.S081</a> ，MIT6.828从2019年以后以RISCV指令集实现，并拆分了课程</li>
</ul>
<p>两者的课程内容区别：</p>
<p>6.828 and 6.S081 will be offered as two separate classes. 6.S081 (Introduction to Operating Systems) will be taught as a stand-alone AUS subject for undergraduates, and will provide an introduction to operating systems. 6.828 will be offered as a graduate-level seminar-style class focused on research in operating systems. 6.828 will assume you have taken 6.S081 or an equivalent class.</p>
<p>为什么选用x86版本：</p>
<p>x86版本有更完善的资料和更细节的代码讲解，参考：</p>
<p><a href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p><a href="https://github.com/woai3c/MIT6.828">woai3c&#x2F;MIT6.828</a></p>
<p>学完x86版本再学riscv版本，只需要关注指令集差异即可</p>
<h2 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h2><p>主流程参考：<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">Tools Used in 6.828</a></p>
<p>这里只记录我操作过程中和该wiki的差异点</p>
<p>1.下载包有的连接失败，bing搜索到合适的下载源后，最终成功下载的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br></pre></td></tr></table></figure>

<p>2.编译Toolchain中的问题：</p>
<p>(0)<strong>注意!!!</strong> 在编译Toolchain完成以后要恢复默认的LD_LIBRARY_PATH，不要在toolchain配置了LD_LIBRARY_PATH的情况下去完成后续的安装qemu等其他任何操作，否则可能系统损害无法进入桌面且不能recovery，报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libgnutls.so.30 undefined symbol: __gmpz_limbs_write</span><br></pre></td></tr></table></figure>

<p>问题原因和解决办法参考：<a href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined"><a href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined">apt-get wants an older GNUTLS version to be defined</a></a></p>
<p><strong>LIB PATH导致系统损坏的经验：搭建开发环境配置的LD_LIBRARY_PATH不要随便export；在使用时export, 使用完毕后恢复</strong></p>
<p>(1)如果安装在&#x2F;usr&#x2F;local，所有make install都要sudo；安装在home不需要sudo</p>
<p>(2)编译gcc时报错：<code>configure: error: cannot compute suffix of object files: cannot compile</code></p>
<p>需要export PATH，由于所有编译包都安装在&#x2F;usr&#x2F;local&#x2F;，所以export PATH也为&#x2F;usr&#x2F;local&#x2F;，保存为export-path.sh方便重启后使用，也可以加到~&#x2F;.bashrc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>(3)编译gdb时报错：<code>error: no termcap library found</code></p>
<p>要手动下载termcap包并编译，操作过程和toolchain一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>完整的编译脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export PFX=~/xv6/toolchain #这里编译到home,也可以用/usr/local</span><br><span class="line">mkdir -p $PFX</span><br><span class="line">cd $PFX</span><br><span class="line"></span><br><span class="line">#install a development environment.</span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line">sudo apt-get install gcc-multilib</span><br><span class="line"></span><br><span class="line">#Building Your Own Compiler Toolchain</span><br><span class="line">#wget容易失败，因此这部分最好手动执行，确保全部下载成功</span><br><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br><span class="line"></span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">tar xjf gmp-5.0.2.tar.bz2</span><br><span class="line">cd gmp-5.0.2</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf mpfr-3.1.2.tar.bz2</span><br><span class="line">cd mpfr-3.1.2</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xzf mpc-0.9.tar.gz</span><br><span class="line">cd mpc-0.9</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf binutils-2.21.1.tar.bz2</span><br><span class="line">cd binutils-2.21.1</span><br><span class="line">./configure --prefix=$PFX --target=i386-jos-elf --disable-werror</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gcc-core-4.6.4.tar.bz2</span><br><span class="line">cd gcc-4.6.4</span><br><span class="line">mkdir build              # GCC will not compile correctly unless you build in a separate directory</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=$PFX \ </span><br><span class="line">    --with-gmp=$PFX --with-mpfr=$PFX --with-mpc=$PFX \ #指定gmp, mpfr, mpc位置</span><br><span class="line">    --target=i386-jos-elf --disable-werror \</span><br><span class="line">    --disable-libssp --disable-libmudflap --with-newlib \</span><br><span class="line">    --without-headers --enable-languages=c MAKEINFO=missing</span><br><span class="line">make all-gcc</span><br><span class="line">make install-gcc         # This step may require privilege (sudo make install-gcc)</span><br><span class="line">make all-target-libgcc</span><br><span class="line">make install-target-libgcc     # This step may require privilege (sudo make install-target-libgcc)</span><br><span class="line">cd ../..</span><br><span class="line"></span><br><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gdb-7.3.1.tar.bz2</span><br><span class="line">cd gdb-7.3.1</span><br><span class="line">./configure --prefix=$PFX \</span><br><span class="line">    --target=i386-jos-elf --program-prefix=i386-jos-elf- \</span><br><span class="line">    --disable-werror</span><br><span class="line">make all</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">i386-jos-elf-objdump -i</span><br><span class="line"># Should produce output like:</span><br><span class="line"># BFD header file version (GNU Binutils) 2.21.1</span><br><span class="line"># elf32-i386</span><br><span class="line">#  (header little endian, data little endian)</span><br><span class="line">#   i386...</span><br><span class="line"></span><br><span class="line">i386-jos-elf-gcc -v</span><br><span class="line"># Should produce output like:</span><br><span class="line"># Using built-in specs.</span><br><span class="line"># COLLECT_GCC=i386-jos-elf-gcc</span><br><span class="line"># COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/i386-jos-elf/4.6.4/lto-wrapper</span><br><span class="line"># Target: i386-jos-elf</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=&quot;&quot; #恢复系统本身的libpath(默认空)，避免装其他软件有lib冲突造成系统损坏</span><br></pre></td></tr></table></figure>

<h2 id="交叉编译的参数"><a href="#交叉编译的参数" class="headerlink" title="交叉编译的参数"></a>交叉编译的参数</h2><p>在交叉编译configure时，通常会需要设置–build、–host和–target选项。各个选项的含义如下：</p>
<ul>
<li>–build：编译所用的机器的平台。</li>
<li>–host：编译出的代码运行的平台。</li>
<li>–target：编译出来的工具链生成的代码的运行平台。这个选项不常用，一般只在编译gcc、ld等工具链的过程中用到。</li>
</ul>
<p>在不涉及到交叉编译的时候，–build、–host、–target缺省值都是本机平台，不需要特别设置。</p>
<p>在交叉编译的时候，比如需要在x86平台编译arm程序，就需要设置–build和–host选项；其中host的内容为目标平台名称，通常编译器的名字前缀就是目标平台名称，例如用arm-unknown-linux-gnueabi-gcc编译，–host设置为arm-unknown-linux-gnueabi；–build可以缺省不设置就是使用当前平台名称</p>
<h2 id="编译QEMU"><a href="#编译QEMU" class="headerlink" title="编译QEMU"></a>编译QEMU</h2><p>xv6使用的QEMU是patched version，要手动编译，过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/mit-pdos/6.828-qemu.git qemu</span><br><span class="line"></span><br><span class="line">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span><br><span class="line"></span><br><span class="line">#此qemu版本需要python2 (2.7), 由于python2和3不兼容, 且系统只有Python3, 因此需要安装</span><br><span class="line">sudo apt install python2</span><br><span class="line">python2 -V</span><br><span class="line">cd qemu</span><br><span class="line"></span><br><span class="line">./configure --disable-kvm --disable-werror --prefix=$PFX --target-list=&quot;i386-softmmu x86_64-softmmu&quot; --python=/usr/bin/python2</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>qemu编译错误的解决办法：<a href="https://github.com/woai3c/MIT6.828/blob/master/docs/install.md">MIT6.828 实验环境安装教程</a></p>
<p>其中以下错误的解决方法： 在 <code>qga/commands-posix.c</code> 文件中加 <code>#include &lt;sys/sysmacros.h&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qga/commands-posix.c: In function ‘dev_major_minor’:</span><br><span class="line">qga/commands-posix.c:633:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;.</span><br></pre></td></tr></table></figure>

<h2 id="运行xv6"><a href="#运行xv6" class="headerlink" title="运行xv6"></a>运行xv6</h2><p>下载6.828的jos lab，make产生kernel.img</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></pre></td></tr></table></figure>

<p>运行qemu的xv6之前，需要export PATH和LD_LIBRARY_PATH；运行之后要清掉LD_LIBRARY_PATH为空(重启或手动清除)</p>
<p>写export_xv6.sh如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PFX=~/xv6/toolchain</span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>建议给调用export_xv6.sh的命令加别名(alias)到.bashrc，可以用get-xv6命令一键export：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias get_xv6=&#x27;. $HOME/xv6/export_xv6.sh&#x27;</span><br></pre></td></tr></table></figure>

<p>如果是本地执行qemu(带GUI)用<code>make qemu</code>; 如果是远程终端执行用<code>make qemu-nox</code>。qemu内容如下表示qemu环境搭建OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit</span><br><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log </span><br><span class="line">VNC server running on `127.0.0.1:5900&#x27;</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：使用GDB调试多线程</title>
    <url>/2021/07/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-GDB简介"><a href="#1-GDB简介" class="headerlink" title="1.GDB简介"></a>1.GDB简介</h1><p>官网文档：<br><a href="https://www.gnu.org/software/gdb/documentation/">GDB: The GNU Project Debugger</a></p>
<p>关于GDB的原理：<br><a href="https://cloud.tencent.com/developer/article/1365186">GDB实现原理和使用范例</a><br><a href="http://oenhan.com/gdb-principle">GDB工作原理和内核实现</a><br><a href="http://www.docin.com/p-18618736.html">GDB的基本工作原理</a></p>
<p>其他教程：<a href="http://c.biancheng.net/gdb/">GDB调试教程</a></p>
<p>几个重点：</p>
<ul>
<li>多种运行方式：gdb启动程序再调试(独立功能程序)，gdb attach进程再调试(服务端程序)，gdb加载core dump调试(离线调试)</li>
<li>GDB的本质是“截获”被调试程序，attach用ptrace截获了OS和应用程序之间的通信, 端点本质是trap中断，截获了CPU正常取指执行流程</li>
</ul>
<p>本文源码：<a href="https://github.com/cursorhu/SimpleMultiThread/tree/master/4.gdb_thread">cursorhu&#x2F;SimpleMultiThread&#x2F;4.gdb_thread&#x2F;</a></p>
<h1 id="2-多线程程序的GDB调试"><a href="#2-多线程程序的GDB调试" class="headerlink" title="2.多线程程序的GDB调试"></a>2.多线程程序的GDB调试</h1><p>待调试代码：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 0;
std::mutex g_mutex;

void thread_func1()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        if(g_mydata == 1024)
            g_mydata = 0;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);
    t1.join();
    t2.join();
    return 0;
&#125;
</code></pre>
<p>编译：</p>
<pre><code>g++ -g -std=c++11 cppthread.cpp -o cppthread -lpthread
</code></pre>
<p>-g: 带debug信息，gdb要用<br>-lpthread：链接pthread库。当应用直接调用POSIX&#x2F;pthread接口，或Linux环境中运行多线程都需要</p>
<h2 id="attach方式调试"><a href="#attach方式调试" class="headerlink" title="attach方式调试"></a>attach方式调试</h2><p>(1)后台运行并获取PID</p>
<ul>
<li>GDB调试已运行的程序，cppthread线程写成死循环，后台运行。</li>
<li>ps -ef | grep NAME 获取PID</li>
<li>pstree可以查看线程关系</li>
<li>LWP:轻量级进程，是用户线程和内核的中间接口。用户级线程连接LWP上便具有内核线程的所有属性。因此可以认为LWP ID对应线程ID</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534342.png" alt="1"></p>
<p>(2)gdb attach，管控进程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051544779.png" alt="2"></p>
<p>(3)查看所有线程信息<br>*表示当前在1号线程，注意这个ID是GDB attach后分配的，真实线程ID参考LWP<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534546.png" alt="3"></p>
<p>(4)查看线程backtrace<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535566.png" alt="4"></p>
<p>(5)切换线程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535346.png" alt="5"></p>
<p>(6)单步调试线程</p>
<ul>
<li>注意，GDB调试时是支持线程切换的，等同正常执行多线程，也可以禁用切换：<code>set scheduler-locking on</code>。本示例有mutex锁,未见到切换</li>
<li><code>next</code>: 单步（一步），<code>next n</code>: 单步n步</li>
<li><code>watch 变量</code>，可见<code>next 6</code>后g_mydata + 1</li>
<li><code>watch</code>会自动隐式的加断点，后文会看到断点信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535751.png" alt="6"></p>
<p>(7)断点</p>
<ul>
<li><code>break i</code>: 在代码i行加断点， <code>break func</code>:在函数加断点</li>
<li><code>clear i</code>: 清除i行的断点， <code>delete id</code>: 清除指定id的断点</li>
<li>注意看watch引入了一个断点11</li>
<li><code>continue</code>：继续执行，通常配合断点使用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535502.png" alt="7"></p>
<p>(8)线程外调试+多断点<br>两个工作线程都加断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535139.png" alt="8"><br>一次运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535180.png" alt="9"><br>继续运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536672.png" alt="10"></p>
<ul>
<li>Thread2和Thread3即工作线程，Thread1为主线程</li>
<li>Thread1会切到工作线程，LWP&#x3D;6080或6081</li>
<li>两次运行,Thread1切到的LWP不一样</li>
</ul>
<p>GDB显示主线程切到哪个工作线程，实际是CPU当前在执行哪个工作线程，因此两次运行到断点时，当前执行线程分别是Thread2和Thread3，主线程实际是阻塞的。</p>
<h2 id="GDB直接运行程序"><a href="#GDB直接运行程序" class="headerlink" title="GDB直接运行程序"></a>GDB直接运行程序</h2><p>用GDB运行程序的调试方式：</p>
<pre><code> gdb &lt; prog_name &gt;
</code></pre>
<p>(1)运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536065.png" alt="11"></p>
<p>(2)加断点和执行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536275.png" alt="12"></p>
<p>(3)查看变量值<br><code>p 变量</code>：打印变量，和<code>watch</code>相比不会加隐含的断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536108.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051537112.png" alt="14"></p>
<h2 id="core-dump文件方式调试"><a href="#core-dump文件方式调试" class="headerlink" title="core dump文件方式调试"></a>core dump文件方式调试</h2><p>有关core dump<br><a href="https://www.cnblogs.com/computer1-2-3/p/11114981.html">Linux 下如何产生core文件（core dump设置）</a><br><a href="https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/">Understand and configure core dumps on Linux</a><br><a href="https://www.cnblogs.com/uhziel/p/cpp_segmentation_fault.html">C++中段错误的常见情况</a><br><a href="https://blog.csdn.net/xuzhina/category_1322964.html">coredump问题原理探究(Linux版)
</a></p>
<p>下面修改前面的程序，制造core dump<br>(1)数组越界<br>cppthread_dump_array.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int g_mydata = 0;
std::mutex g_mutex;

char test_dump_buf[10] = &#123;0&#125;;

void thread_func1()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        char c;
        sprintf(&amp;c, &quot;%d&quot;, g_mydata);
        std::strcat(test_dump_buf, &amp;c); //持续追加g_mydata字符串
        if(g_mydata == 1024)
            g_mydata = 0;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;test_dump_buf: &quot; &lt;&lt; test_dump_buf &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538738.png" alt="15"><br>并未发生段错误，更不谈core dump。因为CPP对数组没有越界限制，这是个“合法”行为</p>
<p>(2)使用空指针<br>cppthread_dump_nullptr.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
&#123;
    public:
        Foo(int m)
        &#123;
            m_data = m;
        &#125;
        ~Foo()&#123;&#125;
        void printval() 
        &#123;
            std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
        &#125;
        void increase()
        &#123;
            ++m_data;
        &#125;
        int getval()
        &#123;
            return m_data;
        &#125;
        void resetval()
        &#123;
            m_data = 0;
        &#125;
        
    private:
        int m_data;
&#125;;

void thread_func1(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.increase();
        if(p.getval() == 1024)
            p.resetval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.printval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;    
    Foo *pFoo = new Foo(0);

    std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
    std::thread t2(thread_func2, std::ref(*pFoo));

    //t1.join();  //这里故意不join
    //t2.join();
    sleep(10);  //sleep等一下thread1,2
    
    delete pFoo; 
    pFoo = NULL;  //这时thread1,2还没执行完，形成了使用空指针的条件
            
    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538644.png" alt="16"></p>
<p>下面gdb调试这个core dump</p>
<ul>
<li><p>设置core dump文件大小限制为不受限<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538876.png" alt="17"><br>最好写入配置文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538835.png" alt="18"></p>
</li>
<li><p>gdb加载程序和core dump文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538139.png" alt="19"><br>可见siganl 6发生，使进程终止</p>
</li>
<li><p>看dump位置，bt或where都可以<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538557.png" alt="20"></p>
</li>
<li><p>看所有线程的栈<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538027.png" alt="21"></p>
</li>
<li><p>直接看dump附近的代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051539217.png"></p>
</li>
</ul>
<p>结论：根据bt&#x2F;where, dump发生时，主进程在在执行67行：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542767.png" alt="image-20221205154207720"></p>
<p>根据源码，具体是工作线程调用对象的方法时发生<br>再看dump打印，正好要打印<code>m_data = 10</code>的时候dump，结合main中sleep(10)和工作线程sleep(1)，dump原因是main把对象指针置空了，而两个工作线程还在调用对象的方法，位置是thread_func2的p.printval()处</p>
<h2 id="一个示例：调试死锁"><a href="#一个示例：调试死锁" class="headerlink" title="一个示例：调试死锁"></a>一个示例：调试死锁</h2><p>最常见的死锁是双重加锁，和双重delete的道理一样，代码复杂了，层层调用的情况下容易出现<br>示例代码cppthread_deadlock.cpp：<br>线程函数和其调用的类方法都加锁了，形成死锁</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
&#123;
    public:
        Foo(int m)
        &#123;
            m_data = m;
        &#125;
        ~Foo()&#123;&#125;
        void printval() 
        &#123;
            std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
        &#125;
        void increase()
        &#123;
            g_mutex.lock(); //故意制造双重加锁
            ++m_data;
            g_mutex.unlock();
        &#125;
        int getval()
        &#123;
            return m_data;
        &#125;
        void resetval()
        &#123;
            m_data = 0;    
        &#125;
        
    private:
        int m_data;
&#125;;

void thread_func1(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.increase();
        if(p.getval() == 1024)
            p.resetval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.printval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;    
    Foo *pFoo = new Foo(0);

    std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
    std::thread t2(thread_func2, std::ref(*pFoo));

    t1.join();
    t2.join();
    
    delete pFoo;
    pFoo = NULL;
            
    return 0;
&#125;
</code></pre>
<p>调试：</p>
<ul>
<li>直接运行方式，要run起来才有线程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542989.png" alt="23"></p>
<ul>
<li>backtrace可见两个线程都停止于lock_wait()，其中thread2回溯看到死锁代码在45行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051546645.png" alt="24"></p>
<p>对于互斥锁推荐用RAII机制的<code>std::lock_guard&lt;mutex&gt; lockGuard(m)</code>，能避免忘记unlock情况。但在此示例中，lock_guard也会双重加锁。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>thread gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：多线程的同步机制</title>
    <url>/2021/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>本文讲解并发环境中的几个线程同步示例<br>线程同步，即多个线程如何协调，谁先谁后<br>本文基于Linux&#x2F;POSIX API<br>本系列源码：<a href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p>生产者&#x2F;消费者模式是并发环境常见的模式，简单地讲，通过中介缓冲，支持多组任务并发执行，避免任务间发生通信阻塞。<br>参考：<a href="https://blog.csdn.net/darkdragonking/article/details/89208124">生产者&#x2F;消费者模式的理解及实现</a></p>
<p>常用的实现方式</p>
<ul>
<li>互斥量(参考<a href="http://47.100.221.149:9010/blog/post/admin/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89">多线程入门（一）</a>)</li>
<li>信号量</li>
<li>条件变量</li>
<li>读写锁</li>
</ul>
<h1 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h1><p>关于LInux信号量：<a href="https://www.jianshu.com/p/6e72ff770244">Linux信号量</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
&#123;
public:
    Task(int taskID)
    &#123;
        this-&gt;taskID = taskID;
    &#125;
    
    void doTask()
    &#123;
        std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
    &#125;
    
private:
    int taskID;
&#125;;

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
sem_t            mysemaphore;

void* consumer_thread(void* param)
&#123;    
    Task* pTask = NULL;
    while (true)
    &#123;
        struct timespec ts;
        ts.tv_sec = 3;
        ts.tv_nsec = 0;
        
        if (sem_timewait(&amp;mysemaphore, &amp;ts) != 0)
        &#123;
            if (errno == ETIMEOUT)
            &#123;
                std::cout &lt;&lt; &quot;ETIMEOUT&quot; &lt;&lt; std::endl;
            &#125;
            continue;
        &#125;
        
        if (tasks.empty())
            continue;
        
        pthread_mutex_lock(&amp;mymutex);    
        pTask = tasks.front();
        tasks.pop_front();
        pthread_mutex_unlock(&amp;mymutex);
        
        pTask-&gt;doTask();
        delete pTask;
    &#125;
    
    return NULL;
&#125;

void* producer_thread(void* param)
&#123;
    int taskID = 0;
    Task* pTask = NULL;
    
    while (true)
    &#123;
        pTask = new Task(taskID);
            
        pthread_mutex_lock(&amp;mymutex);
        tasks.push_back(pTask);
        std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
        
        pthread_mutex_unlock(&amp;mymutex);
        
        //释放信号量，通知消费者线程
        sem_post(&amp;mysemaphore);
        
        taskID ++;

        //休眠1秒
        sleep(1);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_mutex_init(&amp;mymutex, NULL);
    //初始信号量资源计数为0
    sem_init(&amp;mysemaphore, 0, 0);

    //创建5个消费者线程
    pthread_t consumerThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
    &#125;
    
    //创建一个生产者线程
    pthread_t producerThreadID;
    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

    pthread_join(producerThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(consumerThreadID[i], NULL);
    &#125;
    
    sem_destroy(&amp;mysemaphore);
    pthread_mutex_destroy(&amp;mymutex);

    return 0;
&#125;
</code></pre>
<p>说明几点：</p>
<ul>
<li>信号量和锁一样，全局的</li>
<li>sem_post和sem_wait是P(), V()操作的具体实现，即计数+1，-1</li>
</ul>
<h1 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h1><p>关于条件变量(cv)：<a href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量(condition variables)</a><br>条件变量同锁一起使用使得线程可以以一种无竞争的方式等待任意条件的发生。所谓无竞争就是，条件改变这个信号会发送到所有等待这个信号的线程。</p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
&#123;
public:
    Task(int taskID)
    &#123;
        this-&gt;taskID = taskID;
    &#125;
    
    void doTask()
    &#123;
        std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
    &#125;
    
private:
    int taskID;
&#125;;

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
pthread_cond_t   mycv;

void* consumer_thread(void* param)
&#123;    
    Task* pTask = NULL;
    while (true)
    &#123;
        pthread_mutex_lock(&amp;mymutex);
        while (tasks.empty())
        &#123;                
            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
            pthread_cond_wait(&amp;mycv, &amp;mymutex);
        &#125;
        
        pTask = tasks.front();
        tasks.pop_front();

        pthread_mutex_unlock(&amp;mymutex);
        
        if (pTask == NULL)
            continue;

        pTask-&gt;doTask();
        delete pTask;
        pTask = NULL;        
    &#125;
    
    return NULL;
&#125;

void* producer_thread(void* param)
&#123;
    int taskID = 0;
    Task* pTask = NULL;
    
    while (true)
    &#123;
        pTask = new Task(taskID);
            
        pthread_mutex_lock(&amp;mymutex);
        tasks.push_back(pTask);
        std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
        
        pthread_mutex_unlock(&amp;mymutex);
        
        //释放条件信号，通知消费者线程
        pthread_cond_signal(&amp;mycv);
        
        taskID ++;

        //休眠1秒
        sleep(1);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_mutex_init(&amp;mymutex, NULL);
    pthread_cond_init(&amp;mycv, NULL);

    //创建5个消费者线程
    pthread_t consumerThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
    &#125;
    
    //创建一个生产者线程
    pthread_t producerThreadID;
    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

    pthread_join(producerThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(consumerThreadID[i], NULL);
    &#125;
    
    pthread_cond_destroy(&amp;mycv);
    pthread_mutex_destroy(&amp;mymutex);

    return 0;
&#125;
</code></pre>
<h1 id="读写锁实现"><a href="#读写锁实现" class="headerlink" title="读写锁实现"></a>读写锁实现</h1><p>关于读写锁，参考：<a href="https://www.cnblogs.com/love-DanDan/p/8723931.html">Linux：使用读写锁使线程同步</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;

int resourceID = 0;
pthread_rwlock_t myrwlock;

void* read_thread(void* param)
&#123;    
    while (true)
    &#123;
        //请求读锁
        pthread_rwlock_rdlock(&amp;myrwlock);

        std::cout &lt;&lt; &quot;read thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
                
        //使用睡眠模拟读线程读的过程消耗了很久的时间
        sleep(1);
                
        pthread_rwlock_unlock(&amp;myrwlock);
    &#125;
    
    return NULL;
&#125;

void* write_thread(void* param)
&#123;
    while (true)
    &#123;
        //请求写锁
        pthread_rwlock_wrlock(&amp;myrwlock);

        ++resourceID;
        std::cout &lt;&lt; &quot;write thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
                
        //使用睡眠模拟读线程读的过程消耗了很久的时间
        sleep(1);
                
        pthread_rwlock_unlock(&amp;myrwlock);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_rwlock_init(&amp;myrwlock, NULL);

    //创建5个请求读锁线程
    pthread_t readThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);
    &#125;
    
    //创建一个请求写锁线程
    pthread_t writeThreadID;
    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);

    pthread_join(writeThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(readThreadID[i], NULL);
    &#125;
    
    pthread_rwlock_destroy(&amp;myrwlock);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：线程库的使用</title>
    <url>/2021/07/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>多线程概述：应用层的多线程的目的就是让每一个任务（例如一系列函数调用）都认为自己独占CPU资源，即宏观上，多个任务可以同时执行（实际可能是轮转的串行执行）。<br>代码实现：线程库可以由编程语言的标准库或者操作系统的库实现，具体包含的头文件如下：</p>
<ul>
<li>C&#x2F;C++ : &lt; thread &gt;</li>
<li>POSIX(Portable Operating System Interface of UNIX, Linux环境使用较多) ：&lt; pthread.h &gt;</li>
<li>Windows OS : &lt; windows.h &gt;</li>
</ul>
<p>具体环境使用哪个库，有不同的观点，参考<br><a href="https://www.zhihu.com/question/36236334/answer/98422670">c++多线程编程主要用pthread还是c++11中的thread类？</a><br>即使是同一环境，也有不同封装层次的API<br><a href="https://blog.csdn.net/qq_22642239/article/details/90445414">CreateThread()与_beginthread()的区别详细解析</a></p>
<p>主线程与工作线程：<br>一般应用程序都有主要的执行流程，例如C&#x2F;C++的main入口函数，主要执行流程是在进程中执行的，也可以认为main是线程，独占了进程的全部资源，称为主线程。如果在该进程执行时，创建多个线程，用于并行处理其他任务，称为工作线程。</p>
<p>本文讲不同风格的线程创建\销毁，和访问共享数据的锁操作<br>本系列源码：<a href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="Windows风格多线程"><a href="#Windows风格多线程" class="headerlink" title="Windows风格多线程"></a>Windows风格多线程</h1><p>(1)双线程打印</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s &lt;&lt; endl;
    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    CloseHandle(hThread);
    
    return 0;
&#125;
</code></pre>
<p>主线程和工作线程都运行Print()，各线程的栈空间保存自己的局部数据。<br>windows API使用CreateThread和CloseHandle创建线程、释放线程句柄，说明如下</p>
<pre><code>HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD：线程安全相关的属性，常置为NULL
    SIZE_T dwStackSize,//initialstacksize：新线程的初始化栈的大小，可设置为0
    LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction：被线程执行的回调函数，也称为线程函数
    LPVOID lpParameter,//threadargument：传入线程函数的参数，不需传递参数时为NULL
    DWORD dwCreationFlags,//creationoption：控制线程创建的标志
    LPDWORD lpThreadId//threadidentifier：传出参数，用于获得线程ID，如果为NULL则不返回线程ID
    )
 
/*
lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，决定返回的句柄是否可被子进程继承，如果为NULL则表示返回的句柄不能被子进程继承。
dwStackSize：设置初始栈的大小，以字节为单位，如果为0，那么默认将使用与调用该函数的线程相同的栈空间大小。
任何情况下，Windows根据需要动态延长堆栈的大小。
lpStartAddress：指向线程函数的指针，函数名称没有限制，但是必须以下列形式声明：
DWORD WINAPI 函数名 (LPVOID lpParam) ，格式不正确将无法调用成功。
lpParameter：向线程函数传递的参数，是一个指向结构的指针，不需传递参数时，为NULL。
dwCreationFlags：控制线程创建的标志，可取值如下：
（1）CREATE_SUSPENDED(0x00000004)：创建一个挂起的线程（就绪状态），直到线程被唤醒时才调用
（2）0：表示创建后立即激活。
（3）STACK_SIZE_PARAM_IS_A_RESERVATION(0x00010000)：dwStackSize参数指定初始的保留堆栈的大小，
如果STACK_SIZE_PARAM_IS_A_RESERVATION标志未指定，dwStackSize将会设为系统预留的值
lpThreadId:保存新线程的id
返回值：函数成功，返回线程句柄，否则返回NULL。如果线程创建失败，可通过GetLastError函数获得错误信息。
*/
 
BOOL WINAPI CloseHandle(HANDLE hObject);        //关闭一个被打开的对象句柄
/*可用这个函数关闭创建的线程句柄，如果函数执行成功则返回true(非0),如果失败则返回false(0)，
如果执行失败可调用GetLastError.函数获得错误信息。
*/
</code></pre>
<p>LPVOID 与 std::string类型的转换，需要用char*类型作中介，LPVOID接受buffer数组类型的转换<br>注意CloseHandle只是释放句柄资源，线程的资源释放是其函数执行完毕自动销毁的。</p>
<p>2次的运行结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png" alt="image-20221205152628474"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png"></p>
<p>可见，两个线程是随机切换的，导致如下现象：</p>
<ul>
<li>Print()内的<code>cout &lt;&lt; s</code>和<code>&lt;&lt;endl</code>之间线程被切换，导致没有换行+双重换行。</li>
<li>存在工作线程没执行完，主线程就执行完导致main return，整个进程销毁的情况。</li>
</ul>
<p>改进如下：</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s;
    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread\n&quot;;
    std::string s2 = &quot;Main thread\n&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    CloseHandle(hThread);
    Sleep(100);
    return 0;
&#125;
</code></pre>
<p>使用以下方法解决上述问题</p>
<ul>
<li><p>主线程完成Print后，休眠100s，这个时间足够工作线程完成，Sleep结束后，main进程执行完毕</p>
</li>
<li><p>把换行放到字符串中，使该字符串的完整打印成为不可被中途切换的操作，即原子操作</p>
</li>
</ul>
<p>输出如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526645.png" alt="image-20221205152645608"></p>
<p>如果Print有很多句打印，又不希望中途切换线程，如何做？</p>
<ul>
<li>互斥锁可以实现“大块代码的原子操作”</li>
<li>锁是全局变量，因为主线程main和工作线程Print都能看到全局变量，而看不到对方的局部变量</li>
</ul>
<p>代码如下:</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
HANDLE hMutex = NULL;//互斥锁的句柄

DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;

    for (int i = 0; i &lt; 10; i++)
    &#123;
        WaitForSingleObject(hMutex, INFINITE);//请求锁
        cout &lt;&lt; s &lt;&lt; endl;
        ReleaseMutex(hMutex);//释放锁
    &#125;

    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;

    hMutex = CreateMutex(NULL, FALSE, NULL); //创建互斥锁
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    
    CloseHandle(hThread);
    CloseHandle(hMutex);//销毁互斥锁
    
    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526485.png" alt="image-20221205152654439"><br>关于windows的互斥锁：</p>
<pre><code>互斥量：
        采用互斥对象机制。互斥锁，像一个物件，这个物件只能同时被一个线程持有。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。
        一、创建 创建互斥锁的方法是调用函数CreateMutex： CreateMutex(&amp;sa, bInitialOwner, szName);第一个参数是一个指向SECURITY_ATTRIBUTES结构体的指针，一般的情况下，可以是nullptr。 第二个参数类型为BOOL，表示互斥锁创建出来后是否被当前线程持有。 第三个参数类型为字符串（const TCHAR*），是这个互斥锁的名字，如果是nullptr，则互斥锁是匿名的。 例： HANDLE hMutex = CreateMutex(nullptr, FALSE, nullptr);上面的代码创建了一个匿名的互斥锁，创建出来后，当前线程不持有这个互斥锁。

         二、持有 WaitForSingleObject函数可以让一个线程持有互斥锁。用法： WaitForSingleObject(hMutex, dwTimeout);这个函数的作用比较多。这里只介绍第一个参数为互斥锁句柄时的作用。 它的作用是等待，直到一定时间之后，或者，其他线程均不持有hMutex。第二个参数是等待的时间（单位：毫秒），如果该参数为INFINITE，则该函数会一直等待下去。

        三、释放 用ReleaseMutex函数可以让当前线程“放开”一个互斥锁（不持有它了），以便让其他线程可以持有它。用法 ReleaseMutex(hMutex)

         四、销毁 当程序不再需要互斥锁时，要销毁它。 CloseHandle(hMutex)

         五、命名互斥锁 如果CreateMutex函数的第三个参数传入一个字符串，那么所创建的锁就是命名的。当一个命名的锁被创建出来以后，当前进程和其他进程如果试图创建相同名字的锁，CreateMutex会返回原来那把锁的句柄，并且GetLastError函数会返回ERROR_ALREADY_EXISTS。这个特点可以使一个程序在同一时刻最多运行一个实例
</code></pre>
<h1 id="C-风格多线程"><a href="#C-风格多线程" class="headerlink" title="C++风格多线程"></a>C++风格多线程</h1><p>双线程分别实现计算和打印</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 1;
std::mutex g_mutex;

void thread_func1()
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>几点说明：</p>
<ul>
<li>C++使用&lt; thread &gt;调用线程库</li>
<li>std::thread t(thread_func)创建一个thread对象，传入参数为thread_fun，即线程内执行的函数</li>
<li>t.join()的含义是，线程t执行完毕后，join函数才能返回，主线程才能继续向后执行，宏观上就是，主线程被t线程阻塞在join函数处，这也许就是join的含义，t线程“加入”主线程的队伍，主线程必须原地等待t准备好了（执行完了）才能继续向后走。</li>
<li>由于全局数据g_mydata和打印语句都不是原子操作，要保证完整操作，需要加锁，库定义在&lt; mutex &gt;</li>
<li>为什么要sleep? 注意两个工作线程都while循环操作，sleep是手动使当前线程休眠，操作系统会轮换到其他active状态的线程执行，如果不sleep, 一个线程一直执行再被OS切换，间隔可能很久。&lt; chrono &gt;库用于时间</li>
<li>INT_MAX是C++定义的int类最大值，2^31-1</li>
</ul>
<p>运行结果:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051527091.png" alt="image-20221205152705047"></p>
<h1 id="POSIX-x2F-Linux风格"><a href="#POSIX-x2F-Linux风格" class="headerlink" title="POSIX&#x2F;Linux风格"></a>POSIX&#x2F;Linux风格</h1><p>逻辑同上节，代码如下</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;limits.h&gt; //for INT_MAX

int g_mydata = 1;
pthread_mutex_t m;

void* thread_function1(void* args)
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        pthread_mutex_lock(&amp;m);
        ++g_mydata;
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    &#125;
    
    return NULL;
&#125; 

void* thread_function2(void* args)
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;    
        pthread_mutex_lock(&amp;m);
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl;
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    &#125;
    
    return NULL;
&#125; 

int main()
&#123;
    pthread_mutex_init(&amp;m, NULL);
    
    pthread_t threadIDs[2];    
    pthread_create(&amp;threadIDs[0], NULL, thread_function1, NULL);
    pthread_create(&amp;threadIDs[1], NULL, thread_function2, NULL);
    
    for(int i = 0; i &lt; 2; ++i)
    &#123;
        pthread_join(threadIDs[i], NULL);
    &#125;
    
    pthread_mutex_destroy(&amp;m);

    return 0;
&#125;
</code></pre>
<p>win32应用程序使用pthread，需要配置pthread dll库，下载地址和配置方法：<br><a href="http://sourceware.org/pthreads-win32/">pthreads-win32</a><br><a href="https://www.cnblogs.com/lizhigang/p/7326022.html">VS2013 配置pthread</a></p>
<p>pthread的几个锁，参考：<br><a href="https://blog.csdn.net/guotianqing/article/details/80559865">linux线程互斥量pthread_mutex_t使用简介</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：线程池</title>
    <url>/2021/07/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>线程池的概念和相关示例可以参考：<br><a href="https://blog.csdn.net/MOU_IT/article/details/88712090">C++实现线程池</a><br><a href="https://www.cnblogs.com/ailumiyana/p/10016965.html">基于C++11实现线程池的工作原理</a></p>
<p>本代码相关的C++基础，参考：<br><a href="https://www.cnblogs.com/alantu2018/p/8459250.html">c++拷贝构造函数详解</a><br><a href="https://www.cnblogs.com/jiayayao/archive/2016/12/03/6128877.html">智能指针shared_ptr的用法</a><br><a href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量</a></p>
<p>其他相关文章<br><a href="https://www.jianshu.com/u/9456fecb5f96">jorion&#x2F;c++11 多线程（X）</a><br><a href="https://github.com/jorionwen/threadtest">jorionwen&#x2F;threadtest</a></p>
<h1 id="线程池示例"><a href="#线程池示例" class="headerlink" title="线程池示例"></a>线程池示例</h1><h2 id="调用线程池"><a href="#调用线程池" class="headerlink" title="调用线程池"></a>调用线程池</h2><pre><code>#include &quot;TaskPool.h&quot;
#include &lt;chrono&gt;

int main()
&#123;
    TaskPool threadPool;
    threadPool.init(); //初始化线程对象队列

    Task* task = NULL;
    for (int i = 0; i &lt; 10; ++i)
    &#123;
        task = new Task();
        threadPool.addTask(task); //初始化任务对象队列，调度线程时会取出执行
    &#125;
    
    std::this_thread::sleep_for(std::chrono::seconds(2));

    threadPool.stop(); //等待所有工作线程结束

    return 0; //析构
&#125;
</code></pre>
<h2 id="线程池的方法"><a href="#线程池的方法" class="headerlink" title="线程池的方法"></a>线程池的方法</h2><pre><code>#include &quot;TaskPool.h&quot;

TaskPool::TaskPool() : m_bRunning(false)
&#123;

&#125;

TaskPool::~TaskPool()
&#123;
    removeAllTasks();
&#125;

void TaskPool::init(int threadNum/* = 5*/)
&#123;
    if (threadNum &lt;= 0)
        threadNum = 5;

    m_bRunning = true;

    for (int i = 0; i &lt; threadNum; ++i)
    &#123;
        std::shared_ptr&lt;std::thread&gt; spThread;
        //shared_ptr.reset带参数是初始化，指向new出的thread对象
        //bind绑定了thread对象和其执行函数threadFunc
        spThread.reset(new std::thread(std::bind(&amp;TaskPool::threadFunc, this))); 
        m_threads.push_back(spThread); //thread对象入队
    &#125;
&#125;

void TaskPool::threadFunc() //thread对象唤醒时执行
&#123;
    std::shared_ptr&lt;Task&gt; spTask;
    while (true)
    &#123;
        std::unique_lock&lt;std::mutex&gt; guard(m_mutexList); //RAII实现，作用域结束自动解锁
        while (m_taskList.empty())
        &#123;                 
            if (!m_bRunning)
                break;
            
            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
            m_cv.wait(guard);
        &#125;

        if (!m_bRunning)
            break;

        spTask = m_taskList.front(); //取m_taskList的task对象
        m_taskList.pop_front(); //更新m_taskList

        if (spTask == NULL)
            continue;

        spTask-&gt;doIt(); //执行task
        spTask.reset(); //shared_ptr.reset不带参数，指向对象的计数-1
    &#125;

    std::unique_lock&lt;std::mutex&gt; guard(m_mutexList); //为了打印的原子性，再加锁
    &#123;
        std::cout &lt;&lt; &quot;Exit thread, threadID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    &#125;
    
&#125;

void TaskPool::stop()
&#123;
    m_bRunning = false;
    m_cv.notify_all(); //唤醒所有等待条件变量的线程

    //等待所有线程退出
    for (auto&amp; iter : m_threads)
    &#123;
        if (iter-&gt;joinable())   //该线程是否可join
            iter-&gt;join();       //主线程等待该线程
    &#125;
&#125;

void TaskPool::addTask(Task* task)
&#123;
    std::shared_ptr&lt;Task&gt; spTask;
    spTask.reset(task); //shared_ptr初始化，指向task

    &#123;
        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);       
        //m_taskList.push_back(std::make_shared&lt;Task&gt;(task));
        m_taskList.push_back(spTask); //Task对象入队
        std::cout &lt;&lt; &quot;Add a Task.&quot; &lt;&lt; std::endl;
    &#125;
    
    m_cv.notify_one(); //唤醒随机一个等待条件变量的线程
&#125;

void TaskPool::removeAllTasks()   //析构时调用
&#123;
    &#123;
        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);
        for (auto&amp; iter : m_taskList)
        &#123;
            iter.reset();
        &#125;
        m_taskList.clear();
    &#125;
&#125;
</code></pre>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><pre><code>#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt; //for visual studio build

class Task
&#123;
public:
    virtual void doIt()
    &#123;
        std::cout &lt;&lt; &quot;Do a task...&quot; &lt;&lt; std::endl;
    &#125;

    virtual ~Task()
    &#123;
        //为了看到一个task的销毁，这里刻意补上其析构函数
        std::cout &lt;&lt; &quot;A task destructed...&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

class TaskPool final
&#123;
public:
    TaskPool();
    ~TaskPool();
    TaskPool(const TaskPool&amp; rhs) = delete;     //delete: 禁用某函数（C++11），阻止拷贝和赋值构造，C++98用private
    TaskPool&amp; operator=(const TaskPool&amp; rhs) = delete;

public:
    void init(int threadNum = 5);   //默认初始化
    void stop();

    void addTask(Task* task);
    void removeAllTasks();

private:
    void threadFunc();

private:
    std::list&lt;std::shared_ptr&lt;Task&gt;&gt;            m_taskList;
    std::mutex                                  m_mutexList;
    std::condition_variable                     m_cv;
    bool                                        m_bRunning;
    std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt;   m_threads;
&#125;;
</code></pre>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221205152435385.png" alt="image-20221205152435385"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>如何向Linux内核驱动提交和使用patch</title>
    <url>/2023/03/09/%E5%A6%82%E4%BD%95%E5%90%91Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E6%8F%90%E4%BA%A4%E5%92%8C%E4%BD%BF%E7%94%A8patch/</url>
    <content><![CDATA[<p>本文描述：如何参与到Linux kernel社区中，为Linux kernel提交Patch代码；以Linux子系统MMC&#x2F;SD为例介绍如何使用patch。</p>
<h2 id="Linux-kernel提交代码的基本概念"><a href="#Linux-kernel提交代码的基本概念" class="headerlink" title="Linux kernel提交代码的基本概念"></a>Linux kernel提交代码的基本概念</h2><h3 id="如何参与Linux内核开发"><a href="#如何参与Linux内核开发" class="headerlink" title="如何参与Linux内核开发"></a>如何参与Linux内核开发</h3><p>Linux kernel的官方网站：<a href="https://kernel.org/">kernel.org</a></p>
<p>kernel.org内的中文文档：<a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/process/howto.html">如何参与Linux内核开发</a>, 其中最常用的：</p>
<ul>
<li>内核源码库：<a href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a> 在线查看kernel源码而无需git下载</li>
<li>内核子系统(subsystem)的补丁(patch)列表：<a href="https://patchwork.kernel.org/">https://patchwork.kernel.org/</a> 显示正在发布、评论或修订的patch： </li>
<li>内核邮件列表的存档(archive)：<a href="https://lore.kernel.org/lkml/">https://lore.kernel.org/lkml/</a> 所有正在进行或已存档的patchwork都能在此找到邮件记录：</li>
</ul>
<h3 id="如何提交Patch"><a href="#如何提交Patch" class="headerlink" title="如何提交Patch"></a>如何提交Patch</h3><p>Patch是提交到kernel之前的一个阶段，由kernel subsystem maintainer review后<strong>有机会</strong>进入Linux kernel Mainline。事实上绝大所述patch最终未进入Linux kernel Mainline，仅存档到了邮件列表，在lore&#x2F;patchwork.kernel.org可查看这部分patch的内容和提交过程。</p>
<ul>
<li><p>提交Patch的总体规范参考：</p>
<p><a href="https://docs.kernel.org/translations/zh_CN/process/submitting-patches.html">提交补丁：如何让你的改动进入内核</a></p>
</li>
<li><p>具体地讲如何向kernel提交patch和使用patch（需要详细看）: </p>
<p><a href="https://www.kernel.org/doc/html/v4.11/process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></p>
<p><a href="https://www.kernel.org/doc/html/v4.11/process/applying-patches.html?highlight=applying%20patches%20linux%20kernel">Applying Patches To The Linux Kernel</a></p>
</li>
<li><p>关于patch命令如何使用，参考： </p>
<p><a href="https://www.thegeekstuff.com/2014/12/patch-command-examples/">patch-command-examples</a></p>
<p><a href="https://www.man7.org/linux/man-pages/man1/patch.1.html">patch(1) — Linux manual page</a> </p>
<p><a href="https://blog.csdn.net/dl0914791011/article/details/17299103">Linux下生成patch和打patch</a></p>
</li>
</ul>
<h2 id="Linux-MMC子系统中UHS-II-Patch的演化过程"><a href="#Linux-MMC子系统中UHS-II-Patch的演化过程" class="headerlink" title="Linux MMC子系统中UHS-II Patch的演化过程"></a>Linux MMC子系统中UHS-II Patch的演化过程</h2><h3 id="Linux-MMC子系统的现状"><a href="#Linux-MMC子系统的现状" class="headerlink" title="Linux MMC子系统的现状"></a>Linux MMC子系统的现状</h3><p>MMC子系统主要包含SD card, eMMC card, SDIO几部分，Kernel Mainline的支持情况参考：<a href="https://elinux.org/images/9/91/Clement-sd-mmc-high-speed-support-in-linux-kernel_0.pdf#:~:text=%E2%96%B6New%20speed%20modes%20%28name%20are%20base%20on%20the,the%203.3V%20forDS%28Default%20Speed25MHz%29%20andHS%28High%20Speed%20at%2050MHz%29">SD&#x2F;eMMC: new speed modes and their support in Linux</a></p>
<p>这里只关注SD card, Kernel Mainline在当前时间点（kernel 6.2）：</p>
<ul>
<li>不支持UHS-II (SD 4.0 specification)</li>
<li>SD express(SD 7.0 specification)在Kernel 5.11版本以后是支持的</li>
<li>SD UHS-I (SD 3.0 specification)和更老版本的SD协议则在kernel 3.0就已经支持</li>
</ul>
<h3 id="Linux-MMC-UHS-II-patch的演变"><a href="#Linux-MMC-UHS-II-patch的演变" class="headerlink" title="Linux MMC UHS-II patch的演变"></a>Linux MMC UHS-II patch的演变</h3><p>Linux MMC子系统的维护者可以在<a href="https://patchwork.kernel.org/">patchwork.kernel.org</a>的MMC development的about页面看到：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091635752.png" alt="image-20230309163541697"></p>
<p>在patch页面可以搜索以<a href="https://patchwork.kernel.org/project/linux-mmc/list/?q=UHS-II&archive=both&series=&submitter=&delegate=&state=*">UHS-II为关键字的相关patch</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091621148.png" alt="image-20230309162128061">结果如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091623615.png" alt="image-20230309162327522"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091623615.png"> </p>
<p>具体看一下上面这些UHS-II patch的内容和reviewer的评论：</p>
<p>1.首次提交是<a href="https://patchwork.kernel.org/project/linux-mmc/patch/1419672479-30852-2-git-send-email-yi.y.sun@intel.com/">Intel的yisun</a>, 该patch被MMC维护者Ulf Hansson评论：应该split it up，之后就没有再修改和提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RFC,1/2] mmc: core: support UHS-II in core stack.</span><br><span class="line"></span><br><span class="line">Commit Message</span><br><span class="line"></span><br><span class="line">[yisun1](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=102631)Dec. 27, 2014, 9:27 a.m. UTC</span><br><span class="line"></span><br><span class="line">This patch adds the UHS-II support in core layer. This is a RFC patch for</span><br><span class="line">community review.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Yi Sun &lt;yi.y.sun@intel.com&gt;</span><br><span class="line">---</span><br><span class="line"> drivers/mmc/core/Makefile |    3 +-</span><br><span class="line"> drivers/mmc/core/bus.c    |    5 +-</span><br><span class="line"> drivers/mmc/core/core.c   |   89 ++++-</span><br><span class="line"> drivers/mmc/core/sd.c     |   15 +</span><br><span class="line"> drivers/mmc/core/sd_ops.c |   12 +</span><br><span class="line"> drivers/mmc/core/uhs2.c   |  908 +++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> drivers/mmc/core/uhs2.h   |   26 ++</span><br><span class="line"> include/linux/mmc/core.h  |    6 +</span><br><span class="line"> include/linux/mmc/host.h  |   27 ++</span><br><span class="line"> include/linux/mmc/uhs2.h  |  274 ++++++++++++++</span><br><span class="line"> 10 files changed, 1356 insertions(+), 9 deletions(-)</span><br><span class="line"> create mode 100644 drivers/mmc/core/uhs2.c</span><br><span class="line"> create mode 100644 drivers/mmc/core/uhs2.h</span><br><span class="line"> create mode 100644 include/linux/mmc/uhs2.h</span><br><span class="line"></span><br><span class="line">Comments</span><br><span class="line"></span><br><span class="line">[Ulf Hansson](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=45281)Jan. 21, 2015, 10:31 a.m. UTC | [#1](https://patchwork.kernel.org/comment/12007791/)</span><br><span class="line"></span><br><span class="line">Even if this an RFC, me and likely everybody else just stops from</span><br><span class="line">reviewing this patch by looking at the above change log.</span><br><span class="line"></span><br><span class="line">Is there a way to split it up?</span><br><span class="line"></span><br><span class="line">Kind regards</span><br><span class="line">Uffe</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Genesys的Ben Chuang, Jason Lai, Victor.shih 和linaro 的akashi 在Intel的UHS-II patch上不断提交修改后的UHS-II patch（V3~V6）跟随着Kernel版本不断演化，此patch完整内容可在GitLab查看 <a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755">linux-uhs2-gl9755</a>，在patchwork也可以查看commit内容和review意见：<a href="https://patchwork.kernel.org/project/linux-mmc/patch/20221213090047.3805-7-victor.shih@genesyslogic.com.tw/">V6 patch的第6&#x2F;24提交</a>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[V6,06/24] mmc: core: Support UHS-II card control and access</span><br><span class="line"></span><br><span class="line">Commit Message </span><br><span class="line"></span><br><span class="line">[Victor Shih](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=207469) Dec. 13, 2022, 9 a.m. UTC</span><br><span class="line"></span><br><span class="line">Embed UHS-II access/control functionality into the MMC request</span><br><span class="line">processing flow.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Ulf Hansson &lt;ulf.hansson@linaro.org&gt;</span><br><span class="line">Signed-off-by: Jason Lai &lt;jason.lai@genesyslogic.com.tw&gt;</span><br><span class="line">Signed-off-by: Victor Shih &lt;victor.shih@genesyslogic.com.tw&gt;</span><br><span class="line">---</span><br><span class="line"> drivers/mmc/core/block.c   |    6 +-</span><br><span class="line"> drivers/mmc/core/core.c    |   20 +</span><br><span class="line"> drivers/mmc/core/mmc_ops.c |   25 +-</span><br><span class="line"> drivers/mmc/core/mmc_ops.h |    1 +</span><br><span class="line"> drivers/mmc/core/sd.c      |   11 +-</span><br><span class="line"> drivers/mmc/core/sd.h      |    3 +</span><br><span class="line"> drivers/mmc/core/sd_ops.c  |   13 +</span><br><span class="line"> drivers/mmc/core/sd_ops.h  |    3 +</span><br><span class="line"> drivers/mmc/core/sd_uhs2.c | 1171 +++++++++++++++++++++++++++++++++++-</span><br><span class="line"> 9 files changed, 1206 insertions(+), 47 deletions(-)</span><br><span class="line"></span><br><span class="line">Comments</span><br><span class="line"></span><br><span class="line">[Adrian Hunter](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=31052) Jan. 5, 2023, 9:26 p.m. UTC | [#1](https://patchwork.kernel.org/comment/25148889/)</span><br><span class="line"></span><br><span class="line">&gt; +u32 sd_uhs2_select_voltage(struct mmc_host *host, u32 ocr)</span><br><span class="line">&gt; +&#123;</span><br><span class="line">...</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +	if (host-&gt;caps2 &amp; MMC_CAP2_FULL_PWR_CYCLE) &#123;</span><br><span class="line">&gt; +		bit = ffs(ocr) - 1;</span><br><span class="line">&gt; +		ocr &amp;= 3 &lt;&lt; bit;</span><br><span class="line">&gt; +		/* Power cycle */</span><br><span class="line">&gt; +		err = sd_uhs2_power_off(host);</span><br><span class="line">&gt; +		if (err)</span><br><span class="line">&gt; +			return 0;</span><br><span class="line">&gt; +		err = sd_uhs2_reinit(host);</span><br><span class="line"></span><br><span class="line">This looks circular:</span><br><span class="line"></span><br><span class="line">sd_uhs2_select_voltage</span><br><span class="line">-&gt; sd_uhs2_reinit</span><br><span class="line">   -&gt; sd_uhs2_init_card</span><br><span class="line">      -&gt; sd_uhs2_legacy_init</span><br><span class="line">         -&gt; sd_uhs2_select_voltage</span><br><span class="line"></span><br><span class="line">[Ulf Hansson](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=45281) Feb. 8, 2023, 3:30 p.m. UTC | [#2](https://patchwork.kernel.org/comment/25202573/)</span><br><span class="line"></span><br><span class="line">&gt; diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span><br><span class="line">&gt; index 20da7ed43e6d..d3e8ec43cdd5 100644</span><br><span class="line">&gt; --- a/drivers/mmc/core/block.c</span><br><span class="line">&gt; +++ b/drivers/mmc/core/block.c</span><br><span class="line">&gt; @@ -1596,6 +1596,9 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;         struct request *req = mmc_queue_req_to_req(mqrq);</span><br><span class="line">&gt;         struct mmc_blk_data *md = mq-&gt;blkdata;</span><br><span class="line">&gt;         bool do_rel_wr, do_data_tag;</span><br><span class="line">&gt; +       bool do_multi;</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +       do_multi = (card-&gt;uhs2_state &amp; MMC_UHS2_INITIALIZED) ? true : false;</span><br><span class="line">&gt;</span><br><span class="line">&gt;         mmc_blk_data_prep(mq, mqrq, recovery_mode, &amp;do_rel_wr, &amp;do_data_tag);</span><br><span class="line">&gt;</span><br><span class="line">&gt; @@ -1606,7 +1609,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;                 brq-&gt;cmd.arg &lt;&lt;= 9;</span><br><span class="line">&gt;         brq-&gt;cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;</span><br><span class="line">&gt;</span><br><span class="line">&gt; -       if (brq-&gt;data.blocks &gt; 1 || do_rel_wr) &#123;</span><br><span class="line">&gt; +       if (brq-&gt;data.blocks &gt; 1 || do_rel_wr || do_multi) &#123;</span><br><span class="line"></span><br><span class="line">This looks wrong to me. UHS2 can use single block read/writes too. Right?</span><br><span class="line"></span><br><span class="line">&gt;                 /* SPI multiblock writes terminate using a special</span><br><span class="line">&gt;                  * token, not a STOP_TRANSMISSION request.</span><br><span class="line">&gt;                  */</span><br><span class="line">&gt; @@ -1619,6 +1622,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;                 brq-&gt;mrq.stop = NULL;</span><br><span class="line">&gt;                 readcmd = MMC_READ_SINGLE_BLOCK;</span><br><span class="line">&gt;                 writecmd = MMC_WRITE_BLOCK;</span><br><span class="line">&gt; +               brq-&gt;cmd.uhs2_tmode0_flag = 1;</span><br><span class="line"></span><br><span class="line">As &quot;do_multi&quot; is always set for UHS2, setting this flag here seems to</span><br><span class="line">be wrong/redundant.</span><br><span class="line"></span><br><span class="line">Anyway, if I understand correctly, the flag is intended to be used to</span><br><span class="line">inform the host driver whether the so-called 2L_HD_mode (half-duplex</span><br><span class="line">or full-duplex) should be used for the I/O request or not.</span><br><span class="line"></span><br><span class="line">To fix the above behaviour, I suggest we try to move the entire</span><br><span class="line">control of the flag into mmc_uhs2_prepare_cmd(). We want the flag to</span><br><span class="line">be set for multi block read/writes (CMD18 and CMD25), but only if the</span><br><span class="line">host and card supports the 2L_HD_mode too. According to my earlier</span><br><span class="line">suggestions, we should be able to check that via the bits we set</span><br><span class="line">earlier in the ios-&gt;timing.</span><br><span class="line"></span><br><span class="line">Moreover, by making mmc_uhs2_prepare_cmd() responsible for setting the</span><br><span class="line">flag, I think we can also move the definition of the flag into the</span><br><span class="line">struct uhs2_command. While at it, I suggest we also rename the flag</span><br><span class="line">into &quot;tmode_half_duplex&quot;, to better describe its purpose, which also</span><br><span class="line">means the interpretation of the flag becomes inverted.</span><br></pre></td></tr></table></figure>

<h2 id="详解Patch的使用"><a href="#详解Patch的使用" class="headerlink" title="详解Patch的使用"></a>详解Patch的使用</h2><h3 id="Patch与git-diff"><a href="#Patch与git-diff" class="headerlink" title="Patch与git diff"></a>Patch与git diff</h3><p>Patch文件的内容实际是<code>git diff</code>命令的输出，git diff的输出定义为.diff文件或.patch文件，即可作为patch使用。打patch实际上就是按diff规则，解析diff&#x2F;patch文件，去改变本地的代码树和内容。</p>
<p>git diff说明文档参考 <a href="https://git-scm.com/docs/git-diff">git-diff</a>，比较常用的是使用<code>git diff [&lt;path&gt;…]</code>输出某个路径&#x2F;文件的差异；如果path为空，则输出当前git仓库所有文件的差异。</p>
<p>如下示例：在drivers&#x2F;mmc&#x2F;core&#x2F;block.c增加修改了<code>//AAAAAAAAA</code>，在drivers&#x2F;mmc&#x2F;core&#x2F;block.h增加了<code>//BBBBBBBBB</code>，以下详细说明git diff 输出的含义：</p>
<ul>
<li>diff –git a&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c b&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c：用git diff命令，比较a和b版本的drivers&#x2F;mmc&#x2F;core&#x2F;block.c，a和b是diff用来区分同名文件的标识，不是实际路径。</li>
<li>index 7fa83e5..8963e57：这个diff如果被commit提交，commit-id将是index值7fa83e5..8963e57。</li>
<li>— a&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c 和+++ b&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c 同时存在：表示是对已存在的block.c文件有内容修改；与之相对的是某个文件只有+++或—，表示是新增文件文件，或者是删除了文件。</li>
<li>@@ -1829,6 +1829,8 @@ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)：该修改代码所在的行数以及所在的函数名。</li>
<li>+&#x2F;&#x2F;AAAAAAAAA：具体的修改内容，+是新增，-是删除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span><br><span class="line">index 7fa83e5..8963e57 100644</span><br><span class="line">--- a/drivers/mmc/core/block.c</span><br><span class="line">+++ b/drivers/mmc/core/block.c</span><br><span class="line">@@ -1829,6 +1829,8 @@ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)</span><br><span class="line">        u32 blocks;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">+//AAAAAAAAA</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">diff --git a/drivers/mmc/core/block.h b/drivers/mmc/core/block.h</span><br><span class="line">index 31153f6..5501895 100644</span><br><span class="line">--- a/drivers/mmc/core/block.h</span><br><span class="line">+++ b/drivers/mmc/core/block.h</span><br><span class="line">@@ -17,4 +17,6 @@ struct work_struct;</span><br><span class="line"></span><br><span class="line"> void mmc_blk_mq_complete_work(struct work_struct *work);</span><br><span class="line"></span><br><span class="line">+//BBBBBBBBB</span><br><span class="line"></span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure>

<p>一般提交给Kernel社区的patch需要按功能和文件拆分成多个patch提交，也就是说应该对某个文件或者路径git diff, 而不建议直接对所有文件git diff。例如以上示例可以分为两个diff：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff drivers/mmc/core/block.c</span><br><span class="line"></span><br><span class="line">git diff drivers/mmc/core/block.h</span><br></pre></td></tr></table></figure>

<h3 id="Patch与kernel版本"><a href="#Patch与kernel版本" class="headerlink" title="Patch与kernel版本"></a>Patch与kernel版本</h3><p>为了正确打一个补丁，你需要知道这个补丁是从哪个基础代码版本(base)产生的，以及这个补丁会使源码树升级成哪个版本。</p>
<h4 id="用于Kernel升级的官方patch"><a href="#用于Kernel升级的官方patch" class="headerlink" title="用于Kernel升级的官方patch"></a>用于Kernel升级的官方patch</h4><p>在kernel.org可以看到有很多Kernel版本之间有patch可以用于升级kernel，例如从kernel 4.19.275升级到5.4.234，可以下载并安装patch-5.4.234.xz</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091942357.png" alt="image-20230309194230288"></p>
<h4 id="patchwork社区的第三方patch"><a href="#patchwork社区的第三方patch" class="headerlink" title="patchwork社区的第三方patch"></a>patchwork社区的第三方patch</h4><p>可以下载diff或者series去获取patch文件，根据patch提交时间和代码上下文大致估计当时的Kernel版本</p>
<ul>
<li>diff: 当前patch的diff, 由于一个大patch可能被拆分为多个小patch，此文件通常为某个小patch</li>
<li>mbox: 在diff基础上包含了邮件信息（MIME信息）</li>
<li>series: 整个功能的所有patch系列的mbox合并内容，包括邮件信息（MIME信息）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091945285.png" alt="image-20230309194559245"></p>
<p>Patch命令一般使用以上的diff文件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c</span><br><span class="line">index 86d2711..6565754 100644</span><br><span class="line">--- a/drivers/mmc/core/bus.c</span><br><span class="line">+++ b/drivers/mmc/core/bus.c</span><br><span class="line">@@ -308,8 +308,9 @@ int mmc_add_card(struct mmc_card *card)</span><br><span class="line"> 	&#125; else &#123;</span><br><span class="line"> 		pr_info(&quot;%s: new %s%s%s%s%s card at address %04x\n&quot;,</span><br><span class="line"> 			mmc_hostname(card-&gt;host),</span><br><span class="line">-			mmc_card_uhs(card) ? &quot;ultra high speed &quot; :</span><br><span class="line">-			(mmc_card_hs(card) ? &quot;high speed &quot; : &quot;&quot;),</span><br><span class="line">+			mmc_card_uhs2(card) ? &quot;ultra high speed 2 &quot; :</span><br><span class="line">+			(mmc_card_uhs(card) ? &quot;ultra high speed 1&quot; :</span><br><span class="line">+			(mmc_card_hs(card) ? &quot;high speed &quot; : &quot;&quot;)),</span><br><span class="line"> 			mmc_card_hs400(card) ? &quot;HS400 &quot; :</span><br><span class="line"> 			(mmc_card_hs200(card) ? &quot;HS200 &quot; : &quot;&quot;),</span><br><span class="line"> 			mmc_card_ddr52(card) ? &quot;DDR &quot; : &quot;&quot;,</span><br></pre></td></tr></table></figure>

<p>对于一个大功能的多个patch series，需要分别下载各diff文件； 或者一次下载series后手动删除所有MIME信息。</p>
<h4 id="如何寻找Patch对应的kernel版本"><a href="#如何寻找Patch对应的kernel版本" class="headerlink" title="如何寻找Patch对应的kernel版本"></a>如何寻找Patch对应的kernel版本</h4><p>如果Patch和kernel版本不匹配，patch命令无法合并patch到此kernel中，导致patch失败，因此打patch首先要确定其对应哪个kernel版本。</p>
<p>（1）如果patch commit是已提交到kernel的官方patch，则可以根据commit-id查找包含此commit的kernel版本，参考：<a href="https://lwn.net/Articles/392293/">Finding a patch’s kernel version with git</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git describe --contains &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>

<p>（2）大多数patch是没提交到kernel的第三方patch，因此patch中的index在kernel是找不到的，所以只能通过提交邮件的信息确定适用的kernel版本。</p>
<p>以前文提到的 <a href="https://lore.kernel.org/all/20201106022726.19831-2-takahiro.akashi@linaro.org/T/#u">RFC PATCH v3.1 16&#x2F;27</a>为例，patch是在提交时间点的kernel master版本或tag版本上测试的。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[auto build test WARNING on linus/master]</span><br><span class="line">[also build test WARNING on v5.10-rc2]</span><br><span class="line">[cannot apply to v3.1 next-20201105]</span><br><span class="line">[If your patch is applied to the wrong git tree, kindly drop us a note</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另外一个示例：提交者在提交信息中写了基于哪个kernel版本：<a href="https://lore.kernel.org/all/20221213090047.3805-24-victor.shih@genesyslogic.com.tw/T/#u">Add support UHS-II for GL9755</a></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes in v6 (Dec. 12, 2022)</span><br><span class="line">* rebased to the linux-kernel-v6.1.0-rc8 in Ulf Hansson next branch.</span><br><span class="line"></span><br><span class="line">Changes in v5 (Oct. 19, 2022)</span><br><span class="line">* rebased to the linux-kernel-v6.1-rc1 in Ulf Hansson next branch.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果一个第三方patch没有任何kernel版本的信息，只能通过提交时间来尝试kernel，一般情况下不建议这种尝试，因为提交者使用的可能是当时最新的kernel, 也可能是一两个月前的kernel, 中间可能有很多-rc版本。</p>
<p>下面以<a href="https://lore.kernel.org/all/525EAED47491124EB5123A51BD2FC79101A30EE2@SHSMSX101.ccr.corp.intel.com/">RFC 0&#x2F;2 mmc: UHS-II implementation</a>为例，尝试寻找此patch可应用的kernel版本，此patch提交信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* RE: [RFC 0/2] mmc: UHS-II implementation</span><br><span class="line">  2014-12-27  9:27 [RFC 0/2] mmc: UHS-II implementation Yi Sun</span><br><span class="line">  2014-12-27  9:27 ` [RFC 1/2] mmc: core: support UHS-II in core stack Yi Sun</span><br><span class="line">  2014-12-27  9:27 ` [RFC 2/2] mmc: sdhci: support UHS-II in SDHCI host Yi Sun</span><br></pre></td></tr></table></figure>

<p>（1）首先在linux kernel git tag时间记录找到接近此patch提交时间的kernel版本：</p>
<p>在<a href="https://github.com/torvalds/linux">linux kernel github</a> 下拉tag列表，找接近patch申请时间的kernel release版本，可见kernel version &lt; 4.0是此patch可能适用的版本</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131133722.png" alt="image-20230313113324650"></p>
<p>（2）patch内容的函数名和上下文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@ -248,6 +252,12 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)</span><br><span class="line"> 			mrq-&gt;stop-&gt;mrq = mrq;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">+</span><br><span class="line">+	if (host-&gt;flags &amp; MMC_UHS2_SUPPORT &amp;&amp;</span><br><span class="line">+	    host-&gt;flags &amp; MMC_UHS2_INITIALIZED)</span><br><span class="line">+		if (mrq-&gt;cmd-&gt;uhs2_cmd == NULL)</span><br><span class="line">+			uhs2_prepare_sd_cmd(host, mrq);</span><br><span class="line">+</span><br><span class="line"> 	mmc_host_clk_hold(host);</span><br><span class="line"> 	led_trigger_event(host-&gt;led, LED_FULL);</span><br><span class="line"> 	host-&gt;ops-&gt;request(host, mrq);</span><br></pre></td></tr></table></figure>

<p>（3）在 <a href="https://elixir.bootlin.com/linux/v4.9/source/drivers/mmc/core/core.c#L264">bootlin</a> 找到kernel的同函数并对比上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mrq-&gt;data) &#123;</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">	mrq-&gt;cmd-&gt;data = mrq-&gt;data;</span><br><span class="line">	mrq-&gt;data-&gt;error = 0;</span><br><span class="line">	mrq-&gt;data-&gt;mrq = mrq;</span><br><span class="line">	if (mrq-&gt;stop) &#123;</span><br><span class="line">		mrq-&gt;data-&gt;stop = mrq-&gt;stop;</span><br><span class="line">		mrq-&gt;stop-&gt;error = 0;</span><br><span class="line">		mrq-&gt;stop-&gt;mrq = mrq;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///// 此处为patch添加处</span><br><span class="line"></span><br><span class="line">led_trigger_event(host-&gt;led, LED_FULL);</span><br><span class="line">__mmc_start_request(host, mrq);</span><br><span class="line"></span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<p>在stable kernel版本上尝试此patch (跳过-rc版本)，首先找kernel tag早于此patch邮件的时间，尝试了kernel 3.18, 3.17都有patch fail，如下可见patch和kernel有少量代码offset能自动匹配，但是有些差异patch搞不定，例如有merge代码冲突会导致对应的Hunk # FAILED，hunk是patch中的diff –git的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~/linux-4.9$ patch -p1 &lt; RFC-1-2-mmc-core-support-UHS-II-in-core-stack..diff </span><br><span class="line">patching file drivers/mmc/core/Makefile</span><br><span class="line">Hunk #1 FAILED at 7.</span><br><span class="line">1 out of 1 hunk FAILED -- saving rejects to file drivers/mmc/core/Makefile.rej</span><br><span class="line">patching file drivers/mmc/core/bus.c</span><br><span class="line">Hunk #1 succeeded at 334 with fuzz 2 (offset 26 lines).</span><br><span class="line">patching file drivers/mmc/core/core.c</span><br><span class="line">Hunk #2 FAILED at 36.</span><br><span class="line">Hunk #3 succeeded at 63 with fuzz 2 (offset 6 lines).</span><br><span class="line">Hunk #4 FAILED at 250.</span><br><span class="line">Hunk #5 succeeded at 503 (offset 116 lines).</span><br><span class="line">Hunk #6 succeeded at 518 (offset 116 lines).</span><br><span class="line">Hunk #7 FAILED at 425.</span><br><span class="line">...</span><br><span class="line">6 out of 17 hunks FAILED -- saving rejects to file drivers/mmc/core/core.c.rej</span><br></pre></td></tr></table></figure>

<p>在kernel 3.18打此patch，只有一个fail，可以根据此fail进一步定位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hunk #13 FAILED at 2339.</span><br><span class="line">1 out of 17 hunks FAILED -- saving rejects to file drivers/mmc/core/core.c.rej</span><br></pre></td></tr></table></figure>

<p>core.c.rej 内容如下，注意这里的行号是已经经过patch操作被偏移的代码的行号，实际行号应该去patch原文件查看此hunk的行号，这里只看是什么函数名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- drivers/mmc/core/core.c</span><br><span class="line">+++ drivers/mmc/core/core.c</span><br><span class="line">@@ -2339,7 +2391,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Set initial state and call mmc_set_ios */</span><br><span class="line">-       mmc_set_initial_state(host);</span><br><span class="line">+       /* TODO: need verify this for UHS2. */</span><br><span class="line">+       if (!host-&gt;flags &amp; MMC_UHS2_SUPPORT)</span><br><span class="line">+               mmc_set_initial_state(host);</span><br><span class="line"></span><br><span class="line">        mmc_host_clk_release(host);</span><br></pre></td></tr></table></figure>

<p>patch原文件drivers&#x2F;mmc&#x2F;core&#x2F;core.c搜索函数名对应的hunk内容，得知代码行数是2287：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@ -2287,7 +2339,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	/* Set initial state and call mmc_set_ios */</span><br><span class="line">-	mmc_set_initial_state(host);</span><br><span class="line">+	/* TODO: need verify this for UHS2. */</span><br><span class="line">+	if (!host-&gt;flags &amp; MMC_UHS2_SUPPORT)</span><br><span class="line">+		mmc_set_initial_state(host);</span><br><span class="line"> </span><br><span class="line"> 	mmc_host_clk_release(host);</span><br></pre></td></tr></table></figure>

<p>去bootlin.com查找<a href="https://elixir.bootlin.com/linux/v3.18/source/drivers/mmc/core/core.c">kernel 3.18的core.c代码</a>如下(直接搜索drivers&#x2F;mmc&#x2F;core&#x2F;core.c定位到文件，然后在core.c文件ctrl+F查找行数2287)，2287行对不上当然patch fail。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131921412.png" alt="image-20230313192134365"></p>
<p>根据patch提交时间，其大概率是使用3.18~4.0之间的kernel版本，因此搜寻3.18以后，且符合上面fail点的代码，首先就是<a href="https://elixir.bootlin.com/linux/v3.19/source/drivers/mmc/core/core.c">3.19版本</a>对比代码如下，可见2287开始的几行和patch完全对应：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131917802.png" alt="image-20230313191733743"></p>
<p>打patch也全部通过未报错，所以3.19是此patch可适配的kernel版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~/linux-3.19$ patch -p1 &lt; RFC-1-2-mmc-core-support-UHS-II-in-core-stack..diff</span><br><span class="line">patching file drivers/mmc/core/Makefile</span><br><span class="line">patching file drivers/mmc/core/bus.c</span><br><span class="line">patching file drivers/mmc/core/core.c</span><br><span class="line">patching file drivers/mmc/core/sd.c</span><br><span class="line">patching file drivers/mmc/core/sd_ops.c</span><br><span class="line">patching file drivers/mmc/core/uhs2.c</span><br><span class="line">patching file drivers/mmc/core/uhs2.h</span><br><span class="line">patching file include/linux/mmc/core.h</span><br><span class="line">patching file include/linux/mmc/host.h</span><br><span class="line">patching file include/linux/mmc/uhs2.h</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目学习：Tinyhttpd</title>
    <url>/2020/12/03/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9ATinyhttpd/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Tinyhttpd是一个C + CGI实现的简单http server，适合初学者学习。代码许可协议：GPL，copyright 1999, by J. David Blackstone.<br>本文对Tinyhttp稍作注释和改动，验证并理解其主要流程, 本文源码：<br>Github: <a href="https://github.com/cursorhu/myTinyHttpd">cursorhu&#x2F;myTinyHttpd</a></p>
<h1 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2.背景知识"></a>2.背景知识</h1><h2 id="TCP套接字的通信流程"><a href="#TCP套接字的通信流程" class="headerlink" title="TCP套接字的通信流程"></a>TCP套接字的通信流程</h2><p>网络协议栈的核心是TCP&#x2F;IP协议，HTTP本质上是对TCP的应用层封装，要理解HTTP服务程序，首先要理解TCP层的通信机制，在Linux环境中TCP采用socket接口通信，流程如下图<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121451104.png" alt="image-20221212145149039"><br>关于Linux网络编程相关知识，参考《Linux网络编程-第二版》<br>TinyHttpd实现服务端的流程。</p>
<h2 id="HTTP的请求方式"><a href="#HTTP的请求方式" class="headerlink" title="HTTP的请求方式"></a>HTTP的请求方式</h2><p>参考：<br><a href="https://www.cnblogs.com/williamjie/p/9099940.html">浅谈HTTP中GET、POST用法以及它们的区别</a><br><a href="https://blog.csdn.net/eson_15/article/details/88083280">99%的人都理解错了HTTP中GET与POST的区别</a><br>理解以下几点：</p>
<ul>
<li>GET，POST，PUT，DELETE是http层对数据操作的封装，底层本质还是TCP的read&#x2F;write过程</li>
<li>http server处理请求的基本流程：读取-拆解-处理-封装-回写，拆解和封装的就是http层的请求和数据格式，处理是指TCP层能理解的数据。就像快递退货时的流程：取件-拆包-查看-装包-寄出</li>
</ul>
<h2 id="CGI的时代背景"><a href="#CGI的时代背景" class="headerlink" title="CGI的时代背景"></a>CGI的时代背景</h2><p>参考：<a href="https://www.jianshu.com/p/c4dc22699a42">CGI是什么</a></p>
<ul>
<li>CGI是2000年的web接口标准，后端部署perl-CGI脚本，连接server处理程序和web客户端</li>
<li>CGI目前还应用在嵌入式web等C-based环境，这个和当前web主流的Java Spring + Vue(JS)是完全不同的应用场景，所以CGI技术本身并无过时一说。</li>
</ul>
<h1 id="3-调试httpd"><a href="#3-调试httpd" class="headerlink" title="3.调试httpd"></a>3.调试httpd</h1><h2 id="部署httpd服务"><a href="#部署httpd服务" class="headerlink" title="部署httpd服务"></a>部署httpd服务</h2><p>Aliyun CentOS环境，运行如下deploy.sh：</p>
<pre><code>#!/bin/bash
chmod +x htdocs/*.cgi
yum install -y perl perl-CGI
make clean &amp;&amp; make
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452836.png" alt="image-20221212145206784"></p>
<h2 id="浏览器访问httpd"><a href="#浏览器访问httpd" class="headerlink" title="浏览器访问httpd"></a>浏览器访问httpd</h2><p>服务端直接运行httpd，会分配随机可用端口，本地chrome浏览器访问该服务所在的ip:端口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452831.png" alt="image-20221212145218796"></p>
<p>这里ip即为httpd所在主机ip，默认访问资源是htdocs&#x2F;index.html，原因可见httpd.c的http Get请求解析url的处理<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452854.png" alt="image-20221212145227807"></p>
<p>index.h调用color.cgi脚本：</p>
<pre><code>&lt;HTML&gt;
&lt;TITLE&gt;Index&lt;/TITLE&gt;
&lt;BODY&gt;
&lt;P&gt;Welcome to J. David&#39;s webserver.
&lt;H1&gt;CGI demo: get color
&lt;FORM ACTION=&quot;color.cgi&quot; METHOD=&quot;POST&quot;&gt;
Enter color(example: red, pink, blue): &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;color&quot;&gt;
&lt;INPUT TYPE=&quot;submit&quot;&gt;
&lt;/FORM&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p>color.cgi内容：</p>
<pre><code>#!/usr/bin/perl -Tw

use strict;
use CGI;

my($cgi) = new CGI;

print $cgi-&gt;header;
my($color) = &quot;blue&quot;;
$color = $cgi-&gt;param(&#39;color&#39;) if defined $cgi-&gt;param(&#39;color&#39;);

print $cgi-&gt;start_html(-title =&gt; uc($color),
                       -BGCOLOR =&gt; $color); 
print $cgi-&gt;h1(&quot;This is $color&quot;);
print $cgi-&gt;end_html;
</code></pre>
<p>干了两件事：</p>
<ul>
<li>html页面的bgcolor参数设置成了用户输入的color变量字符串</li>
<li>显示字符串：This is $color</li>
</ul>
<p>输入“red”, 浏览器显示效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452042.png" alt="image-20221212145241997"></p>
<p>F12打开浏览器调试窗口，可见：</p>
<ul>
<li>访问资源为color.cgi</li>
<li>查看http head内容，浏览器客户端的请求是POST，类型是text文本，表单数据(Form data):color的值是red</li>
<li>查看http response内容，即httpd返回的内容。返回了html文本，即浏览器可见的红色页面</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452614.png" alt="image-20221212145258548"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121455408.png" alt="image-20221212145533364"></p>
<p>现在理解以下整个流程：</p>
<ul>
<li>服务器上httpd先运行，处于监听(listen)客户端请求的状态</li>
<li>本地浏览器输入服务器ip：端口，访问httpd，发送的http请求类型是GET,即获取文本</li>
<li>httpd收到请求，在处理过程中调用cgi脚本，生成response的内容</li>
<li>httpd打包内容成http层的格式(head+body+…)，返回浏览器客户端</li>
<li>浏览器客户端解析html文本并显示成可见的页面。</li>
</ul>
<p>再看另外一个获取时间的功能：<br>浏览器输入<code>ip:port/date.html</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453695.png" alt="image-20221212145316645"><br>访问的资源是date.cgi，返回了显示当前时间的页面<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453222.png" alt="image-20221212145338163"><br>看下http请求和响应<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453850.png" alt="image-20221212145345780"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453273.png" alt="image-20221212145353230"></p>
<p>date.cgi的实现：shell直接调用linux <code>date</code>命令</p>
<pre><code>#!/bin/bash
echo &quot;Content-Type: text/html&quot;
echo
echo &quot;&lt;HTML&gt;&lt;BODY&gt;&quot;
echo &quot;&lt;CENTER&gt;Today is:&lt;/CENTER&gt;&quot;
echo &quot;&lt;CENTER&gt;&lt;B&gt;&quot;
date
echo &quot;&lt;/B&gt;&lt;/CENTER&gt;&quot;
echo &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;
</code></pre>
<h2 id="TCP-socket访问httpd-测试"><a href="#TCP-socket访问httpd-测试" class="headerlink" title="TCP socket访问httpd(测试)"></a>TCP socket访问httpd(测试)</h2><p>client.c直接使用socket接口访问httpd，这是个测试功能，因此用编译参数控制了该功能, <code>make test_sock=y</code>编译该版本的httpd<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454984.png" alt="image-20221212145401934"><br>client和httpd在同一主机，直接访问回环地址127.0.0.1，可见httpd返回了client发送的字符’A’</p>
<h1 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h1><h2 id="1-httpd的处理http请求的主要流程"><a href="#1-httpd的处理http请求的主要流程" class="headerlink" title="(1) httpd的处理http请求的主要流程"></a>(1) httpd的处理http请求的主要流程</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454501.png" alt="image-20221212145417431"></p>
<ol>
<li>服务器启动，在指定端口或随机选取端口绑定 httpd 服务</li>
<li>收到一个 HTTP 请求时（其实就是 listen 的端口 accpet 的时候），派生一个线程运行 accept_request 函数</li>
<li>取出 HTTP 请求中的 method (GET 或 POST) 和 url,。对于 GET 方法，如果有携带参数，则 query_string 指针指向 url 中 ？ 后面的 GET 参数</li>
<li>格式化 url 到 path 数组，表示浏览器请求的服务器文件路径，在 tinyhttpd 中服务器文件是在 htdocs 文件夹下。当 url 以 &#x2F; 结尾，或 url 是个目录，则默认在 path 中加上 index.html，表示访问主页</li>
<li>如果文件路径合法，对于无参数的 GET 请求，直接输出服务器文件到浏览器，即用 HTTP 格式写到套接字上，然后跳到（10）。其他情况（带参数 GET，POST 方式，url 为可执行文件），则调用 excute_cgi 函数执行 cgi 脚本</li>
<li>读取整个 HTTP 请求并丢弃，如果是 POST 则找出 Content-Length. 把 HTTP 200 状态码写到套接字</li>
<li>建立两个管道，cgi_input 和 cgi_output, 并 fork 一个进程</li>
<li>在子进程中，把 STDOUT 重定向到 cgi_outputt 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端，设置 request_method 的环境变量，GET 的话设置 query_string 的环境变量，POST 的话设置 content_length 的环境变量，这些环境变量都是为了给 cgi 脚本调用，接着用 execl 运行 cgi 程序</li>
<li>在父进程中，关闭 cgi_input 的读取端 和 cgi_output 的写入端，如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT。接着关闭所有管道，等待子进程结束。管道状态参考下图。</li>
<li>关闭与浏览器的连接，完成了一次 HTTP 请求与回应， HTTP是无连接的。</li>
</ol>
<p>管道初始状态：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454140.png" alt="image-20221212145427091"><br>管道最终状态：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454591.png" alt="image-20221212145432542"></p>
<p>主要函数：</p>
<ul>
<li>startup: 初始化httpd服务，包括建立服务端的套接字，绑定端口，进行监听等</li>
<li>accept_request: 处理从套接字上监听到的一个 HTTP 请求，是服务器处理请求的主流程</li>
<li>execute_cgi: 运行cgi程序的处理，对应POST请求</li>
<li>sever_file: 调用cat把服务器文件返回给浏览器，对应GET请求</li>
</ul>
<p>辅助功能函数：</p>
<ul>
<li>get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束</li>
<li>unimplemented: 返回给浏览器表明收到的HTTP请求所用的method不支持，httpd只支持GET和POST</li>
<li>headers: 把HTTP响应的头部写到套接字</li>
<li>cat: 读取服务器上的指定文件写到socket套接字</li>
</ul>
<h2 id="2-httpd处理client的socket请求"><a href="#2-httpd处理client的socket请求" class="headerlink" title="(2)httpd处理client的socket请求"></a>(2)httpd处理client的socket请求</h2><p>参考TCP套接字流程，注意一点，server端回写数据后，要close掉，client才能正常close。<br>编译选项的实现讲一下：<br>Makefile根据输入参数，定义宏, 如果编译输入带参<code>make test_sock=y</code>，则定义宏TEST_SOCK，等价于在源码<code>#define TEST_SOCK</code></p>
<pre><code>#用编译选项定义宏
ifeq ($(test_sock), y)
CFLAGS+= -D TEST_SOCK
endif
</code></pre>
<p>httpd.c对宏的处理：</p>
<pre><code>#ifdef TEST_SOCK
void test_sock(int);
#else
#define test_sock(...)  do&#123;&#125;while(0)
#endif
</code></pre>
<p>这里如果没定义TEST_SOCK，直接把test_sock函数声明成do{}while(0)形式，这种控制在linux kernel源码中很常见，好处是不需要在调用处加宏控制，若TEST_SOCK未定义，调用test_sock()等价于空语句。<code>...</code>代表所有入参</p>
<p>扩展：httpd能否同时支持浏览器和client程序访问?<br>一个socket描述符只能对应一个客户端，如果server想要一对多的IO复用，需要select-poll机制，参考：<br><a href="https://www.cnblogs.com/feily/articles/14030297.html">IO多路复用之select、poll、epoll</a><br><a href="https://blog.csdn.net/zouli415/article/details/79696766">linux下socket编程实现一个服务器连接多个客户端</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/nengm1988/p/7816618.html">Tinyhttpd精读解析</a><br><a href="https://github.com/EZLippi/Tinyhttpd">EZLippi&#x2F;Tinyhttpd</a></p>
]]></content>
      <categories>
        <category>open source</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>如何看懂UML类图</title>
    <url>/2020/12/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。<br>统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。<br>UML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图<br>本文介绍开发中常用的类图</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。<br>首先讲解关系, 先来看一个例子：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148263.png" alt="image-20221205114810203"></p>
<p>分析一下上面的图, 首先从动物开始<br>动物是一个类 动物依赖氧气和水<br>然后鸟继承了动物，所以鸟的父类是动物 所以鸟是属于动物<br>然后鸟和翅膀是组合关系 一只鸟有两个翅膀<br>大雁鸭子和企鹅都是鸟所以继承了鸟类<br>大雁会有大雁群，大雁群是由大雁组成所以是聚合关系<br>企鹅和气候是关联关系因为企鹅需要依赖气候<br>然后再看大雁 大雁会飞翔 所以就实现了飞翔接口<br>唐老鸭是属于鸭子的 所以唐老鸭继承了鸭子这个类<br>上图是借鉴了大话设计模式里面的图。下面具体介绍各个符号的作用</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类一般是用三层矩形框表示，第一层表示类的名称，第二层表示的是字段和属性，第三层则是类的方法。第一层中，如果是抽象类，需用斜体显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148740.png" alt="image-20221205114819689"></p>
<h2 id="类符号"><a href="#类符号" class="headerlink" title="类符号"></a>类符号</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148030.png" alt="image-20221205114830981"><br>看上面的学生类里面有五个属性和两个方法</p>
<pre><code>+号表示公共的 public
-表示 私有的 private
#表示protected
</code></pre>
<p>带下划线表示静态属性，一般表示方法: +属性:类型。<br>括号内表示参数，后面是返回类型, 没有表示无返回值</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包(Package)： 是一种常规用途的组合机制。在UML中用一个Tab框表示，Tab里写上包的名称，框里则用来放一些其他子元素，比如类，子包等等。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148985.png" alt="image-20221205114837947"></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口(interface)：接口包含操作但不包含属性，且它没有对外界可见的关联<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148968.png" alt="image-20221205114843929"></p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>依赖(Dependency) 表示的是类之间的调用关系。UML中用带箭头的虚线表示依赖关系，而箭头所指的则是被依赖的类。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148704.png" alt="image-20221205114849672"></p>
<h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>泛化(Generalization)： 表示的是类之间的继承关系，注意是子类指向父类。UML中用带空心三角箭头的实线表示泛化关系，箭头指向的是一般个体。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148143.png" alt="image-20221205114855112"></p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联(Association) 表示的是类与类之间存在某种特定的对应关系。UML中用双向带箭头的虚线表示关联关系，箭头两端为相互关联的两个类<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051149187.png" alt="image-20221205114902153"></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合(Aggregation)： 是关联关系的一种特例，表示的是整体与部分之间的关系，部分不能离开整体单独存在。UML中用空心菱形头的实线表示聚合关系，菱形头指向整体<br><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221205114909206.png" alt="image-20221205114909206"></p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合(Composition)： 是聚合的一种特殊形式，表示的是类之间更强的组合关系。UML中用实心菱形头的实线来表示组合，菱形头指向整体。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051149567.png" alt="image-20221205114949528"></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派笔记：使用ALSA+A2DP+PulseAudio自制蓝牙音箱</title>
    <url>/2021/09/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8ALSA-A2DP-PulseAudio%E8%87%AA%E5%88%B6%E8%93%9D%E7%89%99%E9%9F%B3%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>树莓派4B自带蓝牙和Wifi, 无需外接 USB dongle；<br>蓝牙最常见的应用是近距离传输数据，比如蓝牙传文件，蓝牙音箱等。正好家里有个普通的usb供电的便携音箱；</p>
<p>本文用树莓派蓝牙+普通音箱，实现简单的蓝牙音箱。</p>
<p>首先需要了解Linux音频系统的整体框架：<br><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221208194352559.png" alt="image-20221208194352559"></p>
<p>大致分为三个部分：</p>
<ul>
<li>kernel&#x2F;driver层的ALSA驱动框架</li>
<li>蓝牙音频协议栈：A2DP, 这是使蓝牙具有传输音频流能力的基石; Linux官方的bluez包实现了A2DP</li>
<li>音频应用层, Linux最常用的音频服务器是Pulse Audio</li>
</ul>
<p>怎样理解这三层：可以类比Linux网络层：<br>ALSA 类似网络驱动框架<br>A2DP 类似TCP&#x2F;UDP层<br>PulseAudio 类似HTTP层的服务器，类比Apache</p>
<p>而蓝牙连接类似http连接和会话；<br>声卡(输入、输出)类似网卡(Ethernet和wifi)，音频设备(音箱，麦克风)类似具体的网口设备</p>
<p>深入了解 ALSA 音频驱动和 A2DP 蓝牙音频协议，参考：<br><a href="https://www.alsa-project.org/wiki/Main_Page">Advanced Linux Sound Architecture (ALSA) project homepage</a><br><a href="http://www.dslreports.com/r0/download/2285126~a70eb148e16b921dc323dbb977d4b4b1/A2DP_SPEC.pdf">A2DP Spec</a></p>
<p>本文的环境<br>树莓派4B, 系统: ubuntu-server raspberry pi版本<br>音箱：usb供电，音频线<br>安卓手机：用于配对树莓派的蓝牙音频服务</p>
<p>连接示意图</p>
<pre><code> Audio source (i.e. smartphone) 
                |
                v
 (((  Wireless Bluetooth Channel  )))
                |
                v
  Raspberry PI (with A2DP service)
                |
                v
         Audio Interface
                |
                v
             Speakers
</code></pre>
<h1 id="使用alsa-utils测试音频设备"><a href="#使用alsa-utils测试音频设备" class="headerlink" title="使用alsa-utils测试音频设备"></a>使用alsa-utils测试音频设备</h1><p>首先测试Linux上如何使用普通音箱<br>将音箱USB连到树莓派USB, 音频线连到音频接口</p>
<h2 id="查看音频设备"><a href="#查看音频设备" class="headerlink" title="查看音频设备"></a>查看音频设备</h2><p>ALSA在应用层提供了alsa-utils包，其含有arecord、aplay等工具来查看和使用音频设备。</p>
<pre><code>apt-get install alsa-utils
</code></pre>
<p>查看声卡列表：</p>
<pre><code>cat /proc/asound/cards
</code></pre>
<p>可以看到当前有两张声卡</p>
<p>card 0是树莓派的bcm2835集成声卡，card 1 是另外接的USB麦克风</p>
<p>注意区分声卡和音频设备，一个声卡可以管理多个音频设备，类似于”总线”和”设备”的关系。</p>
<p>音频设备可以细分为输入和输出两种：例如音箱是播放音频，属于输出；麦克风是录入音频，属于输入。下面分别查看这两类设备。</p>
<p>查看音频输入设备：</p>
<pre><code>arecord -l
</code></pre>
<p>查看音频输出设备：</p>
<pre><code>aplay -l
</code></pre>
<h2 id="使用音频设备"><a href="#使用音频设备" class="headerlink" title="使用音频设备"></a>使用音频设备</h2><p>(1)测试音频输出：</p>
<pre><code>aplay test.wav -D plughw:CARD=0,DEV=0
</code></pre>
<p>音频设备用 CARD 和 DEV 指定，来自于前文<code>aplay -l</code>查看音频设备的输出<br>测试音频(wav格式)可以在此下载：<a href="https://www.ape8.cn/wav/">ape8.cn</a></p>
<p>(2)测试音频输入：</p>
<p>使用arecord录制音频输入<br>-f 录制音频格式。例如 cd 表示 (16 bit little endian, 44100, stereo)<br>-d 录制时间，单位秒<br>-c 输入通道的个数，如果是麦克风阵列可能有多通道<br>-D 使用的设备：-D hw:1,0 表示使用 card 1 下的device 0设备</p>
<p>测试如下：</p>
<pre><code>arecord -f cd -d 5 -c 1 -D hw:1,0 &gt; test.pcm
</code></pre>
<p>然后播放此音频：</p>
<pre><code>aplay test.pcm
</code></pre>
<h1 id="蓝牙服务相关配置"><a href="#蓝牙服务相关配置" class="headerlink" title="蓝牙服务相关配置"></a>蓝牙服务相关配置</h1><h2 id="蓝牙协议栈和服务的安装"><a href="#蓝牙协议栈和服务的安装" class="headerlink" title="蓝牙协议栈和服务的安装"></a>蓝牙协议栈和服务的安装</h2><p>首先确保系统软件是最新：</p>
<pre><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>安装 bluez，pulseaudio 等蓝牙基础组件，对于树莓派还要安装pi-bluetooth</p>
<pre><code>sudo apt-get install pi-bluetooth bluez bluez-tools pulseaudio pulseaudio-module-bluetooth
</code></pre>
<p>bluez 是Linux官方的蓝牙协议栈，其内部实现 A2DP 蓝牙音频协议，参考<a href="http://www.bluez.org/about/">bluez.org</a></p>
<p>PulseAudio 是Linux音频服务器, 其最主要的作用是：<br>PulseAudio clients can send audio to “sinks” and receive audio from “sources”</p>
<p>参考<a href="https://www.freedesktop.org/wiki/Software/PulseAudio/About/">PulseAudio&#x2F;About</a></p>
<p>简单说明下蓝牙的发送、接收的概念：<br>蓝牙的Source端为发送码流的端，Sink端为接收码流的端；可类比生产者和消费者模型</p>
<h2 id="启动音频服务"><a href="#启动音频服务" class="headerlink" title="启动音频服务"></a>启动音频服务</h2><p>PulseAudio服务需要创建用户名和用户组，示例如下：</p>
<pre><code>sudo usermod -G bluetooth -a ubuntu
</code></pre>
<p>启动服务器</p>
<pre><code>pulseaudio --start
</code></pre>
<h2 id="启动蓝牙配对"><a href="#启动蓝牙配对" class="headerlink" title="启动蓝牙配对"></a>启动蓝牙配对</h2><p>蓝牙首次连接需要配对，使用 bluez 的 <code>bluetoothctl</code>工具</p>
<p>参考：<a href="https://www.makeuseof.com/manage-bluetooth-linux-with-bluetoothctl/">How to Manage Bluetooth Devices on Linux Using bluetoothctl</a></p>
<pre><code>bluetoothctl //进入蓝牙配置模式，会显示用户为[bluetooth]#
[bluetooth]# list //列出树莓派的蓝牙控制器列表
[bluetooth]# agent on //注册蓝牙代理
[bluetooth]# default-agent //使用默认代理
[bluetooth]# discoverable on //树莓派的蓝牙可被其他设备发现
[bluetooth]# scan on //开始扫描可连接蓝牙设备
</code></pre>
<p>此后选择要连接的蓝牙设备，手机蓝牙打开，<code>scan on</code>列表找到手机的 MAC地址 进行连接配对。<br>手机的MAC可在设置-&gt;系统信息查看</p>
<pre><code>[bluetooth]# pair &lt;dev&gt; //配对设备，首次需要密码
[bluetooth]# trust &lt;dev&gt; //信任该设备，此后可以自动配对无需密码
[bluetooth]# connect &lt;dev&gt; //建立连接
</code></pre>
<p>现在可以退出 bluetoothctl模式，然后测试蓝牙音频播放：</p>
<pre><code>[bluetooth]# quit
aplay test.wav
</code></pre>
<p>关于蓝牙的agent，参考<a href="https://askubuntu.com/questions/763939/bluetoothctl-what-is-a-bluetooth-agent">bluetoothctl - What is a bluetooth agent?</a></p>
<h2 id="设置自动配对连接"><a href="#设置自动配对连接" class="headerlink" title="设置自动配对连接"></a>设置自动配对连接</h2><p>为了避免每次pair都要指定设备，可以配置蓝牙打开时，自动pair上次的设备。</p>
<p>编辑PulseAudio配置文件 <code>/etc/pulse/default.pa</code> </p>
<pre><code># automatically switch to newly-connected devices
load-module module-switch-on-connect
</code></pre>
<p>编辑bluez配置文件 <code>/etc/bluetooth/main.conf</code></p>
<pre><code>[Policy]
AutoEnable=true
</code></pre>
<p>系统重启后只需要重启PulseAudio服务：</p>
<pre><code>pulseaudio --start
</code></pre>
<h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><h2 id="找不到蓝牙controller"><a href="#找不到蓝牙controller" class="headerlink" title="找不到蓝牙controller"></a>找不到蓝牙controller</h2><p>最开始bluetoothctl list显示的蓝牙控制器列表是空的，我一度怀疑买了假的raspi-4B</p>
<p>原因是树莓派需要安装专门的蓝牙包 pi-bluetooth，参考<a href="https://raspberrypi.stackexchange.com/questions/114586/rpi-4b-bluetooth-unavailable-on-ubuntu-20-04">rpi-4b-bluetooth-unavailable-on-ubuntu</a></p>
<p>树莓派很多功能都要求系统有定制包，大多数硬件失效都是定制包未安装。</p>
<h2 id="蓝牙连接正常，播放没声音"><a href="#蓝牙连接正常，播放没声音" class="headerlink" title="蓝牙连接正常，播放没声音"></a>蓝牙连接正常，播放没声音</h2><p>首先确认音频设备物理连接是否正常；</p>
<p>然后确认PulseAudio音频服务是否正常，检查服务状态和配置文件；</p>
<pre><code>pacmd info
pactl info
</code></pre>
<p>问题仍没有解决，仔细听似乎有很小的声音，检测音量配置：</p>
<pre><code>pacmd list-sinks //找到sink设备，即音箱
pacmd set-sink-volume &lt;sink&gt; &lt;value&gt; //设置音量，value取值 [0, 65536] 代表标准音量 0~100%
</code></pre>
<p>参考：<a href="https://askubuntu.com/questions/219739/adjust-max-possible-volume-in-pulseaudio#:~:text=pactl%20set-sink-volume%200%20100%25%20Where%200%20is%20the,100%25%20to%20get%20audio%20boost%20%28200%25%20for%20example%29.">adjust max possible volume in pulseaudio</a></p>
<p>此时播放音乐可以听到但声音极小；<br>检查音箱的线控音量调节，调到最大；<br>此时蓝牙音乐只有正常音箱大概 30% 的播放音量。</p>
<p>原因是树莓派的USB供电驱动能力有限，同一音箱，在PC-USB供电下30%的音量大小等同于树莓派上100%的音量大小。</p>
<p>自此蓝牙播放音量可以达到正常水平，需要更高音量和音质建议220V供电的音箱。</p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p><a href="https://www.jianshu.com/p/1b79537da86d">Ubuntu音频设备检测</a><br><a href="https://www.nicolabs.net/2020/Make-RPi-bluetooth-speaker-part-1">Make-RPi-bluetooth-speaker-part-1</a><br><a href="https://gist.github.com/actuino/9548329d1bba6663a63886067af5e4cb">actuino&#x2F;bt_speaker-raspberry_pi-zero_w</a><br><a href="https://gist.github.com/oleq/24e09112b07464acbda1#file-a2dp-autoconnect-L17">A2DP audio streaming using Raspberry PI</a></p>
]]></content>
      <categories>
        <category>raspi</category>
      </categories>
      <tags>
        <tag>raspi</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建高可移植的Markdown写作和博客环境：Obsidian+PicGo+Hexo+Github</title>
    <url>/2022/02/28/%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84Markdown%E5%86%99%E4%BD%9C%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%EF%BC%9AObsidian+PicGo+Hexo+Github/</url>
    <content><![CDATA[<h2 id="0-背景"><a href="#0-背景" class="headerlink" title="0.背景"></a>0.背景</h2><p>写技术笔记并发布博客，通常有以下方式：</p>
<ul>
<li>第三方平台CSDN&#x2F;cnblogs，最简单但是最不可控，例如我写过一篇如何使用shadow-sock，直接被删掉，各种广告也是技术洁癖症不能忍的。</li>
<li>使用云服务器自建Leanote博客系统，我用过几年，最大缺点是服务器续费太贵，且文章数据存在数据库很难导出，优点是自建的Leanote写作发布一体化体验极好。</li>
<li>使用github+picgo+hexo， github作为图床和博客的云服务，picgo用于建立图床通道，hexo用于发布博客。缺点是github访问慢，用开源CDN可以很好解决；优点是全部免费，数据可移植(图片链接都在github图床)，可长期使用（只要github不倒闭不锁区）</li>
</ul>
<p>最终我选择github+picgo+hexo方案。<br>为什么不用gitee: gitee上传图片限制1M, github有25M。有了CDN, github的速度也不是问题</p>
<p>现在只需要确定Markdown编辑器</p>
<p>VSCode加Markdown插件试过，体验并不完美<br><a href="https://www.typora.io/">Typora</a>是很不错的选择，除了收费<br><a href="https://obsidian.md/">Obsidian</a>免费且优雅：</p>
<ul>
<li>支持动态渲染，即写出的Markdown语句自动显示预览</li>
<li>支持各种快捷键，无需手动输入Markdown语法格式（<a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法</a>）。比如标题，链接，列表，引用，可以设置标准的Markdown快捷键。</li>
<li>支持关联PicGo实现粘贴图片即上传到云端图床，这一点对于写作体验和文章的可迁移性很重要</li>
<li>特色的Zettelkasten笔记管理方法，本文不描述这部分，参考<a href="https://sspai.com/post/62414#!">玩转 Obsidian 01：打造知识循环利器</a></li>
</ul>
<h2 id="1-搭建可移植的Markdown写作环境"><a href="#1-搭建可移植的Markdown写作环境" class="headerlink" title="1. 搭建可移植的Markdown写作环境"></a>1. 搭建可移植的Markdown写作环境</h2><p>Markdown文档本身是可移植的，但是其图片资源不是, 因为图片不是以二进制嵌入文档，而只是个图片地址的链接。</p>
<p>如果只是在本地写写Markdown，完全不需要考虑图片的可移植，只需要存本地固定路径即可。<br>如果想在本地写Markdown，且这个文档拿到别的机器，或者放到博客论坛发布，别人都可以看到图片，就要一个云端的图片存储服务，即图床。</p>
<p>本节讲如何实现一个“一处写作，到处可见”的Markdown写作环境，并优化工具设置，让写作顺滑流程</p>
<h3 id="1-1-Github-PicGo搭建图床"><a href="#1-1-Github-PicGo搭建图床" class="headerlink" title="1.1 Github+PicGo搭建图床"></a>1.1 Github+PicGo搭建图床</h3><p>完整流程参考<a href="https://blog.csdn.net/yefcion/article/details/88412025">PicGo + GitHub 搭建个人图床工具</a></p>
<p>流程包含以下部分：</p>
<ul>
<li>一个public的Github仓库，用来存放文章链接的图片，注意单仓库最大容量1GB。</li>
<li>一个personal access token，用于PicGo免密访问github实现自动上传图片</li>
<li>一个图片上传工具：PicGo及其插件，用它上连Github图床仓库，下连本地markdown编辑器，实现“图片粘贴即上传”</li>
<li>一个CDN(推荐，很好用)：使用开源CDN jsdelivr加速Github访问，避免因访问速度造成图片上传失败</li>
</ul>
<p>最终我的配置如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281014786.png"></p>
<p>单元测试：<br>手动上传本地图片，如果上传成功，且图片可预览，则功能正常<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024870.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024344.png"></p>
<p>遇到的坑：<br>仓库名必须填&lt;用户名&gt;&lt;仓库名&gt;，不是完整的http或git仓库链接！否则上传图片error404</p>
<p>PicGo支持log调试，参考：<br><a href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html"><a href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html">PicGo上传图片到GitHub总是失败的特殊解决办法</a></a></p>
<p>2022&#x2F;5&#x2F;17更新：<br>最近发现jsdelivr在大陆挂了，那么只能放弃使用CDN, 直接使用github图床的raw链接</p>
<p>将Picgo默认图床路径从jsdelivr的<br><a href="https://cdn.jsdelivr.net/gh/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D@master">https://cdn.jsdelivr.net/gh/账户名/图床仓库名@master</a><br>改为：<br><a href="https://raw.githubusercontent.com/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D/master">https://raw.githubusercontent.com/账户名/图床仓库名/master</a></p>
<p>对于已发布的博客的图床链接，直接用VSCode全局查找替换以上前缀即可，后面的图片id是不变的。</p>
<p><strong>如何删除Github图床的图片：</strong><br>PicGo默认的Github图床不能通过相册删除github仓库的图片，需要使用第三方插件github-plus，建议作为默认图床工具，支持相册删除同步到github仓库:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281208516.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281209075.png"></p>
<h3 id="1-2-Obsidian链接图床"><a href="#1-2-Obsidian链接图床" class="headerlink" title="1.2 Obsidian链接图床"></a>1.2 Obsidian链接图床</h3><p>流程参考<a href="https://www.jianshu.com/p/4c30495f4325"># 在Obsidian中使用图床实现“一次上传、多次搬运”省心又省力</a></p>
<p>重点部分：配置自动上传插件。写Markdown文章时粘贴的图片自动上传到Github+PicGo图床，无需手动上传和写链接<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029686.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029586.png"></p>
<p>可以看到，此插件相当于一个PicGo客户端，而本地运行的PicGo Server已开启端口36677的监听。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281033479.png"></p>
<p>单元测试：<br>以上配置好后，Obsidian新建一个Markdown文档，粘贴图片会显示updating… ，成功后可在github图床仓库看到该图片，且Markdown本地预览也可以看到。</p>
<p>遇到的坑：<br>一开始上传的图片，github可预览，Obsidian预览失败<br>在PicGo客户端查看刚才上传图片预览也不正常，PicGo客户端手动上传一张后才正常预览。<br>此后Obsidian再粘贴上传图片，预览正常。<br>可能是PicGo首次链接Obsidian插件的bug。</p>
<h3 id="1-3-优化Obsidian写作体验"><a href="#1-3-优化Obsidian写作体验" class="headerlink" title="1.3 优化Obsidian写作体验"></a>1.3 优化Obsidian写作体验</h3><h4 id="1-3-1-Markdown快捷键"><a href="#1-3-1-Markdown快捷键" class="headerlink" title="1.3.1 Markdown快捷键"></a>1.3.1 Markdown快捷键</h4><p>很多Markdown编辑器支持各种快捷键，写作时不需要手动输入Markdown语法，例如一个ctrl+h形成标题，一个ctrl+k形成代码格式。<br>Obsidian默认快捷键不完整，需要补全优化<br>我之前用的Leanote写博客，Obsidian也快捷键设置如下。</p>
<blockquote>
<p>提升标题 Ctrl + H (header)<br>有序列表 Ctrl + O (Ordered)<br>无序列表 Ctrl + U (Un-Ordered)<br>插入链接 Ctrl + L (Link)<br>插入代码 Ctrl + K (K &#x3D; Code, 因为ctrl+C用于粘贴)<br>加粗 Ctrl + B (Bold)<br>斜体 Ctrl + I (Italian体)<br>引用 Ctrl + Q (Quote)<br>插入图片 Ctrl + G (Graph, 有了“粘贴即上传”，这个实际上用不上)</p>
</blockquote>
<p>其他我基本不用的就没设置，例如表格，删除线，分割线等等。<br>如果经常用表格，推荐 Advanced Tables插件。<br>读者也可以参考VS Code的Markdown插件设置。</p>
<h4 id="1-3-2-实时预览和标题大纲"><a href="#1-3-2-实时预览和标题大纲" class="headerlink" title="1.3.2 实时预览和标题大纲"></a>1.3.2 实时预览和标题大纲</h4><p>实时预览是你写一句Markdown，自动转换成预览格式，而不显示Markdown源码。这样不需要开两个窗口，一个写源码一个看预览。在设置-&gt;编辑器里开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281103907.png"></p>
<p>标题大纲是侧边栏显示文章标题列表，就像word的导航窗口一样。在设置-核心插件开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281104255.png"></p>
<h2 id="2-搭建hexo博客发布环境"><a href="#2-搭建hexo博客发布环境" class="headerlink" title="2. 搭建hexo博客发布环境"></a>2. 搭建hexo博客发布环境</h2><h3 id="2-1-环境安装"><a href="#2-1-环境安装" class="headerlink" title="2.1 环境安装"></a>2.1 环境安装</h3><p>整体流程参考：<a href="https://zhuanlan.zhihu.com/p/105715224"># 个人博客第5篇——安装node.js和Hexo</a><br>官方文档参考：<a href="https://hexo.io/zh-cn/docs/">hexo.io</a></p>
<p>简单总结一下：</p>
<ul>
<li>hexo是一个基于nodeJS的博客框架，nodeJS提供JavaScript实现后端服务的能力。</li>
<li>hexo可以将本地写好的Markdown文本和图片资源，以JavaScript网页资源的方式打包。hexo可以在本机运行服务，通过浏览器可以在网页访问。</li>
<li>如果要使博客外网可访问，需要一个云服务存放hexo生成的博客，我们使用github仓库作为博客云端。前面已经搭建了github图床仓库，因此图片并不需要放到此hexo仓库。</li>
<li>使用git实现hexo博客部署到github仓库</li>
</ul>
<p>遇到的坑：<br>如果你以前用过hexo，之后nodeJS升级了版本，一定不要用以前的hexo博客目录，必须新建博客目录，重新<code>hexo init</code>安装相关hexo插件。否则nodeJS和hexo插件可能不兼容导致部署失败。</p>
<p>hexo插件版本是根据nodeJS版本自动安装的，配置文件是package.json。以nodeJS 16.3为例，自动生成的依赖版本如下：</p>
<p><code>&#123;   &quot;name&quot;: &quot;hexo-site&quot;,   &quot;version&quot;: &quot;0.0.0&quot;,   &quot;private&quot;: true,   &quot;scripts&quot;: &#123;     &quot;build&quot;: &quot;hexo generate&quot;,     &quot;clean&quot;: &quot;hexo clean&quot;,     &quot;deploy&quot;: &quot;hexo deploy&quot;,     &quot;server&quot;: &quot;hexo server&quot;   &#125;,   &quot;hexo&quot;: &#123;     &quot;version&quot;: &quot;6.0.0&quot;   &#125;,   &quot;dependencies&quot;: &#123;     &quot;hexo&quot;: &quot;^6.0.0&quot;,     &quot;hexo-deployer-git&quot;: &quot;^3.0.0&quot;,     &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,     &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,     &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,     &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,     &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,     &quot;hexo-renderer-marked&quot;: &quot;^5.0.0&quot;,     &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;,     &quot;hexo-server&quot;: &quot;^3.0.0&quot;,     &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot;   &#125; &#125;</code></p>
<p>博客的github仓库，主题等关键配置都在<code>hexo init</code>对应目录下的<code>_config.yml</code><br>我修改了几个关键配置如下：<br>博客框架的语言一定要配，否则默认德语阿拉伯语…</p>
<blockquote>
<p>title: ThinkNotes<br>   subtitle: Simple is not easy<br>   author: Cursorhu<br>   language: zh-CN</p>
</blockquote>
<p>Github部署配置</p>
<blockquote>
<p>url: <a href="https://cursorhu.github.io/">https://cursorhu.github.io</a><br>deploy:<br>      type: git<br>      repo: <a href="https://github.com/cursorhu/cursorhu.github.io">https://github.com/cursorhu/cursorhu.github.io</a><br>      branch: master</p>
</blockquote>
<h3 id="2-2-发布博客"><a href="#2-2-发布博客" class="headerlink" title="2.2 发布博客"></a>2.2 发布博客</h3><p>hexo new命令可以从0新建markdown写博客，一般不用这么麻烦。</p>
<p>我们直接将Obsidian写好的Markdown（图片资源是图床链接）放到hexo博客目录的post文件夹，例如我的本地目录是：</p>
<blockquote>
<p>F:\HexoBlog\source_posts</p>
</blockquote>
<p>在Markdown文件前添加hexo博客特有的头，说明博客的标题时间，分类等属性。这个头如果用<code>hexo new</code>命令会自动生成，可以先new一个然后拷过来。</p>
<blockquote>
<p>title: 博客文章名<br>date: 2022-02-28 15:04:18<br>tags: markdown<br>categories: markdown</p>
</blockquote>
<p>最后使用git生成网页文件并发布到github博客仓库, 注意不是用node命令行！<br>在hexo博客目录下运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-博客主题"><a href="#2-3-博客主题" class="headerlink" title="2.3 博客主题"></a>2.3 博客主题</h3><p>博客主题(theme)取决于不同人喜好，github有大量的hexo主题，按需配置<br>推荐几个主流的：<br><a href="https://github.com/theme-next/hexo-theme-next">Next</a><br><a href="https://github.com/bollnh/hexo-theme-material">hexo-theme-material</a></p>
<p>以Next主题为例，安装：</p>
<blockquote>
<p>$ cd hexo博客目录<br>   $ git clone <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> themes&#x2F;next</p>
</blockquote>
<p>已我的配置为例，就会在F:\HexoBlog\themes\next看到next主题的源码和配置文件config.yml</p>
<p>Next配置可以自定义各种设置，例如子主题:</p>
<blockquote>
<p> scheme: Muse<br>#scheme: Mist<br>#scheme: Pisces<br>#scheme: Gemini</p>
</blockquote>
<p>我们前面已经用jsdelivr开源CDN为PicGo上传图片加速，可以配置Next主题的网页静态文件的相关库也用jsdelivr加速。最好用到才开启，例如motion enable, 其依赖库velocity就可以设置jsdelivr加速：</p>
<blockquote>
<p>motion:<br>      enable: true<br>    velocity: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.min.js<br>    velocity_ui: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.ui.min.js</p>
</blockquote>
<p>注意这些配置文件也是Markdown格式，<code># </code> 注释一定要带空格</p>
<p>hexo要使用next, 在hexo配置文件设置:</p>
<blockquote>
<p>theme: next</p>
</blockquote>
<p>hexo clean, hexo g, hexo s 跑本地服务，看一下效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203041651883.png"></p>
<p>最后hexo clean, g, d 命令三连部署到github</p>
<h3 id="2-4-速度优化"><a href="#2-4-速度优化" class="headerlink" title="2.4 速度优化"></a>2.4 速度优化</h3><p>参考<a href="https://ednovas.gitee.io/2021/09/23/speeduphexo/"># Hexo 网站访问速度优化</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派笔记：使用mjpg-streamer+Apache+SSH自制网络摄像头</title>
    <url>/2021/08/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8mjpg-streamer-Apache+SSH%E8%87%AA%E5%88%B6%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h1><ul>
<li>为什么用树莓派4：</li>
</ul>
<p>资料多遇到容易解决问题；<br>性能较强适合作为终端服务器；<br>自带WIFI, BT5.0，GPIO 方便拓展开发IOT相关项目；<br>适配系统丰富，基本PC上linux版本树莓派都有对应版本</p>
<ul>
<li>为什么用USB摄像头：</li>
</ul>
<p>为了快速实现，Linux对USB设备支持非常好，USB设备基本都是免驱；<br>USB摄像头支持高分辨率，带麦克风，满足其他项目拓展应用；<br>当然CSI接口摄像头也有优势，同等条件下其CPU占用率比USB低；不过本地测试中CPU并不是USB摄像头性能瓶颈<br>关于CSI和USB 摄像头区别：<a href="https://blog.csdn.net/ZhaoDongyu_AK47/article/details/103981905">CSI摄像头 vs USB摄像头</a></p>
<ul>
<li>树莓派用什么系统：</li>
</ul>
<p>看个人喜好，我用的ubuntu server的树莓派版本，软件源基本最新；</p>
<ul>
<li>用什么云服务器：</li>
</ul>
<p>看个人喜好和价格；云服务器最大价值在于公网IP<br>我目前用的Aliyun + CentOS7 系统</p>
<p>系统实拍：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081944910.png" alt="image-20221208194427802"></p>
<h1 id="树莓派系统安装"><a href="#树莓派系统安装" class="headerlink" title="树莓派系统安装"></a>树莓派系统安装</h1><p>准备：电源，网线，SD卡<br>安装步骤：</p>
<ul>
<li>1.下载ubuntu server for raspi</li>
</ul>
<p>注意一定要下载raspi版本的镜像，普通ubuntu server版本安装完不能直接使用SSH<br><a href="https://ubuntu.com/download/raspberry-pi">Install Ubuntu on a RaspberryPi</a></p>
<ul>
<li>2.Win32DiskImager写.img镜像到SD卡，作为系统盘</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/bhniunan/article/details/104790090">使用win32DiskImager为树莓派4B安装系统</a></p>
<ul>
<li>3.SSH 登陆</li>
</ul>
<p>ubuntu server for raspi系统装机启动后，连接网线到主机局域网后就可以SSH登陆<br>树莓派连到主机网段路由器的LAN口，树莓派系统默认开了dhcp, 用Advanced IP Scanner扫描树莓派IP</p>
<p>树莓派4b：mac地址“dc-a6-32”开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081944582.png" alt="image-20221208194446543"></p>
<p>SSH 软件看个人喜好，putty, SecureCRT, Xshell都可以，我个人使用的SecureCRT</p>
<p>ubuntu server for raspi系统的SSH会话初始化如下：<br>新建会话-&gt; SSH2链接-&gt; 树莓派ip -&gt; 账户名(默认ubuntu)<br>初始密码：ubuntu，登陆成功后需要重设密码。</p>
<p>wifi配置方式参考 <a href="https://blog.csdn.net/weixin_42378324/article/details/114631521">树莓派安装ubuntu server, 无显示屏和键盘</a></p>
<ul>
<li>4.固定树莓派IP</li>
</ul>
<p>DHCP方式每次启动树莓派IP可能不一样，有两种方式固定IP</p>
<ul>
<li>MAC绑定IP<br>参考<a href="https://blog.csdn.net/Echozi/article/details/104210167">TL-WR886N路由器+树莓派绑定IP地址</a></li>
<li>手动配置固定ip<br><a href="https://blog.csdn.net/u010169607/article/details/111316624">Pi4B 树莓派 ubuntu20.04 设置固定IP地址</a></li>
</ul>
<h1 id="USB摄像头测试"><a href="#USB摄像头测试" class="headerlink" title="USB摄像头测试"></a>USB摄像头测试</h1><ul>
<li>首先主机win10上验证摄usb像头功能正常</li>
</ul>
<p>设备管理器禁用笔记本原装摄像头驱动，搜索相机-&gt; 打开视频，视频流应该正常</p>
<ul>
<li>在树莓派上验证摄像头设备</li>
</ul>
<p>usb摄像头设备既是usb设备又是v4l2设备，应该挂载在&#x2F;dev&#x2F;videoX</p>
<pre><code>ls /dev/video*
ls /dev | grep video
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945191.png" alt="image-20221208194510165"><br>插拔摄像头确认usb摄像头对应设备是video0</p>
<h1 id="树莓派安装mjpg-streamer"><a href="#树莓派安装mjpg-streamer" class="headerlink" title="树莓派安装mjpg-streamer"></a>树莓派安装mjpg-streamer</h1><p>mjpg-streamer的作用是将摄像头采集的YUV&#x2F;JPEG数据，封装成流服务，其他设备可以通过http方式获取图片或视频流。<br>mjpg-streamer属于应用层实现流媒体服务端，其底层调用的是Linux V4L2框架接口。</p>
<p>安装过程：</p>
<ol>
<li><p>依赖库安装</p>
<p>sudo apt-get install subversion libjpeg8-dev imagemagick libv4l-dev cmake git</p>
</li>
<li><p>安装mjpg-streamer</p>
<p>git clone <a href="https://github.com/jacksonliam/mjpg-streamer.git">https://github.com/jacksonliam/mjpg-streamer.git</a><br>cd mjpg-streamer&#x2F;mjpg-streamer-experimental&#x2F;<br>make all<br>sudo make install</p>
</li>
</ol>
<h1 id="局域网测试mjpg-streamer"><a href="#局域网测试mjpg-streamer" class="headerlink" title="局域网测试mjpg-streamer"></a>局域网测试mjpg-streamer</h1><p>mjpg-streamer&#x2F;mjpg-streamer-experimental目录下有测试脚本：<code>start.sh</code><br>环境变量添加依赖库路径：</p>
<pre><code>export LD_LIBRARY_PATH=&quot;$(pwd)&quot; 
</code></pre>
<p>运行示例：</p>
<pre><code>./mjpg_streamer -i &quot;./input_uvc.so&quot; -o &quot;./output_http.so -w ./www&quot; 
</code></pre>
<p>其YUV&#x2F;MJPEG的输入使用 input_uvc.so， 输出流到 http依赖于 output_http.so，<code>-w ./www</code> 表示http客户端访问时返回www文件夹下的资源，即对应的浏览器页面。</p>
<p>可以自定义参数，参考：</p>
<pre><code>mjpg_streamer -i &quot;input_uvc.so --help&quot;
</code></pre>
<p>修改start.sh的自定义启动语句如下：</p>
<pre><code>./mjpg_streamer -i &quot;./input_uvc.so -n -f 30 -r 640x480 -d /dev/video0&quot;  -o &quot; ./output_http.so -w ./www&quot;
</code></pre>
<p>-n 用于跳过一些ioctrl请求，我的摄像头如果不用-n，有一些ioctrl会返回错误，尽管不影响流传输功能，还是跳过。<br>-f 设置fps，如果有卡顿考虑降低该值<br>-r 分辨率，1080P摄像头可以支持到1920x1080<br>-d 设备名，默认&#x2F;dev&#x2F;video0</p>
<p>一般USB摄像头支持直接输出压缩后的MJPEG格式图像，有的只支持YUV格式图像；<br>摄像头优先使用MJPEG格式，因为不用mjpg-streamer软件边采集边做压缩，减少CPU使用</p>
<p>启动信息：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945245.png" alt="image-20221208194525192"></p>
<p>此时流服务已运行，在局域网任意设备用浏览器访问<code>树莓派ip:流服务端口</code>即可获取www目录的网页资源<br>192.168.0.105是我树莓派固定ip, 8080是mjpg-streamer服务默认端口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945636.png" alt="image-20221208194549504"><br>局域网下即使是1080p 30fps也非常流畅，看不出卡顿</p>
<h1 id="公网服务器搭建反向代理"><a href="#公网服务器搭建反向代理" class="headerlink" title="公网服务器搭建反向代理"></a>公网服务器搭建反向代理</h1><h2 id="反向代理的概念"><a href="#反向代理的概念" class="headerlink" title="反向代理的概念"></a>反向代理的概念</h2><p>正向代理和反向代理的概念图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946618.png" alt="image-20221208194609572"></p>
<p>正向代理：代理的是客户端，例如GFW禁止某用户直接访问目标服务器的8080端口，但没有禁止访问正向代理服务器，客户端访问正向代理服务器，代理服务将用户请求转发给目标服务器，实现“蛙跳式”访问。对于目标服务器来说，正向代理服务器才是其客户端，用户ip对其是不可见的。<br>反向代理：代理的是服务端，应用于以下场景：</p>
<ul>
<li>出于安全考虑，目标服务器不直接暴露其ip和端口，用户通过访问反向代理服务器来间接访问目标服务器</li>
<li>保证系统稳定性：反向代理服务器可以代理多个目标服务器，当用户请求量大时作为负载均衡(<a href="https://blog.csdn.net/ywd1992/article/details/112858537">负载均衡和反向代理的区别</a>); 支持目标服务器作为集群管理，当某个目标服务器失效时将请求转发到其他服务器, 参考<a href="https://www.cnblogs.com/jkko123/p/6426857.html">centos7下apache2.4反向代理</a></li>
</ul>
<p>对于本项目，树莓派的mjpg-streamer进程是真正提供流媒体服务的目标服务器，阿里云公网服务器上安装apache服务，实现反向代理。</p>
<h2 id="安装apache服务"><a href="#安装apache服务" class="headerlink" title="安装apache服务"></a>安装apache服务</h2><p>Apache实现http web服务器；没有apache, 客户浏览器页面没办法访问对应服务。<br>阿里云主机 cent-OS 7 上的安装过程：</p>
<pre><code>//安装Apache
yum install httpd
//设置服务器开机自动启动Apache
systemctl enable httpd.service
//启动Apache
systemctl start httpd.service
//重启
systemctl restart httpd.service
//停止
systemctl stop httpd.service    
</code></pre>
<p>启动apache后，直接访问阿里云ip，默认端口 80 即为 apache 进程端口，得到如下页面说明服务正常<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946493.png" alt="image-20221208194622426"></p>
<h2 id="配置apache为反向代理"><a href="#配置apache为反向代理" class="headerlink" title="配置apache为反向代理"></a>配置apache为反向代理</h2><p>apache相关配置路径在&#x2F;etc&#x2F;httpd的几个conf目录<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946576.png" alt="image-20221208194635517"></p>
<p><code>vim /etc/httpd/conf/httpd.conf</code> 查看关键内容如下:</p>
<pre><code>Listen 80 //监听80端口
Include conf.modules.d/*.conf //包含module.d目录的所有conf
DocumentRoot &quot;/var/www/html&quot; //默认返回该目录的html资源
IncludeOptional conf.d/*.conf //包含conf.d目录的所有conf
</code></pre>
<p><code>/etc/httpd/conf.modules.d</code>目录下的<code>00-proxy.conf</code>是针对代理的配置项，其中有大量LoadModule加载proxy模块。<br>配置内容是XML格式，在此自定义反向代理，追加以下内容：</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ProxyRequests off
    &lt;Proxy raspi&gt;
        Order allow,deny
        Allow from all
    &lt;/Proxy&gt;
    ProxyPass /raspi http://127.0.0.1:9020
    ProxyPassReverse /raspi http://127.0.0.1:9020
&lt;/VirtualHost&gt;
</code></pre>
<p>含义：<br><code>&lt;VirtualHost *:80&gt;</code> 定义一个虚拟主机，<em>表示任意命名，端口80<br><code>ProxyRequests off</code> 关闭正向代理<br><code>&lt;Proxy raspi&gt;</code>定义一个代理对象，可以命名为</em>，这里命名为raspi因为后端服务是raspi流服务<br><code>ProxyPass</code> 和 <code>ProxyPassReverse</code> 内容要完全一样，<code>ProxyPassReverse /raspi http://127.0.0.1:9020</code> 表示用户访问&#x2F;raspi资源实际访问的是本地（apache所在云主机）的9020端口。</p>
<p>注意阿里云端口要支持外部可访问，需要在控制台配置安装组，参考：<a href="https://developer.aliyun.com/article/767328">阿里云服务器开放端口教程</a></p>
<p>我个人的配置是直接(1~65535)全部端口打开（不推荐，有风险）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946296.png" alt="image-20221208194652256"></p>
<p>配置完毕重启apache服务</p>
<h2 id="配置SSH反向隧道"><a href="#配置SSH反向隧道" class="headerlink" title="配置SSH反向隧道"></a>配置SSH反向隧道</h2><p>树莓派的mjpg-streamer服务如何连接到阿里云的apache服务？<br>使用SSH连通。关于SSH，参考<a href="https://www.ssh.com/academy/ssh">SSH (Secure Shell) Home Page</a></p>
<p>前文的SecureCRT登陆树莓派就是使用SSH2协议，下面将树莓派的mjpg-streamer服务端口通过SSH反向隧道连接到apache的代理端口</p>
<pre><code>ssh -fN -R &lt;阿里云apache代理端口&gt;:&lt;树莓派localhost&gt;:&lt;树莓派mjpg-streamer服务端口&gt; &lt;阿里云服务器用户名&gt;@&lt;服务器IP&gt;
</code></pre>
<p>例如 <code>ssh -fN -R 9020:localhost:8080 root@47.100.221.149</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947690.png" alt="image-20221208194724640"></p>
<p>输入服务器的登录密码完成通道建立，在阿里云可以查看：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947971.png" alt="image-20221208194733933"></p>
<h1 id="验证公网可访问-mjpg-streamer-服务"><a href="#验证公网可访问-mjpg-streamer-服务" class="headerlink" title="验证公网可访问 mjpg-streamer 服务"></a>验证公网可访问 mjpg-streamer 服务</h1><ul>
<li><p>1.验证树莓派到apache的视频流通道：</p>
<ol>
<li>阿里云服务器启动apache</li>
<li>树莓派建立SSH反向隧道</li>
<li>树莓派启动mjpg-streamer</li>
<li>在阿里云curl访问本地的代理端口</li>
</ol>
<p> curl 127.0.0.1:9020&#x2F;?action&#x3D;stream</p>
</li>
</ul>
<p>如果有大量数据输出，说明连接没问题</p>
<ul>
<li>2.验证apache到客户端浏览器的反向代理通道：</li>
</ul>
<p>使用处于任意网络的设备的浏览器，访问：</p>
<pre><code>http://云服务器IP / Apache代理名 / ?action=stream
</code></pre>
<p>本文中配置对应的输入是：<code>47.100.221.149/raspi/?action=stream</code>，注意<code>?action=stream</code>不能掉，直接访问<code>/raspi</code>得到的是静态页面，跳转不到<code>action=stream</code>的页面<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947462.png" alt="image-20221208194745374"></p>
<p>直接访问 SSH 通道的 9020 端口支持主页面访问和跳转到<code>action=stream</code>页面：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947787.png" alt="image-20221208194754703"></p>
<p>自此验证完毕公网可访问树莓派的视频流服务</p>
<h1 id="性能测试与优化"><a href="#性能测试与优化" class="headerlink" title="性能测试与优化"></a>性能测试与优化</h1><p>实测发现mjpg-streamer启动时使用 640x480分辨率, 30fps，MJPEG格式，延迟卡顿严重</p>
<p>树莓派 ping 阿里云延迟很小：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081948699.png" alt="image-20221208194803656"><br>可能是阿里云带宽不足以支撑大数据量，只能降低分辨率和帧率</p>
<p>我的阿里云服务器只有 3M 带宽，计算一下合适的配置：</p>
<pre><code>3 * 1M/8 = 3 * 128KB = 384KB
</code></pre>
<p>理论上当分辨率 640x480 &#x3D; 300KB, fps 要设置为 1 才几乎无延迟</p>
<p>测试一： 分辨率&#x3D;640x480, fps&#x3D;5<br>结果：初始延迟在 1s 以内，之后延迟增加到几秒；</p>
<p>测试二： 分辨率&#x3D;640x480, fps&#x3D;1<br>结果：初始延迟在 0.5s 左右，半小时后延迟也稳定在1s以内，效果明显比 fps&#x3D;5 好；<br>测试符合理论预期，分辨率 和 FPS 要满足带宽</p>
<p>延迟的测试方法：手机计时，网页视频显示，放一起拍照，时间差即视频延迟<br>以下显示都在1分47秒，延迟小于 1s<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081948279.png" alt="image-20221208194813177"></p>
<p>注意: 树莓派长时间运行发热较明显，需要配散热片。</p>
]]></content>
      <categories>
        <category>raspi</category>
      </categories>
      <tags>
        <tag>raspi</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C++实现单例模式</title>
    <url>/2020/11/20/%E6%B5%85%E8%B0%88C-%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>相信大家面试都逃不开设计模式话题，本节将阐述面试中的最常用的设计模式(单例模式)，从分类，线程安全，不基于C++11标准的角度与基于C++11标准的角度，有哪些解决线程安全的单例模式方案，相信认真看完本篇文章，在以后面试中就不用担忧了。</p>
<p>众所周知的单例：<br>在一般书籍中或者大家比较是熟知的单例模式是下面这样：</p>
<pre><code>class singleton &#123;
private:
    singleton() &#123;&#125;
    static singleton *p;
public:
    static singleton *instance();
&#125;;

singleton *singleton::p = nullptr;

singleton* singleton::instance() &#123;
    if (p == nullptr)
        p = new singleton();
    return p;
&#125;
</code></pre>
<p>这是一个非常简单的实现，将构造函数声明为private或protect防止被外部函数实例化，内部有一个静态的类指针保存唯一的实例，实例的实现由一个public方法来实现，该方法返回该类的唯一实例。</p>
<p>当然这个代码只适合在单线程下，当多线程时，是不安全的。考虑两个线程同时首次调用instance方法且同时检测到p是nullptr，则两个线程会同时构造一个实例给p，这将违反了单例的准则。</p>
<h1 id="2-懒汉与饿汉"><a href="#2-懒汉与饿汉" class="headerlink" title="2.懒汉与饿汉"></a>2.懒汉与饿汉</h1><p>单例分为两种实现方法：</p>
<p>懒汉:第一次用到类实例的时候才会去实例化，上述就是懒汉实现。<br>饿汉:单例类定义的时候就进行了实例化。</p>
<p>这里也给出饿汉的实现：</p>
<pre><code>class singleton &#123;
private:
    singleton() &#123;&#125;
    static singleton *p;
public:
    static singleton *instance();
&#125;;

singleton *singleton::p = new singleton();
singleton* singleton::instance() &#123;
    return p;
&#125;
</code></pre>
<p>当然这个是线程安全的，对于我们通常阐述的线程不安全，为懒汉模式，下面会阐述懒汉模式的线程安全代码优化。</p>
<h1 id="3-多线程加锁"><a href="#3-多线程加锁" class="headerlink" title="3.多线程加锁"></a>3.多线程加锁</h1><p>在C++中加锁有个类实现原理采用RAII，不用手动管理unlock，那就是lock_guard，这里采用其进行加锁。</p>
<pre><code>class singleton &#123;
private:
    singleton() &#123;&#125;
    static singleton *p;
    static mutex lock_;
public:
    static singleton *instance();
&#125;;

singleton *singleton::p = nullptr;

singleton* singleton::instance() &#123;
    lock_guard&lt;mutex&gt; guard(lock_);
    if (p == nullptr)
        p = new singleton();
    return p;
&#125;
</code></pre>
<p>这种写法不会出现上面两个线程都执行到p&#x3D;nullptr里面的情况，当线程A在执行p &#x3D; new Singleton()的时候，线程B如果调用了instance()，一定会被阻塞在加锁处，等待线程A执行结束后释放这个锁。从而是线程安全的。</p>
<p>但是这种写法性能非常低下，因为每次调用instance()都会加锁释放锁，而这个步骤只有在第一次new Singleton()才是有必要的，只要p被创建出来了，不管多少线程同时访问，使用if (p &#x3D;&#x3D; nullptr)进行判断都是足够的（只是读操作，不需要加锁），没有线程安全问题，加了锁之后反而存在性能问题。</p>
<p>因此引出**双重检查锁(DCL)**。</p>
<h1 id="4-双重检查锁模式"><a href="#4-双重检查锁模式" class="headerlink" title="4.双重检查锁模式"></a>4.双重检查锁模式</h1><p>上面写法是不管任何情况都会去加锁，然后释放锁，而对于读操作是不存在线程安全的，故只需要在第一次实例创建的时候加锁，以后不需要。下面先看一下DCLP的实现：</p>
<pre><code>singleton* singleton::instance() &#123;
    if(p == nullptr) &#123;  // 第一次检查
        Lock lock;
        if(p == nullptr)&#123; // 第二次检查
            p = new singleton;
        &#125;
    &#125;
    return p;
&#125;
</code></pre>
<p>基于上述，我们可以写出<strong>双重检查锁+自动回收(DCLP)</strong></p>
<pre><code>class singleton &#123;
private:
    singleton() &#123;&#125;

    static singleton *p;
    static mutex lock_;
public:
    singleton *instance();

    // 实现一个内嵌垃圾回收类
    class CGarbo
    &#123;
    public:
        ~CGarbo()
        &#123;
            if(singleton::p)
                delete singleton::p;
        &#125;
    &#125;;
    static CGarbo Garbo; // 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象
&#125;;

singleton *singleton::p = nullptr;
singleton::CGarbo Garbo;

singleton* singleton::instance() &#123;
    if (p == nullptr) &#123;
        lock_guard&lt;mutex&gt; guard(lock_);
        if (p == nullptr)
            p = new singleton();
    &#125;
    return p;
&#125;
</code></pre>
<p>DCLP的关键在于，大多数对instance的调用会看到p是非空的，因此甚至不用尝试去初始化它。因此，DCLP在尝试获取锁之前检查p是否为空。只有当检查成功（也就是p还没有被初始化）时才会去获得锁，然后再次检查p是否仍然为空（因此命名为双重检查锁）。第二次检查是必要，因为就像我们刚刚看到的，很有可能另一个线程偶然在第一次检查之后，获得锁成功之前初始化p。</p>
<p>看起来上述代码非常美好，可是过了相当一段时间后，才发现这个漏洞，原因是：<strong>内存读写的乱序执行(编译器问题)。</strong></p>
<p>再次考虑初始化p的那一行：</p>
<pre><code>p = new singleton;
</code></pre>
<p>这条语句会导致三个事情的发生：</p>
<ul>
<li>分配能够存储singleton对象的内存；</li>
<li>在被分配的内存中构造一个singleton对象；</li>
<li>让p指向这块被分配的内存。</li>
</ul>
<p>可能会认为这三个步骤是按顺序执行的，但实际上只能确定步骤1是最先执行的，步骤2，3却不一定。问题就出现在这。</p>
<ol>
<li>线程A调用instance，执行第一次p的测试，获得锁，按照1,3,执行，然后被挂起。此时p是非空的，但是p指向的内存中还没有Singleton对象被构造。</li>
<li>线程B调用instance，判定p非空，</li>
<li>将其返回给instance的调用者。调用者对指针解引用以获得singleton，噢，一个还没有被构造出的对象。bug就出现了。</li>
</ol>
<p>DCLP能够良好的工作仅当步骤一和二在步骤三之前被执行，但是并没有并没有方法在C或C++中表达这种限制。这就像是插在DCLP心脏上的一把匕首：我们需要在相对指令顺序上定义限制，但是我们的语言没有给出表达这种限制的方法。</p>
<h1 id="5-memory-barrier指令"><a href="#5-memory-barrier指令" class="headerlink" title="5.memory barrier指令"></a>5.memory barrier指令</h1><p>DCLP问题在C++11中，这个问题得到了解决。</p>
<p>因为新的C++11规定了新的内存模型，保证了执行上述3个步骤的时候不会发生线程切换，相当这个初始化过程是“原子性”的的操作，DCL又可以正确使用了，不过在C++11下却有更简洁的多线程singleton写法了，这个留在后面再介绍。</p>
<p>C++11之前解决方法是barrier指令。要使其正确执行的话，就得在步骤2、3直接加上一道memory barrier。强迫CPU执行的时候按照1、2、3的步骤来运行。</p>
<p>第一种实现：</p>
<p>基于operator new + placement new，遵循1,2,3执行顺序依次编写代码。</p>
<pre><code>// method 1 operator new + placement new
singleton *instance() &#123;
    if (p == nullptr) &#123;
        lock_guard&lt;mutex&gt; guard(lock_);
        if (p == nullptr) &#123;
            singleton *tmp = static_cast&lt;singleton *&gt;(operator new(sizeof(singleton)));
            new(p)singleton();
            p = tmp;
        &#125;
    &#125;
    return p;
&#125;
</code></pre>
<p>第二种实现：</p>
<p>基于直接嵌入ASM汇编指令mfence，uninx的barrier宏也是通过该指令实现的。</p>
<pre><code>#define barrier() __asm__ volatile (&quot;lwsync&quot;)
singleton *singleton::instance() &#123;
    if (p == nullptr) &#123;
        lock_guard&lt;mutex&gt; guard(lock_);
        barrier();
        if (p == nullptr) &#123;
            p = new singleton();
        &#125;
    &#125;
    return p;
&#125;
</code></pre>
<p>通常情况下是调用cpu提供的一条指令，这条指令的作用是会阻止cpu将该指令之前的指令交换到该指令之后，这条指令也通常被叫做barrier。 </p>
<p>上面代码中的asm表示这个是一条汇编指令，volatile是可选的，如果用了它，则表示向编译器声明不允许对该汇编指令进行优化。lwsync是POWERPC提供的barrier指令。</p>
<h1 id="6-静态局部变量"><a href="#6-静态局部变量" class="headerlink" title="6.静态局部变量"></a>6.静态局部变量</h1><p>Scott Meyer在《Effective C++》中提出了一种简洁的singleton写法</p>
<pre><code>singleton *singleton::instance() &#123;
    static singleton p;
    return &amp;p;
&#125;
</code></pre>
<ul>
<li>单线程下，正确。</li>
<li>C++11及以后的版本（如C++14）的多线程下，正确。</li>
<li>C++11之前的多线程下，不一定正确。</li>
</ul>
<p>原因在于在C++11之前的标准中并没有规定local static变量的内存模型。于是乎它就是不是线程安全的了。但是在C++11却是线程安全的，这是因为新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它。</p>
<p>上述使用的内存序：</p>
<p>memory_order_relaxed：松散内存序，只用来保证对原子对象的操作是原子的<br>memory_order_acquire：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见<br>memory_order_release：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</p>
<h1 id="7-Atomic"><a href="#7-Atomic" class="headerlink" title="7.Atomic"></a>7.Atomic</h1><p>在C++11之前的版本下，除了通过锁实现线程安全的Singleton外，还可以利用各个编译器内置的atomic operation来实现。</p>
<p>java和c#发现乱序问题后，就加了一个关键字volatile，在声明p变量的时候，要加上volatile修饰，编译器看到之后，就知道这个地方不能够reorder（一定要先分配内存，在执行构造器，都完成之后再赋值）。</p>
<p>而对于c++标准却一直没有改正，所以VC++在2005版本也加入了这个关键字，但是这并不能够跨平台（只支持微软平台）。</p>
<p>而到了c++ 11版本，为了从根本上消除这些漏洞，引入了适合多线程的内存模型。终于有了这样的机制帮助我们实现跨平台的方案。</p>
<pre><code>mutex singleton::lock_;
atomic&lt;singleton *&gt; singleton::p;

/*
* std::atomic_thread_fence(std::memory_order_acquire); 
* std::atomic_thread_fence(std::memory_order_release);
* 这两句话可以保证他们之间的语句不会发生乱序执行。
*/
singleton *singleton::instance() &#123;
    singleton *tmp = p.load(memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    if (tmp == nullptr) &#123;
        lock_guard&lt;mutex&gt; guard(lock_);
        tmp = p.load(memory_order_relaxed);
        if (tmp == nullptr) &#123;
            tmp = new singleton();
            atomic_thread_fence(memory_order_release);
            p.store(tmp, memory_order_relaxed);
        &#125;
    &#125;
    return p;
&#125;
</code></pre>
<p>值得注意的是，上述代码使用两个比较关键的术语，获得与释放：</p>
<ul>
<li>获得是一个对内存的读操作，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去。</li>
<li>释放是一个对内存的写操作，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去。</li>
</ul>
<p>acquire 和 release 通常都是配对出现的，目的是保证如果对同一个原子对象的 release 发生在 acquire 之前的话，release 之前发生的内存修改能够被 acquire 之后的内存读取全部看到。</p>
<h1 id="8-pthread-once"><a href="#8-pthread-once" class="headerlink" title="8.pthread_once"></a>8.pthread_once</h1><p>如果是在unix平台的话，除了使用atomic operation外，在不适用C++11的情况下，还可以通过pthread_once来实现Singleton。</p>
<p>原型如下：</p>
<pre><code>int pthread_once(pthread_once_t once_control, void (init_routine) (void))；
</code></pre>
<p>实现：</p>
<pre><code>class singleton &#123;
private:
    singleton(); //私有构造函数，不允许使用者自己生成对象
    singleton(const singleton &amp;other);

    //要写成静态方法的原因：类成员函数隐含传递this指针（第一个参数）
    static void init() &#123;
        p = new singleton();
    &#125;

    static pthread_once_t ponce_;
    static singleton *p; //静态成员变量 
public:
    singleton *instance() &#123;
        // init函数只会执行一次
        pthread_once(&amp;ponce_, &amp;singleton::init);
        return p;
    &#125;
&#125;;
</code></pre>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>本文讲解了几种单例模式，并讲解了线程安全的单例模式，以及不用C++11实现的几种线程安全的单例模式：memory barrier，静态局部变量，pthread_once方式，C++11的atomic实现等。</p>
<p>最后值得注意的是，针对上述单例类的析构函数请参考双重锁检查模式+自动回收实现，必须在类中声明一个静态局部变量，静态局部变量可以理解为全局变量，在程序结束时，自动调用该静态局部变量的析构函数，这就是为什么要在类中声明与定义嵌套类，而不是直接编写单例的析构函数。</p>
<p>本文参考：<a href="https://light-city.club/sc/design_pattern/singleton/singleton/">C++那些事-&gt;设计模式-&gt;单例模式</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C++的RAII机制</title>
    <url>/2020/11/08/%E6%B5%85%E8%B0%88C-%E7%9A%84RAII%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-资源与内存分配"><a href="#1-资源与内存分配" class="headerlink" title="1.资源与内存分配"></a>1.资源与内存分配</h1><p>资源的概念:资源是数量有限且对系统正常运转具有一定作用的元素。比如，内存，文件句柄，网络套接字（network sockets），互斥锁（mutex locks）等等<br>对于进程，这些资源都作为某种数据结构存储在内存中。<br>程序运行需要分配内存来管理以上资源，内存分配可以分为三类：</p>
<ul>
<li>静态分配：如创建一个进程执行某段代码，需要加载该代码的代码段，数据段等数据到内存中，其中数据段包含已初始化的全局数据，可以称为是静态的内存分配</li>
<li>自动分配：进程内函数的调用和返回，以及其内部的局部变量创建和销毁，对应该进程高地址的入栈出栈，这个是操作系统自动处理的，无需应用程序控制</li>
<li>动态分配：静态数据和堆栈之前的空间（称为堆），可由应用程序动态分配，同时，也必须由应用程序释放。所谓的内存的动态分配与释放，通常讨论的是这种情况</li>
</ul>
<p>以32位Linux环境的应用程序为例，每个进程可见的（虚拟）内存分布如下，C&#x2F;C++常用的malloc&#x2F;free, new&#x2F;delete对应的内存分配释放都在.heap段内<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081658341.png" alt="image-20221208165846274"></p>
<h1 id="2-动态内存管理的缺陷"><a href="#2-动态内存管理的缺陷" class="headerlink" title="2.动态内存管理的缺陷"></a>2.动态内存管理的缺陷</h1><p>我们在使用资源时必须严格遵循的步骤是：</p>
<ol>
<li>获取资源</li>
<li>使用资源</li>
<li>释放资源</li>
</ol>
<p>代码形式：</p>
<pre><code>void UseResources()    
&#123;  
    // 获取资源1  
    // ...  
    // 获取资源n  
     
    // 使用这些资源  
     
    // 释放资源n  
    // ...  
    // 释放资源1  
&#125; 
</code></pre>
<p>当代码量和复杂度达到一定程度，这种手动资源管理容易出错，且难以避免<br>例如C++使用new和delete时可能发生的一些错误是：</p>
<ul>
<li>内存泄漏：例如，使用new分配对象，而忘记删除该对象，打开文件，忘记关闭文件等等</li>
<li>过早删除（或悬挂引用）：持有指向对象的另一个指针，删除该对象，但是还有其他指针在引用它。</li>
<li>双重删除：尝试两次删除一个对象</li>
</ul>
<h1 id="3-RAII：将资源管理交给系统"><a href="#3-RAII：将资源管理交给系统" class="headerlink" title="3.RAII：将资源管理交给系统"></a>3.RAII：将资源管理交给系统</h1><ul>
<li>自动内存管理，局部变量能在调用函数时分配，退出函数时释放</li>
<li>类是 C++ 中的主要抽象工具，将资源抽象为类，用局部对象来表示资源，把管理资源的任务转化为管理局部对象的任务</li>
</ul>
<p>RAII 就是基于以上思想，折中了全手动和全自动的内存管理，手动的选择管理哪些资源，自动的分配和释放资源。有效地实现了 C++ 资源管理的自动化</p>
<p>RAII（Resource Acquisition Is Initialization, 资源获取即初始化）:<br>是80年代，Bjarne Stroustrup为C++发明了的范例。<br>具体实现方法：将资源的声明周期，绑定到对象的生命周期，即将资源分配和释放操作，包含到指定对象的构造函数和析构函数中，这些构造函数和析构函数在适当的时候由编译器自动调用，资源数据包含到对象的成员中。</p>
<p>一个简单示例：</p>
<p>（1）常规内存管理</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std; 
int main() 
&#123; 
    int *testArray = new int [10]; 
    // Here, you can use the array 
    delete [] testArray; 
    testArray = NULL ; 
    return 0; 
&#125;
</code></pre>
<p>（2）RAII方式</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std; 

class ArrayOperation 
&#123; 
public : 
    ArrayOperation() 
    &#123; 
        m_Array = new int [10]; //构造函数包含资源的分配
    &#125; 
 
    void InitArray()  //使用资源
    &#123; 
        for (int i = 0; i &lt; 10; ++i) 
        &#123; 
            *(m_Array + i) = i; 
        &#125; 
    &#125; 
 
    void ShowArray() //使用资源
    &#123; 
        for (int i = 0; i &lt;10; ++i) 
        &#123; 
            cout&lt;&lt;m_Array[i]&lt;&lt;endl; 
        &#125; 
    &#125; 
 
    ~ArrayOperation()  //析构函数包含资源的释放
    &#123; 
        cout&lt;&lt; &quot;~ArrayOperation is called&quot; &lt;&lt;endl; 
        if (m_Array != NULL ) 
        &#123; 
            delete[] m_Array;  
            m_Array = NULL ; 
        &#125; 
    &#125; 
 
private : 
    int *m_Array;  //成员变量包含资源
&#125;; 
 
int main() 
&#123; 
    ArrayOperation arrayOp; //资源自动分配
    arrayOp.InitArray(); 
    arrayOp.ShowArray(); 
    return 0;           //资源自动释放
&#125;
</code></pre>
<p>根据RAII对资源的所有权控制，分为常性类型和外部初始化类型<br>上述示例即为常性类型，也是最纯粹的RAII形式，最容易理解，最容易编码。获取资源的地点是构造函数，释放点是析构函数，并且在这两点之间的一段时间里，任何对该RAII类型实例的操纵都不应该从它手里夺走资源的所有权<br>外部初始化类型是指资源在外部被创建，并被传给RAII实例的构造函数，后者进而接管了其所有权。boost::shared_ptr&lt;&gt;和std::auto_ptr&lt;&gt;都是此类型</p>
<h1 id="4-RAII的应用场景"><a href="#4-RAII的应用场景" class="headerlink" title="4.RAII的应用场景"></a>4.RAII的应用场景</h1><p>常见的应用有：</p>
<ul>
<li>文件操作</li>
<li>智能指针</li>
<li>互斥量</li>
</ul>
<h2 id="4-1文件操作"><a href="#4-1文件操作" class="headerlink" title="4.1文件操作"></a>4.1文件操作</h2><p>（1）常规形式</p>
<pre><code>void UseFile(char const* fn)  
&#123;  
    FILE* f = fopen(fn, &quot;r&quot;);        // 获取资源  
    // 在此处使用文件句柄f...代码          // 使用资源  
    fclose(f);                       // 释放资源  
&#125;  
</code></pre>
<p>（2）RAII<br>文件类：</p>
<pre><code>class FileHandle &#123;  
public:  
    FileHandle(char const* n, char const* a) &#123; p = fopen(n, a); &#125; 
    ~FileHandle() &#123; fclose(p); &#125;  
private:   
    FileHandle(FileHandle const&amp;);  
    FileHandle&amp; operator= (FileHandle const&amp;); // 禁止拷贝操作  
    FILE *p;  
&#125;; 
</code></pre>
<p> FileHandle 类的构造函数调用 fopen() 获取资源；FileHandle类的析构函数调用 fclose()释放资源。请注意，考虑到FileHandle对象代表一种资源，它并不具有拷贝语义，因此将拷贝构造函数和赋值运算符声明为私有成员<br> 使用：</p>
<pre><code>void UseFile(char const* fn)  
&#123;  
    FileHandle file(fn, &quot;r&quot;);  
    // 在此处使用文件句柄  
    // 超出此作用域时，系统会自动调用file的析构函数，从而释放资源
&#125;  
</code></pre>
<h2 id="4-2互斥量"><a href="#4-2互斥量" class="headerlink" title="4.2互斥量"></a>4.2互斥量</h2><p>C++标准库提供lock_guard类实现mutex分配与释放，其实现就是RAII方式。</p>
<pre><code>template&lt;class... _Mutexes&gt;
    class lock_guard
    &#123;    // class with destructor that unlocks mutexes
public:
    explicit lock_guard(_Mutexes&amp;... _Mtxes)
        : _MyMutexes(_Mtxes...)
        &#123;    // construct and lock
        _STD lock(_Mtxes...);
        &#125;
 
    lock_guard(_Mutexes&amp;... _Mtxes, adopt_lock_t)
        : _MyMutexes(_Mtxes...)
        &#123;    // construct but don&#39;t lock
        &#125;
 
    ~lock_guard() _NOEXCEPT
        &#123;    // unlock all
        _For_each_tuple_element(
            _MyMutexes,
            [](auto&amp; _Mutex) _NOEXCEPT &#123; _Mutex.unlock(); &#125;);
        &#125;
 
    lock_guard(const lock_guard&amp;) = delete;
    lock_guard&amp; operator=(const lock_guard&amp;) = delete;
private:
    tuple&lt;_Mutexes&amp;...&gt; _MyMutexes;
    &#125;;
</code></pre>
<p>使用多线程时，经常会涉及到共享数据的问题，C++中通过实例化std::mutex创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。不过这意味着必须记住在每个函数出口都要去调用unlock()，也包括异常的情况，这非常麻烦，而且不易管理。C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，其会在构造函数的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。上面的代码属于mutex头文件</p>
<h2 id="4-3智能指针"><a href="#4-3智能指针" class="headerlink" title="4.3智能指针"></a>4.3智能指针</h2><p>先看一个例子，用RAII管理指针</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;fstream&gt;
using namespace std;

enum class shape_type &#123;
    circle,
    rectangle,
&#125;;

class shape &#123;
public:
    shape() &#123; cout &lt;&lt; &quot;shape&quot; &lt;&lt; endl; &#125;
    virtual void print() &#123;
        cout &lt;&lt; &quot;I am shape&quot; &lt;&lt; endl;
    &#125;
    virtual ~shape() &#123;&#125;
&#125;;

class circle : public shape &#123;
public:
    circle() &#123; cout &lt;&lt; &quot;circle&quot; &lt;&lt; endl; &#125;
    void print() &#123;
        cout &lt;&lt; &quot;I am circle&quot; &lt;&lt; endl;
    &#125;
&#125;;

class rectangle : public shape &#123;
public:
    rectangle() &#123; cout &lt;&lt; &quot;rectangle&quot; &lt;&lt; endl; &#125;
    void print() &#123;
        cout &lt;&lt; &quot;I am rectangle&quot; &lt;&lt; endl;
    &#125;
&#125;;

// 利用多态上转,如果返回值为shape,会存在对象切片问题。
shape *create_shape(shape_type type) &#123;
    switch (type) &#123;
        case shape_type::circle:
            return new circle();
        case shape_type::rectangle:
            return new rectangle();
    &#125;
&#125;

class shape_wrapper &#123;
public:
    explicit shape_wrapper(shape *ptr = nullptr) : ptr_(ptr) &#123;&#125;

    ~shape_wrapper() &#123;
        delete ptr_;
    &#125;

    shape *get() const &#123;
        return ptr_;
    &#125;

private:
    shape *ptr_;
&#125;;
</code></pre>
<p>​<br>​<br>    int main() {</p>
<pre><code>    // 第一种方式, 手动管理指针
    shape *sp = create_shape(shape_type::circle);
    sp-&gt;print();
    delete sp; //显式delete

    // 第二种方式， RAII管理指针，一般封装到函数，更快释放
    shape_wrapper ptr(create_shape(shape_type::circle));
    ptr.get()-&gt;print();

    return 0;
&#125;
</code></pre>
<p>C++标准库的智能指针：auto_ptr(C++11弃用), unique_ptr,shared_ptr, weak_ptr<br>可以参考<a href="https://www.cnblogs.com/WindSun/p/11444429.html">WindSun:详解C++11智能指针</a></p>
<h2 id="4-4实现自己的RAII类"><a href="#4-4实现自己的RAII类" class="headerlink" title="4.4实现自己的RAII类"></a>4.4实现自己的RAII类</h2><p>一般情况下，RAII临时对象不允许复制和赋值，当然更不允许在heap上创建，所以先写下一个RAII的base类，使子类私有继承Base类来禁用这些操作：</p>
<pre><code>class RAIIBase  
&#123;  
public:  
    RAIIBase()&#123;&#125;  
    ~RAIIBase()&#123;&#125;//由于不能使用该类的指针，定义虚函数是完全没有必要的  
      
    RAIIBase (const RAIIBase &amp;);  
    RAIIBase &amp; operator = (const RAIIBase &amp;);  
    void * operator new(size_t size);   
    // 不定义任何成员  
&#125;;
</code></pre>
<p>要写自己的RAII类时就可以直接继承该类的实现</p>
<pre><code>template&lt;typename T&gt;  
class ResourceHandle: private RAIIBase //私有继承 禁用Base的所有继承操作  
&#123;  
public:  
    explicit ResourceHandle(T * aResource):r_(aResource)&#123;&#125;//获取资源  
    ~ResourceHandle() &#123;delete r_;&#125; //释放资源  
    T *get()    &#123;return r_ ;&#125; //访问资源  
private:  
    T * r_;  
&#125;;
</code></pre>
<p>将Handle类做成模板类，这样就可以将class类型放入其中。另外，ResourceHandle可以根据不同资源类型的释放形式来定义不同的析构函数。由于不能使用该类的指针，所以不使用虚函数。</p>
<h1 id="5-GC和RAII"><a href="#5-GC和RAII" class="headerlink" title="5.GC和RAII"></a>5.GC和RAII</h1><p>在没有RAII的时代，GC和非GC语言是水火不容，GC追求开发效率和稳健设计，非GC如C++最求极致性能和绝对控制。RAII的设计机制，兼顾了两者的优点。<br>如果用三个等级代表程序员对系统资源的使用权限，如下：</p>
<ul>
<li>动态分配：C++的new&#x2F;delete之类，程序员100%负责内存使用和释放，编译器、操作系统不额外干预</li>
<li>垃圾回收(GC)：java&#x2F;go语言之类，程序员只负责要内存，而不用管，也管不了内存释放，其由该语言运行环境管理，规则可以描述成：如果一个资源没被任何对象使用(例如没有指针指向它)，运行环境定时或者其他方式检测到后，自动释放该资源，该过程对程序员不可控。可以说程序员有50%的权限，即想要就能要，但想甩却不能甩</li>
<li>RAII：程序员负责资源编排，运行时的分配与释放由系统自动完成，可以说程序员有90%的权限，放权10%给系统</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>RAII的本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来，从而确保在对象的生存期内资源始终有效，对象销毁时资源必被释放。换句话说，拥有对象就等于拥有资源，对象存在则资源必定存在。<br>具体实现：</p>
<ul>
<li>资源在构造函数中获取</li>
<li>资源在析构函数中释放</li>
<li>资源是类的成员变量</li>
<li>类的实例是堆栈分配的</li>
</ul>
<p>相关文章<br><a href="https://light-city.club/sc/codingStyleIdioms/RAII/">C++那些事：RAII</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的函数指针</title>
    <url>/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="1-函数指针基本概念"><a href="#1-函数指针基本概念" class="headerlink" title="1. 函数指针基本概念"></a>1. 函数指针基本概念</h2><p>C语言调用函数的本质是什么？</p>
<ol>
<li>CPU PC指针(program counter)跳转到函数的入口地址，传入参数，传入返回位置</li>
<li>在函数栈内生成临时变量并执行函数内容指令，执行完毕后返回参数</li>
<li>CPU返回原调用处执行</li>
</ol>
<p>这里，函数的入口地址实际上就存储在函数名中，也就是说，C代码中的函数名就是函数的入口地址。<br>既然是地址，就可以用来初始化一个指针，使指针指向该地址。<br>函数指针，就是存放函数首地址的指针。</p>
<h3 id="1-2-函数指针变量"><a href="#1-2-函数指针变量" class="headerlink" title="1.2 函数指针变量"></a>1.2 函数指针变量</h3><p>首先声明普通函数是如下格式：<br><code>void Func(int);</code><br>定义一个同类型函数的函数指针变量，只需要用<code>*p</code>表示函数名即可：<br><code>void (*p)(int);</code><br>注意，上面是定义了函数指针变量，而不是声明函数指针类型。</p>
<p>函数指针变量的定义，和普通变量格式不一样。</p>
<ul>
<li>普通变量： &lt;类型&gt; &lt;变量名&gt;</li>
<li>函数指针：&lt;函数类型 变量名&gt;，按函数声明的格式定义，变量是包含在类型内部</li>
</ul>
<p>那么此函数指针的类型是什么：<br><code>void (*)(int);</code></p>
<p>怎么使用此函数指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Func(int x) // 声明一个函数*/</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line">void (*p)(int); // 定义一个函数指针*/</span><br><span class="line">p = Func; // 将Func函数的首地址赋给函数指针变量p*/</span><br><span class="line">(*p)(100);  // 通过函数指针调用Func函数</span><br></pre></td></tr></table></figure>

<h3 id="1-3-函数指针类型"><a href="#1-3-函数指针类型" class="headerlink" title="1.3 函数指针类型"></a>1.3 函数指针类型</h3><p>typedef可以定义某种类型的别名，例如将unsigned char定义为u8<br><code>typedef unsigned char u8;</code><br>可见其格式是：typedef &lt;原类型&gt; &lt;别名类型&gt;</p>
<p>那么如何定义函数指针类型：<br>只需要在函数指针声明的格式前加typedef, p就定义为函数指针类型而不是变量:<br><code>typedef void (*p)(int);</code></p>
<p>这里定义了<code>void (*)(int)</code>类型的函数指针类型，其别名为p</p>
<p>怎么使用此函数指针类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义类型</span><br><span class="line">typedef void (*pFuncType)(int); </span><br><span class="line">//定义变量  </span><br><span class="line">pFuncType p;   </span><br><span class="line"></span><br><span class="line">void Func(int x)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%d&quot;,x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main()   </span><br><span class="line">&#123;   </span><br><span class="line">    p = Func; //初始化变量   </span><br><span class="line">    (*p)(100);   //使用变量</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-函数指针的应用"><a href="#2-函数指针的应用" class="headerlink" title="2. 函数指针的应用"></a>2. 函数指针的应用</h2><h3 id="2-1-Linux驱动软件设计的分层"><a href="#2-1-Linux驱动软件设计的分层" class="headerlink" title="2.1 Linux驱动软件设计的分层"></a>2.1 Linux驱动软件设计的分层</h3><p>C++中有多态的概念，父类定义某种函数类型，子类实现具体的函数内容，之后父类对象就可以调用子类的实现内容。<br>这样实现“父类定义格式，子类实现细节”的软件分层设计。</p>
<p>Linux驱动中也大量使用这种分层设计，C使用结构体和函数指针，分别对应C++的类和方法。<br>例如某驱动模块，顶层框架定义open, read, write, 而底层驱动根据具体硬件，实现xxx_open, xxx_read, xxx_write，然后按结构体成员赋值实现上下层联通：</p>
<p>以s3c的SDHCI驱动为例：<br>sdhci_ops即父类框架结构体，sdhci_s3c_ops为s3c芯片的具体实现结构体。<br><code>.set_clock = sdhci_s3c_set_clock</code>就实现了父类的set_clock方法被子类sdhci_s3c_set_clock实现的效果。<br>其本质是函数指针的赋值，父类和子类的函数名都指向同一个函数地址，所以父类可以通过调用set_clock来实现调用sdhci_s3c_set_clock的效果。<br>这样，父类设计者根本不关心底层用什么函数名实现set_clock的功能，只需要调用set_clock这个函数名即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct sdhci_ops sdhci_s3c_ops = &#123;</span><br><span class="line">	.get_max_clock		= sdhci_s3c_get_max_clk,</span><br><span class="line">	.set_clock		= sdhci_s3c_set_clock,</span><br><span class="line">	.get_min_clock		= sdhci_s3c_get_min_clock,</span><br><span class="line">	.set_bus_width		= sdhci_set_bus_width,</span><br><span class="line">	.reset			= sdhci_reset,</span><br><span class="line">	.set_uhs_signaling	= sdhci_set_uhs_signaling,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数指针实现指令跳转"><a href="#2-2-函数指针实现指令跳转" class="headerlink" title="2.2 函数指针实现指令跳转"></a>2.2 函数指针实现指令跳转</h3><p>调用一个函数，其内部就包含跳转操作(jump指令)<br>那么，如何用C语言实现跳转到某个绝对地址去执行？具体场景：<br>在Bootloader过程中，加载完kernel到RAM后，要跳转到kernel首地址开始执行，如何实现？</p>
<p>方案一：C嵌入汇编<br>以下是基于SPARC CPU的汇编，跳转到0x40000000, 即RAM首地址执行firmware.<br>对于其他CPU，汇编实现也不同，因此此方法不能跨平台。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void boot_exit()</span><br><span class="line">&#123;</span><br><span class="line">    /* jump to RAM entry to execute firmware. */</span><br><span class="line"></span><br><span class="line">    asm(</span><br><span class="line">        &quot;set 0x40000000, %g2\n&quot;</span><br><span class="line">        &quot;jmp %g2\n&quot;</span><br><span class="line">        &quot;nop&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：函数指针<br>Bootloader中很常用的一种跳转方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef void (*pFuncType)(); //定义无入参无返回类型的函数指针类型</span><br><span class="line">pFuncType Reset = (pFuncType)0xF000FFF0; //函数指针指向待跳转地址</span><br><span class="line">Reset(); //调用函数，实际上执行了跳转</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的宏函数</title>
    <url>/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="1-连接操作符"><a href="#1-连接操作符" class="headerlink" title="1. 连接操作符:##"></a>1. 连接操作符:##</h1><pre><code>#define Conn(x,y) x##y
</code></pre>
<p><code>##</code> 表示连接 , <code>x##y</code> 表示x连接y</p>
<p>示例：</p>
<pre><code>int n = Conn(123,456);
     ==&gt; int n=123456;
char* str = Conn(&quot;asdf&quot;, &quot;adf&quot;);
     ==&gt; char* str = &quot;asdfadf&quot;;
</code></pre>
<p><code>##</code> 的左右符号必须能够组成一个有意义的符号，否则预处理器会报错</p>
<h1 id="2-字符串化和字符化"><a href="#2-字符串化和字符化" class="headerlink" title="2.字符串化和字符化: #, #@"></a>2.字符串化和字符化: #, #@</h1><p>(1) # 把任意类型的宏入参转化成字符串：</p>
<pre><code>#define ToString(x) #x
</code></pre>
<p>符号 # 表示字符串化操作符（stringification）。<br>其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。<br>其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</p>
<p>示例：</p>
<pre><code> char* str = ToString(123132);
 ==&gt; char* str=&quot;123132&quot;;
</code></pre>
<p>如果要对展开后的宏参数进行字符串化，则需要使用两层宏。</p>
<pre><code>#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
     ==&gt; &quot;foo&quot;
xstr (foo)
     ==&gt; xstr (4)
     ==&gt; str (4)
     ==&gt; &quot;4&quot;
</code></pre>
<p>(2) #@ 把任意类型的宏入参转化成单字符：</p>
<pre><code>#define ToChar(x) #@x
</code></pre>
<p>示例：</p>
<pre><code>char a = ToChar(1);
     ==&gt; char a=&#39;1&#39;
</code></pre>
<h1 id="3-不定参数宏-VA-ARGS"><a href="#3-不定参数宏-VA-ARGS" class="headerlink" title="3. 不定参数宏: __VA_ARGS__"></a>3. 不定参数宏: <code>__VA_ARGS__</code></h1><p><code>__VA_ARGS__</code>宏用来接受不定数量的参数。例如：</p>
<pre><code>#define eprintf(...) fprintf (stderr, __VA_ARGS__)

eprintf (&quot;%s:%d: &quot;, input_file, lineno)
==&gt;  fprintf (stderr, &quot;%s:%d: &quot;, input_file, lineno)
</code></pre>
<p>当<code>__VA_ARGS__</code>宏前面加 <code>##</code> 时，可以省略参数输入。<br>例如：</p>
<pre><code>#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

eprintf (&quot;success!\n&quot;)
==&gt; fprintf(stderr, &quot;success!\n&quot;);
</code></pre>
<h1 id="4-宏函数定义-do-while-0-与换行"><a href="#4-宏函数定义-do-while-0-与换行" class="headerlink" title="4. 宏函数定义: do-while(0)与换行"></a>4. 宏函数定义: do-while(0)与换行</h1><p>(1) 用 do{}while(0) 定义宏函数</p>
<pre><code>#define foo() do&#123;...&#125;while(0)
</code></pre>
<p>宏函数可能在任意地方被调用，如果在if-else语句中，为了确保宏函数作为整体单元被编译器替换后不产生歧义，一般用do-while(0)包起来定义<br>这种定义有点像其他语言的“闭包函数”，纯粹是C语言中为了避免语法歧义的可靠性定义。</p>
<p>(2) 用显式换行符</p>
<p>宏函数定义不能直接回车换行，需要在回车换行前，用\（反斜线）表示下一行继续此宏的定义<br>预处理器在编译之前会自动将\与换行回车去掉。</p>
<p>例如：</p>
<pre><code>#define PRINT_INT(a)    \
do&#123;                     \
    printf(&quot;%d \n&quot;, a); \
&#125;while(0)
</code></pre>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的结构体与面向对象</title>
    <url>/2020/02/29/%E6%B5%85%E8%B0%88C%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>结构体（Struct）：存放一组不同类型的数据的数据结构。<br>数组（Array）：存放一组相同类型的数据的数据结构。<br>结构体和int,char，指针等基础数据类型一样，也是一种数据类型。格式定义如下：</p>
<pre><code>struct 结构体名&#123;
    成员类型1 成员名1;
    成员类型2 成员名2；
&#125;实例1，实例2;
</code></pre>
<p>结构体的成员（Member）可以为任意类型，如int,char，指针，甚至结构体类型。<br>结构体可以配合结构体数组、普通指针、函数指针、以及自身嵌套的使用方法，实现复杂数据结构，以及面向对象的代码风格。</p>
<h1 id="1-结构体声明"><a href="#1-结构体声明" class="headerlink" title="1.结构体声明"></a>1.结构体声明</h1><p>声明是告诉编译器某个数据结构的定义。一般在头文件对结构体、函数等类型声明。声明过程不分配内存。<br>一个结构体类型的声明：</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125;;
</code></pre>
<p>注意：<br>1.结构体声明类似于函数声明，是一个语句，末尾加；<br>2.结构体声明只声明了类型，不实例化变量，因此不分配内存。<br>3.结构体成员的变量只在实例结构体才分配内存。</p>
<h1 id="2-结构体实例"><a href="#2-结构体实例" class="headerlink" title="2.结构体实例"></a>2.结构体实例</h1><h2 id="2-1基础方法"><a href="#2-1基础方法" class="headerlink" title="2.1基础方法"></a>2.1基础方法</h2><p>结构体变量是结构体类型的实例，实例化就是在内存分配一个结构体类型的变量空间。<br>方法一：先声明结构体类型stu，再实例变量stu1,stu2。<br>该方法结构体类型声明和实例化分离。声明一次，到处实例化。注意实例变量要带struct关键字。</p>
<pre><code>struct stu stu1, stu2;
</code></pre>
<p>方法二：声明的时候也实例变量stu1,stu2。</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<p>方法三：不声明接头体名，直接实例变量。<br>适用于只需要 stu1、stu2两个变量，后面不需要再使用结构体名定义其他变量的情况</p>
<pre><code>struct&#123;             //没有写stu
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<h2 id="2-2重定义方法"><a href="#2-2重定义方法" class="headerlink" title="2.2重定义方法"></a>2.2重定义方法</h2><p>结构体类型通常配合typedef重定义后声明。<br>声明一次，到处实例化。不需要带struct关键字。</p>
<pre><code>    typedef struct stu&#123; //stu可省略
        char *name;     //姓名
        int num;        //学号
        int age;        //年龄
        char group;     //所在小组
        float score;    //成绩
    &#125;stu_t, *stu_p;    //声明stu_t为stu类型，stu_p为stu类型的指针
</code></pre>
<p>实例变量：</p>
<pre><code>stu_t stu1,stu2;    //实例两个stu结构体变量
stu_p *stu1_p, *stu2_p; //实例两个指向stu结构体指针
stu1_p = &amp;stu1; //指向实例stu1
stu2_p = &amp;stu2; //指向实例stu2
</code></pre>
<h1 id="3-结构体初始化"><a href="#3-结构体初始化" class="headerlink" title="3.结构体初始化"></a>3.结构体初始化</h1><p>初始化&#x3D;赋初始值。<br>结构体的实例只分配了内存，其成员的值要手动赋值后才能确定。否则直接拿来用会得到不确定的值（取决于分配到的内存原本的值）。<br>以重定义的结构体类型stu_t为例，实例变量时顺便初始化所有成员为0：</p>
<pre><code>stu_t stu1,stu2 = &#123;0&#125;;
</code></pre>
<p>有的编译器可能要求这种写法：</p>
<pre><code>stu_t stu1,stu2 = &#123;&#123;0&#125;&#125;;
</code></pre>
<p>如果各成员有默认初始值，初始化如下：</p>
<pre><code>stu_t stu1, stu2 = &#123; &quot;Tom&quot;, 9527, 18, &#39;A&#39;, 136.5 &#125;;
</code></pre>
<h1 id="4-结构体的赋值"><a href="#4-结构体的赋值" class="headerlink" title="4.结构体的赋值"></a>4.结构体的赋值</h1><p>结构体赋值是对结构体变量内的成员赋值。<br>两种方式访问成员：</p>
<pre><code>结构体变量.成员名;
stu1.name = &#39;Tom&#39;;
结构体指针-&gt;成员名
stu1_p-&gt;name = &#39;Tom&#39;;
</code></pre>
<p>这两种方法的选择取决于使用情况。如果结构体作为参数在函数之间频繁传递和赋值，建议使用传指针，而不是传结构体变量，这样减少函数为结构体频繁分配局部内存，但要注意结构体已被释放，形成空指针的判断。<br>注意是对实例的成员赋值（已分配内存），而不能对结构体类型的成员赋值（只是个标签）。例如如下操作是错误的：</p>
<pre><code>stu_t.name = &quot;Tom&quot;  //错，stu_t是类型
stu1_p = &amp;stu_t     //错，stu_t没地址
</code></pre>
<p>可以对结构体类型进行sizeof操作，而不需要分配内存。</p>
<pre><code>sizeof(stu_t);      //获取结构体（将）占用的内存空间
</code></pre>
<h1 id="5-结构体的内存分配"><a href="#5-结构体的内存分配" class="headerlink" title="5.结构体的内存分配"></a>5.结构体的内存分配</h1><p><strong>理论上</strong>结构体的内存占用是成员占用的和。各成员在内存中连续存储的，和数组非常类似，例如结构体变量 stu1、stu2的内存分布如下，共占用 4+4+4+1+4&#x3D;17字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061515193.jpeg" alt="1"><br>但实际上，编译器会遵循<strong>内存对齐</strong>规则。实际内存占用大于各成员占用的和。如下图，stu1、stu2 其实占用了 17+3&#x3D;20 字节<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516336.jpeg" alt="2"></p>
<h2 id="5-1内存对齐概述"><a href="#5-1内存对齐概述" class="headerlink" title="5.1内存对齐概述"></a>5.1内存对齐概述</h2><p>1.CPU怎么访问内存中的数据最高效？<br>答：用最少的访问次数，获取该数据所在的内存空间的值。<br>2.怎么做到对某类型数据的最少访问？<br>答：编译器设置数据的存放地址的单位为数据占用空间的长度，CPU以数据长度为单位查询偏移地址，找到数据空间首地址后，根据数据类型取出其占用空间大小的数据。<br>如int数据，就存放在以4字节为单位的偏移地址，如0，4，8…,CPU取数据就按0，4，8…的地址查询，找到该数据地址后取4字节。这样做到一次性访问获取int数据。如果CPU按单字节访问int,就要查询4次，如int首字节地址为0x00001024, CPU要分4次查询0x00001024~0x00001027才能得到一个int。<br>3.对于结构体，包含多种数据类型，怎么对齐？<br>答：各成员按各自的类型对齐，即对于成员来说不存在结构体的概念，它认为它就是基本的数据类型int、char、指针等。</p>
<h2 id="5-2结构体与内存对齐"><a href="#5-2结构体与内存对齐" class="headerlink" title="5.2结构体与内存对齐"></a>5.2结构体与内存对齐</h2><p>结构体是不同类型数据的集合，因此内存对齐问题就特别突出。一个例子：</p>
<pre><code>#include &quot;stdio.h&quot;
typedef struct &#123;
    int a;
    double b;
    char c;
&#125;A; 

typedef struct &#123;
    int a;
    char b;
    double c;
&#125;B;

int main()
&#123;
    printf(&quot;sizeof A: %d, sizeof B: %d\n&quot;, sizeof(A), sizeof(B));
&#125;
</code></pre>
<p>A和B的内存占用：A&#x3D;24字节，B&#x3D;16字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516111.png" alt="3"><br>结构体内存对齐的计算规则：<br>1.默认首地址已对齐（或认为是0地址)<br>2.各成员按自己的类型对齐<br>3.整个结构体分配的空间是期中最大成员占用空间的整数倍<br>对于A：<br>int a占用4字节，地址byte[0<del>3]<br>double b占8字节，起始地址必须是8的倍数，占用byte[7</del>15]<br>char c占1字节，因此占byte[16]<br>目前共占用17字节。编译器会按照规则3，将byte[17~13]也分配给结构体，因此最终结构体占用3<em>8&#x3D;24字节。<br>对于B, int a和char b加起来都不够8字节，double c再占用8字节，共占用2</em>8&#x3D;16字节。<br>因此<strong>结构体的内存分配&#x3D;各成员按类型对齐+总空间是最大成员空间的倍数</strong><br>注意，结构体不仅成员间要对齐，最后一个成员后面的空余空间可能也分配给结构体。<br>查看下面的测试程序：</p>
<pre><code>typedef struct &#123;
    int a;
    double b;
    char c;
    char d;         //d作为成员
&#125;C;

typedef struct &#123;
    int a;
    double b;
    char c;
    struct &#123;        //d作为嵌套结构体的成员
        char d; 
    &#125;;
&#125;D;

printf(&quot;sizeof C: %d, sizeof D: %d\n&quot;, sizeof(C), sizeof(D));
</code></pre>
<p>C和D的内存占用：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517211.png" alt="4"><br>新增的char d作为C的成员被分配在第三个8byte区域的第二个字节（byte[17])，嵌套的结构体并不从第四个8byte开始分配，它占用空间还是byte[17]。可见编译器对结构体内存分配不区分成员类型，只根据成员大小来处理。</p>
<h1 id="6-联合、位域、枚举"><a href="#6-联合、位域、枚举" class="headerlink" title="6.联合、位域、枚举"></a>6.联合、位域、枚举</h1><p>这几种数据结构体和结构体相关联，通常混合使用。</p>
<h2 id="6-1联合"><a href="#6-1联合" class="headerlink" title="6.1联合"></a>6.1联合</h2><p>联合(Union)也称共用体，和结构体的区别：<br>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。<br>声明格式：</p>
<pre><code>union 共用体名&#123;
    成员列表
&#125;;
</code></pre>
<p>共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>联合的一个示例：</p>
<pre><code>#include &lt;stdio.h&gt;
union data&#123;
    int n;
    char ch;
    short m;
&#125;;
int main()&#123;
    union data a;
    printf(&quot;%d, %d\n&quot;, sizeof(a), sizeof(union data) );
    a.n = 0x40;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.ch = &#39;9&#39;;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.m = 0x2059;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.n = 0x3E25AD54;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>4, 4
40, @, 40
39, 9, 39
2059, Y, 2059
3E25AD54, T, AD54
</code></pre>
<p>在内存中数据分布如下（以大端，低字节存高位为例）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517262.jpeg" alt="5"><br>可见数据会相互覆盖，联合可以理解为分时复用的结构体，其空间占用定长，为最大的成员长度，在不同时间，值的含义不同。</p>
<h2 id="6-2位域"><a href="#6-2位域" class="headerlink" title="6.2位域"></a>6.2位域</h2><p>有的结构体成员在存储时并不占用一个完整的字节，只需要按二进制位为单位分配空间即可。可以指定该成员所占用的二进制位数（Bit），这就是位域。</p>
<pre><code>#include &quot;stdio.h&quot;
struct &#123;
        unsigned char a;    //a占完整的8bit
        unsigned char b: 2; //b占2bit
        unsigned char c: 6; //C占6bit
&#125;bs;

int main()
&#123;
    printf(&quot;sizeof bs: %d\n&quot;, sizeof(bs));
&#125;
</code></pre>
<p>输出2字节，可见b和c刚好拼成一个unsigned char(8 bit)：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517807.png" alt="6"><br>位域将结构体成员占用的空间从基本数据类型为单位，变成了以二进制位为单位，是更精细的结构体内存分配。<br>位域不能超过对应基本类型的二进制位数。</p>
<h2 id="6-3枚举"><a href="#6-3枚举" class="headerlink" title="6.3枚举"></a>6.3枚举</h2><p>枚举可以理解为计数宏的结构体。</p>
<pre><code>#include &lt;stdio.h&gt;
int main()&#123;
    enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125; day;
    scanf(&quot;%d&quot;, &amp;day);
    switch(day)&#123;
        case Mon: puts(&quot;Monday&quot;); break;
        case Tues: puts(&quot;Tuesday&quot;); break;
        case Wed: puts(&quot;Wednesday&quot;); break;
        case Thurs: puts(&quot;Thursday&quot;); break;
        case Fri: puts(&quot;Friday&quot;); break;
        case Sat: puts(&quot;Saturday&quot;); break;
        case Sun: puts(&quot;Sunday&quot;); break;
        default: puts(&quot;Error!&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
<p>枚举值默认从0开始，往后逐个加 1（递增）；如果第一个成员赋值，从那个成员值往后递增。也就是说，week中的 Mon、Tues …… Sun 对应的值分别为 1、2… 7。<br>宏在编译的预处理阶段将名字替换成对应的值，而枚举在编译阶段将名字替换成对应的值。在编译过程中，Mon、Tues、Wed 名字都被替换成了对应的数字。这意味着Mon、Tues、Wed 等都不是变量，不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是被编译到指令里面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。<br>枚举类型实例的内存占用通常&#x3D;int类型占用&#x3D;4字节。</p>
<h1 id="7-结构体常见用法"><a href="#7-结构体常见用法" class="headerlink" title="7.结构体常见用法"></a>7.结构体常见用法</h1><h2 id="7-1结构体数组"><a href="#7-1结构体数组" class="headerlink" title="7.1结构体数组"></a>7.1结构体数组</h2><p>结构体数组是将多个同类型结构体按数组的方式存储，其成员访问方式为：先访问数组元素，再访问结构体成员。<br>结构体数组本质还是数组，但数组成员是结构体，结构体内可以包含各种类型的成员。<br>一个Linux NandFlash驱动的结构体数组如下：</p>
<pre><code>    static struct mtd_partition s3c_nand_parts[] = &#123;
    [0] = &#123;
        .name   = &quot;bootloader&quot;,
        .size   = 0x00040000,
        .offset    = 0,
    &#125;,
    [1] = &#123;
        .name   = &quot;params&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00020000,
    &#125;,
    [2] = &#123;
        .name   = &quot;kernel&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00200000,
    &#125;,
    [3] = &#123;
        .name   = &quot;root&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = MTDPART_SIZ_FULL,
    &#125;
&#125;;
</code></pre>
<p> 该数组名为s3c_nand_parts，成员为mtd_partition结构体，包含分区名，分区大小和分区偏移地址。每个结构体成员分别初始化赋值。注意结构体数组实例没写结构体名，只有数组下标[]，结构体成员没写结构体名,只有.符号。这是Linux kernel常见的精简写法。<br> 访问一个结构体数组的成员：</p>
<pre><code>s3c_nand_parts[0].name = &quot;bootloader_2&quot;
</code></pre>
<p>结构体数组的内存占用&#x3D;数组成员数*单个结构体内存占用。</p>
<h2 id="7-2结构体指针"><a href="#7-2结构体指针" class="headerlink" title="7.2结构体指针"></a>7.2结构体指针</h2><p>结构体指针本质是指针变量，其值是结构体的地址。<br>前面结构体重定义一节已经定义和初始化过结构体指针，需要注意的是，结构体指针的初始化值来源于结构体实例，结构体类型名只是标签，不代表结构体地址，注意和”数组名&#x3D;数组地址“区分。</p>
<pre><code>struct stu&#123;         
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;

struct stu *stu_p = stu;    //错，stu只是符号，不占内存
struct stu *stu_p = &amp;stu1;  //对，stu1是结构体实例，占内存  //对，stu1是stu实例变量，有内存占用
</code></pre>
<p>结构体指针的常见用途：malloc分配结构体空间</p>
<pre><code>stu_p =(stu_t *)malloc(sizeof(stu_t));  //分配结构体空间，返回地址给结构体指针
</code></pre>
<p>结构体指针最重要的用途：函数传参<br>结构体变量作为函数参数时传递的是整个结构体内存空间，也就是所有成员空间，而不是像数组一样被编译器转换成一个指针。如果结构体成员较多，传送的时间和空间开销会很大，影响程序的运行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。</p>
<h2 id="7-2结构体嵌套"><a href="#7-2结构体嵌套" class="headerlink" title="7.2结构体嵌套"></a>7.2结构体嵌套</h2><p>结构体嵌套是结构体的成员也是结构体。有两种情况：<br>1.成员是其他类型的结构体<br>2.成员是同类型的结构体</p>
<h3 id="7-2-1-嵌套其他类型"><a href="#7-2-1-嵌套其他类型" class="headerlink" title="7.2.1.嵌套其他类型"></a>7.2.1.嵌套其他类型</h3><p>在协议开发中，一个命令的数据可以用结构体来表达，在命令的内部又分为很多个数据域，每个数据域又用结构体来表达，因此需要结构体嵌套。对于同一块数据，根据命令的不同，解析为不同的结构体,因此存在多类命令公用一块数据域的情况，因此需要联合（Union）。以NVMe协议为例，结构体嵌套和联合一起使用的例子：</p>
<pre><code>typedef struct  //nvme命令结构体
&#123;
     union      //命令中dword10空间的联合
    &#123;
        u32 command_dw10;
        struct
        &#123;
            u32 cntid:16;   //16 bit位域
            u32 resv1:8;    //8 bit位域
            u32 cns:8;      //8 bit位域
        &#125;identify;          //当命令为identify时
        struct
        &#123;
            u32 save:1;
            u32 resv1:20;
            u32 select:3;
            u32 feature_identifier:8;
        &#125;get_features;      //当命令为get_featuresy时
        struct
        &#123;
            u32 queue_size:16;
            u32 queue_identifier:16;
        &#125;io_queue_create_delete_dw10;
        ...
    &#125;;
    
    union   //命令中dword11空间的联合
    &#123;
        u32 command_dw11;
        struct
        &#123;
            u32 completion:16;
            u32 submission:16;
        &#125;number_of_queues;
        struct
        &#123;
            u32 interrupt_vector:16;
            u32 resv1:14;
            u32 interrupt_enabled:1;
            u32 physically_contiguous:1;
        &#125;create_io_completion_queue_dw11;
        ...
    &#125;;
    
&#125;command_t, *command_p;
</code></pre>
<p>该例子结合了结构体、联合、位域。对每个nvme命令，多个联合并存在结构体command_t实例里，每个联合长度为一个dword(4字节)，分别表示dword0~15中的一个。对于dword内部，根据解析到命令的不同，作为不同含义处理，如解析为identify就按identify的结构体读写成员，如解析为get_features则按get_features的结构体读写成员。在结构体内部，用位域更精细控制这个dword内各bit的含义。</p>
<h3 id="7-2-2嵌套自身类型"><a href="#7-2-2嵌套自身类型" class="headerlink" title="7.2.2嵌套自身类型"></a>7.2.2嵌套自身类型</h3><p>结构体嵌套自身类型的典型应用：链表数据结构体</p>
<pre><code>typedef struct ListNode &#123;
    DataType data;          // 节点数据 
    struct ListNode *next;  // 指向下一个结点的指针 
&#125; ListNode_t;
</code></pre>
<p>这个结构体有两个成员：DataType类型的数据，和指向 struct ListNode类型(&#x3D;ListNode_t类型)的实例的指针。有多个ListNode_t类型的结构体被实例化且依次指向后续节点后，可以依次node1-&gt;next-&gt;next…-&gt;data访问链表中的节点数据。<br>注意：结构体体能嵌套自身类型的指针，而不能嵌套自身类型的实例。因为指针分配内存是定长（通常4字节），而循环嵌套结构体变量是无穷的。以下写法是错的</p>
<pre><code>typedef struct ListNode &#123;
    DataType data;           
    struct ListNode next;  // 错，嵌套的是实例 
&#125; ListNode_t;
</code></pre>
<h1 id="8-结构体高级用法：面向对象"><a href="#8-结构体高级用法：面向对象" class="headerlink" title="8.结构体高级用法：面向对象"></a>8.结构体高级用法：面向对象</h1><h2 id="8-1函数指针"><a href="#8-1函数指针" class="headerlink" title="8.1函数指针"></a>8.1函数指针</h2><p>程序中定义的函数，在编译时会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的入口地址。函数名表示的就是这个地址的值。可以定义一个指针变量来存放函数的入口地址，这个指针变量就叫作函数指针变量，简称函数指针。<br>这段话什么意思？<br>1.函数名&#x3D;函数入口地址<br>2.可以用指针变量的值取代函数名，函数的调用和该指针变量的调用等价<br>3.可以把这个指针变量当参数传递给别的函数，也可以把这个指针变量作为结构体的成员，总之，一切指针能做的，函数指针都能做。<br>函数指针的定义：</p>
<pre><code>返回值 函数入口地址(入参1的类型，入参2的类型，...)
int (*p)(int, int);     //p为函数指针，*p为入口地址
</code></pre>
<p>定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数。p 的类型为 int(*)(int，int)<br>函数指针的初始化：</p>
<pre><code>int Func(int x);   /*声明一个函数，包含入参名*/
int (*p) (int);  /*声明一个函数指针，只有入参类型*/
p = Func;         /*将Func函数的入口地址赋给指针变量p*/
</code></pre>
<p>函数指针作为结构体成员的调用如下</p>
<pre><code>struct&#123;
    int (* func)(int);
&#125;stu1, *stu1_p; //分配两个结构体实例：stu1结构体和指针stu1_p

stu1.func(10);  //通过结构体调用函数指针
stu1_p-&gt;func(10);   //通过结构体指针调用函数指针
</code></pre>
<h2 id="8-2回调函数"><a href="#8-2回调函数" class="headerlink" title="8.2回调函数"></a>8.2回调函数</h2><p>回调函数(Callback)就是一个通过函数指针调用的函数。把函数指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由函数的实现方直接调用，而是在特定的事件或条件发生时，由把它当参数的那个函数调用的，用于对该事件或条件进行响应。<br>回调的两个特点：<br>1.函数&#x3D;参数。函数A指针当参数传递B<br>2.异步。特定时间发生时，B才调用A指针指向的函数</p>
<h2 id="8-3结构体与面向对象"><a href="#8-3结构体与面向对象" class="headerlink" title="8.3结构体与面向对象"></a>8.3结构体与面向对象</h2><p>当函数指针作为结构体的成员，可以通过结构体实例调用成员函数，此时可以实现类似其他语言中“类”或“接口”的概念：<br>结构体声明&#x3D;类声明&#x3D;接口声明<br>结构体的函数指针成员&#x3D;类方法&#x3D;接口函数<br>结构体实例调用函数指针成员&#x3D;类实例调用方法&#x3D;接口的实现<br>这种设计思想在Linux内核和驱动框架中很常用。以字符设备驱动为例：<br>字符设备驱动顶层框架将所有字符操作函数作为接口在结构体file_operations中定义，在底层具体的设备驱动中实现file_operations的方法。底层驱动实例化file_operations结构体（分配内存），将各种操作的具体实现函数赋值给接口定义的函数，然后上报（注册）该file_operations实例给顶层驱动框架，顶层驱动框架接收到应用层的系统调用请求时，回调已注册的file_operations实例的函数。<br>上层驱动框架定义的字符文件操作接口如下，这些open、read、write作为文件操作的方法供应用层调用。</p>
<pre><code> struct file_operations &#123;   //字符文件操作的接口定义
　　struct module *owner;   //结构体指针
　　ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);      //函数指针read
　　ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);    //函数指针write
　　int (*open) (struct inode *, struct file *);    //函数指针open
　　int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);   //函数指针ioctl
　　...
&#125;;
</code></pre>
<p>而这些方法具体实现（内部做什么）是由底层驱动代码实现：</p>
<pre><code>static int my_drv_open(struct inode *inode, struct file *file)
&#123;
    //硬件寄存器操作A...
    return 0;
&#125;

static ssize_t my_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)
&#123;
    //硬件寄存器操作B...
    return 0;
&#125;
</code></pre>
<p>那么这些实现怎么关联接口：在底层驱动分配结构体实例，初始化函数指针为实现函数</p>
<pre><code>static struct file_operations my_drv_fops = &#123;
    .owner  =   THIS_MODULE,   
    .open   =   my_drv_open,   //open接口由my_drv_open函数实现  
    .write    =    my_drv_write,     //write接口由my_drv_write函数实现  
&#125;;
</code></pre>
<p>关联完了，上层驱动怎么调用：结构体指针传参+回调<br>my_drv_fops是file_operations的实例，上报给上层驱动，上层驱动有它自己的字符设备结构体cdev，取出my_drv_fops实例的.结构体指针fops的值，赋给cdev实例内的ops指针。之后它就能用ops调用my_drv_open、my_drv_write函数。</p>
<pre><code>//注册结构体
cdev-&gt;owner = fops-&gt;owner;
cdev-&gt;ops = fops;
//回调.open方法
cdev-&gt;ops-&gt;open(inode,file);
</code></pre>
<p>由于my_drv_write是值，open才是结构体成员，因此调用的时候看上去调用的是open函数，本质上执行的还是my_drv_write的流程。函数指针的回调能将接口名暴露，方法名隐藏。因此底层实现的函数名和上层驱动的调用函数名不相关，上层永远都可以用.open .read .write这些接口调用底层驱动，而底层函数可以随便改名（不能改入参出参类型，否则函数指针类型变了），这种特性都是函数指针决定的。<br>对于应用程序，是调用上层驱动提供的系统调用接口，还是如.open .read .write等接口。Linux驱动将设备抽象成了文件，驱动程序实现了文件的各种方法，所以对应用程序，打开文件&#x3D;打开设备，调用文件对应的接口&#x3D;调用设备驱动提供的接口。</p>
<pre><code>fd = open(&quot;/dev/xyz&quot;, O_RDWR);  //打开文件（设备）
read(fd, &amp;val, 1);  //读fd文件（设备）的值到val变量
</code></pre>
<p>除了C语言，在golang中也有类似的结构体+函数指针实现的面向对象方法。<br>NOTE:关于结构体中的函数指针写法易错点：<br>不包含变量名，只能使用基本类型</p>
<pre><code>   #一个结构体
   typedef stru&#123;    //定义结构体名
        int a;
        char b;
   &#125;stru_t, *stru_p; //重定义结构体变量和指针
    
    #普通函数声明
    int func(int a, stru_p p); //参数写类型且写值，可以使用typedef后的结构体指针类型
    
    #函数指针声明
    int (*func)(int, struct stru *);    //参数只写类型不写参数，只能使用C基本类型，不能使用typedef后的类型，只能写struct stru *类型
</code></pre>
<p>函数指针声明使用typedef后的类型名，编译器不认识，产生syntax error。    </p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux的Signal信号</title>
    <url>/2020/11/08/%E6%B5%85%E8%B0%88Linux%E7%9A%84Signal%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<p>本文将从以下几个方面来阐述信号:</p>
<p>(1) 信号的基本知识<br>(2) 信号生命周期与处理过程分析<br>(3) 基本的信号处理函数<br>(4) 保护临界区不被中断<br>(5) 信号的继承与执行<br>(6) 实时信号中锁的研究</p>
<h1 id="第一部分-信号的基本知识"><a href="#第一部分-信号的基本知识" class="headerlink" title="第一部分: 信号的基本知识"></a>第一部分: 信号的基本知识</h1><h2 id="1-信号本质"><a href="#1-信号本质" class="headerlink" title="1.信号本质:"></a>1.信号本质:</h2><p>信号的本质是软件层次上对中断的一种模拟。它是一种异步通信的处理机制，事实上，进程并不知道信号何时到来。</p>
<h2 id="2-信号来源"><a href="#2-信号来源" class="headerlink" title="2.信号来源"></a>2.信号来源</h2><p>(1)程序错误，如非法访问内存<br>(2)外部信号，如按下了CTRL+C<br>(3)通过kill或sigqueue向另外一个进程发送信号</p>
<h2 id="3-信号种类"><a href="#3-信号种类" class="headerlink" title="3.信号种类"></a>3.信号种类</h2><p>信号分为可靠信号与不可靠信号,可靠信号又称为实时信号，非可靠信号又称为非实时信号。<br>信号代码从1到32是不可靠信号,不可靠信号主要有以下问题:<br>(1)每次信号处理完之后，就会恢复成默认处理，这可能是调用者不希望看到的<br>(2)存在信号丢失的问题<br>现在的Linux对信号机制进行了改进，因此，不可靠信号主要是指信号丢失<br>信号代码从SIGRTMIN到SIGRTMAX之间的信号是可靠信号。可靠信号不存在丢失，由sigqueue发送，可靠信号支持排队。</p>
<p>可靠信号注册机制:<br>内核每收到一个可靠信号都会去注册这个信号，在信号的未决信号链中分配sigqueue结构，因此，不会存在信号丢失的问题。</p>
<p>不可靠信号的注册机制:<br>而对于不可靠的信号，如果内核已经注册了这个信号，那么便不会再去注册，对于进程来说，便不会知道本次信号的发生。<br>可靠信号与不可靠信号与发送函数没有关系，取决于信号代码，前面的32种信号就是不可靠信号，而后面的32种信号就是可靠信号。</p>
<h2 id="4-信号响应的方式"><a href="#4-信号响应的方式" class="headerlink" title="4.信号响应的方式"></a>4.信号响应的方式</h2><p>(1)采用系统默认处理SIG_DFL,执行缺省操作<br>(2)捕捉信号处理，即用户自定义的信号处理函数来处理<br>(3)忽略信号SIG_IGN ,但有两种信号不能被忽略SIGKILL，SIGSTOP</p>
<h1 id="第二部分-信号的生命周期与处理过程分析"><a href="#第二部分-信号的生命周期与处理过程分析" class="headerlink" title="第二部分: 信号的生命周期与处理过程分析"></a>第二部分: 信号的生命周期与处理过程分析</h1><h2 id="1-信号的生命周期"><a href="#1-信号的生命周期" class="headerlink" title="1. 信号的生命周期"></a>1. 信号的生命周期</h2><p>信号产生-&gt;信号注册－&gt;信号在进程中注销-&gt;信号处理函数执行完毕</p>
<p>(1)信号的产生是指触发信号的事件的发生</p>
<p>(2)信号注册<br>指的是在目标进程中注册，该目标进程中有未决信号的信息:</p>
<pre><code>struct sigpending pending：
struct sigpending&#123;
struct sigqueue *head, **tail;
sigset_t signal;
&#125;;

struct sigqueue&#123;
struct sigqueue *next;
siginfo_t info;
&#125;
</code></pre>
<p>其中 sigqueue结构组成的链称之为未决信号链，sigset_t称之为未决信号集。<br>*head,**tail分别指向未决信号链的头部与尾部。<br>siginfo_t info是信号所携带的信息。<br>信号注册的过程就是将信号值加入到未决信号集siginfo_t中，将信号所携带的信息加入到未决信号链的某一个sigqueue中去。<br> 因此，对于可靠的信号，可能存在多个未决信号的sigqueue结构，对于每次信号到来都会注册。而不可靠信号只注册一次，只有一个sigqueue结构。<br>只要信号在进程的未决信号集中，表明进程已经知道这些信号了，还没来得及处理，或者是这些信号被阻塞。</p>
<p>(3)信号在目标进程中注销<br> 在进程的执行过程中，每次从系统调用或中断返回用户空间的时候，都会检查是否有信号没有被处理。如果这些信号没有被阻塞，那么就调用相应的信号处理函数来处理这些信号。则调用信号处理函数之前，进程会把信号在未决信号链中的sigqueue结构卸掉。是否从未决信号集中把信号删除掉，对于实时信号与非实时信号是不相同的。<br>非实时信号:由于非实时信号在未决信号链中只有一个sigqueue结构，因此将它删除的同时将信号从未决信号集中删除。<br>实时信号:由于实时信号在未决信号链中可能有多个sigqueue结构，如果只有一个，也将信号从未决信号集中删除掉。如果有多个那么不从未决信号集中删除信号，注销完毕。</p>
<p>(4)信号处理函数执行完毕<br>执行处理函数，本次信号在进程中响应完毕。<br>在第4步，只简单的描述了信号处理函数执行完毕，就完成了本次信号的响应，但这个信号处理函数空间是怎么处理的呢? 内核栈与用户栈是怎么工作的呢? 这就涉及到了信号处理函数的过程。</p>
<h2 id="2-信号处理函数的过程"><a href="#2-信号处理函数的过程" class="headerlink" title="2. 信号处理函数的过程:"></a>2. 信号处理函数的过程:</h2><p>(1)注册信号处理函数<br>信号的处理是由内核来代理的，首先程序通过sigal或sigaction函数为每个信号注册处理函数，而内核中维护一张信号向量表，对应信号处理机制。这样，在信号在进程中注销完毕之后，会调用相应的处理函数进行处理。</p>
<p>(2)信号的检测与响应时机<br>在系统调用或中断返回用户态的前夕，内核会检查未决信号集，进行相应的信号处理。</p>
<p>(3)处理过程:<br>程序运行在用户态时-&gt;进程由于系统调用或中断进入内核-&gt;转向用户态执行信号处理函数-&gt;信号处理函数完毕后进入内核-&gt;返回用户态继续执行程序<br>首先程序执行在用户态，在进程陷入内核并从内核返回的前夕，会去检查有没有信号没有被处理，如果有且没有被阻塞就会调用相应的信号处理程序去处理。首先，内核在用户栈上创建一个层，该层中将返回地址设置成信号处理函数的地址，这样，从内核返回用户态时，就会执行这个信号处理函数。当信号处理函数执行完，会再次进入内核，主要是检测有没有信号没有处理，以及恢复原先程序中断执行点，恢复内核栈等工作，这样，当从内核返回后便返回到原先程序执行的地方了。<br>信号处理函数的过程大概是这样了。<br>具体的可参考<a href="http://www.spongeliu.com/linux/linux%E5%86%85%E6%A0%B8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/">http://www.spongeliu.com/linux/linux内核信号处理机制介绍/</a></p>
<h1 id="第三部分-基本的信号处理函数"><a href="#第三部分-基本的信号处理函数" class="headerlink" title="第三部分: 基本的信号处理函数"></a>第三部分: 基本的信号处理函数</h1><p>首先看一个两个概念: 信号未决与信号阻塞<br>信号未决: 指的是信号的产生到信号处理之前所处的一种状态。确切的说，是信号的产生到信号注销之间的状态。<br>信号阻塞: 指的是阻塞信号被处理，是一种信号处理方式。</p>
<h2 id="1-信号操作"><a href="#1-信号操作" class="headerlink" title="1. 信号操作"></a>1. 信号操作</h2><p> 信号操作最常用的方法是信号的屏蔽，信号屏蔽主要用到以下几个函数:</p>
<pre><code>int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set,int signo);
int sigdelset(sigset_t *set,int signo);
int sigismemeber(sigset_t* set,int signo);
int sigprocmask(int how,const sigset_t*set,sigset_t *oset);
</code></pre>
<p>信号集，信号掩码，未决集<br>信号集: 所有的信号阻塞函数都使用一个称之为信号集的结构表明其所受到的影响。<br>信号掩码:当前正在被阻塞的信号集。<br>未决集: 进程在收到信号时到信号在未被处理之前信号所处的集合称为未决集。<br>可以看出，这三个概念没有必然的联系，信号集指的是一个泛泛的概念，而未决集与信号掩码指的是具体的信号状态。</p>
<p>对于信号集的初始化有两种方法: 一种是用sigemptyset使信号集中不包含任何信号，然后用sigaddset把信号加入到信号集中去。<br>另一种是用sigfillset让信号集中包含所有信号，然后用sigdelset删除信号来初始化。<br>sigemptyset()函数初始化信号集set并将set设置为空。<br>sigfillset()函数初始化信号集，但将信号集set设置为所有信号的集合。<br>sigaddset()将信号signo加入到信号集中去。<br>sigdelset()从信号集中删除signo信号。<br>sigprocmask()将指定的信号集合加入到进程的信号阻塞集合中去。如果提供了oset,那么当前的信号阻塞集合将会保存到oset集全中去。<br>参数how决定了操作的方式:<br>SIG_BLOCK 增加一个信号集合到当前进程的阻塞集合中去<br>SIG_UNBLOCK 从当前的阻塞集合中删除一个信号集合<br>SIG_SETMASK 将当前的信号集合设置为信号阻塞集合</p>
<p>下面看一个例子:</p>
<pre><code>int main()&#123;
    sigset_t initset;
    int i;
    sigemptyset(&amp;initset);//初始化信号集合为空集合
    sigaddset(&amp;initset,SIGINT);//将SIGINT信号加入到此集合中去
    while(1)&#123;
        sigprocmask(SIG_BLOCK,&amp;initset,NULL);//将信号集合加入到进程的阻塞集合中去
        fprintf(stdout,&quot;SIGINT singal blocked/n&quot;);
        for(i=0;i&lt;10;i++)&#123;
        
            sleep(1);//每1秒输出
            fprintf(stdout,&quot;block %d/n&quot;,i);
        &#125;
        //在这时按一下Ctrl+C不会终止
        sigprocmask(SIG_UNBLOCK,&amp;initset,NULL);//从进程的阻塞集合中去删除信号集合
        fprintf(stdout,&quot;SIGINT SINGAL unblokced/n&quot;);
        for(i=0;i&lt;10;i++)&#123;
            sleep(1);
            fprintf(stdout,&quot;unblock %d/n&quot;,i);
        &#125;
    &#125;
    exit(0);
&#125;
</code></pre>
<p>执行结果:</p>
<pre><code>SIGINT singal blocked
block 0
block 1
block 2
block 3
block 4
block 5
block 6
block 7
block 8
block 9
</code></pre>
<p>在执行到block 3时按下了CTRL+C并不会终止，直到执行到block9后将集合从阻塞集合中移除。</p>
<pre><code>[root@localhost C]# ./s1
SIGINT singal blocked
block 0
block 1
block 2
block 3
block 4
block 5
block 6
block 7
block 8
block 9
SIGINT SINGAL unblokced
unblock 0
unblock 1
</code></pre>
<p>由于此时已经解除了阻塞，在unblock1后按下CTRL+C则立即终止。</p>
<h2 id="2-信号处理函数"><a href="#2-信号处理函数" class="headerlink" title="2. 信号处理函数"></a>2. 信号处理函数</h2><p>sigaction</p>
<pre><code>int sigaction(
    int signo,
    const struct sigaction *act,
    struct sigaction *oldact
);
</code></pre>
<p>这个函数主要是用于改变或检测信号的行为。<br>第一个参数是变更signo指定的信号，它可以指向任何值，SIGKILL,SIGSTOP除外<br>第二个参数,第三个参数是对信号进行细粒度的控制。<br>如果<em>act不为空，</em>oldact不为空，那么oldact将会存储信号以前的行为。如果act为空，*oldact不为空，那么oldact将会存储信号现在的行为。</p>
<pre><code>struct sigaction &#123;
    void (*sa_handler)(int);
    void (*sa_sigaction)(int,siginfo_t*,void*);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
&#125;
</code></pre>
<p>参数含义:<br>sa_handler是一个函数指针，主要是表示接收到信号时所要采取的行动。此字段的值可以是SIG_DFL,SIG_IGN.分别代表默认操作与内核将忽略进程的信号。这个函数只传递一个参数那就是信号代码。<br>当SA_SIGINFO被设定在sa_flags中，那么则会使用sa_sigaction来指示信号处理函数，而非sa_handler.<br>sa_mask设置了掩码集，在程序执行期间会阻挡掩码集中的信号。<br>sa_flags设置了一些标志， SA_RESETHAND当该函数处理完成之后，设定为为系统默认的处理模式。SA_NODEFER 在处理函数中，如果再次到达此信号时，将不会阻塞。默认情况下，同一信号两次到达时，如果此时处于信号处理程序中，那么此信号将会阻塞。<br>SA_SIGINFO表示用sa_sigaction指示的函数。<br>sa_restorer已经被废弃。</p>
<p>sa_sigaction所指向的函数原型:</p>
<pre><code>void my_handler(int signo,siginfo_t *si,void *ucontext);
</code></pre>
<p>第一个参数: 信号编号<br>第二个参数:指向一个siginfo_t结构。<br>第三个参数是一个ucontext_t结构。<br>其中siginfo_t结构体中包含了大量的信号携带信息，可以看出，这个函数比sa_handler要强大，因为前者只能传递一个信号代码，而后者可以传递siginfo_t信息。</p>
<pre><code>typedef struct siginfo_t&#123;
    int si_signo;//信号编号
    int si_errno;//如果为非零值则错误代码与之关联
    int si_code;//说明进程如何接收信号以及从何处收到
    pid_t si_pid;//适用于SIGCHLD，代表被终止进程的PID
    pid_t si_uid;//适用于SIGCHLD,代表被终止进程所拥有进程的UID
    int si_status;//适用于SIGCHLD，代表被终止进程的状态
    clock_t si_utime;//适用于SIGCHLD，代表被终止进程所消耗的用户时间
    clock_t si_stime;//适用于SIGCHLD，代表被终止进程所消耗系统的时间
    sigval_t si_value;
    int si_int;
    void * si_ptr;
    void* si_addr;
    int si_band;
    int si_fd;
&#125;;
</code></pre>
<p>sigqueue</p>
<pre><code>sigqueue(pid_t pid,int signo,const union sigval value)
</code></pre>
<p>sigqueue函数类似于kill,也是一个进程向另外一个进程发送信号的。<br>但它比kill函数强大。<br>第一个参数指定目标进程的pid.<br>第二个参数是一个信号代码。<br>第三个参数是一个共用体，每次只能使用一个，用来进程发送信号传递的数据。<br>或者传递整形数据，或者是传递指针。<br>发送的数据被sa_sigaction所指示的函数的siginfo_t结构体中的si_ptr或者是si_int所接收。</p>
<p>sigpending</p>
<pre><code>sigpending(sigset_t set);
</code></pre>
<p>这个函数的作用是返回未决的信号到信号集set中。即未决信号集，未决信号集不仅包括被阻塞的信号，也可能包括已经到达但没有被处理的信号。</p>
<h2 id="示例1-sigaction函数的用法"><a href="#示例1-sigaction函数的用法" class="headerlink" title="示例1: sigaction函数的用法"></a>示例1: sigaction函数的用法</h2><pre><code>void signal_set(struct sigaction *act)
&#123;
switch(act-&gt;sa_flags)&#123;
    case (int)SIG_DFL:
        printf(&quot;using default hander/n&quot;);
        break;
    case (int)SIG_IGN:
        printf(&quot;ignore the signal/n&quot;);
        break;
    default:
        printf(&quot;%0x/n&quot;,act-&gt;sa_handler);
    &#125;
&#125;
void signal_set1(int x)&#123;//信号处理函数
    printf(&quot;xxxxx/n&quot;);
    while(1)&#123;&#125;
&#125;

int main(int argc,char** argv)
&#123;
    int i;
    struct sigaction act,oldact;
    act.sa_handler = signal_set1;
    act.sa_flags = SA_RESETHAND;
    //SA_RESETHANDD 在处理完信号之后，将信号恢复成默认处理
    //SA_NODEFER在信号处理程序执行期间仍然可以接收信号
    sigaction (SIGINT,&amp;act,&amp;oldact) ;//改变信号的处理模式
    for (i=1; i&lt;12; i++)
    &#123;
        printf(&quot;signal %d handler is : &quot;,i);
        sigaction (i,NULL,&amp;oldact) ;
        signal_set(&amp;oldact);//如果act为NULL，oldact会存储信号当前的行为
        //act不为空，oldact不为空，则oldact会存储信号以前的处理模式
    &#125;
    while(1)&#123;
        //等待信号的到来
    &#125;
    return 0;
&#125;
</code></pre>
<p>运行结果:</p>
<pre><code>[root@localhost C]# ./s2
signal 1 handler is : using default hander
signal 2 handler is : 8048437
signal 3 handler is : using default hander
signal 4 handler is : using default hander
signal 5 handler is : using default hander
signal 6 handler is : using default hander
signal 7 handler is : using default hander
signal 8 handler is : using default hander
signal 9 handler is : using default hander
signal 10 handler is : using default hander
signal 11 handler is : using default hander
xxxxx
</code></pre>
<p>解释:</p>
<pre><code>sigaction(i,NULL,&amp;oldact);
signal_set(&amp;oldact);
</code></pre>
<p>由于act为NULL,那么oldact保存的是当前信号的行为，当前的第二个信号的行为是执行自定义的处理程序。<br>当按下CTRL＋C时会执行信号处理程序，输出xxxxxx，再按一下CTRL＋C会停止,是由于SA_RESETHAND恢复成默认的处理模式，即终止程序。<br>如果没有设置SA_NODEFER,那么在处理函数执行过程中按一下CTRL＋C将会被阻塞，那么程序会停在那里。</p>
<h2 id="示例2-sigqueue向本进程发送数据的信号"><a href="#示例2-sigqueue向本进程发送数据的信号" class="headerlink" title="示例2: sigqueue向本进程发送数据的信号"></a>示例2: sigqueue向本进程发送数据的信号</h2><pre><code>int main()&#123;
    union sigval val;//定义一个携带数据的共用体
    struct sigaction oldact,act;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO;//表示使用sa_sigaction指示的函数，处理完恢复默认，不阻塞处理过程中到达下在被处理的信号
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;act,&amp;oldact);
    char data[100];
    int num=0;
    while(num&lt;10)&#123;
        sleep(2);
        printf(&quot;等待SIGUSR1信号的到来/n&quot;);
        sprintf(data,&quot;%d&quot;,num++);
        val.sival_ptr=data;
        sigqueue(getpid(),SIGUSR1,val);//向本进程发送一个信号
    &#125;
&#125;

void myhandler(int signo,siginfo_t *si,void *ucontext)&#123;
    printf(&quot;已经收到SIGUSR1信号/n&quot;);
    printf(&quot;%s/n&quot;,(char*)(si-&gt;si_ptr));
&#125;
</code></pre>
<p>程序执行的结果是:</p>
<pre><code>等待SIGUSR1信号的到来
已经收到SIGUSR1信号
0
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
1
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
2
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
3
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
4
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
5
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
6
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
7
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
8
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
9
</code></pre>
<p>解释: 本程序用sigqueue不停的向自身发送信号,并且携带数据，数据被放到处理函数的第二个参数siginfo_t结构体中的si_ptr指针，当num&lt;10时不再发。</p>
<p>一般而言，sigqueue与sigaction配合使用，而kill与signal配合使用。</p>
<h2 id="示例3-一个进程向另外一个进程发送信号，并携带信息"><a href="#示例3-一个进程向另外一个进程发送信号，并携带信息" class="headerlink" title="示例3: 一个进程向另外一个进程发送信号，并携带信息"></a>示例3: 一个进程向另外一个进程发送信号，并携带信息</h2><p>发送端:</p>
<pre><code>int main()&#123;
    union sigval value;
    value.sival_int=10;
    
    if(sigqueue(4403,SIGUSR1,value)==-1)&#123;//4403是目标进程pid
        perror(&quot;信号发送失败/n&quot;);
    &#125;
    sleep(2);
&#125;
</code></pre>
<p>接收端:</p>
<pre><code>int main()&#123;
    struct sigaction oldact,act;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO|SA_NODEFER;
    //表示执行后恢复，用sa_sigaction指示的处理函数，在执行期间仍然可以接收信号
    sigaction(SIGUSR1,&amp;act,&amp;oldact);
    while(1)&#123;
        sleep(2);
        printf(&quot;等待信号的到来/n&quot;);
    &#125;
&#125;

void myhandler(int signo,siginfo_t *si,void *ucontext)&#123;
    printf(&quot;the value is %d/n&quot;,si-&gt;si_int);
&#125;
</code></pre>
<h2 id="示例4-sigpending的用法"><a href="#示例4-sigpending的用法" class="headerlink" title="示例4: sigpending的用法"></a>示例4: sigpending的用法</h2><p>sigpending(sigset_t *set)将未决信号放到指定的set信号集中去，未决信号包括被阻塞的信号和信号到达时但还没来得及处理的信号</p>
<pre><code>int main()&#123;
    struct sigaction oldact,act;
    sigset_t oldmask,newmask,pendingmask;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO;
    sigemptyset(&amp;act.sa_mask);//首先将阻塞集合设置为空，即不阻塞任何信号
    //注册信号处理函数
    sigaction(SIGRTMIN+10,&amp;act,&amp;oldact);
    //开始阻塞
    sigemptyset(&amp;newmask);
    sigaddset(&amp;newmask,SIGRTMIN+10);
    printf(&quot;SIGRTMIN+10 blocked/n&quot;);
    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask);
    sleep(20);//为了发出信号
    printf(&quot;now begin to get pending mask/n&quot;);
    if(sigpending(&amp;pendingmask)&lt;0)&#123;
        perror(&quot;pendingmask error&quot;);
    &#125;
    if(sigismember(&amp;pendingmask,SIGRTMIN+10))&#123;
        printf(&quot;SIGRTMIN+10 is in the pending mask/n&quot;);
    &#125;
    
    sigprocmask(SIG_UNBLOCK,&amp;newmask,&amp;oldmask);
    printf(&quot;SIGRTMIN+10 unblocked/n&quot;);
&#125;
//信号处理函数
void myhandler(int signo,siginfo_t *si,void *ucontext)&#123;
    printf(&quot;receive signal %d/n&quot;,si-&gt;si_signo);
&#125;
</code></pre>
<p>程序执行,在另一个shell发送信号:</p>
<pre><code> kill -44 4579

SIGRTMIN+10 blocked
now begin to get pending mask
SIGRTMIN+10 is in the pending mask
receive signal 44
SIGRTMIN+10 unblocked
</code></pre>
<p>可以看到SIGRTMIN由于被阻塞所以处于未决信号集中。<br>关于基本的信号处理函数就介绍到这了。</p>
<h1 id="第四部分-保护临界区不被中断"><a href="#第四部分-保护临界区不被中断" class="headerlink" title="第四部分: 保护临界区不被中断"></a>第四部分: 保护临界区不被中断</h1><h2 id="1-函数的可重入性"><a href="#1-函数的可重入性" class="headerlink" title="1. 函数的可重入性"></a>1. 函数的可重入性</h2><p>函数的可重入性是指可以多于一个任务并发使用函数，而不必担心数据错误。相反，不可重入性是指不能多于一个任务共享函数，除非能保持函数互斥(或者使用信号量，或者在代码的关键部分禁用中断)。可重入函数可以在任意时刻被中断，稍后继续执行，而不会丢失数据。</p>
<p>可重入函数：</p>
<ul>
<li>不为连续的调用持有静态数据。</li>
<li>不返回指向静态数据的指针；所有数据都由函数的调用者提供。</li>
<li>使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。</li>
<li>绝不调用任何不可重入函数。</li>
</ul>
<p>不可重入函数可能导致混乱现象，如果当前进程的操作与信号处理程序同时对一个文件进行写操作或者是调用malloc()，那么就可能出现混乱，当从信号处理程序返回时，造成了状态不一致。从而引发错误。<br>因此，信号的处理必须是可重入函数。<br>简单的说，可重入函数是指在一个程序中调用了此函数，在信号处理程序中又调用了此函数，但仍然能够得到正确的结果。<br>printf，malloc函数都是不可重入函数。printf函数如果打印缓冲区一半时，又有一个printf函数，那么此时会造成混乱。而malloc函数使用了系统全局内存分配表。</p>
<h2 id="2-保护临界区不被中断"><a href="#2-保护临界区不被中断" class="headerlink" title="2. 保护临界区不被中断"></a>2. 保护临界区不被中断</h2><p>由于临界区的代码是关键代码，是非常重要的部分，因此，有必要对临界区进行保护，不希望信号来中断临界区操作。这里通过信号屏蔽字来阻塞信号的发生。</p>
<p> 下面介绍两个与保护临界区不被信号中断的相关函数。</p>
<pre><code>int pause(void);
int sigsuspend(const sigset_t *sigmask);
</code></pre>
<p>pause函数挂起一个进程，直到一个信号发生。</p>
<p>sigsuspend函数的执行过程如下:<br>(1)设置新的mask去阻塞当前进程<br>(2)收到信号，调用信号的处理函数<br>(3)将mask设置为原先的掩码<br>(4)sigsuspend函数返回</p>
<p>可以看出，sigsuspend函数是等待一个信号发生，当等待的信号发生时，执行完信号处理函数后就会返回。它是一个原子操作。</p>
<p>保护临界区的中断:<br>(1)首先用sigprocmask去阻塞信号<br>(2)执行后关键代码后,用sigsuspend去捕获信号<br>(3)然后sigprocmask去除阻塞<br>这样信号就不会丢失了，而且不会中断临界区。</p>
<p>上面的程序是用pause去保护临界区，首先用sigprocmask去阻塞SIGINT信号，执行临界区代码，然后解除阻塞。最后调用pause()函数等待信号的发生。但此时会产生一个问题，如果信号在解除阻塞与pause之间发生的话，信号就可能丢失。这将是一个不可靠的信号机制。<br>因此，采用sigsuspend可以避免上述情况发生。</p>
<p>sigsuspend函数的用法：<br>sigsuspend函数是等待的信号发生时才会返回。<br>sigsuspend函数遇到结束时不会返回，这一点很重要。</p>
<p>示例:</p>
<p>下面的例子能够处理信号SIGUSR1,SIGUSR2,SIGSEGV,其它的信号被屏蔽，该程序输出对应的信号，然后继续等待其它信号的出现。</p>
<pre><code>void myhandler(int signo);
int main()&#123;
    struct sigaction action;
    sigset_t sigmask;
    sigemptyset(&amp;sigmask);
    sigaddset(&amp;sigmask,SIGUSR1);
    sigaddset(&amp;sigmask,SIGUSR2);
    sigaddset(&amp;sigmask,SIGSEGV);
    action.sa_handler=myhandler;
    action.sa_mask=sigmask;
    sigaction(SIGUSR1,&amp;action,NULL);
    sigaction(SIGUSR2,&amp;action,NULL);
    sigaction(SIGSEGV,&amp;action,NULL);
    sigfillset(&amp;sigmask);
    sigdelset(&amp;sigmask,SIGUSR1);
    sigdelset(&amp;sigmask,SIGUSR2);
    sigdelset(&amp;sigmask,SIGSEGV);
    while(1)&#123;
        sigsuspend(&amp;sigmask);//不断的等待信号到来
    &#125;
    return 0;
&#125;
    
void myhandler(int signo)&#123;
    switch(signo)&#123;
        case SIGUSR1:
            printf(&quot;received sigusr1 signal./n&quot;);
        break ;
        case SIGUSR2:
            printf(&quot;received sigusr2 signal./n&quot;);
        break;
        case SIGSEGV:
            printf(&quot;received sigsegv signal/n&quot;);
        break;
    &#125;
&#125;
</code></pre>
<p>程序运行结果:</p>
<pre><code>received sigusr1 signal
received sigusr2 signal
received sigsegv signal
received sigusr1 signal
已终止
</code></pre>
<p>另一个终端用于发送信号:<br>先得到当前进程的pid, ps aux|grep 程序名</p>
<pre><code>kill -SIGUSR1 4901
kill -SIGUSR2 4901
kill -SIGSEGV 4901
kill -SIGTERM 4901
kill -SIGUSR1  4901
</code></pre>
<p>解释:<br>第一行发送SIGUSR1，则调用信号处理函数，打印出结果。<br>第二，第三行分别打印对应的结果。<br>第四行发送一个默认处理为终止进程的信号。<br>但此时，但不会终止程序，由于sigsuspend遇到终止进程信号并不会返回，此时并不会打印出”已终止”，这个信号被阻塞了。当再次发送SIGURS1信号时，进程的信号阻塞恢复成默认的值，因此，此时将会解除阻塞SIGTERM信号，所以进程被终止。</p>
<h1 id="第五部分-信号的继承与执行"><a href="#第五部分-信号的继承与执行" class="headerlink" title="第五部分: 信号的继承与执行"></a>第五部分: 信号的继承与执行</h1><p>当使用fork()函数时，子进程会继承父进程完全相同的信号语义，这也是有道理的，因为父子进程共享一个地址空间，所以父进程的信号处理程序也存在于子进程中。</p>
<p>示例: 子进程继承父进程的信号处理函数</p>
<pre><code>void myhandler(int signo,siginfo_t *si,void *vcontext);
int main()&#123;
    union sigval val;
    struct sigaction oldact,newact;
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO|SA_RESETHAND;//表示采用sa_sigaction指示的函数以及执行完处理函数后恢复默认操作
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    
    if(fork()==0)&#123;
        val.sival_int=10;
        printf(&quot;子进程/n&quot;);
        sigqueue(getpid(),SIGUSR1,val);
    &#125;
    else &#123;
        val.sival_int=20;
        printf(&quot;父进程/n&quot;);
        sigqueue(getpid(),SIGUSR1,val);
    &#125;
&#125;

void myhandler(int signo,siginfo_t *si,void *vcontext)&#123;
    printf(&quot;信号处理/n&quot;);
    printf(&quot;%d/n&quot;,(si-&gt;si_int));
&#125;
</code></pre>
<p>输出的结果为:</p>
<pre><code>子进程
信号处理
10
父进程
信号处理
20
</code></pre>
<p>可以看出来，子进程继承了父进程的信号处理函数。</p>
<h1 id="第六部分-实时信号中锁的研究"><a href="#第六部分-实时信号中锁的研究" class="headerlink" title="第六部分: 实时信号中锁的研究"></a>第六部分: 实时信号中锁的研究</h1><h2 id="1-信号处理函数与主函数之间的死锁"><a href="#1-信号处理函数与主函数之间的死锁" class="headerlink" title="1. 信号处理函数与主函数之间的死锁"></a>1. 信号处理函数与主函数之间的死锁</h2><p>当主函数访问临界资源时，通常需要加锁，如果主函数在访问临界区时，给临界资源上锁，此时发生了一个信号，那么转入信号处理函数，如果此时信号处理函数也对临界资源进行访问，那么信号处理函数也会加锁，由于主程序持有锁，信号处理程序等待主程序释放锁。又因为信号处理函数已经抢占了主函数，因此，主函数在信号处理函数结束之前不能运行。因此，必然造成死锁。</p>
<p>示例1: 主函数与信号处理函数之间的死锁</p>
<pre><code>int value=0;
sem_t sem_lock;//定义信号量
void myhandler(int signo,siginfo_t *si,void *vcontext);//进程处理函数声明
int main()&#123;
    union sigval val;
    val.sival_int=1;
    struct sigaction oldact,newact;
    int res;
    res=sem_init(&amp;sem_lock,0,1);
    if(res!=0)&#123;
        perror(&quot;信号量初始化失败&quot;);
    &#125;
    
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    sem_wait(&amp;sem_lock);
    printf(&quot;xxxx/n&quot;);
    value=1;
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);//sigqueue发送带参数的信号
    sem_post(&amp;sem_lock);
    sleep(10);
    exit(0);
&#125;

void myhandler(int signo,siginfo_t *si,void *vcontext)&#123;
    sem_wait(&amp;sem_lock);
    value=0;
    sem_post(&amp;sem_lock);
&#125;
</code></pre>
<p>此程序将一直阻塞在信号处理函数的sem_wait函数处。</p>
<h2 id="2-利用测试锁解决死锁"><a href="#2-利用测试锁解决死锁" class="headerlink" title="2. 利用测试锁解决死锁"></a>2. 利用测试锁解决死锁</h2><p>sem_trywait(&amp;sem_lock);是非阻塞的sem_wait,如果加锁失败或者是超时，则返回－1。<br>示例2: 用sem_trywait来解决死锁</p>
<pre><code>int value=0;
sem_t sem_lock;//定义信号量
void myhandler(int signo,siginfo_t *si,void *vcontext);//进程处理函数声明
int main()&#123;
    union sigval val;
    val.sival_int=1;
    struct sigaction oldact,newact;
    int res;
    res=sem_init(&amp;sem_lock,0,1);
    if(res!=0)&#123;
        perror(&quot;信号量初始化失败&quot;);
    &#125;
    
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    sem_wait(&amp;sem_lock);
    printf(&quot;xxxx/n&quot;);
    value=1;
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);//sigqueue发送带参数的信号
    sem_post(&amp;sem_lock);
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);
    exit(0);
&#125;

void myhandler(int signo,siginfo_t *si,void *vcontext)&#123;
    if(sem_trywait(&amp;sem_lock)==0)&#123;
        value=0;
        sem_post(&amp;sem_lock);
    &#125;
&#125;
</code></pre>
<p>第一次发送sigqueue时，由于主函数持有锁，因此，sem_trywait返回－1，当第二次发送sigqueue时，主函数已经释放锁，此时就可以在信号处理函数中对临界资源加锁了。<br>但这种方法明显丢失了一个信号，不是很好的解决方法。</p>
<h2 id="3-利用双线程来解决主函数与信号处理函数死锁"><a href="#3-利用双线程来解决主函数与信号处理函数死锁" class="headerlink" title="3. 利用双线程来解决主函数与信号处理函数死锁"></a>3. 利用双线程来解决主函数与信号处理函数死锁</h2><p>我们知道，当进程收到一个信号时，会选择其中的某个线程进行处理，前提是这个线程没有屏蔽此信号。因此，可以在主线程中屏蔽信号，另选一个线程去处理这个信号。由于主线程与另外一个线程是平行执行的，因此，等待主线程执行完临界区时，释放锁，这个线程去执行信号处理函数，直到执行完毕释放临界资源。</p>
<p>这里用到一个线程的信号处理函数: pthread_sigmask</p>
<pre><code>int pthread_sigmask(int how,const sigset_t *set,sigset_t *oldset);
</code></pre>
<p>这个函数与sigprocmask很相似。<br>how的取值:<br>SIG_BLOCK 将信号集加入到线程的阻塞集中去<br>SIG_UNBLOCK 将信号集从阻塞集中删除<br>SIG_SETMASK 将当前集合设置为线程的阻塞集</p>
<p>示例: 利用双线程来解决主函数与信号处理函数之间的死锁</p>
<pre><code>void*thread_function(void *arg);//线程处理函数
void myhandler(int signo,siginfo_t *si,void *vcontext);//信号处理函数
int value;
sem_t semlock;
int main()&#123;
    int res;
    pthread_t mythread;
    void *thread_result;
    res=pthread_create(&amp;mythread,NULL,thread_function,NULL);//创建一个子线程
    if(res!=0)&#123;
        perror(&quot;线程创建失败&quot;);
    &#125;

    //在主线程中将信号屏蔽
    sigset_t empty;
    sigemptyset(&amp;empty);
    sigaddset(&amp;empty,SIGUSR1);
    pthread_sigmask(SIG_BLOCK,&amp;empty,NULL);

    //主线程中对临界资源的访问
    if(sem_init(&amp;semlock,0,1)!=0)&#123;
        perror(&quot;信号量创建失败&quot;);
    &#125;
    sem_wait(&amp;semlock);
    printf(&quot;主线程已经执行/n&quot;);
    value=1;
    sleep(10);
    sem_post(&amp;semlock);
    res=pthread_join(mythread,&amp;thread_result);//等待子线程退出
    exit(EXIT_SUCCESS);
&#125;

void *thread_function(void *arg)&#123;
    struct sigaction oldact,newact;
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    union sigval val;
    val.sival_int=1;
    printf(&quot;子线程睡眠3秒/n&quot;);
    sleep(3);
    sigqueue(getpid(),SIGUSR1,val);
    pthread_exit(0);//线程结束
&#125;

void myhandler(int signo,siginfo_t *si,void *vcontext)&#123;
    sem_wait(&amp;semlock);
    value=0;
    printf(&quot;信号处理完毕/n&quot;);
    sem_post(&amp;semlock);
&#125;
</code></pre>
<p>运行结果如下:</p>
<pre><code>主线程已经执行
子线程睡眠3秒
信号处理完毕
</code></pre>
<p>解释一下:<br>在主线线程中阻塞了SIGUSR1信号,首先让子线程睡眠3秒，目的让主线程先运行，然后当主线程访问临界资源时，让线程sleep(10),在这期间，子线程发送信号，此时子线程会去处理信号，而主线程依旧平行的运行，子线程被阻止信号处理函数的sem_wait处，等待主线程10后，信号处理函数得到锁，然后进行临界资源的访问。这就解决了主函数与信号处理函数之间的死锁问题。</p>
<p>扩展: 如果有多个信号到达时，还可以用多线程来处理多个信号，从而达到并行的目的，这个很好实现的，可以尝试一下。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux网络编程: IO多路复用之select、poll、epoll</title>
    <url>/2020/12/07/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>I&#x2F;O多路复用：通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<p>但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>IO多路复用适用如下场合：</p>
<ul>
<li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li>
</ul>
<p>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p>
<h1 id="select实现"><a href="#select实现" class="headerlink" title="select实现"></a>select实现</h1><p>逻辑时序：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401453.png" alt="1"><br>具体实现：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401118.png" alt="2"></p>
<p>fd_set(监听的端口个数)：32位机默认是1024个，64位机默认是2048。</p>
<p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间<br>（2）注册回调函数__pollwait<br>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）<br>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。<br>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。<br>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。<br>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。<br>（8）把fd_set从内核空间拷贝到用户空间。</p>
<p>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024</p>
<h1 id="poll实现"><a href="#poll实现" class="headerlink" title="poll实现"></a>poll实现</h1><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，而使其没有连接数的限制。其他的都差不多。</p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401522.png" alt="3"></p>
<h2 id="epoll的几大改进"><a href="#epoll的几大改进" class="headerlink" title="epoll的几大改进"></a>epoll的几大改进</h2><p>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。<br>每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中。<br>而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。即epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关。</p>
<p>对于第三个缺点，epoll没有这个限制。<br>它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看,一般来说这个数目和系统内存关系很大。</p>
<h2 id="epoll小结："><a href="#epoll小结：" class="headerlink" title="epoll小结："></a>epoll小结：</h2><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。<br>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<h1 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h1><ol>
<li><p>支持一个进程所能打开的最大连接数<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051402990.png" alt="4"></p>
</li>
<li><p>FD剧增后带来的IO效率问题<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051402536.png" alt="5"></p>
</li>
<li><p>消息传递方式<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051403370.png"></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p>
<ul>
<li>连接数多，活跃链接占比不高的场景下，epoll的性能最好</li>
<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>
<li>select低效是因为每次它都需要轮询。但低效也是相对的，可通过良好的设计改善。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux进程的内存分布和进程IPC</title>
    <url>/2020/11/15/%E6%B5%85%E8%B0%88Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9B%E7%A8%8BIPC/</url>
    <content><![CDATA[<h1 id="Linux虚拟内存空间分布"><a href="#Linux虚拟内存空间分布" class="headerlink" title="Linux虚拟内存空间分布"></a>Linux虚拟内存空间分布</h1><p>（1）虚拟内存空间与物理内存：<br>带MMU控制器的CPU支持将物理内存以分页的方式，细粒度的动态分配给进程，使每个进程只看得到这个虚拟的内存空间，每个进程认为自己可以访问整个内存空间。进程根本不知道其访问的某个内存页的实际物理地址，也许在SDRAM上，或者硬盘的交换分区上。</p>
<p>进程的虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每个进程都拥有一套属于它自己的页表。</p>
<p>（2）下面讨论用户进程能看到什么样的虚拟内存空间：</p>
<p>以32位系统为例，CPU可寻址4GB的内存空间。此时虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分：</p>
<ul>
<li>将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。</li>
<li>将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间</li>
</ul>
<p>因为每个进程可以通过<strong>系统调用</strong>进入内核，因此，Linux内核由系统内的所有进程共享。从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051156842.png" alt="image-20221205115648795"></p>
<p>注意：</p>
<ul>
<li>内核可见的内存空间只有全局的1GB; 用户进程可见的内存空间包括该进程独有的3GB空间，和全局内核的1GB;</li>
<li>用户进程虽然可见内核空间的1GB，但不可直接访问，要通过系统调用（或中断等方式），涉及上下文切换；</li>
<li>当进程访问内核空间时，称为“进入内核态”，返回时称为“进入用户态”；</li>
<li>内核空间分布在虚拟内存空间的高地址，用户空间在低地址</li>
</ul>
<p>（3）用户进程的内部空间详解</p>
<p>编译好的程序都分为几个段(section)，在程序运行过程中的临时变量还产生堆栈，程序手动分配的内存使用堆, 还有命令行参数和环境变量等配置信息，这些东西都属于进程空间的数据。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051159094.png" alt="image-20221205115908003"></p>
<p>详解如下：<br>代码段(Text):存放程序指令，一些只读数据(.rodata)也可归为此类<br>数据段(Data):存放初始化过的全局数据<br>BSS段:存放未初始化(默认为0)的全局数据<br>栈 (Stack): 用于控制函数调用和返回过程中的临时变量，存储函数内的临时变量; 存储函数的返回指针，<br>堆 (Heap):存储动态内存分配, 需要程序员手工分配, 手工释放。注意与数据结构中的堆(优先队列)是不同，分配方式类似于链表。</p>
<h1 id="Linux进程间通信-IPC"><a href="#Linux进程间通信-IPC" class="headerlink" title="Linux进程间通信(IPC)"></a>Linux进程间通信(IPC)</h1><p>进程本身是为了隔离程序的资源，但不同程序间可能有数据通信或调用关系，因此需要进程通信机制。</p>
<p>进程通信最主要的几种方式有：管道(pipe) , 共享内存(shared memory), 消息队列(message queue), socket等。为了进程间的时序同步和资源处理，信号量(semaphore)通常配合使用。</p>
<p>本节重点讲管道和共享内存，关于Linux IPC 的全面内容，参考：<br><a href="http://www.cs.fsu.edu/~zwang/files/cop4610/Fall2016/linux-ipc.pdf">An introduction to Linux IPC</a><br><a href="https://opensource.com/sites/default/files/gated-content/inter-process_communication_in_linux.pdf">inter-process_communication_in_linux</a></p>
<h2 id="进程通信的基本思路"><a href="#进程通信的基本思路" class="headerlink" title="进程通信的基本思路"></a>进程通信的基本思路</h2><p>根据上节的内存空间分布，所有进程共享同一个内核空间，最简单的进程通信就是通过 进程A-&gt;内核-&gt;进程B：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157104.png" alt="1637063328269_12"></p>
<p>以上虽然可以实现，但有两次拷贝以及上下文切换，其总体思路是管道和共享内存方式的基础。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道的实质就是一个内核缓冲区；<br>管道对于管道两端的进程而言就是一个文件，与普通文件的区别是管道只存在于内存中；<br>进程通过读写管道文件，传递数据；</p>
<p>管道依据是否有名字分为匿名管道和命名管道，其功能有以下区别：<br>匿名管道(通常管道就是指匿名管道)：</p>
<ul>
<li>半双工的，即管道设置好后，数据只能从进程A到进程B；如果还需要从B到A,需要创建另外的管道</li>
<li>只能用于父子进程或兄弟进程之间的通信</li>
</ul>
<p>命名管道(FIFO)：</p>
<ul>
<li>可用于无关联进程的通信，其基本原理和匿名管道一样，本节不详细描述</li>
</ul>
<p>管道内部提供了同步机制<br>临界资源： 大家都能访问到的共享资源<br>临界区： 对临界资源进行操作的代码<br>同步： 临界资源访问的可控时序性（一个操作完另一个才可以操作）<br>互斥： 对临界资源同一时间的唯一访问性（保护临界资源安全）</p>
<h3 id="匿名-管道使用三部曲"><a href="#匿名-管道使用三部曲" class="headerlink" title="(匿名)管道使用三部曲"></a>(匿名)管道使用三部曲</h3><p>1.创建本进程的管道<br>使用pipe函数创建管道文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157310.png" alt="image-20221205115729244"></p>
<p>2.fork子进程，共享管道<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157031.png" alt="image-20221205115734973"></p>
<p>3.设置管道为单向<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157508.png" alt="image-20221205115744442"></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>Linux中每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。</p>
<p>两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。</p>
<p>共享内存的通信原理：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157936.png" alt="image-20221205115751869"></p>
<p>共享内存的关键是一份内存资源被两个进程占用，因此需要信号量等同步机制，实现进程同步与资源互斥。</p>
<p>这里简单说明我对信号量的理解：</p>
<ul>
<li>信号量的作用是“流程同步”，这个流程可以是两个进程访问共享内存，也可以是同一进程内的多个线程访问共享数据；</li>
<li>注意，信号量并不一定用于共享资源的情景，可能只是简单的主线程等待工作线程这种情况。这是其和互斥锁的关键区别；</li>
<li>信号量如果用于共享资源，其本质是“引用计数”，即共享资源是否可用的计数，计数为0表示无资源可用。各进程如果获得资源计数-1，释放资源计数+1。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/cl_linux/article/details/80328608">Linux进程地址空间和进程的内存分布</a><br><a href="http://www.cs.fsu.edu/~zwang/files/cop4610/Fall2016/linux-ipc.pdf">An introduction to Linux IPC</a><br><a href="https://opensource.com/sites/default/files/gated-content/inter-process_communication_in_linux.pdf">inter-process_communication_in_linux</a><br><a href="https://www.cnblogs.com/huansky/p/13170125.html#:~:text=Linux%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B8%BB%E8%A6%81%E6%9C%89%EF%BC%9A%E7%AE%A1%E9%81%93%20%28pipe%29,%28%E5%8C%85%E6%8B%AC%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%29%E3%80%81%E4%BF%A1%E5%8F%B7%20%28signal%29%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%28queue%29%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%82">Linux 进程间通信（IPC）总结</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux网络编程: Socket基础</title>
    <url>/2020/10/30/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Socket%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="套接字（socket）基础"><a href="#套接字（socket）基础" class="headerlink" title="套接字（socket）基础"></a>套接字（socket）基础</h1><p>套接字是网络编程中，应用层和传输层之间的数据结构，其作用如下:<br>应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字(Socket)的接口，以区分不同应用程序进程间的网络通信和连接。</p>
<h1 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h1><p>通用套接字地址的结构体sockaddr定义如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411648.png" alt="1"><br>在以太网中，不直接使用sockaddr结构体，而使用sockaddr_in,其定义如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411109.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411045.png" alt="3"></p>
<p>通用结构体sockaddr和以太网的sockaddr_in结构体，有点像C++中的父类和子类的关系，sockaddr_in是对sockaddr的细化，其存储结构大小相同，分布如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411360.png" alt="4"><br>由于大小相同，在设置socket地址时，一般先设置sockaddr_in结构体，然后强转为sockaddr类型</p>
<h1 id="套接字地址结构在用户层和内核层的交互"><a href="#套接字地址结构在用户层和内核层的交互" class="headerlink" title="套接字地址结构在用户层和内核层的交互"></a>套接字地址结构在用户层和内核层的交互</h1><p>sockaddr的使用，以socket流程中的bind()函数为例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411733.png" alt="5"><br>bind函数需要传入sockaddr结构体的指针，和sockaddr结构体的长度</p>
<h2 id="向内核传入数据"><a href="#向内核传入数据" class="headerlink" title="向内核传入数据"></a>向内核传入数据</h2><p>向内核传入数据的socket函数有：bind,send<br>传入过程如下：</p>
<ul>
<li>sockaddr结构体的长度，以传值方式传入内核</li>
<li>内核通过sockaddr结构体的指针以及结构体长度，以内存复制的方式，从用户层拷贝sockaddr结构体到内核层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411951.png" alt="6"></p>
<h2 id="从内核获取数据"><a href="#从内核获取数据" class="headerlink" title="从内核获取数据"></a>从内核获取数据</h2><p>从内核得到数据的socket函数有：accept,recv</p>
<ul>
<li>sockaddr结构体的长度，以传值方式传入内核</li>
<li>内核通过sockaddr结构体的指针以及结构体长度，以内存复制的方式，从内核层拷贝sockaddr结构体到用户层。</li>
<li>内核返回内核的结构体的长度<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412551.png" alt="7"><h1 id="Socket编程流程"><a href="#Socket编程流程" class="headerlink" title="Socket编程流程"></a>Socket编程流程</h1><h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2>TCP编程主要为C&#x2F;S模式，即服务器和客户端编程，我们讲socket编程，要区分是服务器端的流程还是客户端的流程。</li>
<li>服务器端：创建服务-等待客户端连接-收到连接请求-处理</li>
<li>客户端：发起对服务器的连接请求-根据服务器的响应做处理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412551.png"></p>
<p>服务端各函数含义:</p>
<ul>
<li>socket：套接字初始化</li>
<li>bind：绑定套接字和端口</li>
<li>listen：配置服务器的请求队列，监测连接请求</li>
<li>accept：接受客户端连接</li>
<li>read&#x2F;write：数据的接收、发送</li>
<li>close：断开连接，释放套接字</li>
</ul>
<p>客户端函数：</p>
<ul>
<li>客户端套接字不需要绑定端口和监听，直接connect发起连接请求，其他函数和服务端一致。</li>
</ul>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>socket函数用于创建socket套接字的文件描述符，</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412223.png" alt="9"></p>
<p>有三个入参：</p>
<ul>
<li>domain：域，区分本地，IPV4 Internet，IPV6 Internet等。有的以PF开头，有的以AF开头，这两者值一样。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412180.png" alt="10"></p>
<ul>
<li>type：通信类型，如流式（TCP）,数据报式（UDP）等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412975.png" alt="11"></p>
<ul>
<li>protocal：协议类型，指定通信类型中的子类型，一般为0</li>
</ul>
<p>socket套接字初始化的一个例子：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412776.png" alt="12"></p>
<h2 id="socket函数在应用层和内核层的交互"><a href="#socket函数在应用层和内核层的交互" class="headerlink" title="socket函数在应用层和内核层的交互"></a>socket函数在应用层和内核层的交互</h2><p>用户调用的socket函数，会调用内核的sys_socket函数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051415958.png" alt="2"></p>
<p>sys_socket做两件事：</p>
<ul>
<li><p>sock_create生成内核的socket结构，和应用层的结构不同，如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413920.png" alt="13"></p>
</li>
<li><p>sock_map_fd将内核socket结构绑定文件描述符fd,用户层可通过fd访问内核socket结构</p>
</li>
</ul>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>服务端用socket函数建立套接字文件描述符后，需要绑定地址和端口到该文件描述符，才能接受客户端请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413732.png" alt="14"></p>
<ul>
<li>sockfd：socket函数创建的文件描述符</li>
<li>sockaddr结构的指针：指向的sockaddr结构，包含ip和port等信息</li>
<li>addrlen：即sizeof(struct sockaddr)</li>
</ul>
<p>bind函数绑定UNIX族的套接字：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413483.png" alt="15"></p>
<p>bind函数绑定AF_INET族的套接字:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413289.png" alt="16"></p>
<h2 id="bind函数在应用层和内核层的交互"><a href="#bind函数在应用层和内核层的交互" class="headerlink" title="bind函数在应用层和内核层的交互"></a>bind函数在应用层和内核层的交互</h2><p>以AF_INET族的套接字绑定为例，不同协议族实际上是调用内核不同的绑定函数<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051418474.png" alt="image-20221205141814380"></p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>listen函数用于初始化服务器的可连接队列，即服务器处理客户的请求，不是并行处理，而是异步的串行处理。服务器建立可连接队列，将当前不能同步处理的新请求放到队列中，等队列前面的请求处理完了，才异步处理这个请求。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051414568.png" alt="18"></p>
<ul>
<li>backlog是服务器可连接队列的最大长度</li>
<li>当前队列没满，即当前队列的请求没超过backlog值，才可以调用accept</li>
<li>listen函数只针对SOCK_STREAM和SOCK_SEQPACKET才能调用，因为TCP请求才需要建立连接。对于SOCK_DGRAM不支持listen，因为UDP是无连接的。</li>
</ul>
<p>TCP连接中，SOCK_STREAM类型的套接字，调用listen的示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419762.png" alt="image-20221205141912644"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419995.png" alt="image-20221205141921877"></p>
<h2 id="listen函数在应用层和内核层的交互"><a href="#listen函数在应用层和内核层的交互" class="headerlink" title="listen函数在应用层和内核层的交互"></a>listen函数在应用层和内核层的交互</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419209.png" alt="image-20221205141934130"></p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>服务端用listen建立连接队列后，客户端以connect发来一个请求，会加入到服务端连接队列的队尾，当这个请求到达队头，会调用accept真正处理该请求。<br>accept会创建一个新的套接字文件描述符，用来描述客户端的连接，这个时候会有两个套接字描述符并存：</p>
<ul>
<li>socket函数创建的老的sockfd，表示正在监听的ip和端口</li>
<li>accept函数创建的新的clientfd，表示当前的客户端连接，后续的客户端的收发和客户端关闭，即send，recv，close函数，都使用clientfd</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420456.png" alt="image-20221205142030402"></p>
<p>流式连接的accept示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420563.png" alt="image-20221205142038423"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420232.png" alt="image-20221205142048069"></p>
<h2 id="accept函数在应用层和内核层的交互"><a href="#accept函数在应用层和内核层的交互" class="headerlink" title="accept函数在应用层和内核层的交互"></a>accept函数在应用层和内核层的交互</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051421941.png" alt="image-20221205142100841"></p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>connect函数是客户端调用的函数，在客户端调用socket函数创建套接字文件sockfd后，可调用connect函数向服务端发起连接请求，请求的ip和端口信息包含在sockaddr结构体内。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051422137.png" alt="image-20221205142256082"></p>
<p>客户端的socket connect示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051422137.png"></p>
<h2 id="connect函数在应用层和内核层的交互"><a href="#connect函数在应用层和内核层的交互" class="headerlink" title="connect函数在应用层和内核层的交互"></a>connect函数在应用层和内核层的交互</h2><p>根据数据流式或数据报式的请求，具体调用inet_stream_connect或inet_dgram_connect<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423142.png" alt="image-20221205142315046"></p>
<h2 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h2><p>服务端和客户端真正建立连接后（socket通信逻辑连接，不是TCP&#x2F;UDP的面向连接&#x2F;无连接的传输层连接），即客户端发起connect，服务端accept完成，双方就可以相互read&#x2F;write，读写对方的数据，通过sockfd文件描述符，就像读写本地文件一样。</p>
<ul>
<li>read：从套接字文件读取数据，写入本地缓冲区，返回非空的有效数据大小<br> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423066.png" alt="image-20221205142328017"></li>
<li>write：向套接字文件写入数据，将本地缓冲区数据写入socket函数创建的socket文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423066.png"></li>
</ul>
<h2 id="close和shutdown函数"><a href="#close和shutdown函数" class="headerlink" title="close和shutdown函数"></a>close和shutdown函数</h2><ul>
<li>close：关闭socket连接，释放内核的套接字资源，不能通过套接字文件来读写操作</li>
<li>shutdown：支持读写的单向关闭，即关闭套接字文件的读、写、或者读写能力（等同于close）</li>
</ul>
<h1 id="Socket客户端和服务端交互的例程"><a href="#Socket客户端和服务端交互的例程" class="headerlink" title="Socket客户端和服务端交互的例程"></a>Socket客户端和服务端交互的例程</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>客户端从标准输入读取用户输入的字符串，发送给服务端，服务端读取数据，回写这些数据到客户端，客户端收到数据后输出到标准输出。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423842.png" alt="image-20221205142345794"></p>
<p>客户端和服务端可以在同一台机器部署，访问回环地址127.0.0.1即可，注意服务端的监听端口不能和其他进程的端口冲突。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>服务端代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
//#define PORT 8088                        /*侦听端口地址*/
#define BACKLOG 2                        /*侦听队列长度*/

int main(int argc, char *argv[])
&#123;
    int ss,sc;        /*ss为服务器的socket描述符，sc为客户端的socket描述符*/
    struct sockaddr_in server_addr;    /*服务器地址结构*/
    struct sockaddr_in client_addr;    /*客户端地址结构*/
    int err;                            /*返回值*/
    pid_t pid;                            /*分叉的进行ID*/

    /*建立一个流式套接字*/
    ss = socket(AF_INET, SOCK_STREAM, 0);
    if(ss &lt; 0)&#123;                            /*出错*/
        printf(&quot;socket error\n&quot;);
        return -1;    
    &#125;
    
    /*设置服务器地址*/
    bzero(&amp;server_addr, sizeof(server_addr));            /*清零*/
    server_addr.sin_family = AF_INET;                    /*协议族*/
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    /*本地地址*/
    //server_addr.sin_port = htons(PORT);
    server_addr.sin_port = htons(atoi(argv[1]));        /*服务器端口*/
    
    /*绑定地址结构到套接字描述符*/
    err = bind(ss, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));
    if(err &lt; 0)&#123;/*出错*/
        printf(&quot;bind error\n&quot;);
        return -1;    
    &#125;
    
    /*设置侦听*/
    err = listen(ss, BACKLOG);
    if(err &lt; 0)&#123;                                        /*出错*/
        printf(&quot;listen error\n&quot;);
        return -1;    
    &#125;
    
        /*主循环过程*/
    for(;;)    &#123;
        socklen_t addrlen = sizeof(struct sockaddr);
        /*接受客户端连接*/
        sc = accept(ss, (struct sockaddr*)&amp;client_addr, &amp;addrlen); 
        if(sc &lt; 0)&#123;                            /*出错*/
            continue;                        /*结束本次循环*/
        &#125;    
        
        /*建立一个新的进程处理到来的连接*/
        pid = fork();                        /*分叉进程*/
        if( pid == 0 )&#123;                        /*子进程中*/
            process_conn_server(sc);        /*处理连接*/
            close(ss);                        /*在子进程中关闭服务器的侦听*/
        &#125;else&#123;
            close(sc);                        /*在父进程中关闭客户端的连接*/
        &#125;
    &#125;
&#125;
</code></pre>
<p>服务端注意几点:</p>
<ul>
<li>accept后处理连接的过程，是在子进程中处理的，使用fork创建子进程用于连接处理。根据fork返回的pid是0还是其他，判断当前调度到子进程还是父进程，从全局上来讲，这个<code>if-else</code>的两种流程分别在父进程和子进程中指向。</li>
<li>服务端有两个套接字：侦听套接字和连接套接字。处理连接传入的是连接套接字。</li>
<li>在父进程（侦听进程）中，要关闭连接套接字；在子进程（连接处理进程）中，要关闭侦听套接字。这是为了避免子父进程相互影响。</li>
<li>对于多进程，一个进程的套接字关闭不会释放该套接字内存，只有所有进程都关闭了这个套接字，内核才会 释放该套接字，所有可以放心在侦听进程和连接处理进程中，关闭对方的套接字。</li>
</ul>
<p>客户端代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
//#define PORT 8088                                /*侦听端口地址*/

int main(int argc, char *argv[])
&#123;
    int s;                                        /*s为socket描述符*/
    struct sockaddr_in server_addr;            /*服务器地址结构*/
    
    s = socket(AF_INET, SOCK_STREAM, 0);         /*建立一个流式套接字 */
    if(s &lt; 0)&#123;                                    /*出错*/
        printf(&quot;socket error\n&quot;);
        return -1;
    &#125;    
    
    /*设置服务器地址*/
    bzero(&amp;server_addr, sizeof(server_addr));    /*清零*/
    server_addr.sin_family = AF_INET;                    /*协议族*/
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    /*本地地址*/
    server_addr.sin_port = htons(atoi(argv[2]));        /*服务器端口*/
    
    /*将用户输入的字符串类型的IP地址转为整型*/
    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);    
    /*连接服务器*/
    connect(s, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr));
    process_conn_client(s);                        /*客户端处理过程*/
    close(s);                                    /*关闭连接*/
    return 0;
&#125;
</code></pre>
<p>建立连接后的读写交互代码，包含服务端的调用和客户端的调用：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
/*客户端的处理过程*/
void process_conn_client(int s)                    /* 传入的是客户端调用socket时创建的s */
&#123;
    ssize_t size = 0;
    char buffer[1024];                            /*数据的缓冲区*/
    
    for(;;)&#123;                                    /*循环处理过程*/
        /*从标准输入中读取数据放到缓冲区buffer中,标准输入：0，标准输出：1，标准错误：2*/
        size = read(0, buffer, 1024);
        if(size &gt; 0)&#123;                            /*读到数据*/
            write(s, buffer, size);                /*发送给服务器*/
            /*客户端阻塞，等待服务器有数据可读*/
            size = read(s, buffer, 1024);        /*从服务器读取数据*/
            write(1, buffer, size);                /*写到标准输出*/
        &#125;
    &#125;    
&#125;
/*服务器对客户端的处理*/
void process_conn_server(int s)                 /* 传入的是服务端调用accept时创建的sc */
&#123;
    ssize_t size = 0;
    char buffer[1024];                            /*数据的缓冲区*/
    
    for(;;)&#123;                                    /*循环处理过程*/        
        size = read(s, buffer, 1024);            /*从套接字中读取数据放到缓冲区buffer中*/
        if(size == 0)&#123;                            /*没有数据*/
            return;    
        &#125;
        
        /*构建响应数据*/
        //sprintf(buffer, &quot;server receive %d bytes from client\n&quot;, size);
        //write(s, buffer, strlen(buffer));
        write(s, buffer, size);                    /*发回给客户端*/
    &#125;    
&#125;
</code></pre>
<p>Makefile编译脚本:</p>
<pre><code>all:client server                    #all规则，它依赖于client和server规则

client:tcp_process.o tcp_client.o    #client规则，生成客户端可执行程序
    gcc -o client tcp_process.o tcp_client.o
server:tcp_process.o tcp_server.o    #server规则，生成服务器端可执行程序
    gcc -o server tcp_process.o tcp_server.o    
tcp_process.o:                        #tcp_process.o规则，生成tcp_process.o
    gcc -c tcp_process.c -o tcp_process.o
clean:                                #清理规则，删除client、server和中间文件
    rm -f client server *.o
</code></pre>
<h2 id="部署和运行"><a href="#部署和运行" class="headerlink" title="部署和运行"></a>部署和运行</h2><p>后台运行server,指定监听端口:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424795.png" alt="image-20221205142401747"><br>运行client，指定服务端的ip, port：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424795.png"><br>客户端每输入一个字符串，服务端返回完全相同的字符串，通信正常<br>如果运行服务端时，有bind error，可能是端口被占用，<code>netstat</code>找到占用端口的PID，kill之后再运行server<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424796.png" alt="image-20221205142416741"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈信号完整性和ReDriver</title>
    <url>/2023/04/10/%E6%B5%85%E8%B0%88%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8CReDriver/</url>
    <content><![CDATA[<h2 id="信号完整性"><a href="#信号完整性" class="headerlink" title="信号完整性"></a>信号完整性</h2><p>在讨论ReDriver之前，先说明信号完整性（Signal Integrity, SI）的相关背景。<br>电子信号在传输过程中(无线或有线)都会受到环境噪声干扰，信号功率也会随着传输距离衰减(signal attenuation)。<br>通信系统中用信噪比表达的信号的好坏:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信噪比(dB)=10*log（信号/噪音）</span><br></pre></td></tr></table></figure>

<ul>
<li>当信噪比大于设备接收灵敏度时，信号能被正常接收和解析（成逻辑0&#x2F;1）</li>
<li>当信噪比小于设备接收灵敏度时，信号被错误解析（错误的逻辑0&#x2F;1）或者是根本解析不出信号(噪声完全淹没信号，接收端恒为0或1，没有信号变化)。</li>
</ul>
<p>信号完整性（Signal Integrity, SI）一般指PCB电路中的电压信号的信噪比好坏。如果电路中信号能够以要求的时序、持续时间和电压幅度到达接收器，则该电路具有较好的信号完整性。反之当信号不能正常响应时，就出现了信号完整性问题。一般通过眼图观测信号完整性好坏。</p>
<p>信号完整性在高速电路更容易出问题，表现为信号有传输延迟和时序错误、电路串扰（电容性、电感性串扰）等。</p>
<p>高速信号的PCB电路设计和信号完整性密切相关，例如下图是PCB使用FR4材料和Megtron6材料，信号-频率函数显示衰减度不同。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101118830.png" alt="Attenuation versus Frequency as a function of PCB material"></p>
<h2 id="ReDriver"><a href="#ReDriver" class="headerlink" title="ReDriver"></a>ReDriver</h2><p>Redriver能减弱信号在远距离、高噪声环境的传输中的信号完整性问题对接收端的影响。</p>
<p>Redriver类似通信系统中的基站，其接收传输线路中的信号，重新生成原始信号，再转发给远端设备；其输出信号基本和原始信号完全一致以保证接收端能正常解析信号。</p>
<p>(1)PCIe redriver</p>
<p>以典型的高速信号PCIe接口为例，其使用Redriver和Retimer提高信号完整性，参考：<a href="https://www.allaboutcircuits.com/industry-articles/choosing-the-right-redriver-or-retimer-device-to-extend-pcie-protocol-signal-range/">Choosing the Right Redriver or Retimer Device to Extend PCIe Protocol Signal Range</a></p>
<p>其RX, EQ接收PCIe信号源的TX, EQ信号，redrive生成原始信号后再从TX, EQ发送给接收端。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101126665.png" alt="Single lane redriver block diagram"></p>
<p>(2)USB redriver</p>
<p>以多层子设备结构的USB接口为例，其使用Redriver提高子USB host的驱动能力，参考 <a href="https://www.diodes.com/zh/products/connectivity-and-timing/redrivers-repeaters/">信号完整性 - ReDriver&#x2F; 信号中继器 &#x2F; 调节器</a></p>
<p><img src="https://www.diodes.com/assets/Uploads/redrivers-application2__ResizedImageWzYwMCwzNTFd.png" alt="redrivers application2"></p>
<p>(3)SD redriver</p>
<p>即使是较低速的SD接口(MB&#x2F;s级别)也有PCB设计和传输距离引起的信号完整性问题，也需要redriver解决。</p>
<p>如下SD redriver接收SD host的几个信号并重新生成：SD clock, SD cmd, SD data, Vdd power。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101130119.png" alt="image-20230410113046013"></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>ReDriver</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈加密和编码：MD5</title>
    <url>/2022/01/25/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9AMD5/</url>
    <content><![CDATA[<h1 id="1-MD5简介"><a href="#1-MD5简介" class="headerlink" title="1.MD5简介"></a>1.MD5简介</h1><p>MD5的全称是Message-Digest Algorithm 5（<strong>信息摘要算法</strong>），经MD2、MD3和MD4发展而来。<br>所谓信息摘要，就是包含数据关键特性，能（唯一）识别原数据的关键信息。</p>
<p>MD5也称为<strong>单向散列算法</strong>，这是从其实现方式命名，因为：</p>
<ul>
<li>MD5能对大量数据，进行哈希映射，输出固定长度(128bit)的数据，输出数据也称为原数据的信息摘要。</li>
<li>不能由摘要推测出原数据，即MD5算法是单向的，当加密来用的话，只能加密不能解密。</li>
</ul>
<p>MD5的特点：</p>
<ul>
<li>固定长度：输入任意长度的信息，经过MD5处理，输出总是128位的信息。</li>
<li>唯一性：不同的输入得到的不同的结果；同样的输入一定得到相同的结果。</li>
<li>不可逆：根据128位的输出结果不可能反推出输入的信息。</li>
</ul>
<h1 id="2-MD5的应用"><a href="#2-MD5的应用" class="headerlink" title="2.MD5的应用"></a>2.MD5的应用</h1><p>1、防止被篡改：<br>1）比如A和B发送一个电子文档，发送前，A先自己计算出数据的MD5输出结果a。<br>然后在B收到电子文档后，B计算得到一个MD5的输出结果b。<br>如果a与b一样就代表传输中途数据未被篡改。<br>2）比如A提供文件下载，为了防止不法分子在文件中添加木马，伪装成A的文件。A可以在网站上公布由安装文件得到的MD5输出结果。<br>要下载文件的人只需要下载后，验证MD5是否和A一致，如果不一致，就是被其他人修改过。</p>
<p>2、防止暴露明文：<br>基本上存储用户密码的场景，都用到MD5加密明文。<br>1）例如网站服务器在其数据库存储用户的密码，都是存储用户密码的MD5值。就算不法分子得用户密码的MD5值，也无法知道用户的密码。<br>2）在UNIX、Linux系统中，用户密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。</p>
<p>3、防止抵赖（数字签名）：<br>这需要一个存储MD5值的第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。</p>
<h1 id="3-MD5算法实现"><a href="#3-MD5算法实现" class="headerlink" title="3.MD5算法实现"></a>3.MD5算法实现</h1><p>对MD5算法简要的叙述可以为：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<p>第一步、填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N<em>512+448(bit)；<br>第二步、记录信息长度：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N</em>512+448+64&#x3D;(N+1)*512位。<br>第三步、装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A&#x3D;(01234567) 16 ，B&#x3D;(89ABCDEF) 16 ，C&#x3D;(FEDCBA98) 16 ，D&#x3D;(76543210) 16 ）。如果在程序中定义应该考虑大小端（A&#x3D;0X67452301L，B&#x3D;0XEFCDAB89L，C&#x3D;0X98BADCFEL，D&#x3D;0X10325476L）。<br>第四步、四轮循环运算：循环的次数是分组的个数（N+1）。 最终由4个32bit数据拼成128bit的结果。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121430277.png" alt="image-20221212143002209"></p>
<h1 id="4-MD5的安全性"><a href="#4-MD5的安全性" class="headerlink" title="4.MD5的安全性"></a>4.MD5的安全性</h1><p>普遍认为MD5是很安全，因为哈希散列是强抗碰撞的：已知原数据和其MD5值，想通过枚举找到一个相同MD5值的数据，基本不可能。如果暴力破解MD5，其运算时间是不可想象的。</p>
<p>但是实际应用上，如果把用户密码仅仅MD5处理后再存储到数据库，其实是很不安全的。因为用户的密码的固有特征，让枚举集合变小了许多，原因：</p>
<ul>
<li>用户密码是比较短的一般8位左右。</li>
<li>很多用户的密码有规律，例如使用生日，手机号码，或者使用常用数字组合，或某个英文单词。</li>
<li>许多用户的常用密码只有一个，也就是说，泄漏了微信的密码，也很有可能QQ,支付宝密码也泄漏了</li>
</ul>
<p>如果把常用的密码先MD5处理后存储结果，然后再跟用户的MD5结果匹配，这时就有较大概率“碰撞”，得到明文。这种预先存储的MD5表称为rainbow-table。<br>因此MD5作为“信息摘要”的用途多一些，作为加密，还需要配合其他的算法（例如AES等几种公钥算法），或者“加盐”。<br>安全性比较好的网站，都会用一种叫做 “加盐”(salt)的方式来存储密码:</p>
<ul>
<li>先将用户输入的密码进行一次MD5（或其它哈希算法）加密。</li>
<li>将得到的MD5值前后加上一些只有管理员自己知道的随机串，再进行一次MD5加密。</li>
<li>这个随机串中可以包括某些固定的串，也可以包括用户名（用来保证每个用户加密使用的密钥都不一样）。</li>
<li>在管理员和用户的两个salt没有泄露的情况下，黑客拿到加密串，就几乎不可能推算出原始的密码是什么了。</li>
</ul>
<h1 id="5-MD5库"><a href="#5-MD5库" class="headerlink" title="5.MD5库"></a>5.MD5库</h1><p>在涉及到文件传输的场景，通常用MD5校验文件的一致性，openSSL库提供MD5计算函数：</p>
<p><a href="https://www.openssl.org/docs/man3.0/man3/MD5_Update.html">MD5_Update</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int MD5_Init(MD5_CTX *c);</span><br><span class="line">int MD5_Update(MD5_CTX *c, const void *data, unsigned long len);</span><br><span class="line">int MD5_Final(unsigned char *md, MD5_CTX *c);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>encrypt</category>
      </categories>
      <tags>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈加密和编码：base64</title>
    <url>/2022/01/22/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9Abase64/</url>
    <content><![CDATA[<h1 id="1-什么是编码解码"><a href="#1-什么是编码解码" class="headerlink" title="1.什么是编码解码"></a>1.什么是编码解码</h1><p>编码：利用特定的算法，对原始内容进行处理，生成运算后的内容，形成另一种数据的表现形式，可以根据算法，再还原回来，这种操作称之为编码。<br>解码：利用编码使用的算法的逆运算，对经过编码的数据进行处理，还原出原始数据，这种操作称之为解码。</p>
<h1 id="2-什么是Base64编码算法"><a href="#2-什么是Base64编码算法" class="headerlink" title="2.什么是Base64编码算法"></a>2.什么是Base64编码算法</h1><p>将任意的字节数组数据，通过Base64算法，生成只有（大小写英文、数字、+、&#x2F;）（一共64个字符）内容表示的字符串数据。即将任意的内容转换为可见的字符串形式。</p>
<h1 id="3-为什么需要Base64编码"><a href="#3-为什么需要Base64编码" class="headerlink" title="3.为什么需要Base64编码"></a>3.为什么需要Base64编码</h1><p>Base64算法最开始是被用于解决电子邮件数据传输问题。以前发送邮件只支持可见字符的传送，但ASCII码中，有一部分不支持直接显示。由此，需要有一个方法将不可见的字符转换为可见的字符，便产生了Base64编码算法。</p>
<h1 id="4-Base64算法的实现"><a href="#4-Base64算法的实现" class="headerlink" title="4.Base64算法的实现"></a>4.Base64算法的实现</h1><p>特点：</p>
<ul>
<li>将数据按照 3个字节一组的形式进行处理，每三个字节在编码之后被转换为4个字节。即：如果一个数据有6个字节，可编码后将包含6&#x2F;3*4&#x3D;8个字节</li>
<li>当数据的长度无法满足3的倍数的情况下，最后的数据需要进行填充操作，即补“&#x3D;” ，这里“&#x3D;”是填充字符，不要理解为第65个字符。因此我们经常看见base64编码的字符串结尾有几个”&#x3D;”号</li>
</ul>
<p>示例：</p>
<p> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121437191.png" alt="image-20221212143753149"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121438580.png" alt="image-20221212143830525"></p>
<p>上面示例将原始数据的每三个字节分为一组，按位进行分割为每6位一个字节的形式，进行转换，形成新的4个字节。空缺的两个bit用0填补。<br>这四个字节才通过Base64编码表进行映射，形成最后实际的Base64编码结果。<br>如果原始数据最后无法凑成3个字节，则以“&#x3D;”填充。</p>
<p>注：上图中的1234567表示bit的位置，不是bit的值。</p>
<p>将字符串”ABC”进行Base64编码流程如下。</p>
<p>1.使用ASCII编码方式将字符串”ABC”转换成二进制数据 01000001 | 01000010 | 01000011<br>2.将步骤1的二进制数据进行分组，每个分组6bit 010000 | 010100 | 001001 | 000011<br>3.将步骤2的4组6bit二进制编码数据进行补位（高位补0），变成4组8bit二进制 00010000 | 00010100 | 00001001 | 00000011<br>4.将步骤3中的4组8bit转换成十进制。16 | 20 | 9 | 3<br>5.以步骤4的十进制数据为索引，去Base64编码映射表中寻找对应的字符。16在编码表中映射的字符是Q，20映射的字符是U，9映射的字符是J，3映射的字符是D。<br>所以，字符串”ABC”经过Base64编码后的数据是”QUJD”。</p>
<p><strong>Base64编码索引表</strong><br>26个字母 * 2(大小写) + 10个数字 + 2个运算符号 &#x3D; 64个字符<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121438704.png" alt="image-20221212143820653"></p>
<h1 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h1><p>http协议中，GET方式和POST方式是Http请求常用的两种方式，GET方法只能传递ASCII数据，但某些情况下会要求使用GET来传递二进制数据。<br>此时用Base64对Get传输的二进制数据，编码成ASCII数据，例如，客户端和服务器传递JSON数据时，经常会进行base64编解码。</p>
<p>注意：</p>
<ul>
<li>Base64是编码算法，不是加密算法，只是用来编码二进制的字节数组，形成可视的ASCII字符串。</li>
<li>Base64编码实际上是把原数据的3个字节映射成了4个字节，所以相比于原数据长度，编码后的长度会增加1&#x2F;3。会降低传输效率。</li>
</ul>
]]></content>
      <categories>
        <category>encrypt</category>
      </categories>
      <tags>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈数字电路之PLL</title>
    <url>/2023/03/01/%E6%B5%85%E8%B0%88%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B9%8BPLL/</url>
    <content><![CDATA[<p>本文PLL的基础内容参考了Digital Integrated Circuits一书，下载方式：在 <a href="https://vdoc.pub/">vdoc</a> 搜索关键字 Digital Integrated Circuits</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303011144938.jpeg" alt="img"></p>
<h2 id="PLL的应用概述"><a href="#PLL的应用概述" class="headerlink" title="PLL的应用概述"></a>PLL的应用概述</h2><p>两个作用：Clock Synthesis（时钟综合）和 Clock Synchronization（时钟同步）</p>
<ul>
<li>Clock Synthesis，Synthesis是综合&#x2F;生成的意思，Clock Synthesis即生成时钟，但此处含义不是作为时钟源，而是在低频晶振时钟的基础上倍频生成高频时钟：其中低频的晶振时钟的特性：10~200MHz， accurate, low-jitter ，高频时钟特性：200MHz ~ GHz级别，通常也称为系统时钟，例如SOC core的基准频率</li>
<li>Clock Synchronization，不同芯片之间传递时钟信号需要同步时钟相位，例如SOC的CPU和外设之间的通信接口一般是：分频后的时钟信号（reference clock）和数据信号（Date），CPU和外设间的信号传递是需要时间的，高速信号传递到外设侧有相位偏移（可以简单理解为延迟），因此需要PLL同步时钟相位以保证对数据采样的正确性（想象一下，如果reference clock相位偏移过大，可能每个采样时刻得到的data数据都是错位的）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031043844.png" alt="image-20230303104354744"></p>
<h2 id="相位的概念"><a href="#相位的概念" class="headerlink" title="相位的概念"></a>相位的概念</h2><p>Digital Integrated Circuits一书对相位的描述：</p>
<p>Periodic signals of known frequency can be discribed exactly by only one parameter, their<br>phase. More accurately a set of two or more periodic signals of the same frequency can be<br>well defined if we know one of them and its phase with respect to the other signals.  </p>
<p>翻译下就是：</p>
<ul>
<li><p>多个已知频率的周期信号只用一个参数就能精确区分：相位</p>
</li>
<li><p>如果这些信号的频率相同，则只需知道相位差就可以从一个信号精确推测另一个信号</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031634330.png" alt="image-20230303163446269"></p>
<p>基于以上概念，下面介绍PLL的两个核心功能：</p>
<ul>
<li>将输入PLL的时钟和PLL输出时钟的频率精确同步：输出时钟信号频率是输入时钟信号频率的精确的N倍</li>
<li>将输入PLL的时钟和PLL输出时钟的相位精确同步：输出时钟信号N分频后，其应该和输入信号完全一致，其上升&#x2F;下降沿应该精确对齐输入时钟信号的上升&#x2F;下降沿</li>
</ul>
<h2 id="PLL内部实现"><a href="#PLL内部实现" class="headerlink" title="PLL内部实现"></a>PLL内部实现</h2><p>PLL内部结构如下，真正核心的只有两个组件：</p>
<ul>
<li>VCO: The voltage-controlled oscillator (VCO) takes an analog control input and generates a clock signal of the desired frequency.  VCO接受电压（模拟信号），转换为频率（数字信号），也就是说，VCO使输出频率是电压的函数(非线性)。Charge pump是控制电压增加和减少的模块，Loop filter是低通滤波器，过滤掉电压信号中的高频正弦噪声，使VCO的输入更“纯粹”（减少毛刺信号，jittery clock）</li>
<li>Phase Detectors: 为什么带s ? 因为可以有两种实现：XOR Phase Detector  和 Phase-Frequency Detector ，Phase Detectors是相位和频率同步的核心，具体原理下面讲</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031635776.png" alt="image-20230303163504732"></p>
<h3 id="XOR-Phase-Detector"><a href="#XOR-Phase-Detector" class="headerlink" title="XOR Phase Detector"></a>XOR Phase Detector</h3><p>用一个异或门(XOR)就能实现相位检测，是最简单但有缺陷的实现：</p>
<p>当ref clock和local clock(反馈时钟)有相位差，异或之后输出的就是相位差信号(phase error)，这个信号经过线性函数转换成Vdd, 作为VCO的控制电压。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031433820.png" alt="image-20230303143346757"></p>
<p>XOR的缺陷：当local clock相位和ref clock相位一致，但local clock频率是ref clock的N倍时，XOR检不输出相位差，但此时PLL输出频率不是预期的频率，而是N倍的预期频率。</p>
<h3 id="Phase-Frequency-Detector-PFD"><a href="#Phase-Frequency-Detector-PFD" class="headerlink" title="Phase-Frequency Detector (PFD)"></a>Phase-Frequency Detector (PFD)</h3><p>为了解决XOR的缺陷，引入了Phase-Frequency Detector (PFD)，看名字就知道，它同时检测相位和频率，以保证PLL输出的正确性</p>
<p>如下图，UP&#x2F;DN是控制VCO的信号，用于给VCO加压&#x2F;降压；A和B是local clock和ref clock；</p>
<p>PFD使用触发器(flip-flops)，将UP&#x2F;DN变成A和B的状态机；关于flip-flops的特性，参考 <a href="https://courses.cs.washington.edu/courses/cse370/03sp/pdfs/lectures/lecture15.pdf">Overview The D latch - University of Washington</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031532421.png" alt="image-20230303153203366"></p>
<p>(1) PFD如何检测相位差</p>
<p>以左侧信号为例，过程如下：</p>
<ol>
<li>信号A相位超前于信号B, A上升沿时会触发UP信号输出(D触发器特性，这里A作为D触发器的CLK输入信号)；</li>
<li>当信号B上升沿变化时, B处的触发器也输出DN脉冲，两个触发器的输出都为1，经过与门后Rst复位信号为1，导致A和B的触发器都被reset, 之后UP和DN都变为低；</li>
<li>综合下来看，UP信号的宽度就等于相位差，线性转换后就可以作为控制VCO的电压</li>
</ol>
<p>右侧波形同理，信号A相位落后于信号B，DN即相位差</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031500042.png" alt="image-20230303150043973"></p>
<p>(2) PFD如何检测频率差</p>
<p>如下图，当B频率比A低，PFD输出更多的UP信号增加VCO电压，提高B的频率；当B频率比A高则相反，PFD输出更多DN信号降低B的频率</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031517323.png" alt="image-20230303151725271"></p>
<h2 id="PLL的指标"><a href="#PLL的指标" class="headerlink" title="PLL的指标"></a>PLL的指标</h2><p>PLL structure is a feedback structure and the addition of extra phase shifts, as is done by a high-order filter, may result in instability. </p>
<p>PLL是能造成相位偏移（矫正）的反馈电路，既然是反馈就得像数学求极限一样不断趋近，这决定PLL不是一上电就能马上稳定工作，因此引入PLL的关键指标如下：</p>
<p>Important properties of a PLL are：</p>
<ul>
<li><p>lock range—the range of input frequencies over which the loop can maintain functionality; PLL能接受的输入时钟不可能太高，一般是OSC晶振低频时钟。想象一下，太高的输入时钟要去同步相位和倍频，对VCO和相位检测器的精度要求也极高</p>
</li>
<li><p>the lock time—the time it takes for the PLL to lock onto a given input signal; PLL是反馈环路电路，需要不断递归趋近于目标时钟信号直到稳定，稳定需要的时间称为PLL锁定时间</p>
</li>
<li><p>jitter.  毛刺信号，在模拟端称为noise(VCO输入电压)，在数字端称为jitter毛刺(VCO输出时钟)，这是时钟信号相关模块必不可少的指标</p>
</li>
</ul>
<h2 id="PLL的稳定过程"><a href="#PLL的稳定过程" class="headerlink" title="PLL的稳定过程"></a>PLL的稳定过程</h2><p>如下图是Spice 仿真将100Mhz reference clock倍频8倍，VCO最终稳定输出800Mhz system clock的过程：</p>
<ul>
<li><p>左侧是VCO控制电压，经过几次反馈调整后最终稳定</p>
</li>
<li><p>右侧是时钟信号，ref是输入的100Mhz reference clock，vco是输出的system clock， div是vco输出8分频后的反馈时钟</p>
</li>
</ul>
<p>可见PLL稳定过程是将ref，vco和div时钟信号的相位、频率都收敛到一致</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031423652.png" alt="image-20230303142344571"></p>
<h2 id="PLL在IC设计IP的实例"><a href="#PLL在IC设计IP的实例" class="headerlink" title="PLL在IC设计IP的实例"></a>PLL在IC设计IP的实例</h2><p>以SMIC的PLL IP S65NLLPLLGS 为例介绍实际IC设计中的PLL模块：</p>
<p>(1) 简介</p>
<p>This PLL is developed as an IP block to reduce time to market, risk and cost in the<br>development of Analog Front –End design. This macro cell is mainly for the clock<br>generator. It can generate stable high-speed clock from a slower clock signal with<br>single power supply. The output frequency is adjustable and can be up to 1500MHz.<br>This PLL integrates a Phase Frequency Detector (PFD), a Low Pass Filter (LPF), a<br>Voltage Controlled Oscillator and other associated circuit. All fundamental building<br>blocks as well as fully programmable dividers are integrated in the core. It is useful<br>for clock multiplication of stable crystal oscillator sources and for de-skew clock<br>signals  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061656462.png" alt="image-20230306165657371"></p>
<p>可见主要模块还是PFD + VCO，输出时钟加了一些逻辑门控制，例如PDRST是PLL时钟复位控制。</p>
<p>(2) 主要参数</p>
<p>Technology: SMIC 65nm logic LL process  </p>
<p>PFD comparison frequency range from 1Mhz to 50Mhz.  </p>
<p>Output clock frequency range from 62.5MHz to 1500MHz  </p>
<p>基本体现了PLL的指标：输入输出时钟频率有限制</p>
<p>(3) PLL reset</p>
<p>PLL作为实际可用的模块，其输出频率一定是可调的，以下PLL IP的pin中的M, N即调整频率；对于固件、驱动软件开发者，M，N分频的访问接口是作为寄存器来动态配置。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061707268.png" alt="image-20230306170709189"></p>
<p>在M，N调整分配时，必须reset PLL并等待PLL再次稳定（PLL lock time），如下图：</p>
<p>LKDT: Lock Detection, 表示目前PLL正在lock，即反映PLL是否处于不稳定状态</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061711496.png" alt="image-20230306171156449"></p>
<h2 id="PLL在外设时钟配置的实例"><a href="#PLL在外设时钟配置的实例" class="headerlink" title="PLL在外设时钟配置的实例"></a>PLL在外设时钟配置的实例</h2><p>SD控制器(SD host)是SOC中常用的外围模块，通过SD specification规定的SD Command通信格式向SD卡通信。</p>
<p>下面以SD host&#x2F;card的时钟初始化为例，介绍PLL的lock time在外设时钟初始化的影响</p>
<p>(1) SD 4.0标准的host和card的物理框图如下图，这里重点关注host侧的时钟相关的模块：</p>
<ul>
<li>OSC: host 的时钟来源，同时也是PLL的输入</li>
<li>PLL: host的倍频器，为了给SD UHS-II card提供更高速的工作时钟(UHS-I低速SD card不需要此PLL)</li>
<li>RCLK: SD card的工作时钟(reference clock)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061954691.png" alt="image-20230306195458581"></p>
<p>(2) SD host和card的时钟初始化</p>
<p>SD host和card的时钟初始化包含三步：</p>
<p>1.使能internal clock: sd host chip自己的工作时钟(即base clock，来源是OSC)，并等待其稳定，如下图(3)~(4)</p>
<p>2.enable PLL，并等待其稳定，这个等待稳定超时时间为150ms ，如下图(5)~(6)。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303062016985.png" alt="image-20230306172758282"></p>
<p>3.待host PLL输出稳定后，即可enable SD clock开始对SD卡供应reference clock时钟, 注意SD clock是下图(1)~(2)就已经计算好的，如下表Base Clock为internal clock，M可理解为PLL倍频后的频率, 经过2^N分频后给SD card作为reference clock。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303062013044.png" alt="image-20230306201345998"></p>
<h2 id="PLL在电源管理的实例"><a href="#PLL在电源管理的实例" class="headerlink" title="PLL在电源管理的实例"></a>PLL在电源管理的实例</h2><p>所谓电源管理，通俗的讲就是按需管理电源：</p>
<ul>
<li>按需，指的是按应用场景的需求，例如在高性能肯定对应高功耗，各种模块全部开启，且时钟频率拉到最大；而睡眠休眠等模式，有时只需要保留能唤醒系统的时钟就行；</li>
<li>管理电源，涉及到供电和时钟：将低功耗情景下不需要用到的模块直接关电，将要用到但速度要求不高的模块进入低速时钟工作。</li>
</ul>
<p>下面以PCIe的电源管理为例，介绍低功耗状态如何影响PLL的状态</p>
<p>（1）PCIe电源管理基本概念</p>
<p>PCIe的电源管理基本概念参考 <a href="https://www.intel.cn/content/www/cn/zh/io/pci-express/pci-express-architecture-power-management-rev-1-1-paper.html">PCI EXPRESS ARCHITECTURE POWER MANAGEMENT</a>, 也可以参考PCIe标准协议PCIe Base Spec</p>
<p>从上到下包含三层：系统电源状态(S)，PCIe链路电源状态(L)，PCIe设备电源状态(D)</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071046331.png" alt="Untitled Diagram"></p>
<ul>
<li>Sleep state</li>
</ul>
<p>S0 (Working): This is the active system state in which the platform appears to be “on.”  </p>
<p>S1&#x2F;POS, S1 (Microsoft* OS Stand By): These are the lowest wake latency sleeping states.  </p>
<p>S3 (Microsoft OS Stand By) and S4 (Microsoft OS Hibernate): S3 is a low wake latency sleeping state in which all device contexts are lost except system memory</p>
<p>S5 (Microsoft OS Soft-off): In this state, the OS does not save any context and requires a complete OS boot when the system wakes  </p>
<ul>
<li>Link States</li>
</ul>
<p>L0: Active state  </p>
<p>L1: This link state is a low exit latency link state that is intended to reduce power when the device becomes aware of a lack of outstanding requests or pending transactions  </p>
<p>L2&#x2F;L3 Ready: This link state prepares the PCI Express link for the removal of power and clock.   </p>
<p>L3 (link off): Power and clock are removed in this link state  </p>
<ul>
<li>Device States</li>
</ul>
<p>D0 (Fully-on): The device is completely active and responsive during this D-state  </p>
<p>D1 and D2: There is no universal definition for these D-states. In general, D1 is expected to save<br>less power but preserve more device context than D2  </p>
<p>D3 (Off): Primary power may be fully removed from the device (D3cold), or not removed from the device (D3hot). </p>
<p>S, L, D 三层状态的对应关系如下表</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071050761.png" alt="image-20230307105034704"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071050372.png" alt="image-20230307105052312"></p>
<p>注意，Link state是Sleep state对Device state作用的结果，即状态变化的过程是：</p>
<p>系统发起S3 -&gt; Device sate进入D3-&gt;Link state进入L2&#x2F;L3</p>
<p>（2）使用PLL控制Device state</p>
<p>Device sate进入D3, 设备内部操作即包含PLL的disable，将PLL模块整个关掉，保留OSC低速时钟作为退出D3状态的唤醒时钟源（软件上可以理解为heart beat），当PLL关掉后，其他依赖PLL的高速模块通常也断电，整个设备接近（或彻底）断电，因此设备功耗极低。</p>
<p>Device sate退出D3并进入D0则是相反过程，设备的PLL模块打开，其他依赖PLL的高速模块也打开，整个设备进入Active状态，功耗自然升高。</p>
<p>（3）使用PLL控制Link state</p>
<p>参考chapter11 of <a href="https://vdoc.pub/download/introduction-to-pci-express-a-hardware-and-software-developers-guide-1r2bcv8l7e6o">Introduction to PCI Express: A Hardware and Software Developer’s Guide</a></p>
<p>当PCIe link改变时，本质是PCIe时钟改变；PCIe host侧（bridge&#x2F;Root Complex）的时钟也是低速clock source经PLL倍频后的2.5GHz，如下图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071202081.png" alt="image-20230307120222026"></p>
<p>L1 link state的本质：The L1 Link state is an idle state with the internal Phase Lock Loop Circuit turned off. The source clock is still feeding a 100-megahertz differential clock signal to the PCI Express component.</p>
<p>L2 link state的本质：The L2 Link state is an optional auxiliary idle state with the internal Phase Lock Loop Circuit, the external clock source, and the main device power turned off (auxiliary power remains on)</p>
<p>总结就是：PCIe Link State本质是通过关闭PCIe host侧的PLL甚至clock source来实现的。</p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>PLL</tag>
      </tags>
  </entry>
  <entry>
    <title>高通平台编译Android系统镜像记录</title>
    <url>/2019/09/26/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91Android%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文记录在高通开发平台HDK845上编译Android系统镜像的过程</p>
<h2 id="一、-搭建Shadowsocks-Privoxy代理"><a href="#一、-搭建Shadowsocks-Privoxy代理" class="headerlink" title="一、 搭建Shadowsocks+Privoxy代理"></a>一、 搭建Shadowsocks+Privoxy代理</h2><h3 id="1-1为什么需要搭代理"><a href="#1-1为什么需要搭代理" class="headerlink" title="1.1为什么需要搭代理"></a>1.1为什么需要搭代理</h3><p>下载Android源码需要访问国外代码源，直接访问会被GFW阻挡，代理服务器（VPS）是未被GFW阻挡的国外服务器，通过代理服务器跳转至目标服务器访问国外代码源。</p>
<h3 id="1-2-shadowsocks-privoxy代理架构"><a href="#1-2-shadowsocks-privoxy代理架构" class="headerlink" title="1.2 shadowsocks+privoxy代理架构"></a>1.2 shadowsocks+privoxy代理架构</h3><p>使用shadowssocks+privoxy搭建客户端代理，如下图客户端进程发送请求（http&#x2F;https&#x2F;git）到privoxy，privoxy将请求转化为socks5请求，发送给shadowsocks客户端，shadowsocks处理socks5请求,将其发送到远端VPS上运行的socks5服务端（shadowsocks server），VPS再将请求转发给目标服务器。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281739480.png" alt="image001"></p>
<h3 id="1-3-shadowsocks-privoxy代理搭建"><a href="#1-3-shadowsocks-privoxy代理搭建" class="headerlink" title="1.3 shadowsocks+privoxy代理搭建"></a>1.3 shadowsocks+privoxy代理搭建</h3><h4 id="1-3-1-shadowsocks"><a href="#1-3-1-shadowsocks" class="headerlink" title="1.3.1 shadowsocks"></a>1.3.1 shadowsocks</h4><p>HOST系统：ubuntu 14.04 LTS<br>安装shadowsock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install python-pip </span><br><span class="line">pip install shadowsocks </span><br></pre></td></tr></table></figure>
<p>配置shadowsocks client</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /etc/ss.json </span><br><span class="line">输入以下内容: </span><br><span class="line">&#123; </span><br><span class="line">&quot;server&quot;:&quot;176.122.xxx.xx&quot;, </span><br><span class="line">&quot;server_port&quot;:8080, </span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;, </span><br><span class="line">&quot;local_port&quot;:1080, </span><br><span class="line">&quot;password&quot;:&quot;xxxxx&quot;, </span><br><span class="line">&quot;timeout&quot;:100, </span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行shadowsocks客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/ss.json &gt; ss.log 2&gt;&amp;1 &amp;  </span><br><span class="line">查看服务是否起来:  </span><br><span class="line">ps -ef | grep sslocal  </span><br></pre></td></tr></table></figure>
<p>若开机启动可写入<code>/etc/rc.local</code></p>
<h4 id="1-3-2-privoxy"><a href="#1-3-2-privoxy" class="headerlink" title="1.3.2 privoxy"></a>1.3.2 privoxy</h4><p>下载privoxy稳定版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz </span><br><span class="line">tar -zxvf privoxy-3.0.26-stable-src.tar.gz </span><br><span class="line">cd privoxy-3.0.26-stable </span><br></pre></td></tr></table></figure>
<p>privoxy服务需要新建privoxy用户,并添加到privoxy用户组来运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd privoxy </span><br><span class="line">groupadd -g 888 privoxy  </span><br><span class="line">gpasswd -a privoxy privoxy  </span><br></pre></td></tr></table></figure>
<p>查看privoxy用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id privoxy </span><br></pre></td></tr></table></figure>
<p>安装provoxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install autoconf </span><br><span class="line">autoheader &amp;&amp; autoconf</span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>
<p>设置privoxy监听http&#x2F;https&#x2F;git的端口，和privoxy面向socks5的端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /usr/local/etc/privoxy/config </span><br><span class="line">下面两行取消注释 </span><br><span class="line">listen-address 127.0.0.1:8118 </span><br><span class="line">forward-socks5t / 127.0.0.1:1080 </span><br></pre></td></tr></table></figure>
<p>启动privoxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privoxy --user privoxy /usr/local/etc/privoxy/config </span><br><span class="line">ps -ef | grep sslocal </span><br></pre></td></tr></table></figure>
<p>若开机启动可写入<code>/etc/rc.local</code></p>
<h4 id="1-3-3-设置代理环境变量"><a href="#1-3-3-设置代理环境变量" class="headerlink" title="1.3.3 设置代理环境变量"></a>1.3.3 设置代理环境变量</h4><p>http&#x2F;https&#x2F;ftp请求的代理端口设置为privoxy的监听端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /etc/profile </span><br><span class="line">export http_proxy=&quot;http://127.0.0.1:8118&quot; </span><br><span class="line">export https_proxy=&quot;http://127.0.0.1:8118&quot; </span><br><span class="line">export ftp_proxy=&quot;http://127.0.0.1:8118&quot; </span><br></pre></td></tr></table></figure>
<p>生效并测试, curl返回大堆json字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile </span><br><span class="line">curl http://www.google.com </span><br></pre></td></tr></table></figure>
<p>系统的http(s)等请求的代理配置完成</p>
<h4 id="1-3-4-设置git代理"><a href="#1-3-4-设置git代理" class="headerlink" title="1.3.4 设置git代理"></a>1.3.4 设置git代理</h4><p>安装并配置git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install git </span><br><span class="line">git config --global user.email &quot;yourname@xxx.com&quot;  </span><br><span class="line">git config --global user.name &quot;yourname&quot; </span><br><span class="line">git config --global http.proxy http://127.0.0.1:8118 </span><br><span class="line">git config --global https.proxy http://127.0.0.1:8118 </span><br></pre></td></tr></table></figure>
<p>设置git使用代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install connect-proxy </span><br><span class="line">mkdir ~/bin </span><br><span class="line">echo &quot;connect-proxy -S 127.0.0.1:1080 \&quot;\$@\&quot;&quot; &gt; ~/bin/socks5proxywrapper </span><br><span class="line">chmod 755 ~/bin/socks5proxywrapper </span><br><span class="line">git config --global core.gitproxy `echo $HOME`/bin/socks5proxywrapper </span><br></pre></td></tr></table></figure>

<h2 id="二、下载编译Android源码"><a href="#二、下载编译Android源码" class="headerlink" title="二、下载编译Android源码"></a>二、下载编译Android源码</h2><h3 id="2-1-交叉编译的概念"><a href="#2-1-交叉编译的概念" class="headerlink" title="2.1 交叉编译的概念"></a>2.1 交叉编译的概念</h3><p>- 1 本地编译：在当前编译平台下，编译出来的程序只能运行在当前平台。常见的应用软件开发的编译都属于本地编译。<br>- 2 交叉编译：在当前编译平台下，编译出来的程序能运行在另一种体系结构不同的目标平台上，但是编译平台本身却不能运行该程序。<br>- 3 交叉编译工具链：编译过程包括了预处理、编译、汇编、链接等过程。每个子过程都是单独的工具来实现。交叉编译链是为了编译跨平台体系结构的程序代码而形成的由多个子工具构成的一套完整的工具集。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281739906.png" alt="image003"><br>如上图，交叉编译工具链中最主要的部分包含编译器（如gcc）,汇编器（如as）,连接器（如ld）。通常as和ld及objcopy等其他工具由GNU打包成了binutils（binary utilitys)工具，再加上编译器组成整个工具链。<br>其中编译器命名规则为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arch-core-kernel-system-compiler </span><br><span class="line"></span><br><span class="line">arch：目标平台架构，如arm, x86_64 </span><br><span class="line">core： 目标平台的CPU Core，如Cortex A8 </span><br><span class="line">kernel： 目标平台所运行的OS，如Linux，Android </span><br><span class="line">systen：交叉编译链所选择的库函数和目标系统的规范，如gnu，gnueabi等 </span><br><span class="line">compiler: 编译器名，如gcc, g++,clang,clang++ </span><br></pre></td></tr></table></figure>

<p>- 4 交叉编译架构：<br>HOST OS 通常为Linux，包含自身的kernel、glibc基础库和Target程序的依赖库。Toolchain包含C&#x2F;C++及其他语言编译器和汇编、链接器等组件。Toolchain依赖于HOST的glibc基础库。Target binary是编译出的目标镜像&#x2F;程序，编译过程依赖于Toolchain及HOST的build essential libs。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740465.png" alt="image005"></p>
<h3 id="2-2-高通Android平台编译概念"><a href="#2-2-高通Android平台编译概念" class="headerlink" title="2.2 高通Android平台编译概念"></a>2.2 高通Android平台编译概念</h3><p>高通平台HDK845推荐的编译环境如下：</p>
<table>
<thead>
<tr>
<th>HOST</th>
<th>Toolchain</th>
<th>Source code repository</th>
<th>build out Android version</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu14.04 LTS</td>
<td>Clang&#x2F;LLVM</td>
<td>CAF</td>
<td>support Android 9 Pie</td>
</tr>
</tbody></table>
<p>高通平台HDK845推荐的编译流程如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740419.png" alt="image006"></p>
<p>Clang&#x2F;LLVM编译器介绍<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281748816.png" alt="clangLLVM"><br>CAF和AOSP的介绍  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAF is Code Aurora repository. It&#x27;s the place where Qualcomm releases source code for their phone processors.  </span><br><span class="line">It&#x27;s directly supported by Qualcomm and it&#x27;s generally a more optimized branch for Snapdragon phones.  </span><br><span class="line">Actually, there are two main baselines for support of Qualcomm devices:  </span><br><span class="line">- 1. CodeAurora (CAF) - These are Qualcomm&#x27;s reference sources for their platform.  </span><br><span class="line">This is what they provide to OEMs, and what nearly all OEMs base their software off of.  </span><br><span class="line">As a result - nearly all non-Nexus devices are running kernels/display HALs/etc. that are derived from a CAF baseline.  </span><br><span class="line">- 2. Google&#x27;s software baseline(AOSP) - Usually when Google starts working on a new Android version, they&#x27;ll fork from CAF at the beginning.  </span><br><span class="line">Very often Google will be adding &quot;new&quot; features specific to the new Android version, while Qualcomm will continue with performance enhancements and bugfixes against the &quot;old&quot; baseline.  </span><br><span class="line">- 3. So when a new Android revision comes out, you have two baselines: CAF which is usually &quot;ahead&quot; in performance but &quot;behind&quot; in features,  while AOSP is “behind” in performance (relatively) but “ahead” in features.  </span><br><span class="line">Nowadays, developers are directly compiling the builds from CAF source code which is really difficult as this is what Google does initially before upgrading to a new version,  </span><br><span class="line">and then they add features and the source by the time gets ‘compilable’, it is easier to compile the one on Google Sources than the one which is there on CAF.  </span><br><span class="line">CAF can be considered as Vanilla version of a Vanilla version of Android.  </span><br></pre></td></tr></table></figure>
<h3 id="2-3-高通Android平台编译流程"><a href="#2-3-高通Android平台编译流程" class="headerlink" title="2.3 高通Android平台编译流程"></a>2.3 高通Android平台编译流程</h3><p>- 1 安装jdk，用于编译Android源码中的java代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add-apt-repository ppa:openjdk-r/ppa </span><br><span class="line">apt-get update </span><br><span class="line">apt-get -y install openjdk-8-jdk </span><br><span class="line">update-alternatives --config java </span><br><span class="line">java -version </span><br></pre></td></tr></table></figure>
<p>- 2 安装HOST(ubuntu14.04)的build essentials，编译过程依赖这些工具和库 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip libssl-dev libc6:i386 libstdc++6:i386</span><br></pre></td></tr></table></figure>
<p>- 3 安装repo，用于下载android源码 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo </span><br><span class="line">chmod +x ~/bin/repo </span><br><span class="line">export PATH=~/bin:$PATH </span><br><span class="line">repo --help </span><br></pre></td></tr></table></figure>
<p>- 4 解压开发板厂商的BSP，其中包含源码下载的脚本、补丁包等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip Open-Q_845_Android-P_v2.1.zip </span><br><span class="line">cd Open-Q_845_Android-P_v2.1/Source_Package </span><br><span class="line">chmod +x getSource_and_build.sh </span><br></pre></td></tr></table></figure>
<p>- 5 用脚本从CAF源下载代码，打补丁后编译 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./getSource_and_build.sh </span><br></pre></td></tr></table></figure>

<p><code>./getSource_and_build.sh</code>内容如下 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNDER=&#x27;\e[4m&#x27; </span><br><span class="line">RED=&#x27;\e[31;1m&#x27; </span><br><span class="line">GREEN=&#x27;\e[32;1m&#x27; </span><br><span class="line">YELLOW=&#x27;\e[33;1m&#x27; </span><br><span class="line">BLUE=&#x27;\e[34;1m&#x27; </span><br><span class="line">MAGENTA=&#x27;\e[35;1m&#x27; </span><br><span class="line">CYAN=&#x27;\e[36;1m&#x27; </span><br><span class="line">WHITE=&#x27;\e[37;1m&#x27; </span><br><span class="line">ENDCOLOR=&#x27;\e[0m&#x27; </span><br><span class="line">ITCVER=&quot;P_v2.1&quot; </span><br><span class="line">WORKDIR=`pwd` </span><br><span class="line">CAFTAG=&quot;LA.UM.7.3.r1-06700-sdm845.0&quot; </span><br><span class="line">BUILDROOT=&quot;$&#123;WORKDIR&#125;/SDA845_Open-Q_845_Android-$&#123;ITCVER&#125;&quot; </span><br><span class="line">PATCH_DIR=&quot;$&#123;WORKDIR&#125;/patches&quot; </span><br><span class="line">DB_PRODUCT_STRING=&quot;Open-Q 845 HDK Development Kit&quot; </span><br><span class="line"></span><br><span class="line">function download_CAF_CODE() &#123; </span><br><span class="line"># Do repo sanity test </span><br><span class="line">if [ $? -eq 0 ] </span><br><span class="line">then </span><br><span class="line">  echo &quot;Downloading code please wait..&quot; </span><br><span class="line">  repo init -q -u git://codeaurora.org/platform/manifest.git -b release -m $&#123;CAFTAG&#125;.xml </span><br><span class="line">  repo sync -q -c -j 4 --no-tags --no-clone-bundle </span><br><span class="line">  if [ $? -eq 0 ] </span><br><span class="line">  then </span><br><span class="line">    echo -e &quot;$GREEN Downloading done..$ENDCOLOR&quot; </span><br><span class="line">  else </span><br><span class="line">    echo -e &quot;$RED!!!Error Downloading code!!!$ENDCOLOR&quot; </span><br><span class="line">  fi </span><br><span class="line">else </span><br><span class="line">  echo &quot;repo tool problem, make sure you have setup your build environment&quot; </span><br><span class="line">  echo &quot;1) http://source.android.com/source/initializing.html&quot; </span><br><span class="line">  echo &quot;2) http://source.android.com/source/downloading.html (Installing Repo Section Only)&quot; </span><br><span class="line">  exit -1 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to check result for failures </span><br><span class="line">check_result() &#123; </span><br><span class="line">if [ $? -ne 0 ] </span><br><span class="line">then </span><br><span class="line">  echo </span><br><span class="line">  echo -e &quot;$RED FAIL: Current working dir:$(pwd) $ENDCOLOR&quot; </span><br><span class="line">  echo </span><br><span class="line">  exit 1 </span><br><span class="line">else </span><br><span class="line">  echo -e &quot;$GREEN DONE! $ENDCOLOR&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to autoapply patches to CAF code </span><br><span class="line">apply_android_patches() </span><br><span class="line">&#123; </span><br><span class="line">  echo &quot;Applying patches ...&quot; </span><br><span class="line">  if [ ! -e $PATCH_DIR ] </span><br><span class="line">  then </span><br><span class="line">    echo -e &quot;$RED $PATCH_DIR : Not Found $ENDCOLOR&quot; </span><br><span class="line">    return </span><br><span class="line">  fi </span><br><span class="line">  cd $PATCH_DIR </span><br><span class="line">  patch_root_dir=&quot;$PATCH_DIR&quot; </span><br><span class="line">  android_patch_list=$(find . -type f -name &quot;*.patch&quot; | sort) &amp;&amp; </span><br><span class="line">  for android_patch in $android_patch_list; do</span><br><span class="line">    android_project=$(dirname $android_patch) </span><br><span class="line">    echo -e &quot;$YELLOW  applying patches on  $android_project ... $ENDCOLOR&quot; </span><br><span class="line">    cd $BUILDROOT/$android_project </span><br><span class="line">    if [ $? -ne 0 ]; then </span><br><span class="line">      echo -e &quot;$RED $android_project does not exist in BUILDROOT:$BUILDROOT $ENDCOLOR&quot; </span><br><span class="line">      exit 1 </span><br><span class="line">    fi </span><br><span class="line">    git am --3way $patch_root_dir/$android_patch </span><br><span class="line">    check_result </span><br><span class="line">  done </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to check whether host utilities exists </span><br><span class="line">check_program() &#123; </span><br><span class="line">for cmd in &quot;$@&quot; </span><br><span class="line">do </span><br><span class="line">  which $&#123;cmd&#125; &gt; /dev/null 2&gt;&amp;1 </span><br><span class="line">  if [ $? -ne 0 ] </span><br><span class="line">  then </span><br><span class="line">    echo </span><br><span class="line">    echo -e &quot;$RED Cannot find command \&quot;$&#123;cmd&#125;\&quot;  $ENDCOLOR&quot; </span><br><span class="line">    echo </span><br><span class="line">    exit 1 </span><br><span class="line">  fi </span><br><span class="line">done </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">#Main Script starts here </span><br><span class="line">#Note: Check necessary program for installation </span><br><span class="line">echo </span><br><span class="line">echo -e &quot;$CYAN Product          : $DB_PRODUCT_STRING $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Intrinsyc Release Version : $ITCVER $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA WorkDir          : $WORKDIR $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Build Root        : $BUILDROOT $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Patch Dir         : $PATCH_DIR $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA CodeAurora TAG      : $CAFTAG $ENDCOLOR&quot; </span><br><span class="line">echo -n &quot;Checking necessary program for installation......&quot; </span><br><span class="line">echo </span><br><span class="line">check_program tar repo git patch </span><br><span class="line">if [ -e $BUILDROOT ] </span><br><span class="line">then </span><br><span class="line">  cd $BUILDROOT </span><br><span class="line">else </span><br><span class="line">  mkdir $BUILDROOT </span><br><span class="line">  cd $BUILDROOT </span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">#1 Download code </span><br><span class="line">download_CAF_CODE </span><br><span class="line">cd $BUILDROOT </span><br><span class="line"></span><br><span class="line">#2 Apply Open-Q 845 HDK Development Kit Patches</span><br><span class="line">apply_android_patches </span><br><span class="line"></span><br><span class="line">#3 Extract the proprietary objs </span><br><span class="line">cd $BUILDROOT </span><br><span class="line">echo -e &quot;$YELLOW  Extracting proprietary binary package to $BUILDROOT ... $ENDCOLOR&quot; </span><br><span class="line">tar -xzvf ../proprietary.tar.gz -C vendor/qcom/ </span><br><span class="line"></span><br><span class="line">#4 Build </span><br><span class="line">echo -e &quot;$YELLOW  Building Source code from $BUILDROOT ... $ENDCOLOR&quot; </span><br><span class="line">if [[ -z &quot;$&#123;BUILD_NUMBER&#125;&quot; ]]; then export BUILD_NUMBER=$(date +%m%d%H%M); fi </span><br><span class="line">. build/envsetup.sh </span><br><span class="line">lunch sdm845-$&#123;BV:=&quot;userdebug&quot;&#125; </span><br><span class="line">ITC_ID=Open-Q_845_$&#123;ITCVER&#125; make -j $(nproc) $@ </span><br></pre></td></tr></table></figure>

<p>编译后生成bootloader和系统等镜像：<br>SDA845_Open-Q_845_Android-P_v2.1&#x2F;out&#x2F;target&#x2F;product&#x2F;sdm845&#x2F;xxx.img<br>后续重新编译只需要注释掉<code>./getSource_and_build.sh</code>的<code>步骤#1 #2 #3</code>，保留<code>#4 Build</code></p>
<h2 id="二、-烧写Android镜像"><a href="#二、-烧写Android镜像" class="headerlink" title="二、 烧写Android镜像"></a>二、 烧写Android镜像</h2><h3 id="3-1-烧写、调试、打印的工具"><a href="#3-1-烧写、调试、打印的工具" class="headerlink" title="3.1 烧写、调试、打印的工具"></a>3.1 烧写、调试、打印的工具</h3><p>开发板通过micro USB和type-C USB连接到主机<br>type-C: 用于开发板接收adb&#x2F;fastboot<br>micro USB： 用于HOST接收开发板的输出打印<br>连接如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740889.png" alt="image007"></p>
<p>HOST端用到的工具：<br>fastboot: 用于烧写Android镜像到开发板<br>adb(Android Debug Bridge): 用于调试Android系统<br>secureCRT: 用于查看开发板串口打印<br>- 1 首先配置fastboot和adb到系统环境变量，windows环境下<code>win + R</code>输入<code>cmd</code>配置<code>PATH</code>变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set PATH=%PATH%;d:\platform-tools\adb.exe</span><br><span class="line">set PATH=%PATH%;d:\platform-tools\fastboot.exe</span><br></pre></td></tr></table></figure>
<p>确认adb和fastboot加到了<code>PATH</code>环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo %PATH%</span><br></pre></td></tr></table></figure>
<p>- 2 查看开发板对应的com口，secureCRT新建会话，设置serial，设置com口和波特率115200</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740486.png" alt="image009"></p>
<h3 id="3-2-烧写镜像"><a href="#3-2-烧写镜像" class="headerlink" title="3.2 烧写镜像"></a>3.2 烧写镜像</h3><p>- 1 首先使开发版进入fastboot模式，连接micro USB，电源选项拨到DC电源, 上电后长按vol-, 然后连接type-C，串口打印出现<code>Fastboot: Processing commands</code>则进入fastboot。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740947.png" alt="image011"><br>- 2 <code>win + R</code>打开<code>cmd</code>，用fastboot烧写编译出来的镜像 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash system system.img </span><br><span class="line">fastboot flash persist persist.img </span><br><span class="line">fastboot flash boot boot.img  </span><br><span class="line">fastboot flash dtbo dtbo.img </span><br><span class="line">fastboot flash vbmeta vbmeta.img </span><br><span class="line">fastboot flash vendor vendor.img </span><br><span class="line">fastboot reboot </span><br></pre></td></tr></table></figure>
<p>可写入flash.bat脚本,放到系统镜像同一目录下运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off </span><br><span class="line"></span><br><span class="line">@echo Reboot bootloader... </span><br><span class="line">adb reboot bootloader </span><br><span class="line"></span><br><span class="line">@echo Flashing device... </span><br><span class="line">fastboot flash system system.img </span><br><span class="line">fastboot flash persist persist.img </span><br><span class="line">fastboot flash boot boot.img </span><br><span class="line">fastboot flash dtbo dtbo.img </span><br><span class="line">fastboot flash vbmeta vbmeta.img </span><br><span class="line">fastboot flash vendor vendor.img </span><br><span class="line"></span><br><span class="line">@echo Flashing finish, rebooting system... </span><br><span class="line">fastboot reboot </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281741449.png" alt="image012"><br>完成后系统重启进入Android桌面。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281741637.png" alt="image014"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用笔记</title>
    <url>/2023/04/26/Ubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文基于Ubuntu 22.04 LTS</p>
<h2 id="软件下载源"><a href="#软件下载源" class="headerlink" title="软件下载源"></a>软件下载源</h2><p>使用国内软件源下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">software&amp;updates -&gt; Ubuntu Software -&gt; download from -&gt; cn99.com或aliyun.com</span><br></pre></td></tr></table></figure>

<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>安装中文输入法(pinyin)的步骤：</p>
<p>安装中文支持：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Install/Remove Languages -&gt; 安装chinese simplified</span><br></pre></td></tr></table></figure>

<p>设置系统语言为中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成Chinese</span><br></pre></td></tr></table></figure>

<p>安装Fcitx框架和中文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-bin #安装fcitx框架</span><br><span class="line">sudo apt-get install fcitx-table #安装输入法栏，其中自动安装拼音输入法</span><br><span class="line">fcitx --version</span><br></pre></td></tr></table></figure>

<p>使用Fcitx框架，重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Keyboard input method system 选择Fcitx 4</span><br></pre></td></tr></table></figure>

<p>添加输入法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ubuntu右上角的小键盘图标 -&gt; configure -&gt; 添加pinyin（只有系统语言为中文时才能添加中文输入法）</span><br></pre></td></tr></table></figure>

<p>切换中英文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + space</span><br></pre></td></tr></table></figure>

<p>设置系统语言改回英文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成English</span><br></pre></td></tr></table></figure>

<h2 id="snap包管理工具"><a href="#snap包管理工具" class="headerlink" title="snap包管理工具"></a>snap包管理工具</h2><p><a href="https://snapcraft.io/store">Snap</a>是Canonical开发的Linux包管理和软件部署工具。 </p>
<p>安装和使用参考 <a href="https://phoenixnap.com/kb/install-snap-ubuntu#:~:text=1%20Start%20by%20updating%20packages%3A%0Asudo%20apt,update%202%20Enter%20the%20following%20command%3A"><strong>How to Install Snap on Ubuntu</strong></a></p>
<p>特点：丰富的第三方工具库，包括开源工具和闭源工具；二进制安装，不是源码编译</p>
<p>相比apt，其查找工具和安装极为简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap find &lt;keyword&gt; #查找keyword相关的工具，显示可安装的列表</span><br><span class="line">sudo snap install &lt;package&gt; #安装列表中的工具</span><br></pre></td></tr></table></figure>

<p>查看和卸载snap安装的包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snap list</span><br><span class="line">sudo snap remove &lt;package&gt;</span><br></pre></td></tr></table></figure>

<p>示例：安装VSCode和Chrome</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap find vscode #找到&lt;package&gt;为code</span><br><span class="line">sudo snap install code --classic</span><br><span class="line">sudo snap find chrome #找到&lt;package&gt;为chromium</span><br><span class="line">sudo snap install chromium</span><br></pre></td></tr></table></figure>

<h2 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h2><p>setting -&gt; keyboard -&gt; shortcuts -&gt; custom shortcut -&gt; 为应用程序添加快捷键</p>
<p>以截图工具flameshot为例，设置快捷键的command为调用flameshot的命令，截图默认保存到~&#x2F;Pictures</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051055723.png" alt="image-20230505105544618"></p>
<p>要配置其他flameshot命令的快捷键，用 <code>man flameshot</code> 查看，参考 <a href="https://flameshot.org/docs/guide/key-bindings/">Keyboard shortcuts for Flameshot</a></p>
<h2 id="Timeshift备份系统"><a href="#Timeshift备份系统" class="headerlink" title="Timeshift备份系统"></a>Timeshift备份系统</h2><p>22.04系统似乎比较容易挂，进不了系统显示”Oh no… system can’t recover…”，比如：</p>
<p>Nvdia驱动选择开源版本xserver就挂了一次, recovery模式看&#x2F;var&#x2F;log&#x2F;message有nouveau和nvidia module相关问题</p>
<p>学习xv6时安装编译环境时也挂了一次(不能安装到&#x2F;usr&#x2F;local，应该安装到&#x2F;home)，recovery模式dpkg report显示failure log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbol lookup error: /lib/x86_64-linux-gnu/libgnutls.so.30: undefined symbol: __gmpz_limbs_write </span><br></pre></td></tr></table></figure>

<p>都是找遍办法都修复不了，只能重装…</p>
<p>为了解决此问题，使用Timeshift将系统备份，参考: <a href="https://itsfoss.com/backup-restore-linux-timeshift/">How to Backup and Restore Linux System Settings With Timeshift</a></p>
<p>安装timeshift：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install timeshift</span><br></pre></td></tr></table></figure>

<p>备份整个系统，包括&#x2F;root和&#x2F;home&#x2F;user，设置定时备份</p>
<p>如何恢复：</p>
<p>情景一：系统无法进入桌面，但是可以进入recovery模式root操作：</p>
<p>如下图，用<code>timeshift --help</code>查看各种命令，使用<code>timeshift --restore</code>恢复指定snapshot</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305081931009.png" alt="image-20230508193100794"></p>
<p>情景二：系统无法进入recovery模式，但是备份的snapshot数据还在</p>
<p>使用<a href="https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows?ref=itsfoss.com">Ubuntu Live USB</a> ，即装系统的USB进入try ubuntu环境，联网换国内源安装timeshift，再恢复系统盘中的snapshot数据</p>
<p>情景三：磁盘中的snapshot数据损害：只能重装系统，为了避免此情况发生，应该将系统备份到其他硬盘而不仅仅在当前系统盘</p>
<h2 id="Clonezilla克隆系统"><a href="#Clonezilla克隆系统" class="headerlink" title="Clonezilla克隆系统"></a>Clonezilla克隆系统</h2><p>类似windows ghost的整盘克隆：</p>
<p><a href="https://www.linuxbabe.com/backup/how-to-use-clonezilla-live">https://www.linuxbabe.com/backup/how-to-use-clonezilla-live</a></p>
<p>至少需要三个盘：</p>
<p>在U盘写入Clonezilla的live usb iso生成Clonezilla live USB，再以Clonezilla live USB启动，对待备份的SSD盘做系统备份，到另一个SSD或者大USB盘；</p>
<p>恢复也是需要Clonezilla live USB + 有系统备份的盘 + 目标写入盘</p>
<h2 id="关于系统目录"><a href="#关于系统目录" class="headerlink" title="关于系统目录"></a>关于系统目录</h2><p>&#x2F;usr：系统级的目录，可以理解为C:&#x2F;Windows&#x2F;，apt安装的一般在&#x2F;usr&#x2F;bin和&#x2F;usr&#x2F;lib</p>
<p>&#x2F;usr&#x2F;lib：理解为C:&#x2F;Windows&#x2F;System32</p>
<p>&#x2F;usr&#x2F;local：用户级的程序目录，可以理解为C:&#x2F;Progrem Files&#x2F;，用户自己编译的软件默认安装到这个目录下</p>
<p>&#x2F;opt是用户级的目录用来安装大型的第三方附加软件包，可以理解为D:&#x2F;Software</p>
<p>开发过程中为了避免lib冲突，自己编译的包建议放在&#x2F;home&#x2F;&lt;具体的项目目录&gt;，此外注意自己编译基础库设置的LD_LIBRARY_PATH造成系统库链接冲突</p>
<h2 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h2><p>参考：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>随机笔记</title>
    <url>/2023/05/19/%E9%9A%8F%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>马化腾：AI是互联网百年不遇的机遇，有些公司为提振股价太急了</strong></p>
<p>近日，在腾讯2023年股东大会上，腾讯CEO马化腾回应有关ChatGPT和AI相关提问时表示，“我们最开始以为（人工智能）是互联网十年不遇的机会，但是越想越觉得，这是几百年不遇的、类似发明电的工业革命一样的机遇。”</p>
<p>马化腾表示，互联网企业在AI领域都有很多的积累，腾讯也一样在埋头研发，但是并不急于早早做完，把半成品拿出来展示。“对于工业革命来讲，早一个月把电灯泡拿出来，在长的时间跨度上来看是不那么重要的。关键还是要把底层的算法、算力和数据扎扎实实做好，而且更关键的是场景落地，目前（我们）还在做一些思考。我感觉现在有很多公司太急了，感觉是为了提振股价，我们一贯不是这种风格。”</p>
<p>马化腾分享称，<strong>好的公司不能包揽一切，他通过多年管理层经验看到，要聚焦最擅长的领域，才能更好地发挥自己的价值，不能贪图利益，把宝贵的精力分散在其他人更专业的方面去抢一杯羹，专注才能最大化地发展自己的优势。“发现哪些业务和过去的业务能产生1+1大于2的效益，用得上自己过去的经验并且能做到业内最好的水准，经常思考这个，会让自己的动力更足。”</strong></p>
]]></content>
  </entry>
  <entry>
    <title>xv6-annotated:xv6完全注释</title>
    <url>/2023/05/17/xv6-annotated-xv6%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<p>xv6是mit6.828操作系统课程的基于unix v6重新实现的教学操作系统。</p>
<p>本文英文部分是x86版本的xv6(mit6.828 2018及以前的版本)完全注释，github：<a href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p>本文中文部分是我学习xv6过程中添加了部分中文注解</p>
<h1 id="DAS-BOOT"><a href="#DAS-BOOT" class="headerlink" title="DAS BOOT"></a>DAS BOOT</h1><p>First things first: in order for a computer to run xv6, we need to load it from<br>disk into memory and tell the processor to start running it. So how does this<br>all happen?</p>
<h2 id="The-Boot-Process"><a href="#The-Boot-Process" class="headerlink" title="The Boot Process"></a>The Boot Process</h2><p>When you press the power button, the hardware gets initialized by a piece of<br>firmware called the BIOS (Basic Input&#x2F;Output System) that comes pre-installed on<br>the motherboard on a ROM chip. Nowadays, your computer probably uses UEFI loaded<br>from flash memory, but xv6 pretends like it’s 1995 and sticks with BIOS. Since<br>xv6 runs on x86 hardware, we’re gonna have to satisfy all the janky requirements<br>that come with that architecture, in addition to the BIOS’s requirements.</p>
<p>Now the BIOS has to load some <em>other</em> code called the boot loader from disk;<br>then it’s the boot loader’s job to load the OS and get it running. The boot<br>loader has to act as a middle-man because the BIOS has no idea where on the disk<br>you decided to put the OS.</p>
<p>The BIOS will look for the boot loader in the very first sector (512 bytes) of<br>whatever mass storage device you told it to boot from, which we’ll call the boot<br>disk. The processor will execute the instructions it finds there. This means<br>you have to make a choice: either your boot loader has to be less than 512 bytes<br>or you can split it up into smaller parts and have each part load the next one.<br>xv6 takes the first approach.</p>
<p>The BIOS loads the boot loader into memory at address 0x7C00, then sets the<br>processor’s <code>%ip</code> register to that address and jumps to it. Remember that <code>%eip</code><br>is the instruction pointer on x86? Okay cool. But why did I write <code>%ip</code> instead<br>of <code>%eip</code>? Well, the BIOS assumes we’re gonna be using 16 bits because of the<br>hellscape known as backwards-compatibility, so we’ve gotta pretend like it’s<br>1975 before we can pretend it’s 1995. The irony here is that this initial 16-bit<br>mode is called “real mode”. So on top of loading the OS, the boot loader will<br>also have to shepherd the processor from real mode to 32-bit “protected mode”.</p>
<p>One last detail: we’ll look at the Makefile and linker script later on, but for<br>now just keep in mind that the boot loader will be compiled separately from the<br>kernel, which will be compiled separately from all the user-space programs. This<br>makes it easier to make sure that the entire boot loader will fit in the first<br>512 bytes on disk. Eventually, the boot loader and the kernel will be stored on<br>the same boot disk together, and the user-space programs will be on a separate<br>disk that holds the file system.</p>
<h2 id="bootasm-S"><a href="#bootasm-S" class="headerlink" title="bootasm.S"></a>bootasm.S</h2><p>Boot loader space is tight, and we want to make sure our instructions are exact,<br>so we’re gonna start off in assembly. The “.S” file extension means it’s gonna<br>be assembled by the GNU assembler <code>as</code>, and we’re allowed to use C preprocessor<br>directives like <code>#include</code> or <code>#define</code> or whatever in the assembly code. Also,<br>xv6 uses AT&amp;T syntax, so if you read CS:APP or took the online course then it’ll<br>be familiar; if you don’t know what that means, then don’t worry about it.</p>
<h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>First we include some header files to use some constants; I’ll point them out<br>later. Next up, we gotta tell the assembler to generate 16-bit code, and set a<br>global label to tell the BIOS where to start executing code.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.code16         # Tell compiler to generate 16-bit code</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br></pre></td></tr></table></figure>

<p>Next up: you know how sometimes you can press a special key to tell the BIOS to<br>stop what it’s doing and let you pick a disk to boot from? Or you move your<br>mouse around in the BIOS menu and you see the pointer moving? Yeah, that needs<br>hardware interrupts in order to work, but right now, we don’t have the faintest<br>clue how to handle those if they happen, so let’s go ahead and turn those off.<br>There’s an x86 instruction to disable them by clearing the interrupt flag in<br>the CPU’s flags register.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cli</span><br></pre></td></tr></table></figure>

<p>Now we’ve gotta handle some of x86’s quirks. First off, we’re gonna need 20-bit<br>memory addresses, but we only have 16 bits to work with. x86 uses six segment<br>registers <code>%cs</code> (code segment), <code>%ds</code> (data segment), <code>%ss</code> (stack segment),<br><code>%es</code> (extra segment), <code>%fs</code> and <code>%gs</code> (general-purpose segments) to create 20-<br>bit addresses from 16-bit ones; we’re gonna need the first four. The BIOS<br>guarantees that <code>%cs</code> will be set to zero, but it doesn’t make any promises<br>about the others, so we have to clear them ourselves. We’re not using <code>%eax</code> for<br>anything yet, so we’ll use that to clear the others. The <code>w</code> at the end of <code>xorw</code><br>and <code>movw</code> means we’re operating on 16-bit words.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xorw    %ax,%ax</span><br><span class="line">movw    %ax,%ds     # Data segment</span><br><span class="line">movw    %ax,%es     # Extra segment</span><br><span class="line">movw    %ax,%ss     # Stack segment</span><br></pre></td></tr></table></figure>

<p>This next part is a total hack for backwards-compatibility: sometimes a virtual<br>address might get converted to a 21-bit physical address, and oh no, what are we<br>gonna do? Well, some hardware can’t deal with 21 bits, so it just ignores it,<br>but it’s 1995, so we’ve got fancy hardware that can use that extra bit. Wow, you<br>really know we’re in the future when you’ve got a whole 2 MB of RAM to work<br>with! So we have to tell the processor not to throw away that 21st bit. The way<br>we do that is by setting the second bit of the keyboard controller’s output port<br>to line high. I don’t know. Don’t ask me why. The output ports are 0x64 and<br>0x60, so we’re gonna wait until they’re not busy, then set the magic values that<br>will make this all work.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb     $0x64,%al   # Wait for not busy</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.1</span><br><span class="line"></span><br><span class="line">    movb    $0xd1,%al   # 0xD1 -&gt; port 0x64</span><br><span class="line">    outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb     $0x64,%al   # Wait for not busy</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.2</span><br><span class="line"></span><br><span class="line">    movb    $0xdf,%al   # 0xDF -&gt; port 0x60</span><br><span class="line">    outb    %al,$0x60</span><br></pre></td></tr></table></figure>

<h3 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h3><p>Now it’s time to switch to 32-bit “protected mode”. Up until now, the processor<br>has been converting virtual addresses to physical ones using those segment<br>registers which we cleared, so the mapping has been an identity map. But let’s<br>talk about how x86 converts 32-bit virtual addresses to physical ones; this is<br>important for the rest of the boot loader code as well as the OS, so you’re<br>gonna have to bear with me for this maelstrom of x86-specific details.</p>
<p>The x86 architecture does the conversion in two steps: first segmentation, then<br>paging. A virtual address starts off life as a <em>logical address</em>. Segmentation<br>converts that to a <em>linear address</em>, and paging converts that to a physical one.</p>
<p>A logical address consists of a 20-bit <em>segment selector</em> and a 12-bit offset,<br>with the segment bits before the offset bits, like <code>segment:offset</code>. The CPU’s<br>segmentation hardware uses those segment bits to pick one of those four segment<br>registers we cleared earlier, which acts as an index into a <em>Global Descriptor<br>Table</em> or GDT. Each entry of this GDT tells you where that segment is found in<br>memory using a base physical address and a virtual address for the maximum or<br>limit.</p>
<p>The GDT entry also has some permission bits for that segment; the segmentation<br>hardware will check whether each address can be written to and whether the<br>process generating the virtual address has the right permissions to access it.<br>These checks compare the GDT entry’s <em>Descriptor Privilege Levels</em>, also known<br>as <em>ring levels</em>, against the <em>Current Privilege Level</em>. x86 has four privilege<br>levels (0-3), so if you’ve ever heard of the kernel operating in ring 0 or user<br>code in ring 3, this is where it comes from.</p>
<p>Okay, so the GDT entry will give us the first 20 bits of the new linear address;<br>the offset bits stay the same. After that, the linear address is ready to be<br>converted to a physical address by the paging hardware. We’ll go over this<br>second half of the story in the virtual memory section. For now, the point is<br>this: xv6 is mostly gonna say no thank you to segmentation and stick to paging<br>alone for memory virtualization.</p>
<p>So we’re gonna set up our GDT to map all segments the exact same way: with a<br>base of zero and the maximum possible limit (with 32 bits, that works out to a<br>grand total of 4 GB, wow so much RAM, I can’t imagine ever needing more). We<br>have to stick this GDT somewhere in our code so we can point the CPU to it, so<br>we’ll put it at the end and throw a <code>gdtdesc</code> label on it. Now we can tell the<br>CPU to load it up with a special x86 instruction for that.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lgdt    gdtdesc</span><br></pre></td></tr></table></figure>

<h3 id="Protected-Mode"><a href="#Protected-Mode" class="headerlink" title="Protected Mode"></a>Protected Mode</h3><p>Good news, everyone! We’re finally ready to turn on protected mode, which we do<br>by setting the zero bit of the <code>%cr0</code> control register. Note that the <code>l</code> at the<br>end of the instructions here means we’re now using long words, i.e. 32 bits;<br><code>CR0_PE</code> is defined in the <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a><br>header file as 0x1.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    %cr0, %eax      # Copy %cr0 into %eax</span><br><span class="line">orl     $CR0_PE, %eax   # Set bit 0</span><br><span class="line">movl    %ax, %cr0       # Copy it back</span><br></pre></td></tr></table></figure>

<p>Oh wait, I lied. Enabling protection mode like we just did doesn’t change how<br>the processor translates addresses. We have to load a new value into a segment<br>register to make the CPU read the GDT and change its internal segmentation<br>settings. We can do that by using a long jump instruction, which lets us specify<br>a code segment selector. We’re just gonna jump to the very next line anyway, but<br>in doing so we’ll force the CPU to start using the GDT, which describes a 32-bit<br>code segment, so <em>now</em> we’re finally in 32-bit mode! Here, <code>SEG_KCODE</code> is a<br>constant defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as segment 1, for <code>%cs</code>; we bitshift it left by 3.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ljmp    $(SEG_KCODE&lt;&lt;3), $start32</span><br></pre></td></tr></table></figure>

<p>First we signal the compiler to start generating 32-bit code. Then we initialize<br>the data, extra, and stack segment registers to point to the <code>SEG_KDATA</code> entry<br>of the GDT; that constant is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as the segment for the kernel<br>data and stack. We’re not required to set up <code>%fs</code> and <code>%gs</code>, so we’ll just zero<br>them.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.code 32    # Tell assembler to generate 32-bit code now</span><br><span class="line">start32:</span><br><span class="line">    movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector</span><br><span class="line">    movw    %ax, %ds    # Data segment</span><br><span class="line">    movw    %ax, %es    # Extra segment</span><br><span class="line">    movw    %ax, %ss    # Stack segment</span><br><span class="line">    movw    $0, %ax     # Zero the segments not ready for use</span><br><span class="line">    movw    %ax, %fs</span><br><span class="line">    movw    %ax, %gs</span><br></pre></td></tr></table></figure>

<h3 id="The-Kernel-Stack"><a href="#The-Kernel-Stack" class="headerlink" title="The Kernel Stack"></a>The Kernel Stack</h3><p>Okay, last step in the assembly code now: we have to set up a stack in an unused<br>part of memory. In x86, the stack grows downwards, so the “top” of the stack–<br>that is, the most-recently-added byte–is actually at the bottom of the stack in<br>physical memory. It’s annoying, but we’re gonna have to keep track of that. The<br><code>%ebp</code> register points to the base of the stack (i.e., the first byte we pushed<br>onto the stack), and the <code>%esp</code> register holds the address of the top of the<br>stack (most-recently-pushed byte).</p>
<p>But where should we put the stack? The memory from 0xA_0000 to 0x10_0000 is<br>littered with a memory regions that I&#x2F;O devices are gonna be checking, so that’s<br>out. The boot loader starts at 0x7C00 and takes up 512 bytes, so that means it<br>ends at 0x7E00. So xv6 is gonna start the stack at 0x7C00 and have it grow down<br>from there, toward 0x0000 and away from the boot loader. Remember how back in<br>the beginning, we started off the assembly code with a <code>start</code> label? That means<br>that <code>start</code> is conveniently located at 0x7C00.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $start, %esp</span><br></pre></td></tr></table></figure>

<p>And we’re done with assembly! Time to move on to C code for the rest of the boot<br>loader. We’ll take over with a C function called <code>bootmain()</code>, which should<br>never return. The linker will take care of connecting the call here to its<br>definition in <a href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">bootmain.c</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    bootmain</span><br></pre></td></tr></table></figure>

<h3 id="Handling-Errors"><a href="#Handling-Errors" class="headerlink" title="Handling Errors"></a>Handling Errors</h3><p>Wait, what? There’s more assembly code after this? Why?</p>
<p>Well, if something goes wrong in <code>bootmain()</code>, then the function will return, so<br>we have to handle that here. Since we usually run OSes we’re developing in an<br>emulator like Bochs or QEMU, we’ll trigger a breakpoint and loop. Bochs listens<br>on port 0x8A00, so we can transfer control back to it there; this wouldn’t do<br>anything on real hardware.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    movw    $0x8a00, %ax    # 0x8a00 -&gt; port 0x8a00</span><br><span class="line">    movw    %ax, %dx</span><br><span class="line">    outw    %ax, %dx</span><br><span class="line">    movw    $0x8ae0, %ax    # 0x8ae0 -&gt; port 0x8a00</span><br><span class="line">    outw    %ax, %dx</span><br><span class="line">spin:</span><br><span class="line">    jmp     spin            # loop forever</span><br></pre></td></tr></table></figure>

<h3 id="The-Global-Descriptor-Table"><a href="#The-Global-Descriptor-Table" class="headerlink" title="The Global Descriptor Table"></a>The Global Descriptor Table</h3><p>Oh, and remember when we promised the hardware that we were gonna give it a GDT?<br>We even told it to load it from address <code>gdtdesc</code>, remember? Well, we have to<br>deliver on that promise now by defining the GDT here.</p>
<p>x86 expects that the GDT will be aligned on a 32-bit boundary, so we tell the<br>assembler to do that. Then we use the macros <code>SEG_NULLASM</code> and <code>SEG_ASM</code> defined<br>in <a href="https://github.com/mit-pdos/xv6-public/blob/master/asm.h">asm.h</a> to create three segments: a null segment, a segment for executable<br>code, and another for writeable data. The null segment has all zeroes; the first<br>argument to <code>SEG_ASM</code> has the permission bits, the second is the physical base<br>address, and the third is the maximum virtual address. As we said before, xv6<br>relies mostly on paging, so we set the segments to go from 0 to 4 GB so they<br>identity-map all the memory.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.p2align 2      # force 4-byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                             # null segment</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code segment</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)         # data segment</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word   (gdtdesc - gdt - 1)     # sizeof(gdt) - 1</span><br><span class="line">    .long   gdt                     # address of gdt</span><br></pre></td></tr></table></figure>

<h2 id="bootmain-c"><a href="#bootmain-c" class="headerlink" title="bootmain.c"></a>bootmain.c</h2><p>Okay, the rest of the boot loader is in C now! Most of the code here is just to<br>interact with the disk in order to read the kernel from disk and load it into<br>memory. Let’s start off by looking at <code>waitdisk()</code>.</p>
<h3 id="waitdisk"><a href="#waitdisk" class="headerlink" title="waitdisk"></a>waitdisk</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HEAD. DESK. Why all the magic numbers? At least we’re lucky that the name makes<br>it obvious what this function does; this won’t always be true in xv6. Okay, so<br>this function does only one thing: it loops until the disk is ready. Disk specs<br>are boring as all hell, so feel free to skip to the next section if you don’t<br>care about the particulars (I don’t blame you).</p>
<p>The usual way to talk to the disk is with Direct Memory Access (DMA), in which<br>devices are hooked up directly to RAM for easy communication. But we haven’t<br>initialized the disk at all or set up any drivers for it; that’s the OS’s<br>responsibility, not the boot loader’s. Even if we could ask the disk to give us<br>some data through memory-mapped I&#x2F;O, we disabled all interrupts, so we wouldn’t<br>know when it’s ready. So instead, we have to go back to assembly code (ugh, I<br>know) to access the disk directly.</p>
<p>Storage disks have all kinds of standardized specifications, among them IDE<br>(Integrated Drive Electronics) and ATA (Advanced Technology Attachment). The<br>ATA specs include a Programmed I&#x2F;O mode where data can be transferred between<br>the disk and CPU through I&#x2F;O ports. This is usually a huge waste of resources<br>because every byte has to be transferred through a port and the CPU is busy the<br>entire time, but right now beggars can’t be choosers.</p>
<p>Each disk controller chip has two buses (primary and secondary) for use with ATA<br>PIO mode; the primary bus sends data on port 0x1F0 and has control registers on<br>ports 0x1F1 through 0x1F7. In particular, port 0x1F7 is the status port, which<br>will have some flags to let us know what it’s up to. The sixth bit (or 0x40 in<br>hex) is the RDY bit, which is set when it’s ready to receive more commands. The<br>seventh bit (i.e., 0x80) is the BSY bit, which if set says the disk is busy.</p>
<p>Since interrupts are disabled, we’ll have to manually poll the status port in an<br>infinite loop until the BSY bit is not set but the RDY bit is: <code>inb()</code> is a C<br>wrapper (defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">x86.h</a>) for the x86 assembly instruction <code>inb</code>, which reads<br>from a port. We don’t care about any of the other status flags, so we’ll get rid<br>of them by bitwise-ANDing the result with 0xC0 &#x3D; 0x40 + 0x80. If the result of<br>that is 0x40, then only the RDY bit is set and we’re good to go.</p>
<p>Phew. That was a lot for just one line of code.</p>
<h3 id="readsect"><a href="#readsect" class="headerlink" title="readsect"></a>readsect</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Issue command</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);</span><br><span class="line">    outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read data</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you skipped the last section: this function reads a sector (which in the<br>current-year-according-to-xv6 of 1995 is 512 bytes) from disk. Good to see you<br>again, on to the next section for you!</p>
<p>If you powered through the pain and read about ATA PIO mode above, some of the<br>magic numbers here might be familiar. First we call <code>waitdisk()</code> to wait for the<br>RDY bit, then we send some stuff over ports 0x1F2 through 0x1F7, which we know<br>are the command registers for the primary ATA bus.</p>
<p>Note that <code>uint</code> is just a type alias for C’s <code>unsigned int</code>, defined in the<br>header file <a href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">types.h</a>. The <code>offset</code> argument is in bytes, and determines which<br>sector we’re gonna read; sector 0 has to hold the boot loader so the BIOS can<br>find it, and in xv6 the kernel will start on disk at sector 1.</p>
<p><code>outb()</code> is another C wrapper for an x86 instruction from <a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>; this one’s<br>the opposite of <code>inb()</code> because it sends data out to a port. The disk controller<br>register at port 0x1F2 determines how many sectors we’re gonna read. Ports 0x1F3<br>through 0x1F6 are where the sector’s address goes. If you <em>really</em> must know<br>(why?) they’re the sector number register, the cylinder low and high registers,<br>and the drive&#x2F;head register, in order. Port 0x1F7 was the status port above, but<br>it also doubles as the command register; we send it command 0x20, aka READ<br>SECTORS.</p>
<p>Then we wait for the RDY bit again before reading from the bus’s data register<br>at port 0x1F0, into the address pointed to by <code>dst</code>. Once again, <code>insl()</code> is a<br>C wrapper for the x86 instruction <code>insl</code>, which reads from a port into a string.<br>The <code>l</code> at the end means it reads one long-word (32 bits) at a time.</p>
<h3 id="readseg"><a href="#readseg" class="headerlink" title="readseg"></a>readseg</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(uchar *pa, uint count, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar *epa = pa + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round down to sector boundary</span></span><br><span class="line">    pa -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time. We&#x27;d write</span></span><br><span class="line">    <span class="comment">// more to memory than asked, but it doesn&#x27;t matter -- we load in increasing</span></span><br><span class="line">    <span class="comment">// order.</span></span><br><span class="line">    <span class="keyword">for</span> (; pa &lt; epa; pa += SECTSIZE, offset++) &#123;</span><br><span class="line">        readsect(pa, offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Okay, finally, we’re done with assembly and disk specs. We’re gonna read <code>count</code><br>bytes starting from <code>offset</code> into physical address <code>pa</code>. Note that <code>uchar</code> is<br>another type alias for <code>unsigned char</code> from <a href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>; this means that <code>pa</code> is a<br>pointer (which is 32 bits in x86) to some data where each piece is 1 byte.</p>
<p><code>epa</code> will point to the end of the part we want to read. Now, <code>count</code> might not<br>be sector-aligned, so we fix that. Declaring <code>pa</code> as a <code>uchar *</code> lets us do this<br>pointer arithmetic easily because we know that adding 1 to <code>pa</code> makes it point<br>at the next byte; if it were a <code>void *</code> like in <code>readsect()</code>, pointer arithmetic<br>would be undefined. (Actually, GCC lets you do it anyway, but GCC lets you get<br>away with a lot of crazy stuff, so let’s not go there.)</p>
<p>Now that we’ve got everything set up, we just call <code>readsect()</code> in a for loop to<br>read one sector at a time, and that’s it!</p>
<p>Some people have asked about the structure of some of the for loops in xv6,<br>because they don’t always use obvious index variables like <code>int i</code>. There are<br>plenty of reasons to hate C, but I think the way it structures for loops is by<br>far one of its most powerful features:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test condition; update statements) &#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When evaluating the for loop, C first executes anything in the initialization.<br>Then it checks whether the test condition is true; if so, it executes the code<br>inside the loop. Then it carries out the update statements before checking the<br>test condition again and runnning the code if it’s still true.</p>
<p>In the for loop above, the initialization is just an empty statement; all the<br>variables we want to use have already been set up, so we don’t need it and C<br>will just move on to the next step. The test condition is simple enough. But the<br>update statement actually increments both <code>pa</code> and <code>offset</code> at once before going<br>through the loop again.</p>
<p>Okay great, so now we can read from the disk into memory, so we’re all set up to<br>load the kernel and start running it!</p>
<h3 id="ELF-Files"><a href="#ELF-Files" class="headerlink" title="ELF Files"></a>ELF Files</h3><p>Before we move on to the star of the show, <code>bootmain()</code>, we need to talk about<br>how a computer can actually recognize a file as executable. When you compile<br>some code, the result gets spit out in a format that your machine can recognize,<br>load into memory, and run; it’s usually the linker’s job to do this. Most Unix<br>and Unix-like systems use the standardized Executable and Linkable Format, or<br>ELF, for this purpose.</p>
<p>ELF divides the executable file into sections: <code>text</code> (the code’s instructions),<br><code>data</code> (initialized global variables), <code>bss</code> (statically-allocated variables<br>that have been declared but not initialized), <code>stab</code> and <code>stabstr</code> (debugging<br>symbols and similar info), <code>rodata</code> (read-only data, usually stuff like string<br>literals).</p>
<p>An ELF file starts with a header which has a magic number: 0x7F followed by the<br>letters “ELF” represented as ASCII bytes; an OS can use this to recognize an ELF<br>file. The header also tells you the file’s type: it could be an executable, or a<br>library to be linked with executables, or something else. There’s a whole bunch<br>of other info in the header, like the architecture it’s made to run on, version,<br>etc., but we’re gonna ignore most of that.</p>
<p>The most important parts of the header are the part where it tells us where in<br>the file the processor should start executing instructions and the part that<br>describes the number of entries, on-disk offset, and size of the program header<br>table.</p>
<p>The program header table is an array that has one entry for each of the file<br>sections above that’s found in this program. It describes the offset in the file<br>where each section can be found along with the physical and virtual address at<br>which that section should be loaded into memory and the size of the section,<br>both in the file and in memory; these might differ if, e.g. the program contains<br>some uninitialized variables which don’t need to be stored in the file but do<br>need to have space in memory.</p>
<p>The kernel (along with all the user-space programs) will be compiled and linked<br>as ELF files, so <code>bootmain()</code> will have to parse the ELF header to find the<br>program header table, then parse that to load each section into memory at the<br>right address. xv6 uses a <code>struct elfhdr</code> and a <code>struct proghdr</code>, both defined<br>in <a href="https://github.com/mit-pdos/xv6-public/blob/master/elf.h">elf.h</a>, for this purpose.</p>
<p>Okay, back to the boot loader to finish up now!</p>
<h3 id="bootmain"><a href="#bootmain" class="headerlink" title="bootmain"></a>bootmain</h3><p>This is the C function that gets called by the first part of the boot loader<br>written in assembly. Its job will be to load the kernel into memory and start<br>running it at its entry point, a program called <code>entry()</code>.</p>
<p>Next up, we’re gonna use <code>readseg()</code> to load the kernel’s ELF header into memory<br>at physical address 0x1_0000; the number isn’t too important because the header<br>won’t be used for long; we just need some scratch space in some unused memory<br>away from the boot loader’s code, the stack, and the device memory-mapped I&#x2F;O<br>region. We’ll read 4096 bytes first at offset 0; <code>readseg()</code> turns that offset<br>into sector 1. Remember that we have to convert <code>elf</code> into a <code>uchar *</code> so that<br>the pointer arithmetic in <code>readseg()</code> works out the way we want it to.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> elfhdr *) <span class="number">0x10000</span>;</span><br><span class="line">    readseg((uchar *) elf, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>While we’re at it, let’s go ahead and make sure that what we’re loading really<br>is an ELF file and not some random other garbage because any of a million things<br>went wrong during the compilation process, or we got some rootkit that totally<br>corrupted the kernel or something. It’s not really the most robust of checks,<br>but <em>eh</em>. If something went wrong we’ll just return, since we know that the code<br>in <code>bootasm.S</code> is ready to handle that with some Bochs breakpoints.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have to look at the program header table to know where to find each of<br>the kernel’s segments. The <code>elf-&gt;phoff</code> field tells us the program header<br>table’s offset from the start of the ELF header, so we’ll set <code>ph</code> to point to<br>that and <code>eph</code> to point to the end of the table.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (<span class="keyword">struct</span> proghdr *) ((uchar *) elf + elf-&gt;phoff);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">eph</span> =</span> ph + elf-&gt;phnum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each entry in the program header table tells us where to find a segment, so<br>we’ll iterate over the entries, reading each one from disk and loading it up. In<br>this for loop, note that <code>ph</code> is a <code>struct proghdr *</code>, so incrementing it with<br><code>ph++</code> increments it by the size of a <code>struct proghdr</code> and not by one byte; this<br>makes it automatically point at the next entry in the table.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">        uchar *pa = (uchar *) ph-&gt;paddr;    <span class="comment">// address to load section into</span></span><br><span class="line">        readseg(pa, ph-&gt;filesz, ph-&gt;off);   <span class="comment">// read section from disk</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the segment&#x27;s size in memory is larger than the file image</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;memsz &gt; ph-&gt;filesz) &#123;</span><br><span class="line">            stosb(pa + ph-&gt;filesz, <span class="number">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That if statement at the end checks if the section’s size in memory should be<br>larger than its size in the file, in which case it calls <code>stosb()</code>, which is yet<br>another C wrapper from <a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a> for the x86 instruction <code>rep stosb</code>, which block<br>loads bytes into a string. It’s used here to zero the rest of the memory space<br>for that section. Okay, but why would we want to do that? Well, if the reason<br>it’s larger is because it has some uninitialized static variables, then we want<br>to make sure those start off holding zero (as the C standard requires) and not<br>whatever garbage value may have been there before.</p>
<p>Last part of the bootloader: let’s call the kernel’s entry point, <code>entry()</code>, and<br>get it running! But remember how the boot loader is compiled and linked<br>separately from the kernel? Yeah, that means we can’t just call <code>entry()</code> as a<br>function, because then the linker would go “Huh? What entry function? I don’t<br>have any <code>entry</code> function here in your symbol table. REJECTED.” And then it<br>would throw a huge error.</p>
<p>Luckily, the ELF header tells us where to find the entry point in memory, so we<br>could get a pointer to that address. That means… function pointers! If you’ve<br>never used function pointers in C before, then this won’t be the last time<br>you’ll see them in xv6, so check it out.</p>
<p>A C function is just a bunch of code to be executed in order, right? That means<br>it shows up in the ELF file’s <code>text</code> section, which will end up in memory. When<br>you call a regular old C function, the compiler just adds some extra assembly<br>instructions to throw a return address on the stack and update the registers<br><code>%ebp</code> and <code>%esp</code> to point to the new function’s stack on top of the old one. If<br>the function getting called has any arguments or local variables, they’ll get<br>pushed onto the stack too. Then the instruction register <code>%eip</code> gets updated to<br>point to the new function section, and that’s it. After the compiler is done,<br>the linker will replace the function’s name with its memory address in the<br><code>text</code> section, and voila, a function call.</p>
<p>The point of all this is that in C we can use pointers to functions; they just<br>point to the beginning of that function’s instructions in memory, where the<br><code>%eip</code> register would end up pointing if the function gets called. So in this<br>case, even though we’re not linking with the kernel, we can still call into the<br>entry point by getting its address from the ELF header, creating a function<br>pointer to that address, then calling the function pointer. The compiler will<br>still add all the usual stack magic, but instead of the linker determining where<br><code>%eip</code> should point, we’ll do that ourselves.</p>
<p>The first line below declares <code>entry</code> as a pointer to a function with argument<br>type <code>void</code> and return type <code>void</code>. Then we set <code>entry</code> to the address from the<br>ELF header, then we call it.</p>
<p>Again, this shouldn’t return, but if it does then it’s the last part of this<br>function, so this function will return back into the assembly boot loader code.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">void</span> (*entry)(<span class="type">void</span>);</span><br><span class="line">    entry = (<span class="type">void</span>(*) (<span class="type">void</span>)) (elf-&gt;entry);</span><br><span class="line">    entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s it! Starting from <code>entry()</code>, we’re officially out of the boot loader and<br>into the kernel.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, the assembly part of the boot loader (1) disabled interrupts, (2)<br>set up the GDT and segment registers so the segmentation hardware is happy and<br>we can ignore it later, (3) set up a stack, and (4) got us from 16-bit real mode<br>to 32-bit protected mode.</p>
<p>Then the C part of the boot loader just loaded the kernel from disk and called<br>into its entry point.</p>
<p>ELF headers will continue to haunt us in the kernel’s linker script and when we<br>load user programs from disk in <code>exec()</code>, and function pointers will make<br>another appearance when we get around to handling interrupts. The good news: the<br>boot loader is one of the most opaque parts of the xv6 code, full of boring<br>hardware specs and backwards-compatibility requirements, so if you made it this<br>far, it does get better!</p>
<p>(But it also gets worse… looking at you, <a href="https://github.com/mit-pdos/xv6-public/blob/master/mp.c">mp.c</a> and <a href="https://github.com/mit-pdos/xv6-public/blob/master/kb.c">kbd.c</a>…)</p>
<h1 id="The-Beginning-Entry-and-Paging"><a href="#The-Beginning-Entry-and-Paging" class="headerlink" title="The Beginning: Entry and Paging"></a>The Beginning: Entry and Paging</h1><h2 id="xv6’s-Memory-Layout"><a href="#xv6’s-Memory-Layout" class="headerlink" title="xv6’s Memory Layout"></a>xv6’s Memory Layout</h2><p>The whole point of virtualizing memory is to give users the illusion that they<br>can roam freely across a limitless field of memory without worrying their pretty<br>little heads about such boring details as how much physical memory their machine<br>actually has, or where kernel code is stored, or the fact that their seemingly-<br>continuous heap space is actually shattered into tons of tiny pages spread out<br>in possibly random parts of physical memory. As long as user code is well-<br>behaved, that illusion should hold up; if they do a no-no we’ll just smack them<br>with a segmentation fault.</p>
<p>One downside is that the kernel also has to use virtual memory, so we’re faced<br>with the potentially-complicated challenge of setting things up in physical<br>memory without knowing where anything is actually located in physical memory! So<br>xv6 does something that a lot of OSes do: it sets itself up as a higher-half<br>kernel. That means that in the virtual address space (from 0 to 4 GB), the<br>kernel will reside in the upper half starting at 2 GB, i.e. address 0x8000_0000<br>and up; user code will start at 0 and end at 2 GB. Because of this, <code>KERNBASE</code><br>is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a> as 0x8000_0000.</p>
<p>Then it sets up paging so that all of physical memory is identity-mapped to<br>virtual memory starting at 0x8000_0000. This makes it really convenient for the<br>kernel to figure out the physical address of a virtual address it’s using; just<br>subtract <code>KERNBASE</code> and you’re done. The <code>V2P</code> and <code>V2P_WO</code> macros defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a> do just that, and the <code>P2V</code> and <code>P2V_WO</code> add <code>KERNBASE</code> to a<br>physical address to get the kernel virtual address.</p>
<p>Note that I said “kernel virtual address”, not just any old virtual address.<br>Users don’t get these kinds of fancy privileges, because they shouldn’t be<br>worrying about where anything is in physical memory. They’re running through a<br>limitless field of virtual memory, remember? So user virtual addresses between 0<br>and 2 GB will get mapped to totally arbitrary locations in physical memory.</p>
<p>One consequence of this is that xv6 is limited to no more than 2 GB of physical<br>memory (instead of the 4 GB that 32-bit addresses allow for) in order to map it<br>all into the top 2 GB of virtual memory. In reality, it’s even less, for two<br>reasons: (1) we also need to map device I&#x2F;O regions into virtual memory, so<br>it’ll be a little less than 2 GB, and (2) it’s hard and annoying to figure out<br>how much physical memory is actually present on any given machine, so xv6 just<br>says to hell with all that and picks the totally arbitrary value of a puny 224<br>MB as the amount of available physical memory (that’s <code>PHYSTOP</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a>).</p>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>Remember when we talked about segmentation, and how we said we’d come back to<br>paging later? Guess what? It’s later.</p>
<p>So all virtual addresses are really “logical addresses”, and segmentation turns<br>those into “linear addresses”. In xv6, the boot loader set up the segmentation<br>hardware to use an identity map, so virtual addresses are the same as logical<br>addresses are the same as linear addresses. Now paging has to turn those linear<br>addresses into physical addresses. Just like segmentation uses a GDT and the<br>segment registers for its mapping, paging uses a page directory, page tables,<br>and the <code>%cr3</code> register.</p>
<p>First, imagine a world where every single time some user code throws up an<br>address (maybe it looks up a variable, or it calls a function, or it simply<br>needs to execute the next instruction), the CPU has to stop what it’s doing,<br>save all the user’s register contents, load up some kernel code, restore its<br>register contents, find out where its stack is, get it running, and then ask the<br>OS where that virtual address is actually located in physical memory. That would<br>be <em>so</em> slow. We don’t want that. We want the hardware to do all the address<br>conversions by itself, and involve the OS only minimally to set up a new page<br>directory when it starts a new process.</p>
<p>Instead, the x86 hardware uses one of its control registers, <code>%cr3</code>, to store a<br>pointer to a page directory in memory. Then every time it needs to map a linear<br>address to a physical one, it goes to that page directory and grabs the relevant<br>entry. That entry is a pointer to a page <em>table</em> somewhere else in memory, so<br>the processor grabs the right entry from there, which points to a 4096-byte page<br>in some other location.</p>
<p>A linear address has a three-part structure: the 10 most significant bits are an<br>index that picks an entry from the page directory, the next 10 bits are an index<br>to pick an entry from whatever page table we’ve been directed to, and the last<br>12 bits are an offset that determines where to look in the page that the page<br>table entry pointed to.</p>
<p>For example, let’s say we have a virtual address like 0x9C4A_02BF. If we convert<br>to binary, split it up, and convert back to hex, we can see that the 10 most<br>significant bits are 0x271, the next 10 are 0x0A0, and the last 12 are 0x2BF. So<br>the paging hardware would look at wherever <code>%cr3</code> is pointing to find the page<br>directory; let’s just call it <code>pgdir</code>. Then it would take entry <code>pgdir[0x271]</code><br>and go look wherever that’s pointing to find the right page table; let’s call<br>that <code>pgtab271</code>. Then it would take entry <code>pgtab271[0x0A0]</code> and look wherever<br>that’s pointing to find the right page, <code>pg</code>. <em>Then</em> it would finally<br>know that the corresponding physical address is <code>pg + 0x2BF</code>. Whew.</p>
<p>This still sounds super slow, so the paging hardware uses a cache called the<br>Translation Lookaside Buffer (TLB) to store recently-used mappings and make them<br>faster in the future. Since pages are 4096 bytes, it only needs to map a new<br>page if the addresses some code is asking for crosses a page boundary.</p>
<p>xv6 provides two macros, <code>PDX</code> and <code>PTX</code> defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>, to recover just the<br>page directory index bits or the page table index bits, respectively, from a<br>virtual address.</p>
<p>Finally: an important aspect of virtual memory is that each process should be<br>isolated from the others, and the kernel should be isolated from user processes.<br>So each process will get its own page directory, and each entry of that page<br>directory will say whether it’s present (i.e., mapped) or not. If it’s present,<br>then it points to a page table for that process; if it’s not present and we try<br>to access it, we’ll get a page fault or a general protection fault. Each entry<br>in a page table will also say whether that page is present and what kinds of<br>permissions it has. The bit flags for the permissions are (in order from least<br>to most significant bit):</p>
<ul>
<li>Bit 0: present.</li>
<li>Bit 1: read&#x2F;write.</li>
<li>Bit 2: user (otherwise only the kernel can access it).</li>
<li>Bit 3: write-through.</li>
<li>Bit 4: cache disabled.</li>
<li>Bit 5: accessed (for the TLB).</li>
<li>Bit 6: page size (we’ll talk about this later).</li>
<li>Bit 7: (unused).</li>
</ul>
<p>This way, since each process has its own page directory, page tables, and pages,<br>and each level has specific permissions set, they should never be able to<br>interfere with each other.</p>
<p>Again, most of the time, the kernel will just happily ignore all this and use<br>the mapping in the higher half of virtual memory for simplicity. Each user<br>process’s page directory will have the same mapping in the higher half so that<br>the kernel can keep doing what it’s doing no matter which user process is<br>currently running.</p>
<p>Anyway, back to the code! We left off after the boot loader had finished loading<br>the kernel into memory; it ended by calling an <code>entry()</code> function in the kernel.<br>We haven’t set up paging yet, so that’s next on our to-do list. But first, the<br>kernel is compiled and linked using a <em>linker script</em>, so we’ll have to look at<br>that to understand how that sets up memory the way we want it.</p>
<h2 id="kernel-ld"><a href="#kernel-ld" class="headerlink" title="kernel.ld"></a>kernel.ld</h2><p>The gory details of linker scripts as a whole are outside the scope of these<br>posts, so I’m gonna gloss over a lot of the parts of this file and focus on<br>the important pieces.</p>
<p>It’s important to understand what a linker does in a rough sense, so I’ll just<br>generalize and wave my hands around and say that a compiler takes code in a<br>high-level language and converts it to assembly, an assembler takes that<br>assembly code and turns it into machine code, and a linker takes a whole bunch<br>of machine code files (including any code for library functions) and links them<br>all together into a single executable file.</p>
<p>注释: compiler -&gt; assembler -&gt; linker, high-level language -&gt; asm code -&gt; machine code</p>
<p>Linking involves three steps that are important for us here: first, the linker<br>has to assign each piece of code a location in memory, so that different<br>variables, functions, etc. don’t end up colliding; then it replaces references<br>to that object with its address. Second, it has to resolve any outstanding<br>symbols (variables, functions, etc.) in each file by looking them up in all the<br>other files and replacing them with those addresses; the linker can define its<br>own symbols too. Third, it has to create an output file in a format that the OS<br>can use, like ELF.</p>
<p>注释: 链接的本质是将符号(symbol)替换为地址值(address)，symbol主要指函数；链接输出二进制程序例如elf</p>
<p>xv6 has decided that command-line flags are too basic for it, so instead it’ll<br>use a linker script <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a> for the GNU linker.</p>
<p>We start off by specifying the output format (32-bit ELF), the architecture<br>(x86, also known as i386), and the entry point to start executing code. The<br>convention is to call the entry point <code>_start</code>; the ELF header will include its<br>address, which is how we were able to call it from the boot loader.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure>

<p>Next up come the sections. Remember the ELF sections <code>text</code>, <code>rodata</code>, <code>data</code>,<br><code>bss</code>, and <code>stab</code>? Well we’ve gotta tell the linker where to set them up in<br>memory, using commands like <code>. = address</code>. These are virtual addresses, so since<br>we want to set up our kernel in the higher half of virtual memory, we’ll tell it<br>to link the code start at 0x8010_0000. Again, we use that address instead of<br>0x8000_0000 (which maps to physical address 0) because we have to avoid the<br>address spaces of the boot loader and the memory-mapped I&#x2F;O devices.</p>
<p>We can also tell the linker where in physical memory the code should be placed<br>(in linker script lingo, its “load address”) using the <code>AT(address)</code> command.<br>We’ll use the physical address 0x0010_0000, since that maps to virtual address<br>0x8010_0000.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x80100000;</span><br><span class="line"></span><br><span class="line">    .text : AT(0x100000) &#123;</span><br><span class="line">        /* this part tells the linker which files to include in this section */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* more sections here... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s one other detail we should check out: the linker can create its own<br>symbols using the <code>PROVIDE(symbol = .)</code> command. If the code happens to declare<br>its own variable <code>symbol</code>, then the linker will just throw away its own version<br>of it, but if the code uses <code>symbol</code> without defining it, then the linker will<br>replace those references with the contents of that memory location.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* virtual address and text sections are defined as above */</span><br><span class="line"></span><br><span class="line">    PROVIDE(etext = .);     /* etext will be at the address right after the end</span><br><span class="line">                            of the text section */</span><br><span class="line"></span><br><span class="line">    /* rodata, stab, and stabstr sections defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(data = .);      /* data will be at the address at the very beginning</span><br><span class="line">                            of the data section */</span><br><span class="line"></span><br><span class="line">    /* data section defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(edata = .);     /* edata will be at the address right after the end</span><br><span class="line">                            of the data section */</span><br><span class="line"></span><br><span class="line">    /* bss section defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(end = .);       /* end will be at the very last address at the end</span><br><span class="line">                            of the entire kernel code */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Those variables will be used later in the kernel code; not so much for their<br>contents but for their addresses, as pointers to the virtual addresses of<br>specific parts of the kernel’s code in memory. On to the kernel!</p>
<h2 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h2><p>I have bad news. That <code>entry()</code> function that the boot loader called? It’s in<br>assembly again. :(</p>
<h3 id="Multiboot-Header"><a href="#Multiboot-Header" class="headerlink" title="Multiboot Header"></a>Multiboot Header</h3><p>Okay, so first off, we’ve got some more hideous specs to deal with for a bit in<br>the form of a multiboot header. Multiboot is a specification that lets boot<br>loaders load up kernel code in a standardized way; the GNU boot loader GRUB uses<br>it. So this part is mostly here in case you want to run xv6 on real hardware<br>using GRUB; feel free to skip to <code>entry()</code> below.</p>
<p>The original Multiboot specification has since been replaced with Multiboot 2,<br>but again, it’s 1995, so we don’t know about that yet.</p>
<p>Multiboot helps compliant kernels and boot loaders identify each other using a<br>special header. The header must be completely contained in the first 8192 bytes<br>of the kernel’s image, and it must be 32-bit aligned. The header contains three<br>things: (1) a magic number used for mutual identification and recognition<br>(0x1BADB002 for kernels, 0x2BADB002 for boot loaders), (2) some flags for the<br>kernel to inform the boot loader what the kernel requires in order to run<br>successfully, and (3) a 32-bit unsigned checksum which when added to the other<br>two fields must have a 32-bit unsigned sum of zero. Depending on the flags that<br>are set, there may be other components to the Multiboot header.</p>
<p>So we’ll start by creating a <code>multiboot_header</code> label at the beginning of the<br>file (and thus, the beginning of the kernel image) and making sure it’s aligned<br>to 32 bits.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.p2align 2      # Force 4-byte alignment</span><br><span class="line">.text</span><br><span class="line">.globl multiboot_header</span><br><span class="line">multiboot_header:</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Now we’ll just add the magic number, set the flags to 0 to indicate no special<br>requirements, and add the checksum.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define magic 0x1badboo2</span><br><span class="line">#define flags 0</span><br><span class="line">.long magic</span><br><span class="line">.long flags</span><br><span class="line">.long (-magic-flags)</span><br></pre></td></tr></table></figure>

<p>And that’s it!</p>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>Back in <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, we said that the linker would set up the kernel’s ELF<br>header to specify the kernel’s entry point using <code>_start</code>, but <code>_start</code> itself<br>wasn’t actually defined there, so we have to do that first. We don’t know where<br>this code will end up in memory, so we’ll define an <code>entry</code> label and set<br><code>_start</code> to the address of <code>entry</code>. Note that the linker script used virtual<br>addresses in the higher half, but we haven’t set up paging yet, so we’ll have to<br>convert it to a physical address using one of the macros we mentioned earlier.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start = V2P_WO(entry)</span><br><span class="line">.globl entry</span><br></pre></td></tr></table></figure>

<p>Next up we want to finish setting up virtual memory by enabling paging, but<br>that’s all kinds of complicated, so we’re gonna start off with a super simple<br>version of paging. Part of that difficulty is that there’s a bootstrap problem:<br>we need to allocate pages to hold the page tables themselves, but we can’t use<br>pages without page tables… uhh…</p>
<p>We’ll solve that by starting off with a basic, super-simple page directory where<br>only two entries are mapped: the first entry maps virtual addresses 0 to 4 MB to<br>physical addresses 0 to 4 MB, and the second entry maps virtual addresses<br><code>KERNBASE</code> to <code>KERNBASE</code> + 4MB to physical addresses 0 to 4 MB. One consequence<br>is that the entire kernel code and data has to fit in 4 MB.</p>
<p>Why the two entries pointing to the same place? It’s to solve another bootstrap<br>problem. The kernel is currently running in physical addresses close to 0. Once<br>we enable paging and start using virtual addresses in the higher half, the stack<br>pointer <code>%esp</code>, instruction pointer <code>%eip</code>, even the pointer in <code>%cr3</code> to the<br>page directory itself will all still point to low addresses until we update<br>them. But updating them requires executing instructions, which would require<br>accessing low addresses a few more times. If we left out the low addresses, we’d<br>get a page fault, and since we don’t have exception handlers set up yet, that<br>would cause a double fault, which would turn into the dreaded <strong>TRIPLE FAULT</strong>,<br>in which the processor enters an infinite reboot loop. So yeah, point is, we<br>need both the low and high mappings for now; we’ll get rid of the low mappings<br>once we’re done setting up.</p>
<p>But wait! Aren’t page directory entries supposed to point to page tables? How<br>can they point directly to pages here? It turns out that x86 can skip that<br>second layer altogether if we use so-called “huge” pages of 4 MB in size instead<br>of the usual 4 KB. In the long run, this could lead to internal fragmentation,<br>but it does cut down on the overhead and allows a faster set-up. Plus we’re only<br>gonna use them for a minute while we get ready for the full paging ordeal.</p>
<p>To use 4 MB pages, we have to enable x86’s Page Size Extension (PSE) by setting<br>the fourth bit in the <code>%cr4</code> register. <code>CR4_PSE</code> is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as 0x10,<br>or 00010000 in binary.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry:</span><br><span class="line">    movl    %cr4, %eax</span><br><span class="line">    orl     $(CR4_PSE), %eax</span><br><span class="line">    movl    %eax, %cr4</span><br></pre></td></tr></table></figure>

<p>We need a page directory before we can set up paging; again, basic version now,<br>full glorious page directory later. We’re gonna do the same thing we did in the<br>boot loader where we tell the processor to load the page directory now but then<br>procrastinate actually writing it; this time, we’ll write it in C and call it<br><code>entrypgdir</code>. Then we’ll load its physical address into register <code>%cr3</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class="line">movl    %eax, %cr3</span><br></pre></td></tr></table></figure>

<p>Now we can enable (a basic version of) paging! We tell the CPU to start using<br>the page directory in <code>%cr3</code> by setting bit 31 (paging) of register <code>%cr0</code>; we<br>can also set bit 16 (write protect) of the same register to prevent writing to<br>any pages that the page directory and page tables have marked as read-only.<br><code>CR0_PG</code> and <code>CR0_WP</code> are defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> to set these bits.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $(CR0_PG|CR0_WP), %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>

<p>Now remember how the processor is still running at low addresses? Yeah, let’s<br>fix that. First we’ll make a new kernel stack in the higher half that will still<br>be valid even after we get rid of the lower address mappings. We’ll have the<br>linker save some space for us under the symbol <code>stack</code> and set it up there;<br><code>KSTACKSIZE</code> is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 4096 bytes. So we just set the stack<br>pointer register <code>%esp</code> to the top of that section in order to let the stack<br>grow down toward the address of <code>stack</code>. Again, we’ll procrastinate actually<br>defining <code>stack</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $(stack + KSTACKSIZE), %esp</span><br></pre></td></tr></table></figure>

<p>Now we want to call into the <code>main()</code> function, but we don’t just want to do<br>that the usual assembly way of <code>call main</code>. That would generate a jump relative<br>to the current value of <code>%eip</code>, which is still in low addresses. We’ll use an<br>indirect jump instead.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     $main, %eax</span><br><span class="line">jmp     *%eax</span><br></pre></td></tr></table></figure>

<p>Finally, we need to get around to reserving space for the stack. We can do that<br>with the assembler instruction <code>.comm symbol, size</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.comm stack, KSTACKSIZE</span><br></pre></td></tr></table></figure>

<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>Awesome, back to C code now! Remember how we procrastinated actually defining<br><code>entrypgdir</code>? Let’s do that now; it’s at the bottom of <a href="https://github.com/mit-pdos/xv6-public/blob/master/main.c">main.c</a>.</p>
<h3 id="entrypgdir"><a href="#entrypgdir" class="headerlink" title="entrypgdir"></a>entrypgdir</h3><p>What in the world is this?!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entrypgdir[NPDENTRIES] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = (<span class="number">0</span>) | PTE_P | PTE_W | PTE_PS,</span><br><span class="line">    [KERNBASE&gt;&gt;PDXSHIFT] = (<span class="number">0</span>) | PTE_P | PTE_W | PTE_PS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Okay, bear with me; I promise it’s not too bad.</p>
<p>First, the <code>__attribute__</code> tells the compiler and linker that the page directory<br>should be placed in memory at an address that’s a multiple of <code>PGSIZE</code> (4096<br>bytes); that’s just a requirement of the paging hardware.</p>
<p>Next, we define <code>entrypgdir</code> as an array of <code>NPDENTRIES</code> (1024, according to<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>), each of type <code>pde_t</code> (a type alias for <code>unsigned int</code>, according to<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>).</p>
<p>Then we initialize the entries: in C, you’re allowed to initialize an array by<br>specifying the values of specific enties; all other enties become zero. You<br>specify an entry by putting its index in square brackets before its value, so<br><code>[2] 5</code> will set the entry with index 2 to be 5. Here we initialize the entries<br>with indices 0 and <code>KERNBASE &gt;&gt; PDXSHIFT</code>, which is the same thing as<br><code>PDX(KERNBASE)</code>, AKA the page directory index corresponding to the virtual<br>address <code>KERNBASE</code>, AKA 0x8000_0000. So basically, we’ve initialized the page<br>directory entries corresponding to the low virtual address 0 and the high<br>virtual address <code>KERNBASE</code>.</p>
<p>We set their value to 0, because we want them to map to physical addresses from<br>0 up to 4 MB. Oh, and remember how page directories and page tables can also<br>hold permission flags? We want to set flags to say that these pages are present<br>(so that accessing them doesn’t cause a page fault), writeable, and 4 MB in<br>size; those are defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as <code>PTE_P</code>, <code>PTE_W</code>, and <code>PTE_PS</code>. We can<br>combine them all together by bitwise-ORing them.</p>
<p>And we’re done!</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>The code in <a href="https://github.com/mit-pdos/xv6-public/blob/master/entry.S">entry.S</a> finished up by calling into the C function <code>main()</code>, which<br>is where the core set-up happens before we can start running processes. It calls<br>into basically every single part of the xv6 kernel, so we can’t go through all<br>the functions line-by-line yet; instead I’ll just give you an overview of what<br>they do.</p>
<ul>
<li><code>kinit1()</code> solves another bootstrap problem around paging: we need to allocate<br>  pages in order to use the rest of memory, but we can’t allocate those pages<br>  without first freeing the rest of memory, which requires allocating them…<br>  You see what I mean. This function will free the rest of memory between the<br>  <code>end</code> of the kernel code (defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, remember?) and 4 MB.</li>
<li><code>kvmalloc()</code> allocates a page of memory to hold the fancy full-fledged page<br>  directory, sets it up with mappings for the kernel’s instructions and data,<br>  all of physical memory, and I&#x2F;O space, then switches to that page directory<br>  (leaving poor old <code>entrypgdir</code> in the trash).</li>
<li><code>mpinit()</code> detects hardware components like additional CPUs, buses, interrupt<br>  controllers, etc. Then it determines whether this machine supports this<br>  crazy new idea where you can have multiple CPU cores. Wow, 1995 is crazy.</li>
<li><code>lapicinit()</code> programs this CPU’s local interrupt controller so that it’ll<br>  deliver timer interrupts, exceptions, etc. when we’re ready for them later.</li>
<li><code>seginit()</code> sets up this CPU’s kernel segment descriptors in its GDT; we still<br>  won’t really use segmentation, but we’ll at least use the permission bits.</li>
<li><code>picinit()</code> disables the <em>ancient</em> PIC interrupt controller that literally no<br>  one has ever used since the APIC was introduced in 1989. I don’t even know<br>  what to say. I guess I was mistaken when I assumed it was 1995; I don’t<br>  know.</li>
<li><code>ioapicinit()</code> programs the I&#x2F;O interrupt controller to forward interrupts<br>  from the disk, keyboard, serial port, etc., when we’re ready for them later.<br>  Each device will have to be set up to send its interrupts to the I&#x2F;O APIC.</li>
<li><code>consoleinit()</code> initializes the console (display screen) by adding it to a<br>  table that maps device numbers to device functions, with entries for reading<br>  and writing to the console. It also sets up the keyboard to send interrupts<br>  to the I&#x2F;O APIC.</li>
<li><code>uartinit()</code> initializes the serial port to send an interrupt if we ever<br>  receive any data over it. xv6 uses the serial port to communicate with<br>  emulators like QEMU and Bochs.</li>
<li><code>pinit()</code> initializes an empty process table so that we can start allocating<br>  slots in it to processes as we spin them up.</li>
<li><code>tvinit()</code> sets up and interrupt descriptor table (IDT) so that the CPU can<br>  find interrupt handler functions to deal with exceptions and interrupts when<br>  they come.</li>
<li><code>binit()</code> initializes the buffer cache, a linked list of buffers holding<br>  cached copies of disk data for more efficient reading and writing.</li>
<li><code>fileinit()</code> sets up the file table, a global array of all the open files in<br>  the system. There are other parts of the file system that need to be<br>  initialized like the logging layer and inode layer, but those might require<br>  sleeping, which we can only do from user mode, so we’ll do that in the first<br>  user process we set up.</li>
<li><code>ideinit()</code> initializes the disk controller, checks whether the file system<br>  disk is present (because both the kernel and boot loader are on the boot<br>  disk, which is separate from the disk with user programs), and sets up disk<br>  interrupts.</li>
<li><code>startothers()</code> loads the entry code for all other CPUs (in <a href="https://github.com/mit-pdos/xv6-public/blob/master/entryothers.S">entryothers.S</a>)<br>  into memory, then runs the whole setup process again for each new CPU.</li>
<li><code>kinit2()</code> finishes initializing the page allocator by freeing memory between<br>  4 MB and <code>PHYSTOP</code>.</li>
<li><code>userinit()</code> creates the first user process, which will run the initialization<br>  steps that have to be done in user space before spinning up a shell.</li>
<li><code>mpmain()</code> loads the interrupt descriptor table into the CPU so that we’re<br>  finally completely ready to receive interrupts, then calls the <code>scheduler()</code><br>  function in <a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a>, which enables interrupts on this CPU and starts<br>  scheduling processes to run. <code>scheduler()</code> never returns, so at that point<br>  we’re completely done with setup and we’re running the OS proper.</li>
</ul>
<h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>The entry code in the xv6 kernel had one job: to set up paging. It kind of<br>failed at that job, but not for lack of trying! There are just all kinds of<br>Catch-22s when it comes to paging, so at least it got us partway there by making<br>a temporary page directory to tide us over until we can throw it away and never<br>look back.</p>
<p>We also took a sneak peek at all the setup code in <code>main()</code>; we’re gonna end up<br>going through it all, but at least now you should have enough of an idea of<br>what’s going on that you can more or less skip around and look at what you need.</p>
<h1 id="Detour-Spin-Locks"><a href="#Detour-Spin-Locks" class="headerlink" title="Detour: Spin-Locks"></a>Detour: Spin-Locks</h1><p>So I know I said I wasn’t expecting you to have finished the OSTEP section on<br>concurrency, but xv6 uses locks all over the place, so we’re gonna have to get<br>comfortable with them right away. Luckily, xv6 primarily uses spin-locks, which<br>are super simple and work on bare metal; a lot of the more complex&#x2F;more awesome<br>locks that OSTEP talks about require an OS beneath them.</p>
<p>I’ll give a brief intro to concurrency first in case you haven’t made it to that<br>part in OSTEP; then we’ll turn to the spin-lock implementation in xv6.</p>
<h2 id="A-Very-Brief-Poor-Man’s-Intro-to-Concurrency"><a href="#A-Very-Brief-Poor-Man’s-Intro-to-Concurrency" class="headerlink" title="A Very Brief, Poor-Man’s Intro to Concurrency"></a>A Very Brief, Poor-Man’s Intro to Concurrency</h2><p>TL;DR: Concurrency is your worst nightmare. It’ll cause bugs in the places where<br>you least expect it, and they won’t even be consistent: your code might work 95%<br>of the time, but every once in a while it’ll randomly fail and you’ll have no<br>idea why. The good news: xv6 handles it in a super-simple way, so we’ll get to<br>appreciate it as we go along. If you’re like me, you might also see the code use<br>locks when you wouldn’t have thought they were needed, and then you’ll come to<br>appreciate just how clever the xv6 authors are.</p>
<p>First off, stop reading this and go watch the discussion of data races and locks<br>in <a href="https://www.youtube.com/watch?v=LzElj46saa8&t=8762s">the last few minutes of the CS 50 2021 lecture on SQL</a>.<br>I’m serious, go watch it right now; this post will still be here.</p>
<p>Okay, I’m gonna assume you’ve seen it now; you should have a decent sense of the<br>main issues with data races and how locks solve them. But the CS 50 lecture<br>skipped some details about locks: (1) what Brian (the TA) does when he finds a<br>locked fridge, (2) how locks are implemented in code, and (3) deadlocks.</p>
<h3 id="What-Does-Brian-Do"><a href="#What-Does-Brian-Do" class="headerlink" title="What Does Brian Do?"></a>What Does Brian Do?</h3><p>Let’s say process <code>david</code> is running on one thread, and it needs to use some<br>resource (a global variable maybe, or an I&#x2F;O device like the disk or console)<br>that other threads might want to use too, so <code>david</code> acquires the lock for that<br>resource. Then process <code>brian</code> comes along and wants to use the same resource at<br>the same time. This could cause a data race, but luckily we’ve thought ahead and<br>used a lock, so <code>brian</code> can’t access it until <code>david</code> is done with it and<br>releases the lock.</p>
<p>First of all, we better hope <code>david</code> remembers to release the lock; otherwise<br><code>brian</code> (and all other processes, even the kernel) will <em>never</em> be able to use<br>that resource. But assuming we’re smart and remembered to release it, what does<br>the <code>brian</code> process do in the meantime?</p>
<p>Well, maybe <code>brian</code> has some other work to do that he can get started on in the<br>meantime. But what would that mean for an OS? How would we know, in general,<br>whether the lines of code that follow the use of a shared resource can be safely<br>executed if we haven’t used that resource yet? That sounds impossible to figure<br>out without knowing ahead of time what the resource is and how it’s used, so<br>let’s just go ahead and skip that idea.</p>
<p>Another option that’s actually used often in the real world is for <code>brian</code> to<br>stop trying and go to sleep. Maybe he can put a note on himself asking <code>david</code><br>to wake him up when he gets back with the milk. So in code, that might look like<br><code>brian</code> signaling the OS and letting it run a different process until the lock<br>is released. That sounds nice and all, but at this early stage in our kernel, we<br>don’t even have processes or a scheduler yet, let alone a notion of sleeping.</p>
<p>Okay, another option: what if <code>brian</code> just spins around in circles, or twiddles<br>his thumbs, or does jumping jacks or whatever until <code>david</code> releases the lock?<br>In code, that means looping over and over forever until the lock is released.<br>That would be horribly inefficient; think of all the CPU time wasted when one<br>process just loops over and over again while another process does something slow<br>while holding a lock! But it’s also the approach that xv6 is gonna take, because<br>at the end of the day, our kernel is still in baby stages and beggars can’t be<br>choosers. So xv6 uses <em>spin-locks</em> with loops that only stop when we acquire a<br>lock.</p>
<p>This means we should be careful when using locks to acquire them only at the<br>last possible moment when they’re absolutely needed, and release them as soon as<br>they’re no longer required, in order to limit the amount of wasted CPU cycles.</p>
<h3 id="Implementing-Locks"><a href="#Implementing-Locks" class="headerlink" title="Implementing Locks"></a>Implementing Locks</h3><p>We can implement locks as a simple boolean variable: if it’s true, then someone<br>else is using the resource behind the lock. If it’s false, then it’s unused and<br>you can go ahead and take it. So an <code>acquire()</code> function sets the lock to <code>true</code><br>and a <code>release()</code> function sets it back to <code>false</code>. Done!</p>
<p>But it’s not so simple: there’s actually a race condition hidden in the very<br>idea of a lock. Think about it for a second: a lock protects some shared<br>resource, right? And a shared resource is something that more than one process<br>wants to use? But a lock is itself a thing that more than one process wants to<br>use… so we haven’t actually gotten rid of the race condition. (FLIPS TABLE.)</p>
<p>We have another Catch-22 on our hands, but this time we can’t get rid of it with<br>a clever software trick like we did with the <code>entrypgdir</code>. The issue is that no<br>matter how well we write our code, it will always require more than one step:<br>first we have to check whether the lock is <code>true</code>, then we have to set it to<br><code>true</code>. But if someone else is doing the same thing at the same time, our<br>instructions might get executed in parallel and then we’d both acquire the lock<br>at the same time -&gt; RACE CONDITION.</p>
<p>The solution will require hardware support, using <em>atomic</em> instructions – these<br>are hardware instructions that are indivisible; no other code can execute in<br>between ours. One example is the x86 instruction <code>xchg</code>, which atomically reads<br>a value from memory, updates it to a new value, and returns the old value.</p>
<p>Now we’re good! A lock can still be a boolean variable but now <code>acquire</code> has to<br>use <code>xchg</code>: it should get the old value while simultaneously updating it to<br><code>true</code>.</p>
<p>Atomic instructions have more overhead than regular ones, so we should only use<br>them when they’re required, like in locks, but otherwise we can stick to the<br>regular instructions we’ve always used.</p>
<p>There’s one other detail we should be careful about: a lot of the locks in xv6<br>protect resources that are needed by both interrupt handlers and kernel or user<br>code. For example, we might use a process table lock to protect the list of all<br>currently running processes; suppose some kernel code has acquired the lock in<br>order to run a new process. What happens if a timer interrupt goes off at that<br>moment? The timer interrupt handler function might need to acquire the lock in<br>order to switch processes, but it’s already being held by the kernel thread. But<br>the timer interrupt might take priority over the kernel thread and refuse to<br>return to the kernel until it finishes executing. The result: that CPU comes to<br>a total halt as the timer interrupt handler function spins forever, never to get<br>the lock it so desperately needs to move on. So sad. :(</p>
<p>xv6 avoids this issue in a really simple way: every time we acquire a lock,<br>we’ll just disable interrupts altogether. Problem solved: now a thread can’t get<br>interrupted until it’s done using the lock and releases it. This does mean that<br>a process which grabs locks often might stick around longer than it should,<br>since we won’t have timer interrupts to tell the scheduler to swap it out with<br>another process, but we’re just gonna cross our fingers and hope that doesn’t<br>happen too often.</p>
<h3 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h3><p>The last concurrency issue we need to be aware of is the problem of deadlocks.<br>Suppose two threads each need locks A and B; this happens often, e.g. when<br>loading a user program the kernel will need to hold a lock for the disk and<br>another for the process table, or a process might be reading from disk and<br>printing to the console at the same time.</p>
<p>Suppose they’re running at the same time, and one process acquires lock A while<br>the other one acquires lock B. If they each need the other lock to keep going,<br>they’d spin forever waiting for it. This is a deadlock.</p>
<p>The way to avoid these is to make sure that, if we use more than one lock, we<br><em>always</em> acquire them in the same order. That way, one process would acquire<br>lock A, the second one would be unable to acquire it and would spin, then the<br>first process acquires lock B with no issues. When it’s done, it releases both<br>locks and the second process can continue.</p>
<p>This can get complicated though: if we ever acquire a lock in a function, we’d<br>have to check any functions that that function calls to see whether they use any<br>locks, and so on. If they do, and if the order conflicts with another chain of<br>function calls, we’d have to refactor the code until the orders match. xv6 has<br>been carefully written so that the lock acquisition order is always consistent.</p>
<h2 id="spinlock-c"><a href="#spinlock-c" class="headerlink" title="spinlock.c"></a>spinlock.c</h2><p>xv6’s spin-locks are set up as a <code>struct spinlock</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/spinlock.h">spinlock.h</a>. The<br><code>locked</code> field acts as the boolean variable to determine whether the lock is<br>held; the other fields are for debugging, since we can expect concurrency issues<br>to be the one of the most common causes of bugs in the kernel code because,<br>again, concurrency is your worst nightmare.</p>
<p>Note that <code>locked</code> is an <code>unsigned int</code> instead of a <code>bool</code>; C requires the<br>standard library header <em>stdbool.h</em> in order to use the <code>bool</code> type, but on<br>bare metal we can’t assume we have a standard library to use.</p>
<h3 id="initlock"><a href="#initlock" class="headerlink" title="initlock"></a>initlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function is pretty straightforward; it just stores the string <code>name</code> in<br>the lock and starts it off as unlocked; the <code>cpu</code> field is 0 because no CPU is<br>holding it yet. Next.</p>
<h3 id="pushcli-and-popcli"><a href="#pushcli-and-popcli" class="headerlink" title="pushcli and popcli"></a>pushcli and popcli</h3><p>For reasons mentioned above, we need to disable interrupts whenever we’re using<br>a lock and re-enable them when we release a lock. But if we’re not careful, we<br>could end up enabling interrupts too early when we release one lock while still<br>holding another; or if interrupts were already disabled when we acquired a lock,<br>we could unintentionally re-enable them upon releasing it.</p>
<p>xv6 uses paired functions <code>pushcli()</code> and <code>popcli()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushcli</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> eflags = readeflags();</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli == <span class="number">0</span>) &#123;</span><br><span class="line">        mycpu()-&gt;intena = eflags &amp; FL_IF;</span><br><span class="line">    &#125;</span><br><span class="line">    mycpu()-&gt;ncli += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readeflags()</code> is a C wrapper for some x86 assembly code that reads from the<br><code>eflags</code> register; the 9th bit is the interrupt flag, which is set whenever<br>interrupts are enabled. <code>cli</code> is another x86 instruction that clears that flag,<br>thus disabling interrupts.</p>
<p><code>mycpu()</code> returns a pointer to a <code>struct cpu</code> with information about the CPU<br>running this code; we’ll go over these when we talk about processes; here we<br>increment the <code>ncli</code> field in every call to <code>pushcli()</code>. If this is the first<br>call, we save the value of the interrupt flag in the <code>intena</code> field.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">popcli</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;popcli - interruptible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--mycpu()-&gt;ncli &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;popcli&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli == <span class="number">0</span> &amp;&amp; mycpu()-&gt;intena) &#123;</span><br><span class="line">        sti();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>popcli()</code> first checks to make sure interrupts aren’t already enabled and we’re<br>not popping without having pushed. Then it decrements the <code>ncli</code> field of the<br><code>struct cpu</code> for this CPU. If this is the last call to <code>popcli()</code>, it checks the<br><code>intena</code> field; if it was set (i.e., interrupts were enabled before the first<br><code>popcli()</code>), then it enables interrupts again.</p>
<p>Check out how these two functions are carefully written so that they’re matched:<br>it takes two calls to <code>popcli()</code> to undo two calls to <code>pushcli()</code>. Also, if<br>interrupts were already off before the first call to <code>pushcli()</code>, they’ll stay<br>off after the last <code>popcli()</code>. Pretty neat, right?</p>
<h3 id="holding"><a href="#holding" class="headerlink" title="holding"></a>holding</h3><p>This function checks whether this CPU is holding the lock.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line">    <span class="type">int</span> r = lock-&gt;locked &amp;&amp; lock-&gt;cpu == mycpu();</span><br><span class="line">    popcli();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not much to talk about here; it just checks (inside calls to <code>pushcli()</code> and<br><code>popcli()</code>) whether the lock is being held and this is the CPU holding it. If<br>both conditions are true it’ll return 1; otherwise 0.</p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>The first step in this function is to disable interrupts to avoid deadlocks. We<br>also make sure we’re not already holding the lock; otherwise we’d deadlock<br>ourselves.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holding(lk)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next up, we’ve gotta acquire the lock using the atomic <code>xchg</code> instruction,<br>defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>.<br>Like we said before, the trick is to atomically set <code>locked</code><br>to 1 while returning the old value. If the returned old value is 1, that<br>means it was already 1 before we got to it, so it’s currently being held and we<br>can’t acquire it yet – gotta spin. But if the returned old value is 0, that<br>means the lock was free before we got to it, and our <code>xchg</code> just updated it to<br>1, so we’ve successfully acquired it. No other instruction can occur between<br>checking the old value and updating it to the new one, so we can be confident<br>that no one else will be holding the lock at the same time.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We do have to be careful about one other thing: compiler optimizations can get<br>pretty wild nowadays, so the order of code on the page isn’t necessarily the<br>order it’ll get compiled to or executed in. This is a critical section of code,<br>so we need to make sure acquiring the lock forms a barrier between the code that<br>comes before it and the code after it so any reordering doesn’t cross the lock<br>acquisition point. We can do that with a special compiler instruction:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll record some info about the CPU and process holding the lock for<br>debugging purposes. Don’t worry about <code>mycpu()</code> for now, but we’ll talk about<br><code>getcallerpcs()</code> below.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lk-&gt;cpu = mycpu();</span><br><span class="line">    getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>Releasing a lock is a little easier than acquiring it: to acquire it, we need to<br>check whether it’s already held and update its value, with both steps together<br>as an atomic instruction. To release it, we only have to set the value to false.<br>That’s only one instruction, so it’s automatically atomic!</p>
<p>Well, almost, but not quite. The compiler works some serious magic behind the<br>scenes, so there’s no guarantee that a single C operation like <code>lk-&gt;locked = 0</code><br>will actually get compiled down to a single assembly instruction. So we’re gonna<br>have to make sure it does by writing it directly in assembly.</p>
<p>We start off by making sure we are already holding the lock before releasing a<br>lock held by someone else. Then we clear the debug info stored in the lock, and<br>tell the compiler and processor not to reorder code past the lock release.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holding(lk)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to release the lock, i.e. an assembly instruction equivalent to<br><code>lk-&gt;locked = 0</code> in C. C allows in-line assembly code using the <code>asm</code> keyword.<br>We mark it as <code>volatile</code>, which prevents the compiler from optimizing the write<br>away and ensures it’ll get written to memory. Finally, we call <code>popcli()</code> to<br>enable interrupts again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl $0, %0&quot;</span> : <span class="string">&quot;+m&quot;</span> (lk-&gt;locked) : )</span>;</span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getcallerpcs"><a href="#getcallerpcs" class="headerlink" title="getcallerpcs"></a>getcallerpcs</h3><p>This function exists to store information about the current process in the lock<br>for use in debugging. In particular, we want to record the program counters of<br>the last 10 functions on the call stack so we can try to figure out which<br>functions were called in which order when concurrency issues inevitably bring<br>our world crashing down with data races, or to a grinding halt with deadlocks.</p>
<p>In order to get the program counters, we’re gonna have to know a bit about how<br>x86 handles function calls. The <code>%eip</code> register (or instruction pointer) holds<br>the program counter, which tracks the next instruction to be executed. The<br><code>%ebp</code> register (or base pointer) holds the address of the base of the stack<br>(i.e., its highest address, since it grows down).</p>
<p>When a function gets called all its arguments are pushed on the stack in reverse<br>order, so that the first argument is at the top (lowest address) of the stack.<br>Then the previous function’s <code>%eip</code> is pushed on the stack, followed by its<br><code>%ebp</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;- low addresses                                               high addresses -&gt;</span><br><span class="line">...  [new function&#x27;s data]  [old %ebp]  [old %eip]  [new arg1]  [new arg2]  ...</span><br><span class="line">&lt;- top of stack                                               bottom of stack -&gt;</span><br></pre></td></tr></table></figure>

<p>Anyway, the point is that if we have the address of the first argument to the<br>current function, then we can recover the contents of the previous function’s<br><code>%ebp</code> and <code>%eip</code> registers: <code>%eip</code> is one spot below it on the stack and <code>%ebp</code><br>is two spots below it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    uint *ebp = (uint *) v - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note the type casts here – <code>v</code> is a pointer to the first argument, which can be<br>of any type and size, so we use a <code>void *</code>. But both of the <code>%eip</code> and <code>%ebp</code><br>registers hold 32-bit pointers, so <code>ebp</code> is declared as a pointer to a <code>uint</code><br>(a type alias for <code>unsigned int</code>, remember?), which makes the pointer arithmetic<br>work out nicely so that subtracting 2 returns a pointer to the right spot on the<br>stack.</p>
<p>Now, what we really want is the program counter <code>%eip</code>, not the pointer to the<br>stack base <code>%ebp</code>. But we can use the address of <code>%ebp</code> to make sure we haven’t<br>gone too far back in the function call history. Remember, we wanna get the<br>program counters for the last 10 functions in the call stack, then save them in<br>the <code>pcs</code> array.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// Stop if the %ebp pointer is null or out of range</span></span><br><span class="line">        <span class="keyword">if</span> (ebp == <span class="number">0</span> || ebp &lt; (uint *) KERNBASE || ebp == (uint *) <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pcs[i] = ebp[<span class="number">1</span>];</span><br><span class="line">        ebp = (uint *) ebp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s talk about those last two lines: the <code>ebp</code> pointer in the code holds the<br>location of the saved <code>%ebp</code> register, so <code>ebp[0]</code> is the value at that address<br>(i.e., the actual value of the saved <code>%ebp</code> register) and <code>ebp[1]</code> is the value<br>stored one spot above that, i.e. the value of the saved <code>%eip</code> register. So<br>each iteration of the loop will get one <code>%eip</code> and store it in a <code>pcs</code> entry.</p>
<p>Then we update <code>ebp</code> to the actual value at the address it points to, which<br>means <code>ebp</code> will now point to the address of the saved <code>%ebp</code> register for the<br>function one step further back in the call chain. Okay sorry, I know that’s<br>confusing, but basically each iteration of the for loop moves us back to the<br>function that called this function, then the function that called that one, and<br>so on.</p>
<p>Okay, whew. So what happens if we break out of the for loop early because we<br>went all the way back in the call stack? The other entries of <code>pcs</code> might hold<br>some garbage values, so let’s just make them null pointers so we know to ignore<br>them when debugging.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        pcs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One last little trick: the previous for loop declared the loop variable <code>i</code><br>before the loop – this means <code>i</code> will be in scope for the rest of the function<br>body. If it had been declare inside the for loop like <code>for (int i = 0; ...)</code>, it<br>would fall out of scope at the end of the loop. So we can keep using the same<br><code>i</code> in this second for loop (without an initialization statement) and know it’ll<br>hold the value it had after finishing the first for loop. If we finished all the<br>iterations, that value will be 10; otherwise it’ll be less. So we use that to<br>clear any remaining entries of <code>pcs</code>.</p>
<h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>You’ll learn to hate concurrency issues in C; newer languages like Rust make<br>data races a thing of the past, though deadlocks can still rear their ugly<br>heads. But for now, the xv6 authors have done all the dirty work for us, so we<br>can just sit back and watch. Note, though, that even the xv6 authors say it’s<br>totally possible that something has slipped past them and the thousands of other<br>students and instructors that have looked at xv6, so it’s probable that xv6<br>still has some lingering race conditions. See, even the masters struggle with<br>it. -_-</p>
<p>Anyway, we saw that locks have to be implemented with hardware support using<br>atomic instructions. C and most languages provide high-level atomics that real-<br>world operating systems use, but the point of xv6 is elegance in simplicity, not<br>being a total show-off, so the xv6 spin-locks just use the basic <code>xchg</code>.</p>
<p>We took this detour into spin-locks to make sure we all understand some basic<br>details because we’re gonna be seeing a lot of them in the rest of the kernel<br>code. They’re inefficient (because the processor just spins around waiting for<br>the lock to be released, WHEEEEE), but we gotta make do with the machinery we’ve<br>built up so far. xv6 will also use some fancier locks called sleep-locks, but<br>we’ll cross that bridge when we get to it.</p>
<h1 id="Page-Allocation"><a href="#Page-Allocation" class="headerlink" title="Page Allocation"></a>Page Allocation</h1><p>When we left off before the lock detour, the boot loader had set up a GDT to<br>ignore segmentation, and the entry code set up some barebones paging with an<br><code>entrypgdir</code>. But that initial page directory is too limiting to keep for long;<br>it only mapped the first 4 MB of physical memory. So we want a new one, but we<br>have to set it up and allocate pages in it before we can actually use it. And<br>until we switch to it, everything has to happen in those first 4 MB.</p>
<h2 id="kalloc-c"><a href="#kalloc-c" class="headerlink" title="kalloc.c"></a>kalloc.c</h2><p>We start off in this file by declaring the function <code>freerange()</code>, which will be<br>defined below. We have to do this in C in order to call a function in the code<br>before the compiler has actually seen the function’s definition, which comes<br>below, or maybe in another file. A <em>declaration</em> tells the C compiler “I know I<br>haven’t shown you this symbol before, but don’t worry; it’s just a function that<br>takes this number of arguments with these types and has a return value of this<br>type.” That lets the compiler keep calm and carry on with its usual type-checks<br>(weak as they may be in C). A <em>definition</em> tells the compiler that this is the<br>function (or variable) we were talking about, so it’ll reserve some space in<br>memory for it; it also tells the compiler how to evaluate that function whenever<br>it’s called (for variables, an <em>initialization</em> will have to tell the compiler<br>what the value the variable should hold). The linker will take care of matching<br>function calls (and variable uses) to their definitions, possibly across files.</p>
<p>Usually you’d stick declarations in a C header file and tell the preprocessor to<br>copy-paste the header into your code with an <code>#include</code> directive; then other<br>files could <code>#include</code> that header too. So header files should really be more of<br>an API kind of thing, for functions that you want other code to be able to call.<br>This one is just a local helper function, so we’ll declare it here instead of in<br>a header so other code can’t use it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span>;</span><br></pre></td></tr></table></figure>

<p>Okay okay, I know function declarations are like 101-level C, but I wanted to<br>mention them because we’re about to see something similar but a little off next<br>when we declare <code>end</code> as a global array of characters.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[];</span><br></pre></td></tr></table></figure>
<p>The C keyword <code>extern</code> lets you define a global variable or function in one file<br>and use it in another, so in that sense it’s similar to the function declaration<br>above. In fact, the compiler implicitly assumes there’s an <code>extern</code> before each<br>function declaration. The difference is that an explicit <code>extern</code> lets us do the<br>same thing for global variables: we tell the compiler and linker “hey, I’m gonna<br>use a variable of this type with symbol <code>end</code>, but don’t worry about reserving a<br>spot in memory for it; that already happened elsewhere.”</p>
<p>The really cool thing about <code>extern</code> is that the function or variable might not<br>even be defined in C – it could come from any other language! We just pass the<br>compiled object files from the other language together with the C object files<br>to the linker and it’ll match up the definitions and calls.</p>
<p>In this case if you try looking for the place where <code>end</code> is defined in the C or<br>assembly code, you’re gonna be disappointed. Turns out it’s actually defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, remember? Back then, we said it was gonna be located at the very<br>first memory address right after the end of the kernel code and data in memory.<br>We’re about to see why it’s needed.</p>
<p>Next up, we define a new <code>struct</code> type:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Hmm, the only member of this <code>struct run</code> is a pointer to another <code>struct run</code>.<br>Hopefully, you’ve seen some singly-linked lists before so you can recognize it<br>as one of those. Usually it would have another member to hold the data in the<br>list, but we won’t need any extra data here; we’ll find out why soon enough.</p>
<p>Last thing before we get to the functions: we define another <code>struct</code> type and<br>declare the global variable <code>kmem</code> to be of that type.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> use_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<p>The syntax here is the usual C thing where we say the type of a variable, then<br>an identifier, like <code>int i</code>; it just looks more confusing because we’re also<br>defining the type at the same time. This <code>struct</code> type doesn’t get a name like<br><code>struct run</code> did because we’re only gonna need it this one time. The fields are<br>a spin-lock (hence the detour before coming here), a <code>use_lock</code> variable that<br>we’ll treat as a boolean, and a pointer to a <code>struct run</code> called <code>freelist</code>.</p>
<p>I’m just gonna go ahead and spoil the next two functions for you: we want to use<br>a better page directory than <code>entrypgdir</code>, right? Well then we need to assign<br>a page of memory for it, plus a page for each of its page tables, plus a page<br>for each entry in those page tables that’s mapped. That means we’ll need some<br>bookkeeping to track which pages have already been assigned. We’re gonna use a<br>linked list of free pages (that’s what <code>struct run</code> is for); we’ll allocate a<br>page by popping one off the free list, and we’ll free a page by pushing it onto<br>the top of the list.</p>
<p>Note that <code>kfree()</code> here is <em>not</em> supposed to be a kernel version of the usual C<br>standard library function <code>free()</code>, nor is <code>kalloc()</code> supposed to be a kernel<br>version of <code>malloc()</code>. We have no concept of a heap yet, so heap allocation<br>wouldn’t make sense. These functions allocate and free <em>whole physical pages</em> to<br>be added to the current page directory and its page tables.</p>
<h3 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h3><p>This function will free a single page (4096 bytes, or <code>PGSIZE</code>) of memory by<br>adding it to the front of the free list. It takes an argument <code>char *v</code> which is<br>a virtual address; we’re using <code>char *</code> here instead of <code>uint *</code> or <code>void *</code> or<br>whatever so that the pointer arithmetic increments by a single byte instead of<br>4 bytes for <code>uint</code> or whatever.</p>
<p>First, some sanity checks: <code>v</code> should be page-aligned (because we’re freeing a<br>whole page), it should be above <code>end</code> (because we don’t want to accidentally<br>overwrite the kernel code), and its corresponding physical address should be<br>below <code>PHYSTOP</code> (because the only addresses we’ll use above the top of physical<br>memory are for memory-mapped I&#x2F;O devices and we shouldn’t be freeing those pages<br>anyway).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((uint) v % PGSIZE || v &lt; end || V2P(v) &gt;= PHYSTOP) &#123;</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if you’ve programmed in C, you might have come across the dreaded (but oh-<br>so-common) bug known as a <em>use-after-free</em>. This means you called <code>free()</code> on<br>some variable (hopefully one you had <code>malloc()</code>-ed before), and then used it<br>again. Hmm, very naughty! The problem is that that memory might have been re-<br>allocated to some other variable or even another process, so you might read the<br>wrong values or overwrite something important. This is a <em>very</em> common cause of<br>security vulnerabilities in C and C++ to this day; it’s also not always easy to<br>spot because huge projects might have you call <code>malloc()</code> in one file, then use<br>the variable somewhere else thousands of lines of code later in some other file,<br>then call <code>free()</code> in yet another file – plus it’s unlikely that all of these<br>pieces were written by the same person. So let’s make this a little easier on<br>ourselves by filling the freed page with junk (a bunch of 1s everywhere) in the<br>hope that a use-after-free leads to a crash (and thus debugging and detection)<br>sooner than it would otherwise.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">1</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might be familiar with <code>memset()</code> from the C standard library in <em>string.h</em>,<br>but we can’t risk using standard library functions here because they assume the<br>code will be provided by the OS, and the implementation might require any of a<br>million features we haven’t implemented yet. So we have to make our own version<br>for the kernel in <a href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>. We’ll get around to looking at that code later on<br>in an optional detour, but for now just know that it sets the memory starting at<br><code>v</code> and continuing for <code>PGSIZE</code> bytes to hold a bunch of repeated 1s.</p>
<p>Now let’s talk concurrency. At any time, multiple threads might want to allocate<br>or free pages simultaneously; if we’re not careful we might accidentally use the<br>same page twice, which would cause bugs in addition to security vulnerabilities,<br>because all the per-process isolation that paging gets us would be lost. So much<br>work down the drain! This is why <code>kmem</code> has a lock, which we should use any time<br>we push to or pop from the free list.</p>
<p>But in the early stages of the kernel we only use a single CPU and interrupts<br>are disabled, so there’s nothing to fear. Plus, locks add overhead, and the<br><code>acquire()</code> function needs to call <code>mycpu()</code>, which we haven’t even defined yet,<br>so let’s just go ahead and skip them in the beginning. So <code>kmem.use_lock</code> is a<br>boolean that will tell us whether we need a lock right now or not.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        acquire(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, we’re finally at the point where we can free the page. We’ll make a<br><code>struct run *r</code> that points to virtual address <code>v</code>, then make its <code>next</code> point<br>to the first entry of the free list. Then we’ll update the head of the list to<br>point at the newly-freed page. This is the standard C idiom to add to the front<br>of a singly-linked list.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> (<span class="keyword">struct</span> run *) v;</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s something interesting here: where are we storing this entry for the free<br>list? Why, in the free page itself! So each unused page will hold the address of<br>the next one in its first few bytes.</p>
<p>Finally, we’re out of the critical section where we updated the free list, so we<br>can release the lock.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h3><p>Allocating a page means popping off the head of the free list. We acquire the<br>lock first, if we need one.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        acquire(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we get a pointer to the first free page in the list and update the head to<br>point to the next one in the list. But what if the list is empty? In that case,<br>the head would be a null pointer, and dereferencing a null pointer (like we do<br>here in <code>r-&gt;next</code>) is undefined behavior in C, which means BAD THINGS HAPPEN.<br>I’m serious – there are absolutely no restrictions on what might happen, so the<br>compiler could literally set your computer on fire if it wanted to. In the real<br>world, that usually means either a segmentation fault or security vulnerability,<br>or both if you’re unlucky. So we should check whether <code>r</code> is null (i.e. zero).<br>if it’s nonzero then we can update <code>r-&gt;next</code>; otherwise we should just return<br><code>r</code> and hope whoever called us checks whether it’s null. Moral of the story:<br>any call to <code>kalloc()</code>, just like any call to <code>malloc()</code> in regular C code,<br>should always be followed by checking whether the returned pointer is null.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        kmem.freelist = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now we just release the lock, and we’re done!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freerange"><a href="#freerange" class="headerlink" title="freerange"></a>freerange</h3><p><code>kalloc()</code> and <code>kfree()</code> both handle only one page at a time, which can get<br>annoying if we’re trying to free tons of pages at once; also, they can only use<br>page-aligned virtual addresses, which have to be typecast to <code>char *</code>. Let’s<br>simplify our lives with a simple wrapper function to free multiple pages between<br>two virtual memory addresses <code>vstart</code> and <code>vend</code> that may not be page-aligned.</p>
<p>Let’s assume that <code>vstart</code> is the first address after some other data in an<br>already-allocated page; we don’t want to free that page, but the next one, so we<br>align it to a page boundary by rounding up, then cast that to a <code>char *</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *) PGROUNDUP((uint) vstart);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can iterate over the pages, starting at <code>p</code> and incrementing by <code>PGSIZE</code><br>until we reach or pass <code>vend</code>, freeing pages as we go.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; p + PGSIZE &lt;= (<span class="type">char</span> *) vend; p += PGSIZE) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Done, next.</p>
<h3 id="kinit1-and-kinit2"><a href="#kinit1-and-kinit2" class="headerlink" title="kinit1 and kinit2"></a>kinit1 and kinit2</h3><p>Both of these functions get called by the kernel’s <code>main()</code>. Quick reminder:<br>we’ve got an <code>entrypgdir</code> that maps two virtual address ranges (0 to 4 MB and<br><code>KERNBASE</code> to <code>KERNBASE</code> + 4 MB) to the physical addresses range from 0 to 4 MB.<br>We want to leave this baby page directory behind for a grown-up page directory<br>that maps all of physical memory, but first we needed to figure out how to<br>allocate pages.</p>
<p>Okay cool, we already did that. But allocation needs a free list, which for now<br>is just sitting around chilling as an empty list. But we can’t free pages if<br>they’re not already allocated, right? Ahh, bootstrap problems! This one’s not an<br>issue; we’ll just cheat this one time and free all the memory between <code>end</code> (the<br>end of the kernel code and data in memory) and <code>PHYSTOP</code>, even though we didn’t<br>get it from a call to <code>kalloc()</code>. Sounds good, right?</p>
<p>I hate to burst your bubble, but kernel development <em>loves</em> bursting bubbles.<br>Turns out there’s yet another bootstrap problem: each page has to store the<br>pointer to the next free page, which means we have to write to that page, which<br>means that page must already be mapped… but we can’t map all of memory until<br>we initialize the free list by freeing all of memory…</p>
<p>HEAD. DESK. We’re screwed.</p>
<p>Okay, obviously the xv6 authors figured this out already. The trick is that we<br>do have <em>some</em> physical memory we can write to: everything between <code>end</code> and 4<br>MB. So we can free that part for now, allocate some of those pages for a fresh<br>page directory and some pages, then use those pages to map the rest of physical<br>memory, then come back later and free those pages.</p>
<p>So we’ll have to split up the work of setting up the new page directory into two<br>very similar functions, <code>kinit1()</code> and <code>kinit2()</code>. The first one will initialize<br>the lock for the free list but make <code>kmem.use_lock</code> false so we don’t use a lock<br>in the early stages of kernel setup. The second one will set it to true so we<br>start using a lock to allocate and free pages once we have multiple CPUs, a<br>scheduler, interrupts, etc.</p>
<p>Both of them will use <code>freerange()</code> to free the pages in a section of physical<br>memory. <code>main()</code> calls <code>kinit1()</code> with arguments to free the range from <code>end</code> to<br>4 MB, and calls <code>kinit2()</code> with arguments for the range from 4 MB to <code>PHYSTOP</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit1</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    kmem.use_lock = <span class="number">0</span>;</span><br><span class="line">    freerange(vstart, vend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kinit2</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    freerange(vstart, vend);</span><br><span class="line">    kmem.use_lock = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>This whole file was just to set up page allocation for the new page directory<br>we’re gonna replace <code>entrypgdir</code> with. It uses a free list in <code>kmem</code>; freeing a<br>page adds it to the front of the list and allocation pops a page off the front.<br>We have to populate the free list will pages for all of physical memory, but we<br>do that in two steps to avoid some bootstrap issues.</p>
<p>Again, this is a <em>page</em> allocator, not a <em>heap</em> allocator like <code>malloc()</code>, but<br>many heap allocator implementations use linked lists of free heap regions in the<br>same way. We talked about use-after-free bugs above, but now we can also see why<br><em>double-frees</em> (in which you free the same memory region more than once) can<br>cause bugs and security vulnerabilities: they add the same region to it twice,<br>which then might get allocated to two different variables or processes, which<br>might ruin the per-process isolation that virtualization is supposed to provide.<br>In addition, our page allocator handles fixed-size regions, but a heap allocator<br>needs to use variable regions, so when a memory region gets allocated twice<br>after a double-free, it might get split up into differently-sized pieces, of<br>which some parts get allocated to other processes, etc… It’s just a nightmare.</p>
<p>Next up, we’ll see the full story of virtual memory.</p>
<h1 id="More-Paging-The-Kernel-Side"><a href="#More-Paging-The-Kernel-Side" class="headerlink" title="More Paging: The Kernel Side"></a>More Paging: The Kernel Side</h1><p>We’ve already talked <em>plenty</em> about virtual memory, and I bet you’re probably so<br>over <code>entrypgdir</code> by now; let’s wrap up its story and get rid of it!</p>
<p>The <a href="https://github.com/mit-pdos/xv6-public/blob/master/vm.c">vm.c</a> file is HUGE; only <a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a> and <a href="https://github.com/mit-pdos/xv6-public/blob/master/sysfile.c">sysfile.c</a> match its length. Some<br>parts deal with the general paging implementation; we’ll look at those here. The<br>rest handles the details of paging for processes and user code, we’ll need to<br>know a bit more about processes in xv6 for that.</p>
<h2 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h2><p>After the include directives for the preprocessor, we have a declaraction for<br>an external symbol defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>. This one is the beginning of the<br>data section for the kernel.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> data[];</span><br></pre></td></tr></table></figure>

<p>Next we have a definition for a pointer to a global page directory: this is the<br>fancy new one that’s gonna replace <code>entrypgdir</code>. Note that <code>pde_t</code> is a type for<br>page directory entries defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>; it’s just a type alias for <code>int</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *kpgdir;</span><br></pre></td></tr></table></figure>

<h3 id="seginit"><a href="#seginit" class="headerlink" title="seginit"></a>seginit</h3><p>This first function gets called directly by the kernel’s <code>main()</code>; it sets up<br>the segment descriptors in the GDT as identity maps to all of memory so that we<br>can ignore them from now on. Wait, didn’t we already do that in the boot loader?</p>
<p>Yes, kind of, but that was before the kernel took over, so back then we had no<br>notion of kernel space versus user space. Now that we do, we want to set the<br>permission flags for each segment so that we can use the privilege ring levels,<br>with the kernel in ring 0 and user code in ring 3. That way any misbehaving user<br>code will get slapped with a segmentation fault the way we’ve all come to know<br>and love in C.</p>
<p>We also have some permission flags for protection in the page directory and page<br>table entries, so maybe we could get away without it? I mean, both kernel code<br>and user code are read-only anyway, so maybe they could both have a Descriptor<br>Privilege Level of 3. But no, x86 is gonna shut that right down by forbidding<br>interrupts that take you from ring level 0 to ring level 3, so all the interrupt<br>handler functions have to be in kernel space with a kernel code segment selector<br>at ring level 0.</p>
<p>So we’re just gonna have to do it all over again. Great. Well, maybe it’s not<br>too bad, let’s take a look… oh god, it’s awful. Okay, deep breath.</p>
<p>Each processor has its own GDT, so we’re gonna need to call this function once<br>per CPU. First we figure out which CPU we’re on with with the <code>cpuid()</code> function<br>that we’ll see later on; for now it… (drumroll)… gets the CPU’s ID. Then we<br>look that up in a global table of CPUs (there’s an <code>extern</code> declaration for this<br>in the included <a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.h">proc.h</a>) and store it in a <code>struct cpu</code>; we saw that before in<br>the spin-lock code, but we’ll get around to talking about it more later.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[cpuid()];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That <code>struct cpu</code> has a field to hold the GDT, so we’re gonna add entries for<br>the kernel code, kernel data, user code, and user data segment descriptors;<br>those entries are <code>SEG_KCODE</code>, <code>SEG_KDATA</code>, <code>SEG_UCODE</code>, and <code>SEG_UDATA</code>,<br>respectively. Recall that the permission bits are <code>STA_X</code> (executable), <code>STA_R</code><br>(readable), and <code>STA_W</code> (writeable); now we’re gonna pile on the descriptor<br>privilege levels for the kernel (0) and user (3, or <code>DPL_USER</code>) on top. Besides<br>those ring levels, we want to ignore segmentation, so each segment should be an<br>identity map for all virtual memory from 0 to 4 GB (0xffff_ffff).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c-&gt;gdt[SEG_KCODE] = SEG(STA_X|STA_R, <span class="number">0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;gdt[SEG_KDATA] = SEG(STA_W, <span class="number">0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;gdt[SEG_UCODE] = SEG(STA_X|STA_R, <span class="number">0</span>, <span class="number">0xffffffff</span>, DPL_USER);</span><br><span class="line">    c-&gt;gdt[SEG_UDATA] = SEG(STA_W, <span class="number">0</span>, <span class="number">0xffffffff</span>, DPL_USER);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The only difference between the <code>SEG</code> macro used here and the <code>SEG_ASM</code> one from<br>the boot loader is that this one is for C code and the other is for assembly.</p>
<p>Finally, we load up the new GDT into the processor with a C wrapper for the<br>x86 instruction <code>lgdt</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lgdt(c-&gt;gdt, <span class="keyword">sizeof</span>(c-&gt;gdt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done with segmentation, now on to more paging.</p>
<h3 id="walkpgdir"><a href="#walkpgdir" class="headerlink" title="walkpgdir"></a>walkpgdir</h3><p>A page directory lets the paging hardware convert virtual addresses to physical<br>ones, but we’re gonna need those mappings in the kernel too while we set up the<br>page directory, so this function does the conversion manually. Wait, but aren’t<br>we setting up paging so that all of physical memory is mapped in the higher half<br>of the virtual address space? Can’t we just add or subtract <code>KERNBASE</code> to do the<br>conversion? Well, that would work for kernel virtual addresses, but user virtual<br>addresses actually will use page directories and page tables in a non-obvious<br>way, so if we want to figure out where those go, we’ll need a function for it.</p>
<p>In C, using the <code>static</code> keyword before a function limits its scope and makes it<br>visible only within its own file. The function returns a <code>pte_t *</code>, a pointer to<br>a page table entry (the type is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as a type alias for <code>uint</code>).</p>
<p>Its arguments are a pointer to a page directory, a virtual address, and <code>alloc</code><br>(a boolean variable, but as an <code>int</code> instead of <code>bool</code>). This <code>alloc</code> lets the<br>function play a dual role: if it’s set, the function will allocate a page table<br>if needed; otherwise it reports failure if the page table doesn’t exist. The<br><code>const</code> keyword lets the compiler know a variable shouldn’t be mutated so it’ll<br>throw an error if we do. Here, <code>const void *va</code> is a pointer to a constant value<br>of any type; the address the pointer holds might change, but we can never write<br>to that address. The opposite is a <code>void *const va</code>: the address being pointed<br>to will never change, but we can overwrite the contents of that address all we<br>want. You can combine the two with <code>const void *const va</code>. What’s that I hear? C<br>syntax is the worst? No, never…</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember way back when, when we talked about how “linear” addresses are set up<br>and converted to physical ones? The first 10 bits are an index for the page<br>directory to pick a page directory entry, which points to a page table; the next<br>10 bits pick a page table entry that points to a page, and the last 12 bits are<br>an offset within that page; the <code>PDX()</code> and <code>PTX()</code> macros get first 10 bits and<br>the next 10 bits from a linear address, respectively. So we start by getting the<br>page directory index and using that to get the page directory entry.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *pde = &amp;pgdir[PDX(va)];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now <code>pde</code> points to a page directory entry which has two parts: a<br>pointer to the physical address of a page table, and some flags. But who knows<br>if this page table even exists; most page directory (and page table) entries<br>aren’t mapped in order to save space. So we have to check whether <code>*pde</code> has the<br><code>PTE_P</code> (present) flag set.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the page table exists, we should get rid of the flags and recover the pointer<br>to the page table using the <code>PTE_ADDR()</code> macro. But the hardware uses physical<br>addresses for these pointers, so we need to convert it to a virtual address<br>first, which is what this function does… recursion? Bootstrap problem? No,<br>it’s actually easy because we can access the page table from within the kernel’s<br>virtual address space in the higher half by adding <code>KERNBASE</code> to the physical<br>address with the <code>P2V()</code> macro.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        pgtab = (<span class="type">pte_t</span> *) P2V(PTE_ADDR(*pde));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now for the else clause, which happens if the page directory entry doesn’t have<br>the <code>PTE_P</code> bit set. Well, if the boolean <code>alloc</code> is false (zero), then we’re<br>done and we should just report failure by returning a null pointer. On the other<br>hand, if it’s true, we just allocate a page for the page table. But wait,<br>remember how page allocation might fail and return a null pointer if we’re out<br>of free pages in the free list? And remember how I said we should always check<br>for that? Okay well let’s check for that; if allocation fails, we also return a<br>null pointer. Oh, and because this is C, we’re gonna do a jillion things at once<br>in a single line: check if <code>alloc</code> is false, try to allocate a page table, and<br>check if that allocation failed. C lets us assign to a variable and then test<br>that variable’s value in a single statement.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!alloc || (pgtab = (<span class="type">pte_t</span> *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now suppose: (1) the page table wasn’t present, (2) alloc was set, and<br>(3) we successfully allocated a page. Now what? Remember how we filled all free<br>pages with garbage in <code>kfree()</code> using <code>memset()</code>? Let’s undo that now by zeroing<br>it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">memset</span>(pgtab, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll update the page directory entry to point to this new page table and<br>add the <code>PTE_P</code> flag so it knows it’s present. Wait, while we’re at it, what<br>other permissions will it need? Is it writeable? Can users access it? Hmm, we’d<br>have to know whether we’re looking up a user virtual address or a kernel one,<br>and whether it’s gonna be used for code or data. Ah, screw it, we’ll just throw<br>all the flags on there at once. Either way, the page table entries will have<br>their own flags too, so we can restrict the page’s permissions there instead of<br>here at the page directory entry.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This probably isn’t the safest thing ever, because we’re saying that only the<br>page table will restrict permissions, so we’re throwing all that responsibility<br>over there, but hey, xv6 is supposed to be simple, not ultra-secure. Just don’t<br>do this at home, kids.</p>
<p>Finally, we return the address of the corresponding page table entry using the<br>index from the middle bits of <code>va</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pgtab[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mappages"><a href="#mappages" class="headerlink" title="mappages"></a>mappages</h3><p>Okay, so <code>walkpgdir()</code> returns a pointer to a page table entry and can even<br>crate a page table if if it doesn’t exist. That’s not quite enough to add new<br>mappings for pages though; the page itself might not be mapped, and if we just<br>created a new page table, then certainly none of the pages are mapped yet.<br><code>mappages()</code> will finish the job by installing mappings in page tables (possibly<br>newly-allocated ones) for a range of virtual addresses.</p>
<p>The arguments are a page directory, a virtual address for the beginning of the<br>range, the size of the range, a physical address to map it to, and the flags for<br>permissions we want to set. We start off by rounding the virtual address down to<br>the nearest page boundary and getting a pointer to the end of the range, also<br>page-aligned.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span> *) PGROUNDDOWN((uint) va);</span><br><span class="line">    <span class="type">char</span> *last = (<span class="type">char</span> *) PGROUNDDOWN(((uint) va) + size - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’re gonna iterate over the pages in that range; <code>for (;;)</code> is a common C<br>idiom for an infinite loop. In this case, we need to increment <code>a</code> and <code>pa</code> by<br><code>PGSIZE</code> each time, and we’ll break out of the loop when <code>a</code> reaches <code>last</code>. To<br>be completely honest, I’m not really sure why the authors chose to write this as<br>an infinite loop with the condition&#x2F;break statement and update statements inside<br>the loop rather than as a regular old for loop; I think the latter would be more<br>clear, but oh well, I didn’t write this.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (a == last) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inside the for loop, we’ll start each iteration by looking up the right page<br>table entry with <code>walkpgdir()</code>, with <code>alloc</code> set to true. Remember how that<br>function called <code>kalloc()</code>, which might fail, in which case it returns a null<br>pointer? Well that means we’ve gotta check for a null pointer here too. This<br>time however, we’ll return -1 for failure and 0 for success, because why not?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, a, <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re supposed to be allocating brand-new pages for this range of addresses, so<br>if a page has already been allocated, we’ll just flip out in rage and panic.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_P) &#123;</span><br><span class="line">            panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last thing before checking the loop condition and updating <code>a</code> and <code>pa</code> is<br>to install the mapping to the right physical address with the right permissions<br>in the page table. Then we’re done!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *pte = pa | perm | PTE_P;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cool, now we have a way to map new pages into a page directory. We’re well on<br>our way to leaving poor old <code>entrypgdir</code> behind for the shiny new <code>kpgdir</code>.</p>
<h3 id="kmap"><a href="#kmap" class="headerlink" title="kmap"></a>kmap</h3><p>Each process is gonna have its own page directory, so its mappings in the lower<br>half of the virtual address space might be totally different from those of<br>another process. But the mappings in the higher half (where the kernel lives)<br>will always be the same – that way, the kernel can always use the existing page<br>directory for whatever process it happens to be running. We’ll only use <code>kpgdir</code><br>when the kernel isn’t currently running a process, e.g. while it’s running the<br>scheduler.</p>
<p>So when we create a new process, we’ll need to copy in all the mappings that the<br>kernel expects to find into a fresh page directory for that process. Those are:<br>memory-mapped I&#x2F;O device space from physical address 0 to 0x10_0000 (the boot<br>loader is also here, but we don’t need it any more), kernel code and read-only<br>data from 0x10_0000 to the physical address of <code>data</code> (one of the symbols<br>defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>), kernel data the rest of physical memory from there to<br><code>PHYSTOP</code>, and more I&#x2F;O devices from 0xFE00_0000 and up. Each of these ranges<br>needs its own permissions too.</p>
<p>We’ll represent each of these mappings with a <code>struct kmap</code>, which has fields<br>for the starting virtual address, the starting and ending physical addresses,<br>and the permissions; then the mappings will get stored in a static global<br>variable <code>kmap</code>… oh come on, what fresh hell is THIS?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *virt;</span><br><span class="line">    uint phys_start;</span><br><span class="line">    uint phys_end;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line">&#125; kmap[] = &#123;</span><br><span class="line">    &#123; (<span class="type">void</span> *)KERNBASE, <span class="number">0</span>, EXTMEM, PTE_W &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)KERNLINK, V2P(KERNLINK), V2P(data), <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)data, V2P(data), PHYSTOP, PTE_W &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)DEVSPACE, DEVSPACE, <span class="number">0</span>, PTE_W &#125;.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Okay, there are a few things going on here. First, the <code>static</code> keyword for a<br>variable means that variable has a single fixed location in memory that it’s<br>never gonna move out of.</p>
<p>Then it does that thing again where we simultaneously define a <code>struct</code> type and<br>define a variable of that type. So the type is</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *virt;</span><br><span class="line">    uint phys_start;</span><br><span class="line">    uint phys_end;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>So then the static global variable <code>kmap</code> is an array of <code>struct kmap</code>s. I guess<br>we ran out of names or something. The array has four entries, and since each one<br>is a <code>struct</code>, it needs curly braces around it.</p>
<p>The first entry (for the lower of the two memory-mapped I&#x2F;O device regions) has<br>a <code>virt</code> field of <code>KERNBASE</code>, a <code>phys_start</code> field of 0, a <code>phys_end</code> field of<br><code>EXTMEM</code> (defined as 0x10_0000), and permission flag <code>PTE_W</code>. So it maps a<br>virtual address range starting at <code>KERNBASE</code> to the physical address range from<br>0x0 to 0x10_0000 and makes it writeable so we can communicate with the devices<br>there. The next two entries are similar, except that the kernel code isn’t<br>writeable.</p>
<p>The last entry has <code>phys_start</code> of 0xFE00_0000 and a <code>phys_end</code> of 0. That’s a<br>little strange, but it’s because we want to map all the way up to the end of the<br>virtual address space at 0xFFFF_FFFF. The end should be one byte past that, but<br>it’s impossible to represent 0x1_0000_0000 with 32 bits. Setting the end to 0<br>makes the size calculation (<code>phys_end - phys_start</code>) work out nicely: it’ll just<br>overflow to the right number. This is okay since we’re using unsigned integers,<br>but note that <em>signed</em> integer overflow is undefined behavior and thus VERY BAD<br>and the cause of many security vulnerabilities.</p>
<p>Okay, back to getting rid of <code>entrypgdir</code>!</p>
<h3 id="setupkvm"><a href="#setupkvm" class="headerlink" title="setupkvm"></a>setupkvm</h3><p>This function sets up a fresh new page directory with all the mappings in <code>kmap</code><br>in order to please the kernel when it encounters the page directory. So needy,<br>right?</p>
<p>It takes no arguments and returns a pointer to the new page directory. First,<br>let’s allocate a page of memory to hold the new directory. We’ll be good and<br>remember to check for null (in which case we return null too) and clear the page<br>of the garbage values we wrote when we freed it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *pgdir;</span><br><span class="line">    <span class="keyword">if</span> ((pgdir = (<span class="type">pde_t</span> *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The upper end of virtual memory after <code>DEVSPACE</code> has I&#x2F;O devices, so <code>PHYSTOP</code><br>should be below that; this is as good a place as any to make sure.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (P2V(PHYSTOP) &gt; (<span class="type">void</span> *) DEVSPACE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;PHYSTOP too high&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll add all the mappings in <code>kmap</code> above into this page directory so<br>the kernel is happy. We’ll use <code>mappages()</code>, which returns -1 if it fails, so<br>we should check for that. The <code>freevm()</code> function is defined below, and we’ll<br>get to it soon, but for now just know that it gets rid of all the mappings we<br>just made, in case any of them fails.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> *<span class="title">k</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (k = kmap; k &lt; &amp;kmap[NELEM(kmap)]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappages(pgdir,</span><br><span class="line">                k-&gt;virt,</span><br><span class="line">                k-&gt;phys_end - k-&gt;phys_start,</span><br><span class="line">                (uint) k-&gt;phys_start,</span><br><span class="line">                k-&gt;perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            freevm(pgdir);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pgdir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s check out that for loop: <code>k</code> is a pointer to a <code>struct kmap</code>, and <code>kmap</code><br>is an array of <code>struct kmap</code>s; in C, arrays decay to pointers, so they have the<br>same type. <code>k</code> starts off pointing to the first (zero) entry of <code>kmap</code>. Then<br>incrementing it with <code>k++</code> shifts its value by the size of a <code>struct kmap</code>, so<br>it’ll point to the next entry. The loop stops when <code>k</code> points beyond the last<br>entry of <code>kmap</code>, as determined by the <code>NELEM()</code> macro which counts the number of<br>entries in an array. Note that array element-counting only works in C if the<br>array is defined in the same function or as a global variable in the same file,<br>which is why it’s so easy to do an out-of-bounds read or write in C (yet another<br>common security vulnerability).</p>
<p>Finally, if everything worked out okay, we return a pointer to the new page<br>directory.</p>
<h3 id="switchkvm"><a href="#switchkvm" class="headerlink" title="switchkvm"></a>switchkvm</h3><p>We said above that the kernel would usually just use the page directory of the<br>currently-running process, but it’ll use <code>kpgdir</code> when no process is running,<br>i.e. during the kernel setup and while it’s scheduling a new process. So we need<br>a way to tell the paging hardware to load <code>kpgdir</code> into register <code>%cr3</code>, which<br>holds a pointer to the page directory. That’s this function.</p>
<p>It’s a one-liner: get the physical address of <code>kpgdir</code> and stick it in <code>%cr3</code><br>with the assembly instruction <code>lcr3</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcr3(V2P(kpgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvmalloc"><a href="#kvmalloc" class="headerlink" title="kvmalloc"></a>kvmalloc</h3><p>FINALLY, we’re here! We’re gonna get rid of <code>entrypgdir</code>! The kernel’s <code>main()</code><br>calls this function right after <code>kinit1()</code>.</p>
<p>We already did all the hard work, so this one’s a breeze: we call <code>setupkvm()</code><br>to allocate a new page directory and fill it with the kernel’s mappings, then<br>call <code>switchkvm()</code> to load it into the paging hardware.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kvmalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    kpgdir = setupkvm();</span><br><span class="line">    switchkvm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And we’re DONE! Take that, <code>entrypgdir</code>, we don’t need you anymore. We’re big<br>kids now.</p>
<h2 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h2><p>So far, it’s been a serious odyssey just to move from no paging in the boot<br>loader, to super basic paging with <code>entrypgdir</code> in <a href="https://github.com/mit-pdos/xv6-public/blob/master/entry.S">entry.S</a>, to <code>kpgdir</code> now.<br>Along the way, we’ve looked at code to allocate and free pages and install new<br>mappings in page directories and page tables. That’ll come in handy when we look<br>at processes next; the virtual memory story still isn’t over.</p>
<p>Also, note that <code>kpgdir</code> still isn’t at the height of its powers: at the point<br>when <code>main()</code> calls <code>kvmalloc()</code>, the free list only contains pages for physical<br>memory between 0 and 4 MB. The rest will have to wait until <code>kinit2()</code> unleashes<br>its full potential. (Maybe some self-actualization seminars would help…)</p>
<h1 id="More-Paging-The-User-Side"><a href="#More-Paging-The-User-Side" class="headerlink" title="More Paging: The User Side"></a>More Paging: The User Side</h1><p>It’s almost time to turn to interrupts and processes so we can figure out how to<br>work that sweet multiprocessing magic, but unfortunately we have some last<br>pieces of paging to wrap up before we can get there.</p>
<p>I know, we’ve been talking about virtual memory for what feels like a century<br>now, but so far everything we’ve done has been on the kernel side, allocating<br>pages and creating new page directories with the same kernel mapping. But what<br>about the lower half of the virtual address space, where user processes live?</p>
<p>This post will go through the rest of<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/vm.c">vm.c</a><br>and set up the paging-related machinery we’ll need to run processes later on.</p>
<h2 id="Detour-Starting-a-New-Process"><a href="#Detour-Starting-a-New-Process" class="headerlink" title="Detour: Starting a New Process"></a>Detour: Starting a New Process</h2><p>When xv6 runs a new process, it will create a brand new virtual memory space for<br>it with a fresh page directory. We haven’t talked about processes in xv6 yet, so<br>you might wonder how a process gets started up in the first place.</p>
<p>Let’s forget all about xv6 for a second and think about another Unix-like OS:<br>Linux. How do we start a process there? Okay, we also have to forget about GUI<br>applications there. Let’s just say you want to run some C code (xv6 maybe?) that<br>you’ve just compiled; what happens when you run it from the terminal?</p>
<p>Hopefully, you’ve done the OSTEP project called <a href="https://github.com/remzi-arpacidusseau/ostep-projects/tree/master/processes-shell">processes-shell</a><br>by now, so you know the answer; if you haven’t, I recommend doing that one right<br>now before I give it away. (It’s not strictly required, but are you really the<br>kind of person who loves getting movies spoiled for them?)</p>
<p>Okay, are you done?</p>
<p>The answer: it’s just an <code>exec()</code> system call! The shell finds the executable<br>file in the file system, calls <code>fork()</code> to create a new child process, which<br>then calls <code>exec()</code> to transform itself into the program you want to run.</p>
<p>We’ll get to these system calls later, so for now let’s just go over the broad<br>strokes as they relate to virtual memory. <code>fork()</code> works by taking the parent<br>process’s virtual memory space and making a copy of it for the child process.</p>
<p><code>exec()</code> allocates a new page directory, figures out how much memory the new<br>program will need when it runs, then grows the virtual memory space allocated in<br>that new page directory to the required size. Then it loads the program into<br>memory in the new page directory.</p>
<p>Next, <code>exec()</code> skips a page, leaving it mapped but user-inaccessible; then the<br>next page becomes the process’s stack. Why that empty page? It’s an important<br>one for protection: that way, user programs that blow their stack will trigger a<br>page fault or a general protection fault instead of possibly overwriting random<br>code.</p>
<p>Then <code>exec()</code> copies some arguments into the stack before it switches to using<br>the new page directory and gets rid of the old one it had before.</p>
<p>Whew, okay, that’s a lot of code to go over later, and that’s only the virtual<br>memory part of the story. So let’s just make it easier by doing all the work we<br>can right now. According to the above, we have to understand how xv6 does all of<br>the following:</p>
<ul>
<li>Makes a copy of a whole page directory,</li>
<li>Creates a new page directory,</li>
<li>Grows (or shrinks) the virtual memory space of a page directory,</li>
<li>Loads program code into a page directory,</li>
<li>Makes a page inaccessible to users,</li>
<li>Copies stuff into a page in a page directory,</li>
<li>Switches to a new process page directory, and</li>
<li>Gets rid of an unused page directory.</li>
</ul>
<p>Finally, there’s one edge case to think about: running the very first process.<br>We obviously need to start running a shell at some point, so we need a special<br>way to get that started too, so it can in turn run other processes.</p>
<h2 id="vm-c-Again"><a href="#vm-c-Again" class="headerlink" title="vm.c, Again"></a>vm.c, Again</h2><p>We’re gonna need some new functions! Actually, we already finished one of the<br>requirements – <code>setupkvm()</code> can allocate a new page directory and set up the<br>kernel portion too. <code>switchkvm()</code> lets us switch to using <code>kpgdir</code> as a page<br>directory, but now we need to switch <em>away</em> from that to a page directory for a<br>process, so that’ll be <code>switchuvm()</code>.</p>
<p><code>copyuvm()</code> creates a copy of an entire page directory for a child process.<br><code>allocuvm()</code> and <code>deallocuvm()</code> grow and shrink the virtual memory space that’s<br>allocated in a page directory, and <code>freevm()</code> clears a page directory we no<br>longer need.</p>
<p><code>loaduvm()</code> will load program code into a page directory; <code>clearpteu</code> makes a<br>page inaccessible to users, and <code>copyout()</code> copies data into a page in a page<br>directory. <code>inituvm()</code> handles the special case of setting up the page directory<br>for the very first process that xv6 will run.</p>
<p>The rest of this post will go over those functions one by one so we can be done<br>with virtual memory, but I know it’s a little strange to go through a million<br>helper functions when we haven’t seen the code that’s gonna use them yet, so if<br>you’d prefer, you can come back to this after reading about processes and system<br>calls.</p>
<h3 id="deallocuvm"><a href="#deallocuvm" class="headerlink" title="deallocuvm"></a>deallocuvm</h3><p>The arguments for this function are a page directory, the process’s old size,<br>and the new size we want to shrink it down to; it’ll return the process’s new<br>size. By “shrinking” a virtual memory space, we really mean making sure that the<br>page directory only allocates up to <code>newsz</code> worth of pages. So if we think of<br>the sizes as virtual addresses, then the page directory currently maps the<br>virtual space from 0 to <code>oldsz</code>, so we should free everything between <code>newsz</code><br>and <code>oldsz</code>, leaving behind the space from 0 to <code>newsz</code>.</p>
<p>First, we should make sure the new size is actually smaller than the old one;<br>otherwise trying to “shrink” down to the new size might cause integer overflow.<br>There; the sizes are both unsigned integers here, so at least it wouldn’t be<br>that scary boogeyman of undefined behavior, but it could still be bad: 0 would<br>wrap around to 2^32 - 1, so “shrinking” to the new size would actually grow the<br>process way beyond what physical memory could handle.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newsz &gt;= oldsz) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re gonna shrink the physical memory allocated to this page directory by<br>freeing pages until we reach the new size. Let’s start with the first page above<br><code>newsz</code>; we can get its virtual address by rounding up <code>newsz</code> to a page<br>boundary.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint a = PGROUNDUP(newsz);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll just iterate over the pages between <code>a</code> and <code>oldsz</code> one at a time and<br>free them. This is a little tricky: <code>kfree()</code> takes a virtual address (cast to a<br><code>char *</code>), but it should be a <em>kernel</em> virtual address in the higher half, not a<br>user virtual address. Luckily, we already have <code>walkpgdir()</code>, which can take an<br>arbitrary virtual address and return its page table entry, so that’s a good<br>start.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walkpgdir(pgdir, (<span class="type">char</span> *) a, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The page table entry contains the page’s physical address, plus some flags to<br>determine whether it’s mapped and what permissions are set for it.</p>
<p>Now, a virtual address space isn’t laid out contiguously. Think about it: if you<br>sit back and imagine a user process hanging out in memory, what does that<br>address space look like? You’re probably imagining the stack at one end of<br>memory and the heap at the other, with each growing toward the center, right?<br>so there will be some pages in the center that aren’t mapped; some of the page<br>tables might not exist either, in which case <code>walkpgdir()</code> would return a null<br>pointer.</p>
<p>Remember we agreed to never dereference null pointers? Yeah, so we’ll have to<br>skip all those unmapped pages. If we got a null pointer, then that means the<br>entire page table doesn’t exist, so we need to skip forward to the next page<br>directory entry (and thus the next page table). We’ll have to move <code>a</code> to the<br>virtual address that corresponds to that next page directory entry.</p>
<p>We can get the page directory index from <code>a</code> with the <code>PDX()</code> macro we’ve seen<br>seen before, and then just add 1 to get the next entry in the page directory.<br>Now we need to turn that back into a virtual address. We’ll use a new macro,<br><code>PGADDR()</code> (also from <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>),<br>to do that. So then we’ll continue to the next loop iteration, which will get<br>the page table entry for this new virtual address.</p>
<p>Wait wait wait, one last thing! After all that, <code>a</code> should now be the first<br>virtual address in the page table for the new page directory entry… except<br>it’s get <code>PGSIZE</code> added to it because of the for loop’s update statement.</p>
<p>Ugh, okay, fine, this is annoying. Let’s just fix it with a hack: subtract<br><code>PGSIZE</code> from it now, so that it gets incremented to the right value in the next<br>iteration. Okay, that’s it, I swear!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walkpgdir(pgdir, (<span class="type">char</span> *) a, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            a = PGADDR(PDX(a) + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) - PGSIZE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now the else branch: if we don’t get a null pointer then at least the page<br>table exists, but that doesn’t mean the page itself is mapped. If it’s not, then<br>we don’t need to do anything else, but if it is mapped, then we need to free it.<br>We can get the page’s physical address out of the page table entry with the<br><code>PTE_ADDR</code> macro then make sure it’s not null.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            uint pa = PTE_ADDR(*pte);</span><br><span class="line">            <span class="keyword">if</span> (pa == <span class="number">0</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The whole point of this was to be able to call <code>kfree()</code>, remember? So let’s<br>convert <code>pa</code> to a kernel virtual address as a <code>char *</code> and free it. Then after<br>the loop is done, we’ll return the new size.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="type">char</span> *v = P2V(pa);</span><br><span class="line">            kfree(v);</span><br><span class="line">            *pte = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocuvm"><a href="#allocuvm" class="headerlink" title="allocuvm"></a>allocuvm</h3><p>This is the reverse of <code>deallocuvm()</code>: instead of freeing pages with <code>kfree()</code>,<br>we’ll allocate them with <code>kalloc()</code>. Here too, we start by checking for integer<br>overflow by making sure <code>newsz</code> really is larger than <code>oldsz</code>. But now we also<br>have to check that we’re not gonna grow the process’s size into the region where<br>it could access kernel memory; otherwise it might read or modify arbitrary<br>physical memory.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newsz &gt;= KERNBASE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newsz &lt; oldsz) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re gonna start adding new pages right after <code>oldsz</code>, so we have to align that<br>to a page boundary:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint a = PGROUNDUP(oldsz);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The for loop is easier this time around because we already know that the pages<br>aren’t mapped. First we allocate a new page. Any call to <code>kalloc()</code> needs two<br>things after, remember? We have to check for null, in which case we print an<br>error message to the console (that’s <code>cprintf()</code>; we’ll get to that in the<br>devices section), then undo any allocations we made and return 0. Then we have<br>to zero the page because we filled it with 1s when it was freed.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">char</span> *mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;allocuvm out of memory\n&quot;</span>);</span><br><span class="line">            deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We have a page now, but it’s not yet mapped in the page directory. We can do<br>that with <code>mappages()</code>; that might fail too (because it needs to allocate more<br>pages for the page tables), in which case we do the same as before. Then after<br>the for loop is done, we return the new size.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span>, uint oldsz, uint newsz) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappages(pgdir, (<span class="type">char</span> *) a, PGSIZE, V2P(mem), PTE_W | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;allocuvm out of memory (2)\n&quot;</span>);</span><br><span class="line">            deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freevm"><a href="#freevm" class="headerlink" title="freevm"></a>freevm</h3><p>This function will get rid of a user page directory that we no longer need. Now<br>that we have <code>deallocuvm()</code>, it’s easy: we just “shrink” the process to a size<br>of zero. Oh and we’ll remember the lessons our ancestors have taught us and make<br>sure the pointer to the page directory isn’t null before dereferencing it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pgdir == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;freevm: no pgdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    deallocuvm(pgdir, KERNBASE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Great, so all pages are freed, and we’re done!</p>
<p>Now hang on a sec… The page directory itself resides in memory; so do the page<br>tables. We have to free those too. We’ll start with the page tables; freeing the<br>page directory first would be a use-after-free vulnerability because we’d need<br>to use it to get to the page tables.</p>
<p>We’ll iterate over the page directory’s entries, checking whether each one has<br>the “present” flag set (<code>NPDENTRIES</code> is defined as 1024 in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">mmu.h</a>).<br>If it does, we’ll get the page table’s physical address from it with the<br><code>PTE_ADDR()</code> macro, then convert that to a virtual address as a <code>char *</code> to make<br><code>kfree()</code> happy. We don’t have to worry about clearing the “present” flag in the<br>page directory because it’s about to be freed anyway.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; NPDENTRIES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pgdir[i] &amp; PTE_P) &#123;</span><br><span class="line">            <span class="type">char</span> *v = P2V(PTE_ADDR(pgdir[i]));</span><br><span class="line">            kfree(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We wrap up by freeing the page directory itself.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    kfree((<span class="type">char</span> *) pgdir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copyuvm"><a href="#copyuvm" class="headerlink" title="copyuvm"></a>copyuvm</h3><p>The <code>fork()</code> system call will need to “clone” a process, which includes its<br>virtual address space. This function takes a pointer to the parent process’s<br>page directory and the size of the parent process’s address space and returns a<br>pointer to a fresh new page directory with everything set up exactly the same.</p>
<p>We start by creating a new page directory and taking care of the kernel’s half<br>of the address space with <code>setupkvm()</code>. That might fail if it can’t allocate a<br>new page, so we have to check for null. Sigh. C code is approximately 40%<br>checking for null return values.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *d;</span><br><span class="line">    <span class="keyword">if</span> ((d = setupkvm()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll iterate over the user portion of the parent process’s address space<br>from 0 to <code>sz</code>, copying everything over as we go. Say we want to copy a page<br>from the parent’s virtual address <code>i</code> to the child’s address <code>i</code> (note that<br>they’ll map to different physical addresses). We’ll have to figure out the<br>corresponding kernel virtual address for the parent’s <code>i</code> in order to do that,<br>so we use <code>walkpgdir()</code> to get the page table entry, then get the page’s<br>physical address.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, (<span class="type">void</span> *) i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;copyuvm: pte should exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; PTE_P)) &#123;</span><br><span class="line">            panic(<span class="string">&quot;copyuvm: page not present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint pa = PTE_ADDR(*pte);</span><br><span class="line">        uint flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case we know the parent process is already set up, so we don’t really<br>have to worry about <code>walkpgdir()</code> failing and returning null, but it’s bad C<br>juju to ignore a possibly-null return value, so we just panic if it does fail or<br>if the page isn’t present.</p>
<p>Next we allocate a page for the child process (checking for null again…) and<br>copy everything from the parent’s page to the new child page.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">char</span> *mem;</span><br><span class="line">        <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">        memmove(mem, (<span class="type">char</span> *) P2V(pa), PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might recognize <code>memmove()</code> as a C standard library function that copies the<br>contents of one memory address into another, but we can’t use those, remember?<br>So xv6 provides its own implementation of it in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>.</p>
<p>If you haven’t seen a <code>goto</code> statement before, it’s basically a holdover from ye<br>olde days before Edsger Dijkstra preached the gospel of structured programming<br>to the world and invented the if statement. It does exactly what it sounds like:<br>you make a label somewhere in code and it takes you there.</p>
<p>Next we stick that new page into the child’s page directory, checking for null<br>again. If <code>mappages()</code> fails, then the new page won’t be in the page directory,<br>so we have to free it here or else we’ll never be able to find it again: a<br>memory leak.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (mappages(d, (<span class="type">void</span> *) i, PGSIZE, V2P(mem), flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If none of the allocations failed, we just return a pointer to the new page<br>directory. But if something went wrong, then one of those <code>goto</code> statements will<br>send us to the time out corner of <code>bad</code>, where we undo all our work by freeing<br>the page directory and returning a null pointer.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    freevm(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Great, another function we’ll have to check for null.</p>
<h3 id="switchuvm"><a href="#switchuvm" class="headerlink" title="switchuvm"></a>switchuvm</h3><p>Okay, we’ve got a way to create a new process page directory. We also have a way<br>to switch to using the kernel page directory <code>kpgdir</code> with <code>switchkvm()</code>. But we<br>need a way to switch to using the process page directory too. Enter <code>switchuvm()</code>.</p>
<p>I’ll warn you – <code>switchkvm()</code> was nice and short, but <code>switchuvm()</code> is an ugly<br>one for sure.</p>
<p>The argument to this function is a pointer to a <code>struct proc</code>, which represents<br>a process. We’ll talk about that more when we get to processes; two fields are<br>important now: <code>p-&gt;kstack</code> which holds a pointer to the kernel stack for that<br>process, and <code>p-&gt;pgdir</code>, which points to that process’s page directory.</p>
<p>Okay, well let’s start with some sanity checks to make sure that the process <code>p</code><br>actually exists (the pointer is non-null) and its kernel stack and page directory<br>pointers are non-null too.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no process&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kstack == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kstack == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The main function of loading the process’s page directory will be the same as in<br><code>switchkvm()</code>: just an <code>lcr3</code> instruction. But the difference now is that the<br>x86 architecture requires some additional bookkeeping for processes.</p>
<p>See, when the kernel runs a new process, the CPU will start executing different<br>instructions. But it needs a way to keep track of where it left off in the<br>kernel code so that it can pick the thread back up after the process is done<br>executing. Similarly, interrupts and system calls might change the running<br>process, so the CPU needs to record some metadata about the process’s state too<br>before switching to another one. x86 does that by means of a structure called a<br><em>Task State Segment</em>, or TSS.</p>
<p>The TSS holds information like the current state of certain registers (e.g.,<br><code>%esp</code>, <code>%eip</code>, <code>%cr3</code>, etc.), segment descriptors (<code>%cs</code>, <code>%ss</code>, <code>%ds</code>, etc.),<br>the current privilege leve, and I&#x2F;O privilege levels – in other words, the<br>process’s <em>context</em>. It can be located anywhere in memory, but the processor<br>needs to find it, so it uses an entry in the GDT called the TSS segment<br>descriptor that points to the TSS. Remember the GDT from way back when we were<br>talking about segmentation? Good times. The CPU holds a pointer to the GDT’s TSS<br>entry in a special register called the task register.</p>
<p>Back in the segmentation days of our youth, we stored the GDT in a <code>struct cpu</code><br>that held information about the current processor. We got that <code>struct cpu</code> by<br>calling a <code>mycpu()</code> function. We’re gonna do the same thing here in order to<br>update the GDT with a segment for the TSS. Getting interrupted in the middle of<br>this might be disastrous: the TSS would be half-updated, so who knows what would<br>happen when the CPU tried to resume execution where it last left off. So we’ll<br>use the <code>pushcli()</code> and <code>popcli()</code> functions we saw with spin-locks to temporarily<br>disable interrupts.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    mycpu()-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;mycpu()-&gt;ts, <span class="keyword">sizeof</span>(mycpu()-&gt;ts)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    mycpu()-&gt;gdt[SEG_TSS].s = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whoa okay what is this?</p>
<p>We’ve seen the <code>SEG()</code> and <code>SEG_ASM()</code> macros before; they created GDT segments.<br><code>SEG16()</code> does the same with 16 bits (it’s defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>). <code>STS_T32A</code><br>is a flag that sets the segment’s type as an available 32-bit TSS. Then we pass<br>in a pointer to the task state with <code>&amp;mycpu()-&gt;ts</code>, its size, and a descriptor<br>privilege level of 0 (which means ring 0, the kernel level). The GDT’s <code>.s</code><br>field is a one-bit flag to determine whether this is a system or application<br>segment, so we set it to system.</p>
<p>Okay, so now the GDT points to the task state. Next we need to update the task<br>state, then load it into the CPU. We’ll start by storing a segment selector and<br>the stack pointer in the task state; these should look familiar from the boot<br>loader and <code>seginit()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mycpu()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    mycpu()-&gt;ts.esp0 = (uint) p-&gt;kstack + KSTACKSIZE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The TSS can also specify permissions for accessing I&#x2F;O ports: for example,<br>setting the I&#x2F;O privilege level to 0 in the <code>eflags</code> register <em>and</em> setting a<br>part of the TSS called the I&#x2F;O map base address to an address beyond the TSS<br>segment forbids I&#x2F;O instructions like <code>inb</code> and <code>outb</code> from user space. So we’ll<br>set the I&#x2F;O map base address next.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mycpu()-&gt;ts.iomb = (ushort) <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So now we have a GDT entry pointing to the TSS, which is now updated. Now we<br>just load it into the task register with the x86 instruction <code>ltr</code>; here we use<br>a C wrapper for that assembly instruction, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ltr(SEG_TSS &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, the last thing we do before re-enabling interrupts is to load the<br>process’s page directory into the <code>%cr3</code> register so we can start using it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lcr3(V2P(p-&gt;pgdir));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loaduvm"><a href="#loaduvm" class="headerlink" title="loaduvm"></a>loaduvm</h3><p>Okay, this is another function that’s gonna require extra info we haven’t seen<br>yet, but I’m gonna make it a bit easier by waving my hands around and glossing<br>over the details. It’s gonna read a program from a file into memory at virtual<br>address <code>addr</code> using page directory <code>pgdir</code>. The part we want to read has size<br><code>sz</code> and is located at position <code>offset</code> within the file.</p>
<p>Now, what about the file? We’ll talk more when we get to the file system code,<br>but for now let’s just say that files are represented in xv6 as <code>struct inode</code>s,<br>and we can read from them with the function <code>readi()</code>.</p>
<p>We’re gonna run the program from this code, so the address it’s stored in needs<br>to be page-aligned.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((uint) addr % PGSIZE != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;loaduvm: addr must be page aligned&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’re gonna iterate over pages starting from <code>addr</code>, reading from the file<br>in <code>ip</code> into that page. As usual, we’ll need to get the kernel virtual address<br>from the user address <code>addr</code>, so we start by getting the page table entry via<br><code>walkpgdir()</code>, checking for a null pointer if the corresponding page table<br>doesn’t exist. Then we can turn that into a physical address.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// Get the page table entry</span></span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, addr + i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;loaduvm: address should exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get the page&#x27;s physical address</span></span><br><span class="line">        uint pa = PTE_ADDR(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we want to read from the file one page at a time using <code>readi()</code>, which<br>takes a pointer to an inode (here, <code>ip</code>), a kernel virtual address (<code>P2V(pa)</code>),<br>the location within the file of the segment we want to read (<code>offset + i</code>), and<br>the segment’s size.</p>
<p>Now we want to read from the file one page at a time using <code>readi()</code>. We have to<br>specify a size in bytes to read; if the remaining unread part of the segment is<br>larger than a page, then the size we pass to <code>readi()</code> should be <code>PGSIZE</code>, but<br>otherwise it’ll be less. So we’ll compare <code>sz</code> to <code>i</code> and define define <code>n</code><br>accordingly.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        uint n;</span><br><span class="line">        <span class="keyword">if</span> (sz - i &lt; PGSIZE) &#123;</span><br><span class="line">            n = sz - i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n = PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The other arguments to <code>readi()</code> are a pointer to an inode (<code>ip</code>), a kernel<br>virtual address (<code>P2V(pa)</code>), and the location within the file of the segment we<br>want to read (<code>offset + i</code>). It returns the number of bytes read, so if it’s not<br><code>n</code> we’ll report an error by returning -1. Otherwise we return 0 after the for<br>loop is done.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (readi(ip, P2V(pa), offset + i, n) != n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inituvm"><a href="#inituvm" class="headerlink" title="inituvm"></a>inituvm</h3><p>Okay, the next three are nice and easy! This next one is pretty similar to<br><code>loaduvm()</code>, except instead of loading program code from disk, it copies it in<br>from memory. We’ll take <code>sz</code> bytes from a source address of <code>init</code> and stick it<br>in address 0 of the process’s page directory <code>pgdir</code>.</p>
<p>This function is also easier because we’re only gonna call it for programs that<br>are less than one page in size, so we don’t have to worry about looping over<br>pages or anything like that. I like it when xv6 keeps things simple.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sz &gt;= PGSIZE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we allocate a fresh page of memory, zero it to clear the garbage values,<br>and stick it into <code>pgdir</code> at address 0.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> *mem = kalloc();</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    mappages(pgdir, <span class="number">0</span>, PGSIZE, V2P(mem), PTE_W | PTE_U);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And we wrap up by actually loading the code from <code>init</code> into the new page.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    memmove(mem, init, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clearpteu"><a href="#clearpteu" class="headerlink" title="clearpteu"></a>clearpteu</h3><p>This function takes a page directory and a user virtual address and clears the<br>“user-accessible” flag so that the process can’t touch it. It’s used to create<br>an inaccessible page below a new process’s stack to guard against stack<br>overflows; this way, a stack overflow will cause a page fault instead of<br>silently overwriting memory.</p>
<p>The <code>PTE_U</code> flag is in the page table entry, so we’ll have to get that, then set<br>the flag.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearpteu</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *uva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the page table entry</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = walkpgdir(pgdir, uva, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;clearpteu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Clear the user permission flag</span></span><br><span class="line">    *pte &amp;= ~PTE_U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here <code>&amp;</code> is a bitwise-AND and <code>~</code> is a bitwise-NOT; for reference, <code>|</code> is<br>bitwise-OR and <code>^</code> is bitwise-XOR. Contrast these with their logical versions,<br><code>&amp;&amp;</code>, <code>!</code>, and <code>||</code> (XOR has no logical version). C also has corresponding<br>assignment operators (similar to <code>+=</code>, <code>-=</code>, <code>*=</code>, etc.) for each of them. So<br>the last line of code is equivalent to <code>*pte = *pte &amp; (~PTE_U)</code>.</p>
<h3 id="uva2ka"><a href="#uva2ka" class="headerlink" title="uva2ka"></a>uva2ka</h3><p>We often need to convert user virtual addresses to kernel ones; <code>uva2ka()</code> is a<br>short helper function that does that while checking that the page is actually<br>present and has the user permission flag set.</p>
<p>We’ll call walkpgdir to get the page table entry, then check both permission<br>bits before recovering the page address with <code>PTE_ADDR()</code> and converting it to a<br>kernel virtual address. We’ll return the kernel virtual address as a <code>char *</code>,<br>or null if either flag is not set.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">uva2ka</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *uva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walkpgdir(pgdir, uva, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_P) == <span class="number">0</span>) &#123;  <span class="comment">// check that it&#x27;s present</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span>) &#123;  <span class="comment">// check that it&#x27;s user-accessible</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> *) P2V(PTE_ADDR(*pte));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let me ask you a weird question: how are you feeling right now?</p>
<p>Okay, that was a test of your C coding practices, because if you took those null<br>checks to heart, you should be <em>really</em> uncomfortable right about now.</p>
<p>Check it out: <code>walkpgdir()</code> returns a pointer to the page table entry. <em>Any</em><br>time a function returns a pointer, you should immediately ask yourself whether<br>that function can return a null pointer. Tons of C functions report an error by<br>returning null. In this case, we <em>know</em> <code>walkpgdir()</code> can fail and report null<br>if the page table doesn’t exist, so we <em>know</em> we might get a null pointer out of<br>it – it’ll happen whenever a page table doesn’t exist. So what do we do with<br>that knowledge?</p>
<p>Why, we go right ahead and dereference that pointer. WKBW;NQ39Q2A4T8YHMFGRW!!!</p>
<p>Dereferencing a null pointer is undefined behavior. There’s literally no telling<br>what might happen. It can cause all kinds of bugs from segmentation faults to<br>security vulnerabilities.</p>
<p>All those null checks in the other functions serve a purpose: if something goes<br>wrong and a function returns a null pointer, they catch it before it gets<br>dereferenced, then either handle it gracefully or simply propagate the error by<br>returning null (or some other error code) and let the caller figure out what to<br>do with it.</p>
<p>Omitting a check for a null pointer like <code>uva2ka()</code> does is bad practice in C<br>because it means the programmer has to <em>guarantee</em> – by manually checking –<br>that no call to this function could <em>ever possibly</em> cause a null return value.<br>Except humans are dumb, dumb creatures who make mistakes all the time, especially<br>in big projects: there’s no way you’d be able to remember that tiny little<br>detail two years later when you decide to refactor your code or add a new<br>feature or something.</p>
<p>But maybe you can note that in the comments? Okay yeah, but think about it: how<br>often do you go and look up the source code for every single function you call?<br>Yeah, I thought so.</p>
<p>This is why C is so dangerous: there are hundreds of such problems that you need<br>to be aware of and remember to add stuff like null pointer checks to your code.<br>If you don’t because you’re a normal human who forgets things sometimes, then<br>you’ll need to remember that you forgot to do it before and manually check every<br>single call to your code and think about every possible edge case that a<br>malicious adversary might exploit.</p>
<p>Good thing no one ever makes these mistakes in C, or we’d see enormous security<br>vulnerabilities being reported every single day in all kinds of critical<br>software. Oh wait…</p>
<p>So if you ever find yourself looking at C during code review and you come across<br>a function that returns a pointer, you should stop what you’re doing and look up<br>the documentation for that function. If that function has any chance of<br>returning a null pointer, then you should yell and kick and scream until somebody<br>adds a null check and figures out how they want to handle it if it’s null. Is<br>this annoying? Yes. Hard to remember? Yes. But that’s C. <em>(cough cough use Rust<br>instead cough cough…)</em></p>
<p>Now, the xv6 authors are so awesome that I’m gonna give them the benefit of the<br>doubt and assume they left it off because they hand-checked every call to make<br>sure it would never be an issue. But you and me? Nah.</p>
<p>The point of my rant is this: if you’re reading this, then you’re probably gonna<br>find yourself hacking away at xv6 for a project sooner or later. When you do<br>that, you should treat this function as VERBOTEN. You’re not allowed to touch<br>it or call it, at least until you add a null check to it yourself.</p>
<p>The same goes for any functions that call this one, because maybe all the<br>existing calls to <code>uva2ka()</code> are fine right now, but then you make some tiny<br>change and now it’s no longer guaranteed to never be null. For reference, this<br>function currently only gets called by <code>copyout()</code>, and that one only gets<br>called by <code>exec()</code>. <code>exec()</code> gets called by <code>sys_exec()</code>, the shell, and the<br>initial user-space program <code>init</code>. So be careful if you touch any of those.</p>
<p>Whew, okay, &#x2F;rant.</p>
<h3 id="copyout"><a href="#copyout" class="headerlink" title="copyout"></a>copyout</h3><p>This function copies <code>len</code> bytes of data from a kernel virtual address <code>p</code> to a<br>user virtual address <code>va</code> using page directory <code>pgdir</code>. <code>exec()</code> will use this<br>to copy command-line arguments to the stack for a program it’s about to run.</p>
<p>You might be wondering why it’s needed – doesn’t <code>memmove()</code> do the same thing?<br>Almost, but the difficulty is that <code>pgdir</code> may not be the current page<br>directory, so we’ll have to manually translate the virtual address <code>va</code>. That’s<br>where <code>uva2ka()</code> comes in, plus it ensures that the page for <code>va</code> has the right<br>flags set. <em>Then</em> we can use <code>memmove()</code>.</p>
<p>First, <code>p</code> will be the source address, but <code>memmove()</code> requires a <code>char *</code> in<br>order to copy data byte-by-byte, so let’s convert it now:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to get the kernel virtual address corresponding to <code>va</code>, but<br>there’s a challenge: what if the data crosses a page table boundary? It might be<br>spread across separate locations in physical memory (and thus in kernel virtual<br>memory too). So we’ll need a loop in which each iteration gets the next kernel<br>virtual address and copies whatever part of the data is in this page.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        len -= n;</span><br><span class="line">        buf += n;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So we’ll start each iteration by making <code>va0</code> the base address of the page <code>va</code><br>is on and <code>pa0</code> the kernel address of <code>va0</code>, converted with <code>uva2ka()</code>. I…<br>honestly don’t know why they used <code>pa0</code> as an identifier here. It makes it look<br>like it should be a physical address, but it’s not; it’s a kernel virtual<br>address. Sigh. Anyway, the call to <code>uva2ka()</code> might fail if the page isn’t<br>present or it doesn’t have a user permission bit, so we have to check for a null<br>pointer and return -1 if we find one.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        uint va0 = (uint) PGROUNDDOWN(va);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *pa0 = uva2ka(pgdir, (<span class="type">char</span> *) va0);</span><br><span class="line">        <span class="keyword">if</span> (pa0 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        va = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now <code>va</code> is in between <code>va0</code> and the next page, so the length of the data within<br>this page is <code>PGSIZE - (va - va0)</code>, unless it’s the last page, in which case we<br>should pick the lesser of this value and <code>len</code> (since <code>len</code> gets decremented on<br>each iteration through the loop).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        uint n = PGSIZE - (va - va0);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we copy the data from <code>buf</code> into the target kernel virtual address for<br><code>va</code>. Hmm, we don’t have that yet. Oh wait, <code>pa0</code> is the kernel virtual address<br>for <code>va0</code>, and <code>va</code> is just <code>va-va0</code> bytes after that, so we’ll use it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        memmove(pa0 + (va - va0), buf, n);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We return 0 if everything went okay.</p>
<h2 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h2><p>Okay, that was a lot of helper functions, but we’re ALL DONE with virtual<br>memory! From now on, we have all the tools we’ll need to manage memory and set<br>up virtual address spaces for new processes.</p>
<h1 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h1><p>It’s time to turn our attention to processes in xv6!<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a> is another<br>huge file, so I’m gonna split it up into a few posts. This one will focus on the<br>basic functions we’ll need in order to create new processes; later posts will<br>go over scheduling and system calls.</p>
<h2 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a>proc.h</h2><p>I haven’t spent much time on the header files in xv6, but<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.h">proc.h</a> defines some<br>important structures we’re gonna be using often, so let’s just get those out of<br>the way first.</p>
<p>Let’s start off with the definition for <code>struct context</code>. The processor will<br>have to switch between different processes during interrupts, system calls,<br>exceptions, etc.; these <em>context switches</em> will require saving the contents of<br>some of the CPU registers so that it can reload them when it switches back and<br>resume execution where it left off. It’ll save the process’s context by pushing<br>those register contents on the stack; that way the stack pointer is effectively<br>a pointer to the context. So the fields of a <code>struct context</code> will just list all<br>the registers that were saved on the stack.</p>
<p>Now, which registers do we need to save? Let’s look at the full list on the<br><a href="https://wiki.osdev.org/CPU_Registers_x86">OSDev Wiki</a>. We’ve got some general-<br>purpose registers, the instruction pointer register <code>%eip</code>, segment registers,<br>a flags register, control registers, and the GDT and IDT registers (x86 doesn’t<br>use the debug, test, or LDT registers).</p>
<p>The flags register, control registers, and GDT&#x2F;IDT registers shouldn’t change<br>between processes, so we don’t need to save those. What about the segment<br>registers like <code>%cs</code>? Back when we set up segmentation, we made the segments be<br>identity maps that would always stay the same for all processes. There are<br>separate segments for user mode and kernel mode, but context switches will<br>always occur in kernel mode, so the segment registers shouldn’t change, and we<br>don’t need to save them either.</p>
<p>We should definitely save the program counter (AKA instruction pointer <code>%eip</code>),<br>since that will point to the place in the code where we should resume execution.</p>
<p>The only ones left now are the general-purpose registers: the stack base pointer<br><code>%ebp</code> and stack pointer <code>%esp</code>, along with <code>%eax</code>, <code>%ebx</code>, <code>%ecx</code>, <code>%edx</code>,<br><code>%esi</code>, and <code>%edi</code>. We said above that the stack pointer <code>%esp</code> would tell us<br>where to find the context, so that must mean we’ll already have it through some<br>other means in order to find the rest of the context, so we don’t need to save<br>it again (we’ll see how we end up getting it later on). But we do need to save<br><code>%ebp</code>.</p>
<p>There’s an x86 convention that the caller of a function has to save <code>%eax</code>,<br><code>%ecx</code>, and <code>%edx</code>, so those are already taken care of. So we’ll just save the<br>others: <code>%edi</code>, <code>%esi</code>, and <code>%ebx</code>.</p>
<p>We end up with this list of saved registers as the fields for <code>struct context</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    uint edi;</span><br><span class="line">    uint esi;</span><br><span class="line">    uint ebx;</span><br><span class="line">    uint ebp;</span><br><span class="line">    uip eip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Next up: we might end up with a bunch of processes, some of which are currently<br>running while others aren’t. Let’s set up some labels to note that. We’ll<br>definitely need a <code>RUNNING</code> label; we’ll also use one called <code>RUNNABLE</code> for<br>processes that are ready to be run the next time there’s a free CPU. We also<br>need a label for processes that are blocked waiting for something else to happen<br>(e.g., I&#x2F;O); xv6 calls this <code>SLEEPING</code>. Processes that don’t exist yet will be<br>called <code>UNUSED</code>.</p>
<p>There are two special moments in a process’s lifecycle that we should be careful<br>with: birth and death. When we create a new process, we’ll have to do a bunch of<br>setup before it’s <code>RUNNABLE</code>; killing a process requires clean-up before it goes<br>back to <code>UNUSED</code>. We’ll call those <code>EMBRYO</code> and <code>ZOMBIE</code>, respectively.</p>
<p>We could use bit flags for these states or just regular integers, except then<br>we’d have to do annoying bit arithmetic or keep track of which number represents<br>which state. And yes, we could use a bunch of <code>#define</code> directives for the<br>preprocessor for that, but there’s a better way to do it. C lets us create data<br>types for labels using <code>enum</code>s. These don’t have fields like <code>struct</code>s do;<br>they’re basically just a mapping between integers and what the labels those<br>integers represent. So it’s pretty similar to using a bunch of <code>#define</code><br>directives, except that they’re all defined neatly in a single place, so it<br>helps us remember they’re all representing the same idea. So we’ll use an <code>enum</code><br>like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Now it’s time to look at how we’ll represent processes themselves together with<br>their metadata. Let’s see… what kind of unique data does each process have?<br>We just talked about <code>struct context</code>s and <code>enum procstate</code>s; each process will<br>have both of those.</p>
<p>We also talked about virtual memory for processes in a previous post, so it<br>should also have its own page directory and stack for the kernel to use, plus a<br>way to track the size of its virtual address space. We said then that processes<br>are created using <code>fork()</code>, so let’s add a field to point to the parent process.</p>
<p>We’ll need a way for the kernel to refer to a process, so let’s give it a unique<br>process ID. That’s not super helpful when it comes to debugging, so let’s also<br>add a name for it as a string.</p>
<p>The rest of the fields are for aspects we haven’t seen yet but will talk about<br>soon: a <em>trap frame</em> for interrupts and system calls, a boolean to track whether<br>a process should be killed soon, a <em>channel</em> to be able to wake up a sleeping<br>process, an array of open files, and a current working directory.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    uint sz;                    <span class="comment">// size (in bytes) of virtual address space</span></span><br><span class="line">    <span class="type">pde_t</span> *pgdir;               <span class="comment">// page directory</span></span><br><span class="line">    <span class="type">char</span> *kstack;               <span class="comment">// kernel stack for this process</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>       <span class="comment">// process state</span></span><br><span class="line">    <span class="type">int</span> pid;                    <span class="comment">// process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>        <span class="comment">// parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// trap frame for current system call</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span>    <span class="comment">// saved register contents for context switches</span></span><br><span class="line">    <span class="type">void</span> *chan;                 <span class="comment">// channel that process is sleeping on, if any</span></span><br><span class="line">    <span class="type">int</span> killed;                 <span class="comment">// boolean: should process be killed soon?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// array of open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>          <span class="comment">// current working directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];              <span class="comment">// process name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Okay, next we’ll add another structure for metadata representing each CPU.</p>
<p>If you read the previous post, then you know each CPU has its own local<br>interrupt controller with a unique ID, so we’ll write that down. The post about<br>process paging talked about the TSS, so we’ll need one of those per CPU, plus a<br>GDT too.</p>
<p>At any point in time, a processor will be running one of: its own initialization<br>routine (only once while the kernel is setting up), a user process (or any<br>interrupts or system calls that come up), or a scheduler routine to run the next<br>process. So let’s add a pointer to a <code>struct proc</code>, which will be null if it’s<br>not running a process; a boolean <code>started</code> will be false until the CPU finishes<br>its own set-up. The scheduler isn’t itself a process; it uses the <code>kpgdir</code> page<br>directory and has its own context, so we’ll store that context in a field here.</p>
<p>Finally: remember how the spin-lock post talked about nested calls to <code>pushcli()</code><br>and <code>popcli()</code> tracking whether interrupts were enabled before the first call to<br><code>pushcli()</code>, and only enabling interrupts after the last call to <code>popcli()</code> if<br>they were enabled before? Those were tracked with per-CPU fields <code>ncli</code> and<br><code>intena</code>, so we need those too.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">    uchar apicid;               <span class="comment">// ID of this CPU&#x27;s local interrupt controller</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">scheduler</span>;</span>  <span class="comment">// scheduler&#x27;s context</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span>;</span>        <span class="comment">// task state segment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[<span class="title">NSEGS</span>];</span>  <span class="comment">// global descriptor table</span></span><br><span class="line">    <span class="keyword">volatile</span> uint started;      <span class="comment">// boolean: has this CPU been initialized yet?</span></span><br><span class="line">    <span class="type">int</span> ncli;                   <span class="comment">// depth of pushcli() nesting</span></span><br><span class="line">    <span class="type">int</span> intena;                 <span class="comment">// were interrupts enabled before pushcli()?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// currently running process</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Last but not least, we’ll add declarations for the global array of CPUs and the<br>number of CPUs actually present on this machine; these were defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mp.c">mp.c</a></p>
<p>Okay, on to the functions now!</p>
<h2 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a>proc.c</h2><p>xv6 uses a global process table with an array of processes to store all the<br><code>struct proc</code>s in; this means we’ll never be able to create more processes than<br>the number of entries in the array, <code>NPROC</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 64.<br>We’ll need a lock too to prevent data races while accessing the process table.<br>The process table’s definition does that thing again where you simultaneously<br>define a <code>struct type</code> and define a variable using that type in a single<br>statement.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line">&#125; ptable;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Then we define a global static variable to point to the first process that gets<br>run on xv6, so that other files can set it up.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">initproc</span>;</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Finally, we’re gonna need to assign unique process IDs, so we’ll use a global<br>counter to know which one we should use next.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="pinit"><a href="#pinit" class="headerlink" title="pinit"></a>pinit</h3><p>This function only does one thing: initializes the lock in the process table.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;ptable.lock, <span class="string">&quot;ptable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mycpu"><a href="#mycpu" class="headerlink" title="mycpu"></a>mycpu</h3><p>This function will return a pointer to the <code>struct cpu</code> for the current CPU.<br>There’s a potential concurrency bug with this function: if it gets interrupted<br>before it returns, then it might get rescheduled on a different CPU, and end up<br>returning an incorrect <code>struct cpu</code>. So we need to make sure that interrupts are<br>disabled when we call it. Normally we’d do that with <code>pushcli()</code> and <code>popcli()</code>,<br>but those functions actually call this one, so we’d get an infinite recursion.<br>So instead we’re just gonna have to remember to disable interrupts <em>before</em><br>calling this function.</p>
<p>If you’re reading this because you’re gonna do some xv6 kernel hacking for an<br>OSTEP project or something, you should read that as “DANGER DANGER DANGER!”. If<br>your code calls this function, or calls any other functions that in turn call<br>this one, you <em>have</em> to make sure you’ve disabled interrupts first.</p>
<p>Concurrency bugs are a nightmare because they’re not deterministic: for example,<br>if you forget to disable interrupts before calling this function, it might work<br>just fine most of the time until the one unlucky moment when it gets interrupted<br>and rescheduled on a different CPU. So let’s make this easier to debug by<br>starting off with a check that interrupts are disabled and panic if they’re not.<br>We can check whether the interrupt flag <code>FL_IF</code> is set in the <code>eflags</code> register.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *<span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;mycpu called with interrupts enabled\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay so how do we figure out which CPU we’re on? Well, the previous post talked<br>about interrupt controllers; each CPU has a local interrupt controller with a<br>unique ID which we can get with <code>lapicid()</code>. Once we have that, we can iterate<br>over the CPU array <code>cpus</code> until we find an entry with a matching <code>apicid</code>; we’ll<br>just panic if none of them match.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *<span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> apicid = lapicid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ncpu; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpus[i].apidid == apicid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;cpus[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;unknown apicid\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cpuid"><a href="#cpuid" class="headerlink" title="cpuid"></a>cpuid</h3><p>Those local interrupt controller IDs aren’t guaranteed to start from 0, so we’ll<br>need another way to identify CPUs. We can just use its entry number in the<br>global <code>cpus</code> array for that; <code>cpus</code> is an array of <code>struct cpu</code>s, which in C<br>means it’s really a pointer to the entry with index 0. <code>mycpu()</code> returns a<br>pointer to the entry for the current CPU, so we can just subtract those pointers<br>to get the index.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpuid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mycpu() - cpus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="myproc"><a href="#myproc" class="headerlink" title="myproc"></a>myproc</h3><p>This function returns a pointer to the <code>struct proc</code> running on this CPU. We’re<br>gonna call <code>mycpu()</code> here, so we’ll be good and remember to dsable interrupts<br>first with <code>pushcli()</code> and reenable them at the end with <code>popcli()</code>. Then we’ll<br>get the current process from the <code>struct cpu</code>‘s field.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc *<span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocproc"><a href="#allocproc" class="headerlink" title="allocproc"></a>allocproc</h3><p>Okay, we’re finally at the code to create a new process! Whew, it’s been a long<br>journey.</p>
<p>This is a <code>static</code> function, which means it can only be called by functions<br>defined in this same file. Creating a new process will require modifying the<br>process table, so we need to grab the lock so that other threads can’t mess with<br>it while we’re using it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to look through the table and find a slot that’s <code>UNUSED</code>; if we<br>find on, then great, we’ll assign that slot to the new process after the <code>found</code><br>label below. But if none of them are free, we’ll have to return a null pointer<br>to indicate that. You know what that means, right? Yup, we’re gonna have to add<br>null checks every time we call this function! Wooooo!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look through process table looking for an UNUSED slot</span></span><br><span class="line">    <span class="keyword">for</span> (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If none is found, return null pointer</span></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Check out that for loop too: <code>p</code> is a pointer to a <code>struct proc</code> that starts off<br>pointing to <code>ptable.proc</code>; that means it points to the entry and index 0. Then<br>it gets incremented by 1 each iteration; since it’s a <code>struct proc</code>, the pointer<br>arithmetic will work out so that it points to the next entry in the process<br>table.</p>
<p>Okay now let’s check out the <code>found</code> label and see what happens if we did find<br>an unused slot. First we set its state to <code>EMBRYO</code> (instead of <code>RUNNABLE</code>, since<br>we’re not done setting it up) and give it a PID. That state means it’s neither<br><code>UNUSED</code> nor <code>RUNNABLE</code>, so we can be confident that any other threads wouldn’t<br>try messing with it right now; they can’t allocate the slot to another process,<br>and they can’t try to run it yet. So we can stop hogging the process table now<br>and let other threads take a turn.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    p-&gt;state = EMBRYO;</span><br><span class="line">    p-&gt;pid = nextpid++;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to allocate a page for this process’s kernel thread to use as a<br>stack. Remember, <code>kalloc()</code> can return null, so we need a null check here.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;kstack = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;state = UNUSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we’re not gonna set up its page directory yet; that’ll happen in <code>fork()</code>,<br>which we’ll see later on. But we do need to set up the process so that it’ll<br>start executing code somewhere. It needs to start off in kernel mode, then it’ll<br>context-switch back into user mode and start running its code.</p>
<p>We haven’t looked at the mechanics of context switches yet, so I’ll spoil it a<br>little now (I know, I’m sorry). When a process is already running, it can send a<br>system call to ask for the kernel’s attention to do whatever it needs, like a<br>baby crying until it gets fed or changed or burped or whatever. Then it’ll<br>switch into kernel mode to run the system call, then switch back to where it<br>left off and pick up from there.</p>
<p>Well, xv6 is all about simplicity, right? And what’s more simple and elegant<br>than treating a special case (creating a new process and starting it off running<br>some code) the same as the general case (returning from a system call)? So xv6<br>will set up every new process to start off by “returning” from a (non-existent)<br>system call. That way the context switch code can be reused for new processes<br>too.</p>
<p>New processes are created via <code>fork()</code>, so we’ll return into a function called<br><code>forkret()</code>. Then that has to return into the function <code>trapret()</code>, which<br>closes out a <em>trap</em> (interrupt, system call, or exception) by restoring saved<br>registers and switching into user mode. We’ll get to <code>forkret()</code> and <code>trapret()</code><br>soon.</p>
<p>But first, the challenge: how do we “return” into a function that never called<br>us in the first place? We talked about function calls in x86 in the post on<br>spin-locks with the <code>getcallerpcs()</code> function, so make sure to read that now if<br>you need a refresher.</p>
<p>To summarize: when a function <code>f()</code> calls another function <code>g()</code>, it pushes the<br>arguments of <code>g()</code> on the top of its stack. Then it pushes a return address to<br>know where it should continue running the code of <code>f()</code> after <code>g()</code> returns;<br>that’s just the <code>%eip</code> register. Then it pushes the base address of the stack<br>for <code>f()</code>, i.e. the current <code>%ebp</code> register. That’s where <code>g()</code>‘s stack will<br>start off.</p>
<p>When the scheduler first runs the new process, it’ll check its context via<br><code>p-&gt;context</code> to get its register contents, including the instruction pointer<br><code>%eip</code>. So if we want it to start executing the code in <code>forkret()</code>, the <code>eip</code><br>field of its context should point to the beginning of <code>forkret()</code>. Then we can<br>trick it into thinking that the previous caller was <code>trapret()</code> by setting up<br>arguments and a return address in its stack.</p>
<p>Let’s start off by getting a pointer to the bottom of the stack. We had just<br>allocated a new stack page at <code>p-&gt;kstack</code>, but the stack grows from high to low<br>addresses, so the base of the stack is really at <code>p-&gt;kstack + KSTACKSIZE</code>. We’ll<br>make it a <code>char *</code> so we can move around one byte at a time using pointer<br>arithmetic.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> *sp = p-&gt;<span class="built_in">stack</span> + KSTACKSIZE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we should push any arguments for <code>trapret()</code> on the stack; it takes a<br><code>struct trapframe</code> (which we’ll go over later), so we’ll leave some room for it<br>and make the process point to it with <code>p-&gt;tf</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="keyword">sizeof</span>(*p-&gt;tf);</span><br><span class="line">    p-&gt;tf = (<span class="keyword">struct</span> trapframe *) sp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we add a “return address” to the beginning of <code>trapret()</code> after that.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="number">4</span>;</span><br><span class="line">    *((uint *) sp) = (uint) trapret;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last thing we need is to save some space for the process’s context on the<br>stack and point <code>p-&gt;context</code> to it. Then we’ll zero it all out, except for the<br><code>eip</code> field, which will point to the beginning of <code>forkret()</code>. And that’s it!<br>We just return the pointer to the process now.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="keyword">sizeof</span>(*p-&gt;context);</span><br><span class="line">    p-&gt;context = (<span class="keyword">struct</span> context *) sp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(*p-&gt;context));</span><br><span class="line">    p-&gt;context-&gt;eip = (uint) forkret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can create new processes now!</p>
<h3 id="growproc"><a href="#growproc" class="headerlink" title="growproc"></a>growproc</h3><p>What about growing or shrinking the size of a process’s address space? We<br>already did most of the hard work with <code>allocuvm()</code> and <code>deallocuvm()</code> from the<br>post on process paging, so let’s take a beat to thank past us for that.</p>
<p>Okay, so first we have to get the current process’s size.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    uint sz = curproc-&gt;sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Depending on the size of <code>n</code>, we’ll either grow the process or shrink it by <code>n</code><br>bytes. Both <code>allocuvm()</code> and <code>deallocuvm()</code> can fail and return zero, so let’s<br>add some checks for those and return -1 if they fail.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sz = allocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sz = deallocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curproc-&gt;sz = sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we need to tell the hardware that there’s a new page directory in town<br>with a different size than the old one, so we’ll use <code>switchuvm()</code> to update<br>the page directory and TSS stored by the hardware to reflect the changes. Then<br>we return 0 to indicate everything went okay.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    switchuvm(curproc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="procdump"><a href="#procdump" class="headerlink" title="procdump"></a>procdump</h3><p>This function is for debugging purposes: it’ll print a complete listing of any<br>processes in the process table. Quick spoiler: the keyboard interrupt handler<br>function will set things up so that pressing <code>^P</code> runs this function. Go ahead,<br>load up xv6 and try it out!</p>
<p>We want to print out the state for each process, but the states in <code>enum procstate</code> are just integers, which isn’t very debug-friendly. So let’s map them<br>all to strings first with a static array of strings.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *states[] = &#123;</span><br><span class="line">        [UNUSED]    <span class="string">&quot;unused&quot;</span>,</span><br><span class="line">        [EMBRYO]    <span class="string">&quot;embryo&quot;</span>,</span><br><span class="line">        [SLEEPING]  <span class="string">&quot;sleep &quot;</span>,</span><br><span class="line">        [RUNNABLE]  <span class="string">&quot;runble&quot;</span>,</span><br><span class="line">        [RUNNING]   <span class="string">&quot;run   &quot;</span>,</span><br><span class="line">        [ZOMBIE]    <span class="string">&quot;sombie&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This array notation might be a little unusual if you haven’t seen it before: C<br>lets you initialize arrays by specifying the value of each entry. If you leave<br>any entries out, then they’ll get initialized to zero. You can even write the<br>entries out of order by adding their index before them in square brackets. So<br><code>&#123; [1] 5, [0] 2 &#125;</code> is the same thing as <code>&#123;2, 5&#125;</code>. The <code>enum</code> turns the states<br>into integers, so they work as indices here.</p>
<p>Now we’ll just iterate over the process table to get all the processes, skipping<br>over any <code>UNUSED</code> ones.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll get the process’s state (or just use <code>&quot;???&quot;</code> if something went wrong<br>and the state isn’t recognized).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">char</span> *state;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state &gt;= <span class="number">0</span> &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state]) &#123;</span><br><span class="line">            state = states[p-&gt;state];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we can print out its PID, state, and name to the console.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        cprintf(<span class="string">&quot;%d %s %s&quot;</span>, p-&gt;pid, state, p-&gt;name);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll see later on that the <code>sleep()</code> and <code>wakeup()</code> system calls<br>involve some lock trickery, so sleeping processes could be a common cause of<br>concurrency issues like deadlocks. So if a process is sleeping, we’ll print out<br>its call stack using the <code>getcallerpcs()</code> function.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">            uint pc[<span class="number">10</span>];</span><br><span class="line">            getcallerpcs((uint *) p-&gt;context-&gt;ebp + <span class="number">2</span>, pc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; pc[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">                cprintf(<span class="string">&quot; %p&quot;</span>, pc[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h2><p>Whew, we’re making good progress. The most important part of this code was how<br>xv6 creates new processes and sets them up to start running: basically, it uses<br>some stack and function call trickery to make the scheduler start running a new<br>process with the code in <code>forkret()</code>, then <code>trapret()</code>, before switching context<br>into user mode.</p>
<p>We haven’t talked about those two functions yet; we’ll hold off on that until we<br>do traps and system calls. Next up is scheduling processes!</p>
<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><p>We’ve done a lot of talking about context switching and scheduling, but we’ve<br>procrastinated looking at the code for those. It’s time to fix that.</p>
<p>There are all kinds of advanced schedulers out there, but as we’ve said before,<br>the name of the game in xv6 is simplicity, so xv6 just uses a round-robin<br>scheduling algorithm in which in loops through the exisitng processes in order.<br>Each timer interrupt will force the current process to yield the processor and<br>perform a context switch back into the scheduler so it can run the next<br>available process.</p>
<h2 id="swtch-S"><a href="#swtch-S" class="headerlink" title="swtch.S"></a>swtch.S</h2><p>The <code>struct context</code> we talked about in the last post is gonna be key here, so<br>let’s just look at its fields again:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    uint edi;</span><br><span class="line">    uint esi;</span><br><span class="line">    uint ebx;</span><br><span class="line">    uint ebp;</span><br><span class="line">    uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The context switch function is <code>swtch()</code>; it’s gonna need to save and restore<br>processor registers, so that means it’s gonna have to be written in assembly.<br>But let’s pretend it’s just a C function for a second and talk about what it’s<br>going to do.</p>
<p>This function will save the contents of the registers on the stack as a <code>struct context</code>, then save that location as the old context. Then it’ll load a new<br>context, switch to the new stack, and restore the registers of the new context.<br>Its declaration would look like this in C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context **old, <span class="keyword">struct</span> context *new)</span>;</span><br></pre></td></tr></table></figure>
<p>The first argument is a pointer <em>to a pointer</em> to a <code>struct context</code>. That<br>double indirection might be confusing, but there’s a method to this madness: C<br>passes arguments by value, so if we used <code>struct context *old</code> and changed <code>old</code><br>to point to the saved context, it would be lost as soon as we returned from this<br>function. So instead we have to use this kind of double pointer so we can set<br><code>*old</code> to point to the saved context. This way <code>old</code> will be lost anyway, but<br><code>*old</code> was changed and will persist beyond this function’s return.</p>
<p>Note that, as we’ve said before, those arguments will be pushed on the stack<br>before <code>swtch()</code> is called. So at the beginning of <code>swtch()</code>, the stack pointer<br><code>%esp</code> points to a return address; the argument <code>old</code> is one space (4 bytes)<br>above that in the stack, and <code>new</code> is one space higher than that.</p>
<p>Okay, let’s check out the assembly code now. We’re gonna start by saving those<br>arguments into registers. We can’t just use any old registers here, or we might<br>overwrite some of the data we’re trying to save. But in the last post, I said<br>x86 has a convention that the caller has to save the contents of the <code>%eax</code>,<br><code>%ecx</code>, and <code>%edx</code> registers, so that means we’re free to overwrite them all we<br>want since they’ve already been saved.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">    movl    4(%esp), %eax</span><br><span class="line">    movl    8(%esp), %edx</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>
<p>We haven’t seen this number-parenthesis notation in assembly yet, so in case<br>you’re not familiar with x86 assembly, it’s just a way to add a number to the<br>contents of a register, then treating it as a pointer and dereferencing it. So<br><code>4(%esp)</code> in assembly is the same as <code>*(esp + 4)</code> in C. So at this point, <code>%eax</code><br>holds the <code>struct context **old</code> pointer, and <code>%edx</code> holds the<br><code>struct context *new</code> pointer.</p>
<p>Now it’s time to save all the fields in a <code>struct context</code> on the stack. The<br>stack grows from high addresses to low ones, but C <code>structs</code> expect their fields<br>to be from low to high, so we’ll save them in reverse order. Oh, and hang on –<br>remember what’s at the bottom of the stack right now, after the arguments?<br>That’s right, a return address. That’s just a saved <code>%eip</code>, so that one’s<br>already done for us! We just need to save the others.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    pushl   %ebp</span><br><span class="line">    pushl   %ebx</span><br><span class="line">    pushl   %esi</span><br><span class="line">    pushl   %edi</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Next we have to save a pointer to this old <code>struct context</code> into <code>*old</code>. Well,<br>we pushed them on the stack in reverse order, right? So <code>%esp</code> already <em>is</em><br>pointing to it, so that’s our pointer; we’ll just copy it into <code>*old</code> (remember<br>it’s stored in <code>%eax</code>, and we dereference it in assembly with parentheses).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    movl    %esp, (%eax)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Now it’s time to switch stacks to the <code>new</code> context, which we saved in <code>%edx</code>.<br>That context must have been saved by a previous call to <code>swtch()</code>, so it also<br>happens to be a stack pointer as well.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    movl    %edx, %esp</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>At this point, we’re using the stack from <code>new</code>, which will already have its<br>saved context at the top. So we can load the new context by popping it off the<br>stack in reverse order into the corresponding registers. And again, just like<br>the <code>call</code> instruction had already saved <code>%eip</code> on the stack as the return<br>address, the <code>ret</code> (return) instruction will pop it off and restore it into<br><code>%eip</code> for us.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    popl    %edi</span><br><span class="line">    popl    %esi</span><br><span class="line">    popl    %ebx</span><br><span class="line">    popl    %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>And that’s it! That’s a context switch in xv6.</p>
<h2 id="proc-c-1"><a href="#proc-c-1" class="headerlink" title="proc.c"></a>proc.c</h2><p>And now, finally, we can look at the scheduling code. Once the kernel is done<br>setting itself up, initializing all the devices and drivers, etc., the very last<br>function that <code>main()</code> calls is <code>scheduler()</code>. Interrupts were disabled in the<br>boot loader and haven’t been enabled yet, so it’s also the scheduler’s job to<br>enable them for the first time in xv6.</p>
<p><code>scheduler()</code> never returns; it’s an infinite loop that just keeps searching<br>through the process table for a <code>RUNNABLE</code> process, then runs it. So from that<br>point on, with the exception of interrupts and system calls, the kernel will<br>only ever do one thing: schedule processes to run.</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>A CPU that’s running the scheduler isn’t running its own process. So we’ll start<br>off by setting this CPU’s process pointer to null. Note that <code>mycpu()</code> requires<br>interrupts to be disabled before it’s called, but that’s okay here because<br>interrupts were disabled in the boot loader and haven’t been re-enabled before<br>the scheduler is called.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">    c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The order of the next few steps is tricky, and the authors of xv6 had to be<br>extremely careful to do them in the right order to avoid concurrency problems.<br>We need to (1) re-enable interrupts, (2) acquire the process table’s lock, and<br>(3) create an infinite loop to iterate over the process table forever, scheduling<br>processes along the way. To see why this is nontrivial, let’s check out some<br>different orders (with a <code>fake_scheduler()</code> function) and see what problems we<br>get.</p>
<p>ATTEMPT #1: interrupts -&gt; lock -&gt; loop. Let’s try it out.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fake_scheduler1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sti();                  <span class="comment">// enable interrupts</span></span><br><span class="line">    acquire(&amp;ptable.lock);  <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              <span class="comment">// infinite scheduling loop</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interrupts have been disabled since the boot loader used <code>cli</code>, so when we call<br><code>sti()</code> here they’ll be turned on for the first time in the kernel. At that<br>point we’ll find out if there were any interrupts waiting to be acknowledged,<br>and possibly jump into some handler function to take care of it. Then when<br>that’s done, we’ll come back here and acquire the process table’s lock. Acquiring<br>a lock disables interrupts, remember? So they’re disabled again in the infinite<br>scheduling loop (but not forever; we’ll release the lock before switching to a<br>user process). That sounds okay, right?</p>
<p>Not so fast! There’s a hidden problem: suppose we had a situation in which none<br>of the current processes are <code>RUNNABLE</code> – maybe they’re all blocked (or<br><code>SLEEPING</code>) waiting for I&#x2F;O or something, which is not unlikely. In that case,<br>the scheduler would just keep idly looping through the process table until one<br>of them becomes <code>RUNNABLE</code> again. But if interrupts are always disabled in the<br>loop, then this processor will never find out about, e.g., a disk interrupt<br>saying it’s done reading data which would allow a blocked process to become<br><code>RUNNABLE</code>. That means the process will never find out the condition it’s<br>waiting for has already happened, which means the scheduler will never find any<br><code>RUNNABLE</code> processes. It’ll just get stuck in an infinite loop, repeatedly and<br>desperately searching every entry of the process table. So basically, the<br>system would freeze while the CPU pointlessly spins at top speed.</p>
<p>Okay okay, so that doesn’t work. We’ll have to periodically re-enable interrupts<br>before disabling them again. So let’s try moving the call to <code>sti()</code> inside the<br>infinite loop so interrupts get re-enabled every once in a while.</p>
<p>ATTEMPT #2: lock -&gt; loop -&gt; interrupts.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fake_scheduler2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;ptable.lock);  <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              <span class="comment">// infinite scheduling loop</span></span><br><span class="line">        sti();              <span class="comment">// temporarily enable interrupts</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Problem solved, right? Actually… this one turns out to be just as bad. The<br>call to <code>acquire()</code> disables interrupts, only for <code>sti()</code> to enable them again.<br>There’s a reason that locks disable interrupts, remember? If an interrupt occurs<br>that switches away from <code>scheduler()</code>, then it might call a handler function<br>that needs to access the process table lock, which is already held by<br><code>scheduler()</code>, so that function would spin forever in a deadlock.</p>
<p>So now we arrive at the correct order: we’ll call <em>both</em> <code>sti()</code> and <code>acquire()</code><br>inside the loop, in that order. That means we’ll also need a call to <code>release()</code><br>at the end of the loop before we try to <code>acquire()</code> again in the next iteration.<br>We had already said we’d have to release the lock before running a process; now<br>we’ll have to acquire it again before context-switching back into the loop.</p>
<p>ATTEMPT #3 (the right one): loop -&gt; interrupts -&gt; lock. This will give us a<br>chance to detect any outstanding interrupts in each iteration of the for loop,<br>but before we’ve acquired the lock again and thus, before doing so could cause a<br>deadlock.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        sti();</span><br><span class="line">        acquire(&amp;ptable.lock);</span><br><span class="line">        <span class="comment">// ... pick a process and run it ...</span></span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Whew, okay. Basically, we’ve learned that concurrency bugs can be hard to predict<br>and can turn seemingly-fine code into impossible-to-diagnose system crashes or<br>freezes.</p>
<p>Okay, so now let’s fill in the part of the loop where the scheduling algorithm<br>goes. We’ll add an inner for loop to iterate over the process table entries<br>and stop when we find a <code>RUNNABLE</code> process.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state != RUNNABLE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... run that process ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, if we found a process, then we need to switch to that process’s virtual<br>address space; that is, we need to start using its page directory.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            c-&gt;proc = p;</span><br><span class="line">            switchuvm(p);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if we just switched to an arbitrary page directory in the middle of running<br>other code, we might cause a bunch of problems: all the virtual addresses we’re<br>currently using for variables, functions, instructions, etc. might suddenly<br>become invalid and point to random other places in memory. But this is where can<br>see some of the earlier design decisions in xv6 start to pay off: remember how<br><code>setupkvm()</code> made sure every single process would have the exact same mappings<br>for the upper half of the address space, starting at <code>KERNBASE</code>? That means that<br>if we’re running in kernel mode, we can arbitrarily switch to any process’s page<br>directory and know that all of our mappings will be exactly the same. The user<br>mappings in the lower half might be different, but the kernel side will never<br>change. Nice!</p>
<p>Now we can run the process using <code>swtch()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            p-&gt;state = RUNNING;</span><br><span class="line">            swtch(&amp;(c-&gt;scheduler), p-&gt;context);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swtch()</code> will <em>not</em> return here immediately; instead, it’ll pick up execution<br>wherever the process last left off, which will be in kernel mode – if it<br>stopped running before, it must have been due to a system call, interrupt, or<br>exception, which would have been handled in kernel mode before calling the<br>scheduler.</p>
<p>Note that this process will still be holding the process table lock when it<br>starts running again. For example, that’s the main reason for the existence of<br>the <code>forkret()</code> function we mentioned before. This is another dangerous detail<br>we’ll have to remember, so I’m just gonna go ahead and hope you remember THIS<br>BIG GIANT GLARING WARNING FLAG RIGHT HERE: if you do any xv6 kernel hacking, and<br>you want to add a new system call that will let go of the CPU, then your code<br><em>must</em> release the process table lock at the point at which it starts executing<br>after switching to it from the scheduler.</p>
<p>This is pretty dangerous; if xv6 were a big project, it would be really easy to<br>forget that when adding more features later on. But in this case, there’s no<br>easy way to get around it; for example, we can’t just release the process table<br>lock before calling <code>swtch()</code> and reacquire it after. The problem becomes<br>apparent if you think of locks as protecting some invariant; that invariant<br>might be temporarily violated while you hold the lock, but it should be restored<br>before the lock is released.</p>
<p>The process table protects invariants related to the process’s <code>p-&gt;state</code> and<br><code>p-&gt;context</code> fields, e.g. that the CPU registers must hold the process’s<br>register values, that a <code>RUNNABLE</code> process must be able to be run by any idle<br>CPU’s scheduler, etc. These don’t hold true while executing in <code>swtch()</code>, so we<br>need to hold the lock then; otherwise another CPU might decide to run the<br>process before <code>swtch()</code> is done executing.</p>
<p>Now, at some point that process will be done running and will give up the CPU<br>again. Before it switches back into the scheduler, it has to acquire the process<br>table lock again. So here’s ONE MORE GIANT WARNING for good measure: you should<br>make sure to do that too if you add your own scheduling-related system call.</p>
<p>Eventually, it’ll switch back here with a call with the arguments in reverse,<br>like <code>swtch(&amp;(p-&gt;context), c-&gt;scheduler)</code>. At the point, execution of the<br>scheduler will resume right here, so we need to switch back to using the kernel<br>page directory <code>kpgdir</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            switchkvm();</span><br><span class="line">            c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After that, the outer for loop just releases the lock before looping to the top<br>again to temporarily re-enable interrupts, then acquire the lock again and check<br>for another process to run.</p>
<h3 id="forkret"><a href="#forkret" class="headerlink" title="forkret"></a>forkret</h3><p>Let’s take a quick look at one example of where a process might start to execute<br>after being scheduled. All processes (whether the very first process, or any<br>others created later through calls to <code>fork()</code>) will start running code in<br><code>forkret()</code>, then return from here into <code>trapret()</code>.</p>
<p>Most of the time, this function does just one thing: it releases the process<br>table lock. However, there are two kernel initialization functions that have to<br>be run from user mode, so we can’t just call them from <code>main()</code> and be done with<br>it. We need a place for a process to call them, and <code>forkret()</code> is as good a<br>place as any. So the very first call to <code>forkret()</code> will run these two start-up<br>functions, and the rest will ignore them.</p>
<p>The two functions are <code>iinit()</code> and <code>initlog()</code>, which are part of xv6’s file<br>system code; we’ll get to them later on. For now, we’ll just use a <code>static int</code><br>as a boolean and set it to false after we’ve run those functions once on our<br>first pass through <code>forkret()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only gets run once, on the first call</span></span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        iinit(ROOTDEV);</span><br><span class="line">        initlog(ROOTDEV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Returns into `trapret()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Any other kernel code that switches into the scheduler (e.g., <code>sleep()</code> and<br><code>yield()</code>) will have a similar lock release right after returning from<br>the scheduler.</p>
<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>We saw one example of code that runs after switching <em>away</em> from the scheduler,<br>but what about code that runs before switching <em>to</em> the scheduler? Any functions<br>that need to call into the scheduler can’t just call <code>scheduler()</code>, since the<br>scheduler probably left off last time halfway through the loop and should resume<br>in the same place. So <code>sched()</code> handles the task of picking up the scheduler<br>wherever it last left off.</p>
<p><code>sched()</code> should be called <em>after</em> acquiring the process table lock and without<br>holding any other locks (lest we cause a deadlock somewhere). Also, the process<br>should not be in the <code>RUNNING</code> state anymore since we’re about to stop running<br>it. So we’ll start off by checking that those are all true and that interrupts<br>are disabled.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!holding(&amp;ptable.lock)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched ptable.lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli != <span class="number">1</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state == RUNNING) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, remember when the <code>pushcli()</code> and <code>popcli()</code> functions checked whether<br>interrupts were enabled before turning them off while holding a lock? That’s<br>really a property of this kernel thread, not of this CPU, so we need to save<br>that now. Then we can call <code>swtch()</code> to pick up where the scheduler left off<br>(the line right after its own call to <code>swtch()</code>). This process will resume<br>executing after that line eventually, at which point we’ll restore the data<br>about whether interrupts were enabled and let it run again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save whether interrupts were enabled before acquiring the lock</span></span><br><span class="line">    <span class="type">int</span> intena = mycpu()-&gt;intena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform context switch into the scheduler</span></span><br><span class="line">    swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler);</span><br><span class="line">    <span class="comment">// Execution will eventually resume here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore whether interrupts were enabled before</span></span><br><span class="line">    mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>Okay, let’s see an example of how this all comes together now! The <code>yield()</code><br>function forces a process to give up the CPU for one scheduling round. For<br>example, this will be used to handle timer interrupts later on. Now that we know<br>how scheduling works in xv6, <code>yield()</code> is easy. We just acquire the process<br>table lock, set the current process’s state to <code>RUNNABLE</code> so it can get picked<br>up again in the next scheduling round, and call <code>sched()</code> to switch into the<br>scheduler. When we eventually return here, we’ll just release the lock again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    myproc()-&gt;state = RUNNABLE;</span><br><span class="line">    sched();</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h2><p>We’ve now seen how xv6 handles process scheduling with a super-simple round-<br>robin algorithm. The <code>scheduler()</code> function had plenty of concurrency pitfalls,<br>but luckily the xv6 authors took care of all the careful coding for us, so we<br>just get to sit back and admire their work.</p>
<p>We also saw how context switches occur in xv6, so now we can understand how, in<br>the previous post, <code>allocproc()</code> set up a new process with a context that would<br>result in it starting execution in <code>forkret()</code>.</p>
<p>Next up, we’ll look at the way xv6 handles interrupts, system calls, and software<br>exceptions.</p>
<h1 id="It’s-a-Trap"><a href="#It’s-a-Trap" class="headerlink" title="It’s a Trap!"></a>It’s a Trap!</h1><p>The last post introduced the mechanisms that xv6 uses for scheduling and context<br>switches. User processes can transfer control to kernel code with system calls,<br>potentially switching into the scheduler with <code>sleep()</code> or <code>exit()</code> to find<br>another process to run. But there are many other system calls besides those two<br>Kernel code can also be invoked during hardware interrupts or software<br>exceptions; these three together are collectively referred to as traps.</p>
<p>We’ll go over traps now to understand them more generally. First, about the<br>terminology: depending on the source, interrupts might mean hardware interrupts<br>specifically or any trap generally; similarly, exceptions might mean errors<br>arising from the code, or traps in general. It’s super frustrating because it<br>makes it really hard to know what’s meant by a word like “interrupt” or<br>“exception” in whatever specification or source you happen to be reading. So I’m<br>gonna try my best to save you that kind of pain in this post by sticking to<br>“interrupt” for the hardware interrupts only, “exception” for software errors,<br>and “trap” for those two combined with system calls.</p>
<h2 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h2><p>Imagine if, after every single time some user code carried out a division, the<br>processor stopped, context switched into the kernel, and asked the kernel to<br>check if there was a division by zero and handle it if necessary. Or every time<br>a hardware interrupt happened, the kernel had to start polling all the devices<br>to figure out which one just yelled. No. Just no. Running kernel code for all<br>this would be way too slow.</p>
<p>So it’s the processor that will have to detect traps and decide how to handle<br>them. But what exactly it should do for a specific trap depends on all kinds of<br>of particulars about that OS, e.g. a disk saying it’s done reading from a file<br>might require updating some file system data or storing the disk data in a<br>specific buffer or something. That’s too much responsibility for the processor.</p>
<p>Okay, so the kernel will set up a bunch of handler functions for every possible<br>type of trap. Then it tells the hardware, “Okay, so if you get a disk interrupt,<br>here are my instructions to handle that. For timer interrupts, use these<br>instructions. If a process tries to access an invalid page, do this…”<br>From then on, the processor can handle the traps without further input from the<br>kernel by looking up the interrupt number in a big table to get the trap handler<br>function that the kernel set up, then just running it.</p>
<p>In the x86 architecture, that table is called the <em>interrupt descriptor table</em><br>or IDT. I know, I’m sorry, I promised I’d say “trap” for the general case, but<br>the x86 specs give it the official name of IDT even though it handles all the<br>traps. Sigh. It has 256 entries (so that’s the maximum number of distinct traps<br>we can define); each one specifies a segment descriptor (ugh segmentation again,<br>you know what that means: opaque code) and an instruction pointer (<code>%eip</code>) that<br>tell the processor where it can find the corresponding trap handler<br>function.</p>
<p>xv6 won’t use all 256 entries; it’ll mostly use trap numbers 0-31 (software<br>exceptions), 32-63 (hardware interrupts), and 64 (system calls), all defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/traps.h">traps.h</a>.<br>But we do have to stick all 256 in the IDT anway, so we’re the unlucky fools who<br>get to write 256 functions’ worth of assembly code by hand. Nah, just kidding:<br>xv6 uses a script in a high-level language to do that for us and spit out the<br>entries into an assembly file.</p>
<p>Unfortunately for us, that high-level language is Perl. Sigh. Perl is infamous<br>as a “write-only” language, so I guess instead we’re just the unlucky fools who<br>get to try reading Perl.</p>
<h2 id="vectors-pl"><a href="#vectors-pl" class="headerlink" title="vectors.pl"></a>vectors.pl</h2><p>Okay, I’m not gonna assume you know Perl, and either way I really don’t wanna go<br>over every single line of this file. The syntax is similar enough to C’s (except<br>that somehow they managed to make it even <em>worse</em> than C), so you can read it on<br>your own if you want.</p>
<p>Now, no script will be able to generate 256 completely unique assembly functions<br>with enough detail to handle each trap correctly, so each function in the script<br>has to be pretty generic. They’re all gonna call the same assembly helper<br>function, which will call a C function where we can more comfortably code up<br>how to handle each interrupt.</p>
<p>The gist of this Perl script is that it prints a bunch of stuff using a for loop<br>with 256 iterations. The xv6<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a><br>will run it from the command line with <code>./vectors.pl &gt; vectors.S</code> so that the<br>output gets saved in an assembly file, which will then get assembled together<br>with all the other kernel code in <code>OBJS</code>.</p>
<p>The resulting assembly file will look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line"></span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $0</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line">.globl vector1</span><br><span class="line">vector1:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $1</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line">.globl vector2</span><br><span class="line">vector2:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $2</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Except that a handful of entries (8, 10 through 14, and 17) will skip one line<br>(I’ll explain why below):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.globl vector8</span><br><span class="line">vector8:</span><br><span class="line">    pushl   $8</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Then at the end, it defines an array <code>vectors</code> with each of those entries above:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.globl vectors</span><br><span class="line"></span><br><span class="line">vectors:</span><br><span class="line">    .long vector0</span><br><span class="line">    .long vector1</span><br><span class="line">    .long vector2</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Okay, so those are all the handler functions; the <code>vectors</code> array holds a<br>pointer to each one. They’re all more or less the same: most of them push zero<br>onto the stack, then all they push a <em>trap number</em> to indicate which trap<br>just happened, and then they jump to a point in the code called <code>alltraps</code>;<br>that’s the assembly helper function I mentioned earlier.</p>
<p>A handful of the entries don’t push zero on the stack: these are trap numbers<br>8 (a double fault, which happens when the processor encounters an error while<br>handling another trap), 10 (an invalid task state segment), 11 (segment<br>not present), 12 (a stack exception), 13 (a general protection fault), 14 (a<br>page fault), and 17 (an alignment check). These are special because the<br>processor will actually push an error code on the stack before calling into the<br>corresponding handler function in <code>vectors</code>. It doesn’t push any error codes on<br>the stack for the others, so we just push 0 ourselves to make them all match up.</p>
<h2 id="trapasm-S"><a href="#trapasm-S" class="headerlink" title="trapasm.S"></a>trapasm.S</h2><h3 id="alltraps"><a href="#alltraps" class="headerlink" title="alltraps"></a>alltraps</h3><p>The processor needs to run the trap handler in kernel mode, which means we have<br>to save some state for the process that’s currently running so we can return to<br>it later (similar to the <code>struct context</code> we saw before), then set things up to<br>run in kernel mode. The <code>alltraps</code> routine does just that.</p>
<p>Remember how we said the IDT holds segment selectors for <code>%cs</code> and <code>%ss</code>, plus<br>and instruction pointer <code>%eip</code>? (I know we haven’t seen the code to create the<br>IDT and store the entries of <code>vectors</code> in it yet; we’ll get to that below.) The<br>processor will start using those segments (and save the old ones) before running<br>the trap handler function. Each trap handler function in <code>vectors</code> above pushed<br>an error code (or 0) followed by a trap number. Now we have to push all the<br>other segment selectors on the stack one at a time, then push all the general-<br>purpose registers at once with the x86 instruction <code>pushal</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line">alltraps:</span><br><span class="line">    pushl   %ds</span><br><span class="line">    pushl   %es</span><br><span class="line">    pushl   %fs</span><br><span class="line">    pushl   %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Cool, all the registers are saved now. So now we’ll set up the <code>%ds</code> and <code>%es</code><br>registers for kernel mode (<code>%cs</code> and <code>%ss</code> were already done by the processor).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">movw    $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class="line">movw    %ax, %ds</span><br><span class="line">movw    %ax, %es</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Now we’re ready to call the C function <code>trap()</code> that’s gonna do most of the<br>work. That function expects a single argument: a pointer to the process’s saved<br>register contents. Well, we just pushed them all on the stack, so we can just<br>use <code>%esp</code> as that pointer.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">pushl   %esp</span><br><span class="line">call    trap</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>That function will return back here when it’s done, so let’s ignore the return<br>value by moving the stack pointer just above it (essentially popping it off the<br>stack).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">addl    $4, %esp</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<h3 id="trapret"><a href="#trapret" class="headerlink" title="trapret"></a>trapret</h3><p>We’ve talked about this function before; when we create a new process, it starts<br>executing in <code>forkret()</code>, which then returns into <code>trapret()</code>. More generally,<br>any call to <code>trap()</code> will return here as well.</p>
<p>This function just restores everything back to where it was before, popping<br>stored registers off the stack in reverse order. We can skip the trap number and<br>error code; we won’t need them anymore. Then we use the <code>iret</code> or “interrupt<br>return” (though you should read that as “trap return”) instruction to close out,<br>return to user mode, and start executing the process’s instructions again.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl trapret</span><br><span class="line">trapret:</span><br><span class="line">    popal</span><br><span class="line">    popl    %gs</span><br><span class="line">    popl    %fs</span><br><span class="line">    popl    %es</span><br><span class="line">    popl    %ds</span><br><span class="line">    addl    $0x8, %esp  # skip the trap number and error code</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>

<h2 id="trap-c"><a href="#trap-c" class="headerlink" title="trap.c"></a>trap.c</h2><p>Okay, on to the main part of the code! We have to do two things here: stick the<br>trap handler functions in <code>vectors</code> into an IDT, and figure out what to do with<br>each interrupt type.</p>
<p>At the top, we’ve got four global variables. The IDT is represented as an array<br>of <code>struct gatedesc</code>s, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>. It’s worth<br>taking a look at because it uses an obscure C feature (bit fields); we’ll do that<br>in the next section.</p>
<p>Then we declare the <code>vectors</code> array of trap handler (with an <code>extern</code> keyword,<br>since it’s defined in an assembly file), a global counter <code>ticks</code> that tracks<br>the number of timer interrupts so far (basically a rough timer), and a lock to<br>use with <code>ticks</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256];</span></span><br><span class="line"><span class="keyword">extern</span> uint vectors[];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">tickslock</span>;</span></span><br><span class="line">uint ticks;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="Bit-Fields"><a href="#Bit-Fields" class="headerlink" title="Bit Fields"></a>Bit Fields</h3><p>This section will get <em>deep</em> into the weeds, so feel free to skip it if you’re<br>having a nice day and don’t want to spoil it by reading about a bunch of C<br>standards.</p>
<p>So far, we’ve used bit flags with regular integers by manually doing some bit<br>arithmetic to set one bit at a time. For example, the flags for page table and<br>page directory entries are defined as powers of 2 (e.g., <code>PTE_P</code> is 0x1, <code>PTE_W</code><br>is 0x2, <code>PTE_U</code> is 0x4, etc.) so that we can set a specific bit using a bitwise-<br>OR like <code>pte |= PTE_U</code> or test whether it’s set with a bitwise-AND like<br><code>pte &amp; PTE_P</code>.</p>
<p>But sometimes that can get annoying and hard to keep track of; wouldn’t it be<br>nice if we could just have variables that represent a single bit? Or two bits,<br>or any number of bits we want?</p>
<p>The trouble is that most computer architectures don’t work with a single bit at<br>a time; they operate on bytes, words (2 bytes), long&#x2F;double words (4 bytes), or<br>quad words (8 bytes), so it would be nontrivial to compile a line of C like<br><code>a = 1</code> if <code>a</code> is a nonstandard size.</p>
<p>In fact, accessing variables that aren’t aligned to a standard size (4 bytes on<br>x86 or 8 bytes on x86_64) is much slower than when they are aligned. Compilers<br>often optimize code to correct for this by padding <code>struct</code>s so that they’ll<br>line up along those standard sizes. For example, one like</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nopadding</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>is probably left the same on x86, but one like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>is probably converted by the compiler into this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> pad0[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">char</span> pad1[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>WARNING: We’re entering the dark arts of C’s unspecified and implementation-<br>defined behavior here. Note that these are different from <em>undefined</em> behavior:<br>undefined behavior means you did something BAD BAD BAD like dereferencing a null<br>pointer, freeing a memory region twice, using a variable after freeing it,<br>accessing an out-of-bounds index in a buffer, or overflowing a signed data type.<br>Implementation-defined and unspecified behavior aren’t as dangerous as undefined<br>behavior is, but they can cause portability issues.</p>
<p>The C standard is a huge document with a bunch of legalese rules about what<br>makes C, well, C. People who write C compilers need to know exactly how C code<br>should behave under all kinds of different circumstances, so the C standard<br>spells most of it out. But there are some parts it intentionally leaves out.</p>
<p><em>Implementation-defined</em> behavior means the C standard doesn’t set any fixed<br>requirements about how a compiler should handle some behavior or feature; the<br>developers of a C compiler get to decide how to write that part of the code with<br>total freedom. One example is the number of bits in a byte; we’ve been assuming<br>it’s 8, but there are some (dumb) architectures where it’s different.</p>
<p><em>Unspecified behavior</em>, on the other hand, means that the C Standard provides<br>some specific options, and compiler developers have to choose from those options<br>for <em>each instance</em> of the behavior in the code they’re compiling (that means,<br>don’t assume it’s always gonna be the same, even with the same compiler).</p>
<p>Structure padding is implementation-defined, and there are often implementation-<br>defined ways to modify it or disable it altogether (i.e., to <em>pack</em> the <code>struct</code><br>instead of <em>padding</em> it), usually with stuff like <code>__attribute__</code>s or <code>#pragma</code><br>directives for the preprocessor.</p>
<p>Wait weren’t we gonna talk about bit manipulation? Why are we talking about<br><code>struct</code>s? Well, C does have a workaround to make bit manipulation a little<br>easier by avoiding that slightly-annoying bit arithmetic you have to do to set<br>or clear flags in an <code>int</code> or <code>unsigned int</code>: it’s called a <em>bit field</em>, and it<br>takes advantage of <code>struct</code> padding.</p>
<p>You can specify the number of bits that a field of a <code>struct</code> should occupy by<br>adding a colon and a size after the field name:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfield_example</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This way, you can set the single-bit flag <code>a</code> with simple variable assignments<br>like <code>var.a = 1</code>, and the compiler will figure out any necessary magic similar<br>to structure padding to make that happen. Awesome, right? So why haven’t we been<br>using it all the time instead of all that opaque bit arithmetic with arcane<br>operators like <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>|</code>, and <code>&amp;</code>?</p>
<p>Well, there are some big downsides to bit fields. First, the C standard sets<br>some strict rules on their use to make sure that compilers can figure out how to<br>handle them. Bit fields are only allowed inside of structures. You’re not<br>allowed to create arrays of bit fields or pointers to bit fields. Functions<br>aren’t allowed to return a bit field. You’re not allowed to get the address of a<br>bit field with the <code>&amp;</code> operator. You can only operate on a single bit field at a<br>time in any statement; that means you can’t set one bit field to equal another,<br>and you can’t compare the values of two bit fields.</p>
<p>Second, they’re <em>extremely</em> implementation-defined. Each implementation (read:<br>compiler + architecture combo) determines what data types and sizes are allowed<br>to be used in bit fields. The data types you <em>can</em> use might have different<br>signedness rules from the usual ones for signed and unsigned types. How they’re<br>laid out, ordered, and padded in memory can differ. In short: the low-level<br>details are a total black box that you can probably only figure out by reading<br><em>deep</em> into the compiler’s specifications.</p>
<p>Now imagine trying to do something that requires specific protocols like sending<br>data over a network, and you come across a bit field. Lolwut. Who knows what<br>you’d have to do. Bit fields make it impossible to port your code.</p>
<p>BUT! Bit arithmetic is annoying, so let’s use bit fields anyway!</p>
<p>Okay, so back to <code>struct gatedesc</code>. IDT entries have to contain a 16-bit code<br>segment selector (<code>%cs</code>), 16 low bits and 16 high bits for an offset in that<br>segment, the number of arguments for the handler function, a type, a system&#x2F;<br>application flag, a descriptor privilege level (0 for kernel, 3 for user), and a<br>“present” flag. And x86 is very particular about how it’s all laid out, so we<br>have to set up <code>struct gatedesc</code> in the exact right order.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    uint off_15_0 : <span class="number">16</span>;</span><br><span class="line">    uint cs : <span class="number">16</span>;</span><br><span class="line">    uint args : <span class="number">5</span>;</span><br><span class="line">    uint rsv1 : <span class="number">3</span>;</span><br><span class="line">    uint type : <span class="number">4</span>;</span><br><span class="line">    uint s : <span class="number">1</span>;</span><br><span class="line">    uint dpl : <span class="number">2</span>;</span><br><span class="line">    uint p : <span class="number">1</span>;</span><br><span class="line">    uint off_31_16 : <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Well, okay, that’s it for now.</p>
<h3 id="tvinit"><a href="#tvinit" class="headerlink" title="tvinit"></a>tvinit</h3><p>This function loads all the assembly trap handler functions in <code>vectors</code> into<br>the IDT. The <code>SETGATE()</code> macro in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> will organize<br>each entry correctly. We said before that the IDT needs a code segment selector,<br>an instruction pointer (from <code>vectors</code>), and a privilege level (0 for kernel<br>mode), so we’ll stick those in.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, SEG_KCODE &lt;&lt; <span class="number">3</span>, vectors[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re basically done now, but there’s one last hiccup: user code needs to be<br>able to generate system calls, but we just set all the privilege levels so only<br>the kernel and processor can generate traps. So we’ll fix the entry for system<br>calls as a special case.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, SEG_KCODE &lt;&lt; <span class="number">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oh and while we’re at it, let’s just go ahead and initialize the lock for the<br>tick counter.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="idtinit"><a href="#idtinit" class="headerlink" title="idtinit"></a>idtinit</h3><p>The last function stored all the trap vectors in the IDT, so now we need to tell<br>the processor where to find the IDT. There’s a special assembly instruction for<br>that in x86 called <code>lidt</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idtinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lidt(idt, <span class="keyword">sizeof</span>(idt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h3><p>This last function is the one that gets called by the assembly code in <code>alltraps</code>;<br>it’s responsible for figuring out what to do based on the trap number we pushed<br>on the stack before. Heads up: it’s gonna do that by calling a bunch of other<br>functions, many of which we haven’t seen yet. I’ll just give a quick summary<br>when we come across them, and we’ll get to them later on.</p>
<p>The only argument is a pointer to a <code>struct trapframe</code>. Wait, hang on. Up above<br>in the assembly code, the argument we pushed on the stack was <code>%esp</code>, the stack<br>pointer, not a pointer to any <code>struct trapframe</code>. What’s up with that? Did we<br>pass the wrong kind of argument in?</p>
<p>Let’s check out the definition for <code>struct trapframe</code>, found in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>. It’s got a<br>bunch of fields, starting off with the general purpose registers (those are the<br>fields from <code>%edi</code> to <code>%eax</code>). Then it has four segment registers (fields <code>%gs</code><br>through <code>%ds</code>), plus some unused padding bits in between them to round the 16-<br>bit segment registers up to 32 bits. The next two fields are a trap number and<br>an error code.</p>
<p>All that should sound familiar. Take another look at<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/trapasm.S">trapasm.S</a>: so<br>far, those are the exact same things we pushed on the stack! The other fields<br>are what the processor pushed on the stack before calling the handler function<br>in the IDT. So basically, we’re never gonna construct a <code>struct trapframe</code> in C<br>code; we already constructed it manually in assembly. It just describes<br>everything that’s already on the stack by the time this <code>trap()</code> function gets<br>called. In that sense, the <code>%esp</code> we pushed as an argument really <em>is</em> a pointer<br>to a <code>struct trapframe</code>. It’s a clever way to read values off the stack.</p>
<p>So we said we’re gonna check the trap number and decide which kernel function to<br>call based on that, right? Let’s start by checking if the trap number indicates<br>this is a system call (trap number 64, or <code>T_SYSCALL</code>).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;trapno == T_SYSCALL) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Well how should we handle system calls? xv6 will have several, and we don’t even<br>know what they all are yet. So let’s procrastinate again and just call some<br>other function <code>syscall()</code> to handle the work of figuring out which system call<br>to execute. Now we’ll store the pointer to the <code>struct trapframe</code> in that<br>process’s <code>struct proc</code>, obtained with a call to <code>myproc()</code>. Also, processes<br>need to be killed once they’re done, or if they cause an exception; that happens<br>by setting a <code>killed</code> flag in the <code>struct proc</code>. So we’ll check for that before<br>and after carrying out the system call and close the process out with <code>exit()</code><br>if it’s due to be killed.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;trapno == T_SYSCALL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        myproc()-&gt;tf = tf;</span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now we have all the other trap numbers to think about. We could do them<br>with a ton of <code>if</code> statements, but that would be a pain; we’ll use a <code>switch</code><br>statement instead. If you haven’t seen <code>switch</code> statements, they replace big<br><code>if-else</code> blocks with cases instead. The cases can only be indexed by integers,<br>and you have to stick a <code>break</code> statement at the end or else you’ll fall through<br>to the next case and execute the code found there as well. (To be honest, I<br>don’t see a reason why the system call case wasn’t just included in this same<br>switch statement; if you see a reason for that, let me know.)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// cases go here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First up is the trap number for timer interrupts; the main function of timer<br>interrupts is to schedule a new process, but that will come further down in this<br>function. For now, we’ll just increment the <code>ticks</code> counter then call <code>wakeup()</code>,<br>which checks if any processes went to sleep until the next tick; it’ll switch to<br>running any process it finds. There’s one detail to deal with here: the system<br>may have multiple processors, each with their own timer and interrupts. We want<br>to use the <code>ticks</code> counter as a rough timer, but we don’t know whether all the<br>CPU timers will be synchronized, so we’ll only update <code>ticks</code> using the first<br>CPU to avoid those issues.</p>
<p>If you read the post on interrupt controllers then you’ll be familiar with<br><code>lapiceoi()</code>; if you didn’t (or you forgot), it just tells the local interrupt<br>controller that we’ve read and acknowledged the current interrupt so it can<br>clear it and get ready for more interrupts.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">            <span class="keyword">if</span> (cpuid() == <span class="number">0</span>) &#123;</span><br><span class="line">                acquire(&amp;tickslock);</span><br><span class="line">                ticks++;</span><br><span class="line">                wakeup(&amp;ticks);</span><br><span class="line">                release(&amp;tickslock);</span><br><span class="line">            &#125;</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Later on, we’ll see some interrupt handler functions for various devices:<br><code>ideintr()</code> handles disk interrupts, <code>kbdintr()</code> for key presses and releases,<br>and <code>uartintr()</code> for serial port data. We’ll direct the corresponding interrupts<br>to those functions, then acknowledge and clear them with <code>lapiceoi()</code>. Also,<br>devices occasionally generate spurious interrupts due to hardware malfunctions;<br>we’ll either ignore them (if they’re coming from the Bochs emulator) or print a<br>message about it to the console.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_IDE:      <span class="comment">// disk interrupt</span></span><br><span class="line">            ideintr();</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_IDE + <span class="number">1</span>:  <span class="comment">// spurious Bochs disk interrupt</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_KBD:      <span class="comment">// keyboard interrupt</span></span><br><span class="line">            kbdintr();</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ + <span class="number">7</span>:             <span class="comment">// spurious interrupt-no break, FALL THROUGH</span></span><br><span class="line">        <span class="keyword">case</span> T_IRQ + IRQ_SPURIOUS:  <span class="comment">// spurious interrupt</span></span><br><span class="line">            cprintf(<span class="string">&quot;cpu%d: spurious interrupt at %x:%x\n&quot;</span>,</span><br><span class="line">                    cpuid(), tf-&gt;cs, tf-&gt;eip);</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now we’ve dealt with system calls and hardware interrupts, so any other<br>trap must be a software exception. <code>switch</code> statements allow a catch-all case<br>with <code>default</code>, so we’ll use that to catch the rest of the trap numbers. Now,<br>this may have come from a kernel error or a misbehaving user process. We can<br>check with <code>myproc()</code>, which returns a null pointer if we were running kernel<br>code or a pointer to a <code>struct proc</code> if we were in user space, or by checking<br>the current privilege level in the code segment selector. Depending on the<br>source, we’ll print out an appropriate error message and either panic (if in the<br>kernel) or mark the process so it gets killed soon.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (myproc() == <span class="number">0</span> || (tf-&gt;cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Kernel code exception</span></span><br><span class="line">                cprintf(<span class="string">&quot;unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n&quot;</span>,</span><br><span class="line">                        tf-&gt;trapno, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">                panic(<span class="string">&quot;trap&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// User process exception</span></span><br><span class="line">            cprintf(<span class="string">&quot;pid %d %s: trap %d err %d on cpu %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;eip 0x%x addr 0x%x--kill proc\n&quot;</span>,</span><br><span class="line">                    myproc()-&gt;pid, myproc()-&gt;name, tf-&gt;trapno,</span><br><span class="line">                    tf-&gt;err, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">            myproc()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The reason we don’t kill it immediately is because the process might be executing<br>some kernel code right now; for example, system calls allow other interrupts and<br>exceptions to occur while they’re being handled. Killing it now might corrupt<br>whatever it’s doing. So instead we just give it the kiss of death for now and<br>come back to finish the job later.</p>
<p>So next up, we’ll check if this trap was generated by a user process that’s due<br>to be killed, and that process is running in ring 3. If so, we finally do<br>the deed with <code>exit()</code>; otherwise if it’s running in ring 0, it’ll live for now<br>and get killed the next time it generates a trap instead.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;killed &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == DPL_USER) &#123;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Up above, the only thing a timer interrupt did was increment <code>ticks</code>. But we<br>know a really important function of timer interrupts is to force a process to<br>let go of the CPU and let someone else run. It’s time to do that. We’ll check if<br>the process’s state is <code>RUNNING</code> and the trap was a timer interrupt; if so, we<br>call <code>yield()</code> to let another process get scheduled on this CPU.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;state == RUNNING &amp;&amp;</span><br><span class="line">            tf-&gt;trapno == T_IRQ0 + IRQ_TIMER) &#123;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have one last check: a process that yielded, then got picked up again<br>later might have been marked as killed in the meantime, so if it was, we need to<br>finish it off now. So we do the exact same check as above again, and then we’re<br>done.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;killed &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == DPL_USER) &#123;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that this function will return into <code>trapret</code> in the assembly code, which<br>will then send it back to user mode.</p>
<h2 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h2><p>Let’s take a moment to assess how much of xv6 we’ve already covered. Remember,<br>the xv6 kernel has four main functions: (1) finishing the boot process that the<br>boot loader started, (2) virtualizing resources in order to isolate processes<br>from each other, (3) scheduling processes to run, and (4) interfacing<br>between user processes and hardware devices. Let’s take that as a checklist and<br>go through those items now.</p>
<p>We’ve already seen some of the initialization routines that get run on boot in<br><code>main()</code>; most of the code there sets up virtual memory and all the hardware<br>devices. We still have a few more devices to talk about: the keyboard, serial<br>port, console, and disk; each of those has its own boot function that we’ll need<br>to go over in order to wrap up point (1).</p>
<p>On the other hand, we’re already done with (2) and (3): we spent a lot of time<br>going over virtual memory and paging, and the last post on scheduling showed us<br>how xv6 virtualizes the CPU as well as it runs processes.</p>
<p>The code we saw in this post was our introduction to point (4). Traps are the<br>primary mechanism for user processes to communicate with the hardware; the<br>kernel coordinates that communication by setting up trap handler functions. The<br>code we’ve seen here basically acts like an usher, directing traps to the<br>right trap handler function depending on its type.</p>
<p>When a trap occurs (x86 instruction <code>int</code>), the processor will stop executing<br>code, find the IDT, and looks up the entry for that trap number. The script that<br>xv6 uses to generate the IDT entries just makes them all point to the same<br>function <code>alltraps()</code>, which saves all the process’s registers, switches into<br>kernel mode, and calls <code>trap()</code>. Then that function uses the trap number to<br>figure out how the kernel wants it to respond to this particular trap. So any<br>hardware interrupt, software exception, or user system call will get funneled<br>into the functions here before getting dispatched to some other appropriate<br>kernel code that will know what to do with it.</p>
<p>We haven’t finished point (4) yet, though: we have to actually see what each of<br>those trap handler functions does. But we did see some of them: for example, we<br>saw that a software exception either kills the process that caused it or panics<br>if it occurred in kernel code. That already takes care of one of the three types<br>of traps, so we’re left with hardware interrupts and system calls. All the<br>system calls got redirected to a <code>syscall()</code> function which we haven’t seen yet.</p>
<p>We have seen how some of the hardware interrupts are dealt with: a timer<br>interrupt increments a <code>ticks</code> counter (if it’s on CPU 0), then calls <code>yield()</code><br>to force a process to give up the CPU until the next scheduling round. Spurious<br>interrupts either get ignored or print a message to the console. But we’ve<br>procrastinated some of the others: disk interrupts call an <code>ideintr()</code> function<br>to handle them, keyboard interrupts call <code>kdbintr()</code>, and serial port interrupts<br>call <code>uartintr()</code>, none of which we’ve gone over.</p>
<p>So in order to wrap up the xv6 kernel, we still have to understand how system<br>calls are routed in general, as well as how devices are initialized at boot and<br>how the kernel responds to specific system calls that require use of those<br>devices. The general system call routing mechanism is up next.</p>
<h1 id="System-Calls-Routing"><a href="#System-Calls-Routing" class="headerlink" title="System Calls: Routing"></a>System Calls: Routing</h1><p>We said in the last post that system calls are the primary means for user<br>processes to request some action by the kernel; system calls mediate processes’<br>access to hardware resources.</p>
<p>If a user process wants to generate a system call, it starts a trap with the<br>trap number for system calls. Then it identifies which of the various xv6 system<br>calls it wants to do and passes any required arguments. The processor will then<br>handle the trap instruction using the code we saw in the last post. Eventually,<br>it’ll get to the <code>trap()</code> function, which will recognize the trap number as a<br>system call and pass it on to the <code>syscall()</code> function.</p>
<p><code>syscall()</code> is itself a routing function like <code>trap()</code>; it’ll figure out which<br>system call the process created and redirect it again to the appropriate kernel<br>code.</p>
<h2 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h2><p>All system calls use the same trap number: 64, or <code>T_SYSCALL</code>, but xv6 has<br>multiple system calls, so we need another number for a process to identify which<br>system call it wants to run. The convention on x86 is to use a system call<br>number which the calling process should put in the <code>%eax</code> register, which<br>usually holds return values. Then the kernel’s handler function (here,<br><code>syscall()</code>) can just check <code>%eax</code> to figure out which system call to run. The<br>system call numbers are defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/syscall.h">syscall.h</a>. There<br>you can see that, e.g. <code>SYS_fork</code> is defined as 1, <code>SYS_exit</code> is 2, and so on.</p>
<p>All the system call functions are defined in other files, so we’ll have to<br>import their declarations with the <code>extern</code> keyword:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Now we’ve got the numbers and the functions. Note that the numbers start with<br>uppercase <code>SYS_</code> and the functions start with lowercase <code>sys_</code>, so make sure<br>your kernel hacking adventures don’t do anything like <code>SYS_fork()</code>; use<br><code>sys_fork()</code> instead.</p>
<p>We’ll also need a way to map the numbers to those system call functions so that<br><code>syscall()</code> can call the right one depending on the number. We could use another<br><code>switch</code> statement like we did in <code>trap()</code>, but there are 21 system calls here,<br>so that would get pretty long; also, each number will just call the specific<br>function, unlike the different trap numbers which required different responses<br>(e.g., the timer interrupt trap number didn’t call any function at all). xv6<br>does something else this time that’s much simpler and more elegant, but it uses<br>some slightly-obscure C features, so we’ll go over it carefully.</p>
<p>Remember function pointers from way back in the boot loader? Functions are just<br>a set of instructions in order, loaded somewhere in the kernel’s code segment,<br>so C lets us use the function’s name as a pointer to the beginning of its code<br>in memory. So if we have a C function like <code>int func(char c)</code>, then <code>func</code> is<br>its function pointer. We could even assign it to a variable; that variable’s<br>type would be a pointer to a function of argument type <code>char</code> and return type<br><code>int</code>; then we could call the function using the new pointer too. Here’s an<br>example that would print “Match!” to the screen:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = func(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*func_ptr)(<span class="type">char</span>) = &amp;func;</span><br><span class="line"><span class="type">int</span> n = (*func_ptr)(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So instead of a big old <code>switch</code> statement, the <code>syscall()</code> function will use a<br>static, global array of pointers to all the system call functions we just<br>imported above. (Remember that the <code>static</code> keyword in front of a variable means<br>it always occupies the same fixed place in memory.) It’ll work because all the<br>functions have the same argument type (<code>void</code>) and return type (<code>int</code>), so their<br>pointers all have the same type and can fit inside a single array. Then we can<br>get the right function by just using the system call number to index into the<br>array of function pointers.</p>
<p>Now, we’d have to be super careful to add the function pointers into the array<br>in the right order so that the indices match up. Even worse, there is no system<br>call with number zero, so we’d have to skip that entry of the array. This could<br>get complicated. Luckily, even though humans are bad at this kind of thing,<br>computers are <em>really</em> good at it. So instead of trying to line them up by hand,<br>we can use the array notation from <code>procdump()</code> in the post on processes where<br>we specified the value of each entry of an array like this with the index in<br>square brackets, like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; [<span class="number">2</span>] <span class="number">5</span>, [<span class="number">0</span>] <span class="number">1</span>, [<span class="number">4</span>] <span class="number">-2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>The C compiler will use the indices we wrote there to figure out that the array<br>needs 5 entries (indices 0 to 4), and entry 0 is 1, entry 2 is 5, and entry 4 is<br>-2. Entries 1 and 3 will just be initialized to zero.</p>
<p>So at the end of the day, our array of pointers to system call functions looks<br>like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork]      sys_fork,</span><br><span class="line">    [SYS_exit]      sys_exit,</span><br><span class="line">    [SYS_wait]      sys_wait,</span><br><span class="line">    [SYS_pipe]      sys_pipe,</span><br><span class="line">    [SYS_read]      sys_read,</span><br><span class="line">    [SYS_kill]      sys_kill,</span><br><span class="line">    [SYS_exec]      sys_exec,</span><br><span class="line">    [SYS_fstat]     sys_fstat,</span><br><span class="line">    [SYS_chdir]     sys_chdir,</span><br><span class="line">    [SYS_dup]       sys_dup,</span><br><span class="line">    [SYS_getpid]    sys_getpid,</span><br><span class="line">    [SYS_sbrk]      sys_sbrk,</span><br><span class="line">    [SYS_sleep]     sys_sleep,</span><br><span class="line">    [SYS_uptime]    sys_uptime,</span><br><span class="line">    [SYS_open]      sys_open,</span><br><span class="line">    [SYS_write]     sys_write,</span><br><span class="line">    [SYS_mknod]     sys_mknod,</span><br><span class="line">    [SYS_unlink]    sys_unlink,</span><br><span class="line">    [SYS_link]      sys_link,</span><br><span class="line">    [SYS_mkdir]     sys_mkdir,</span><br><span class="line">    [SYS_close]     sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Okay great, now we’re ready to route system calls to the right function.</p>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>The first thing we need to do is get the system call number so we can figure out<br>which function to call. We said above that the x86 convention is to store it in<br>the <code>%eax</code> register, but we might have a problem: by the time we get to<br><code>syscall()</code>, the processor has already executed the code in the trap handler<br>function for trap number <code>T_SYSCALL</code>, which sent it to <code>alltraps()</code>, which<br>replaced all the register contents with those of <code>trap()</code>, so the system call<br>number is probably long gone from <code>%eax</code>.</p>
<p>But wait, all is not lost! <code>alltraps()</code> saved all the registers in a<br><code>struct trapframe</code> for the current process. So we can just read the value of<br><code>%eax</code> from there. Whew, that was some good forward-thinking.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> num = curproc-&gt;tf-&gt;eax;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we just need to do one more thing: call the function that corresponds to<br>that number. We’re gonna use the array of function pointers above, but we have<br>to be careful: this number was given to us by a user process. A malicious user<br>process might pass in an invalid number in the hopes of getting the kernel to<br>carry out some undefined behavior which might lead to an easy exploit. So in<br>order to keep up good security practices, the kernel should <em>always</em> distrust<br>anything originating from user code and handle it carefully, preferably with<br>three-inch-thick lead-lined gloves. So let’s think about it: what might go<br>wrong?</p>
<p>First of all, any entries that weren’t explicitly initialized above (including<br>the 0 entry) will have been automatically initialized to zero, i.e. a null<br>pointer. Also, a number that’s bigger than the highest system call number will<br>make us do an out-of-bounds read from the array, thus possibly executing some<br>arbitrary kernel code that’s stored after the array in memory. So we should<br>check that (1) the number is greater than 0, (2) it’s smaller than the number of<br>elements in the array, and (3) the entry it points to is not a null pointer.</p>
<p>Finally, the <code>%eax</code> register is usually used in x86 to store return values, so<br>we’ll put the return value of the system call function there. If any of the<br>above checks failed, we’ll just print a message to the console and return -1 to<br>indicate failure.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invalid system call number</span></span><br><span class="line">        cprintf(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>, curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">        curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The system call handler function will store its return value in <code>%eax</code>; after<br>that, <code>syscall()</code> will return to the line below where it was called in <code>trap()</code>.<br>After executing the rest of the code there, <code>trap()</code> will return into <code>trapret()</code>,<br>which ends with an <code>iret</code> (interrupt return) instruction to tell the processor<br>to switch to user mode and resume executing the process’s code.</p>
<h3 id="fetchint"><a href="#fetchint" class="headerlink" title="fetchint"></a>fetchint</h3><p>Take a look at the <code>sys_</code> functions we imported above: they all have argument<br>type <code>void</code>. But if you think about it, many system calls need an argument: for<br>example, <code>open()</code> needs to know which file to open, <code>chdir()</code> needs to know<br>which directory to open, <code>kill()</code> needs a PID to know which process to kill,<br>etc. So why did we make them all have argument type <code>void</code>?</p>
<p>The trouble is that until we get the system call number in <code>syscall()</code> above, we<br>have no way of knowing which function we’ll need. And each function takes<br>arguments with different types, e.g. <code>open()</code> might need a string for the file<br>to open but <code>kill()</code> might need an integer for the PID. So there’s no way for<br>the kernel to know which arguments to expect in <code>syscall()</code>, even though the<br>arguments were already pushed on the stack. The task of recovering the arguments<br>from the stack will have to fall to each of the <code>sys_</code> functions. But let’s go<br>ahead and make their lives a little easier by setting up some nice helper<br>functions now.</p>
<p>The system call functions might take integers, strings, or pointers, so we’ll<br>need functions to fetch each of those types. <code>fetchint()</code> is one example; it<br>takes a user virtual address (an integer argument’s location in memory) and a<br>pointer to an integer where we can store the integer we find. Then it returns 0<br>if it was able to find it, or -1 if it failed.</p>
<p>Just like <code>syscall()</code> above, we need to treat anything passed from user space<br>with extreme caution. A user process that tries to read or write memory outside<br>its address space will cause a segmentation fault or page fault and be killed,<br>but the kernel has free reign over memory, so a malicious process might try to<br>trick the kernel into doing that <em>for</em> it by putting its “argument” outside of<br>the user’s address space. So we have to start by checking that the entire 4<br>bytes of the integer is inside the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchint</span><span class="params">(uint addr, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt;= curproc-&gt;sz || addr + <span class="number">4</span> &gt; curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can just cast the address to a pointer, dereference it, and store the<br>value in <code>*ip</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchint</span><span class="params">(uint addr, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *ip = *(<span class="type">int</span> *)(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we can use an address like <code>addr</code> which will be in the lower half of<br>memory because traps don’t perform a full context switch, so we’re still using<br>the process’s page directory even though we’re in kernel mode (ring 0). If we<br>had switched to a kernel page directory, we’d have to call <code>walkpgdir()</code> or<br><code>uva2ka()</code> to figure out the corresponding kernel virtual address for <code>addr</code>.</p>
<p>Now hopefully, if you’ve taken anything away from my past rants about undefined<br>behavior in C, you noticed something wrong with this function. If you didn’t,<br>take another look; I’ll wait.</p>
<p>Did you see it? We’re dereferencing <code>addr</code> without checking that it’s not null,<br>so if the user passed in a null address, we’d dereference a null pointer! We<br>also dereference <code>ip</code> without a similar check, but at the very least <code>ip</code> is<br>passed in by the kernel.</p>
<p>This could be very dangerous – in general, it’s undefined behavior in C, but<br>now that we’ve seen the code for handling traps, we’re actually at a point where<br>we can figure out what would happen in xv6 if a null pointer gets dereferenced,<br>so let’s take the opportunity to think about it for a bit.</p>
<p>First, what would happen if the kernel dereferenced a null pointer? Well, if the<br>kernel is currently using <code>kpgdir</code> as a page directory, the address 0 isn’t<br>mapped to anything, so when the paging hardware goes to figure out which physical<br>address corresponds to the kernel virtual address 0, it would fail and generate<br>a “General Protection Fault” (trap number 13, or <code>T_GPFLT</code>). That would start<br>running the trap handler code, which would eventually get to the <code>switch</code><br>statement in <code>trap()</code> (see the last post). Trap number 13 would fall under the<br><code>default</code> case, and the if statement there would recognize that it originated in<br>the kernel. So it would print an error message to the console, then panic.</p>
<p>Okay, what if we’re using a process’s page directory, e.g. during a system call?<br>Address 0 is in the lower half of memory, so it’s a user virtual address. The<br>result will depend on whether that page and its page table are mapped in the<br>process’s page directory. If they are, then dereferencing a null pointer might<br>be fine after all. But if they’re not mapped, dereferencing a null pointer will<br>cause a General Protection Fault. This time, <code>trap()</code> would print an error<br>message to the console, then mark the process to be killed.</p>
<p>Now, killing a process or causing a kernel panic might not sound like a huge<br>deal. In fact, xv6 does a great job here by killing a process that might have<br>dereferenced a null pointer or caused the kernel to do so. A kernel panic would<br>be much worse – think about how annoying it would be if that PDF you downloaded<br>from that one sketchy website installed some malware that made your kernel panic<br>all the time – the OS would become unusable. In fact, this is an example of a<br>“denial of service” vulnerability – a malicious process might not be able to<br>read or write arbitrary memory or execute arbitrary code, but it can still keep<br>you from using your machine the way you expect to.</p>
<p>Just like <code>uva2ka()</code>, this function will only get called by one other function<br>(we’ll see it soon), so it just so happens that under the current xv6 code,<br>it’ll all be okay because it should never get passed a null pointer. But<br>everything from my rant about <code>uva2ka()</code> applies here: if you add any kernel<br>code that calls this function, be <em>VERY</em> careful and add your own null checks.</p>
<p>Okay, deep breath now. &#x2F;rant.</p>
<h3 id="fetchstr"><a href="#fetchstr" class="headerlink" title="fetchstr"></a>fetchstr</h3><p>Fetching a string argument is tricky too; strings in C are just pointers to an<br>array of characters that ends in nul, i.e. <code>&#39;\0&#39;</code>, so this time we have to make<br>sure that both the pointer <em>and</em> the entire string are in the user’s address<br>space; otherwise, we could unwittingly read from some arbitrary memory location<br>and pass the data back to the user process.</p>
<p>So we’ll start by making sure the pointer itself is in a valid address:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt;= curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll store the string pointer in <code>*pp</code>. We’ll also get a pointer to the end<br>of the process’s virtual address space so we can make sure the entire string is<br>inside its bounds.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pp = (<span class="type">char</span> *) addr;</span><br><span class="line">    <span class="type">char</span> *ep = (<span class="type">char</span> *) curproc-&gt;sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>How can we check if the entire string is inside user memory? Well, a string ends<br>with a nul byte, <code>&#39;\0&#39;</code>, so we just have to start scanning the memory starting<br>from <code>*pp</code> up to <code>ep</code> until we find a zero byte. If we find one in that range,<br>then the entire string is in user memory and we can return its length to<br>indicate success; otherwise the string overflows past the end of the process’s<br>virtual address space, so we should return -1 to indicate failure.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for a nul byte inside process&#x27;s address space</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> *s = *pp; s &lt; ep; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If nul byte found, return the length</span></span><br><span class="line">            <span class="keyword">return</span> s - *pp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// String is not nul-terminated inside process&#x27;s memory, so report failure</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that again, we’re dereferencing <code>pp</code> and <code>addr</code> without any null checks<br>(where <code>addr</code> is definitely the bigger concern, since it’s user-generated), and<br>again, it’s gonna work out okay (a misbehaving process will just get killed),<br>but once more: be careful if you use this function for your own kernel hacks.</p>
<h3 id="argint"><a href="#argint" class="headerlink" title="argint"></a>argint</h3><p>This is the main function that the <code>sys_</code> system call functions will use to<br>recover an integer argument; it’s basically just a wrapper for <code>fetchint()</code>. The<br>arguments are an integer <code>n</code> to say we want the nth integer argument, and a<br>pointer <code>ip</code> to store the recovered argument in. We have to call <code>fetchint()</code><br>with an address argument, so the main task now is to figure out where in memory<br>the nth integer argument should be.</p>
<p>We’re gonna have to use the x86 function call conventions again. Remember how<br>whenever we call a function in x86, its arguments get pushed onto the stack in<br>reverse order (i.e., from right to left), so that the first argument is at the<br>top of the stack (i.e., lowest memory address)? Then we push a return address<br>(<code>%eip</code>) and the old stack base pointer <code>%ebp</code>. Normally, the stack pointer<br>would just keep going on to the next slot on the callee’s stack, but in this<br>case the code in <code>alltraps()</code> saved all the registers (including the stack<br>pointer <code>%esp</code>) in a <code>struct trapframe</code> before calling <code>trap()</code> or <code>syscall()</code>.</p>
<p>That means we can recover the old value of <code>%esp</code> from the trap frame and look<br>one spots below that on the stack (i.e., 4 bytes higher in memory, since <code>int</code>s<br>are 4 bytes) to get the first (<code>n = 0</code>) argument. The second argument (<code>n = 1</code>)<br>would be 8 bytes higher than <code>%esp</code>, and so on. Pretty neat.</p>
<p>Okay, now that we’ve got that down, the code for this function is pretty<br>straightforward.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fetchint((myproc()-&gt;tf-&gt;esp) + <span class="number">4</span> + <span class="number">4</span>*n, ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="argptr"><a href="#argptr" class="headerlink" title="argptr"></a>argptr</h3><p>Some of the system call functions will have pointer arguments, so this function<br>recovers them. Pointers are 4 bytes in x86, so we can use <code>argint()</code> to get the<br>pointer itself before performing some additional checks to make sure the pointer<br>and the address it points to are valid.</p>
<p>The arguments are <code>n</code> (to retrieve the nth function argument), a pointer <code>pp</code> to<br>an address where we can store the retrieved pointer, and the size of the block<br>of memory that the retrieved pointer points to.</p>
<p>Let’s start off by just retrieving the value of the pointer as an integer using<br><code>argint()</code>; that’ll make sure that the number <code>n</code> is valid.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (argint(n, &amp;i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have to make sure that the pointer we just retrieved is itself valid,<br>i.e. that the size is nonnegative and the beginning and end of the memory block<br>it points to are both within the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (uint) i &gt;= curproc-&gt;sz || (uint) i + size &gt; curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we can store the pointer in <code>*pp</code> and return 0.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pp = (<span class="type">char</span> *) i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="argstr"><a href="#argstr" class="headerlink" title="argstr"></a>argstr</h3><p>A string is just a pointer in C, so we can recover the pointer’s value using<br><code>argint()</code> again, then pass it to <code>fetchstr()</code>. The former will make sure <code>n</code> is<br>valid, and the latter will make sure the string is nul-terminated and resides<br>entirely in the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (argint(n, &amp;addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchstr(addr, pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sysproc-c"><a href="#sysproc-c" class="headerlink" title="sysproc.c"></a>sysproc.c</h2><p>So now we know how <code>syscall()</code> will route a system call trap to the right <code>sys_</code><br>function, and we’ve seen how those functions can recover arguments from the<br>process’s stack. Let’s see some examples in action; most of these will be simple<br>wrapper functions.</p>
<h3 id="sys-fork"><a href="#sys-fork" class="headerlink" title="sys_fork"></a>sys_fork</h3><p>All the hard work here is gonna be done by <code>fork()</code>, which will create a new<br>child process by cloning the parent process’s virtual address space. We don’t<br>need any arguments for this, so we’ll just call <code>fork()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-exit"><a href="#sys-exit" class="headerlink" title="sys_exit"></a>sys_exit</h3><p><code>exit()</code> closes out a process, but it puts it in the <code>ZOMBIE</code> state so that the<br>parent process can call <code>wait()</code> to find out it’s done running. <code>exit()</code> should<br>never return, so we’ll add a return value here to make the compiler happy, but<br>it should never get executed.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-wait"><a href="#sys-wait" class="headerlink" title="sys_wait"></a>sys_wait</h3><p>This system call is the parent process’s counterpart to <code>exit()</code>; it’ll do as<br>its name says and wait until the child process exits.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-kill"><a href="#sys-kill" class="headerlink" title="sys_kill"></a>sys_kill</h3><p>The <code>kill()</code> system call sounds like a more aggressive version of <code>exit()</code>:<br>after all, we’re killing another process against its will, right? But in reality<br>it would be way too complicated to do that: the process might be running on<br>another CPU, midway through updating some kernel data structure, or about to<br>wake up another process that’s asleep. Killing it by force might screw up a lot<br>of other things.</p>
<p>So instead <code>kill()</code> just tags it with the <code>killed</code> field in its <code>struct proc</code>;<br>eventually either the process will call <code>exit()</code> on its own, or it’ll generate<br>another trap, at which point the code in <code>trap()</code> will call <code>exit()</code> on it.</p>
<p><code>kill()</code> needs an integer argument: the process ID for the process we wish to<br>kill. So now we can see the payoff of writing those functions above.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;pid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kill(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-getpid"><a href="#sys-getpid" class="headerlink" title="sys_getpid"></a>sys_getpid</h3><p>The <code>getpid()</code> system call is so simple that it doesn’t even have another<br>function for this <code>sys_getpid()</code> to call. We’ll just return the PID for the<br>current process.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> myproc()-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-sbrk"><a href="#sys-sbrk" class="headerlink" title="sys_sbrk"></a>sys_sbrk</h3><p>If you’re not familiar with system calls like <code>brk()</code> and <code>sbrk()</code> on Unix<br>systems, here’s what they do: they grow or shrink the virtual address space of a<br>process. <code>brk()</code> sets its new size to a specific maximum address; <code>sbrk()</code> grows<br>or shrinks the process by a certain size in bytes and returns its old size.<br>They’re mostly used to implement higher-level memory management functions like<br><code>malloc()</code>. Heh, “high-level” probably isn’t high on your mind when you think of<br>adjectives for <code>malloc()</code>, right? Anyway, xv6 only has <code>sbrk()</code>, so let’s check<br>out its <code>sys_</code> wrapper function.</p>
<p>We’ll need an integer argument (the number of bytes to grow or shrink by), so<br>let’s grab that.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can use <code>growproc()</code> from our posts on paging to grow the process by <code>n</code><br>bytes. But we want to return the old size, so we’ll have to grab that before we<br>change it with the call to <code>growproc()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> addr = myproc()-&gt;sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (growproc(n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-sleep"><a href="#sys-sleep" class="headerlink" title="sys_sleep"></a>sys_sleep</h3><p>The <code>sleep()</code> function is pretty interesting; we’ll get to the implementation<br>details later, but let’s talk about the broad strokes now. You might be familiar<br>with the <code>sleep()</code> system call in Unix systems; you pass it an integer (usually<br>in milliseconds) and it puts your process to sleep (i.e., leaves it inactive or<br>not running) for that amount of time.</p>
<p>However, <code>sleep()</code> plays a dual role in xv6: the kernel will call <code>sleep()</code> for<br>processes that need to wait while something else happens, e.g. waiting for a<br>disk to read or write data. That way the processes don’t end up idly spinning in<br>a loop or something and wasting valuable CPU time.</p>
<p>Implementing that is tricky; there’s no way to know how long it would take for<br>whatever condition the process is waiting on to be satisfied, so it’s not like<br>we can just stick in a random amount of time in the call to <code>sleep()</code> and hope<br>the condition is satisfied by then. So instead the <code>sleep()</code> function will just<br>“put a process to sleep” (read: make its state <code>SLEEPING</code> so it can’t be run by<br>the scheduler) on a <em>channel</em>, which is just an arbitrary integer. Then later on<br>the kernel can wake up any processes sleeping on that channel. So for example,<br>the kernel can put a process waiting on the disk to sleep using a specific<br>channel that’s assigned to the disk; then when the next disk interrupt occurs it<br>can wake up any processes that might be sleeping on the disk channel.</p>
<p>Okay so that’s all well and good for the kernel’s use of <code>sleep()</code>. But what<br>about the regular old <code>sleep()</code> system call? The argument is an integer that<br>represents the number of ticks to sleep for; how are we gonna turn that into a<br>channel to sleep on?</p>
<p>The answer is pretty neat (at least I think so): we’ll set the channel to the<br>address of the <code>ticks</code> counter. Remember, <code>ticks</code> is a global variable that gets<br>incremented with every timer interrupt. Go check out the code in <code>trap()</code> again:<br>each timer interrupt sends a wakeup call to any processes that might be sleeping<br>on the <code>&amp;ticks</code> channel. That should wake the process at every timer interrupt.<br>Then we’ll just stick that inside a for loop so it keeps sleeping forever until<br>the right amount of ticks have passed.</p>
<p>Let’s start by retrieving the integer argument, which is the number of ticks to<br>sleep for.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That argument <code>n</code> is a relative count, since a user process won’t necessarily<br>know how many ticks have already gone by. So let’s get the current tick count<br>before we put the process to sleep.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    uint ticks0 = ticks;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we just have to write that while loop I mentioned above to put the process<br>to sleep until <code>n</code> ticks have passed. Since we started counting at <code>ticks0</code>, the<br>condition should be satisfied when <code>ticks - ticks0 == n</code>.</p>
<p>Two more details: first, we’ll add a check inside the while loop to see if the<br>current process has been tagged to be killed; if so, we’ll just return -1 so we<br>can hasten the process’s actual death by letting it run more code so the kernel<br>will call <code>exit()</code> on it at the next trap. Second, the function <code>sleep()</code> takes<br>another argument in addition to the channel: a lock. It’ll release the lock for<br>us and reacquire it before waking up so that a sleeping process doesn’t hog a<br>lock when it doesn’t need it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (ticks - ticks0 &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            release(&amp;tickslock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-uptime"><a href="#sys-uptime" class="headerlink" title="sys_uptime"></a>sys_uptime</h3><p>The <code>uptime()</code> system call just returns the amount of ticks that have passed<br>since the system started. This is another one that’s so simple it doesn’t need<br>another function, so we’ll take care of it all here.</p>
<p>We just acquire the lock for <code>ticks</code>, get its current value, release the lock,<br>and return the value we got.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    uint xticks = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> xticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Running-System-Calls-from-User-Code"><a href="#Running-System-Calls-from-User-Code" class="headerlink" title="Running System Calls from User Code"></a>Running System Calls from User Code</h2><p>We have system calls now! Well, not quite – we still have to check out the<br>actual functions like <code>exit()</code>, <code>sleep()</code>, <code>kill()</code>, etc. Plus, we only saw the<br><code>sys_</code> wrapper functions for <em>some</em> of the system calls here; the rest are in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/sysfile.c">sysfile.c</a>, which<br>we’ll get to after we understand the xv6 file system.</p>
<p>But let’s pause for a second and think about how a user process will send a<br>system call. Like let’s say you’re writing some C code for a user program that<br>will run on xv6 and you want to create a child process with <code>fork()</code>. What<br>should you do?</p>
<p>Well, if you were coding for a Unix system like Linux or macOS, you’d just write<br>a call to <code>fork()</code> in your code. But that can’t be right in xv6, can it? After<br>all, <code>fork()</code> is a kernel function, to be run in kernel mode with a current<br>privilege level of 0. Plus, isn’t it supposed to be called by <code>sys_fork()</code>? So<br>should we call that?</p>
<p>None of these options will work. Well, yes, you do end up just calling <code>fork()</code>,<br>but it’s <em>not</em> the kernel function <code>fork()</code>, so if you’re expecting that one,<br>you’ll be surprised when it doesn’t behave the way you want it to. You won’t be<br>able to use any kernel code at all in your user program for xv6. This is a<br>mistake I’ve seen a <em>lot</em> of people make in their xv6 OSTEP projects, so bear<br>with me for a second while I explain why you can’t do it; feel free to skip the<br>next section on the Makefile if you already know why.</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>To see why, let’s check out the xv6<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a> to see<br>how xv6 is actually compiled, built, and run. There’s a ton of stuff in there,<br>but take a second to think about this: how do you usually run xv6? I bet it’s<br>a command like <code>make qemu</code> or <code>make qemu-nox</code>, right?</p>
<p>If you’re not familiar with Makefiles, here’s a quick primer: each command like<br><code>make qemu</code>, <code>make clean</code>, etc. is specified in the Makefile with a rule that<br>looks like this:</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="section">mycmd: dependency1 dependency2 ...</span></span><br><span class="line">    build_cmd1</span><br><span class="line">    build_cmd2</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>So if I run <code>make mycmd</code>, the <code>make</code> program will check that <code>dependency1</code>,<br><code>dependency2</code>, etc. are up to date; if they’re not, it’ll update them by looking<br>up <em>their</em> rules and executing those to update them. Then it’ll execute<br><code>build_cmd1</code> on the shell, followed by <code>build_cmd2</code>, etc.</p>
<p>Okay, I know that might be confusing, so let me simply the <code>make qemu</code> command a<br>bit to make it more readable (note that I cut a lot of stuff out here, so don’t<br>try to run xv6 with what I wrote below).</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">qemu: fs.img xv6.img</span></span><br><span class="line">    qemu -drive file=fs.img,index=1 -drive file=xv6.img,index=0</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>This just says that in order to run <code>make qemu</code> when you type it on the<br>terminal, the <code>make</code> program first has to make sure that both <code>fs.img</code> and<br><code>xv6.img</code> are fully up to date. Then once they are, it can just run the shell<br>command <code>qemu</code> with the options <code>-drive file=fs.img,index=1</code> and<br><code>-drive file=xv6.img,index=0</code>. Those options are just regular flags like the<br>ones you’re probably used to with stuff like <code>ls -a</code> or <code>rm -rf</code>. In this case,<br>they tell <code>qemu</code> to use the files <code>fs.img</code> and <code>xv6.img</code> as virtual hard drives,<br>with <code>xv6.img</code> as disk number 0 and <code>fs.img</code> as disk number 1.</p>
<p>Okay, let’s check out the <code>make</code> command for <code>xv6.img</code> next.</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">xv6.img: bootblock kernel</span></span><br><span class="line">    <span class="comment"># some dd commands here</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Hey, that’s interesting, we already saw <code>bootblock</code> in a prior post. That’s the<br>one we get when we compile the boot loader. <code>kernel</code> is, well, all the kernel<br>code. The <code>dd</code> command is often used in Unix systems to format and set up disks;<br>the details aren’t important here, so I left them out for now. The point is that<br>the boot loader got compiled separately from the kernel code, remember? But<br>their machine code files get smushed into the same (virtual) disk together as<br><code>xv6.img</code>, which will be disk 0 when we run in <code>qemu</code>.</p>
<p>Not let’s check out the (slightly simplified) <code>make</code> command for <code>fs.img</code>.</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">UPROGS = cat echo forktest grep init kill ln ls <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="section">fs.img: mkfs README <span class="variable">$(UPROGS)</span></span></span><br><span class="line">    ./mkfs fs.img README <span class="variable">$(UPROGS)</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Okay, so <code>UPROGS</code> is just a list of all the user programs. Each of those gets<br>compiled separately; e.g. if you look in their source code, you’ll see each one<br>has its own <code>main()</code> function. Then the shell command says to run <code>mkfs</code> to<br>create a file system called <code>fs.img</code> with <code>README</code> and all the user programs as<br>files.</p>
<p>The point of this detour is this: the boot loader gets compiled as a single<br>unit, as does the entire kernel code. But the user programs are compiled one at<br>a time. So if you write a user program for xv6, you should add it to the list in<br><code>UPROGS</code> (as well as in <code>EXTRA</code>) and expect it to get compiled individually and<br>stuck onto the <code>fs.img</code> disk.</p>
<p>That means there’s no way for a user program to call into any kernel code; the<br>linker wouldn’t even be able to match up the call to the right function. So no<br>user program will ever be able to call functions like (the kernel’s) <code>fork()</code>.<br>Think about it: if you write a program in C and compile it to run on Linux, do<br>you expect to have to recompile the entire Linux kernel just to run your one<br>little program? No, right?</p>
<p>But certainly we can’t just expect every single program ever to be totally self-<br>contained. You also don’t have to rewrite and recompile all of <code>malloc()</code> every<br>time you write a C program. So operating systems provide libraries for users to<br>include and call in their programs. Aha! So all we need to do in order for<br>user processes to execute system calls is to provide a library. That library is<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/usys.S">usys.S</a>.</p>
<h3 id="usys-S"><a href="#usys-S" class="headerlink" title="usys.S"></a>usys.S</h3><p>Let’s trace back to the beginning of a trap. In order to execute a system call,<br>we’re supposed to send the processor an <code>int</code> instruction with a specific trap<br>number; that would be <code>int 64</code> for system calls on xv6. We’re also supposed to<br>stick the system call number in the <code>%eax</code> register. Let’s say we want to call<br><code>fork()</code>. According to<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/syscall.h">syscall.h</a>, the<br>system call number for fork is <code>SYS_fork</code>, or 1. In order to send a specific x86<br>instruction and manipulate individual registers, we’ll have to write our system<br>call library in assembly. Here’s what it would look like for the <code>fork()</code> system<br>call:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl fork</span><br><span class="line">fork:</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>Okay, that’s easy enough, but we have 21 of these to write, and it would be<br>pretty easy to make a mistake or write the wrong system call number. Let’s<br>automate it instead with a C preprocessor macro. We’ve seen plenty of examples<br>of defining simple constants with <code>#define</code> directives for the preprocessor, but<br>we haven’t looked at them too closely until now.</p>
<p>The C preprocessor is a piece of software that edits C (or assembly) code before<br>it’s compiled. Preprocessor directives like <code>#define A 5</code> create macros that are<br>expanded to replace every instance of <code>A</code> in the code with the number 5;<br>directives like <code>#include &quot;header.h&quot;</code> expand such that they essentially copy-<br>paste all the code in the file <code>header.h</code>. We can also create function-like<br>macros like the <code>P2V()</code> and <code>V2P()</code> macros we’ve used often by adding a<br>parameter inside parentheses; unlike functions, these will be expanded <em>before</em><br>compilation to paste the code into every instance of its use, thus avoiding the<br>usual overhead associated with a function call. Function-like macros are also<br>generic, in a sense, since they don’t require specifying parameter types or<br>return types (as long as it works within the places where the macro will be<br>used). Note that there are some drawbacks: macros aren’t type-checked, they can<br>evaluate their arguments more than once, we can’t use pointers to them like we<br>can with functions, and they can result in larger code.</p>
<p>We’re gonna use a function-like macro here to create the assembly code for each<br>system call function so that it gets expanded before the code is assembled.<br>We’ll use <code>T_SYSCALL</code> instead of 64 in the code above, and <code>SYS_fork</code> (or its<br>equivalent for each system call) for the system call number. We’ll have to<br>replace the part after the underscore in <code>SYS_</code> with the name of the system call<br>function; we can do that with the token-pasting operator <code>##</code>, which glues two<br>tokens together to form a single token. Also, macros must be defined on a single<br>line, so we’ll escape the newline characters with <code>\</code> and end each assembly line<br>with a semicolon.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line">#include &quot;traps.h&quot;</span><br><span class="line"></span><br><span class="line">#define SYSCALL(name) \</span><br><span class="line">    .globl name; \</span><br><span class="line">    name: \</span><br><span class="line">        movl    $SYS_##name, %eax; \</span><br><span class="line">        int $T_SYSCALL; \</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>Now we can just invoke the macro on the name of each function we want to create:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">SYSCALL(fork)</span><br><span class="line">SYSCALL(exit)</span><br><span class="line">SYSCALL(wait)</span><br><span class="line"># and so on ...</span><br></pre></td></tr></table></figure>

<p>After the preprocessor runs on the file, the result will look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl fork</span><br><span class="line">fork:</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl exit</span><br><span class="line">exit:</span><br><span class="line">    movl    $2, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl wait</span><br><span class="line">wait:</span><br><span class="line">    movl    $3, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"># and so on...</span><br></pre></td></tr></table></figure>

<p>Great! Now we have 21 functions for the system calls, all written in assembly.<br>All user programs for xv6 will be compiled together with the code for these<br>functions: see <code>ULIB</code> in the Makefile. So now, a user program can execute a<br>system call by calling these functions, e.g. <code>fork()</code>.</p>
<h2 id="Summary-9"><a href="#Summary-9" class="headerlink" title="Summary"></a>Summary</h2><p>After all the preparations are handled by the trap handler functions in the IDT,<br><code>alltraps()</code>, and <code>trap()</code>, system calls get routed to the <code>syscall()</code> function,<br>which uses a system call number to pick the right function out of an array. That<br>function will have to recover any arguments to the system call before passing it<br>on to the real system call function later on.</p>
<p>Next up, we’ll take a look at some of those system calls; we’ll leave the rest<br>until after we go over xv6’s file system.</p>
<h1 id="System-Calls-Processes"><a href="#System-Calls-Processes" class="headerlink" title="System Calls: Processes"></a>System Calls: Processes</h1><p>In a previous post, I pointed out some of the most important functions a kernel<br>has to fulfill. System calls take care of two of these: virtualizing resources<br>via virtual memory and processes, and mediating communication between user-mode<br>processes and the hardware. We’ll wrap up the former now by looking at the<br>system call functions relating to processes and scheduling.</p>
<h2 id="proc-c-2"><a href="#proc-c-2" class="headerlink" title="proc.c"></a>proc.c</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>Unlike some of the other functions we’ll talk about in this post, <code>fork()</code> is<br>used almost exclusively by user code as a system call; the kernel never calls<br>it. That said, it has an extremely important role: after the first process has<br>started, it’s the only way to create more processes. It does that by copying the<br>parent process’s virtual address space into a new page directory. We haven’t<br>talked about the file system yet, but hopefully you’re familiar with file I&#x2F;O in<br>Linux, so you know each process has its own list of open files and a current<br>working directory; <code>fork()</code> will clone those as well for the child process.</p>
<p>Let’s start off by getting a pointer to the parent process and creating a slot<br>in the process table for the child process with <code>allocproc()</code>. Remember, that<br>function returns a pointer to the new process’s <code>struct proc</code>, but it can fail<br>and return null (e.g., if there is no available slot in the process table, or if<br>its call to <code>kalloc()</code> fails), so we’ll need to check for that.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate process table slot for child process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((np = allocproc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allocproc()</code> also sets up the new process’s stack so that it’ll return into<br><code>forkret()</code>, then <code>trapret()</code>, before context switching into user mode, and sets<br>the process’s state to <code>EMBRYO</code>.</p>
<p>Next we need a page directory for the new child process; it should be a copy of<br>the parent process’s page directory. Luckily, we already did the hard work for<br>this back in the virtual memory posts, so we can just use <code>copyuvm()</code> now. That<br>function can also fail, in which case we’ll free the stack that <code>allocproc()</code><br>created and set the child process’s state back to <code>UNUSED</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((np-&gt;pgdir = copyuvm(curproc-&gt;pgdir, curproc-&gt;sz)) == <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(np-&gt;kstack);</span><br><span class="line">        np-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        np-&gt;state = UNUSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll copy the parent process’s size and trap frame; the latter will make<br>sure the child starts executing after <code>trapret()</code> with the same register<br>contents as the parent. We’ll set the child process’s parent to, well, its<br>parent (the current process).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    np-&gt;sz = curproc-&gt;sz;</span><br><span class="line">    np-&gt;parent = curproc;</span><br><span class="line">    *np-&gt;tf = *curproc-&gt;tf;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The two processes will be nearly identical, so we need a way to distiguish them<br>from user space so that a user program can give different instructions to each.<br>xv6 follows the Unix convention that <code>fork()</code> should return the child process’s<br>PID to the parent and return 0 for the child. The parent’s return value is easy;<br>we’ll just literally return the child’s PID at the end. But the child didn’t<br>actually call <code>fork()</code>, so how can we set a return value that it will see?</p>
<p>Well, the x86 convention is for return values to be passed in the <code>%eax</code><br>register, right? And that register will be restored from the trap frame before<br>switching into user mode. So we’ll just store the value 0 there.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    np-&gt;tf-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll copy all the parent process’s open files and its current working<br>current working directory. The files are stored in a per-process file array<br><code>curproc-&gt;ofile</code> of size <code>NOFILE</code>, so we can copy them over with the function<br><code>filedup()</code> (which we’ll see later). The current working directory is in<br><code>curproc-&gt;cwd</code> and can be copied with <code>idup()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NOFILE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> curproc-&gt;ofile[i]) &#123;</span><br><span class="line">            np-&gt;ofile[i] = filedup(curproc-&gt;ofile[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    np-&gt;cwd = idup(curproc-&gt;cwd);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we’ll copy the parent process’s name with <code>safestrcpy()</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>. You<br>might be familiar with the C standard library funtion <code>strncpy()</code>; this function<br>is almost identical, except that unlike <code>strncpy()</code> it’s guaranteed to nul-<br>terminate the string it copies. If you haven’t seen this kind of thing before,<br>it’s a fairly common practice to write your own safe wrappers for some of the C<br>standard library functions, especially the ones in <code>string.h</code> which are so often<br>error-prone and dangerous.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    safestrcpy(np-&gt;name, curproc-&gt;name, <span class="keyword">sizeof</span>(curproc-&gt;name));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll set the child process’s state to <code>RUNNABLE</code> and return its PID<br>for the parent.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    np-&gt;state = RUNNABLE;</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>This is one of the functions that can get called both by the kernel and as a<br>system call. The kernel will use it to terminate malicious or buggy processes,<br>and user code can use it as a system call to kill another process too.</p>
<p>We said before that killing a process immediately would present all kinds of<br>risks (e.g. corrupting any kernel data structures it might be updating, etc.),<br>so all we’re gonna do is give it the ominous mark of death with the <code>p-&gt;killed</code><br>field. Then the code in <code>trap()</code> will handle the actual murder the next time the<br>process passes through there.</p>
<p>The argument is a process ID number, so let’s just iterate over the process<br>table until we find a process with a matching PID; we’ll return -1 if we don’t<br>find any.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we do find a matching process, then we’ll set <code>p-&gt;killed</code>. Also, some of the<br>calls to <code>sleep()</code> will occur inside a while loop that checks if <code>p-&gt;killed</code> has<br>been set since the process started sleeping, so let’s hasten the process’s death<br>a little by setting its state to <code>RUNNABLE</code> so it’ll wake up and encounter those<br>checks faster. There’s no risk of screwing up by waking up a process too early,<br>since each call to <code>sleep()</code> should be in a loop that will just put it back to<br>sleep if it’s not ready to wake up yet.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">                p-&gt;state = RUNNABLE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            release(&amp;ptable.lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>The last post went over the basics of <code>sleep()</code> and <code>wakeup()</code>; they act as<br>mechanisms for <em>sequence coordination</em> or <em>conditional synchronization</em>, which<br>allows processes to communicate with each other by sleeping while waiting for<br>conditions to be fulfilled and waking up other processes when those conditions<br>are satisfied.</p>
<p>Processes can go to sleep on a channel or wake up other processes sleeping on a<br>channel. In many operating systems, this is achieved via channel queues or even<br>more complex data structures, but xv6 makes it as simple as possible by simply<br>using pointers (or equivalently, integers) as channels; the kernel can just use<br>any convenient address as a pointer for one process to sleep on while other<br>processes send a wakeup call using the same pointer.</p>
<p>This does mean that multiple processes might be sleeping on the same channel,<br>either because they are waiting for the same condition before resuming execution<br>or because two different <code>sleep()</code>&#x2F;<code>wakeup()</code> pairs accidentally used the same<br>channel. The result would be that a process might be woken up before the<br>condition it’s waiting for has been fulfilled. We can solve that problem by<br>requiring every call to <code>sleep()</code> to occur inside a loop that checks the<br>condition; that way, if a process receives a spurious wakeup call before it<br>really should have been woken up, the loop will put it right back to sleep<br>anyway. We saw one example of this in the <code>sys_sleep()</code> function, in which the<br>while loop checked if the right number of ticks had passed.</p>
<p>A common concurrency danger with conditional synchronization in any operating<br>system is the problem of missed wakeup calls: if the process that’s supposed to<br>send the wakeup call runs <em>before</em> the process that’s supposed to sleep, it’s<br>possible that the sleeping process will never be woken up again. The problem is<br>more general than just processes; it applies to devices too.</p>
<p>Imagine this scenario: a process tries to read from the disk; it’ll check<br>whether the data is ready yet and go to sleep (inside a while loop) until it is.<br>If the disk gets to run first, then the process will just find the data ready<br>and waiting for it, so it can continue on to use the data. If the process runs<br>before the disk does, then it’ll see the data isn’t ready yet and sleep in a<br>loop until it is; the disk will wake the process up once the data is ready.</p>
<p>But suppose they run at the same time, or in between each other. The process<br>does its check and finds the data isn’t ready, but before it can go to sleep, a<br>timer interrupt or some other trap goes off and the kernel switches processes.<br><em>Then</em> the disk finishes reading and starts a disk interrupt that sends a wakeup<br>call to any sleeping processes, but the process isn’t sleeping yet. When the<br>process starts running again later on, it’ll go to sleep – having already<br>missed its wakeup call.</p>
<p>The problem is that the process can get interrupted between checking the<br>condition and going to sleep, right? So why don’t we just disable interrupts<br>there with <code>pushcli()</code> and <code>popcli()</code>? add a lock there? Ah, but there’s another<br>problem: what if the disk driver is running simultaneously on another CPU?<br>Disabling interrupts on the process’s CPU wouldn’t stop the other CPU from<br>sending the disk’s wakeup call too early.</p>
<p>Okay fine, so let’s use a lock instead. The process will hold the lock while it<br>checks the condition and sleeps, and the disk driver will have to acquire the<br>lock before it can send its wakeup call… Can you see the problem here? If the<br>process holds the lock while it’s sleeping, the disk driver will never be able<br>to acquire the lock in order to wake it up. That’s a deadlock.</p>
<p>HEAD. DESK.</p>
<p>Ugh, okay, fine, you got me. So let’s use a lock, but let’s have <code>sleep()</code><br>release it right away, then reacquire it before waking up; that way the lock<br>will be free while the process is sleeping so the disk driver can acquire it.<br>Done, right? Everybody’s happy?</p>
<p>Nope. Now we’re back to the original problem: if the lock gets released inside<br><code>sleep()</code> before the process is actually sleeping, then the wakeup call might<br>happen in between those and get missed.</p>
<p>@*#&amp;@#$**&amp;@#%$!!!</p>
<p>So we need a lock. And we can’t hold the lock while sleeping, or we’d get a<br>deadlock. But we also can’t release it before sleeping, or we might miss a<br>wakeup call. So… ???</p>
<p>See, I told you: concurrency is your worst nightmare. Ever since we decided we’d<br>like our operating systems to do more than run a single basic process at a time,<br>we introduced all <em>kinds</em> of problems we have to reason through. Let’s check out<br>how xv6 actually writes the <code>sleep()</code> function and think through it ourselves<br>and try to understand if it manages to solve this problem.</p>
<p>We’ll start by making sure of two things: (1) this CPU is currently running a<br>process and not the scheduler (which can’t ever go to sleep), and (2) the caller<br>passed in a lock (which can be any arbitrary lock).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lk == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sleep without lk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to release the lock and put the process to sleep. That will require<br>modifying its state, so we should now acquire the lock for the process table.<br>But if the lock that the process is already holding <em>is</em> the process table lock,<br>then trying to acquire it again would cause a panic, so let’s add a check for<br>that; if we’re already holding it then we’ll keep using it and we don’t need to<br>release it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (lk != &amp;ptable.lock) &#123;</span><br><span class="line">        acquire(&amp;ptable.lock);</span><br><span class="line">        release(lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s nap time for this process. We just update its channel to <code>chan</code><br>and its state to <code>SLEEPING</code>, then call <code>sched()</code> to perform a context switch<br>into the scheduler so it can run a new process. We <em>have</em> to be holding the<br>process table lock before calling <code>sched()</code>, remember?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;chan = chan;</span><br><span class="line">    p-&gt;state = SLEEPING;</span><br><span class="line">    sched();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the process wakes up later on (if indeed it turns out that the code here<br>works and doesn’t miss any wakeup calls), it’ll eventually be run by the<br>scheduler, at which point it will context switch back here. So at that point<br>we’ll reset its channel and reacquire the original lock before returning.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lk != &amp;ptable.lock) &#123;</span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">        acquire(lk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, well I don’t know about you, but I’m still not convinced that this<br>implementation won’t miss any wakeup calls. After all, we release the original<br>lock before putting the process to sleep, right? We’re holding the process table<br>lock at that point, which at least means that interrupts are disabled, but the<br>process that will wake this one up might already be running on another CPU and<br>might send the wakeup signal in between releasing the original lock and<br>updating this process’s channel and state. Hmm… Well, as always, xv6 is<br>brilliant, so we’ll see how this gets solved in the code for <code>wakeup()</code>.</p>
<p>But wait! Before we move on, I have a warning for you about using this function<br>in your own code when you start hacking away at xv6. Remember that when we first<br>talked about deadlocks, we saw we can cause a deadlock if two processes acquire<br>two locks in opposite orders? If process 1 tries to acquire lock A, then lock B,<br>and process 2 simultaneously tries to acquire lock B, then lock A, then the end<br>result is that process 1 will acquire lock A and process 2 will acquire lock B,<br>but neither will be able to acquire the other lock since it’s already being held.</p>
<p>If you look at the code above, the process that called <code>sleep()</code> must have<br>already been holding a lock <code>lk</code>, then <code>sleep()</code> acquires <code>ptable.lock</code> before<br>releasing <code>lk</code>. You know what that means: there’s potential for a deadlock. So<br>in order to avoid that, you should make sure that <em>any</em> lock you pass in to<br><code>sleep()</code> must <em>always</em> get acquired before <code>ptable.lock</code>. If any other function<br>(or chain of function calls) could potentially acquire <code>ptable.lock</code> before <code>lk</code>,<br>then you might end up with a deadlock. As always, the xv6 authors have been<br>extremely careful to make sure that that never happens in the existing code, so<br>you’ll have to do the same thing for any code you add.</p>
<h3 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup"></a>wakeup</h3><p>This function is short and sweet because it procrastinates all the work it has<br>to do by pushing it off to a helper function, <code>wakeup1()</code>. It just acquires the<br>process table lock, calls <code>wakeup1()</code>, then releases the process table lock. It<br>has to grab that lock since it’s gonna modify the process’s state in the process<br>table.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    wakeup1(chan);</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xv6 has to use this kind of a wrapper function for the real wakeup function<br><code>wakeup1()</code> in order to let processes that are already holding the process table<br>lock send wakeup calls too.</p>
<p>Okay, now before we go look at <code>wakeup1()</code>, let’s get back to figuring out<br>whether xv6’s implementation of <code>sleep()</code> and <code>wakeup()</code> can lead to missed<br>wakeup calls. Take a look at the code in <code>sleep()</code> again where the original lock<br>gets released – we have to acquire the process table lock <em>before</em> we can<br>release the other lock. So now there are always two locks in play whenever we<br>use <code>sleep()</code> and <code>wakeup()</code>.</p>
<p>Let’s go back to the example of a process waiting on a disk read. The process<br>acquires some disk-related lock first, then checks to see if the disk is done<br>reading; if not, it’ll call <code>sleep()</code> inside a while loop. If the disk driver<br>runs now before the process gets to call <code>sleep()</code>, that’s okay: the disk driver<br>also has to acquire the same lock before calling <code>wakeup()</code>, so the disk would<br>just end up spinning idly. Eventually, the process runs again and gets to<br>call <code>sleep()</code>; there, it will first acquire the process table lock before<br>releasing the original disk-related lock.</p>
<p>So what happens if the disk driver’s code runs now? Now the disk would be able<br>to acquire the original lock, so there’s nothing stopping it from calling<br><code>wakeup()</code>. But the very first thing it has to do there is acquire the process<br>table lock, which the process is already holding, so it just spins idly again!<br>There’s no way the disk driver could ever beat the process to acquiring this<br>second lock, because the process already held the first (disk-related) lock<br>before acquiring the second one (the process table lock). Now the process can<br>finish going to sleep and switch into the scheduler, which will eventually<br>release the process table lock. So then the disk driver can acquire it, release<br>the first lock, and finally send its wakeup call.</p>
<p>Moral of the story? There’s no way for xv6 to ever have any missed wakeup calls!<br>The trick was to use two locks, and acquire the second before releasing the<br>first. But coming up with that solution isn’t as easy as saying “oh, just use<br>two locks!” The solution only works because of the way the process table lock is<br>already being handled by so many other parts of the kernel code. For example, if<br>the context switch into the scheduler wasn’t guaranteed to release the process<br>table lock, then the disk driver in the example would never be able to acquire<br>it after the process goes to sleep, resulting in a deadlock. The solution works<br>because of all the design decisions in xv6 up to this point.</p>
<h3 id="wakeup1"><a href="#wakeup1" class="headerlink" title="wakeup1"></a>wakeup1</h3><p>Okay, I’ll stop fawning over the intricacies of xv6 concurrency management now<br>so we can look at how wakeup calls actually happen. Remember, this is a separate<br>function from <code>wakeup()</code> because sometimes the scheduler needs to send a wakeup<br>call while it’s already holding the process table lock. So we’re gonna assume<br>that every function that ever calls this is already holding it.</p>
<p>The implementation here is actually pretty simple now: we’ll just iterate over<br>the process table and set every single process that’s sleeping on channel<br><code>chan</code> to <code>RUNNABLE</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wakeup1</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">            p-&gt;state = RUNNABLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, there might be multiple processes sleeping on this channel, so this will<br>wake them all up. For some of those processes, this might be a spurious wakeup,<br>so again, we should always make sure to call <code>sleep()</code> in a loop that checks for<br>some condition to be satisfied. Even if multiple processes do have their<br>sleep conditions satisfied, they’ll have to reacquire their original lock before<br>returning out of <code>sleep()</code>, so only one of them will do so and the others will<br>spin until the first one is done.</p>
<p>Why not just wake up the first process we find that’s sleeping on <code>chan</code>? Then<br>we could avoid the extra overhead of a bunch of processes waking up, checking a<br>condition, and going back to sleep, or even spinning idly waiting to reacquire<br>the lock before returning. The issue is that the channels may not be unique, so<br>there’s no way to know which of all the sleeping processes is the one whose<br>sleep condition has just been fulfilled. If we wake up the wrong process, it’ll<br>just go back to sleep, but the right process didn’t wake up, so that means we’ve<br>lost a wakeup call.</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>Okay, so we saw above that <code>kill()</code> doesn’t really kill a process immediately;<br>it shirks that responsibility and lets <code>exit()</code> handle it instead… except<br>even <code>exit()</code> won’t really fully kill a process. Whew, a process’s death just<br>keeps getting dragged out forever, doesn’t it? It’s starting to feel like a<br>cheesy death scene in a tragedy; I bet the process is tired of suffering the<br>slings and arrows of outrageous fortune by now.</p>
<p>But it does make sense. Think about what we have to do in order to wrap up a<br>process and recycle its slot in the process table: we have to close out any open<br>files and reset its current working directory, free its kernel stack and its<br>entire page directory, then notify the parent that it’s done running.</p>
<p>The trouble comes with freeing the kernel stack and process page directory. This<br>function runs in kernel mode, so while the user stack in the lower half of<br>memory will be unused now, the kernel stack is still needed in order to keep<br>executing the instructions for <code>exit()</code>. Also, with the exception of the times<br>when it’s running the scheduling algorithm, the kernel uses the page directory<br>of the current process. The moment we free that page directory, the very next<br>memory access will be to an invalid page; the CPU would trigger an exception<br>then. That exception would eventually get routed to <code>exit()</code> again, except, oh<br>wait, we can’t even run any instructions without generating another exception,<br>because the entire page directory and stack have been freed; that’s a double<br>fault. So then the CPU would try to handle <em>that</em> exception, which would cause<br>the dreaded boogeyman of OS devs around the world: a triple fault. After a fault<br>triggers a second exception, which itself triggers a third exception, the CPU<br>just decides that the kernel in its current state doesn’t have its shit together<br>enough to keep running, so it takes over and reboots the whole system. Oops.</p>
<p>Okay, so let’s not do that. That means we can’t free the kernel stack nor the<br>page directory until we’re running on a different stack&#x2F;page directory combo.<br>That could happen in <code>scheduler()</code> while we’re using the page directory <code>kpgdir</code>,<br>or it could happen while we’re running another process. xv6 does it while it’s<br>running the parent process, in the <code>wait()</code> system call. If you haven’t used<br>that in Linux before, <code>wait()</code> lets a parent process sleep until a child process<br>is done running. xv6 will use <code>wait()</code> to finish cleaning up after an exited<br>child process too.</p>
<p>Now, the very first process that starts running in xv6 (<code>initproc</code>, which loads<br>and runs the shell) obviously has no parent process, but that’s okay because<br>that one should never exit as long as the system is up. So let’s start this<br>function off by making sure that the process that’s exiting isn’t the initial<br>process.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (curproc == initproc) &#123;</span><br><span class="line">        panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll close all open files and clear the current working directory; again,<br>we haven’t seen the file system functions used here, but we’ll get to them soon.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all open files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curproc-&gt;ofile[fd]) &#123;</span><br><span class="line">            fileclose(curproc-&gt;ofile[fd]);</span><br><span class="line">            curproc-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the current working directory</span></span><br><span class="line">    begin_op();</span><br><span class="line">    iput(curproc-&gt;cwd);</span><br><span class="line">    end_op();</span><br><span class="line">    curproc-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we only have one thing left to do: notify the parent process that this<br>process has exited. If the parent process is currently sleeping in <code>wait()</code>,<br>then we’ll need to wake it up. But maybe the parent process is currently in the<br>middle of executing other code before it gets to <code>wait()</code>; we don’t want it to<br>miss the wakeup call… oh wait, but that’s okay, remember? The implementations<br>of <code>sleep()</code> and <code>wakeup()</code>&#x2F;<code>wakeup1()</code> guarantee that we can’t miss a wakeup<br>call as long as we’re holding the right lock; <code>wait()</code> will use the process<br>table lock for that. So let’s acquire it now and send a wakeup call.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    wakeup1(curproc-&gt;parent);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, remember that a sleeping process needs to check some condition in a loop;<br>how can the parent process know that the child has exited? Hmm, okay, let’s set<br>the child’s state to <code>ZOMBIE</code>. That’ll also prevent the scheduler from trying to<br>run it again.</p>
<p>Ah, but hang on a sec… what if the parent process has itself been killed, i.e.<br>the current process has been orphaned? (Again with the melodrama…) A process<br>can’t run any more user code after <code>exit()</code>, so an undead parent process would<br>never get to call <code>wait()</code> to clean up after its children. In that case, we’d<br>have to find another process that could adopt a child.</p>
<p>So let’s just solve that problem now: this process is about to shuffle off its<br>mortal coil, so let’s figure out if it has any children and pass them off to<br>another process that can keep raising them as its own. But which process is<br>guaranteed to live long enough to clean up after those children once they die?<br>Ah, <code>initproc</code>, of course! That first process is immortal, so it should be able<br>to look after any children that this process might leave behind after it makes<br>its quietus with a bare bodkin.</p>
<p>So we’ll iterate over the process table, looking for any processes with parent<br>process equal to <code>curproc</code>; if we find any, we’ll have <code>initproc</code> adopt them.<br>If any of our now-abandoned children has already exited before we did, we’ll<br>send a wakeup signal to <code>initproc</code> too in case it’s sleeping in <code>wait()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parent == curproc) &#123;</span><br><span class="line">            p-&gt;parent = initproc;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == ZOMBIE) &#123;</span><br><span class="line">                wakeup1(initproc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s finally time for this process to find out what dreams may come in<br>that sleep of death. We’ll set its state to <code>ZOMBIE</code> and context-switch into the<br>scheduler, never to return; if something goes wrong and the scheduler <em>does</em><br>return, we’ll panic in order to keep this function from returning into user code<br>again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    curproc-&gt;state = ZOMBIE;</span><br><span class="line">    sched();</span><br><span class="line"></span><br><span class="line">    panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>Like we said above, this system call lets a parent process wait for a child<br>process to exit; it also cleans up after the child process has exited.</p>
<p>First, we don’t even know if this process has any children, so we’ll have to<br>check by iterating through the process table and checking each process’s parent<br>to see if it matches the current process. If it does, then we’ll check if it’s a<br>zombie, in which case we can clean it up and return its process ID.</p>
<p>We should also deal with two edge cases: first, if the process has no children<br>at all, and second, if the process does have children but none of them are dead<br>yet. In the first case, we’ll just return -1 to report failure; in the second<br>case we’ll put the current process to sleep until one of its children exits. The<br><code>sleep()</code> call means we’ll have to do these checks inside an infinite loop.</p>
<p>Alright, let’s get started by getting the current process and acquiring the<br>process table lock, then starting an infinite loop.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inside the loop, we’ll use a variable <code>havekids</code> as a boolean to track whether<br>we’ve found any child processes. Then we can iterate over the process table,<br>skipping any processes for which the current process is not the parent. If we<br>find any children, we’ll set <code>havekids</code> to 1.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> havekids = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent != curproc) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            havekids = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we did find a child process, we should check if it’s a zombie, in which case<br>it’s time to finish its clean-up. That means freeing its kernel stack and its<br>page directory and recycling its <code>struct proc</code> so that it can be reallocated to<br>another process later on.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == ZOMBIE) &#123;</span><br><span class="line">                <span class="type">int</span> pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Free child&#x27;s kernel stack</span></span><br><span class="line">                kfree(p-&gt;kstack);</span><br><span class="line">                p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Free child&#x27;s page directory</span></span><br><span class="line">                freevm(p-&gt;pgdir);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Recycle child&#x27;s struct proc</span></span><br><span class="line">                p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">                p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">                p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">                p-&gt;state = UNUSED;</span><br><span class="line"></span><br><span class="line">                release(&amp;ptable.lock);</span><br><span class="line">                <span class="keyword">return</span> pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if <code>havekids</code> is still zero by the time we finish the for loop, that means<br>the process doesn’t have any children, so we should report failure. We’ll also<br>check if the process has been marked as killed in the meantime.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!havekids || curproc-&gt;killed) &#123;</span><br><span class="line">            release(&amp;ptable.lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, if it <em>does</em> have children, but none of them have exited yet, we’ll put<br>the process to sleep. It’ll get woken up when a child exits, at which point<br>it’ll restart the outer for loop at the top and start looking through the<br>process table again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        sleep(curproc, &amp;ptable.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-10"><a href="#Summary-10" class="headerlink" title="Summary"></a>Summary</h2><p>By now, we’ve looked at a good chunk of the system calls available in xv6. These<br>system calls wrap up the mechanisms that xv6 uses to create and exit processes<br>with <code>fork()</code>, <code>kill()</code>, <code>exit()</code>, and <code>wait()</code>, and introduced <code>sleep()</code> and<br><code>wakeup()</code> as a means for (limited) inter-process communication.</p>
<p>So what’s left now? The rest of the kernel code we’re gonna look at will just<br>focus on communicating with various hardware devices like the serial port,<br>console, and keyboard. Those drivers are relatively short, but there’s one<br>device that will require a lot more work: the disk. Storing files on disk and<br>making sure they persist across reboots require careful planning, and making<br>files conveniently accessible to users requires an entire system of abstractions<br>layered on top of each other, along with a whole host of file-related system<br>calls.</p>
<h1 id="Sleep-Locks"><a href="#Sleep-Locks" class="headerlink" title="Sleep Locks"></a>Sleep Locks</h1><p>We’ve used plenty of spin-locks, and a previous post looked at their<br>implementation in xv6. Spin-locks have pretty harsh performance costs: a process<br>that’s waiting to acquire a lock will just spin idly in a while loop, wasting<br>valuable CPU time that could be used to run other processes. So far, we’ve only<br>seen locks for kernel resources like the process table, page allocator, and<br>console, for which all operations should be relatively fast, on the order of a<br>few dozen CPU cycles at most.</p>
<p>Now it’s time to look at the disk driver and file system implementation, and<br>we’ll need some locks there too. But disk operations are <em>slow</em> – reading from<br>and writing to disk might take milliseconds, which is a literal eternity for a<br>CPU. Imagine a process hogging a spin-lock for the disk while other processes<br>spin around and around waiting <em>forever</em> for the disk to finish writing. It<br>would be an enormous waste!</p>
<p>Spin-locks were the best we could do at the time, since we didn’t have any<br>infrastructure to support more complex locks, but now we really do need a better<br>alternative. We also have some more kernel building blocks in place relating to<br>processes, including a bunch of system calls.</p>
<p>For example, we’ve seen the <code>sleep()</code> and <code>wakeup()</code> system calls, which let a<br>process give up the CPU until some condition is met. Well, hang on a second –<br>what if that condition is that a lock is free to acquire? Then a process could<br>sleep while another process holds the lock, and wake up when it’s ready to be<br>acquired; that would let other processes run instead of forcing a process to<br>spin and spin. xv6 calls these <em>sleep-locks</em>, and it’s time to find out how they<br>work.</p>
<h2 id="sleeplock-h"><a href="#sleeplock-h" class="headerlink" title="sleeplock.h"></a>sleeplock.h</h2><p>If we want a process holding a sleep-lock to give up the processor in the middle<br>of a critical section, then sleep-locks have to work well when held across<br>context switches. They also have to leave interrupts enabled. This couldn’t<br>happen with spin-locks: it was important that they disable interrupts to prevent<br>deadlocks and ensure a kernel thread can’t get rescheduled in the middle of<br>updating some important data structure.</p>
<p>Leaving interrupts on adds some extra challenges. First, we have to make sure<br>the lock can still be acquired atomically; second, we have to make sure that any<br>operations in the critical section can safely resume after being interrupted.</p>
<p>Let’s solve the first problem: how can we make sure a sleep-lock will always be<br>acquired atomically? Well, if we want to do something atomically, we already<br>have a solution: spin-locks! So rather than reinventing the wheel, we’ll just<br>make each sleep-lock a two-tiered deal with a spin-lock to protect its<br>acquisition.</p>
<p>We’ll use a <code>locked</code> field just like the one all spin-locks have, but then we’ll<br>add a spin-lock to protect it. We’ll also make debugging a little easier by<br>adding a name for the lock and a field for a PID to identify which process is<br>holding it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">    uint locked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="sleeplock-c"><a href="#sleeplock-c" class="headerlink" title="sleeplock.c"></a>sleeplock.c</h2><h3 id="initsleeplock"><a href="#initsleeplock" class="headerlink" title="initsleeplock"></a>initsleeplock</h3><p>We can initialize a sleep-lock by initializing its guard spin-lock, then adding<br>a name for it, setting <code>locked</code> to false, and the <code>pid</code> field to zero.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initsleeplock</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;lk-&gt;lk, <span class="string">&quot;sleep lock&quot;</span>);</span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acquiresleep"><a href="#acquiresleep" class="headerlink" title="acquiresleep"></a>acquiresleep</h3><p>In order to make sure sleep-lock acquisition is atomic, we’ll bookend this<br>function by acquiring and releasing a spin-lock. This will also make sure that<br>interrupts are disabled during this function but re-enabled when it’s done. It<br>does add some overheard in the form of spinning until this lock is free, but the<br>code here should be relatively short and fast to execute. What we really want is<br>to avoid spinning once the sleep-lock is acquired, i.e. spinning <em>after</em> this<br>function is done. So we’ll tolerate a little waste here.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now we have to do the actual acquisition. We said above that we’d use the<br><code>sleep()</code> function to avoid wasting processor time. Hopefully you remember one<br>important detail about <code>sleep()</code>: it must always be called inside a while loop<br>in order to make sure that we don’t miss any wakeup calls. So let’s check if the<br>sleep-lock is already being held and go to sleep if it is. We’ll need a channel<br>and a lock for <code>sleep()</code> to release, so let’s use the pointer to this lock <code>lk</code><br>as the channel, and the outer spin-lock <code>lk-&gt;lk</code> as the lock to be released.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">        sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s important to keep the two locks separate in your head right now: <code>lk</code> is<br>the sleep-lock, and <code>lk-&gt;lk</code> is the spin-lock it uses to protect the sleep-lock’s<br>acquisition. Note that we’re checking <code>lk-&gt;locked</code> here, <em>not</em> the spin-lock<br><code>lk-&gt;lk</code> – this process is already holding <code>lk-&gt;lk</code>, but we need to acquire<br><code>lk</code> itself by updating <code>lk-&gt;locked</code>. Phew, try saying that ten times fast.</p>
<p>Now the process will go to sleep and yield the CPU until the sleep-lock is free.<br>If multiple processes are sleeping waiting on the same sleep-lock, they will all<br>wake up at the same time, but all of them have to reacquire <code>lk-&gt;lk</code> before<br>returning from sleep, so only one will get to return here and complete the<br>sleep-lock acquisition. The others will spin a bit longer, then return here only<br>to find that <code>lk-&gt;locked</code> is already being held by another process, so the while<br>loop will put them to sleep again.</p>
<p>Once the sleep-lock is free, the process can exit the while loop and claim the<br>sleep-lock for itself.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">    lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We don’t need fancy atomic operations like <code>xchg</code> anymore, since the guarding<br>spin-lock has already made sure that interrupts are disabled and all operations<br>are effectively atomic. So that’s all we need! Now we just release the spin-lock<br>and return.</p>
<h3 id="releasesleep"><a href="#releasesleep" class="headerlink" title="releasesleep"></a>releasesleep</h3><p>Now that we’ve seen how a process acquires a sleep-lock, releasing it is easy,<br>we just do the opposite. We’ll set <code>lk-&gt;locked</code> to zero and clear the <code>lk-&gt;pid</code><br>field. And what’s the opposite of <code>sleep()</code>? Well, <code>wakeup()</code>, of course! That<br>will check whether there are any processes sleeping on this channel and let them<br>know they can attempt to acquire the sleep-lock now.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line"></span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    wakeup(lk);</span><br><span class="line"></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="holdingsleep"><a href="#holdingsleep" class="headerlink" title="holdingsleep"></a>holdingsleep</h3><p>This function is even more simple: it just checks whether a sleep-lock is being<br>held, and if so, whether it’s being held by the current process. The first is<br>done by just checking <code>lk-&gt;locked</code>; the second is done by checking that <code>lk-&gt;pid</code><br>matches the current process’s PID. The result is a boolean stored in a temporary<br>variable so we can release the guarding spin-lock before returning the result.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holdingsleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);</span><br><span class="line"></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-11"><a href="#Summary-11" class="headerlink" title="Summary"></a>Summary</h2><p>Okay, that wasn’t too bad! It makes sense why we couldn’t use sleep-locks in a<br>kernel without system calls like <code>sleep()</code> and <code>wakeup()</code>. But xv6 already has<br>those, so why not use them everywhere? If sleep-locks really do cut down on the<br>wasted CPU time, can we just go back and replace all the spin-locks with<br>sleep-locks? Then the only use for spin-locks would be as a guard for the more-<br>sophisticated sleep-locks.</p>
<p>Hold your horses! It’s not that easy. Sleep-locks leave interrupts enabled, so<br>they can’t be used in interrupt handler functions, or inside a critical section<br>where a spin-lock is being used, since interrupts will be disabled (though spin-<br>locks can be used inside sleep-lock critical sections). They also can’t be used<br>by kernel threads like the scheduler, since those aren’t processes and thus<br>can’t be put to sleep.</p>
<p>Finally, there are some situations in which a sleep-lock might actually add<br><em>more</em> overhead than a spin-lock: it takes some time to put a process to sleep,<br>schedule another process, send a wakeup call, schedule the first process again,<br>and so on, and the process will hold the sleep-lock the entire time. If another<br>process is waiting on the sleep-lock, it might actually end up waiting longer<br>than with a spin-lock, although it’ll wait in a sleeping state instead of a<br>running state where it just spins in a loop.</p>
<p>Additionally, sleep-locks can only be used when it’s safe to interrupt a process<br>in the middle of a critical section and wake it up later. Sure, no other process<br>can acquire the sleep-lock in the meantime, but it’s still not great for time-<br>sensitive operations like getting the current number of <code>ticks</code>.</p>
<p>So sleep-locks are great, but their applications are more limited than spin-<br>locks. The perfect use for them is when a process needs to complete an operation<br>atomically, but that operation itself might take a very long time. A great<br>example of that is disk I&#x2F;O, and we’ll see next how xv6 puts them to use in its<br>file system implementation.</p>
<h1 id="Devices-Disk-Driver"><a href="#Devices-Disk-Driver" class="headerlink" title="Devices: Disk Driver"></a>Devices: Disk Driver</h1><p>At this point, we’ve seen how xv6 virtualizes memory and the processor to give<br>each user process the illusion of a contiguous, near-infinite memory space and a<br>dedicated CPU to run it; we’ve also seen how xv6 mediates interactions between<br>most of a computer’s hardware components and user processes via system calls.<br>But there’s one more piece of hardware that’s critically important for an OS<br>that we haven’t looked at yet: the disk. All that’s left in the kernel code for<br>us to look at is how xv6 manages data storage on the disk and how it presents<br>that data to users in a simplified way.</p>
<p>The function of a disk is to provide <em>persistence</em> for an operating system. RAM<br>is volatile memory: it gets erased when the machine is turned off, so any data<br>stored there is fleeting. A disk allows an OS to store and retrieve data across<br>shut-offs. The disk driver we’ll go over in this post allows the xv6 kernel<br>direct access to that device so it can read and write data to it.</p>
<p>But unlike other devices, a simple driver isn’t enough here. We don’t just need<br>to be able to read and write data; we’d like to present users with a simplified,<br>accessible framework to navigate that data. Imagine using a computer where you<br>had to specify which byte of the disk to read or write, then remember that<br>yourself in order to access it again later. It’s madness! Enter file systems;<br>“files” don’t really exist in any real sense on a disk, but the OS can provide<br>the illusion of discrete, individual files in order to simplify access to data.</p>
<p>We also need to make sure concurrent accesses of the same file don’t risk<br>corrupting the file (or even the entire file system). We need to separate out<br>kernel data (like the kernel code itself) from user data on the disk, so that a<br>malicious user process can’t just overwrite arbitrary kernel code. Finally,<br>there’s that oh-so-famous line about Unix systems, “everything is a file”. We’ll<br>need a way to present “everything” in the elegant abstraction of a file.</p>
<p>All of these abstractions and security checks will require far more code than a<br>simple driver to implement them, so before we go on to the driver, let’s check<br>out how xv6 will organize its file system to get a preview of what’s ahead.</p>
<h2 id="File-System-Organization"><a href="#File-System-Organization" class="headerlink" title="File System Organization"></a>File System Organization</h2><p>Laying the abstraction of a complete file system on top of a physical disk will<br>require several steps. xv6 does this using seven layers. From bottom (direct<br>hardware interaction) to top (user-facing code), they are:</p>
<ul>
<li>Disk driver: reads and writes blocks on an IDE hard drive.</li>
<li>Buffer cache: caches disk blocks in memory and synchronizes access to them.</li>
<li>Logging: provides atomic disk writes to mitigate the risk of a crash.</li>
<li>Inodes: turns disk blocks into individual files that the OS can manipulate.</li>
<li>Directories: creates a tree of named directories that contain other files.</li>
<li>Path names: provides hierarchical, human-readable path names in the directory tree structure.</li>
<li>File descriptors: abstracts OS resources like pipes and devices as files to provide a unified API for user programs.</li>
</ul>
<p>That’s a lot of work to do now, but it’ll pay off! The kernel will do all this<br>labor so that users are free to be lazy later on and can live in blissful<br>ignorance of the fact that their precious little files actually exist as nothing<br>but ones and zeroes in totally arbitrary locations on the disk.</p>
<p>Note that hard drives are usually divided into <em>sectors</em>, which are physical<br>divisions (originally referring to literal geometric sectors), traditionally of<br>512 bytes. Operating systems can then collect these into larger <em>blocks</em> which<br>are multiples of the sector size. xv6 uses 512-byte blocks for simplicity so<br>that the sector and block sizes match up; I’ll use the two terms interchangeably.</p>
<p>On the disk, block 0 usually contains the boot sector, so it’s not used by xv6<br>(but remember the Makefile – xv6 actually stores the boot loader and kernel<br>code on an entirely separate physical disk). Block 1 is called the <em>superblock</em><br>because it contains metadata about the file system like its total size, the size<br>of the log, the number of files, and their location on the disk. Then the log<br>starts at block 2 and on.</p>
<h2 id="buf-h"><a href="#buf-h" class="headerlink" title="buf.h"></a>buf.h</h2><p>If you’ve read any of the previous optional posts on device drivers, you know<br>that interacting directly with the hardware means all kinds of opaque code with<br>seemingly-arbitrary port I&#x2F;O and cryptic magic numbers. Drivers are also specific<br>to the actual (or virtual) hardware in the machine that xv6 will run on, so it<br>tends to be less useful for showing general OS concepts – hence why all the<br>other device driver posts were optional. That being said, the disk driver nicely<br>rounds out the rest of the file system code, so I recommend checking it out, but<br>if you’re short on time or bored with all the talk about hardware specs, feel<br>free to skip to the summary section below.</p>
<p>Reading and writing disk data is super slow, so the second layer in the file<br>system is the buffer cache, which will store copies of disk blocks in memory for<br>faster access. But we still have to read from the disk to create that buffer,<br>and we still have to write any modified data to the disk once we’re done, so<br>we still need a layer below the buffer cache to do that. That layer is the disk<br>driver; its purpose is to copy data from the disk to the in-memory cache and<br>vice versa. A single block is represented in the cache as a <code>struct buf</code>, defined<br>in <a href="https://github.com/mit-pdos/xv6-public/blob/master/buf.h">buf.h</a>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    uint dev;               <span class="comment">// device number</span></span><br><span class="line">    uint blockno;           <span class="comment">// block number (same as sector number)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span>  <span class="comment">// sleep-lock to protect buffer reads and writes</span></span><br><span class="line">    uint refcnt;            <span class="comment">// how many processes are using this buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span>       <span class="comment">// for use with buffer cache doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span>       <span class="comment">// for use with buffer cache doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span>      <span class="comment">// for use with disk driver queue</span></span><br><span class="line">    uchar data[BSIZE];      <span class="comment">// data stored in the buffer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_VALID 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_DIRTY 0x4</span></span><br></pre></td></tr></table></figure>

<p>The two constants defined at the bottom are used in the <code>flags</code> field; <code>B_VALID</code><br>indicates that a buffer has been read from disk and should accurately reflect<br>the sector’s contents on the disk, and <code>B_DIRTY</code> says we’ve modified the buffer<br>but haven’t yet updated the on-disk version of a file, so we need to write the<br>buffer to disk soon.</p>
<p>We’ll see later on that the buffer cache uses a doubly-linked list of buffers;<br>the <code>prev</code> and <code>next</code> fields are used there. However, the disk driver also<br>maintains its own queue of buffers that are waiting to be read from or written<br>to the disk; that’s implemented as a singly-linked list using the <code>qnext</code> field.</p>
<h2 id="ide-c"><a href="#ide-c" class="headerlink" title="ide.c"></a>ide.c</h2><p>We’ve already seen some code to read and write disk data in the <a href="boot.md">boot loader</a>;<br>I know it’s been a while, so you can check that out again if you want. We can’t<br>reuse the code there for a few reasons, though: (1) the boot loader has to be<br>compiled separately from the kernel, so we can’t access any of the functions<br>there, and (2) we need to store data in the buffer cache, so we can’t even copy-<br>paste the code we used before since the boot loader barely even knows what<br>memory is, let alone a buffer cache.</p>
<h3 id="ATA-Programmed-I-x2F-O-Mode"><a href="#ATA-Programmed-I-x2F-O-Mode" class="headerlink" title="ATA Programmed I&#x2F;O Mode"></a>ATA Programmed I&#x2F;O Mode</h3><p>Modern disk drivers usually talk to the disk via direct memory access (DMA), but<br>to keep things simple xv6 is just gonna talk to it with port I&#x2F;O. That’s much,<br>much slower, and it requires active participation by the CPU (which means it<br>can’t do anything else at the same time), but hey, xv6 thinks it’s 1995,<br>remember? So PIO mode is still (relatively) cutting edge. Either way, extreme<br>performance isn’t the goal here, so we’ll just have to suck it up.</p>
<p>Okay, let’s do a super-quick summary. <code>inb</code> is a C wrapper for an x86 assembly<br>instruction that reads a single byte of data from a port; <code>outb</code> writes a byte<br>to a port. The disk controller chip has primary and secondary buses; the primary<br>bus sends data on port 0x1F0 and has control registers on ports 0x1F1 through<br>0x1F7. Port 0x1F7 doubles as a command register and a status port with some<br>useful flags we can check in order to know what the disk is up to; we saw some<br>of those before, but I’ll give you the full list now.</p>
<ul>
<li>Bit 0 (0x01) - ERR (indicates an error occurred)</li>
<li>Bit 1 (0x02) - IDX (index; always set to zero)</li>
<li>Bit 2 (0x04) - CORR (corrected data; always set to zero)</li>
<li>Bit 3 (0x08) - DRQ (drive has data to transfer or is ready to receive data)</li>
<li>Bit 4 (0x10) - SRV (service request)</li>
<li>Bit 5 (0x20) - DF (drive fault error)</li>
<li>Bit 6 (0x40) - RDY (ready; clear when drive isn’t running or after an error and set otherwise)</li>
<li>Bit 7 (0x80) - BSY (busy; drive is in the middle of sending&#x2F;receiving data)</li>
</ul>
<p>The disk driver defines some of these with preprocessor macros at the top of the<br>file.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECTOR_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_BSY     0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_DRDY    0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_DF      0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_ERR     0x01</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>We also saw one command example in the boot loader: sending 0x20 to port 0x1F7<br>tells the disk to read a sector and send it to us through data port 0x1F0. Now<br>we’ll also use commands to write a sector, as well as to read or write multiple<br>sectors at once.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_READ    0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_WRITE   0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_RDMUL   0xc4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_WRMUL   0xc5</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>If, for some reason beyond mortal comprehension, you decide you want to know<br>more about the eldritch secrets of ancient hard drives, you can read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/ATA-d1410r3a.pdf">this<br>resource on ATA disks</a>.</p>
<p>After those constants, we find three static global variables: a spin-lock for<br>accessing the disk, the queue of buffers waiting to be synchronized with their<br>on-disk counterparts, and a boolean to track whether xv6 is running with only<br>disk 0 (boot loader and kernel) or with disk 1 (user file system) as well.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">idelock</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">idequeue</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> havedisk1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="idewait"><a href="#idewait" class="headerlink" title="idewait"></a>idewait</h3><p>This function takes an integer <code>checkerr</code> argument that should be a boolean and<br>waits for the disk to be ready to receive more commands. If <code>checkerr</code> is true,<br>it’ll also check whether the status port includes any error flags.</p>
<p>It starts by reading from the disk’s status port and looping until the busy<br>flag is not set but the ready flag is. The bitwise-OR <code>IDE_BSY | IDE_DRDY</code><br>combines both flags, and the bitwise-AND tests whether either one is set in <code>r</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">idewait</span><span class="params">(<span class="type">int</span> checkerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (((r = inb(<span class="number">0x1f7</span>)) &amp; (IDE_BSY | IDE_DRDY)) != IDE_DRDY)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now if <code>checkerr</code> is nonzero we have to check that neither the error nor the<br>drive failure flag is set in the status port. If either one is set, we’ll return<br>-1; we’ll return 0 otherwise.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">idewait</span><span class="params">(<span class="type">int</span> checkerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (checkerr &amp;&amp; (r &amp; (IDE_DF | IDE_ERR)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ideinit"><a href="#ideinit" class="headerlink" title="ideinit"></a>ideinit</h3><p>This function is called by the kernel’s <code>main()</code> during set-up to initialize the<br>disk. We start by initializing the disk lock, then tell the I&#x2F;O interrupt<br>controller to forward all disk interrupts to the last CPU. We talked about the<br><code>ioapicenable()</code> function in detail in the post on interrupt controllers.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;idelock, <span class="string">&quot;ide&quot;</span>);</span><br><span class="line">    ioapicenable(IRQ_IDE, ncpu - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we wait for the disk to be ready to accept commands (ignoring any error<br>flags that may be present).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    idewait(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We said above that disk 0 should contain the boot loader and kernel, so we can<br>assume any machine running xv6 should have that present. However, we need to<br>make sure disk 1 is present; the<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a> includes<br>some configurations like <code>make qemu-memfs</code> under which xv6 can run without a<br>dedicated disk for the file system, storing files in memory instead.</p>
<p>Port 0x1F6 is used to select a drive. Bits 5 and 7 should always be set, and bit<br>6 picks the right mode we need to indicate a disk. Bit 4 determines whether we<br>want to select disk 0 or disk 1. So we can select drive 1 by setting bits 5-7<br>(0xE0 when combined), then bit 4 (<code>1 &lt;&lt; 4</code>).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to wait for disk 1 to be ready; we need to handle this as a special<br>case since <code>waitdisk()</code> can’t check a specific disk for us, and because an<br>absent disk 1 would make the while loop there continue forever. So we’ll check<br>the status register 1000 times; if it ever reports that it’s ready, we’ll set<br><code>havedisk1</code> to true and break, but otherwise we’ll assume disk 1 isn’t present<br>and leave <code>havedisk1</code> as zero (i.e., false).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inb(<span class="number">0x1f7</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            havedisk1 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll switch back to using disk 0 by changing the fourth bit of the<br>register at port 0x1F6.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">0</span> &lt;&lt; <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="idestart"><a href="#idestart" class="headerlink" title="idestart"></a>idestart</h3><p>This is the core function that will read or write a buffer to or from the disk.<br>It’s a <code>static</code> function, so it can only be called by other functions in this<br>file; <code>ideintr()</code> and <code>iderw()</code> will both use it as a helper function. It takes<br>a pointer to a buffer, so the first thing to do is make sure that pointer isn’t<br>null. We’ll also make sure the buffer’s block number is within the maximum limit<br>set by <code>FSSIZE</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 1000.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;blockno &gt;= FSSIZE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;incorrect blockno&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to figure out which disk sector to read from or write to. Since xv6<br>uses blocks that are the same size as a sector, this should just be <code>b-&gt;blockno</code>,<br>but we’ll add a conversion here in case that gets changed later on (especially<br>if we want higher disk throughput).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> sector_per_block = BSIZE / SECTOR_SIZE;</span><br><span class="line">    <span class="type">int</span> sector = b-&gt;blockno * sector_per_block;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If each block fits exactly one sector, then we’ll need to use the single-sector<br>read and write commands; otherwise we should use the multi-sector versions of<br>those commands. We’ll set <code>read_cmd</code> and <code>write_cmd</code> to the right versions.<br>We’ll also make sure that there are no more than 7 sectors per block.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> read_cmd = (sector_per_block == <span class="number">1</span>) ? IDE_CMD_READ : IDE_CMD_RDMUL;</span><br><span class="line">    <span class="type">int</span> write_cmd = (sector_per_block == <span class="number">1</span>) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;</span><br><span class="line">    <span class="keyword">if</span> (sector_per_block &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s wait for the disk to be ready, ignoring any error flags.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    idewait(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s time to brace yourself, because this next part is a hot mess of<br>port I&#x2F;O operations with lots of magic numbers. First we’ll tell the disk<br>controller to generate an interrupt once it’s done reading or writing by setting<br>the device control register at 0x3F6 to zero. Then we’ll tell it how many total<br>sectors we want to read or write by writing that number (AKA <code>sector_per_block</code>)<br>to port 0x1F2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x3f6</span>, <span class="number">0</span>);                 <span class="comment">// generate interrupt when done</span></span><br><span class="line">    outb(<span class="number">0x1f2</span>, sector_per_block);  <span class="comment">// number of sectors to read/write</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Before sending the read or write command, we have to tell the disk which sector<br>to read from, using our <code>sector</code> variable from above. Let’s take a second to<br>talk about hard drive geometry. A hard drive consists of a bunch of stacked<br>circular surfaces, where each surface has a corresponding <em>head</em> that changes<br>its position to read or write from the right place on the disk. Each surface has<br>a number of <em>tracks</em>: concentric circles that contain data. If you pick a track<br>number (i.e. pick a distance from the center of the surfaces) and collect all<br>those tracks from all the surfaces, you get a <em>cylinder</em>.</p>
<p>A sector number acts as a kind of address with each part specifying a different<br>geometric component, similar to how linear addresses contain a page directory<br>index, page table index, and offset. The eight most significant bits (24 through<br>31) identify the drive and&#x2F;or head that the sector is located on (plus some<br>flags); bits 8 through 23 identify the cylinder, and bits 0 through 7 pick a<br>sector within that cylinder. Altogether, these define a 3D coordinate system<br>that uniquely identifies all sectors on a machine’s disks.</p>
<p>Port 0x1F3 is the sector number register, ports 0x1F4 and 0x1F5 are the cylinder<br>low and high registers, and port 0x1F6 is the drive&#x2F;head register. We can write<br>the sector number as <code>sector &amp; 0xFF</code>; the cylinder low and high numbers can be<br>recovered by bitshifting <code>sector</code> down by 8 and 16, respectively.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f3</span>, sector &amp; <span class="number">0xff</span>);             <span class="comment">// sector number</span></span><br><span class="line">    outb(<span class="number">0x1f4</span>, (sector &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);      <span class="comment">// cylinder low</span></span><br><span class="line">    outb(<span class="number">0x1f5</span>, (sector &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);     <span class="comment">// cylinder high</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now for the drive&#x2F;head register, we’ll use <code>b-&gt;dev</code> to get the block’s device<br>and <code>(sector &gt;&gt; 24)</code> to get the head it’s on. Finally, we’ll set bits 5-7 as<br>required (and as mentioned above in <code>ideinit()</code>) with 0xE0. Then we can<br>bitwise-OR all of these together and write them to port 0x1F6.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | ((b-&gt;dev &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>) | ((sector &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0f</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, that was the worst of it! Deep breath now. The last part is just sending<br>the actual read or write command. But how do we know which one we’re supposed to<br>do? The only argument is a pointer to a buffer <code>b</code>, not any sort of boolean that<br>might tell us which to carry out. Well, remember the buffer flag <code>B_DIRTY</code>? That<br>one indicates that a buffer has been modified and needs to be written to disk.<br>If that flag is set, reading from the disk would overwrite any changes, which<br>probably isn’t what we want. So let’s just assume that the <code>B_DIRTY</code> flag means<br>we should write to disk, and the absence of that flag means we should read from<br>disk.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;flags &amp; B_DIRTY) &#123;</span><br><span class="line">        outb(<span class="number">0x1f7</span>, write_cmd);</span><br><span class="line">        outsl(<span class="number">0x1f0</span>, b-&gt;data, BSIZE / <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outb(<span class="number">0x1f7</span>, read_cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here <code>outsl()</code> is another C wrapper for an x86 instruction; this one writes data<br>from a string, four bytes at a time.</p>
<p>That’s it! This is by far the most cryptic function in the disk driver; the last<br>two are relatively easy now.</p>
<h3 id="ideintr"><a href="#ideintr" class="headerlink" title="ideintr"></a>ideintr</h3><p>We saw in <code>idestart()</code> that we set up the disk to send an interrupt whenever<br>it’s done reading or writing data. Back when we looked at<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/trap.c">trap.c</a>, we saw that<br>the <code>trap()</code> function directs all disk interrupts to the handler function<br><code>ideintr()</code>. It’s time to check that one out now.</p>
<p>We’ll start by acquiring the disk’s spin-lock; note that we don’t use a sleep-<br>lock because this is an interrupt handler function, so interrupts should be<br>disabled while it runs.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;idelock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we got an interrupt, then it usually means the disk is done with the most<br>recent request. Those requests are stored in the global <code>idequeue</code> linked list,<br>with the current request at the front of the queue. So we’ll get the head of the<br>queue as <code>b</code>, then set <code>idequeue</code> to point to the next buffer in the queue. If<br>the head is null, then we’ll just return early.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((b = idequeue) == <span class="number">0</span>) &#123;</span><br><span class="line">        release(&amp;idelock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idequeue = b-&gt;next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The read command in <code>idestart()</code> didn’t specify where to read the data to, so we<br>do that now. We’ll check if the <code>B_DIRTY</code> flag was set; if it wasn’t (i.e. the<br>operation was a disk read), then we’ll wait for the disk to be ready (without<br>any errors, using <code>idewait(1)</code> instead of <code>idewait(0)</code> as we have before) and<br>read the data into <code>b-&gt;data</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(b-&gt;flags &amp; B_DIRTY) &amp;&amp; idewait(<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        insl(<span class="number">0x1f0</span>, b-&gt;data, BSIZE / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we set the <code>B_VALID</code> flag with a bitwise-OR and clear any <code>B_DIRTY</code> flag<br>with a bitwise-AND and a bitwise-NOT. Then we’ll wake up any user process that<br>went to sleep on a channel for this buffer after requesting a disk I&#x2F;O operation.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b-&gt;flags |= B_VALID;</span><br><span class="line">    b-&gt;flags &amp;= ~B_DIRTY;</span><br><span class="line">    wakeup(b);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll get the disk started on the next operation, for the next buffer<br>in the queue.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (idequeue != <span class="number">0</span>) &#123;</span><br><span class="line">        idestart(idequeue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iderw"><a href="#iderw" class="headerlink" title="iderw"></a>iderw</h3><p>The <code>idestart()</code> function is <code>static</code>, so it can’t be called by anything outside<br>of this file; we need to provide a mechanism for both kernel and user threads to<br>read and write disk data. That’s what <code>iderw()</code> does. Note that processes should<br>never call this function directly; it only gets called by the code for the<br>buffer cache layer of the file system. In other words, processes will use system<br>calls like <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>, etc., which in turn will<br>use functions from higher layers of abstraction, which in turn call functions<br>from lower layers, and so on, until they reach the buffer cache, which calls<br><code>iderw()</code> to finally read&#x2F;write directly from&#x2F;to the disk.</p>
<p>By the time a process gets to <code>iderw()</code>, it should already be holding a sleep-<br>lock <code>b-&gt;lock</code> for the buffer <code>b</code> it wants to read or write, and either the<br><code>B_DIRTY</code> flag should be set (to write to disk) or the <code>B_VALID</code> flag should be<br>absent (to read from disk). We’ll start off with some sanity checks for those,<br>and make sure that we’re not trying to read from disk 1 if it’s not present on<br>this machine. Then we’ll acquire the disk’s spin-lock.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;iderw: buf not locked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((b-&gt;flags &amp; (B_VALID | B_DIRTY)) == B_VALID) &#123;</span><br><span class="line">        <span class="comment">// B_VALID is set, so we don&#x27;t need to read it; B_DIRTY is not set, so</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to write it</span></span><br><span class="line">        panic(<span class="string">&quot;iderw: nothing to do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev != <span class="number">0</span> &amp;&amp; !havedisk1) &#123;</span><br><span class="line">        panic(<span class="string">&quot;iderw: ide disk 1 not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;idelock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There may be other buffers waiting in line in the disk queue, so we have to<br>append this buffer <code>b</code> to the end of <code>idequeue</code>. We can do that by setting<br><code>b-&gt;qnext</code> to null, then creating a variable <code>pp</code> to traverse the entire queue.<br>When <code>pp</code> points to the last element, we’ll set its <code>qnext</code> field to point to<br><code>b</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b-&gt;qnext = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse the queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> **<span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (pp = &amp;idequeue; *pp; pp = &amp;(*pp)-&gt;qnext)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append b to end of queue</span></span><br><span class="line">    *pp = b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That traversal might look confusing as all hell, so let’s take a closer look.<br>It defines <code>pp</code> as a double pointer: a pointer to a pointer to a <code>struct buf</code>.<br>(If you’ve seen the interview of Linus Torvalds where he talks about good style<br>with linked lists, it’s similar to the code there; there’s a nice summary<br><a href="https://github.com/mkirchner/linked-list-good-taste">here</a>.) <code>pp</code> starts off<br>equal pointing to <code>idequeue</code>, i.e. the head of the linked list. Each iteration<br>checks that <code>pp</code> points to a valid (non-null) pointer, i.e. the loop will end<br>when we reach the end of the list. The body of the loop is empty, so none of the<br>iterations actually do anything; the purpose of the for loop is just to update<br><code>pp</code> several times. At the end of each iteration, <code>pp</code> is updated to point to a<br>pointer to the next buffer in the queue.</p>
<p>Suppose the last buffer in the queue is <code>end</code>. At the end of the for loop, <code>pp</code><br>will hold the address of <code>end-&gt;qnext</code>, so <code>*pp = b</code> sets <code>end-&gt;qnext = b</code>. The<br>double indirection makes it easy to update the last buffer in the queue; without<br>it, we would have to stop the loop one step earlier when <code>pp</code> points to <code>end</code><br>instead of <code>end-&gt;qnext</code> then be careful to update the actual buffer at the end<br>of the queue instead of just updating the local variable <code>pp</code>. All in all, it’s<br>just an elegant way to write a linked list traversal in a single line.</p>
<p>Okay, so now our buffer <code>b</code> is at the end of the queue. If there are others in<br>front of it, then <code>ideintr()</code> will make sure that each disk interrupt starts the<br>disk on the next operation. But what if <code>b</code> is actually the only buffer in the<br>queue? In that case, the disk isn’t running yet, so we need to get it started<br>ourselves.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (idequeue == b) &#123;</span><br><span class="line">        idestart(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At this point, we can be confident that the disk will either start our request<br>now or get to it eventually (if there are other requests in the queue). This<br>process just has to wait for the disk to finish, so we’ll put it to sleep until<br>the buffer has been synchronized with the disk. We’ll check that by making sure<br>the <code>B_VALID</code> flag is present but <code>B_DIRTY</code> is not set. The call to <code>sleep()</code><br>will release <code>idelock</code> and reacquire it before returning.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> ((b-&gt;flags &amp; (B_VALID | B_DIRTY)) != B_VALID) &#123;</span><br><span class="line">        sleep(b, &amp;idelock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-12"><a href="#Summary-12" class="headerlink" title="Summary"></a>Summary</h2><p>The disk driver handles direct communication with the hard drive, issuing orders<br>to read or write sectors. It exposes two API functions, <code>ideintr()</code> and<br><code>iderw()</code>. The former is called by <code>trap()</code> to handle disk interrupts, while the<br>latter is called by the code for the buffer cache layer of the file system to<br>update blocks in the buffer cache with their corresponding sectors on disk. Next<br>up we’ll look at the buffer cache itself, as well as the logging layer, which<br>provides crash recovery.</p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>使用VSCode阅读Linux Kernel</title>
    <url>/2023/05/29/%E4%BD%BF%E7%94%A8VSCode%E9%98%85%E8%AF%BBLinux-Kernel/</url>
    <content><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/558286384">使用VSCode进行linux内核代码阅读和开发</a></p>
<p><a href="https://blog.csdn.net/tanxjian/article/details/128885803">VScode 结合clangd 构建linux源代码阅读环境</a></p>
<p>安装kernel编译环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>

<p>安装bear</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install bear</span><br></pre></td></tr></table></figure>

<p>使用bear编译kernel，生成compile_commands.json，参考：<a href="https://forums.100ask.net/t/topic/1656/2">Ubuntu22 直接 make 内核成功，但不能使用 bear 命令</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bear -- make -j4</span><br></pre></td></tr></table></figure>

<p>在编译Kernel的源代码环境安装clangd服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install clangd</span><br></pre></td></tr></table></figure>

<p>在查看代码的环境安装clangd客户端(即VSCode的clangd插件)，一般通过windows机器的VSCode SSH连接Linux的clangd服务，因此需要将VSCode的remote SSH登陆到Linux机器（注意不要同时使用Xshell等其他SSH工具，否则VSCode remote SSH连不上）</p>
<p>VSCode remote SSH中打开代码后，clangd自动indexing(完成Kernel index需要相当长时间)，CTRL+鼠标左键查看定义，ALT+左键头返回跳转</p>
<p>clangd方式可以很方便找到C函数指针的实现，而VSCode的C++ intellisense跳转不到</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ArchLinux安装和配置笔记</title>
    <url>/2023/07/12/ArchLinux%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近Debian12发布，尝鲜在移动硬盘装了Debian12+KDE，但不习惯Debian繁琐的PPA包管理，也不喜欢Ubuntu越来越商业化的行为，最终切换到ArchLinux，进入Pacman和AUR的包管理和滚动更新风格。此文记录ArchLinux安装配置过程。</p>
<h2 id="构建多系统的U盘启动盘"><a href="#构建多系统的U盘启动盘" class="headerlink" title="构建多系统的U盘启动盘"></a>构建多系统的U盘启动盘</h2><p>使用<a href="https://www.ventoy.net/en/doc_start.html">ventoy&#x2F;Start to use Ventoy</a>，将各系统镜像放到Ventoy目录即可，不需要用传统的UltraISO那种一个系统ISO要占用整个U盘。<br>Arch Linux的ISO<a href="https://archlinux.org/download/">在此下载</a></p>
<h2 id="使用archinstall安装ArchLinux"><a href="#使用archinstall安装ArchLinux" class="headerlink" title="使用archinstall安装ArchLinux"></a>使用archinstall安装ArchLinux</h2><p><a href="https://wiki.archlinux.org/title/Installation_guide">传统的ArchLinux安装方式</a>过于繁琐，现在Arch Linux安装包提供一个类GUI的脚本<a href="https://wiki.archlinux.org/title/Archinstall">archinstall</a>，按需求配置即可，可以一键处理包括KDE&#x2F;GNOME&#x2F;I3W等桌面在内的全部安装过程。</p>
<p>参考 <a href="https://www.linuxmi.com/archinstall-auto-arch-linux.html">使用 archinstall 自动化脚本安装 Arch Linux 完整指南</a>，<a href="https://u.sb/archlinux-archinstall/">使用 archinstall 安装 Arch Linux 和 KDE 桌面环境</a>。</p>
<p>我的配置如下。Profile选择安装desktop Kde, Network选择Use NetworkManager后，Kde Plasma被自动安装，不需要按参考文章手动安装桌面：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307121642425.png" alt="image-20230712164243209"></p>
<h2 id="中文显示和中文输入法"><a href="#中文显示和中文输入法" class="headerlink" title="中文显示和中文输入法"></a>中文显示和中文输入法</h2><p>打开网页有中文乱码（方框），需要安装noto-fonts相关字体包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br></pre></td></tr></table></figure>

<p>安装中文输入法框架（包含pinyin输入法）并配置fcitx5，具体含义参考 <a href="https://wiki.archlinux.org/title/Input_method">Input method</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im fcitx5-chinese-addons  fcitx5-rime</span><br></pre></td></tr></table></figure>
<p>在desktop environment配置fcitx:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/environment</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>

<p>重启，按 <code>Win</code> 键搜索 <code>Input Method</code>, 点击 <code>Add Input Method...</code>搜索 <code>pinyin</code> 然后添加，按 <code>Ctrl</code> + <code>空格</code>可切换输入法</p>
<h2 id="安装yay以使用AUR"><a href="#安装yay以使用AUR" class="headerlink" title="安装yay以使用AUR"></a>安装yay以使用AUR</h2><p><a href="https://aur.archlinux.org/packages/yay">yay</a>: Yet another yogurt. Pacman wrapper and AUR helper written in go.</p>
<p>yay的安装参考: <a href="https://www.debugpoint.com/install-yay-arch/">How to Install yay AUR Helper in Arch Linux [Beginner’s Guide]</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S base-devel git</span><br><span class="line">cd /opt</span><br><span class="line">sudo git clone https://aur.archlinux.org/yay.git</span><br><span class="line">cd yay</span><br><span class="line">sudo chown -R 用户名:users .   #必须修改yay目录的owner, yay不能被sudo编译</span><br><span class="line">makepkg -si  #编译yay</span><br></pre></td></tr></table></figure>

<h2 id="Go语言包换源"><a href="#Go语言包换源" class="headerlink" title="Go语言包换源"></a>Go语言包换源</h2><p>安装yay时makepkg会显示go包安装timeout, 需要换国内源 <a href="https://goproxy.cn/">goprixy.cn</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#临时生效</span><br><span class="line">$ export GO111MODULE=on</span><br><span class="line">$ export GOPROXY=https://goproxy.cn</span><br><span class="line"></span><br><span class="line">#永久生效</span><br><span class="line">$ echo &quot;export GO111MODULE=on&quot; &gt;&gt; ~/.profile</span><br><span class="line">$ echo &quot;export GOPROXY=https://goproxy.cn&quot; &gt;&gt; ~/.profile</span><br><span class="line">$ source ~/.profile</span><br></pre></td></tr></table></figure>

<h2 id="pacman-x2F-yay换源"><a href="#pacman-x2F-yay换源" class="headerlink" title="pacman&#x2F;yay换源"></a>pacman&#x2F;yay换源</h2><p>在archinstall时如果Mirror region选择China，则默认使用官方提供的China源，见&#x2F;etc&#x2F;pacman.conf的[core&#x2F;extra]字段都版本了&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist. </p>
<p>但官方源速度有时很慢，建议手动添加<a href="https://mirrors.tuna.tsinghua.edu.cn/help/archlinuxcn/">archlinuxcn源</a>，如果包在国内源有的话，yay速度直接起飞</p>
<p>有网上建议生成aur配置文件换国内源：<code>yay --aururl “https://aur.tuna.tsinghua.edu.cn” --save</code> 此处不建议，如果国内源没有的包将无法下载；换回官方源：<code>yay --aururl &quot;https://aur.archlinux.org&quot; --save</code>，并删除yay源配置文件<code>~/.config/yay/config.json</code></p>
<h2 id="yay常用命令"><a href="#yay常用命令" class="headerlink" title="yay常用命令"></a>yay常用命令</h2><p>从仓库和 AUR 中交互式搜索和安装软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay &#123;&#123;软件包|搜索词&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>同步并更新所有来自仓库和 AUR 的软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay</span><br></pre></td></tr></table></figure>

<p>从仓库和 AUR 中安装一个新的软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -S &#123;&#123;软件包&#125;&#125;</span><br><span class="line">yay -Sy &#123;&#123;软件包&#125;&#125; #默认yes</span><br></pre></td></tr></table></figure>

<p>从仓库和 AUR 中搜索软件包数据库中的关键词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -Ss &#123;&#123;关键词&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>显示已安装软件包和系统健康状况的统计数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -Ps</span><br></pre></td></tr></table></figure>
<p>卸载包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -R </span><br></pre></td></tr></table></figure>

<h2 id="pacman更新系统"><a href="#pacman更新系统" class="headerlink" title="pacman更新系统"></a>pacman更新系统</h2><p>更新所有安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syu #仅更新</span><br><span class="line">sudo pacman -Syyu #如果系统有损坏包，能覆盖下载</span><br></pre></td></tr></table></figure>

<h2 id="Host-DNS设置"><a href="#Host-DNS设置" class="headerlink" title="Host DNS设置"></a>Host DNS设置</h2><p>NetworkManager会自动配置DNS域名解析文件&#x2F;etc&#x2F;resolv.conf，且手动修改的内容每次重启会被NetworkManager覆盖。</p>
<p>如果要手动配置，参考 <a href="https://wiki.archlinux.org/title/NetworkManager">&#x2F;etc&#x2F;resolv.conf</a>，设置dns.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/NetworkManager/conf.d/dns.conf</span><br><span class="line">[main]</span><br><span class="line">dns=none</span><br></pre></td></tr></table></figure>

<h2 id="KDE-Discover显示unable-to-load-applications"><a href="#KDE-Discover显示unable-to-load-applications" class="headerlink" title="KDE Discover显示unable to load applications"></a>KDE Discover显示unable to load applications</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S packagekit-qt5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>windows coredump的配置和测试</title>
    <url>/2023/07/24/windows-coredump%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>在存储设备的windows系统环境下调试时，因为存储设备本身的问题，有时候coredump不能成功生成到系统目录，本文记录如何修改coredump路径，以及用键盘测试coredump生成符合预期。</p>
<h2 id="使能windows的coredump"><a href="#使能windows的coredump" class="headerlink" title="使能windows的coredump"></a>使能windows的coredump</h2><p><a href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/debugger/enabling-a-kernel-mode-dump-file">Enabling a Kernel-Mode Dump File</a></p>
<h2 id="修改coredump路径"><a href="#修改coredump路径" class="headerlink" title="修改coredump路径"></a>修改coredump路径</h2><p><a href="https://learn.microsoft.com/zh-cn/troubleshoot/windows-server/performance/memory-dump-file-options">Windows 的内存转储文件选项概述</a></p>
<p>可以修改注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\CrashControl</code>的DumpFile键值对，默认路径%SystemRoot%在cmd echo出来是”C:&quot;, 修改为指定路径例如”E:\Memory.dmp”。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241555783.png" alt="image-20230724155525547"></p>
<p>此操作也可以在控制面板完成，两者等效。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241555568.PNG" alt="crashcontrol2"></p>
<h2 id="使用键盘手动生成coredump"><a href="#使用键盘手动生成coredump" class="headerlink" title="使用键盘手动生成coredump"></a>使用键盘手动生成coredump</h2><p><a href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/debugger/forcing-a-system-crash-from-the-keyboard">Forcing a system crash from the keyboard</a></p>
<p>以USB keyboards为例：</p>
<p>修改注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\kbdhid\Parameters</code>，创建CrashOnCtrlScroll &#x3D; 0x01，重启后“Hold down the rightmost CTRL key, and press the SCROLL LOCK key twice.”系统会直接蓝屏，重启即可查看coredump文件。如果用windbg查看KeBugCheck查看错误码是0xE2: MANUALLY_INITIATED_CRASH。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241554830.png" alt="image-20230724155442525"></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux driver常用调试技术记录</title>
    <url>/2023/08/02/Linux-driver%E9%80%9A%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Printk"><a href="#Printk" class="headerlink" title="Printk"></a>Printk</h2><p>printk参考Kernel document: <a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/core-api/printk-basics.html">使用printk记录消息</a></p>
<h3 id="1-printk的基础用法"><a href="#1-printk的基础用法" class="headerlink" title="(1)printk的基础用法"></a>(1)printk的基础用法</h3><p>常用示例如下，一般是手动添加打印代码时使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step1: 例如要打印当前函数被调用，添加pr_info(&quot;%s\n&quot;, __FUNCTION__)</span><br><span class="line">step2: echo 7 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p><strong>Tips1: 非root用户不能成功执行<code>sudo echo 7 &gt; /proc/sys/kernel/printk</code>，显示permission denied</strong></p>
<p>原因：因为sudo仅让echo按root权限执行，没有让&gt;按root权限执行</p>
<p>解决办法一：dmesg配置printk级别：<code>sudo dmesg -n 7</code></p>
<p>解决办法二：解决任何sudo echo写入的权限问题：</p>
<p><code>sudo sh -c &quot;cmd&quot;</code>，让bash将整个cmd字符串当一个命令执行，并赋予root权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo 7 &gt; /proc/sys/kernel/printk&quot;</span><br></pre></td></tr></table></figure>

<p>再<code>cat /proc/sys/kernel/printk</code>可见printk已变成7,4,1,7(默认是4,4,1,7)</p>
<p><strong>Tips2: (printk持久化)系统启动自动设置打印级别：</strong></p>
<p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk每次启动后都恢复为默认值4,4,1,7，要系统启动时自动配置7,4,1,7，在&#x2F;etc&#x2F;sysctl.conf添加如下内容即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel.printk = 7 4 1 7</span><br></pre></td></tr></table></figure>

<p><strong>如果要观测系统启动中的driver debug打印，必须配置kernel.printk</strong></p>
<p><strong>如果要观测系统启动后的driver debug打印，建议使用dmesg -n修改printk</strong></p>
<h3 id="2-printk在driver-subsystem中的使用"><a href="#2-printk在driver-subsystem中的使用" class="headerlink" title="(2)printk在driver subsystem中的使用"></a>(2)printk在driver subsystem中的使用</h3><p>Linux driver子系统通常使用printk的封装版。以pci driver为例，pci driver代码已经提供了pci_dbg, pci_info, pci_err等打印函数，其不仅打印arg信息，也打印pci port设备信息，例如以下PCIe driver的log:</p>
<p>pcieport 0000:00:1b.4 显示了当前的PCIe port。如果有多个PCIe port的打印，可以区分是哪个port的打印输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   44.713266] pcieport 0000:00:1b.4: DPC: containment event, status:0x1f01 source:0x0000</span><br><span class="line">[   44.713268] pcieport 0000:00:1b.4: DPC: unmasked uncorrectable error detected</span><br><span class="line">[   44.713274] pcieport 0000:00:1b.4: PCIe Bus Error: severity=Uncorrected (Non-Fatal), type=Transaction Layer, (Receiver ID)</span><br><span class="line">[   44.713277] pcieport 0000:00:1b.4:   device [8086:43c4] error status/mask=00200000/00004000</span><br><span class="line">[   44.713280] pcieport 0000:00:1b.4:    [21] ACSViol                (First)</span><br></pre></td></tr></table></figure>

<p><strong>如何设置dev_info, dev_err:</strong></p>
<p>pci_info, pci_err的打开和pr_info, pr_err一致，只需要设置打印级别大于info&#x2F;err即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 7 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p>其他驱动模块的xxx_info, xxx_err也是一样</p>
<p><strong>如何设置dev_dbg:</strong></p>
<p>dev_dbg是比较特殊和最常用的打印方式，定义如下。</p>
<p>可见dev_dbg的开启依赖于两个条件：</p>
<ul>
<li><p>driver定义了CONFIG_DYNAMIC_DEBUG 或者 DEBUG 宏才能开启，一般使用DEBUG宏</p>
</li>
<li><p>printk级别需要为8（7为debug level, 8 &gt; debug level，才能开启debug打印）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#if defined(CONFIG_DYNAMIC_DEBUG) || \</span><br><span class="line">	(defined(CONFIG_DYNAMIC_DEBUG_CORE) &amp;&amp; defined(DYNAMIC_DEBUG_MODULE))</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">	dynamic_dev_dbg(dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="line">#elif defined(DEBUG)</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">	dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">(&#123;									\</span><br><span class="line">	if (0)								\</span><br><span class="line">		dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \</span><br><span class="line">&#125;)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>以pci_dbg为例(内部实现是dev_dbg)，要打开pci_dbg设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Kernel Makefile定义DEBUG宏，可以在driver/pci的Makefile定义，也可以在Kernel根目录Makefile定义：</span><br><span class="line"></span><br><span class="line">方式一：DEBUG宏定义在KCFLAG，即编译此目录的任何driver .o, .ko都定义了DEBUG宏</span><br><span class="line">KCFLAGS += -DDEBUG </span><br><span class="line"></span><br><span class="line">方式二：DEBUG宏定义在某一个driver模块，即编译此模块时定义了DEBUG宏，例如</span><br><span class="line">obj-$&#123;CONFIG_PCI&#125; += -DDEBUG </span><br></pre></td></tr></table></figure>

<p>以上是对任意Driver模块打开DEBUG宏的通用方法；实际上drivers&#x2F;pci已经定义了KCONFIG可选项如下，只需要make menuconfig时设置PCI_DEBUG &#x3D; y 即可对drivers&#x2F;pci的当前目录和子目录的模块编译都定义DEBUG宏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### Makefile:</span><br><span class="line">subdir-ccflags-$(CONFIG_PCI_DEBUG) := -DDEBUG</span><br><span class="line"></span><br><span class="line">### Kconfig:</span><br><span class="line">config PCI_DEBUG</span><br><span class="line">	bool &quot;PCI Debugging&quot;</span><br><span class="line">	depends on DEBUG_KERNEL</span><br><span class="line">	help</span><br><span class="line">	  Say Y here if you want the PCI core to produce a bunch of debug</span><br><span class="line">	  messages to the system log.  Select this if you are having a</span><br><span class="line">	  problem with PCI support and want to see more of what is going on.</span><br><span class="line"></span><br><span class="line">	  When in doubt, say N.</span><br></pre></td></tr></table></figure>

<p>最后设置printk level大于DEBUG level：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 8 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p>此后dmesg可查看drivers&#x2F;pci下的所有pci_dbg都被打印（当然也包括pci_info, pci_err等）。</p>
<h2 id="make-menuconfig"><a href="#make-menuconfig" class="headerlink" title="make menuconfig"></a>make menuconfig</h2><h3 id="如何快速定位"><a href="#如何快速定位" class="headerlink" title="如何快速定位"></a>如何快速定位</h3><p>以PCIe driver为例，drivers&#x2F;pci的Makefile有以下CONFIG</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subdir-ccflags-$(CONFIG_PCI_DEBUG) := -DDEBUG</span><br></pre></td></tr></table></figure>

<p>现在make menuconfig时想快速定位CONFIG_PCI_DEBUG对应的位置再设置为y，定位操作如下：</p>
<p>step1: 输入<code>/</code> 打开查找，输入要查找的CONFIG名，注意这里不支持模糊匹配</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031201872.png" alt="Screenshot from 2023-08-03 11-52-54"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031201364.png" alt="Screenshot from 2023-08-03 11-51-31"></p>
<p>step2: 按1跳转到CONFIG对应位置</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031202070.png" alt="Screenshot from 2023-08-03 11-51-55"></p>
<h3 id="直接修改-config文件"><a href="#直接修改-config文件" class="headerlink" title="直接修改.config文件"></a>直接修改.config文件</h3><p>make menuconfig本质是配置.config文件，可以手动修改CONFIG_XXX &#x3D; y&#x2F;m</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
