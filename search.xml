<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI编程 -- Cursor环境配置和简单使用</title>
    <url>/2024/08/30/AI%E7%BC%96%E7%A8%8B%20--%20Cursor%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Cursor-环境配置和简单使用"><a href="#Cursor-环境配置和简单使用" class="headerlink" title="Cursor 环境配置和简单使用"></a>Cursor 环境配置和简单使用</h1><h2 id="Cursor配置"><a href="#Cursor配置" class="headerlink" title="Cursor配置"></a>Cursor配置</h2><h3 id="free-trial续杯"><a href="#free-trial续杯" class="headerlink" title="free trial续杯"></a>free trial续杯</h3><p>Cursor website: <a href="https://www.cursor.com/">https://www.cursor.com</a></p>
<p>Cursor’s free trial for Pro(Premium models) has limitation for two weeks time and up to 500 request count. Use below steps to get more free-trial.</p>
<p>(1) In Account Setting, Detele wasted account, and re-register account with same email address. Log in Cursor desktop and 500 pro request is supported for more two weeks.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502261454158.png" alt="image-20250226145359068"></p>
<p>refer to guide: <a href="https://www.bilibili.com/video/BV1YAtReqEkH?spm_id_from=333.788.videopod.sections">https://www.bilibili.com/video/BV1YAtReqEkH?spm_id_from=333.788.videopod.sections</a></p>
<p>(2) After several times re-register account, Cursor record your PC’s MAC and refuse to re-register, use below tool to re-fresh MAC. </p>
<p><a href="https://github.com/yuaotian/go-cursor-help">https://github.com/yuaotian/go-cursor-help</a></p>
<h3 id="禁用更新"><a href="#禁用更新" class="headerlink" title="禁用更新"></a>禁用更新</h3><p>目前go-cursor-help可以适配到cursor4.7，需要禁用cursor自动更新到4.8以上版本</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091022177.png" alt="image-20250409102242119"></p>
<h2 id="Cursor使用方式"><a href="#Cursor使用方式" class="headerlink" title="Cursor使用方式"></a>Cursor使用方式</h2><h3 id="Chat"><a href="#Chat" class="headerlink" title="Chat"></a>Chat</h3><p>Chat is most used to analysis whole project code or partly code.</p>
<p>Use @codebase is better to make the AI engine think based on current code. otherwise it may give suggestions without context.</p>
<p>below is two examples:</p>
<p>(1)Analysis the project based on codebase.</p>
<p>Use CTRL+L to open chat, select AI model to claude-3.5 or 3.7(newer), write prompt based on codebase.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502261504728.png" alt="image-20250226150407616"></p>
<p>(2)Modifying partly function</p>
<p>Select some code to Chat, and ask what to do, you can apply the generated code. </p>
<p>If the code is wrong after test, you can reject the change like git diff GUI.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502261509413.png" alt="image-20250226150927338"></p>
<h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><p>Composer适用于创建新项目，不适用于对已有的项目局部修改，因为composer改动是跨文件的，composer模式经常会把已有项目写好的功能又改坏，建议多用git管理composer代码，调试现有项目使用Chat。</p>
<p>以下是composer创建WDF项目过程中的示例，对于AI给出的不靠谱的回答，需要用 @Web或者给定Specification document让AI反复确认。对于编译和调试问题也能让AI给出建议，但是尤其要注意AI对于windows driver这种开源资料较少的领域，给出的方案和建议有一定概率是错得离谱而且迷惑性很强。</p>
<p>（1）让AI根据Web资料修正设计</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502261520937.png" alt="image-20250226152037888"></p>
<p>（2）让AI根据报错信息给出调试建议</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502261521572.png" alt="image-20250226152110538"></p>
<h2 id="20250718模型禁用问题"><a href="#20250718模型禁用问题" class="headerlink" title="20250718模型禁用问题"></a>20250718模型禁用问题</h2><p>TB买学生pro一年账户登录后才有高级model，账户每月有最大请求限额约几百次，下月1号复位</p>
<p>model region限制解决：curor setting中 +梯子端口 +禁用HTTP2后可用。</p>
<p>梯子使用github free-proxy免费配clash端口，每天最多4小数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507181431265.png" alt="image-20250718143130155"></p>
]]></content>
      <categories>
        <category>AI编程</category>
      </categories>
      <tags>
        <tag>Cursor</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog配置 -- Picgo使用ImgurL图床支持国内访问</title>
    <url>/2025/06/02/Blog%E9%85%8D%E7%BD%AE%20--%20Picgo%E4%BD%BF%E7%94%A8ImgurL%E5%9B%BE%E5%BA%8A%E6%94%AF%E6%8C%81%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="Picgo使用ImgurL图床支持国内访问"><a href="#Picgo使用ImgurL图床支持国内访问" class="headerlink" title="Picgo使用ImgurL图床支持国内访问"></a>Picgo使用ImgurL图床支持国内访问</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前我的markdown文章图床是使用picgo+github图床，但是不搭梯子情况下图片无法访问，其他图床如SM.MS也不可用，阿里云之类的性价比低不可持续。使用cnblogs的话taste太差，综合考虑使用国内图床ImgURL(山寨Imgur)。记录环境搭建的一些问题。</p>
<h2 id="Picgo和插件的安装"><a href="#Picgo和插件的安装" class="headerlink" title="Picgo和插件的安装"></a>Picgo和插件的安装</h2><ol>
<li>前往Github：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a> 根据你的平台下载最新版本安装。</li>
<li>前往Node.js官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a> 下载最新版Node.js安装（PicGo插件需要）。</li>
<li>退出PicGo并重新打开，在插件设置中搜索“<a href="https://github.com/yuki-xin/picgo-plugin-web-uploader/releases/tag/v1.1.0">web-uploader</a>”插件进行安装，用于支持自定义图床。</li>
</ol>
<p>如果插件无法搜索到，可能是node环境问题或者GFW问题。下面使用npm命令行手动安装插件。</p>
<p>首先确认node npm环境正常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v #显示node.js版本 </span><br><span class="line">npm -v  #显示npm版本</span><br></pre></td></tr></table></figure>

<p><code>cd</code>进入到PicGO的数据目录，默认是：<code>C:\Users\{计算机用户名}\AppData\Roaming\picgo</code></p>
<p>npm换成淘宝的镜像源(必须)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p>安装web-uploader插件，插件格式都是picgo-plugin-&lt;插件名格式&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install picgo-plugin-web-uploader</span><br></pre></td></tr></table></figure>

<h2 id="ImgURL注册和获取API-Token"><a href="#ImgURL注册和获取API-Token" class="headerlink" title="ImgURL注册和获取API Token"></a>ImgURL注册和获取API Token</h2><p>在ImgURL注册账号：<a href="https://www.imgurl.org/vip/user">https://www.imgurl.org/vip/user</a></p>
<p>在ImgURL用户后台找到API地址&#x2F;UID&#x2F;Token三个参数</p>
<p>打开PicGo - 图床设置 - 自定义Web图床</p>
<ul>
<li><p>API地址：填写ImgURL的API地址，比如：<a href="http://imgurl.rss.ink/api/v2/upload">http://imgurl.rss.ink/api/v2/upload</a></p>
</li>
<li><p>POST参数名：填写file，为什么要这么写参考<a href="https://doc.xiaoz.org/books/imgurl-pro/page/api">ImgURL API文档</a></p>
</li>
<li><p>JSON路径：填写data.url，参考<a href="https://doc.xiaoz.org/books/imgurl-pro/page/api">ImgURL API文档</a></p>
</li>
<li><p>自定义Body：填写下面的json并修改引号内的值（保留引号）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script&#123;&quot;uid&quot;:&quot;your uid&quot;,&quot;token&quot;:&quot;your token&quot;&#125;</span><br><span class="line">your uid：改成ImgURL账户的UID</span><br><span class="line">your token：改成ImgURL账户的Token</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以将其设置为默认图床。</p>
<img src="https://s3.bmp.ovh/imgs/2025/10/21/fcee604750439188.png" alt="image-20251021131440638" style="zoom:80%;" />

<h2 id="测试图床"><a href="#测试图床" class="headerlink" title="测试图床"></a>测试图床</h2><p>Picgo手动上传图片，或者markdown右键粘贴图片，都能在图床后台看到则上传通道正常。</p>
<h2 id="配置图片压缩插件"><a href="#配置图片压缩插件" class="headerlink" title="配置图片压缩插件"></a>配置图片压缩插件</h2><p>图片压缩可以减少图床空间占用。</p>
<p>方式一：安装compress图片压缩插件（在picgo AppData数据目录命令行安装，使用阿里源）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\Users\cursorhu\AppData\Roaming\picgo</span><br><span class="line">npm install picgo-plugin-compress</span><br></pre></td></tr></table></figure>

<p>压缩算法基于TinyPNG网站，需要先在 <a href="https://tinypng.com/">tinyPNG</a>注册key，picgo再配置API key。</p>
<p>插件配置参考 <a href="https://www.npmjs.com/package/picgo-plugin-compress">picgo-plugin-compress</a>，注意插件设置一定要启用transformer，否则上传图片不压缩。</p>
<p>配置ok后上传测试，速度会变慢因为要压缩，imgURL图床后台看到相同图片压缩后减少了一半的大小；tinyPNG后台看到压缩次数计数（每月额度500）</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/10/21/57d0c3b34d7dddda.png" alt="image-20251021131136891"></p>
<p>方式二：安装compression插件，参考<a href="https://github.com/Redns/picgo-plugin-compression">picgo-plugin-compression</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install picgo-plugin-compression</span><br></pre></td></tr></table></figure>

<h2 id="配置图片水印插件"><a href="#配置图片水印插件" class="headerlink" title="配置图片水印插件"></a>配置图片水印插件</h2><p>图片水印用于文章防盗</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install picgo-plugin-watermark</span><br></pre></td></tr></table></figure>

<img src="https://s3.bmp.ovh/imgs/2025/10/21/37647b7817b137df.png" alt="image-20251021130442219" style="zoom:80%;" />

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.52txr.cn/2024/PicGOPlungs.html">如何优雅地安装PicGO插件？– 陶小桃blog</a></p>
<p><a href="https://www.fengjian.tech/2023/05/08/%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE/PicGo+ImgUrl/">PicGo + ImgUrl 图床 – 风间小栈</a></p>
<p><a href="https://blog.boringhex.top/posts/5b99230e1ed4/">picgo及其常用插件 – boringhex</a></p>
<p><a href="https://www.npmjs.com/package/picgo-plugin-compress">picgo-plugin-compress</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>picgo</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog配置 -- 搭建可移植的Markdown blog环境：Obsidian/Typora+PicGo+Hexo+Github</title>
    <url>/2022/02/28/Blog%E9%85%8D%E7%BD%AE%20--%20%E6%90%AD%E5%BB%BA%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84Markdown%20blog%E7%8E%AF%E5%A2%83%EF%BC%9AObsidianTypora+PicGo+Hexo+Github/</url>
    <content><![CDATA[<h1 id="搭建可移植的Markdown-blog环境：Obsidian-Typora-PicGo-Hexo-Github"><a href="#搭建可移植的Markdown-blog环境：Obsidian-Typora-PicGo-Hexo-Github" class="headerlink" title="搭建可移植的Markdown blog环境：Obsidian&#x2F;Typora+PicGo+Hexo+Github"></a>搭建可移植的Markdown blog环境：Obsidian&#x2F;Typora+PicGo+Hexo+Github</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>写技术笔记并发布博客，通常有以下方式：</p>
<ul>
<li>第三方平台CSDN&#x2F;cnblogs，最简单但是最不可控，例如写过如何使用shadow-sock直接被删掉，各种广告也不能忍。</li>
<li>使用云服务器自建Leanote博客系统，最大缺点是服务器续费太贵，且文章数据存在数据库很难导出，。</li>
<li>使用github+picgo+hexo， github作为图床和博客的云服务，picgo用于建立图床通道，hexo用于发布博客。缺点是github访问慢，用开源CDN可以很好解决；优点是全部免费，数据可移植(图片链接都在github图床)，可长期使用（只要github不倒闭不锁区）</li>
</ul>
<p>最终我选择github+picgo+hexo方案。<br>为什么不用gitee: gitee上传图片限制1M, github有25M。有了CDN, github的速度也不是问题</p>
<p>比较几个Markdown编辑器：</p>
<p>VSCode加Markdown插件：体验一般<br><a href="https://www.typora.io/">Typora</a>体验完美，但windows收费（Linux版不收费，Windows旧版不收费）<br><a href="https://obsidian.md/">Obsidian</a>免费，特性：</p>
<ul>
<li>支持动态渲染，即写出的Markdown语句自动显示预览</li>
<li>支持各种快捷键，无需手动输入Markdown语法格式（<a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法</a>）。比如标题，链接，列表，引用，可以设置标准的Markdown快捷键。</li>
<li>支持关联PicGo实现粘贴图片即上传到云端图床，这一点对于写作体验和文章的可迁移性很重要</li>
<li>特色的Zettelkasten笔记管理方法，本文不描述这部分，参考<a href="https://sspai.com/post/62414#!">玩转 Obsidian 01：打造知识循环利器</a></li>
</ul>
<h2 id="搭建可移植的Markdown写作环境"><a href="#搭建可移植的Markdown写作环境" class="headerlink" title="搭建可移植的Markdown写作环境"></a>搭建可移植的Markdown写作环境</h2><h2 id="Github-PicGo搭建图床"><a href="#Github-PicGo搭建图床" class="headerlink" title="Github+PicGo搭建图床"></a>Github+PicGo搭建图床</h2><h3 id="图床的用处"><a href="#图床的用处" class="headerlink" title="图床的用处"></a>图床的用处</h3><p>Markdown文档本身是可移植的，但是其图片资源不是, 因为图片不是以二进制嵌入文档，而只是个图片地址的链接。</p>
<p>如果只是在本地写写Markdown，完全不需要考虑图片的可移植，只需要存本地固定路径即可。<br>如果想在本地写Markdown，且这个文档拿到别的机器，或者放到博客论坛发布，别人都可以看到图片，就要一个云端的图片存储服务，即图床。</p>
<p>使用图床，就可以实现Markdown“一处写作，到处可见”。</p>
<h3 id="搭建Github图床，使用Picgo上传"><a href="#搭建Github图床，使用Picgo上传" class="headerlink" title="搭建Github图床，使用Picgo上传"></a>搭建Github图床，使用Picgo上传</h3><p>完整流程参考<a href="https://blog.csdn.net/yefcion/article/details/88412025">PicGo + GitHub 搭建个人图床工具</a></p>
<p>流程包含以下部分：</p>
<ul>
<li>一个public的Github仓库，用来存放文章链接的图片，注意单仓库最大容量1GB。</li>
<li>一个personal access token，用于PicGo免密访问github实现自动上传图片</li>
<li>一个图片上传工具：PicGo及其插件，用它上连Github图床仓库，下连本地markdown编辑器，实现“图片粘贴即上传”</li>
<li>一个CDN(推荐，很好用)：使用开源CDN jsdelivr加速Github访问，避免因访问速度造成图片上传失败</li>
</ul>
<p>最终我的配置如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281014786.png"></p>
<p>单元测试：<br>手动上传本地图片，如果上传成功，且图片可预览，则功能正常</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024870.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024344.png"></p>
<p>遇到的坑：<br>仓库名必须填&lt;用户名&gt;&lt;仓库名&gt;，不是完整的http或git仓库链接！否则上传图片error404</p>
<p>PicGo支持log调试，参考：<br><a href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html"><a href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html">PicGo上传图片到GitHub总是失败的特殊解决办法</a></a></p>
<p>2022&#x2F;5&#x2F;17更新：<br>最近发现jsdelivr在大陆挂了，那么只能放弃使用CDN, 直接使用github图床的raw链接.</p>
<p>将Picgo默认图床路径从jsdelivr的<br><a href="https://cdn.jsdelivr.net/gh/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D@master">https://cdn.jsdelivr.net/gh/账户名/图床仓库名@master</a><br>改为：<br><a href="https://raw.githubusercontent.com/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D/master">https://raw.githubusercontent.com/账户名/图床仓库名/master</a></p>
<p>注意master前是@还是反斜杠 ‘’&#x2F;‘’.</p>
<p>对于已发布的博客的图床链接，直接用VSCode全局查找替换以上前缀即可，后面的图片id是不变的。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404231354103.png" alt="image-20240423135401997"></p>
<p><strong>如何删除Github图床的图片：</strong><br>PicGo默认的Github图床不能通过相册删除github仓库的图片，需要使用第三方插件github-plus，建议作为默认图床工具，支持相册删除同步到github仓库:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281208516.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281209075.png"></p>
<h2 id="Obsidian配置指南"><a href="#Obsidian配置指南" class="headerlink" title="Obsidian配置指南"></a>Obsidian配置指南</h2><h3 id="Obsidian图床自动上传"><a href="#Obsidian图床自动上传" class="headerlink" title="Obsidian图床自动上传"></a>Obsidian图床自动上传</h3><p>流程参考<a href="https://www.jianshu.com/p/4c30495f4325"># 在Obsidian中使用图床实现“一次上传、多次搬运”省心又省力</a></p>
<p>重点部分：配置自动上传插件。写Markdown文章时粘贴的图片自动上传到Github+PicGo图床，无需手动上传和写链接<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029686.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029586.png"></p>
<p>可以看到，此插件相当于一个PicGo客户端，而本地运行的PicGo Server已开启端口36677的监听。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281033479.png"></p>
<p>单元测试：<br>以上配置好后，Obsidian新建一个Markdown文档，粘贴图片会显示updating… ，成功后可在github图床仓库看到该图片，且Markdown本地预览也可以看到。</p>
<p>遇到的坑：<br>一开始上传的图片，github可预览，Obsidian预览失败<br>在PicGo客户端查看刚才上传图片预览也不正常，PicGo客户端手动上传一张后才正常预览。<br>此后Obsidian再粘贴上传图片，预览正常。<br>可能是PicGo首次链接Obsidian插件的bug。</p>
<h3 id="实时预览和标题大纲"><a href="#实时预览和标题大纲" class="headerlink" title="实时预览和标题大纲"></a>实时预览和标题大纲</h3><p>实时预览是你写一句Markdown，自动转换成预览格式，而不显示Markdown源码。这样不需要开两个窗口，一个写源码一个看预览。在设置-&gt;编辑器里开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281103907.png"></p>
<p>标题大纲是侧边栏显示文章标题列表，就像word的导航窗口一样。在设置-核心插件开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281104255.png"></p>
<h2 id="Typora配置指南"><a href="#Typora配置指南" class="headerlink" title="Typora配置指南"></a>Typora配置指南</h2><h3 id="typora-beta安装"><a href="#typora-beta安装" class="headerlink" title="typora beta安装"></a>typora beta安装</h3><p>typora-0-11-18是最后一个windows免费版，windows上安装需要额外配置如下：</p>
<p>win+R， regedit， 在计算机\HKEY_CURRENT_USER\SOFTWARE\Typora文件夹右键权限，选择当前windows登录用户，在拒绝列，勾选全部拒绝。</p>
<p>原理是禁止typora beta访问系统时间，避免弹窗。</p>
<h3 id="typora图床自动上传"><a href="#typora图床自动上传" class="headerlink" title="typora图床自动上传"></a>typora图床自动上传</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404181658086.png"></p>
<h3 id="自动标题编号"><a href="#自动标题编号" class="headerlink" title="自动标题编号"></a>自动标题编号</h3><p><a href="https://blog.csdn.net/qq_52877060/article/details/123646221">设置typora标题、目录、大纲自动编号</a></p>
<p>typora-&gt;偏好设置-&gt;外观-&gt;主题文件夹-&gt;创建“base.user.css”配置代码</p>
<p>配置代码见附录。这个配置是从二级标题开始，一级标题不编号。一级标题一般就是文章标题，写在Markdown最前面，文章内的二级标题是各章节大标题。使用此配置时注意：至少要有一个一级标题，否则二级标题编号是0.X</p>
<h2 id="Markdown高效写作"><a href="#Markdown高效写作" class="headerlink" title="Markdown高效写作"></a>Markdown高效写作</h2><h3 id="Markdown快捷键"><a href="#Markdown快捷键" class="headerlink" title="Markdown快捷键"></a>Markdown快捷键</h3><p>Typora和Obsidian都可以配置快捷键。我习惯的自定义Markdown快捷键设置如下。</p>
<blockquote>
<p>代码 Ctrl+&#96;</p>
<p>代码块 Ctrl+Alt+&#96;</p>
<p>无序列表 Ctrl + U (Un-Ordered)<br>插入链接 Ctrl + L (Link)</p>
<p>加粗 Ctrl + B (Bold)<br>斜体 Ctrl + I (Italian体)<br>引用 Ctrl + Q (Quote)<br>插入图片 Ctrl + G (Graph, 有了“粘贴即上传”后这个实际上用不上)</p>
</blockquote>
<p>其他就保持默认，例如表格，删除线，分割线等等。也可以参考VS Code的Markdown插件设置。</p>
<p>Typora设置方法：设置-&gt;通用-&gt;打开高级设置-&gt;打开conf.user.json，路径在C:\Users\用户\AppData\Roaming\Typora\conf</p>
<p>在KeyBinding设置key-value，其中key是typora菜单的选项，value是快捷键值。typora默认的快捷键已经够好用，这里只作为个人示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;keyBinding&quot;: &#123;</span><br><span class="line">  // for example: </span><br><span class="line">  // &quot;Always on Top&quot;: &quot;Ctrl+Shift+P&quot;</span><br><span class="line">  // All other options are the menu items &#x27;text label&#x27; displayed from each typora menu</span><br><span class="line">  &quot;代码&quot;: &quot;Ctrl+`&quot;,</span><br><span class="line">  &quot;代码块&quot;: &quot;Ctrl+Alt+`&quot;,</span><br><span class="line">  &quot;无序列表&quot;: &quot;Ctrl+u&quot;,</span><br><span class="line">  &quot;有序列表&quot;: &quot;Ctrl+o&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>默认的代码块Ctrl+Shift+K失效可能是因为快捷键被占用，可以使用Ark工具查找，参考： <a href="https://blog.csdn.net/lpwmm/article/details/108451728">https://blog.csdn.net/lpwmm/article/details/108451728</a></p>
<h2 id="搭建hexo博客环境"><a href="#搭建hexo博客环境" class="headerlink" title="搭建hexo博客环境"></a>搭建hexo博客环境</h2><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><p>整体流程参考：<a href="https://zhuanlan.zhihu.com/p/105715224"># 个人博客第5篇——安装node.js和Hexo</a><br>官方文档参考：<a href="https://hexo.io/zh-cn/docs/">hexo.io</a></p>
<p>部署命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\cursorhu&gt;npm install -g hexo-cli #npm安装hexo包</span><br><span class="line">C:\Users\cursorhu&gt;d:  #切到以后写blog的目录</span><br><span class="line">D:\hexo-blog&gt;hexo init #下载hexo</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git </span><br><span class="line">D:\hexo-blog&gt;hexo g  #将blog资料创建为css,html静态文件</span><br><span class="line">INFO  Generated: archives/index.html </span><br><span class="line">D:\hexo-blog&gt;hexo s  #运行hexo server</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>博客的github仓库，主题等关键配置都在<code>hexo init</code>对应目录下的<code>_config.yml</code><br>修改几个关键配置如下：<br>博客框架的语言一定要配，否则默认德语阿拉伯语…</p>
<blockquote>
<p>title: ThinkNotes<br>   subtitle: Simple is not easy<br>   author: Cursorhu<br>   language: zh-CN</p>
</blockquote>
<p>Github部署配置</p>
<blockquote>
<p>url: <a href="https://cursorhu.github.io/">https://cursorhu.github.io</a><br>deploy:<br>  type: git<br>  repo: <a href="https://github.com/cursorhu/cursorhu.github.io">https://github.com/cursorhu/cursorhu.github.io</a><br>  branch: master</p>
</blockquote>
<p>简单总结一下：</p>
<ul>
<li>hexo是一个基于nodeJS的博客框架，nodeJS提供JavaScript实现后端服务的能力。</li>
<li>hexo可以将本地写好的Markdown文本和图片资源，以JavaScript网页资源的方式打包。hexo可以在本机运行服务，通过浏览器可以在网页访问。</li>
<li>如果要使博客外网可访问，需要一个云服务存放hexo生成的博客，我们使用github仓库作为博客云端。前面已经搭建了github图床仓库，因此图片并不需要放到此hexo仓库。</li>
<li>使用git实现hexo博客部署到github仓库</li>
</ul>
<p>安装hexo遇到的坑：<br>如果你以前用过hexo，之后nodeJS升级了版本，一定不要用以前的hexo博客目录，必须新建博客目录，重新<code>hexo init</code>安装相关hexo插件。否则nodeJS和hexo插件可能不兼容导致部署失败。</p>
<p>hexo插件版本是根据nodeJS版本自动安装的，配置文件是package.json。以nodeJS 16.3为例，自动生成的依赖版本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;hexo generate&quot;,</span><br><span class="line">    &quot;clean&quot;: &quot;hexo clean&quot;,</span><br><span class="line">    &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;hexo server&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;6.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^6.0.0&quot;,</span><br><span class="line">    &quot;hexo-deployer-git&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><p>hexo new命令可以从0新建markdown写博客，一般不用这么麻烦。</p>
<p>我们直接将写好的Markdown（图片资源是图床链接）放到hexo博客目录的post文件夹，例如我的本地目录是：</p>
<blockquote>
<p>F:\HexoBlog\source_posts</p>
</blockquote>
<p>在Markdown文件前添加hexo博客特有的头，说明博客的标题时间，分类等属性。这个头如果用<code>hexo new</code>命令会自动生成，可以先new一个然后拷过来。</p>
<blockquote>
<p>title: 博客文章名<br>date: 2022-02-28 15:04:18<br>tags: markdown<br>categories: markdown</p>
</blockquote>
<p>最后使用git生成网页文件并发布到github博客仓库, 注意不是用node命令行！<br>在hexo博客目录下运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<h3 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h3><p>博客主题(theme)取决于不同人喜好，github有大量的hexo主题，按需配置<br>推荐几个主流的：<br><a href="https://github.com/theme-next/hexo-theme-next">Next</a><br><a href="https://github.com/bollnh/hexo-theme-material">hexo-theme-material</a></p>
<p>以Next主题为例，安装：</p>
<blockquote>
<p>$ cd hexo博客目录<br>   $ git clone <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> themes&#x2F;next</p>
</blockquote>
<p>已我的配置为例，就会在F:\HexoBlog\themes\next看到next主题的源码和配置文件config.yml</p>
<p>Next配置可以自定义各种设置，例如子主题:</p>
<blockquote>
<p> scheme: Muse<br>#scheme: Mist<br>#scheme: Pisces<br>#scheme: Gemini</p>
</blockquote>
<p>我们前面已经用jsdelivr开源CDN为PicGo上传图片加速，可以配置Next主题的网页静态文件的相关库也用jsdelivr加速。最好用到才开启，例如motion enable, 其依赖库velocity就可以设置jsdelivr加速：</p>
<blockquote>
<p>motion:<br>  enable: true<br>velocity: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.min.js<br>velocity_ui: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.ui.min.js</p>
</blockquote>
<p>注意这些配置文件也是Markdown格式，<code># </code> 注释一定要带空格</p>
<p>hexo要使用next, 在hexo配置文件设置:</p>
<blockquote>
<p>theme: next</p>
</blockquote>
<p>hexo clean, hexo g, hexo s 跑本地服务，看一下效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203041651883.png"></p>
<p>最后hexo clean, g, d 命令三连部署到github</p>
<p>访问<a href="https://cursorhu.github.io/">https://cursorhu.github.io/</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404231559552.png" alt="image-20240423155947426"></p>
<h2 id="附录：typora自动编号代码"><a href="#附录：typora自动编号代码" class="headerlink" title="附录：typora自动编号代码"></a>附录：typora自动编号代码</h2><p>手动创建的base.user.css路径：</p>
<p>C:\Users\用户名\AppData\Roaming\Typora\themes\base.user.css</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*文章内容自动编号*/</span><br><span class="line">/** initialize css counter */</span><br><span class="line">h1 &#123;</span><br><span class="line">    counter-reset: h2</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">h2 &#123;</span><br><span class="line">    counter-reset: h3</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">h3 &#123;</span><br><span class="line">    counter-reset: h4</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">h4 &#123;</span><br><span class="line">    counter-reset: h5</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">h5 &#123;</span><br><span class="line">    counter-reset: h6</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/** put counter result into headings */</span><br><span class="line">#write h2:before &#123;</span><br><span class="line">    counter-increment: h2;</span><br><span class="line">    content: counter(h2) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#write h3:before,</span><br><span class="line">h3.md-focus.md-heading:before /** override the default style for focused headings */ &#123;</span><br><span class="line">    counter-increment: h3;</span><br><span class="line">    content: counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#write h4:before,</span><br><span class="line">h4.md-focus.md-heading:before &#123;</span><br><span class="line">    counter-increment: h4;</span><br><span class="line">    content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#write h5:before,</span><br><span class="line">h5.md-focus.md-heading:before &#123;</span><br><span class="line">    counter-increment: h5;</span><br><span class="line">    content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#write h6:before,</span><br><span class="line">h6.md-focus.md-heading:before &#123;</span><br><span class="line">    counter-increment: h6;</span><br><span class="line">    content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/** override the default style for focused headings */</span><br><span class="line">#write&gt;h3.md-focus:before,</span><br><span class="line">#write&gt;h4.md-focus:before,</span><br><span class="line">#write&gt;h5.md-focus:before,</span><br><span class="line">#write&gt;h6.md-focus:before,</span><br><span class="line">h3.md-focus:before,</span><br><span class="line">h4.md-focus:before,</span><br><span class="line">h5.md-focus:before,</span><br><span class="line">h6.md-focus:before &#123;</span><br><span class="line">    color: inherit;</span><br><span class="line">    border: inherit;</span><br><span class="line">    border-radius: inherit;</span><br><span class="line">    position: inherit;</span><br><span class="line">    left:initial;</span><br><span class="line">    float: none;</span><br><span class="line">    top:initial;</span><br><span class="line">    font-size: inherit;</span><br><span class="line">    padding-left: inherit;</span><br><span class="line">    padding-right: inherit;</span><br><span class="line">    vertical-align: inherit;</span><br><span class="line">    font-weight: inherit;</span><br><span class="line">    line-height: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*文章主题自动编号*/</span><br><span class="line">/* No link underlines in TOC */</span><br><span class="line">.md-toc-inner &#123;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h1 &#123;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">    font-size: 1.5rem;</span><br><span class="line">    counter-reset: h2toc</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h2 &#123;</span><br><span class="line">    font-size: 1.1rem;</span><br><span class="line">    margin-left: 2rem;</span><br><span class="line">    counter-reset: h3toc</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h3 &#123;</span><br><span class="line">    margin-left: 3rem;</span><br><span class="line">    font-size: .9rem;</span><br><span class="line">    counter-reset: h4toc</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h4 &#123;</span><br><span class="line">    margin-left: 4rem;</span><br><span class="line">    font-size: .85rem;</span><br><span class="line">    counter-reset: h5toc</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h5 &#123;</span><br><span class="line">    margin-left: 5rem;</span><br><span class="line">    font-size: .8rem;</span><br><span class="line">    counter-reset: h6toc</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h6 &#123;</span><br><span class="line">    margin-left: 6rem;</span><br><span class="line">    font-size: .75rem;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h2:before &#123;</span><br><span class="line">    color: black;</span><br><span class="line">    counter-increment: h2toc;</span><br><span class="line">    content: counter(h2toc) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h2 .md-toc-inner &#123;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h3:before &#123;</span><br><span class="line">    color: black;</span><br><span class="line">    counter-increment: h3toc;</span><br><span class="line">    content: counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h3 .md-toc-inner &#123;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h4:before &#123;</span><br><span class="line">    color: black;</span><br><span class="line">    counter-increment: h4toc;</span><br><span class="line">    content: counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h4 .md-toc-inner &#123;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h5:before &#123;</span><br><span class="line">    color: black;</span><br><span class="line">    counter-increment: h5toc;</span><br><span class="line">    content: counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h5 .md-toc-inner &#123;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h6:before &#123;</span><br><span class="line">    color: black;</span><br><span class="line">    counter-increment: h6toc;</span><br><span class="line">    content: counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; counter(h6toc) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.md-toc-h6 .md-toc-inner &#123;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*文章大纲自动编号*/</span><br><span class="line">.outline-h1 &#123;</span><br><span class="line">    counter-reset: h2</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h2 &#123;</span><br><span class="line">    counter-reset: h3</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h3 &#123;</span><br><span class="line">    counter-reset: h4</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h4 &#123;</span><br><span class="line">    counter-reset: h5</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h5 &#123;</span><br><span class="line">    counter-reset: h6</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h2&gt;.outline-item&gt;.outline-label:before &#123;</span><br><span class="line">    counter-increment: h2;</span><br><span class="line">    content: counter(h2) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h3&gt;.outline-item&gt;.outline-label:before &#123;</span><br><span class="line">    counter-increment: h3;</span><br><span class="line">    content: counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h4&gt;.outline-item&gt;.outline-label:before &#123;</span><br><span class="line">    counter-increment: h4;</span><br><span class="line">    content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h5&gt;.outline-item&gt;.outline-label:before &#123;</span><br><span class="line">    counter-increment: h5;</span><br><span class="line">    content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.outline-h6&gt;.outline-item&gt;.outline-label:before &#123;</span><br><span class="line">    counter-increment: h6;</span><br><span class="line">    content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL类使用笔记</title>
    <url>/2020/12/01/C-STL%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><p><strong>查找指定字符串的位置（下标）</strong></p>
<p>string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）</p>
<pre><code>//find函数返回类型 size_type
string s(&quot;1a2b3c4d5e6f7jkg8h9i1a2b3c4d5e6f7g8ha9i&quot;);
int position;
//find 函数 返回jk 在s 中的下标位置
position = s.find(&quot;jk&quot;);
if (position != s.npos)  //如果没找到，返回一个特别的标志c++中用npos表示
&#123;
    printf(&quot;position is : %d\n&quot; ,position);
&#125;
else
&#123;
    printf(&quot;Not found the flag\n&quot;);
&#125;
</code></pre>
<p>##查找某字符首次出现，或最后出现的位置<br>find_first_of() 和 find_last_of()返回子串出现在母串中的首次出现的位置，和最后一次出现的位置<br>查找上面示例的’c’的下标：</p>
<pre><code>flag = &quot;c&quot;;
position = s.find_first_of(flag);
printf(&quot;s.find_first_of(flag) is :%d\n&quot;,position);
position = s.find_last_of(flag);
printf(&quot;s.find_last_of(flag) is :%d\n&quot;,position);
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081711721.png" alt="image-20221208171122674"></p>
<p><strong>查找某给定位置后的子串的位置</strong></p>
<pre><code>//从字符串s 下标5开始，查找字符串b ,返回b 在s 中的下标
position=s.find(&quot;b&quot;,5);
cout&lt;&lt;&quot;s.find(b,5) is : &quot;&lt;&lt;position&lt;&lt;endl;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081711350.png"></p>
<p><strong>查找所有子串在母串中出现的位置</strong></p>
<pre><code>//查找s 中flag 出现的所有位置。
flag=&quot;a&quot;;
position=0;
int i=1;
while((position=s.find(flag,position))!=string::npos)
&#123;
    cout&lt;&lt;&quot;position  &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;position&lt;&lt;endl;
    position++;
    i++;
&#125;
</code></pre>
<h1 id="map与unordered-map的区别"><a href="#map与unordered-map的区别" class="headerlink" title="map与unordered_map的区别"></a>map与unordered_map的区别</h1><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p><strong>map：</strong><br>map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），<strong>红黑树具有自动排序的功能，因此map内部的所有元素都是有序的</strong>，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>
<p><strong>unordered_map:</strong><br>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，<strong>查找的时间复杂度可达到O(1</strong>)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<h2 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h2><p><strong>map</strong><br>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。<br>红黑树结构：内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>
<p>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红&#x2F;黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map：</strong></p>
<p>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结：</strong><br>两种map性能分析的内存占用比较，就是红黑树 VS hash表的性能比较, 还是unorder_map占用的内存要高。<br>但是unordered_map查找的时间复杂度低，执行效率要比map高很多。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>unordered_map的用法和map是一样的，都提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。但其内部实现是不同的，对使用者来说不可见。</p>
<p>示例（map_and_unordered.cpp）：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;unordered_map&gt;  
#include &lt;map&gt;
#include &lt;string&gt;  

using namespace std;  

int main()  
&#123;  
	////使用&#123;&#125;赋值, 注意：C++11才开始支持括号初始化
    unordered_map&lt;int, string&gt; myMap = &#123;&#123; 3, &quot;C&quot; &#125;,&#123; 4, &quot;D&quot; &#125;&#125;; 
    //使用[ ]进行单个插入，若已存在键值2，则修改其值
    myMap[1] = &quot;A&quot;;  
    myMap.insert(pair&lt;int, string&gt;(2, &quot;B&quot;));//使用insert和pair插入
  
	//遍历输出+迭代器的使用
	//auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator
    auto iter = myMap.begin(); 
    while (iter!= myMap.end())
    &#123;  
        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;  
        ++iter;  
    &#125;  
	
	//查找元素并输出+迭代器的使用
	//find()返回一个指向2的迭代器
    auto iterator = myMap.find(2);
    if (iterator != myMap.end())
	    cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iterator-&gt;second &lt;&lt; endl;  
     
    return 0;  
&#125;
</code></pre>
<p>编译：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081713270.png" alt="image-20221208171339229"></p>
<p>结果：<br>unordered_map：没有按值的大小排序，从最近插入的到最早插入的，依次显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081714465.png" alt="image-20221208171412418"><br>把unordered_map改成map: 按值的大小，从小到大显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081713971.png" alt="image-20221208171351937"></p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>sort()函数是STL中的排序函数，由模板函数实现，复杂度N*logN。该函数专门用来对容器或普通数组中指定范围内的元素进行排序，该函数使用频率较高，且其实现综合了几种经典排序方法<br>使用格式如下：</p>
<pre><code>sort (first, last) //排序从first到last的数据，默认从小到大
sort (first, last, rule) //以某种规则排序，rule可使用std定义的，或自定义实现
</code></pre>
<h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><p>几种典型的使用方式：</p>
<ul>
<li>默认：从小到大</li>
<li>greater&lt; Type &gt;()：std提供的从大到小</li>
<li>自定义规则：函数，运算符，Lambda实现，这里规则都是传入两个参数（分别是要比较数组的靠左值，靠右值），返回bool类型，如果左值&lt;右值，即从小到大排序，反之从大到小</li>
</ul>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::sort
#include &lt;vector&gt;       // std::vector
#include &lt;stdlib.h&gt;

using namespace std;

//以普通函数的方式实现自定义排序规则
bool myComp(int i, int j) &#123;
    return (i &lt; j);
&#125;

//以对象的方式实现自定义排序规则
class myCompOper &#123;
public:
    bool operator() (int i, int j) &#123;
        return (i &gt; j);
    &#125;
&#125;;

//打印数组
void print_array(std::vector&lt;int&gt; &amp;a, const char *s)
&#123;
    printf(&quot;%s\n&quot;, s);
    vector&lt;int&gt;::iterator it;
    for (it = a.begin(); it != a.end(); ++it)
    &#123;
        printf(&quot;%d &quot;, *it);
    &#125;
    printf(&quot;\n&quot;);
&#125;

int main() &#123;
    //std::vector&lt;int&gt; array;
    //char num;
    //while(cin.get() != &#39;\n&#39;)
    //&#123;
    //    cin &gt;&gt; num;
    //    array.push_back(num);
    //&#125;

    vector&lt;int&gt; array&#123;1,3,4,2,5,7,6,8,9&#125;;
    print_array(array, &quot;input array:&quot;);

    //默认排序，从小到大
    std::sort(array.begin(), array.end());
    print_array(array, &quot;default sort:&quot;);

    //使用STL标准库提供的其它比较规则, 比如 greater&lt;T&gt;，从大到小
    std::sort(array.begin(), array.end(), std::greater&lt;int&gt;());
    print_array(array, &quot;std::greater&lt;T&gt; sort:&quot;);

    //自定义比较规则: 普通函数
    std::sort(array.begin(), array.end(), myComp);
    print_array(array, &quot;myComp sort:&quot;);

    //自定义比较规则: 类内运算符重载
    std::sort(array.begin(), array.end(), myCompOper());
    print_array(array, &quot;myCompOper sort:&quot;);

    //自定义比较规则: Lambda匿名函数
    std::sort(array.begin(), array.end(), [](int i, int j) &#123;return i &lt; j;&#125;);
    print_array(array, &quot;Lambda sort:&quot;);
</code></pre>
<p>​<br>        return 0;<br>    }</p>
<p>结果如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081715702.png" alt="image-20221208171536663"></p>
<h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p>
<p><strong>(1)普通快排</strong><br>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p>
<ul>
<li>如果S中的元素只有0个或1个，结束。</li>
<li>取S中的任何一个元素作为枢轴pivot。</li>
<li>将S分割为L、R两端，使L内的元素都小于等于pivot，R内的元素都大于等于pivot。 </li>
<li>对L、R递归执行上述过程。</li>
</ul>
<p>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称为median-of-three，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p>
<p>分割的方法通常采用两个迭代器head和tail，head从头端往尾端移动，tail从尾端往头端移动，当head遇到大于等于pivot的元素就停下来，tail遇到小于等于pivot的元素也停下来，若head迭代器仍然小于tail迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p>
<p><strong>(2)内省式排序 Introsort</strong><br>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 O(n2)。David R.Musser于1996年提出一种混合式排序算法：Introspective Sorting（内省式排序），简称IntroSort，其行为大部分与上面所说的median-of-three Quick Sort完全相同，但是当分割行为有恶化为二次方的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 O(nlgn)，又比一开始就使用堆排序来得好。</p>
<p>sort声明：</p>
<pre><code>#include &lt;algorithm&gt;
 
template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );
 
template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );
</code></pre>
<p>sort实现：</p>
<pre><code>template &lt;class _RandomAccessIter&gt;
inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123;
  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,
                 _LessThanComparable);
  if (__first != __last) &#123;
    __introsort_loop(__first, __last,
                     __VALUE_TYPE(__first),
                     __lg(__last - __first) * 2);
    __final_insertion_sort(__first, __last);
  &#125;
&#125;
</code></pre>
<p>__introsort_loop便是上面介绍的内省式排序，其第三个参数中所调用的函数__lg()便是用来控制分割恶化情况，求lg(n)（取下整），意味着快速排序的递归调用最多 2*lg(n) 层。<br>__lg()实现如下</p>
<pre><code>template &lt;class Size&gt;
inline Size __lg(Size n) &#123;
	Size k;
	for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k;
	return k;
&#125;
</code></pre>
<p>__introsort_loop实现：</p>
<ul>
<li>首先判断元素规模是否大于阀值__stl_threshold，__stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。</li>
<li>若元素规模大于__stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。</li>
<li>若没有超过递归调用深度，则调用函数__unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。</li>
<li>经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。</li>
</ul>
<p>递归上述过程，直到元素规模小于__stl_threshold，然后返回sort函数，对整个元素序列调用一次插入排序，此时序列中的元素已基本有序，所以插入排序也很快。至此，整个sort函数运行结束。</p>
<p>__introsort_loop代码：</p>
<pre><code>template &lt;class _RandomAccessIter, class _Tp, class _Size&gt;
void __introsort_loop(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Tp*,
                      _Size __depth_limit)
&#123;
  while (__last - __first &gt; __stl_threshold) &#123;
    if (__depth_limit == 0) &#123;
      partial_sort(__first, __last, __last);
      return;
    &#125;
    --__depth_limit;
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1))));
    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit);
    __last = __cut;
  &#125;
&#125;
</code></pre>
<p>__unguarded_partition()函数</p>
<pre><code>template &lt;class _RandomAccessIter, class _Tp&gt;
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, 
                                        _RandomAccessIter __last, 
                                        _Tp __pivot) 
&#123;
    while (true) &#123;
        while (*__first &lt; __pivot)
            ++__first;
        --__last;
        while (__pivot &lt; *__last)
            --__last;
        if (!(__first &lt; __last))
            return __first;
        iter_swap(__first, __last);
        ++__first;
    &#125;
&#125;
</code></pre>
<p>参考： 《STL源码剖析》–侯捷</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：从C到C++</title>
    <url>/2020/03/14/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%8EC%E5%88%B0C/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>本章介绍C++语言和C语言相近的部分基础用法，包括</p>
<ul>
<li>引用: &amp;</li>
<li>常关键字: const</li>
<li>动态内存分配: new delete</li>
<li>函数内联: inline</li>
<li>函数重载</li>
</ul>
<h1 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h1><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。</p>
<pre><code>类型名 &amp; 引用名 = 某变量名;
</code></pre>
<p>某个变量的引用，等价于这个变量，相当于该变量起了一个别名。别名类似于操作系统的文件链接或快捷方式的概念，访问它变量本身的存储空间。</p>
<pre><code>int n = 4;
int &amp; r = n; // r引用了 n, r的类型是int &amp;
r = 4;
cout &lt;&lt; r; //输出 4
cout &lt;&lt; n; //输出 4
n = 5;
cout &lt;&lt; r; //输出5
</code></pre>
<p>注意：<br>1.定义引用时一定要将其初始化成引用某个变量。<br>2.初始化后，它就一直引用该变量，不会再引用别<br>的变量了。<br>3.引用只能引用变量，不能引用常量和表达式。</p>
<h2 id="引用的示例"><a href="#引用的示例" class="headerlink" title="引用的示例"></a>引用的示例</h2><p>引用常用于函数传参和返回值<br>1.引用作为函数入参<br>C语言写一个swap函数，交换两个变量的值，要传指针而不能传值，因为直接传值实际修改的是函数局部作用域的一份拷贝。</p>
<pre><code>void swap( int * a, int * b)
{
    int tmp;
    tmp = * a; * a = * b; * b = tmp;
}
int n1, n2;
swap(&amp; n1,&amp; n2) ; // n1,n2的值被交换
</code></pre>
<p>C++中，除了传指针，也可以传引用</p>
<pre><code>void swap( int &amp; a, int &amp; b)
{
    int tmp;
    tmp = a; a = b; b = tmp;
}
int n1, n2;
swap(n1,n2) ; // n1,n2的值被交换
</code></pre>
<p>2.引用作为函数返回值</p>
<pre><code>int n = 4;
int &amp; SetValue() { return n; }
int main()
{
SetValue() = 40;
cout &lt;&lt; n;
return 0;
} //输出： 40
</code></pre>
<h2 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h2><p>看上去引用和指针的功能相同，那区别在哪？<br>1.存储类型不同</p>
<ul>
<li>指针是一种变量，存储指向变量的地址值，通常占内存4字节（64位系统8字节）</li>
<li>引用只是变量的别名，它本身不另外占存储空间，对其求大小（sizeof）就是变量本身的大小</li>
</ul>
<p>指针是变量，因此可以为空（0x0）,而引用是标签（别名），不可为空，先有变量才能有其引用。<br>2.作用方式不同</p>
<ul>
<li>指针作为函数入参本质上还是是值传递，只不过传递的是变量的地址值，函数局部拷贝的也是地址。</li>
<li>引用作为函数入参，被调函数的形参作为局部变量在栈中开辟了内存空间，但存放的是主调函数的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。</li>
</ul>
<p>对于函数传参，形参都是用地址值达成对实参的修改，但传指针是显式的，而传引用是编译器隐式处理的。<br>指针和引用在内存中的示意图：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081643838.png" alt="image-20221208164349783"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081644997.png"></p>
<p>指针和引用的应用比较：<br>引用比指针使用起来形式上更为美观，使用引用指向的内容时可以之间用引用变量名，而不像指针一样要使用*；定义引用的时候也不用像指针一样使用&amp;取址。<br>引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针)。</p>
<h1 id="常量关键字const"><a href="#常量关键字const" class="headerlink" title="常量关键字const"></a>常量关键字const</h1><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>常量：不可被修改的内存单元<br>    const int MAX_VAL &#x3D; 23；<br>    const string SCHOOL_NAME &#x3D; “Peking University”；</p>
<h2 id="定义常引用"><a href="#定义常引用" class="headerlink" title="定义常引用"></a>定义常引用</h2><p>定义引用时，前面加const关键字，即为“常引用”。不能<strong>通过常引用修改</strong>其引用的变量，但可直接修改变量的值，引用本身也不能改变</p>
<pre><code>int n;
const int &amp; r = n;
r = 5; //error
n = 4; //ok
</code></pre>
<p><strong>const T &amp; 和T &amp; 是不同的数据类型!!!</strong><br>T &amp; 类型的引用或T类型的变量可以用来初始化const T &amp; 类型的引用，const T 类型的常变量和const T &amp; 类型的引用则不能用来初始化T &amp;类型的引用，除非进行强制类型转换<br>一句话，常指针和常引用不能出现在“&#x3D;”左边</p>
<h2 id="定义常指针"><a href="#定义常指针" class="headerlink" title="定义常指针"></a>定义常指针</h2><p>常指针也叫常量指针。但指针不是常量，指向的也不是常量，只是限制了改写方式：不可<strong>通过常量指针修改</strong>其指向变量的值，但可直接修改变量的值，也可以改变常量指针的指向地址值。</p>
<pre><code>int n,m;
const int * p = &amp; n;
* p = 5; //编译出错
n = 4; //ok
p = &amp;m; //ok, 常量指针的指向可以变化
</code></pre>
<p>不能把常量指针赋值给非常量指针，反过来可以</p>
<pre><code>const int * p1; int * p2;
p1 = p2; //ok
p2 = p1; //error
p2 = (int * ) p1; //ok,强制类型转换
</code></pre>
<p>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容</p>
<pre><code>void MyPrintf( const char * p )
{
strcpy( p,&quot;this&quot;); //编译出错
printf(&quot;%s&quot;,p); //ok
}
</code></pre>
<h2 id="定义指针常量"><a href="#定义指针常量" class="headerlink" title="定义指针常量"></a>定义指针常量</h2><p>定义：本质是一个不可修改指向地址的指针 </p>
<pre><code>int* const p;
</code></pre>
<h2 id="定义指向常量的常指针"><a href="#定义指向常量的常指针" class="headerlink" title="定义指向常量的常指针"></a>定义指向常量的常指针</h2><p>定义：指针指向的地址值不可修改，且该地址中的值也不可修改</p>
<pre><code>const int* const p;
</code></pre>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>动态内存分配是分配内存空间中堆（heap）的内存，实际上是程序内手动的内存分配与释放。并非堆栈中局部变量的入栈出栈，由操作系统控制的动态分配。</p>
<h2 id="new分配内存"><a href="#new分配内存" class="headerlink" title="new分配内存"></a>new分配内存</h2><p>分配一个变量:</p>
<pre><code>P = new T;
</code></pre>
<p>T是任意类型名， P是类型为T * 的指针。<br>动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P：</p>
<pre><code>int * pn = new int;
* pn = 5;
</code></pre>
<p>分配一个数组：</p>
<pre><code>P = new T[N];
</code></pre>
<p>T :任意类型名<br>P :类型为T * 的指针<br>N :要分配的数组元素的个数，可以是整型表达式<br>动态分配出一片大小为 sizeof(T)*N字节的内存空间，并且将该内存空间的起始地址赋值给P</p>
<pre><code>int * pn;
int i = 5;
pn = new int[i * 20];
pn[0] = 20;
pn[100] = 30; //编译没问题。运行时导致数组越界
</code></pre>
<h2 id="delete释放内存"><a href="#delete释放内存" class="headerlink" title="delete释放内存"></a>delete释放内存</h2><p>用“new”动态分配的内存空间用完后，一定要用“delete”运算符进行释放，否则操作系统无法再次使用这块内存，造成内存泄露<br>注意：不能对内存空间delete两次！</p>
<pre><code>#delete 指针； //该指针必须指向new出来的空间
int * p = new int;
* p = 5;
delete p;
delete p; //导致异常， 一片空间不能被delete多次
</code></pre>
<p>用“delete”释放动态分配的数组，要加“[]”</p>
<pre><code>#delete [] 指针； //该指针必须指向new出来的数组
int * p = new int[20];
p[0] = 1;
delete [] p;
</code></pre>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>普通函数：编译出来的可执行程序加载到内存后，代码段只有一份函数的指令序列，函数的调用处就用一个类似jump的语句跳转到函数指令序列的入口地址<br>内联函数：函数的每个调用处都存在整个函数指令序列的拷贝<br>简单讲就是增加编译出来的代码占用空间，换取运行时频繁入栈出栈的时间开销<br>使用场景：简单函数体且多次调用可以定义为内联<br>函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</p>
<pre><code>inline int Max(int a,int b)
{
if( a &gt; b) return a;
return b;
}
</code></pre>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="函数重载概念"><a href="#函数重载概念" class="headerlink" title="函数重载概念"></a>函数重载概念</h2><p>重载不是重新载入，更贴切的含义是重复定义，因为重定义是种错误，重载可以理解为编译器能理解的“重定义”，因此能正常加载。<br>C++重载主要有：</p>
<ul>
<li>函数重载</li>
<li>运算符重载</li>
</ul>
<p>C++的类没有重载一说，本节讲函数重载<br>函数重载：一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。</p>
<pre><code>int Max(double f1,double f2) { }
int Max(int n1,int n2) { }
int Max(int n1,int n2,int n3) { }
</code></pre>
<p>Q1.重载有什么用？<br>C语言定义以上几个函数，不能用同名，但是其功能都是相同的，仅参数类型和值不同。如果用MaxDouble(),MaxInt2(),MaxInt3()过于麻烦。<br>因此函数重载使得函数命名变得简单。<br>Q2.编译器怎么知道调用的是哪个？<br>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数，注意重载函数不会把入参自动类型转换，调用二义性会报错。</p>
<pre><code>Max(3.4,2.5); //调用 (1)
Max(2,4); //调用 (2)
Max(1,2,3); //调用 (3)
Max(3,2.4); //error,二义性
</code></pre>
<p>Q3.函数仅返回值类型不同是不是重载？<br>不是，函数重载的区分在于入参。但是有个例外，返回const T和非const T的两个函数是是重载的，其他情况的入参相同，返回类型不同的函数，视为重定义。</p>
<h2 id="缺省参数与可拓展性"><a href="#缺省参数与可拓展性" class="headerlink" title="缺省参数与可拓展性"></a>缺省参数与可拓展性</h2><p>C++函数支持缺省参数（默认参数值）。定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。</p>
<pre><code>void func( int x1, int x2 = 2, int x3 = 3)
{ }
func(10 ) ; //等效于 func(10,2,3)
func(10,8) ; //等效于 func(10,8,3)
func(10, , 8) ; //不行,只能最右边的连续若干个参数缺省
</code></pre>
<p>函数参数可缺省的目的在于提高程序的可扩充性。<br>如果某个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，那么为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。<br>在C语言中，如果函数新增一个入参，所有调用该函数的地方都要传入该入参值；C++支持缺省参数，只需要改函数定义即可，调用处不需要动。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：模板、泛型与STL</title>
    <url>/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++除了支持面向对象，也支持函数的扩展和重用。继承类和多态充分支持了扩展，即基类进行概括抽象的设计，派生类实现具体的设计。那么重用呢，如何写一个函数，能在多种情况不加修改的套用？<br>考虑以下问题：</p>
<pre><code>交换两个整型变量的值的Swap函数：
void Swap(int &amp; x,int &amp; y)
{
    int tmp = x;
    x = y;
    y = tmp;
}
交换两个double型变量的值的Swap函数:
void Swap(double &amp; x,double &amp; y)
{
    double tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>这两个函数除了入参类型不同，函数名，参数个数，返回类型都相同。函数体的处理流程也完全一样。能否只写一个Swap，就能交换各种类型的变量？<br>模板（template）将解决这种问题。</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="函数模板的概念"><a href="#函数模板的概念" class="headerlink" title="函数模板的概念"></a>函数模板的概念</h2><p>用函数模板，设计仅数据类型不同的一组函数的通用模板：</p>
<pre><code>template &lt;class 类型参数1，class 类型参数2,……&gt;
返回值类型 模板名 (形参表)
{
    函数体
};

template &lt;class T&gt; //在函数前声明模板，参数类型（class）是T
void Swap(T &amp; x,T &amp; y)
{
    T tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>在普通函数前，先用template&lt; class T &gt;声明参数类型T，就可以在函数体使用T，就像使用普通变量一样。在运行时，T传入的类型不同，函数处理的数据类型也不同。<br>函数模板是如何实现的？它是一种函数吗？</p>
<pre><code>int main()
{
    int n = 1,m = 2;
    Swap(n,m); //编译器自动生成 void Swap(int &amp; ,int &amp; )函数
    double f = 1.2,g = 2.3;
    Swap(f,g); //编译器自动生成 void Swap(double &amp; ,double &amp; )函数
    return 0;
}
</code></pre>
<p>函数模板只是个模子，编译器通过模板和具体参数类型产生不同的函数。编译器会进行两次编译，第一次检测模板代码，第二次检测加参数后的具体函数代码。<br>在调用以上函数模板时，实际会生成两个具体函数：</p>
<pre><code>void Swap(int &amp; x,int &amp; y)
{
    int tmp = x;
    x = y;
    y = tmp;
}
void Swap(double &amp; x,double &amp; y)
{
    double tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>函数模板，可以理解为一种函数的宏，编译期在宏被调用的地方，全部替换成宏所对应的具体值。<br>函数模板和运行时函数，也类似于类和对象的关系，类只是类型，对象是给类分配了内存的实例。函数模板只是通用的类型，函数实例是函数模板的实例化对象。</p>
<h2 id="函数模板的特性"><a href="#函数模板的特性" class="headerlink" title="函数模板的特性"></a>函数模板的特性</h2><p>函数模板中可以有不止一个类型参数</p>
<pre><code>template &lt;class T1, class T2&gt;
T2 print(T1 arg1, T2 arg2)
{
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
    return arg2;
}
</code></pre>
<p>不通过参数也能实例化函数模板</p>
<pre><code>template &lt;class T&gt;
T Inc(T n)
{
    return 1 + n;
}
int main()
{
    cout &lt;&lt; Inc&lt;double&gt;(4)/2; //显式实例化模板，输出 2.5
    return 0;
}
</code></pre>
<h2 id="函数模板与重载"><a href="#函数模板与重载" class="headerlink" title="函数模板与重载"></a>函数模板与重载</h2><p>函数模板和函数重载，在写法上很接近，都是一组参数不同的同名函数。它们有什么联系和区别？</p>
<ul>
<li>函数重载，关键在参数个数</li>
<li>函数模板，关键在参数类型</li>
</ul>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<pre><code>template&lt;class T1, class T2&gt;
void print(T1 arg1, T2 arg2) {
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
}
template&lt;class T&gt;
void print(T arg1, T arg2) {
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
}
template&lt;class T,class T2&gt;
void print(T arg1, T arg2) {
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
}
</code></pre>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一条函数调用语句:</p>
<ol>
<li><p>先找参数完全匹配的普通函数(非由模板实例化而得的函数)</p>
</li>
<li><p>再找参数完全匹配的模板函数。</p>
</li>
<li><p>再找实参数经过自动类型转换后能够匹配的普通函数。</p>
</li>
</ol>
<ol start="4">
<li><p>上面的都找不到，则报错<br>如果有函数重载，在第（1）步就找到，如果没有，才找（2）的函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"> T Max( T a, T b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> template &lt;class T,class T2&gt;</span><br><span class="line"> T Max( T a, T2 b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax2&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> double Max(double a, double b)&#123;</span><br><span class="line">     cout &lt;&lt; &quot;MyMax&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main() &#123;</span><br><span class="line">     int i=4, j=5;</span><br><span class="line">     Max( 1.2,3.4); // 输出MyMax</span><br><span class="line">     Max(i, j); //输出TemplateMax</span><br><span class="line">     Max( 1.2, 3); //输出TemplateMax2</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意上文的步骤（2）（3）是分开的，匹配模板函数时，是不进行类型自动转换的，不匹配就是不匹配。输入参数有二义性时。编译器不会为开发者做决定</p>
<pre><code>template&lt;class T&gt;
T myFunction( T arg1, T arg2)
{ cout&lt;&lt;arg1&lt;&lt;&quot; &quot;&lt;&lt;arg2&lt;&lt;&quot;\n&quot;; return arg1;}
……
myFunction( 5, 7); //ok： replace T with int
myFunction( 5.8, 8.4); //ok： replace T with double
myFunction( 5, 8.4); //error， no matching function for call to &#39;myFunction(int, double)&#39;
</code></pre>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="类模板的概念"><a href="#类模板的概念" class="headerlink" title="类模板的概念"></a>类模板的概念</h2><p>类也能使用模板，来生成不同成员类型的类<br>类模板：在定义类的时候，加上一个&#x2F;多个类型参数。在使用类模板时，指定类型参数应该如何替换成具体类型，编译器据此生成相应的模板类</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
class 类模板名
{
    成员函数和成员变量
};
</code></pre>
<p>类模板的成员函数的定义写法：</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名（ 参数表）
{
    ……
}
</code></pre>
<p>用类模板实例化对象的写法：</p>
<pre><code>类模板名 &lt;真实类型参数表&gt; 对象名(构造函数实参表);
</code></pre>
<p>一个例子：map类型中的pair类的实现：</p>
<pre><code>template &lt;class T1,class T2&gt;    //pair是类模板
class Pair
{
public:
    T1 key; //关键字
    T2 value; //值
    Pair(T1 k,T2 v):key(k),value(v) { }; //构造函数
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const; //运算符重载函数
};

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
//Pair的运算符重载函数的定义
{
    return key &lt; p.key;
}

 int main()
{
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,19); //实例化出一个类 Pair&lt;string,int&gt;
    cout &lt;&lt; student.key &lt;&lt; &quot; &quot; &lt;&lt; student.value;
    return 0;
}
</code></pre>
<p>输出：Tom 19<br>编译器由类模板生成类的过程叫类模板的实例化。 由类模板实例化得到的类， 叫模板类<br>同一个类模板的两个模板类是不兼容的，即两个不同的类</p>
<pre><code>Pair&lt;string,int&gt; * p;
Pair&lt;string,double&gt; a;
p = &amp; a; //错误，不是同类也不是继承类，不能赋值
</code></pre>
<p>函数模版可以作为类模板成员</p>
<pre><code>template &lt;class T&gt;
class A
{
public:
    template&lt;class T2&gt;
    void Func( T2 t) { cout &lt;&lt; t; } //成员函数模板
};
int main()
{
    A&lt;int&gt; a;
    a.Func(&#39;K&#39;); //成员函数模板 Func被实例化
    a.Func(&quot;hello&quot;); //成员函数模板 Func再次被实例化
    return 0;
} //输出： KHello
</code></pre>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数：</p>
<pre><code>template &lt;class T, int size&gt;
class CArray{
    T array[size];
    public:
    void Print( )
    {
        for( int i = 0;i &lt; size; ++i)
        cout &lt;&lt; array[i] &lt;&lt; endl;
    }
};

CArray&lt;double,40&gt; a2;
CArray&lt;int,50&gt; a3;
</code></pre>
<h2 id="类模板的派生"><a href="#类模板的派生" class="headerlink" title="类模板的派生"></a>类模板的派生</h2><p>类模板也支持类的派生：<br>• 类模板从类模板派生<br>• 类模板从模板类派生<br>• 类模板从普通类派生<br>• 普通类从模板类派生</p>
<p>(1)类模板从类模板派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A {
    T1 v1; T2 v2;
};

template &lt;class T1,class T2&gt;
class B:public A&lt;T2,T1&gt; {
    T1 v3; T2 v4;
};

template &lt;class T&gt;
class C:public B&lt;T,T&gt; {
    T v5;
};

int main() {
    B&lt;int,double&gt; obj1;
    C&lt;int&gt; obj2;
    return 0;
}
</code></pre>
<p>(2)类模板从模板类派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A {
    T1 v1; T2 v2;
};

template &lt;class T&gt;
class B:public A&lt;int,double&gt; {
    T v;
};

int main() {
    B&lt;char&gt; obj1; //自动生成两个模板类：A&lt;int,double&gt; 和 B&lt;char&gt;
    return 0;
}
</code></pre>
<p>(3)类模板从普通类派生</p>
<pre><code>class A {
    int v1;
};

template &lt;class T&gt;
class B:public A { //所有从B实例化得到的类， 都以A为基类
    T v;
};

int main() {
    B&lt;char&gt; obj1;
    return 0;
}
</code></pre>
<p>(4)普通类从模板类派生</p>
<pre><code>template &lt;class T&gt;
class A {
    T v1;
    int n;
};

class B:public A&lt;int&gt; {
    double v;
};
int main() {
    B obj1;
    return 0;
}
</code></pre>
<h2 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h2><p>• 函数、类、类的成员函数作为类模板的友元<br>• 函数模板作为类模板的友元<br>• 函数模板作为类的友元<br>• 类模板作为类模板的友元</p>
<p>(1)函数、类、类的成员函数作为类模板的友元</p>
<pre><code>void Func1() { }
class A { };
class B
{
    public:
    void Func() { }
};

template &lt;class T&gt;
class Tmpl
{
    friend void Func1();
    friend class A;
    friend void B::Func();
}; //任何从Tmp1实例化来的类， 都有以上三个友元
</code></pre>
<p>(2)函数模板作为类模板的友元</p>
<pre><code>template &lt;class T1,class T2&gt;
class Pair
{
private:
    T1 key; //关键字
    T2 value; //值
public:
    Pair(T1 k,T2 v):key(k),value(v) { };
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const;
    template &lt;class T3,class T4&gt;
    friend ostream &amp; operator&lt;&lt; ( ostream &amp; o,
    const Pair&lt;T3,T4&gt; &amp; p);
};

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
{ //&quot;小&quot;的意思就是关键字小
    return key &lt; p.key;
}
template &lt;class T1,class T2&gt;
ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)
{
    o &lt;&lt; &quot;(&quot; &lt;&lt; p.key &lt;&lt; &quot;,&quot; &lt;&lt; p.value &lt;&lt; &quot;)&quot; ;
    return o;
}

int main()
{
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,29);
    Pair&lt;int,double&gt; obj(12,3.14);
    cout &lt;&lt; student &lt;&lt; &quot; &quot; &lt;&lt; obj;
    return 0;
}

输出：
(Tom,29) (12,3.14)
</code></pre>
<p>任意从 <code>template &lt;class T1,class T2&gt; ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)</code>生成的函数，都是任意Pair摸板类的友元</p>
<p>(3)函数模板作为类的友元</p>
<pre><code>class A
{
    int v;
    public:
    A(int n):v(n) { }
    template &lt;class T&gt;
    friend void Print(const T &amp; p);
};
template &lt;class T&gt;
void Print(const T &amp; p)
{
    cout &lt;&lt; p.v;
}

int main() {
    A a(4);
    Print(a);
    return 0;
}

输出：
4
</code></pre>
<p>所有从 <code>template &lt;class T&gt; void Print(const T &amp; p)</code><br>生成的函数，都成为 A 的友元</p>
<p>(4)类模板作为类模板的友元</p>
<pre><code>template &lt;class T&gt;
class B {
    T v;
    public:
    B(T n):v(n) { }
    template &lt;class T2&gt;
    friend class A;
};

template &lt;class T&gt;
class A {
public:
    void Func( ) {
        B&lt;int&gt; o(10);
        cout &lt;&lt; o.v &lt;&lt; endl;
    }
};

int main()
{
    A&lt; double &gt; a;
    a.Func ();
    return 0;
}

输出：
10
</code></pre>
<p>A&lt; double&gt;类，成了B<int>类的友元。任何从A模版实例化出来的类，都是任何B实例化出来的类的友元</p>
<h2 id="类模板与静态成员"><a href="#类模板与静态成员" class="headerlink" title="类模板与静态成员"></a>类模板与静态成员</h2><p>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员</p>
<pre><code>template &lt;class T&gt;
class A
{
private:
    static int count;
    public:
    A() { count ++; }
    ~A() { count -- ; };
    A( A &amp; ) { count ++ ; }
    static void PrintCount() { cout &lt;&lt; count &lt;&lt; endl; }
};

template&lt;&gt; int A&lt;int&gt;::count = 0;
template&lt;&gt; int A&lt;double&gt;::count = 0;
int main()
{
    A&lt;int&gt; ia;
    A&lt;double&gt; da;
    ia.PrintCount();
    da.PrintCount();
    return 0;
}

输出：
1 1
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：继承与多态</title>
    <url>/2020/03/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>前文分析了C++类内成员的关系，本文讨论类和类之间的关系。<br>考虑用C++对现实世界的交通工具进行描述。</p>
<ul>
<li>汽车可能包含各种类型，小汽车，公交车，但他们能抽象出四个轮子，烧油这些基本属性</li>
<li>飞机也有各种类型，但也能抽象出机翼，机身等基本属性</li>
<li>轮船…</li>
</ul>
<p>如果自顶向下设计，如何设计这些对象的类？</p>
<ul>
<li>提炼这些交通工具的共有属性，如材质，耗油量，价格，设计成一个交通工具基础类；然后设计一些操作方法，比如制造，启动，停止。</li>
<li>分别设计汽车、飞机、轮船等更具体的类的属性，比如轮子、排水量等，注意，他们也包含基础类的材质，耗油量，价格等基本属性；然后也设计一些方法，比如制造汽车、开汽车和造飞机、开飞机等</li>
<li>然后再设计更细节的类，作为汽车、飞机、轮船类的细化，比如A品牌的汽车，B品牌汽车，作为两个具体类。</li>
</ul>
<p>仔细考虑以上步骤，有以下问题：</p>
<ul>
<li>这些类的属性（成员变量）是相互独立的吗？</li>
<li>这些类的方法（成员函数）是相互独立的吗？</li>
</ul>
<p>C++用类的“继承”描述层层细化的类及其成员变量的关系，用“多态”描述各层方法的实现关系。</p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承关系的概念"><a href="#继承关系的概念" class="headerlink" title="继承关系的概念"></a>继承关系的概念</h2><p>继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个<strong>基类</strong>（也叫父类），而把B作为基类的一个<strong>派生类</strong>(也叫子类)。</p>
<ul>
<li>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数</li>
<li>派生类一经定义后，可以独立使用，不依赖于基类。</li>
<li>派生类拥有基类的全部成员函数和成员变量，不论是private、 protected、 public。但是派生类的成员函数不能访问基类中的private成员</li>
</ul>
<p>一个管理学生的类继承：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651314.png" alt="image-20221208165130260"><br>派生类语法:</p>
<pre><code>class 派生类名： public 基类名
{
};
</code></pre>
<p>学生类的派生:</p>
<pre><code>class CStudent {
    private:
    string sName;
    int nAge;
    public:
    bool IsThreeGood() { };
    void SetName( const string &amp; name )
    { sName = name; }
        //......
};

class CUndergraduateStudent: public CStudent {
    private:
    int nDepartment;
    public:
    bool IsThreeGood() { ...... }; //覆盖
    bool CanBaoYan() { .... };
}; // 派生类的写法是：类名: public 基类名
</code></pre>
<h2 id="类继承的存储空间"><a href="#类继承的存储空间" class="headerlink" title="类继承的存储空间"></a>类继承的存储空间</h2><p>在类与对象一文讲过，类对象的存储空间，实际就是成员变量的空间，成员函数不在对象空间内（虚函数包含一个虚函数表指针）。那么基类和派生类的对象空间有什么相关性？<br>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。 在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。<br>一个示例：</p>
<pre><code>class CBase
{
    int v1, v2;
};
class CDerived:public CBase
{
    int v3;
};
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651715.png" alt="image-20221208165140659"></p>
<h2 id="类继承的覆盖"><a href="#类继承的覆盖" class="headerlink" title="类继承的覆盖"></a>类继承的覆盖</h2><p>类内的同名非同参的函数叫函数重载，那么基类与派生类的同名函数呢？<br>派生类可以定义和基类成员同名的成员，这叫<strong>覆盖</strong>。在派生类中访问这类成员时，默认访问派生类中定义的成员，基类的成员函数或变量被“覆盖”掉了。如果要在派生类中访问基类定义的同名成员时，要使用作用域符号::<br>一个例子：</p>
<pre><code>class base {    //基类
    int j;  //默认private
    public:
    int i;
    void func();
};
class derived : public base{    //派生类
    public:
    int i;  //覆盖基类i
    void access();
    void func(); //覆盖基类func()
};

void derived::access() { //访问派生类成员
    j = 5; //error
    i = 5; //引用的是派生类的 i
    base::i = 5; //引用的是基类的 i
    func(); //派生类的
    base::func(); //基类的
}
</code></pre>
<p>调用函数:</p>
<pre><code>derived obj;
obj.i = 1;  //访问派生类成员i
obj.base::i = 1; //访问基类成员i
</code></pre>
<p>内存分布:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651894.png" alt="image-20221208165150851"><br>以上只是示例，一般来说，基类和派生类不定义同名成员变量，但经常有同名成员函数，所以覆盖通常用于成员函数覆盖。</p>
<h2 id="类继承的成员访问控制"><a href="#类继承的成员访问控制" class="headerlink" title="类继承的成员访问控制"></a>类继承的成员访问控制</h2><ul>
<li>基类的private成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数</li>
<li>基类的public成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数<br>– 派生类的友元函数<br>– 其他的函数</li>
<li>基类的protected成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数可以访问当前对象的基类的保护成员</li>
</ul>
<p>一个示例：</p>
<pre><code>class Father {
    private: int nPrivate; //私有成员
    public: int nPublic; //公有成员
    protected: int nProtected; // 保护成员
};
class Son :public Father{
    void AccessFather () {
        nPublic = 1; // ok;
        nPrivate = 1; // wrong
        nProtected = 1; // OK，访问从基类继承的protected成员
        Son f;
        f.nProtected = 1; //wrong ， f不是当前对象
    }
};

int main()
{
    Father f;
    Son s;
    f.nPublic = 1; // Ok
    s.nPublic = 1; // Ok
    f.nProtected = 1; // error
    f.nPrivate = 1; // error
    s.nProtected = 1; //error
    s.nPrivate = 1; // error
    return 0;
}
</code></pre>
<h2 id="类继承的构造函数"><a href="#类继承的构造函数" class="headerlink" title="类继承的构造函数"></a>类继承的构造函数</h2><p>类似于嵌套类（封闭类）的构造函数，使用初始化列表来实现层层构造，基类和派生类只初始化他们能访问的成员</p>
<pre><code>class Bug {
private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug (){ };
};

class FlyBug: public Bug // FlyBug是Bug的派生类
{
    int nWings;
    public:
    FlyBug( int legs,int color, int wings);
};

Bug::Bug( int legs, int color) //Bug类的构造函数
{
    nLegs = legs;
    nColor = color;
}

//错误的FlyBug构造函数！
FlyBug::FlyBug ( int legs,int color, int wings)
{
    nLegs = legs; // 不能访问
    nColor = color; // 不能访问
    nType = 1; // ok
    nWings = wings;
}

//正确的FlyBug构造函数：使用初始化列表
FlyBug::FlyBug ( int legs, int color, int wings):Bug( legs, color)
{
    nWings = wings;
}

int main() {
    FlyBug fb ( 2,3,4);
    fb.PrintBug();
    fb.nType = 1;
    fb.nLegs = 2 ; // error. nLegs is private
    return 0;
}
</code></pre>
<h2 id="类继承的构造析构时序"><a href="#类继承的构造析构时序" class="headerlink" title="类继承的构造析构时序"></a>类继承的构造析构时序</h2><p>在创建派生类的对象时，需要调用基类的构造函数：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。<br>调用基类构造函数的两种方式:</p>
<ul>
<li><p>显式方式：在派生类的构造函数中，为基类的构造函数提供参数.</p>
<p> derived::derived(arg_derived-list):base(arg_base-list)</p>
</li>
<li><p>隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数</p>
</li>
</ul>
<p>析构函数执行时序:<br>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。<br>一个例子：</p>
<pre><code>class Base {
    public:
    int n;
    Base(int i):n(i)
    { cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;}
    ~Base()
    { cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; destructed&quot; &lt;&lt; endl; }
};
    
class Derived:public Base {
    public:
    Derived(int i):Base(i)
    { cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl; }
    ~Derived()
    { cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;}
};
int main() { Derived Obj(3); return 0; }
</code></pre>
<p>输出结果:</p>
<pre><code>Base 3 constructed
Derived constructed
Derived destructed
Base 3 destructed
</code></pre>
<p>##封闭派生类的构造函数<br>封闭类的构造用初始化列表，派生类也用初始化列表，那么封闭派生类呢？<br>还是初始化列表</p>
<pre><code>class Bug {
    private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug (){ };
};

class Skill {
    public:
    Skill(int n) { }
};
class FlyBug: public Bug {
    int nWings;
    Skill sk1, sk2;
    public:
    FlyBug( int legs, int color, int wings);
};
FlyBug::FlyBug( int legs, int color, int wings):
    Bug(legs,color),sk1(5),sk2(color) ,nWings(wings) { //初始化列表，不能访问的通通交给下层构造函数
}
</code></pre>
<h2 id="封闭派生类的构造析构时序"><a href="#封闭派生类的构造析构时序" class="headerlink" title="封闭派生类的构造析构时序"></a>封闭派生类的构造析构时序</h2><p>在创建派生类的对象时:</p>
<ol>
<li>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员</li>
<li>再执行成员对象类的构造函数，用以初始化派生类对象中成员对象</li>
<li>最后执行派生类自己的构造函数<br>在派生类对象消亡时：</li>
<li>先执行派生类自己的析构函数</li>
<li>再依次执行各成员对象类的析构函数</li>
<li>最后执行基类的析构函数<br>析构函数的调用顺序与构造函数的调用顺序相反</li>
</ol>
<h1 id="类的复合"><a href="#类的复合" class="headerlink" title="类的复合"></a>类的复合</h1><p>在数学上，两个集合有无关、相交和包含的关系。对于多个类来说，也应该有以上三种关系。无关类&#x3D;两个成员不相关的类；继承类&#x3D;类成员间有继承关系的类；那么相交的类呢？</p>
<h2 id="复合关系的概念"><a href="#复合关系的概念" class="headerlink" title="复合关系的概念"></a>复合关系的概念</h2><p>C++用“复合”表示类的相交关系。<br>1)继承：“是”的关系<br>基类是A， B是基类A的派生类，逻辑上要求：“一个B对象也是一个A对象”<br>2)复合：“有”的关系<br>类C中“有” 成员变量k，k是类D的对象，则C和D是复合关系，逻辑上要求：“D对象是C对象的固有属性或组成部分</p>
<p>下面比较一下继承和复合在具体设计的实例：<br>继承关系顶层设计例子:</p>
<ul>
<li>写了一个 CMan 类代表男人</li>
<li>后来又发现需要一个CWoman类来代表女人</li>
<li>CWoman类和CMan类有共同之处,让CWoman类从CMan类派生而来，是否合适？</li>
<li>错！从一开始就应该设计CHuman类，代表“人” ,然后CMan和CWoman都从<br>CHuman派生</li>
</ul>
<p>继承逻辑关系：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652246.png" alt="image-20221208165210195"></p>
<p>复合关系顶层设计例子：</p>
<ul>
<li>几何形体程序中，需要写“点”类，也需要写“圆”类</li>
<li>每个圆都有圆心，那么点类应该从圆类派生出来吗？</li>
<li>错！”点“不仅在圆内有，在其他图形也有，不是圆独有，非继承关系</li>
<li>实际上，圆和点是复合关系，每一个“圆”对象里都包含(<strong>有</strong>)一个“点”对象</li>
<li>逻辑上，复合关系就是，我的一部分可以看成是你的，但是我的全部东西不都属于你</li>
</ul>
<p>复合关系的类通常用友元实现：</p>
<pre><code>class CPoint
{
    double x,y;
    friend class CCircle;
    //便于Ccirle类操作其圆心
};

class CCircle
{
    double r;
    CPoint center;
};
</code></pre>
<h2 id="复合关系的典型示例"><a href="#复合关系的典型示例" class="headerlink" title="复合关系的典型示例"></a>复合关系的典型示例</h2><p>如果要写一个小区养狗管理程序，需要写一个“业主”类，还需要写一个“狗” 类<br>狗是归宿于业主的，一个业主可以有多条狗，狗也可以随时脱离业主<br>考虑以下设计方法：<br>设计人和狗两个类，相互包含对方类</p>
<pre><code>class CDog;
class CMaster
{
    CDog dogs[10];
};
class CDog
{
    CMaster m;
};
</code></pre>
<p> 这样有循环定义错误！且逻辑上，狗和人并非相互包含关系<br> 这种关系上相互相关，对象本身又完全独立的情况，用对象指针表示</p>
<pre><code>class CMaster; //CMaster必须提前声明，不能先写CMaster类后写Cdog类
class CDog {
    CMaster * pm;
};
class CMaster {
    CDog * dogs[10];
};
</code></pre>
<p>逻辑关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652390.png" alt="image-20221208165220338"></p>
<h1 id="继承的不足"><a href="#继承的不足" class="headerlink" title="继承的不足"></a>继承的不足</h1><h2 id="继承方式的访问限制"><a href="#继承方式的访问限制" class="headerlink" title="继承方式的访问限制"></a>继承方式的访问限制</h2><p>基类和派生类是包含的关系，那么基类对象和派生类对象是什么关系？<br>对于类的public派生方式:</p>
<pre><code>class base { };
class derived : public base { };
base b;
derived d;
</code></pre>
<p>1）派生类的对象可以赋值给基类对象<br>b &#x3D; d;<br>2）派生类对象可以初始化基类引用<br>base &amp; br &#x3D; d;<br>3）派生类对象的地址可以赋值给基类指针<br>base * pb &#x3D; &amp; d;<br>如果派生方式是 private或protected，则上述三条不可行</p>
<p>对于类的protected和private派生方式:</p>
<pre><code>class base {};
class derived : protected base {};
base b;
derived d;
</code></pre>
<p>• protected继承时，基类的public成员和protected成员成为派生类的protected成员。<br>• private继承时，基类的public成员成为派生类的private成员，基类的protected成员成为派生类的不可访问成员。<br>• protected和private继承不是“是”的关系</p>
<h2 id="派生类的对象指针转换"><a href="#派生类的对象指针转换" class="headerlink" title="派生类的对象指针转换"></a>派生类的对象指针转换</h2><p>public派生的情况下,派生类对象的指针可以直接赋值给基类指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
//ptrBase指向的是一个Derived类的对象；
</code></pre>
<p>*ptrBase可以看作一个Base类的对象，访问它的public成员直接通过ptrBase即可，但不能通过ptrBase访问objDerived对象中属于Derived类而不属于Base类的成员<br>过强制指针类型转换，可以把ptrBase转换成Derived类的指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
Derived *ptrDerived = (Derived * ) ptrBase;
</code></pre>
<p>程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会错</p>
<p>派生类的指针赋值给基类后，基类指针也不能访问派生类的特有成员</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Base {
    protected:
    int n;
    public:
    Base(int i):n(i){cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; constructed&quot; &lt;&lt; endl; }
    ~Base() {cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; destructed&quot; &lt;&lt; endl;}
    void Print() { cout &lt;&lt; &quot;Base:n=&quot; &lt;&lt; n &lt;&lt; endl;}
};

class Derived:public Base {
    public:
    int v;
    Derived(int i):Base(i),v(2 * i) {
    cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl;
}

~Derived() {
    cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;
}

void Func() { } ;
    void Print() {
        cout &lt;&lt; &quot;Derived:v=&quot; &lt;&lt; v &lt;&lt; endl;
        cout &lt;&lt; &quot;Derived:n=&quot; &lt;&lt; n &lt;&lt; endl;
    }
};

int main() {
    Base objBase(5);
    Derived objDerived(3);
    Base * pBase = &amp; objDerived ;
    //pBase-&gt;Func(); //err;Base类没有Func()成员函数
    //pBase-&gt;v = 5; //err; Base类没有v成员变量
    pBase-&gt;Print();
    //Derived * pDerived = &amp; objBase; //error
    Derived * pDerived = (Derived *)(&amp; objBase);
    pDerived-&gt;Print(); //慎用，可能出现不可预期的错误
    pDerived-&gt;v = 128; //往别人的空间里写入数据，会有问题
    objDerived.Print();
    return 0;
}
</code></pre>
<p>输出：</p>
<pre><code>Base 5 constructed
Base 3 constructed
Derived constructed
Base:n=3
Derived:v=1245104 //pDerived-&gt;n 位于别人的空间里
Derived:n=5
Derived:v=6
Derived:n=3
Derived destructed
Base 3 destructed
Base 5 destructed
</code></pre>
<p>从逻辑上来说，派生类指针既然能被赋值给基类指针，那么通过基类指针，应该能调用派生类的成员函数，获取派生类的成员变量。在下一章，继承类的多态将实现这个目的。</p>
<h2 id="多级继承"><a href="#多级继承" class="headerlink" title="多级继承"></a>多级继承</h2><p>类A派生类B，类B派生类C，类C派生类D……<br>– 类A是类B的直接基类<br>– 类B是类C的直接基类，类A是类C的间接基类<br>– 类C是类D的直接基类，类A、 B是类D的间接基类<br>在声明派生类时， 只需要列出它的直接基类<br>– 派生类沿着类的层次自动向上继承它的间接基类<br>– 派生类的成员包括<br>• 派生类自己定义的成员<br>• 直接基类中的所有成员<br>• 所有间接基类的全部成员</p>
<h1 id="多态：在继承上更进一步"><a href="#多态：在继承上更进一步" class="headerlink" title="多态：在继承上更进一步"></a>多态：在继承上更进一步</h1><p>前面派生类的对象指针转换一节，基类指针强转后也不能访问派生类私有对象。考虑一下本文开始讲的交通工具顶层设计思路，在顶层设计时就要设计类的成员函数，在派生类也要设计成员函数，这些函数会有重合的情况吗？如果有重合，基类指针也不能访问派生类成员，这样基类和派生类不就失去联系了吗？多级继承这种情况不是更加严重？<br>为了解决这种问题，本节引入继承类的“多态”<br>多态能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少</p>
<h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><p>在类的定义中，前面有 virtual 关键字的成员函数就是虚函数</p>
<pre><code>class base {
    virtual int get() ;
};
int base::get(){ }
</code></pre>
<p>virtual关键字只用在类定义里的函数声明中使用，定义函数体时不用。<br>使用虚函数，来实现“多态”效果。多态有通过指针和引用两种表现形式:</p>
<ul>
<li>能通过基类的指针调用派生类虚函数，访问其特有成员变量</li>
</ul>
<p>派生类的指针可以赋给基类指针<br>通过基类指针调用基类和派生类中的同名虚函数时:<br>（1）若该指针指向一个基类的对象，那么被调用是<br>基类的虚函数；<br>（2）若该指针指向一个派生类的对象，那么被调用<br>的是派生类的虚函数</p>
<pre><code>class CBase {
public:
    virtual void SomeVirtualFunction() { }
};
class CDerived:public CBase {
public :
    virtual void SomeVirtualFunction() { }
};
int main() {
    CDerived ODerived;
    CBase * p = &amp; ODerived;
    p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象
    return 0;
} 
</code></pre>
<ul>
<li>能通过基类的引用调用派生类虚函数</li>
</ul>
<p>派生类的对象可以赋给基类引用<br>通过基类引用调用基类和派生类中的同名虚函数时:<br>（1）若该引用引用的是一个基类的对象，那么被调<br>用是基类的虚函数；<br>（2）若该引用引用的是一个派生类的对象，那么被<br>调用的是派生类的虚函数。</p>
<pre><code>class CBase {
public:
    virtual void SomeVirtualFunction() { }
};
class CDerived:public CBase {
public :
    virtual void SomeVirtualFunction() { }
};
int main() {
    CDerived ODerived;
    CBase &amp; r = ODerived;
    r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象
    return 0;
} 
</code></pre>
<p>是不是所有成员函数加virtual都是多态？不是！</p>
<ul>
<li>在非构造或析构函数的成员函数中调用虚函数，是多态。在运行时才确定到底调用哪一层派生类函数</li>
<li>在构造函数和析构函数中调用虚函数，不是多态。调用的函数是当前类的函数，编译时即确定</li>
</ul>
<p>多层继承实现多态，每一层都要加virtual关键字吗？</p>
<ul>
<li>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</li>
</ul>
<h2 id="多态与对象指针"><a href="#多态与对象指针" class="headerlink" title="多态与对象指针"></a>多态与对象指针</h2><p>一个变量有两方面属性：类型、值<br>那么多态把derived类的地址值，赋值给base类的指针，访问对象成员时是什么效果？<br>以下例子的this指针指向什么？</p>
<pre><code>class Base {
public:
    void fun1() { this-&gt;fun2(); } //this是基类指针， fun2是虚函数，所以是多态
    virtual void fun2() { cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; }
};
class Derived:public Base {
public:
    virtual void fun2() { cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; }
};
int main() {
    Derived d;
    Base * pBase = &amp; d;
    pBase-&gt;fun1();
    return 0;
}
</code></pre>
<p>pBase被Derived对象的地址赋值后，其值为Derived对象的地址，但类型还是Base的指针（多态指针赋值不会强转）。pBase-&gt;fun1()会先在Base类访问其fun1()，传入this指针（指向fun2）,而this-&gt;fun2()会调用Derived类的fun2()<br>输出： </p>
<pre><code>Derived:fun2()
</code></pre>
<p>虚函数也可以定义为private：</p>
<pre><code>class Base {
private:
    virtual void fun2() { cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; }
};
class Derived:public Base {
public:
    virtual void fun2() { cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; }
};
Derived d;
Base * pBase = &amp; d;
pBase -&gt; fun2(); // 编译出错
</code></pre>
<p>pBase已经被赋值为指向derived d的指针，不能调用base类的private函数。</p>
<h2 id="多态的实例-游戏开发"><a href="#多态的实例-游戏开发" class="headerlink" title="多态的实例:游戏开发"></a>多态的实例:游戏开发</h2><p>游戏中有很多种怪物，每种怪物都有一个类与之对应。某个玩家创建的具体怪物就是对象<br>怪物的主要动作（成员函数）有：</p>
<ul>
<li>攻击（Attack），针对不同的被攻击者有不同的函数</li>
<li>反击（FightBack），被某个怪物攻击时做出的相应动作</li>
<li>掉血（Hurted），被攻击时会掉血，血量值不同有不同处理，如死亡</li>
</ul>
<p>现在的需求是：已经有CWolf、CGhost两种怪物，需要设计新的怪物CThunderBird，并能满足和其他怪物的交互<br>顶层设计:<br>设置基类 CCreature，并且使CDragon, CWolf等其他类都从CCreature派生而来<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652097.png" alt="image-20221208165241029"><br>非多态的派生类设计：<br>由于每个怪物对于其他怪物的攻击和反击都是不同的，每个怪物类都要设计一组Attack和FightBack：</p>
<pre><code>class class CCreature {
    protected: int nPower ; //代表攻击力
    int nLifeValue ; //代表生命值
};
class CThunderBird : public CCreature {
    public:
    void Attack(CWolf * pWolf) {
        ．．．表现攻击动作的代码
        pWolf-&gt;Hurted( nPower);
        pWolf-&gt;FightBack( this);
    }
    void Attack( CDragon * pDragon) {
        ．．．表现攻击动作的代码
        pDragon-&gt;Hurted( nPower);
        pDragon-&gt;FightBack( this);
    }
    void FightBack( CWolf * pWolf) {
        ．．．．表现反击动作的代码
        pWolf -&gt;Hurted( nPower / 2);
    }
    void FightBack( CDragon * pDragon) {
        ．．．．表现反击动作的代码
        pDragon-&gt;Hurted( nPower / 2 );
    }
    void Hurted ( int nPower) {
        ．．．．表现受伤动作的代码
        nLifeValue -= nPower;
    }
}
</code></pre>
<p>现有n种怪物，CThunderBird类中就得有n个Attack 和n个FightBack成员函数，对于其他类也得新增针对CThunderBird的Attack和FightBack。这种设计工作量过于巨大。原因就在于要区分传入的对象指针。<br>那么能否传入基类的指针呢，这样就不存在为各种类型写几个函数。基类指针要访问派生类的成员，得用虚函数形成多态。多态实现如下：</p>
<pre><code>//基类 CCreature：
class CCreature {
protected :
    int m_nLifeValue, m_nPower;
    public:
    virtual void Attack( CCreature * pCreature) {}
    virtual void Hurted( int nPower) { }
    virtual void FightBack( CCreature * pCreature) {}
};
//派生类 CDragon:
class CDragon : public CCreature {
public:
    virtual void Attack( CCreature * pCreature);
    virtual void Hurted( int nPower);
    virtual void FightBack( CCreature * pCreature);
};

//派生类的成员函数实现具体操作
void CDragon::Attack(CCreature * p) //传入基类指针
{ …表现攻击动作的代码
    p-&gt;Hurted(m_nPower); //多态
    p-&gt;FightBack(this); //多态
}
void CDragon::Hurted( int nPower)
{ …表现受伤动作的代码
    m_nLifeValue -= nPower;
}
void CDragon::FightBack(CCreature * p)
{ …表现反击动作的代码
    p-&gt;Hurted(m_nPower/2); //多态
}

//多态的调用
CDragon Dragon; CWolf Wolf; CGhost Ghost;
CThunderBird Bird；
Dragon.Attack( &amp; Wolf); //调用CWolf::Hurted
Dragon.Attack( &amp; Ghost); //调用CGhost::Hurted
Dragon.Attack( &amp; Bird); //调用CBird::Hurted
</code></pre>
<p>使用多态，新增某个派生类时，已有的类可以原封不动，因为传入基类指针，会“自动”调用正确的派生类函数，开发者只需要设计新增的派生类和其成员函数即可</p>
<h2 id="多态的原理：虚函数表指针"><a href="#多态的原理：虚函数表指针" class="headerlink" title="多态的原理：虚函数表指针"></a>多态的原理：虚函数表指针</h2><p>多态” 的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定，这叫“动态联编”<br>首先分析包含虚函数的类对象的内存分布：</p>
<pre><code>class Base {
public:
int i;
    virtual void Print() { cout &lt;&lt; &quot;Base:Print&quot; ; }
};

class Derived : public Base{
public:
int n;
    virtual void Print() { cout &lt;&lt;&quot;Drived:Print&quot; &lt;&lt; endl; }
};

int main() {
    Derived d;
    cout &lt;&lt; sizeof( Base) &lt;&lt; &quot;,&quot;&lt;&lt; sizeof( Derived ) ;
    return 0;
}
</code></pre>
<p>输出：8, 12<br>为什么类对象的size比成员变量int（4字节）还多4字节？<br>因为包含虚函数的基类，实例化的对象除了成员变量，还包含一个指针（一般4字节），指向虚函数的入口地址，如果有多个虚函数，这些地址连续排列形成虚函数表，指针指向首个虚函数地址。如果这个指针指向基类，就能找到基类的所有虚函数入口，如果指针指向派生类，就能找到派生类的的所有虚函数入口。基类和派生类对象的指针赋值，实际会导致虚函数表指针指向的虚函数入口地址不同，从而调用时不同。<br>如果当前指针指向基类，则调用基类自己的虚函数：</p>
<pre><code>Base b;
pBase = &amp;b;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652980.png" alt="image-20221208165259927"><br>如果当前指针指向派生类，则调用派生类的虚函数：</p>
<pre><code>Derived d;
pDerived = &amp;d;
pBase = pDerived;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081653211.png" alt="image-20221208165311145"><br>动态联编的实现：<br>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令<br>而普通函数是编译过程中确定了成员函数的入口地址，不存在运行时根据对象来改变某个函数的入口地址。</p>
<h2 id="虚函数与抽象类"><a href="#虚函数与抽象类" class="headerlink" title="虚函数与抽象类"></a>虚函数与抽象类</h2><p>可以想象得到，前文的游戏使用虚函数的例子是通用的，先设计基类，提炼对象属性，定义虚函数；再派生子类，在子类实现局函数的具体操作。那么问题来了，基类的虚函数有必要实现函数体吗？<br>很多情况，基类只是一个抽象，定义了函数的名称和参数，不需要在基类实现虚函数，全部交给派生类实现。</p>
<ul>
<li>纯虚函数：没有函数体的虚函数</li>
<li>抽象类：包含纯虚函数的类</li>
</ul>
<p>纯虚函数写法：没函数体{}，直接&#x3D;0</p>
<pre><code>class A {
private: int a;
public:
    virtual void Print( ) = 0 ; //纯虚函数
    void fun() { cout &lt;&lt; &quot;fun&quot;; }
};
</code></pre>
<p>抽象类特点：</p>
<ul>
<li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li>
<li>可以创建抽象类的指针和引用，它们可以指向派生类的对象</li>
</ul>
<p>抽象类的指针：</p>
<pre><code>A a ; // 错， A 是抽象类，不能创建对象
A * pa ; // ok,可以定义抽象类的指针和引用
pa = new A ; //错误, A 是抽象类，不能创建对象
</code></pre>
<p>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类<br>抽象类的成员函数可以调用纯虚函数，但是构造函数或析构函数内不能调用纯虚函数</p>
<pre><code>class A {
public:
    virtual void f() = 0; //纯虚函数
    void g( ) { 
        this-&gt;f( ) ; //ok
    }
    A( ){ 
        f( ); // 错误
    }
};
class B:public A{
public:
    void f(){cout&lt;&lt;&quot;B:f()&quot;&lt;&lt;endl; }
};
</code></pre>
<h2 id="虚函数与构造析构函数"><a href="#虚函数与构造析构函数" class="headerlink" title="虚函数与构造析构函数"></a>虚函数与构造析构函数</h2><p>前面考虑了普通成员函数加virtual，可以形成虚函数达到继承类的多态效果。那么构造函数和析构函数呢？</p>
<ul>
<li>不允许以虚函数作为构造函数</li>
<li>类继承需要把基类的析构函数设为虚函数</li>
</ul>
<p>对于常规析构函数，通过基类指针删除派生类对象时，只能调用基类的析构函数。但是合理的做法是，应该先调用派生类的析构函数，然后调用基类的析构函数。解决的方法：把析构函数定义为virtual，由于基类析构函数是虚函数，派生类的同名析构函数自然也是虚函数。<br>什么时候定义虚析构函数</p>
<ul>
<li>一个类只要定义了虚函数，则应该将析构函数也定义成虚函数</li>
<li>一个类打算作为基类使用，则应该将析构函数定义成虚函数</li>
</ul>
<p>虚析构函数用法：通过基类的指针删除派生类对象，会首先调用派生类的析构函数，然后调用基类的析构函数</p>
<pre><code>class son{
public:
    virtual ~son() {cout&lt;&lt;&quot;bye from son&quot;&lt;&lt;endl;};
};
class grandson:public son{
public:
    ~grandson(){cout&lt;&lt;&quot;bye from grandson&quot;&lt;&lt;endl;};
};
int main() {
    son *pson;
    pson= new grandson(); //pson指向派生类grandson
    delete pson;
    return 0;
}
</code></pre>
<p>输出： </p>
<pre><code>bye from grandson
bye from son
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象笔记：类和对象</title>
    <url>/2020/03/18/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++，加的到底是什么？<br>除了基础语法的补充和优化，C++另外几个核心特点是：</p>
<ul>
<li><p>面向对象设计的支持：</p>
<p> 类和对象对变量和函数的封装<br> 类和类之间的继承<br> 继承关系的类之间的函数调用的多态</p>
</li>
<li><p>数据结构和算法的支持<br> STL和各种常用数据类型</p>
</li>
<li><p>高可复用、可拓展的支持<br> 类模板，函数模板<br> 函数、运算符的重载</p>
</li>
</ul>
<p>本文内容：</p>
<ul>
<li>面向对象设计的概念</li>
<li>类和对象的概念及使用</li>
<li>类的几种构造函数</li>
<li>类的析构函数</li>
<li>类对象的this指针</li>
<li>类的嵌套：封闭类</li>
<li>成员的属性：友元和常量成员</li>
</ul>
<h1 id="面向对象设计的概念"><a href="#面向对象设计的概念" class="headerlink" title="面向对象设计的概念"></a>面向对象设计的概念</h1><h2 id="面向过程设计的不足"><a href="#面向过程设计的不足" class="headerlink" title="面向过程设计的不足"></a>面向过程设计的不足</h2><p>程序 &#x3D; 数据结构 + 算法<br>程序由全局变量以及众多相互调用的函数组成，算法以函数的形式实现，用于对数据结构进行操作。<br>结构化程序设计风格中，变量和函数的关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081646566.png" alt="image-20221208164648489"><br>其缺陷在于：</p>
<ul>
<li>结构化程序设计中，函数和其所操作的数据结构，没有直观的联系</li>
<li>随着程序规模的增加，程序逐渐难以理解:<br> 某个数据结构到底有哪些函数可以对它进行操作?<br> 某个函数到底是用来操作哪些数据结构的?<br> 任何两个函数之间存在怎样的调用关系?</li>
<li>结构化程序设计难以维护:<br>由于没有“封装”和“隐藏”的概念，要访问某个数据结构中的某个变量，就可以直接访问，那么当该变量的定义有改动的时候，就要把所有访问该变量的语句找出来修改，不利于程序的维护、扩充。</li>
<li>结构化程序设计难以查错:<br>当某个数据结构的值不正确时，难以找出到底是那个函数导致的。</li>
<li>结构化程序设计难以重用：<br>在编写某个程序时，发现其需要的某项功能，在现有的某个程序里已经有了相同或类似的实现，那么自然希望能够将那部分代码抽取出来，在新程序中使用。在结构化程序设计中，随着程序规模的增大，由于程序大量函数、变量之间的关系错综复杂，要抽取这部分代码，会变得十分困难。</li>
</ul>
<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><p>面向对象的程序设计方法，能够较好解决上述问题<br>面向对象的程序 &#x3D; 类 + 类 + …+ 类<br>设计程序的过程，就是设计类（class）的过程<br>面向对象的程序设计方法:</p>
<ul>
<li>将某类客观事物共同特点（<strong>属性</strong>）归纳出来，形成一个数据结构（可以用多个变量描述事物的属性）</li>
<li>将这类事物所能进行的<strong>行为</strong>也归纳出来，形成一个个函数，这些函数可以用来操作数据结构(这一步叫“ <strong>抽象</strong>”）</li>
<li>然后，通过某种语法形式，将数据结构和操作该数据结构的函数“捆绑”在一起，形成一个“ 类”，从而使得数据结构和操作该数据结构的算法呈现出显而易见的紧密关系，这就是“<strong>封装</strong>”</li>
<li>类与类直接又形成<strong>继承、多态</strong>等关系</li>
<li>面向对象的程序设计具有“抽象”，“封装”“继承”“多态”四个基本特点。</li>
</ul>
<p>面向对象设计风格中，变量和函数的关系;<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081647726.png" alt="image-20221208164703654"></p>
<h2 id="语言和风格的无关性"><a href="#语言和风格的无关性" class="headerlink" title="语言和风格的无关性"></a>语言和风格的无关性</h2><p>注意面向过程、面向对象以及其他的风格（如函数式编程等），只是编程风格，其本质都是组织数据结构（事物属性）和算法（对事物的操作）。<br>C++有原生的类的概念，更方便写出面向对象风格的程序<br>Q. C语言没有类，能不能写出面向对象？<br>可以，C的结构体就是对数据的封装，配合函数指针，也能包含函数成员。利用带函数指针的结构体能实现属性和方法的封装，在Linux内核和设备驱动程序中充满了这种面向对象设计风格。事实上，C++的class在编译器处理后就是类似于C的结构体。<br>Q. 什么时候应该面向对象？<br>面向对象对于人的抽象概括的能力要求较高，需要花较多精力在top-down的顶层设计中，通常用于大型的长期维护的程序设计。<br>面向对象的优势在于数据结构组织化，程序时间和空间的开销可能不如面向过程。例如一个对象里的各个数据的生命周期都是捆绑分配和释放的，而面向过程可以更精细管理。在极端资源紧缺的情况，如部分嵌入式开发，面向过程不论代码设计速度和性能都比面向对象好。</p>
<h1 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a>类和对象的概念</h1><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>设计一个程序，接受输入矩形的长和宽，输出面积和周长<br>如何用类来封装？</p>
<ul>
<li>矩形的属性就是长和宽。因此需要两个变量，分别代表长和宽</li>
<li>矩形的操作方法可以有设置长和宽，算面积，算周长。每个操作各用一个函数来实现，且函数都需要用到长和宽这两个属性</li>
<li>将以上属性和方法组合就能形成一个“矩形类”。长、宽变量成为该“矩形类”的“成员变量”，三个函数成为该类的“成员函数”。成员变量和成员函数统称为类的成员。“类”看上去就像“带函数的结构”</li>
</ul>
<p>类的声明：</p>
<pre><code>class CRectangle
&#123;
    public:
        int w, h;
        int Area() &#123;
        return w * h;
    &#125;
    int Perimeter()&#123;
        return 2 * ( w + h);
    &#125;
    void Init( int w_,int h_ ) &#123;
        w = w_; h = h_;
    &#125;
&#125;; //必须有分号
</code></pre>
<p>类的实例化：</p>
<pre><code>int main( )
&#123;
    int w,h;
    CRectangle r; //r是一个对象
    cin &gt;&gt; w &gt;&gt; h;
    r.Init( w,h);
    cout &lt;&lt; r.Area() &lt;&lt; endl &lt;&lt;
    r.Perimeter();
    return 0;
&#125;
</code></pre>
<p>通过类，可以定义变量。类定义出来的变量，也称为类的实例，就是“<strong>对象</strong>”，对象的本质是在内存中分配了一个存放类这个结构的空间。<br>C++中，类的名字就是用户自定义的类型的名字。可以像使用基本类型那样来使用。 CRectangle就是一种用户自定义的类型。</p>
<h2 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h2><ul>
<li><p>和结构变量一样，对象所占用的内存空间的大小，等于所有成员变量的大小之和（考虑内存对齐可能更大）。对于上面的CRectangle类，sizeof(CRectangle)<br>&#x3D; 8</p>
</li>
<li><p>每个对象各有自己的存储空间。一个对象的某个成员变量被改变了，不会影响到另一个对象</p>
</li>
<li><p>和结构变量一样，对象之间可以用 “&#x3D;”进行赋值，但是不能用 “&#x3D;&#x3D;”“!&#x3D;”“&gt;”“&lt;”“&gt;&#x3D;”“&lt;&#x3D;”进行比较，除非这些运算符经过了“重载”。</p>
</li>
</ul>
<p>Q.类分配内存产生对象后，成员变量占用空间，成员函数占不占用空间?<br>普通成员函数不在对象生成时分配函数空间，因为函数是静态绑定的，即函数体指令只占用代码段的一处空间，对象调用该函数之间跳到该空间入口地址，在对象分配时不会在堆或栈再开辟空间存放函数体。<br>但是当类中定义了虚函数，分配对象时要分配4字节（多个虚函数也是4个字节）的指针指向虚函数表。函数跳转地址依赖于运行时才产生的对象里的虚函数表，称为动态绑定，对象调用虚函数时不知道准确的跳转地址，只跳转到虚函数表查找跳转地址，再根据查找结果跳转。</p>
<h2 id="对象访问其成员"><a href="#对象访问其成员" class="headerlink" title="对象访问其成员"></a>对象访问其成员</h2><p>类似于C结构体实例访问其成员的方法，用实例.成员，实例指针-&gt;成员，除此之外C++特有的通过引用访问：实例引用.成员<br>用法1：对象名.成员名</p>
<pre><code>CRectangle r1,r2;
r1.w = 5;
r2.Init(5,4);
</code></pre>
<p>Init函数作用在 r2 上，即Init函数执行期间访问的w 和 h是属于r2 这个对象的, 执行r2.Init 不会影响到r1<br>用法2. 指针-&gt;成员名</p>
<pre><code>CRectangle r1,r2;
CRectangle * p1 = &amp; r1;
CRectangle * p2 = &amp; r2;
p1-&gt;w = 5;
p2-&gt;Init(5,4); //Init作用在p2指向的对象上
</code></pre>
<p>用法3：引用名.成员名</p>
<pre><code>CRectangle r2;
CRectangle &amp; rr = r2;
rr.w = 5;
rr.Init(5,4); //rr的值变了， r2的值也变
</code></pre>
<h1 id="类成员的访问方式"><a href="#类成员的访问方式" class="headerlink" title="类成员的访问方式"></a>类成员的访问方式</h1><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><p>Q. C++将数据和函数封装成类的成员，那么类内成员、内间成员的访问权限如何控制？<br>用下列访问范围关键字来说明类成员可被访问的范围：</p>
<ul>
<li>private: 私有成员，只能在成员函数内访问</li>
<li>public : 公有成员，可以在任何地方访问</li>
<li>protected: 保护成员，用于继承关系的类的成员访问控制</li>
</ul>
<p>定义一个带访问控制的类：</p>
<pre><code>class className &#123;
    private:
    私有属性和函数
    public:
    公有属性和函数
    protected:
    保护属性和函数
&#125;;
</code></pre>
<p>如过某个成员前面没有上述关键字，则缺省地被认为是private私有成员:</p>
<pre><code>class Man &#123;
    int nAge;       //私有成员
    char szName[20]; // 私有成员
public:
    void SetName(char * szName)&#123;
    strcpy( Man::szName,szName);
    &#125;
&#125;;
</code></pre>
<p>在类的成员函数内部，能够访问：</p>
<ul>
<li>当前对象的全部属性、 函数；</li>
<li>同类其它对象的全部属性、函数。</li>
</ul>
<p>在类的成员函数以外的地方，只能够访问该类对象的公有成员<br>注意：<br>通过对象的成员函数，可以访问同类其他对象的任意成员（即使是private）。private、public、protected真正的作用是限制成员变量的直接访问，而通过成员函数来访问成员变量是不受影响的。</p>
<h2 id="访问控制与隐藏"><a href="#访问控制与隐藏" class="headerlink" title="访问控制与隐藏"></a>访问控制与隐藏</h2><p>成员访问控制可以定义类的成员变量能否被任意访问、或通过成员函数访问、能否被继承的子类访问等。这种机制称为对成员变量的<strong>隐藏</strong><br>隐藏的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则所有直接访问成员变量的语句都需要修改<br>一个类成员变量隐藏的例子：</p>
<pre><code> //类定义
    class CEmployee &#123;
    private:
        char szName[30]; //名字
    public :
        int salary; //工资
        void setName(char * name);
        void getName(char * name);
        void averageSalary(CEmployee e1,CEmployee e2);
    &#125;;
    
    //成员函数定义
    void CEmployee::setName( char * name) &#123;
        strcpy( szName, name); //ok
    &#125;
    void CEmployee::getName( char * name) &#123;
        strcpy( name,szName); //ok
    &#125;
    void CEmployee::averageSalary(CEmployee e1,CEmployee e2)&#123;
        cout &lt;&lt; e1.szName; //ok，访问同类其他对象私有成员
        salary = (e1.salary + e2.salary )/2;
    &#125;
    
    //使用类和对象
    int main()
    &#123;
        CEmployee e;
        strcpy(e.szName,&quot;Tom1234567889&quot;); //编译错，不能访问私有成员
        e.setName( &quot;Tom&quot;);  // ok
        e.salary = 5000;    //ok
        return 0;
    &#125;
</code></pre>
<p>如果将上面的程序移植到内存空间紧张的设备上，希望将szName改为char szName[5]，若szName不是私有，就要找出所有类似strcpy(e.szName,”Tom1234567889”);这样的语句进行修改，以防止数组越界。如果将szName变为私有，那么程序中就不可能出现（除非在类的内部）strcpy(e.szName,”Tom1234567889”);这样的语句，所有对szName的访问都是通过成员函数来进行，比如：e.setName( “Tom12345678909887”);如果szName改短了，上面的语句也不需要找出来修改，只要改setName成员函数，在里面确保不越界就可以了<br>除了使用类和隐藏机制，C++兼容C的struct结构体，也称为类。和用”class”的唯一区别是未说明是公有还是私有的成员，struct类的所有成员都是公有的。</p>
<pre><code>struct CEmployee &#123;
    char szName[30]; //公有!!
    public :
    int salary; //工资
    void setName(char * name);
    void getName(char * name);
    void averageSalary(CEmployee
    e1,CEmployee e2);
&#125;;
</code></pre>
<h2 id="类成员函数的重载和缺省参数"><a href="#类成员函数的重载和缺省参数" class="headerlink" title="类成员函数的重载和缺省参数"></a>类成员函数的重载和缺省参数</h2><p>同普通函数一样，类封装后的成员函数可以重载，可以有缺省参数</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x=0 , int y = 0 );
    void valueX( int val ) &#123; x = val ;&#125;
    int valueX() &#123; return x; &#125;
&#125;;

void Location::init( int X, int Y)
&#123;
    x = X;
    y = Y;
&#125;

int main() &#123;
    Location A,B;
    A.init(5);  //使用init缺省y=0
    A.valueX(5);    //重载，使用valueX(int)
    cout &lt;&lt; A.valueX();     //重载，使用valueX()
    return 0;
&#125;
</code></pre>
<p>输出：5<br>注意：重载和缺省的函数在调用时可能冲突，存在二义性：</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x =0, int y = 0 );
    void valueX( int val = 0) &#123; x = val; &#125;
    int valueX() &#123; return x; &#125;
&#125;;

Location A;
A.valueX(); //错误，编译器无法判断调用哪个valueX
</code></pre>
<h1 id="类对象的创建与释放"><a href="#类对象的创建与释放" class="headerlink" title="类对象的创建与释放"></a>类对象的创建与释放</h1><h2 id="普通构造函数"><a href="#普通构造函数" class="headerlink" title="普通构造函数"></a>普通构造函数</h2><p>定义一个类只是定义一种数据结构类型，类实例化后在内存中才存在改类的对象。类实例化成对象可以在函数的栈中，或者动态分配在堆中</p>
<pre><code>ClassA a;   //该语句在函数内（如main）时，在main的堆栈中分配内存
ClassA *pa = new ClassA;    //在堆中分配，需要delete手动释放
</code></pre>
<p>那么问题来了，分配的内存里的内容是什么？<br>不知道是什么值，只知道这块内存是被其他进程释放过，当前程序可以读写，释放时不会把值清零。<br>在C语言创建一个结构体变量，可以顺便初始化为全0</p>
<pre><code>StructA a = &#123;0&#125;; //单层结构体
StructB b = &#123;&#123;0&#125;&#125;； //嵌套的结构体
</code></pre>
<p>C++也支持创建类时自动初始化，采用与类同名的成员函数的方法。这就是<strong>构造函数（constructor）</strong><br>构造函数：</p>
<ul>
<li>成员函数的一种，名字与类名相同，可以有参数，不能有返回值(void也不行)</li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作</li>
<li>如果定义了构造函数，则编译器不生成默认的无参数构造函数</li>
<li>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</li>
<li>一个类可以有多个构造函数，即构造函数也可以重载</li>
</ul>
<p>注意：构造函数不负责对象的内存分配，其关键作用是对象成员的值初始化。真正做对象分配的语句通常是new，new做两件事：给类分配内存形成对象，调用对象的构造函数。考虑一下也可知道，连对象都没有的情况，怎么能调用对象的构造函数分配内存呢？注意构造函数不给自身对象分配内存，但是构造函数可以做分配内存操作，比如对指针成员指向的空间分配内存。<br>使用默认构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i);
&#125;; //编译器自动生成默认构造函数
Complex c1; //默认构造函数被调用
Complex * pc = new Complex; //默认构造函数被调用
</code></pre>
<p>使用自定义的带参构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    Complex( double r, double i = 0);
&#125;;
    Complex::Complex( double r, double i) &#123;
    real = r; imag = i;
&#125;

Complex c1; // error, 缺少构造函数的参数
Complex * pc = new Complex; // error, 没有参数
Complex c1(2); // OK
Complex c1(2,4), c2(3,5);
Complex * pc = new Complex(3,4);
</code></pre>
<p>使用重载的构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i );
    Complex(double r, double i );
    Complex (double r );
    Complex (Complex c1, Complex c2);
&#125;;

Complex::Complex(double r, double i)
&#123;
    real = r; imag = i;
&#125;
Complex::Complex(double r)
&#123;
    real = r; imag = 0;
&#125;
Complex::Complex (Complex c1, Complex c2);
&#123;
    real = c1.real+c2.real;
    imag = c1.imag+c2.imag;
&#125;

Complex c1(3) , c2 (1,0), c3(c1,c2);
// c1 = &#123;3, 0&#125;, c2 = &#123;1, 0&#125;, c3 = &#123;4, 0&#125;;
</code></pre>
<p>构造函数应该是public的， private构造函数不能直接用来初始化对象</p>
<pre><code>class CSample&#123;
private:
    CSample() &#123;&#125;
&#125;;

int main()&#123;
    CSample Obj; //err. 唯一构造函数是private
    return 0;
&#125;
</code></pre>
<p>对于多个对象的实例化，可以用对象数组,构造函数的调用次数&#x3D;对象个数，重载哪一个构造函数取决于每个对象的初始化方式。</p>
<pre><code>class CSample &#123;
    int x;
    public:
    CSample() &#123;
        cout &lt;&lt; &quot;Constructor 1 Called&quot; &lt;&lt; endl;
    &#125;
    CSample(int n) &#123;
        x = n;
        cout &lt;&lt; &quot;Constructor 2 Called&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main()&#123;
    CSample array1[2];  //两次默认构造函数
    cout &lt;&lt; &quot;step1&quot;&lt;&lt;endl;
    CSample array2[2] = &#123;4,5&#125;;  //两次带参构造函数
    cout &lt;&lt; &quot;step2&quot;&lt;&lt;endl;
    CSample array3[2] = &#123;3&#125;;    //第一个带参构造，第二个默认构造
    cout &lt;&lt; &quot;step3&quot;&lt;&lt;endl;
    CSample * array4 = new CSample[2];  //两次默认构造
    delete []array4;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Constructor 1 Called
Constructor 1 Called
step1
Constructor 2 Called
Constructor 2 Called
step2
Constructor 2 Called
Constructor 1 Called
step3
Constructor 1 Called
Constructor 1 Called
</code></pre>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>定义：拷贝构造函数(copy constructor)是构造函数的一种，特点是：</p>
<ul>
<li>只有一个参数:对同类对象的引用</li>
<li>入参必须是对象的引用，形如 X::X( X&amp; ) 或 X::X(const X &amp;), 后者以常量对象作为参数</li>
<li>如果用户没有定义拷贝构造函数，编译器生成默认的拷贝构造函数，且它完成复制对象的功能。</li>
</ul>
<p>拷贝构造函数也称为复制构造函数<br>调用形式如下。默认（普通）构造函数和默认拷贝构造函数都是编译生成，且并存的</p>
<pre><code>class Complex &#123;
private :
    double real,imag;
&#125;;
Complex c1; //调用缺省无参构造函数
Complex c2(c1);//调用缺省的复制构造函数,将 c2 初始化成和c1一样
</code></pre>
<p>如果定义的自己的拷贝构造函数，则默认的拷贝构造函数不会生成<br>也就是说，自定义的带参拷贝构造函数和编译器生成的默认拷贝构造函数，不存在重载关系；而一个类有多个自定义的带参拷贝构造函数是允许的，可以重载。这一特点对于普通构造函数一样。</p>
<pre><code>class Complex &#123;
public :
    double real,imag;
    Complex()&#123; &#125;
    Complex( const Complex &amp; c ) &#123;
        real = c.real;
        imag = c.imag;
        cout &lt;&lt; “Copy Constructor called”;
    &#125;
&#125;;
Complex c1;
Complex c2(c1); //调用自己定义的复制构造函数，输出 Copy Constructor called
</code></pre>
<p>注意：拷贝构造函数传入的是同类的引用，而不是同类的对象<br>不允许有形如 X::X( X)的构造函数。因为成员函数入参由实参复制到形参实际会调用拷贝构造函数，拷贝构造函数作为成员函数也是一样，因此会有循环定义，即拷贝构造函数的执行需要调用拷贝构造函数的无限循环，用引用作为入参可以解决此问题。这点类似于C结构体允许有结构体指针成员，指向该结构体类型的实例，而不允许结构体有自身结构体的自接实例，这样会照成分配内存空间上的无限循环。</p>
<pre><code>class CSample &#123;
    CSample( CSample c ) &#123;&#125; //错，不允许这样的构造函数
&#125;
</code></pre>
<h3 id="拷贝构造函数的调用"><a href="#拷贝构造函数的调用" class="headerlink" title="拷贝构造函数的调用"></a>拷贝构造函数的调用</h3><p>以下三种情况会调用类对象的拷贝构造函数<br>1)用一个对象去初始化同类的另一个对象：</p>
<pre><code>Complex c2(c1);
Complex c2 = c1; //初始化语句，非赋值语句
</code></pre>
<p>2)类的对象作为函数入参：如果某函数有参数是类A的对象，那么该函数被调用时，类A的拷贝构造函数将被调用：</p>
<pre><code>class A
&#123;
public:
    A() &#123; &#125;;
    A( A &amp; a) &#123;
        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;
    &#125;
&#125;;

void Func(A a1)&#123; &#125;;
int main()&#123;
    A a2;
    Func(a2);  //传参是类A的对象
    return 0;
&#125;
</code></pre>
<p>输出: Copy constructor called<br>3) 类的对象作为函数返回值：如果函数的返回值是类A的对象，函数返回时，A的拷贝构造函数被调用：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int v;</span><br><span class="line">    A(int n) &#123; v = n; &#125;;</span><br><span class="line">    A( const A &amp; a) &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A Func() &#123;</span><br><span class="line">    A a(4);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; Func().v &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>输出：</p>
<pre><code>Copy constructor called
4
</code></pre>
<p>小结：对象作为入参和返回值会调用拷贝构造函数，对象初始化新对象也会调用。</p>
<h3 id="禁用拷贝构造函数"><a href="#禁用拷贝构造函数" class="headerlink" title="禁用拷贝构造函数"></a>禁用拷贝构造函数</h3><p>Q. 调用拷贝构造函数会形成对象的复制品，开销较大，如何禁用拷贝构造函数？<br>使用对象的引用，不自接把对象作为函数的入参出参。<br>Q.对象的引用会导致新问题：函数内修改了引用怎么办，原对象也会改<br>使用const引用，对象实参就不存在被函数修改的可能<br>使用对象的常引用，应用于对象作为函数入参出参，又不希望调用拷贝构造函数的情况</p>
<pre><code>void fun(const CMyclass &amp; obj) &#123;
//函数中任何试图改变 obj值的语句都将是变成非法
&#125;
</code></pre>
<h3 id="对象的赋值和复制"><a href="#对象的赋值和复制" class="headerlink" title="对象的赋值和复制"></a>对象的赋值和复制</h3><p>注意区分对象的赋值和复制：</p>
<ul>
<li><p>对象赋值是类的所有数据成员的一一对应赋值，其本质是对已分配内存的对象，进行数据成员的初始化</p>
</li>
<li><p>对象复制 &#x3D; 分配新对象对象空间 + 对新对象成员的赋值初始化。对象复制是要包含空间分配操作的</p>
</li>
</ul>
<p>两个已分配内存的对象间的赋值并不会导致拷贝构造函数被调用</p>
<pre><code>//声明及初始化，调用拷贝构造函数
Complex c2 = c1; 
//先声明对象，再赋值,不调用拷贝构造函数，调用默认构造函数然后赋值
Complex c2；
c2 = c1;    
</code></pre>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>当类对象有指针成员时，拷贝构造函数遇到一个问题，是只拷贝指针，还是连同指针指向的空间一起拷贝？</p>
<ul>
<li>浅拷贝：只拷贝指针成员</li>
<li>深拷贝：拷贝指针成员，并拷贝其指向的内存空间数据<br> 由于深拷贝的实现用到“&#x3D;”运算符重载，在运算符重载一节详述</li>
</ul>
<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>构造函数是能创建对象并初始化值的函数，将普通变量转换从类对象并分配内存空间的构造函数是转换构造函数。</p>
<ul>
<li>定义转换构造函数的目的是实现类型的自动转换（变量-&gt;对象）</li>
<li>只有一个参数，且不是拷贝构造函数的构造函数，就是转换构造函数</li>
<li>变量被赋值给对象时，编译器会自动调用转换构造函数，建立一个无名的临时对象</li>
</ul>
<p>隐式的转换构造函数：</p>
<pre><code>    class Complex &#123;
    public:
        double real, imag;
        Complex( int i) &#123;//类型转换构造函数
            cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
            real = i; imag = 0;
        &#125;
        Complex(double r,double i) &#123;real = r; imag = i; &#125;
    &#125;;
    
    int main ()
    &#123;
        Complex c1(7,8);
        Complex c2 = 12;
        c1 = 9;     // 9被自动转换成一个临时Complex对象
        cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
        return 0;
    &#125;
</code></pre>
<p>显式的转换构造函数：</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    explicit Complex( int i) &#123;  //显式类型转换构造函数
        cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
        real = i; imag = 0;
    &#125;
    Complex(double r,double i) &#123;real = r; imag = i; &#125;
&#125;;
int main () &#123;
    Complex c1(7,8);
    Complex c2 = Complex(12);
    c1 = 9;         // error, 9不能被自动转换成一个临时Complex对象
    c1 = Complex(9) //ok
    cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><h3 id="析构函数的概念"><a href="#析构函数的概念" class="headerlink" title="析构函数的概念"></a>析构函数的概念</h3><p>**析构函数(destructors)**用于对象生命周期结束前（如函数中的对象在函数返回时消失），释放对象的内存占用，以及其他的准备工作。<br>构造函数和析构函数在对象生命周期的角色从逻辑上讲是开始和结束的关系，但具体操作不一样：构造函数不为对象分配内存，只给成员赋初值；而析构函数一般要释放对象的内存<br>析构函数的特点：</p>
<ul>
<li>名字与类名相同，在前面加‘~’，没有参数和返回值，一个类最多只能有一个析构函数</li>
<li>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。</li>
<li>如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做</li>
<li>如果定义了析构函数，则编译器不生成缺省析构函数</li>
</ul>
<p>析构函数例子：</p>
<pre><code>class String&#123;
private :
    char * p;
    public:
    String () &#123;
        p = new char[10];
    &#125;
    ~ String () ;
&#125;;

String ::~ String()
&#123;
    delete [] p;
&#125;
</code></pre>
<p>对象数组的生命期结束时，每个对象的析构函数都会被调用。</p>
<pre><code>class Ctest &#123;
public:
    ~Ctest() &#123; cout&lt;&lt; &quot;destructor called&quot; &lt;&lt; endl; &#125;
&#125;;

int main () &#123;
    Ctest array[2];
    cout &lt;&lt; &quot;End Main&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>End Main
destructor called
destructor called
</code></pre>
<h3 id="析构函数的调用"><a href="#析构函数的调用" class="headerlink" title="析构函数的调用"></a>析构函数的调用</h3><p>析构函数被调用有以下几种情况<br>1)delete运算导致析构函数调用：</p>
<pre><code>Ctest * pTest;
pTest = new Ctest;  //构造函数调用
delete pTest;       //析构函数调用
---------------------------------------------------------
pTest = new Ctest[3];   //构造函数调用3次
delete [] pTest;        //析构函数调用3次
</code></pre>
<p>若new一个对象数组，那么用delete释放时应该写 []。否则只delete一个对<br>象(调用一次析构函数)<br>2)析构函数在对象作为函数返回值返回后被调用。其原理是，对象作为函数的入参，出参时，都是临时生成的对象，传完就调用析构函数销毁。</p>
<pre><code>class CMyclass &#123;
public:
    ~CMyclass() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125;
&#125;;
CMyclass obj;
CMyclass fun(CMyclass sobj ) &#123; //参数对象消亡也会导致析
                                //构函数被调用
    return sobj;                //函数调用返回时生成临时对象返回
&#125;
int main()&#123;
    obj = fun(obj); //函数调用的返回值（临时对象）被
    return 0;       //用过后，该临时对象析构函数被调用
&#125;
</code></pre>
<p>输出：</p>
<pre><code>destructor
destructor
destructor
</code></pre>
<h2 id="构造与析构的时序"><a href="#构造与析构的时序" class="headerlink" title="构造与析构的时序"></a>构造与析构的时序</h2><p>总体原则：类似堆栈的先入后出原则：先构造的后析构<br>几个关键分类：<br>临时对象：赋值时创建，赋完值就消亡，生命周期似乎就一条指令<br>局部对象：在{}范围内存在，{}结束时消亡<br>全局、静态对象：从创建开始，在程序整个运行期间存在，程序结束时消亡。<br>一个例子：</p>
<pre><code>class Demo &#123;
        int id;
    public:
        Demo(int i) &#123;
            id = i;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;
        &#125;
        ~Demo() &#123;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; destructed&quot; &lt;&lt; endl;
        &#125;
&#125;;

Demo d1(1);
void Func()
&#123;
    static Demo d2(2);
    Demo d3(3);
    cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;
&#125;

int main () &#123;
    Demo d4(4);
    d4 = 6;
    cout &lt;&lt; &quot;main&quot; &lt;&lt; endl;
    &#123; 
        Demo d5(5);
    &#125;
    Func();
    cout &lt;&lt; &quot;main ends&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出结果:</p>
<pre><code>id=1 constructed    //全局对象d1
id=4 constructed    //构造函数d4
id=6 constructed    //转换构造函数d4
id=6 destructed     //临时对象赋值完毕，消亡
main
id=5 constructed    //构造函数d5
id=5 destructed     //d5作用域结束，消亡
id=2 constructed    //Fun构造静态对象d2(等同全局对象)
id=3 constructed    //构造局部对象d3
func
id=3 destructed     //Fun返回，d3消亡
main ends       
id=6 destructed     //Main的局部对象d4消亡（id=6）
id=2 destructed     //整个程序结束，全局对象d2消亡
id=1 destructed     //整个程序结束，全局对象d1消亡
</code></pre>
<h1 id="类对象的指针：this指针"><a href="#类对象的指针：this指针" class="headerlink" title="类对象的指针：this指针"></a>类对象的指针：this指针</h1><p>this指针是在类成员函数内，指向当前类对象的指针。<br>注意：</p>
<ul>
<li>this指针是指向当前对象的，所谓当前，是指调用成员函数时，是通过所在的对象的指针来调用</li>
<li>this指针体现的是成员函数和对象的关系，如果是静态成员函数，没有this指针，因为静态成员函数不从属于对象</li>
</ul>
<p>为什么this指针如此特殊，需要单独命名？这涉及到C++的类的实现原理。</p>
<h2 id="C-的类与C的结构体"><a href="#C-的类与C的结构体" class="headerlink" title="C++的类与C的结构体"></a>C++的类与C的结构体</h2><p>在C++早期，C++代码被编译器翻译成C代码，再由C编译器编译<br>类的实现原理和C的结构体有密切关系，下面是类和结构体的转换：<br>1)C++的类：</p>
<pre><code>class CCar &#123;
    public:
        int price;
        void SetPrice(int p);
&#125;;

void CCar::SetPrice(int p)
&#123; price = p; &#125;

int main()
&#123;
    CCar car;
    car.SetPrice(20000);
    return 0;
&#125;
</code></pre>
<p>2)C的结构体实现类的功能</p>
<pre><code>struct CCar &#123;
    int price;
&#125;;

void SetPrice(struct CCar * this, int p)
&#123; this-&gt;price = p; &#125;

int main() &#123;
    struct CCar car;
    SetPrice( &amp; car,
    20000);
    return 0;
&#125;
</code></pre>
<p>用C实现面向对象(CCar结构体)，方法(SetPrice)传入的参数是结构体对象的指针(struct CCar * this)</p>
<h2 id="C-的this指针"><a href="#C-的this指针" class="headerlink" title="C++的this指针"></a>C++的this指针</h2><p>成员函数（非static）可以直接使用this来代表指向该函数作用的对象的指针</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    void Print() &#123; cout &lt;&lt; real &lt;&lt; &quot;,&quot; &lt;&lt; imag ; &#125;
    Complex(double r,double i):real(r),imag(i)&#123; &#125;   //初始化列表
    Complex AddOne() &#123;
        this-&gt;real ++;  //等价于 real++
        this-&gt;Print();  //等价于 Print()
        return * this;
    &#125;
&#125;;

int main() &#123;
    Complex c1(1,1),c2(0,0);
    c2 = c1.AddOne();
    return 0;
&#125; //输出 2,1
</code></pre>
<p>对象的this指针通常隐式存在：</p>
<ul>
<li>成员函数（非static）的入参实际隐式地有一个this指针参数</li>
<li>成员函数访问成员变量，也是隐式的通过this指针访问</li>
<li>通过对象的指针调用成员函数，本质也是传入this指针</li>
</ul>
<p>如果成员函数不访问成员变量，可以传入NULL的对象指针：</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  //等价于 void Hello(A * this ) &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p)
&#125; // 输出： hello
</code></pre>
<p>如果成员函数访问了成员变量，实际是通过成员函数传入的this指针来访问，此时指针不可为NULL</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  
//等价于void Hello(A * this ) &#123; cout &lt;&lt; this-&gt;i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
//this若为NULL，则出错！！
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p);
&#125; //出错
</code></pre>
<h2 id="静态成员的概念"><a href="#静态成员的概念" class="headerlink" title="静态成员的概念"></a>静态成员的概念</h2><p>静态成员：在定义前面加了static关键字的成员、</p>
<pre><code>class CRectangle
&#123;
    private:
    int w, h;
    static int nTotalArea; //静态成员变量
    static int nTotalNumber;
    public:
    CRectangle(int w_,int h_);
    ~CRectangle();
    static void PrintTotal(); //静态成员函数
&#125;;
</code></pre>
<ul>
<li>普通成员变量每个对象有各自的一份；而静态成员变量是全局共有的一份，为所有对象共享</li>
<li>同一个类的成员函数，不论静不静态都是一份代码段</li>
<li>普通成员函数必须具体作用于某个对象（也可以理解为绑定），而静态成员函数并不具体作用于某个对象</li>
<li>因此静态成员（变量或者函数），不需要通过对象就能访问</li>
</ul>
<p>sizeof求类大小，不会计算静态成员变量，因为不属于类的一部分（从空间占用上讲）。</p>
<pre><code>class CMyclass &#123;
int n;
static int s;
&#125;;  // sizeof(CMyclass) 等于 4
</code></pre>
<h2 id="访问静态成员"><a href="#访问静态成员" class="headerlink" title="访问静态成员"></a>访问静态成员</h2><p>一下几种方法访问,可以归纳为两种：通过类名访问，通过对象访问<br>1)类名::成员名</p>
<pre><code>CRectangle::PrintTotal();
</code></pre>
<p>2)对象名.成员名</p>
<pre><code>CRectangle r; 
r.PrintTotal();
</code></pre>
<p>3)指针-&gt;成员名</p>
<pre><code>CRectangle * p = &amp;r; 
p-&gt;PrintTotal();
</code></pre>
<p>4)引用.成员名</p>
<pre><code>CRectangle &amp; ref = r; 
int n = ref.nTotalNumber;
</code></pre>
<h2 id="静态成员函数与this指针"><a href="#静态成员函数与this指针" class="headerlink" title="静态成员函数与this指针"></a>静态成员函数与this指针</h2><ul>
<li>静态成员函数中不能使用 this 指针！</li>
<li>因为静态成员函数并不具体作用与某个对象!</li>
<li>因此静态成员函数的真实的参数的个数，就是程序中写出的参数个数！</li>
</ul>
<p>前面讲，C++的作用是封装数据，静态成员似乎破坏这一目的，那么静态成员有什么作用？<br>为了兼容C的全局变量与函数</p>
<ul>
<li>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在</li>
<li>静态成员函数本质上是全局函数</li>
<li>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解</li>
</ul>
<h2 id="静态成员函数的使用场景"><a href="#静态成员函数的使用场景" class="headerlink" title="静态成员函数的使用场景"></a>静态成员函数的使用场景</h2><p>对于需要全局维护的数据，可以使用静态成员变量，并通过静态成员函数访问。<br>考虑一个图形处理程序，需要随时知道矩形的总数和总面积</p>
<ul>
<li>每个矩形封装成类的对象</li>
<li>总数和总面积是类的静态成员（等价于全局变量）</li>
</ul>
<p>类定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CRectangle</span><br><span class="line">    &#123;</span><br><span class="line">    private:</span><br><span class="line">        int w, h;</span><br><span class="line">        static int nTotalArea;</span><br><span class="line">        static int nTotalNumber;</span><br><span class="line">    public:</span><br><span class="line">        CRectangle(int w_,int h_);</span><br><span class="line">        ~CRectangle();</span><br><span class="line">        static void PrintTotal();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数定义：</p>
<pre><code>CRectangle::CRectangle(int w_,int h_)
&#123;
    w = w_;
    h = h_;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
CRectangle::~CRectangle()
&#123;
    nTotalNumber --;
    nTotalArea -= w * h;
&#125;
void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl;
&#125;
</code></pre>
<p>类对象的调用：</p>
<pre><code>int CRectangle::nTotalNumber = 0;
int CRectangle::nTotalArea = 0;
// 必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。
int main()
&#123;
    CRectangle r1(3,3), r2(2,2);
    //cout &lt;&lt; CRectangle::nTotalNumber; 
    //错误 , 静态的私有变量也只能通过成员函数访问，静态不等于全局可访问
    CRectangle::PrintTotal();
    r1.PrintTotal();
    return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>2,13
2,13
</code></pre>
<p>注意两点：</p>
<ul>
<li>静态成员变量是全局共有的一份存储，但private的静态成员只能通过类的成员函数访问。注意区分全局存储和全局访问，静态成员只有全局存储特性，没有全局可访问特性。</li>
<li>静态成员函数，不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
<p>以下静态成员函数访问错误：</p>
<pre><code>void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; w &lt;&lt; &quot;,&quot; &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl; //错误
&#125;
CRetangle::PrintTotal(); //解释不通 w 到底是属于那个对象的
</code></pre>
<p> 以上例子还有缺陷：<br> 在使用静态成员时，特别是类的构造和析构会修改该静态成员，如前文的CRectangle类的构造函数有nTotalNumber++操作，析构有nTotalNumber–。这个时候要考虑构造和析构函数是否覆盖到所有类型（普通构造，拷贝构造，转换构造）<br> 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象：</p>
<ul>
<li>调用一个以CRectangle类对象作为参数的函数时</li>
<li>调用一个以CRectangle类对象作为返回值的函数时</li>
</ul>
<p>临时对象在消亡时会调用析构函数，减少nTotalNumber和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber和nTotalArea的值，因为设计类时漏掉了拷贝构造的情况<br>解决办法：为CRectangle类写一个拷贝构造函数：</p>
<pre><code>CRectangle :: CRectangle(CRectangle &amp; r )
&#123;
    w = r.w; h = r.h;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
</code></pre>
<p>这样nTotalNumber和nTotalArea全局计数就是准确的</p>
<h1 id="类的嵌套：封闭类"><a href="#类的嵌套：封闭类" class="headerlink" title="类的嵌套：封闭类"></a>类的嵌套：封闭类</h1><h2 id="封闭类的基本概念"><a href="#封闭类的基本概念" class="headerlink" title="封闭类的基本概念"></a>封闭类的基本概念</h2><p>再来把C++的类和C结构体对比下：</p>
<ul>
<li>C：结构体的成员可以是基础变量，基础变量的指针，结构体的指针，其他复合类型的指针</li>
<li>C++：类的成员变量可以是基础变量，及其指针、引用，可不可以是类对象？类对象的引用和指针？</li>
</ul>
<p>于是引入类嵌套类对象的情况：有成员对象的类叫封闭类（enclosing class)<br>一个示例：写一个汽车类，包含轮胎和引擎类对象<br>轮胎和引擎类：</p>
<pre><code>class CTyre //轮胎类
    &#123;
    private:
        int radius; //半径
        int width; //宽度
    public:
        CTyre(int r,int w):radius(r),width(w) &#123; &#125;   //用初始化列表构造
    &#125;;
    
class CEngine //引擎类
&#123;
&#125;;
</code></pre>
<p>汽车类：</p>
<pre><code>class CCar &#123; //汽车类
private:
    int price; //价格
    CTyre tyre;
    CEngine engine;
public:
    CCar(int p,int tr,int tw );
&#125;;
CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw) //用初始化列表构造
&#123;
&#125;;
</code></pre>
<p>汽车类的使用：</p>
<pre><code>int main()
&#123;
    CCar car(20000,17,225); //传入初始化列表
    return 0;
&#125;
</code></pre>
<h2 id="初始化列表构造封闭类"><a href="#初始化列表构造封闭类" class="headerlink" title="初始化列表构造封闭类"></a>初始化列表构造封闭类</h2><p>对于封闭类，有几个问题就凸显出来：</p>
<ul>
<li>构造一个封闭类，还要构造其嵌套的类</li>
<li>构造时序是怎样的</li>
<li>析构时序是怎样的</li>
</ul>
<p>上例中，如果 CCar类不定义构造函数，下面的语句会编译出错：CCar car;<br>因为CCar不传初始化值给嵌套类CTyre，编译器不知道该如何初始化car.tyre的成员变量<br>而car.engine的初始化没问题，因为不用初始化成员变量，用默认构造函数即可<br>为了解决封闭类的嵌套类成员的初始化问题，构造函数引入新的初始化方法：</p>
<ul>
<li>初始化列表：将成员初始化从构造函数体，移到函数名后面，只是换了形式，但是方便了封闭类各嵌套类的初始化，不用开发者自己到函数体写构造函数内容</li>
<li>成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。</li>
</ul>
<p>封闭类都是通过构造函数的初始化列表，层层传入嵌套类的构造函数：</p>
<pre><code>CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw)&#123;&#125;;
//p, tr, tw是传入的初始化值; price,tyre是CCar对象的两个成员
CCar car(20000,17,225);
//Car的price = 20000, Car的tyre的radius = 17，width = 225
</code></pre>
<p> 上例是普通构造函数，对于封闭类的拷贝构造函数：</p>
<ul>
<li>封闭类对象是用拷贝构造函数初始化的，其成员对象也用拷贝构造函数初始化</li>
</ul>
<p>测试用例：</p>
<pre><code>class A
&#123;
public:
    A() &#123; cout &lt;&lt; &quot;default&quot; &lt;&lt; endl; &#125;
    A(A &amp; a) &#123; cout &lt;&lt; &quot;copy&quot; &lt;&lt; endl;&#125;
&#125;;
class B &#123; A a; &#125;;

int main()
&#123;
    B b1,b2(b1);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>default
Copy
</code></pre>
<p>下面考虑封闭类构造和析构的时序</p>
<ul>
<li>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数、</li>
<li>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关</li>
<li>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反</li>
</ul>
<p>一个测试示例</p>
<pre><code>class CTyre &#123;
    public:
        CTyre() &#123; cout &lt;&lt; &quot;CTyre contructor&quot; &lt;&lt; endl; &#125;
        ~CTyre() &#123; cout &lt;&lt; &quot;CTyre destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CEngine &#123;
    public:
        CEngine() &#123; cout &lt;&lt; &quot;CEngine contructor&quot; &lt;&lt; endl; &#125;
        ~CEngine() &#123; cout &lt;&lt; &quot;CEngine destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CCar &#123;
    private:
        CEngine engine;
        CTyre tyre;
    public:
        CCar( ) &#123; cout &lt;&lt; “CCar contructor” &lt;&lt; endl; &#125;
        ~CCar() &#123; cout &lt;&lt; &quot;CCar destructor&quot; &lt;&lt; endl; &#125;
&#125;;

int main()&#123;
CCar car;
return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>CEngine contructor
CTyre contructor
CCar contructor
CCar destructor
CTyre destructor
CEngine destructor
</code></pre>
<h1 id="类的成员属性：友元和常量成员"><a href="#类的成员属性：友元和常量成员" class="headerlink" title="类的成员属性：友元和常量成员"></a>类的成员属性：友元和常量成员</h1><h2 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h2><p>友元(friend)分为友元函数和友元类两种<br>一个类的private成员，只能通过类自己的成员函数访问，那么其他类的成员函数想访问这个类的private成员怎么办？友元可以解决这种需求</p>
<ol>
<li><p>友元函数: 一个类的友元函数可以访问该类的私有成员<br>即类A内可以声明其他类B的成员函数或者全局函数，加前缀friend，这些以friends开头的函数就可访问类A的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CCar ; //提前声明 CCar类，以便后面的CDriver类使用</span><br><span class="line"> class CDriver</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">         void ModifyCar( CCar * pCar) ; //改装汽车</span><br><span class="line"> &#125;;</span><br><span class="line"> class CCar</span><br><span class="line"> &#123;</span><br><span class="line">     private:</span><br><span class="line">         int price;</span><br><span class="line">         friend int MostExpensiveCar( CCar cars[], int total); //声明友元</span><br><span class="line">         friend void CDriver::ModifyCar(CCar * pCar); //声明友元</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> void CDriver::ModifyCar( CCar * pCar)</span><br><span class="line"> &#123;</span><br><span class="line">     pCar-&gt;price += 1000; //访问CCar成员，汽车改装后加价</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int MostExpensiveCar( CCar cars[],int total)//求最贵汽车的价格</span><br><span class="line"> &#123;</span><br><span class="line">     int tmpMax = -1;</span><br><span class="line">     for( int i = 0;i &lt; total; ++i )</span><br><span class="line">     if( cars[i].price &gt; tmpMax) //访问CCar成员</span><br><span class="line">     tmpMax = cars[i].price;</span><br><span class="line">     return tmpMax;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了普通成员函数，也可以将类构造、析构函数说明为另一个类的友元</p>
<p>2)友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员<br>如果是类的嵌套（封闭类），声明为friend的类A可以调用自己的成员函数访问与它为friend关系的类B的私有成员，而不必调用类B的成员函数。</p>
<pre><code>class CCar
&#123;
private:
    int price;
    friend class CDriver; //声明CDriver为友元类
&#125;;
class CDriver
&#123;
public:
    CCar myCar;
    void ModifyCar() &#123;  //改装汽车
    myCar.price += 1000;   //因CDriver是CCar的友元类，故此处可以访问其私有成员
    &#125;
&#125;;

int main()&#123; return 0; &#125;
</code></pre>
<p>友元类之间的关系不能传递，不能继承。就是说A和B是friend,B和C是friend,但A和C不一定是friend。父类之间的friend关系，子类不一定能传承。</p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>如果不希望某个对象的值被改变，定义该对象的时候可以在前面加 const关键字<br>在类的成员函数说明后面加const关键字，则该成员函数成为常量<br>成员函数。<br>常量成员函数内部不能改变属性的值，也不能调用非常量成员函数<br>在定义常量成员函数和声明常量成员函数时都应该使用const 关键字。</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void PrintValue() const;
&#125;;
void Sample::PrintValue() const &#123;             //此处不使用const会导致编译出错
    cout &lt;&lt; value;
&#125;
void Print(const Sample &amp; o) &#123;
    o.PrintValue(); 
&#125;//若 PrintValue非const则编译错
</code></pre>
<p>以下是错误示例：</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void func() &#123; &#125;;
    Sample() &#123; &#125;
    void SetValue() const &#123;
        value = 0; // wrong
        func(); //wrong
    &#125;
&#125;;
const Sample Obj;
Obj.SetValue (); //常量对象上可以使用常量成员函数
</code></pre>
<p>什么场景定义成常量成员函数？<br>如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，最好将其写成常量成员函数</p>
<p>常量成员函数的重载：<br>两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载关系，而非重定义。</p>
<h1 id="类的运算：运算符重载"><a href="#类的运算：运算符重载" class="headerlink" title="类的运算：运算符重载"></a>类的运算：运算符重载</h1><p>C++定义了类，可以像基本类型那样创建、销毁、初始化。那么类和类之间的运算呢？<br>+、 -、 *、 &#x2F;、 %、 ^、 &amp;、 ~、 !、 |、 &#x3D;、 &lt;&lt; 、&gt;&gt;、 !&#x3D;、<br>考虑以下方法实现类的运算：</p>
<ul>
<li>设计类的成员函数，支持类运算操作</li>
<li>设计某种机制，把运算符关联成函数操作，在函数内定义具体类运算方法。进行类的运算时，形式上可以像基本类型的运算一样</li>
</ul>
<p>例如complex_a和complex_b是两个复数对象；求两个复数的和, 希望能直接写：complex_a + complex_b<br>运算符重载将解决类和对象的运算需求</p>
<h2 id="运算符重载的概念"><a href="#运算符重载的概念" class="headerlink" title="运算符重载的概念"></a>运算符重载的概念</h2><p>运算符重载，就是对已有的运算符(C++中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为<br>运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象<br>期望效果:同一个运算符，对不同类型的操作数，所发生的行为不同</p>
<pre><code>complex_a + complex_b //生成新的复数对象
5 + 4 = 9 //基本运算符操作
</code></pre>
<p>从行为上看，运算符重载类似于把运算符进行了重定义成函数操作（类似C的typedef）<br>运算符重载写法：</p>
<pre><code>返回值类型 operator 运算符（形参表）
&#123;
……  //定义该运算符的运算规则
&#125;
</code></pre>
<p>示例：</p>
<pre><code>class Complex
&#123;
public:
    double real,imag;
    Complex( double r = 0.0, double i= 0.0):real(r),imag(i) &#123; &#125;
    Complex operator-(const Complex &amp; c);
&#125;;
Complex operator+( const Complex &amp; a, const Complex &amp; b)
&#123;
    return Complex( a.real+b.real,a.imag+b.imag); //返回一个临时对象
&#125;
Complex Complex::operator-(const Complex &amp; c)
&#123;
    return Complex(real - c.real, imag - c.imag); //返回一个临时对象
&#125;

int main()
&#123;
    Complex a(4,4),b(1,1),c;
    c = a + b; //等价于c=operator+(a,b);
    cout &lt;&lt; c.real &lt;&lt; &quot;,&quot; &lt;&lt; c.imag &lt;&lt; endl;
    cout &lt;&lt; (a-b).real &lt;&lt; &quot;,&quot; &lt;&lt; (a-b).imag &lt;&lt; endl;
    //a-b等价于a.operator-(b)
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>5,5
3,3
</code></pre>
<p>c &#x3D; a + b; 等价于c&#x3D;operator+(a,b);<br>a-b 等价于a.operator-(b)<br>运算符重载的实现还是成员函数，所以是依赖于对象的。也就是说，运算符重载看上去和类、对象没啥关系，但本质上，重载的运算符是归属于某个类的，因为a-b只是表象现象，真正定义对象运算的，是a.operator-(b)成员函数。<br>因为运算符重载依赖对象的，因此双目运算，如+，-，在运算符重载时只需要传入另一个对象，而不需要传运算符的当前对象。<br>重载为成员函数时， 参数个数为运算符目数减一。<br>重载为普通函数时， 参数个数为运算符目数</p>
<p>运算符重载概念小结：</p>
<ul>
<li>运算符重载的实质是函数重载</li>
<li>可以重载为普通函数，也可以重载为成员函数</li>
<li>把含运算符的表达式转换成对运算符函数的调用</li>
<li>把运算符的操作数转换成运算符函数的参数</li>
<li>运算符被多次重载时，根据实参的类型决定调用哪个运算符函数</li>
</ul>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><p>接下来的几节讲几个代表性的运算符重载。本节讲赋值运算符“&#x3D;”有时候希望赋值运算符两边的类型可以不匹配，比如，把一个int类型变量赋值给一个Complex对象，或把一个 char *类型的字符串赋值给一个字符串对象,此时就需要重载赋值运算符“&#x3D;”。<br>赋值运算符“ &#x3D;”只能重载为成员函数</p>
<p>示例：</p>
<pre><code>class String &#123;
private:
    char * str;
    public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s);
    String::~String( ) &#123; delete [] str; &#125;
&#125;;
String &amp; String::operator = (const char * s)
&#123; //重载“=”以使得 obj = “hello”能够成立
    delete [] str;
    str = new char[strlen(s)+1];
    strcpy( str, s);
    return * this;
&#125;

int main()
&#123;
    String s;
    s = &quot;Good Luck,&quot; ; //等价于 s.operator=(&quot;Good Luck,&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    // String s2 = &quot;hello!&quot;; //这条语句要是不注释掉就会出错
    s = &quot;Shenzhou 8!&quot;; //等价于 s.operator=(&quot;Shenzhou 8!&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Good Luck,
Shenzhou 8!
</code></pre>
<h2 id="赋值运算符与深拷贝"><a href="#赋值运算符与深拷贝" class="headerlink" title="赋值运算符与深拷贝"></a>赋值运算符与深拷贝</h2><p>在类与对象的拷贝构造函数一节讲了拷贝构造函数的作用：用一个已经初始化的对象，去初始化另一个对象，具体操作是讲成员变量一一赋值。<br>那么更深入考虑一下:对于各种类型的成员变量，能不能达到目的？</p>
<ul>
<li>对于基础类型的成员变量，如int,char，直接赋值即可</li>
<li>对于指针类型的成员变量，给指针赋值就Ok?需不需要给指针指向的空间也赋值？</li>
<li>对于引用类型的成员变量，直接赋值OK?</li>
<li>对于类对象类型的成员变量，怎么赋值？嵌套调用拷贝构造函数？</li>
</ul>
<p>引用只是标签，可以直接拷贝，等同变量拷贝。封闭类的构造函数会嵌套调用基础类型的拷贝，直到所有成员赋值完为止。<br>唯一需要考虑的是包含指针类型成员的类如何拷贝<br>如果直接赋值指针而不分配并初始化其指向空间，效果如下:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081648147.png" alt="image-20221208164831061"><br>如不定义自己的赋值运算符，那么S1&#x3D;S2实际上导致 S1.str和 S2.str<br>指向同一地方。<br>如果S1对象消亡，析构函数将释放 S1.str指向的空间，则S2消亡时还<br>要释放一次，就形成两次delete错误!<br>如果执行 S1 &#x3D; “other”；会导致S2.str指向的地方被delete</p>
<p>为了解决以上问题，类的拷贝构造不仅要拷贝指针，还有拷贝指针指向的空间（分配新内存+拷贝）。这种带内存分配的拷贝称为深拷贝</p>
<ul>
<li>浅拷贝：只拷贝成员，对于指针成员，也只拷贝指针变量</li>
<li>深拷贝：拷贝成员，对于指针成员，拷贝指针变量，且拷贝指针指向的内存空间</li>
</ul>
<p>为了实现深拷贝，需要重载“&#x3D;”运算符：</p>
<pre><code>String &amp; operator = (const String &amp; s) &#123;
    delete [] str;  //先释放指针原本指向的空间,因为新空间和原空间大小可能不一样
    str = new char[strlen( s.str)+1];   //分配指针指向的新空间
    strcpy( str,s.str); //新空间赋值初始化
    return * this;  //返回当前对象的指针
&#125;
</code></pre>
<p>还有可优化的，如果传入对象就是当前对象，没必要释放又分配，直接返回即可</p>
<pre><code>String &amp; operator = (const String &amp; s)&#123;
    if( this == &amp; s)
        return * this;
    delete [] str;
    str = new char[strlen(s.str)+1];
    strcpy( str,s.str);
    return * this;
&#125;
</code></pre>
<p>整个类设计如下：</p>
<pre><code>class String &#123;
private:
    char * str;
public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s)&#123;
        delete [] str;
        str = new char[strlen(s)+1];
        strcpy( str, s);
        return * this;
&#125;;
    ~String( ) &#123; delete [] str; &#125;
&#125;;
</code></pre>
<p>再考虑一下运算符重载函数的返回值<br>为什么返回String &amp;<br>原因：对运算符进行重载的时候，好的风格是尽量保留运算符原本的特性<br>例如运算符是可以多个连续运算的</p>
<pre><code>a = b = c;
(a=b)=c; //会修改a的值
</code></pre>
<p>分别等价于：</p>
<pre><code>a.operator=(b.operator=(c));
(a.operator=(b)).operator=(c);
</code></pre>
<p>对于拷贝构造函数，原指针未初始化，不指向任何空间，直接分配空间在拷贝即可，写法如下：</p>
<pre><code>String( String &amp; s)
&#123;
    str = new char[strlen(s.str)+1];
    strcpy(str,s.str);
&#125;
</code></pre>
<h2 id="流运算符的重载"><a href="#流运算符的重载" class="headerlink" title="流运算符的重载"></a>流运算符的重载</h2><p>C++常用的输入输出是怎么实现的？</p>
<pre><code>cout &lt;&lt; 5 &lt;&lt; “this”;
</code></pre>
<ul>
<li>cout是什么?</li>
<li>“&lt;&lt;”原本是位偏移运算，为什么能作用于cout?</li>
<li>“&lt;&lt;”怎么支持连续运算，且支持多种类型</li>
</ul>
<p>原因就是&lt;&lt;被流运算类重载了。</p>
<ul>
<li>cout是在iostream中定义的，ostream类的对象</li>
<li>“&lt;&lt;” 能用在cout上是因为，在iostream里对“ &lt;&lt;” 进行了重载</li>
<li>运算符重载函数返回对象的引用，实现连续运算；多个运算符重载函数的重载，支持多种类型</li>
</ul>
<p>实现方法：</p>
<pre><code>ostream &amp; ostream::operator&lt;&lt;(int n)
&#123;
    …… //输出n的代码
    return * this;
&#125;
ostream &amp; ostream::operator&lt;&lt;(const char * s )
&#123;
    …… //输出s的代码
    return * this;
&#125;
</code></pre>
<p>cout &lt;&lt; 5 &lt;&lt; “this”;<br>等价于： cout.operator&lt;&lt;(5).operator&lt;&lt;(“this”);<br>一个流运算符重载的示例：<br>假定c是Complex复数类的对象，现在希望写“ cout &lt;&lt; c;”，就能以“ a+bi”的形式输出c的值，写“ cin&gt;&gt;c;”，就能从键盘接受“ a+bi”形式的输入，并且使得c.real &#x3D; a,c.imag &#x3D; b</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
using namespace std;
class Complex &#123;
    double real,imag;
    public:
    Complex( double r=0, double i=0):real(r),imag(i)&#123; &#125;;
    friend ostream &amp; operator&lt;&lt;( ostream &amp; os, const Complex &amp; c);
    friend istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c);
&#125;;
ostream &amp; operator&lt;&lt;( ostream &amp; os,const Complex &amp; c)
&#123;
    os &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; //以&quot;a+bi&quot;的形式输出
    return os;
&#125;
   
istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c)
&#123;
    string s;
    is &gt;&gt; s; //将&quot;a+bi&quot;作为字符串读入, “a+bi”中间不能有空格
    int pos = s.find(&quot;+&quot;,0);
    string sTmp = s.substr(0,pos); //分离出代表实部的字符串
    c.real = atof(sTmp.c_str()); //atof库函数能将const char*指针指向的内容转换成 float
    sTmp = s.substr(pos+1, s.length()-pos-2); //分离出代表虚部的字符串
    c.imag = atof(sTmp.c_str());
    return is;
&#125;

int main()
&#123;
    Complex c;
    int n;
    cin &gt;&gt; c &gt;&gt; n;
    cout &lt;&lt; c &lt;&lt; &quot;,&quot; &lt;&lt; n;
    return 0;
&#125;
</code></pre>
<p>运行结果可以如下：</p>
<pre><code>13.2+133i 87    //输入
13.2+133i, 87   //输出
</code></pre>
<h2 id="其他运算符重载"><a href="#其他运算符重载" class="headerlink" title="其他运算符重载"></a>其他运算符重载</h2><p>类型转换运算符”()”重载：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
    double real,imag;
    public:
    Complex(double r=0,double i=0):real(r),imag(i) &#123; &#125;;
    operator double () &#123; return real; &#125;
    //重载强制类型转换运算符 double
&#125;;
int main()
&#123;
    Complex c(1.2,3.4);
    cout &lt;&lt; (double)c &lt;&lt; endl; //输出 1.2
    double n = 2 + c; //等价于 double n=2+c.operator double()
    cout &lt;&lt; n; //输出 3.2
&#125;
</code></pre>
<p>自增自减运算符”++,–”的重载：<br>自增运算符++、自减运算符–有前置&#x2F;后置之分，为了区分所重载的是前置运算符还是后置运算符， C++规定：</p>
<ul>
<li>前置运算符作为一元运算符重载</li>
<li>后置运算符作为二元运算符重载，多写一个没用的参数</li>
</ul>
<p>前置运算符重载形式：</p>
<pre><code>重载为成员函数：
T &amp; operator++();   //不用写入参，当前对象的成员++
T &amp; operator--();
重载为全局函数：
T1 &amp; operator++(T2);
T1 &amp; operator—(T2);
</code></pre>
<p>后置运算符重载形式：    </p>
<pre><code>重载为成员函数：
T operator++(int);  //多写一个入参，用于和前置重载区分
T operator--(int);
重载为全局函数：
T1 operator++(T2,int );
T1 operator—( T2,int);
</code></pre>
<p>调用示例：</p>
<pre><code>int main()
&#123;
    CDemo d(5);
    cout &lt;&lt; (d++ ) &lt;&lt; &quot;,&quot;; //等价于 d.operator++(0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (++d) &lt;&lt; &quot;,&quot;; //等价于 d.operator++();
    cout &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; (d-- ) &lt;&lt; &quot;,&quot;; //等价于 operator--(d,0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (--d) &lt;&lt; &quot;,&quot;; //等价于 operator--(d);
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
&#125;

class CDemo &#123;
private :
    int n;
    public:
    CDemo(int i=0):n(i) &#123; &#125;
    CDemo &amp; operator++(); //用于前置形式
    CDemo operator++( int ); //用于后置形式
    operator int ( ) &#123; return n; &#125;
    friend CDemo &amp; operator--(CDemo &amp; );
    friend CDemo operator--(CDemo &amp; ,int);
&#125;;
CDemo &amp; CDemo::operator++()
&#123; //前置 ++
    n ++;
    return * this;
&#125; // ++s即为: s.operator++();

CDemo CDemo::operator++( int k )
&#123; //后置 ++
    CDemo tmp(*this); //记录修改前的对象
    n ++;
    return tmp; //返回修改前的对象
&#125; // s++即为: s.operator++(0);
CDemo &amp; operator--(CDemo &amp; d)
&#123;//前置--
    d.n--;
    return d;
&#125; //--s即为: operator--(s);
CDemo operator--(CDemo &amp; d,int)
&#123;//后置--
    CDemo tmp(d);
    d.n --;
    return tmp;
&#125; //s--即为: operator--(s, 0);
</code></pre>
<h2 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h2><ul>
<li>C++不允许定义新的运算符</li>
<li>重载后运算符的含义应该符合日常习惯，即保留原运算符的使用风格</li>
<li>运算符重载不改变运算符的优先级</li>
<li>以下运算符不能被重载：“ .” “ .*” “ ::” “ ?:” “sizeof”</li>
<li>重载运算符()、[]、-&gt;、&#x3D;，运算符重载函数必须声明为<br>类的成员函数</li>
</ul>
<h2 id="运算符重载的综合示例"><a href="#运算符重载的综合示例" class="headerlink" title="运算符重载的综合示例"></a>运算符重载的综合示例</h2><p>实现一个可变长数组类型CArray，实现如下用例：</p>
<pre><code>int main() &#123; 
    CArray a; //开始里的数组是空的
    for( int i = 0;i &lt; 5;++i)
        a.push_back(i); //要用动态分配的内存来存放数组元素，需要一个指针成员变量
    CArray a2,a3;
    a2 = a; //要重载“=”
    for( int i = 0; i &lt; a.length(); ++i )
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot; ;  //要重载[]
    a2 = a3; //a2是空的
    for( int i = 0; i &lt; a2.length(); ++i )//a2.length()返回0
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    a[3] = 100;
    CArray a4(a);   //要自己写拷贝构造函数
    for( int i = 0; i &lt; a4.length(); ++i )
        cout &lt;&lt; a4[i] &lt;&lt; &quot; &quot;;
    return 0;
&#125;
</code></pre>
<p>CArray类的设计：</p>
<pre><code>class CArray &#123;
    int size; //数组元素的个数
    int *ptr; //指向动态分配的数组
    public:
    CArray(int s = 0); //s代表数组元素的个数
    CArray(CArray &amp; a);
    ~CArray();
    void push_back(int v); //用于在数组尾部添加一个元素v
    CArray &amp; operator=( const CArray &amp; a);
    //用于数组对象间的赋值
    int length() &#123; return size; &#125; //返回数组元素个数
    int &amp; CArray::operator[](int i) //返回值为 int 不行!不支持 a[i] = 4
    &#123;//用以支持根据下标访问数组元素，如n = a[i] 和a[i] = 4; 这样的语句
        return ptr[i];
    &#125;
&#125;;
</code></pre>
<p>成员函数的实现：</p>
<pre><code>CArray::CArray(int s):size(s)
&#123;
    if( s == 0)
    ptr = NULL;
    else
    ptr = new int[s];
&#125;
CArray::CArray(CArray &amp; a) &#123;
    if( !a.ptr) &#123;
    ptr = NULL;
    size = 0;
    return;
    &#125;
    ptr = new int[a.size];
    memcpy( ptr, a.ptr, sizeof(int ) * a.size);
    size = a.size;
&#125;

CArray::~CArray()
&#123;
    if( ptr) delete [] ptr;
&#125;
CArray &amp; CArray::operator=( const CArray &amp; a)
&#123; //赋值号的作用是使“=”左边对象里存放的数组，大小和内容都和右边的对象一样
    if( ptr == a.ptr) //防止a=a这样的赋值导致出错
    return * this;
    if( a.ptr == NULL) &#123; //如果a里面的数组是空的
    if( ptr ) delete [] ptr;
    ptr = NULL;
    size = 0;
    return * this;
    &#125;
    if( size &lt; a.size) &#123;         //如果原有空间够大，就不用分配新的空间
        if(ptr)
        delete [] ptr;
        ptr = new int[a.size];
    &#125;
    memcpy( ptr,a.ptr,sizeof(int)*a.size);
    size = a.size;
    return * this;
&#125; // CArray &amp; CArray::operator=( const CArray &amp; a)

void CArray::push_back(int v)
&#123; //在数组尾部添加一个元素
    if( ptr) &#123;
        int * tmpPtr = new int[size+1]; //重新分配空间
        memcpy(tmpPtr,ptr,sizeof(int)*size); //拷贝原数组
        内容
        delete [] ptr;
        ptr = tmpPtr;
    &#125;
    else //数组本来是空的
    ptr = new int[1];
    ptr[size++] = v; //加入新的数组元素
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Github常用配置笔记</title>
    <url>/2020/08/27/Github%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Github常用配置笔记"><a href="#Github常用配置笔记" class="headerlink" title="Github常用配置笔记"></a>Github常用配置笔记</h1><h2 id="配置SSH登录（Github，Gitlab等各种git-server通用）"><a href="#配置SSH登录（Github，Gitlab等各种git-server通用）" class="headerlink" title="配置SSH登录（Github，Gitlab等各种git server通用）"></a>配置SSH登录（Github，Gitlab等各种git server通用）</h2><p>配置SSH登录的目的是git操作免密码验证，方便拉取和上传代码。</p>
<p>参考：<a href="https://segmentfault.com/a/1190000043924833">https://segmentfault.com/a/1190000043924833</a> (若要为个人和公司使用不同git账号，见此链接)</p>
<p>下面windows环境创建全局使用唯一的git账号和SSH key；</p>
<p>Linux环境创建SSH key，先查看~&#x2F;.ssh有没有key，如果没有key或者有key但git clone有问题，可以删除key再重新创建id_rsa.pub</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ git config --global user.name thomas.hu</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ git config --global user.email thomas.hu@o2micro.com</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/cursorhu/.ssh/id_rsa):</span><br><span class="line">/c/Users/cursorhu/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)?</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ cat /c/Users/cursorhu/.ssh/id_rsa</span><br><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn</span><br><span class="line">....</span><br><span class="line">2hdYrBeOK+vu1LAAAACGN1cnNvcmh1AQI=</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ cat /c/Users/cursorhu/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDONvU2p10NVjRhu6UGlEMsRWqhbo16zK2Tnqg8....chI60tVZHozCK9PMKZd4dE9RoYMXpJWTo6uIRKEV41qHfaiipfsu1ibRCj1drz/3BTs= cursorhu</span><br></pre></td></tr></table></figure>

<p>最后将id_rsa.pub公钥内容文本粘贴到github&#x2F;gitlab的git账号设置页面中，之后无需登录密码即可git clone，git push。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ git clone git@10.52.1.103:software/storport.git</span><br><span class="line">Cloning into &#x27;storport&#x27;...</span><br><span class="line">remote: Enumerating objects: 12830, done.</span><br><span class="line">remote: Counting objects: 100% (12830/12830), done.</span><br><span class="line">remote: Compressing objects: 100% (3441/3441), done.</span><br><span class="line">remote: Total 12830 (delta 9621), reused 12368 (delta 9251)</span><br><span class="line">Receiving objects: 100% (12830/12830), 259.92 MiB | 52.21 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (9621/9621), done.</span><br></pre></td></tr></table></figure>



<h2 id="初始化git和github仓库"><a href="#初始化git和github仓库" class="headerlink" title="初始化git和github仓库"></a>初始化git和github仓库</h2><p>1.安装git</p>
<p>2.进入本地源码目录</p>
<pre><code>git init
</code></pre>
<p>会出现.git目录<br>首次需要配置github账户和邮箱</p>
<pre><code>git config --global user.name &quot;github注册的用户名&quot;
git config --global user.mail &quot;github注册的邮箱&quot;
</code></pre>
<p>3.添加远程仓库</p>
<p>在github网页新建仓库</p>
<pre><code>git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<p>.git&#x2F;config文件内容会出现remote等内容，ssh方式的url是git开头，http(s)方式是http(s)开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051116187.png" alt="image-20221205111653141"><br>如果是从别人拉过来的仓库，修改后新建仓库，上传遇到<code>fatal: remote origin already exists</code>问题，解决方法:</p>
<pre><code>git remote rm origin
git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<p>4.git add, commit, push三连</p>
<pre><code>git add -A
git commit -m &#39;first commit&#39;
git push -f --set-upstream origin master //首次提交
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117987.png" alt="image-20221205111703940"><br>完成以后远程可以看得到仓库的文件   </p>
<p>5.创建分支</p>
<p>如果已经有主线，在本地<code>git checkout branchname</code>, 远程创建分支，记录.git链接， 然后关联远程分支即可：</p>
<pre><code>git remote add origin https://github.com/*/*.git
</code></pre>
<p>然后推送</p>
<pre><code>git push origin branchname
</code></pre>
<h2 id="首次配置可能的问题："><a href="#首次配置可能的问题：" class="headerlink" title="首次配置可能的问题："></a>首次配置可能的问题：</h2><h3 id="push时有RSA-key错误"><a href="#push时有RSA-key错误" class="headerlink" title="push时有RSA key错误"></a>push时有RSA key错误</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117281.png" alt="image-20221205111713234"><br>因为Git使用SSH连接，而SSH第一次连接需要验证GitHub服务器的Key。确认GitHub的Key的指纹信息是否真的来自GitHub的服务器。解决办法是在本地生成key，配置到github服务器<br>（1)创建ssh key</p>
<pre><code>ls -al ~/.ssh
ssh-keygen -t rsa -C &quot;github用户名&quot;
全部回车默认，生成key
cat ~/.ssh/id_rsa.pub
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117255.png" alt="image-20221205111721197"><br>在push三连过程可以设置global全局配置，以后默认push到github<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117055.png" alt="image-20221205111728996"></p>
<p>（2）配置ssh key到github<br>登陆github,头像-settings-new SSH,复制新生成的SSH配置到服务器<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117386.png" alt="image-20221205111737339"><br>（3）需要重新add origin新建仓库（或者网页上新建仓库)，再push，<code>git status</code>和<code>git log</code>查看分支和日志</p>
<h3 id="push时不能使用密码登陆"><a href="#push时不能使用密码登陆" class="headerlink" title="push时不能使用密码登陆"></a>push时不能使用密码登陆</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Support for password authentication was removed on August 13, 2021.</span><br></pre></td></tr></table></figure>

<p>使用personal token替代密码登陆：</p>
<p>Github setting -&gt; Developer setting -&gt; Personal access token -&gt; Generate a New Token (classic) -&gt; 设置不过时，所有权限勾上 -&gt; 首次会显示token字符，下次不会显示，记得备份token！-&gt; 再次输入账号密码时用token代替密码即可push</p>
<h3 id="git-clone有HTTP2错误"><a href="#git-clone有HTTP2错误" class="headerlink" title="git clone有HTTP2错误"></a>git clone有HTTP2错误</h3><p>错误码：RPC failed; curl 16 Error in the HTTP2 framing layer</p>
<p>解决办法：Git使用HTTP1.1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.version HTTP/1.1</span><br></pre></td></tr></table></figure>

<h2 id="Github-clone使用国内镜像"><a href="#Github-clone使用国内镜像" class="headerlink" title="Github clone使用国内镜像"></a>Github clone使用国内镜像</h2><p>国内搞开发最痛苦的就是限速+断开连接，github clone经常失败。推荐国内镜像服务作为代理进行git clone，将原git地址的github.com替换成代理地址即可。参考 <a href="https://zhuanlan.zhihu.com/p/463954956">无需代理直接加速各种 GitHub 资源拉取</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#git clone原地址</span><br><span class="line">$ git clone https://github.com/kubernetes/kubernetes.git</span><br><span class="line"></span><br><span class="line">#手动配置代理地址，任选其一能clone成功即可</span><br><span class="line">$ git clone https://github.com.cnpmjs.org/kubernetes/kubernetes.git</span><br><span class="line">$ git clone https://hub.fastgit.org/kubernetes/kubernetes.git</span><br><span class="line">$ git clone https://gitclone.com/github.com/kubernetes/kubernetes.git</span><br><span class="line"></span><br><span class="line">#配置git自动使用代理，配置以后可以用git clone原地址，自动走代理</span><br><span class="line">git config --global url.&quot;https://hub.fastgit.org&quot;.insteadOf https://github.com</span><br><span class="line">#取消自动代理</span><br><span class="line">$ git config --global --unset url.https://github.com/.insteadof</span><br></pre></td></tr></table></figure>

<p>使用国内镜像并不一定能解决所有clone问题，有的recursive clone对依赖包有版本要求，国内镜像版本不匹配导致clone fail，此时不能使用国内镜像。</p>
<p>解决版本：下载release版本的zip包，绕开git clone操作。</p>
<h2 id="Github连接报错问题"><a href="#Github连接报错问题" class="headerlink" title="Github连接报错问题"></a>Github连接报错问题</h2><h3 id="OpenSSL-errno-10054"><a href="#OpenSSL-errno-10054" class="headerlink" title="OpenSSL errno 10054"></a>OpenSSL errno 10054</h3><p>一劳永逸的解决办法：git bash -&gt; git config –global http.sslVerify “false”</p>
<p>参考：<a href="https://blog.csdn.net/qq_29493173/article/details/114534057">OpenSSL SSL_read: Connection was reset, errno 10054</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git多人协作下的换行符问题</title>
    <url>/2020/09/06/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E4%B8%8B%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目文件中有如下类型文件：</p>
<pre><code>Makefile, .sh, .bat, .cfg, .exe
</code></pre>
<p>源码用git管理，客户端用cygwin实现windows内的linux环境</p>
<p>问题：如何解决git多人协作下的linux、windows换行符差异问题？</p>
<p>(1)什么是换行符<br>LF：”\n”，Linux的换行符, 只包含“换行”；<br>CRLF：”\r\n”，Windows的换行符，包含“回车+换行”;</p>
<p>(2)不同换行符带来什么问题<br>用git管理代码，必定有远程端和本地端两个仓库，两端的操作系统不同，换行符可能有差异;</p>
<p>多人协作时，本地端可能有linux环境和windows, 如果所有人都是linux就不存在换行符差异的问题；如果有windows和linux就有该问题;<br>例如A上传了Linux换行符LF的代码到远程，B 本地环境是windows, B git pull下来，其git-config设置了自动转换成本地换行，将代码换行全成了CRLF，B上传后，远程仓库变成CRLF换行。此时A git diff查看，所有代码都有换行差异，扰乱真正的代码diff。</p>
<p>不仅是影响git diff， 换行差异还影响脚本执行</p>
<ul>
<li>例如LF换行的.sh，git pull到windows环境后换行转换成CRLF, 导致sh无法正常执行；</li>
<li>.bat调用.exe读取.cfg内的一行，.exe是windows程序，其readline方法只能识别CRLF换行，无法读取LF换行的.cfg文件内容</li>
</ul>
<h1 id="git的自动换行符转换配置"><a href="#git的自动换行符转换配置" class="headerlink" title="git的自动换行符转换配置"></a>git的自动换行符转换配置</h1><p>参考：<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git">core.autocrlf</a></p>
<p>假如你正在 Windows 上写程序，而其他人用的是其他系统（或相反），你可能会遇到 CRLF 问题。 这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 macOS 和 Linux 只使用换行（LF）一个字符。 虽然这是小问题，但它会极大地扰乱跨平台协作。许多 Windows 上的编辑器会悄悄把行尾的换行字符转换成回车和换行， 或在用户按下 Enter 键时，插入回车和换行两个字符。</p>
<p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。 你可以用 core.autocrlf 来打开此项功能。 如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<pre><code>$ git config --global core.autocrlf true
</code></pre>
<p>如果使用以换行作为行结束符的 Linux 或 macOS，你不需要 Git 在检出文件时进行自动的转换； 然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p>
<pre><code>$ git config --global core.autocrlf input
</code></pre>
<p>这样在 Windows 上的检出文件中会保留回车和换行，而在 macOS 和 Linux 上，以及版本库中会保留换行。</p>
<p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中：</p>
<pre><code>$ git config --global core.autocrlf false
</code></pre>
<p><strong>使用<code>git config --global core.autocrlf input</code>就可以做到windows的CRLF换行自动转换成LF换行存储在git远程仓库，且git pull&#x2F;clone到本地时维持LF换行，不影响.sh等linux shell script执行。</strong></p>
<h1 id="手动换行符转换"><a href="#手动换行符转换" class="headerlink" title="手动换行符转换"></a>手动换行符转换</h1><ul>
<li><p>dos2unix FilePath</p>
</li>
<li><p>unix2dos FilePath</p>
</li>
<li><p>windows2linux</p>
<p> sed -i ‘s&#x2F;.$&#x2F;&#x2F;‘ FilePath</p>
</li>
<li><p>linux2windows</p>
<p> sed -i ‘s&#x2F;$&#x2F;\r&#x2F;‘ FilePath</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab笔记：CentOS7部署Gitlab服务</title>
    <url>/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>阿里云ECS, CentOS7, RAM 4G</p>
<h1 id="安装Gitlab"><a href="#安装Gitlab" class="headerlink" title="安装Gitlab"></a>安装Gitlab</h1><p>1.安装ssh并配置</p>
<pre><code>#安装
sudo yum install -y curl policycoreutils-python openssh-server
#配置开机启动
sudo systemctl enable sshd
#启动服务
sudo systemctl start sshd
</code></pre>
<p>2.配置防火墙</p>
<pre><code>#启动防火墙
service firewalld start
#添加http服务到firewalld,pemmanent表示永久生效
sudo firewall-cmd --permanent --add-service=http
#重启防火墙
sudo systemctl reload firewalld
</code></pre>
<p>3.安装gitlab</p>
<pre><code>#下载安装脚本
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash
#安装
yum install -y gitlab-ee
</code></pre>
<p>4.配置gitlab</p>
<pre><code>#gitlab配置文件
vim /etc/gitlab/gitlab.rb
#修改以下内容为主机ip和未使用的端口，否则使用默认端口8080
external_url &#39;http://47.100.221.149:9030&#39;
</code></pre>
<p>5.配置生效并重启gitlab</p>
<pre><code>#配置生效，改了配置需要运行
gitlab-ctl reconfigure
#重启服务，没改配置直接重启
gitlab-ctl restart
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061444445.png" alt="image-20221206144455394"><br>似乎服务都正常启动了，实际上可能有各种问题，参考问题记录</p>
<h1 id="问题Debug记录"><a href="#问题Debug记录" class="headerlink" title="问题Debug记录"></a>问题Debug记录</h1><p>按以上步骤配置好后，访问主机ip:端口，直接弹出502服务端错误<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061445877.png" alt="image-20221206144542817"></p>
<h2 id="配置文件权限问题"><a href="#配置文件权限问题" class="headerlink" title="配置文件权限问题?"></a>配置文件权限问题?</h2><p>配置文件生效命令<code>gitlab-ctl reconfigure</code>做了以下事情：</p>
<ul>
<li>配置设置写到gitlab服务直接调用的文件</li>
</ul>
<p>实际生效的配置文件：</p>
<pre><code>vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446719.png" alt="image-20221206144606669"><br>可见配置被自动拷贝到此处，gitlab相关服务读取的是这里的配置项</p>
<ul>
<li>生成服务相关临时文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446110.png" alt="image-20221206144619066"></p>
<p>原因：gitlab服务的配置文件在reconfigure时生成于&#x2F;var&#x2F;log&#x2F;gitlab，这个文件目录默认权限不够，有些子服务不能正常运行。</p>
<p>解决方法：</p>
<pre><code>chmod -R 777 /var/log/gitlab
</code></pre>
<p>restart服务，网页即可正常访问gitlab，如果恢复该目录755权限，重启服务会502</p>
<p>每次重新配置，<code>gitlab-ctl reconfigure</code>似乎会删除该目录再重新写入<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446151.png" alt="image-20221206144636079"></p>
<p>因此每次gitlab-ctl reconfigure之后都要<code>chmod 777</code>改此目录权限</p>
<h2 id="还有502问题"><a href="#还有502问题" class="headerlink" title="还有502问题?"></a>还有502问题?</h2><h3 id="检查阿里云端口"><a href="#检查阿里云端口" class="headerlink" title="检查阿里云端口"></a>检查阿里云端口</h3><p>首先确保主机ip是公网能访问的，不是内网ip<br>其次看端口是否禁用。在阿里云ECS的安全组策略中查看端口是否允许TCP输入输出<br>我把所有端口（1~65535）全部打开了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446454.png" alt="image-20221206144656411"></p>
<h3 id="检查前向端口冲突"><a href="#检查前向端口冲突" class="headerlink" title="检查前向端口冲突"></a>检查前向端口冲突</h3><p>gitlab配置文件的external_url就包含前向端口</p>
<pre><code>netstat -nlp | grep 9030 (我的gitlab前向端口)
</code></pre>
<p>显示的是nginx服务端口，因为gitlab默认被nginx反向代理了，说明gitlab的代理服务确实占用9030。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449545.png" alt="image-20221206144927508"></p>
<h3 id="检查子服务的端口"><a href="#检查子服务的端口" class="headerlink" title="检查子服务的端口"></a>检查子服务的端口</h3><p>注意gitlab不只有一个服务，默认配置只设置了前向端口（nginx代理端口），而子服务都没配置端口，默认用了8080，如果有其他服务已经占用8080，可能子服务起不来<br>例如unicorn子服务：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449220.png" alt="image-20221206144946178"></p>
<p>查看子服务状态</p>
<pre><code>gitlab-ctl status
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449573.png" alt="image-20221206144958510"></p>
<p>如果本地已有8080的服务，最好杀掉或换其他端口，否则要手动配置gitlab子服务端口</p>
<pre><code>unicorn[&#39;port&#39;] = 9032 （随便一个未使用端口）
gitlab_workhorse[&#39;auth_backend&#39;] = &quot;http://localhost:9032&quot;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450285.png" alt="image-20221206145014236"></p>
<h3 id="检查内存资源不足"><a href="#检查内存资源不足" class="headerlink" title="检查内存资源不足"></a>检查内存资源不足</h3><p>阿里云2G以下RAM可能会有因内存不足，导致服务不能正常启动。<br>使用swap交换分区，避免内存不足的可能性。swap分区可以把部分内存分页存储到磁盘，变相“扩大”内存</p>
<pre><code>#查看现有swap分区，若未分配大小为0
cat /proc/swaps
#创建swap文件，大小4G，挂载到/mnt。交换分区可以使用真正的分区，或者以文件形式的分区
dd if=/dev/zero of=/mnt/swap bs=512 count=8388616
#使之成为swap分区
mkswap /mnt/swap
#修改swap分区配置
cat /proc/sys/vm/swappiness
sysctl -w vm.swappiness=60
#swap分区配置永久生效
vim /etc/sysctl.conf
修改vm.swappiness=60
#启动分区
swapon /mnt/swap
echo “/mnt/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab
#停用分区
swapoff /mnt/swap
swapoff -a &gt; /dev/null
</code></pre>
<p>启用分区后运行gitlab，发现已经有一部分数据转移到了swap文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450437.png" alt="image-20221206145023389"></p>
<h1 id="ssh访问配置"><a href="#ssh访问配置" class="headerlink" title="ssh访问配置"></a>ssh访问配置</h1><p>通过ssh上传下载，需要建立ssh key</p>
<pre><code>ssh-keygen   #一路回车
</code></pre>
<p>若创建成功，查看生成的公钥：</p>
<pre><code>cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yXXXXXXXX
</code></pre>
<p>添加公钥至gitlab</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450049.png" alt="image-20221206145031977"></p>
<h1 id="初始化git项目"><a href="#初始化git项目" class="headerlink" title="初始化git项目"></a>初始化git项目</h1><p>配置git全局用户名，邮箱</p>
<pre><code>git config --global user.name &quot;YOUR NAME&quot;
git config --global user.email &quot;YOUR EMAIL@xxx.com&quot;
</code></pre>
<p>初始化git仓库<br>可以通过xftp上传项目文件夹到gitlab服务器，再到目录内初始化.git仓库。</p>
<pre><code>cd project_folder (项目文件夹)
git init
git remote add origin git@YOUR_IP:YOUR_NAME/project_folder.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
</code></pre>
<p>这样在网页上可看到gitlab有首次commit的文件，后续也可以顺利提交和下载。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作笔记</title>
    <url>/2020/12/03/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="拉取和同步"><a href="#拉取和同步" class="headerlink" title="拉取和同步"></a>拉取和同步</h2><pre><code>git clone http://xxx.xxx.git //http方式, 从远程clone仓库，注意这种方式只clone master到本地，本地要其他分支要手动checkout branchname.
git pull //拉取远程分支
git branch //查看本地
git branch -a //查看远程和本地
git checkout xxxbranch //本地切到某分支
git checkout xxx/xxx //仅拉取部分目录或文件
</code></pre>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log //回车下一行，空格下一页，q退出</span><br><span class="line">git log --pretty=oneline //单行显示每个commit，用于查看大量提交</span><br><span class="line">git log --author=“author” //查看某人的提交</span><br></pre></td></tr></table></figure>

<h2 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a>推送到远程</h2><pre><code>git add -A //推送所有修改到本地仓库
git commit -m &quot;change logs&quot; //提交到本地仓库（记录修改信息）
git push //推送本地分支到远程的同名分支，需要先关联
git push origin &lt;本地分支名&gt; //推送本地分支到远程同名分支
git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; //推送本地分支到远程指定分支
</code></pre>
<h2 id="加tag-删tag"><a href="#加tag-删tag" class="headerlink" title="加tag&#x2F;删tag"></a>加tag&#x2F;删tag</h2><pre><code>git tag -a TAGNAME -m &quot;TAG LOG&quot; //加tag
git push origin TAGNAME //推送tag到远程
git tag -d TAGNAME //删除本地tag
git push origin :refs/tags/TAGNAME //删除远程tag
</code></pre>
<h2 id="创建-删除-修改分支"><a href="#创建-删除-修改分支" class="headerlink" title="创建&#x2F;删除&#x2F;修改分支"></a>创建&#x2F;删除&#x2F;修改分支</h2><p>创建分支并关联远程</p>
<pre><code>git checkout -b BRANCH_NAME //本地创建分支(包含当前分支的历史提交记录)
git push origin BRANCH_NAME //推送到远程
git push --set-upstream origin BRANCH_NAME //关联远程，便于以后分支pull/push

#创建不带历史提交记录的新分支（孤儿分支）
git checkout --orphan BRANCH_NAME
</code></pre>
<p>删除本地分支  </p>
<pre><code>git branch -d branch_name
git branch -D branch_name //强制删除
</code></pre>
<p>删除远程分支</p>
<pre><code>git push origin -d branch_name
</code></pre>
<p>分支重命名</p>
<pre><code>git branch -m OLD_NAME NEW_NAME //本地分支重命名
git push origin NEW_NAME //推送远程
#推送新分支到远程不会删除远程的旧分支，需要手动删除远程的旧分支
git push origin -d 旧分支名
</code></pre>
<h2 id="更换远程"><a href="#更换远程" class="headerlink" title="更换远程"></a>更换远程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重新设置远程仓库</span><br><span class="line">git remote set-url origin https://gitee.com/xx/xx.git (新地址)</span><br><span class="line"># 查看远端地址</span><br><span class="line">git remote -v</span><br><span class="line"># 更换完后的示例：</span><br><span class="line">origin  git@10.22.1.90:thomas.hu/o2link-jev323.git (fetch)</span><br><span class="line">origin  git@10.22.1.90:thomas.hu/o2link-jev323.git (push)</span><br></pre></td></tr></table></figure>

<h2 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h2><p>可以用<code>git diff --help</code>直接查看git diff的Manual Page</p>
<pre><code>git diff COMMIT_ID //比较本地和某commit_id的内容
git diff ID1 ID2 //比较两个提交的内容，比较新增时，旧版本在前，新版本在后
git diff --name-only ID1 ID2 //只显示有差异的文件名列表，不显示内容
git diff &lt;path&gt; //比较某文件夹下所有文件的差异
git diff &lt;path&gt;/*.c //比较指定路径下所有.c文件的差异
git diff &lt;commit&gt;..&lt;commit&gt; [&lt;path&gt;…] //比较两个提交中指定文件或路径的差异
</code></pre>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre><code>git reset --hard HEAD^ //回退到上个版本
git reset --hard HEAD^^ //回退到上上个版本
git reset --hard COMMIT_ID //回退到指定提交
git push -f //强制提交，覆盖远程，使远程也回退
git push origin master -f //强制推送到远程的master分支
</code></pre>
<h2 id="文件回退"><a href="#文件回退" class="headerlink" title="文件回退"></a>文件回退</h2><h3 id="回退未提交的改动"><a href="#回退未提交的改动" class="headerlink" title="回退未提交的改动"></a>回退未提交的改动</h3><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git restore &lt;file&gt;</span><br></pre></td></tr></table></figure>

<h3 id="回退指定文件到历史commit"><a href="#回退指定文件到历史commit" class="headerlink" title="回退指定文件到历史commit"></a>回退指定文件到历史commit</h3><p>格式：git restore –source &lt;指定commit id sha256&gt; –worktree – &lt;要回退的文件路径&gt;</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\edk2&gt; git restore --source e70bb4ae7 --worktree -- MdeModulePkg/Bus/Pci/SdMmcPciHcDxe/SdMmcPciHcDxe.c      </span><br><span class="line">PS C:\edk2&gt; git status</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   MdeModulePkg/Bus/Pci/SdMmcPciHcDxe/SdMmcPciHcDxe.c</span><br></pre></td></tr></table></figure>



<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>两个分支A和B，要把分支B的所有提交合并到A分支上</p>
<pre><code>git checkout &lt;branch A&gt; //切到待合并分支A
git merge &lt;branch B&gt; //拉取分支B，合并到当前分支A
git merge &lt;branch B&gt;  --squash //合并分支，将B的多个提交融合成一个再合并到A，而不是B的所有提交记录都照搬到A（这个更常用）
git merge --abort //终止合并
</code></pre>
<p>如果有<code>merge conflict</code>,手动修改冲突文件-&gt;保存文件-&gt;<code>git add -A</code>提交修改-&gt;<code>git commit -m &quot;xxx&quot;</code>提交该合并</p>
<p>如果本地仓库已经处于待merge状态，又想取消merge,同步成远程仓库状态，只需要reset本地仓库到当前commit-id</p>
<pre><code>git reset --hard HEAD
</code></pre>
<p>也可以reset到指定commit-id:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog &amp;&amp; git reset --hard commit-id</span><br></pre></td></tr></table></figure>

<h2 id="合并提交"><a href="#合并提交" class="headerlink" title="合并提交"></a>合并提交</h2><h3 id="合并当前提交"><a href="#合并当前提交" class="headerlink" title="合并当前提交"></a>合并当前提交</h3><p>如果当前修改还未提交, 想合并到最近的一次提交里，例如最近提交有个错误，可以用<code>--amend</code>修订提交</p>
<pre><code>git add -A
git commit --amend
git push -f //amend后通常强制推送，因为没有新增commit
</code></pre>
<h3 id="合并历史提交"><a href="#合并历史提交" class="headerlink" title="合并历史提交"></a>合并历史提交</h3><p>有时同一个功能分多次提交，提交过于频繁，需要合并成一个提交。<br>如下有三次提交</p>
<pre><code>$git log
commit_3: xxxxx
    message_3 ....
commit_2: xxxxx
    message_2 ....
commit_1: xxxxx
    message_1 ....
</code></pre>
<p>现在想把commit_3 和 commit_2合并成一个commit.</p>
<pre><code>git rebase -i commit_1 //重定位到要合并的前一个提交
</code></pre>
<p>进入commit信息编辑模式：</p>
<pre><code>pick commit_2 message_2...
pick commit_3 message_3...
</code></pre>
<p>将要合并的commit_3前的属性<code>pick</code>（选用）改为<code>squash</code>（压扁），<code>wq</code>保存，进入当前合并commit的信息提交界面，再次<code>wq</code>保存, 查看合并后提交记录如下：</p>
<pre><code>$git log
commit_4: xxxxx
    message_3 ....
    message_2 ....
commit_1: xxxxx
    message_1 ....
</code></pre>
<p>两次提交已合成一次（新的）提交</p>
<h2 id="git-clone远程所有分支到本地"><a href="#git-clone远程所有分支到本地" class="headerlink" title="git clone远程所有分支到本地"></a>git clone远程所有分支到本地</h2><p>仓库备份时需要一次git clone所有远程分支到本地，默认的git clone是只有master分支到本地，如果远程（origin remote）仓库没了，git checkout也无法拉取其他分支。</p>
<p>方法：</p>
<p>手动创建仓库文件夹名，在此目录open git bash </p>
<p>使用 <code>git clone --mirror</code> 命令克隆你的仓库，<code>--mirror</code> 选项设置包含所有分支的源仓库的镜像。</p>
<p>以下克隆了远程仓库整个镜像repo.git, 并保存到本地项目文件夹的.git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --mirror git://xxx/repo.git .git</span><br></pre></td></tr></table></figure>

<p>注意–mirror命令会将仓库设置为裸仓库。要将其变回常规仓库，请将 <code>git config</code> 的 <code>bare</code> 布尔值更改为 <code>false</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --bool core.bare false</span><br></pre></td></tr></table></figure>

<p>使用 <code>git reset</code> 命令设置 <code>HEAD</code>。它从当前文件夹中获取所有内容并在本地计算机上创建所有分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>

<p>最后使用git branch查看本地仓库的分支列表，和git branch -a的远程分支完全一样。</p>
<p>因为此方式是完整的镜像clone，所以分支和tag都和远程完全一样。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /e/801-software-team-git/storport</span><br><span class="line">$ git clone --mirror git@10.52.1.103:software/storport.git .git</span><br><span class="line">Cloning into bare repository &#x27;.git&#x27;...</span><br><span class="line">remote: Enumerating objects: 12836, done.</span><br><span class="line">remote: Counting objects: 100% (12836/12836), done.</span><br><span class="line">remote: Compressing objects: 100% (3447/3447), done.</span><br><span class="line">remote: Total 12836 (delta 9626), reused 12368 (delta 9251)</span><br><span class="line">Receiving objects: 100% (12836/12836), 259.92 MiB | 47.75 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (9626/9626), done.</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /e/801-software-team-git/storport (master)</span><br><span class="line">$ git config --bool core.bare false</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /e/801-software-team-git/storport (master)</span><br><span class="line">$ git reset --hard</span><br><span class="line">HEAD is now at 2ada62d 1.change .sys file name to bhtsddr.sys; 2.change version to 07/20/2020,29.1.3.1010</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /e/801-software-team-git/storport (master)</span><br><span class="line">$ git branch</span><br><span class="line">  * master</span><br><span class="line">  storport</span><br><span class="line">  storport_win10</span><br><span class="line">  storport_win11</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h1 id="账户免密码配置"><a href="#账户免密码配置" class="headerlink" title="账户免密码配置"></a>账户免密码配置</h1><h2 id="全局免密码配置"><a href="#全局免密码配置" class="headerlink" title="全局免密码配置"></a>全局免密码配置</h2><h3 id="https-方式的免密码配置"><a href="#https-方式的免密码配置" class="headerlink" title="https 方式的免密码配置"></a>https 方式的免密码配置</h3><p>配置credential存储</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<p>然后在项目目录，执行git pull命令会提示输入账号密码。这次输入账号密码之后，credential store就会记住账号密码，并且当前用户目录下生成.git-credentials文件，之后就不用再输入账号密码</p>
<h3 id="ssh-方式的免密码配置"><a href="#ssh-方式的免密码配置" class="headerlink" title="ssh 方式的免密码配置"></a>ssh 方式的免密码配置</h3><p>对每个git账户生成对应的ssh公钥-私钥即可，参考：</p>
<p><a href="https://blog.csdn.net/qq_55558061/article/details/124117445">如何在同一电脑上生成配置多个ssh key 公钥 私钥</a></p>
<h1 id="gitignore语法"><a href="#gitignore语法" class="headerlink" title="gitignore语法"></a>gitignore语法</h1><p>参考：<a href="https://git-scm.com/docs/gitignore">git-scm.com&#x2F;docs&#x2F;gitignore</a></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/52885189">.gitignore文件的配置使用</a></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**/MDK-ARM/stm32f072c8t6/  		#忽略stm32f072c8t6文件夹的所有文件</span><br><span class="line">!/**/MDK-ARM/stm32f072c8t6/*.sct 	#不要忽略stm32f072c8t6文件夹的.sct文件</span><br><span class="line">/**/MDK-ARM/*.bin</span><br></pre></td></tr></table></figure>

<h1 id="多人提交的冲突解决办法"><a href="#多人提交的冲突解决办法" class="headerlink" title="多人提交的冲突解决办法"></a>多人提交的冲突解决办法</h1><p>A和B同时开发某项目的同一个分支，A拉取最新版本1.0后，在本地新增功能，此时B也在1.0上修改并提交到了新版本1.1到远程仓库。A在B提交之后再提交，发现自己本地的修改已是旧版本，无法直接提交，如下图是A的add,commit,push三连的结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051005366.png" alt="1631249531971_115"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051006842.png" alt="image-20221205100655798"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051007268.png" alt="image-20221205100726224"></p>
<h3 id="手动解决conflict"><a href="#手动解决conflict" class="headerlink" title="手动解决conflict"></a>手动解决conflict</h3><p><code>git pull</code> 拉取远程仓库最新版本，此时有两种情况</p>
<ul>
<li>代码有冲突，需手动修改冲突区域的代码块，二选一，然后重新add-commit-push三连提交</li>
<li>无冲突，pull代码会自动合并，直接重新三连提交即可</li>
</ul>
<p>以下是有冲突的情况<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051008610.png" alt="image-20221205100836563"></p>
<p>找到冲突源码，冲突的符号定义如下：</p>
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt; HEAD</code>：当前本地的代码块</li>
<li><code>======</code>：分割冲突块</li>
<li><code>&gt;&gt;&gt;&gt;&gt;&gt;b699a7fc</code>：远程最新hash版本号的代码块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051008970.png" alt="image-20221205100855921"></p>
<p>修改方法：先拷贝冲突关键语句，再删除所有冲突域符号，最后只保留如下代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051019814.png" alt="image-20221205101900769"></p>
<p>修改完后，<code>git add, git commit, git push</code>，成功提交<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051020311.png" alt="image-20221205102021265"></p>
<p>查看提交后版本：<code>git log</code></p>
<h3 id="修改某次提交的commit信息"><a href="#修改某次提交的commit信息" class="headerlink" title="修改某次提交的commit信息"></a>修改某次提交的commit信息</h3><p>有时需要修改commit信息便于区分哪个是解决冲突后的提交<br>解决方案：</p>
<ul>
<li>修改最新的commit，只需要amend修改commit信息后，再push</li>
<li>修改历史的commit，需要先rebase修改属性为edit后，再commit –amend</li>
</ul>
<p>下面讲修改历史commit<br>如下图，想修改9877的commit信息<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051023197.png" alt="image-20221205102348131"></p>
<p>先rebase到之前的commit<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051024479.png" alt="image-20221205102432433"><br>显示其后的版本属性如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051024531.png" alt="image-20221205102447476"><br>修改9877的属性为edit(待编辑模式)，将原始commit改成如下内容,<code>:wq</code>保存:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051026868.png" alt="image-20221205102658821"></p>
<p>然后<code>commit --amend, rebase --continue</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051027201.png" alt="image-20221205102751155"><br>再查看下git og修改成功<br>最后<code>git push</code>同步到远程仓库</p>
<h1 id="从分支拉取指定的commit"><a href="#从分支拉取指定的commit" class="headerlink" title="从分支拉取指定的commit"></a>从分支拉取指定的commit</h1><p>A和B都在git的master分支提交代码，一天发现master某个版本有问题，回退n各版本都找不到是谁提交引起的问题，由于master还要作稳定测试等其他用途，决定先回退master分支到较早的指定版本，而master最新版和稳定版之间提交的内容，分别由各自A和B“认领”，拉取master上自己提交的功能到自己的分支，debug好以后在合并回master。<br>需求：<br>如何在开发者分支上拉取master分支的指定几个commit的内容，注意不是某个commit以前的内容，是commit内的内容？</p>
<h2 id="创建自己分支，回退master"><a href="#创建自己分支，回退master" class="headerlink" title="创建自己分支，回退master"></a>创建自己分支，回退master</h2><p>首先切到master分支上，创建一个自己的分支thomas，自己分支是master的拷贝</p>
<pre><code>git checkout master //当前在那个分支，决定创建分支的内容
git checkout -b thomas //做两件事：在本地创建thomas分支，内容和master一样；切到thomas分支
git push --set-upstream origin thomas //推送分支到远程，这步很容易漏掉
git branch //查看当前在哪个分支
git branch -a //查看所有分支
</code></pre>
<p>以上操作完成后，自己分支就创建好了，注意动作只影响到本地仓库的.git文件，要同步远程仓库还要push到远程<br>下面备份master, 再回退master</p>
<pre><code>git checkout master
git checkout -b master_backup //先备份master,上面有自己分支要拉取的内容
git checkout master //切到master,准备回退
git reset --hard COMMIT_ID //回退到稳定版本commit_id
git push -f //由于是回退，提交比远程的还早，一般需要强制提交，这个操作也会把本地的.git修改一同提交到远程
</code></pre>
<p>这样就有三个分支：</p>
<pre><code>master: 包含稳定版本的旧代码
master_backup: master的备份，包含稳定版和之后的A、B的一些提交
thomas: 开发者A的个人分支，现在和master稳定版完全一样
</code></pre>
<p>下面只需要从master_backup拉取自己相关的提交到thomas分支即可。</p>
<h2 id="cherry-pick拉取指定commit"><a href="#cherry-pick拉取指定commit" class="headerlink" title="cherry-pick拉取指定commit"></a>cherry-pick拉取指定commit</h2><p>先把要拉取的commit id存起来：</p>
<pre><code>git checkout master_backup
git log &gt; ../master_backup.log
</code></pre>
<p>截取commit log片段如图<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051038438.png" alt="image-20221205103857374"></p>
<p>切到thomas分支，拉取master_backup的commit</p>
<pre><code>git checkout thomas
git cherry-pick 3d6b3be
</code></pre>
<p>这种方法只拉了一个commit, 更好的方式是按功能，一次拉多个commit,甚至一次把所有的commit都拉完。<br>cherry-pick支持多个pick一步到位<br>例如git log如下</p>
<pre><code>commit4 id4
commit3 id3
commit2 id2
commit1 id1
</code></pre>
<p>离散拉取：只拉取id1和id4：</p>
<pre><code>git cherry-pick id1 id4
</code></pre>
<p>！注意，提交顺序很重要，旧版本写在前新版本写在后<br>如果是区间拉取,即全部的id1，id2, id3，id4</p>
<pre><code>git cherry-pick id1..id4 //加两个点即为区间拉取
</code></pre>
<p>为了验证是不是真的拉取了多个版本，可以<code>git diff --name-only id1 id4</code>看下拉取后的修改哪些文件，对比被拉取分支的修改，如果一致，说明确实拉取多个commit<br>对于上图的commit，建议按功能多次cherry-pick并commit+push，便于后续debug。</p>
<h2 id="cherry-pick的冲突问题"><a href="#cherry-pick的冲突问题" class="headerlink" title="cherry-pick的冲突问题"></a>cherry-pick的冲突问题</h2><p>cherry-pick也是合并，只要是合并代码，就可能有冲突<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051039238.png" alt="image-20221205103926181"><br>合并单个commit,使用使用常规的冲突解决办法即可：</p>
<ul>
<li>到源码改冲突， <code>&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;</code>三个标记之间代码块二选一</li>
<li><code>git status</code>查看哪些待提交</li>
<li><code>git add -A</code>提交修改后的源码到本地.git</li>
</ul>
<h3 id="单个提交的冲突解决"><a href="#单个提交的冲突解决" class="headerlink" title="单个提交的冲突解决"></a>单个提交的冲突解决</h3><p>由于是从其他分支的commit id合并到当前分支（HEAD）,可以不加考虑的删掉<code>&lt;&lt;&lt;&lt;HEAD</code>和<code>====</code>之间的内容，采用<code>====</code>和<code>commit_id</code>之间的内容，随后删掉三个标记即可。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051039681.png" alt="image-20221205103951579"><br>有可能出现冲突代码块有重叠区的情况</p>
<pre><code>&lt;&lt;&lt;&lt; HEAD
code 1
=====
&lt;&lt;&lt;&lt; commit_id 1
code 2
&gt;&gt;&gt;&gt; commit_id 2
code 3
=====
code 4
&gt;&gt;&gt;&gt; commit_id 3
</code></pre>
<p>只要确定一个原则：&lt;&lt;&lt;&lt;是冲突块的起始点，&#x3D;&#x3D;&#x3D;&#x3D;是分界，&gt;&gt;&gt;&gt;是终止点，分两步删代码就可以了。</p>
<h3 id="多个提交的冲突解决："><a href="#多个提交的冲突解决：" class="headerlink" title="多个提交的冲突解决："></a>多个提交的冲突解决：</h3><p>如果是cherry-pick多个commit，冲突的解决方法就不一样了。<br>其区别在于，多个commit_id的cherry-pick，一旦遇到冲突，就会停下pick,需要手动解决冲突后，用<code>cherry-pick --continue</code>继续接下来的commit合并，直到由遇到冲突，再次手动解决。也就是说冲突会阻塞多个commit的cherry-pick，它不会一次性合并所有commit,让你一次性解决冲突。具体流程如下：</p>
<ul>
<li><code>cherry-pick id1 id2 id3 id4 .... idn</code></li>
<li>冲突报错，到源码手动解决</li>
<li><code>git add -A</code> 添加解决冲突后的文件到.git</li>
<li><code>cherry-pick --continue</code> 继续后面的合并,cherry-pick成功会自动提交commit信息</li>
<li>再遇到冲突，再次解决….</li>
<li>所有id1 … idn全部pick完成</li>
</ul>
<p>批量cherry-pick每次成功后都会有一次commit信息，有时候会报错，需要手动commit之后再continue</p>
<h3 id="特殊的冲突情况"><a href="#特殊的冲突情况" class="headerlink" title="特殊的冲突情况"></a>特殊的冲突情况</h3><p>提示有一个commit是合并的提交，即这个提交是两个分支的交汇，cherry-pick不知道以哪个分支为准<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040545.png" alt="image-20221205104005491"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040453.png" alt="image-20221205104017399"></p>
<p>如何解决：cherry-pick添加-m 1选项</p>
<pre><code>For example, if your commit tree is like below:

- A - D - E - F -   master
   \     /
    B - C           branch one
then git cherry-pick E will produce the issue you faced.

git cherry-pick E -m 1 means using D-E, while git cherry-pick E -m 2 means using B-C-E
</code></pre>
<p>例如选择cherry-pick commid_id -m 1, 结果如下，可手动解决冲突了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040782.png" alt="image-20221205104053730"><br>注意有merge的commit,会包含其他人的更新，如果只是pick自己的代码，不需要pick带merge的commit.</p>
<h1 id="跨仓库合并代码"><a href="#跨仓库合并代码" class="headerlink" title="跨仓库合并代码"></a>跨仓库合并代码</h1><p>假设某公司windows driver主线仓库为storport, 为了某产品定制的driver仓库为gg8, 现在gg8的所有feature已充分测试，准备合并到主线仓库storport, 这两个仓库的代码差异非常大，维护者众多，如何处理？</p>
<p>首先划分代码各部分归谁负责：<br>每个人用git，找出其在gg8仓库的个人修改，用winmerge手动合并到主线仓库storport<br>那么具体如何高效，可靠的合并：</p>
<p>git部分：<br>用git只找差异部分，具体操作：</p>
<pre><code>git diff commit_a commit_b //找所有文件+代码差异
git diff commit_a commit_b --stat //只显示有差异的文件名，这个信息对应winmerge手动合并很重要
git diff commit_a commit_b 指定文件路径 //只显示指定文件的内容差异，这个信息对应winmerge手动合并很重要
</code></pre>
<p>winmerge部分：<br>winmerge可以比较两个仓库所有差异，但是有些差异可能不需要合并，例如换行，修改时间等。总之winmerge的差异有很多“误报”<br>如果只一个个打开有差异的文件去比效率太低，需要借助git定位到哪些该开发者负责的文件有改变，以及文件内哪些代码是该开发者改变的。</p>
<p>找出某开发者A的提交改了哪些文件：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046241.png" alt="image-20221205104623191"></p>
<p>找出具体代码：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046320.png"></p>
<p>winmerge直接合并：<br>只是一句打印差异，但是如果不用git先定位，要从左侧差异栏找出此代码，相当困难<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046886.png" alt="image-20221205104642794"></p>
<p>这样，开发者A在代码合并过程中，完全不受其他开发者B, C的差异代码干扰</p>
<h1 id="强制覆盖本地代码"><a href="#强制覆盖本地代码" class="headerlink" title="强制覆盖本地代码"></a>强制覆盖本地代码</h1><p>git本地代码有时checkout到旧版本代码，想回到最新版本时，直接pull无法成功，且强制pull也不行。有以下两种方式解决：</p>
<h2 id="重新克隆"><a href="#重新克隆" class="headerlink" title="重新克隆"></a>重新克隆</h2><p>最简单是直接删掉本地项目，再重新<code>git clone</code></p>
<h2 id="fetch覆盖"><a href="#fetch覆盖" class="headerlink" title="fetch覆盖"></a>fetch覆盖</h2><pre><code>git fetch --all //拉取远程repo所有branch到本地，但不合并到本地repo
git reset --hard origin/master //本地repo强制同步远程repo的master分支
git pull -f //强制拉取远程repo最新代码
</code></pre>
<p>注意，如果本地旧版本代码有xxx.c，而远程最新代码没这个文件，本地需要手动删掉这个文件。因为以上操作不会删除本地文件，只会拉取本地没有的，或者覆盖不同的文件到本地。为了确保旧版本多出的文件删除，直接删除目录下除了<code>.git</code>以外的所有项目文件，再<code>fetch,reset,pull</code></p>
<h1 id="将本地未初始化git的项目上传到远程已初始化的git仓库"><a href="#将本地未初始化git的项目上传到远程已初始化的git仓库" class="headerlink" title="将本地未初始化git的项目上传到远程已初始化的git仓库"></a>将本地未初始化git的项目上传到远程已初始化的git仓库</h1><p>有一些项目代码是基于开源的庞大项目基础上开发，例如UEFI EDK2, Linux kernel.</p>
<p>项目开发时，可能基于不同的开源项目版本，例如：</p>
<p>远程git仓库是EDK2版本A0 + 自定义功能B0；本地的新功能是基于EDK2版本A1 + 自定义功能B1，且本地项目还没有初始化git。这种情况如何将本地项目直接上传到远程已有的项目上面去？</p>
<p>1.首先在本地建立git仓库</p>
<p>在本地新项目目录初始化git仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit信息&quot;</span><br></pre></td></tr></table></figure>

<p>2.将本地git仓库关联到远程已有的git仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin http://远程仓库地址.git</span><br></pre></td></tr></table></figure>

<p>3.拉取远程仓库到本地 (如果远程仓库为空不需要此步)</p>
<p>注意<code>--allow-unrelated-histories</code>是忽略本地项目和远程项目没有历史关联的关键参数，否则不能pull成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<p>合并代码通常会有冲突，手动解决冲突后再<code>git add, git commit -m &quot;fix merge conflict&quot;</code></p>
<p>4.最后推送本地仓库到远程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<h1 id="链接外部repo作为子模块"><a href="#链接外部repo作为子模块" class="headerlink" title="链接外部repo作为子模块"></a>链接外部repo作为子模块</h1><p>在github的项目仓库中，通常看到如下有@符号的外部仓库链接，点进去可能打开其他的项目仓库。这种外部仓库相当于当前项目仓库的子模块。</p>
<p>类似于Linux的软链接，子模块方式可以链接到其他项目仓库，并自动同步其他仓库最新的代码。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212091106114.png" alt="image-20221209110659056"></p>
<p>1.如何创建外部repo的链接:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add &quot;外部repo地址.git&quot; 外部repo文件夹名</span><br></pre></td></tr></table></figure>

<p>本地就clone了外部仓库到外部repo文件夹名中, 提交本项目和正常的提交流程相同</p>
<p>2.如何clone带外部repo的项目：</p>
<p>git clone 的时候需要加上<code>--recursive</code>，否则外部repo文件夹是空文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --recursive &quot;项目地址.git&quot;</span><br></pre></td></tr></table></figure>

<p>如果已经忘记加<code>--recursive</code>，可以手动初始化子模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h1 id="Git的常用配置"><a href="#Git的常用配置" class="headerlink" title="Git的常用配置"></a>Git的常用配置</h1><h2 id="配置多组用户信息"><a href="#配置多组用户信息" class="headerlink" title="配置多组用户信息"></a>配置多组用户信息</h2><p>git上传代码时会提交用户信息，包括姓名和邮箱，这个配置是本地的git配置文件决定。</p>
<p>如果要按项目配置多组用户信息，例如公司的代码以公司邮箱提交到公司内部的gitlab，个人项目的代码以个人邮箱提交到github，如何配置？</p>
<p>下面分别介绍全局配置、按项目配置和按文件目录配置三种git配置方法。</p>
<p>（1）git配置文件的位置</p>
<p>git配置文件为.gitconfig。对于windows, 一般在’C:\Users\用户名‘目录下，可以用everything查找.gitconfig，对于Linux, 一般在home目录。本文以windows为例。</p>
<p>（2）全局配置</p>
<p>.gitconfig里面默认的user字段就是全局的配置，首次使用git提交会提示用户输入此信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = youName</span><br><span class="line">    email = youEmail@example.com</span><br></pre></td></tr></table></figure>

<p>全局配置的查看和修改使用<code>--global</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name                           // 查询全局用户名</span><br><span class="line">git config --global user.name youName                   // 修改全局用户名</span><br><span class="line">git config --global user.email                          // 查询全局邮箱</span><br><span class="line">git config --global user.email youEmail@example.com     // 修改全局邮箱</span><br></pre></td></tr></table></figure>

<p>（3）对某个git项目自定义配置</p>
<p>这种方法的作用域只是某一个git项目，用的比较少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name                           // 查询项目用户名</span><br><span class="line">git config user.name youName                   // 修改项目用户名</span><br><span class="line">git config user.email                          // 查询项目邮箱</span><br><span class="line">git config user.email youEmail@example.com     // 修改项目邮箱</span><br></pre></td></tr></table></figure>

<p>（3）对某个路径下的所有git项目自定义配置</p>
<p>git的<code>Conditional Includes</code>可以针对文件夹配置，在.gitconfig添加如下格式的includeIf字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:path/to/you/gitdir/&quot;]</span><br><span class="line">    path = ~/.gitconfig_self</span><br></pre></td></tr></table></figure>

<p>其中path&#x2F;to&#x2F;you&#x2F;gitdir&#x2F;是要自定义配置的路径，可以包含很多git项目。注意尾部必须要加&#x2F;</p>
<p>.gitconfig_self是自定义配置的gitconfig文件，在里面指定[user]字段</p>
<p>例如我的自定义路径是F:&#x2F;github-my， 自定义配置文件.gitconfig_mygithub，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:F:/github-my/&quot;]</span><br><span class="line">    path = C:/Users/thomas.hu/.gitconfig_mygithub</span><br></pre></td></tr></table></figure>

<p>注意windows上不能直接右键创建只有后缀名的文件，会提示“必须键入文件名”。</p>
<p>使用CMD或Powershell的命令行创建.gitconfig_mygithub：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\Users\thomas.hu</span><br><span class="line">echo &gt; .gitconfig_mygithub</span><br></pre></td></tr></table></figure>

<p>.gitconfig_mygithub定义我个人项目的信息，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = cursorhu</span><br><span class="line">    email = 2449055512@qq.com</span><br></pre></td></tr></table></figure>

<p>全局的.gitconfig是公司项目信息，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">	name = thomas.hu</span><br><span class="line">	email = thomas.hu@xxx.com</span><br></pre></td></tr></table></figure>

<p>配置.gitconfig_mygithub完成后可见两种配置都生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git config --global user.name</span><br><span class="line">thomas.hu</span><br><span class="line">&gt; git config user.name</span><br><span class="line">cursorhu</span><br></pre></td></tr></table></figure>

<p>（4）三种配置文件的优先级</p>
<p>git使用以上三种配置的优先级为：项目配置 &gt; 路径配置 &gt; 全局配置</p>
<h2 id="换行符的配置"><a href="#换行符的配置" class="headerlink" title="换行符的配置"></a>换行符的配置</h2><p>为了解决跨平台的文件换行符问题，git支持自定义配置换行符规则。</p>
<p>（1）跨平台的文件换行符的相关背景</p>
<p>在各操作系统下，文本文件所使用的换行符是不一样的。UNIX&#x2F;Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是 0x0D（CR），后来的 OS X 版本与 UNIX 保持一致了。但 DOS&#x2F;Windows 使用 0x0D0A（CRLF）作为换行符。也就是说，在不同平台上写代码，其代码文件和一些项目配置文件的换行不一样。</p>
<p>（2）Git工具的autocrlf </p>
<p>Git最开始只支持类Unix的LF换行符，为了支持Windows开发的CRLF换行，Git提供了autocrlf 配置字段autocrlf 。</p>
<p>如果autocrlf enable, Windows 本地的CRLF文件在提交到git时，自动转换为LF换行；从git checkout文件到windows本地时，git将LF换行自动替换为 Windows 的换行符（CRLF）。Linux环境下checkout时文件换行也自动转换为Linux的LF格式。</p>
<p>如果autocrlf disable, Windows 本地的CRLF文件在提交到git时仍然为CRLF换行，如果有其他Linux环境的开发者checkout文件，可能无法在Linux上识别相关的CRLF文件引起项目编译问题。</p>
<p>如果没有跨平台的开发环境，即所有开发者都是Windows或都是Linux环境，则不需要autocrlf enable。</p>
<p>注意：对于windows版本的git, 默认是enable autocrlf，.gitconfig内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	autocrlf = true</span><br></pre></td></tr></table></figure>

<p>可以使用命令修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

<p>（3）同一个项目内，要同时支持LF和CRLF如何设置？</p>
<p>如果是临时的解决某些文件的换行问题，可以手动转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dos2unix #转换dos换行符为unix换行</span><br><span class="line">unix2dos #转换unix换行符为dos换行</span><br></pre></td></tr></table></figure>

<p>对git项目的配置，参考<a href="https://git-scm.com/docs/gitattributes">.gitattributes</a>，可以指定某路径的某文件使用指定的换行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*           text=auto		#set autocrlf manually for all files</span><br><span class="line">*.vcproj	text eol=crlf 	#all .vcproj files have CRLF</span><br><span class="line">*.sh		text eol=lf 	#all .sh files have LF</span><br><span class="line">*.jpg		-text 			#prevent .jpg files from being normalized</span><br></pre></td></tr></table></figure>

<p>eol attribute sets a specific line-ending style to be used in the working directory. This attribute has effect only if the <code>text</code> attribute is set or unspecified</p>
<p>一个项目既有windows的bat脚本又有Linux的sh脚本，在全局的core.autocrlf 为true的基础上，配置如下attribute 使这些文件不自动转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.bat	text eol=crlf</span><br><span class="line">*.sh	text eol=lf</span><br><span class="line">*/*.cfg	text eol=crlf</span><br></pre></td></tr></table></figure>

<h1 id="合并时有二进制文件冲突如何处理"><a href="#合并时有二进制文件冲突如何处理" class="headerlink" title="合并时有二进制文件冲突如何处理"></a>合并时有二进制文件冲突如何处理</h1><p>Git merge产生冲突：对于文本文件的冲突有强制处理要求，不解决完冲突无法提交；而对二进制文件的冲突只有提醒，没有强制处理要求。</p>
<p>对于文本文件，提交者可以直接修改冲突的内容；而对于二进制文件，提交者不能直接修改二进制冲突的内容，很容易漏过对二进制文件冲突的处理。</p>
<p>二进制文件冲突，git处理不了内容，应该使用覆盖的方式处理。手动覆盖可以解决此问题，但更合理的方法是用git命令自动解决。</p>
<p>git命令方法：在冲突发生后，使用命令<code>git checkout --ours|--theirs &lt;Paths&gt;</code>来选择是使用“Ours，即当前分支”的二进制文件，还是“Theirs，即合并进来的分支”的二进制文件直接替换掉本地的冲突二进制文件，其中<code>&lt;Paths&gt;</code>是冲突二进制文件的路径。</p>
<p>示例如下：</p>
<p>本地版本为branch-A，要合并进来branch-B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge branch-B --squash</span><br></pre></td></tr></table></figure>

<p>项目中的exe文件产生的冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">warning: Cannot merge binary files: fw_parameter_edit_tool/flash_header_parameter_update_tool.exe (HEAD vs. branch-B)</span><br><span class="line">Auto-merging fw_parameter_edit_tool/flash_header_parameter_update_tool.exe</span><br><span class="line">CONFLICT (content): Merge conflict in fw_parameter_edit_tool/flash_header_parameter_update_tool.exe</span><br></pre></td></tr></table></figure>

<p>此时使用checkout –theirs将branch-B版本的二进制覆盖掉本地branch-A版本的二进制。即完成了此exe的合并（使用branch-B版本）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git checkout --theirs fw_parameter_edit_tool/flash_header_parameter_update_tool.exe</span><br><span class="line">Updated 1 path from the index</span><br></pre></td></tr></table></figure>

<p>合并完以后用beyond compare确认一下两个版本的exe是完全一致的，也可以用git diff看一下合并前后二进制文件是否有差异。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动 -- SD/MMC driver分析与调试记录</title>
    <url>/2022/03/25/Linux%20MMCSD%20driver%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="1-Linux-MMC-框架现状"><a href="#1-Linux-MMC-框架现状" class="headerlink" title="1. Linux MMC 框架现状"></a>1. Linux MMC 框架现状</h2><p>Linux MMC driver是支持包括SD卡，eMMC卡等等，属于MultiMediaCard设备和接口的驱动<br>其源码路径位于Kernel source code的drivers&#x2F;mmc路径, 头文件位于include&#x2F;linux&#x2F;mmc<br>mmc源码分为core&#x2F;host两层，是为了解耦：</p>
<ul>
<li>通用的SD&#x2F;eMMC流程(core)</li>
<li>具体的硬件操作流程(host)，在此层又可分为通用的SDHCI框架和非SDHCI框架，各eMMC&#x2F;SD host厂商实现最底层driver时，可以遵循SDHCI框架下的API, 间接实现core层定义的方法(driver称为operations), 也可以不遵循SDHCI框架，直接实现core层定义的方法。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301058425.png"></li>
</ul>
<p>本文重点关注mmc框架对SD卡驱动的支持</p>
<h3 id="1-1-SD卡的类型概述"><a href="#1-1-SD卡的类型概述" class="headerlink" title="1.1 SD卡的类型概述"></a>1.1 SD卡的类型概述</h3><p>SD卡可以分为三种类型：<br>UHS-I, UHS-II, SD express</p>
<p>详细信息参考<a href="https://www.sdcard.org/">https://www.sdcard.org</a></p>
<ul>
<li>Physical Layer Specification Ver.7.10 (从各层描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD Host Controller Specification Ver7.0 (从host控制器角度，描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD_Specifications_Part_1_UHS_II_Addendum(描述SD UHSII的附录规范)</li>
</ul>
<p>UHS即Ultra High Speed, express也表示高速，这三代SD卡的读写速度是依次增加，参考下图：</p>
<ul>
<li>UHSI：50~104MB&#x2F;s</li>
<li>UHSII: 156~624MB&#x2F;s</li>
<li>SD express: 985MB&#x2F;s</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301119947.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301120184.png"></p>
<h3 id="1-2-Linux-MMC框架对SD卡的支持"><a href="#1-2-Linux-MMC框架对SD卡的支持" class="headerlink" title="1.2 Linux MMC框架对SD卡的支持"></a>1.2 Linux MMC框架对SD卡的支持</h3><p>基本概念：只有mmc框架的core层支持某种SD模式，host层才能实现这种模式；如果core层都不支持，只能厂商自己开发core层，以patch补丁的方式发布。</p>
<p>core层对于上述三种SD模式的支持：</p>
<ul>
<li>Linux kernel 5.11 以前，只支持UHS-I及其更低速度的legacy-SD模式</li>
<li>Linux kernel 5.11 开始，在core层添加了SD express的支持</li>
<li>目前没有UHS-II的支持，只有提交待审核的，参考：<a href="https://lore.kernel.org/all/?q=Jason%20Lai">lore.kernel.org&#x2F;Jason Lai&#x2F;patch</a></li>
</ul>
<p>host层对于上述三种SD模式的支持：</p>
<ul>
<li>UHS-I: 基本host目录的大多数SD厂商驱动都支持，很多符合sdhci框架</li>
<li>SD express: Realtek基于Linux kernel 5.11的core层API, 实现了 驱动的host底层部分，参考kernel的host&#x2F;rtsx_pci_sdmmc.c, 其没有使用SDHCI框架。</li>
<li>UHS-II: 只有以patch方式实现的，参考<a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a>，其实现了core&#x2F;host-sdhci&#x2F;host vendor多个层次的UHS-II支持。</li>
</ul>
<p>综上所述，本文参考uhs2-gl8755 patch，实现自己的SD UHSII driver。</p>
<h2 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2. 编译过程"></a>2. 编译过程</h2><p>本节描述编译mmc driver module和整个kernel的过程，同时描述中间踩的坑。</p>
<h3 id="2-1-直接编译整个Kernel-带UHS-II-Patch"><a href="#2-1-直接编译整个Kernel-带UHS-II-Patch" class="headerlink" title="2.1 直接编译整个Kernel(带UHS-II Patch)"></a>2.1 直接编译整个Kernel(带UHS-II Patch)</h3><p>安装Linux Ubuntu 20版本，Ubuntu环境下载和解压待编译的整个Linux kernel 源码：<a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a></p>
<p>注意：一定要在Linux环境下解压待编译源码，不能在windows下解压再拷到Linux编译，因为源码中有些大小写不同的同名文件，例如net&#x2F;netfilter的很多头文件。windows不区分大小，解压时写会让你替换或重命名，这些同名文件的内容不一样，所以不能替换或重命名，强行替换会导致编译Linux报错找不到相关文件。</p>
<ol>
<li>编译环境准备<br>gcc&#x2F;make等工具，都需要先安装build-essential等工具才能使用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>遇到的问题:</li>
</ul>
<p>apt如果有依赖问题，建议apt手动安装，如果要特定版本，例如指定依赖libc6库版本为2.35-0ubuntu3，使用<code>apt install libc6=2.35-0ubuntu3</code>, 可以用apt policy libc6查看。</p>
<p>这里不建议sudo apt install aptitude（使用aptitude自动安装需要的依赖库版本），因为会导致make menuconfig出现&lt;sys&#x2F;types.h&gt;找不到的问题，这个问题的原因是libc6-dev未安装，必须用apt安装libc6-dev解决此问题。</p>
<ol start="2">
<li>配置，编译和安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd linux-uhs2-gl9755-v3-patch #进入待编译Kernel源码</span><br><span class="line">make menuconfig #配置内核，生成.config文件</span><br><span class="line">make -j4 #以4线程编译内核，等同于make bzImage，make modules</span><br><span class="line">make modules_install #安装各Driver模块</span><br><span class="line">make install #安装内核(包括更新模块信息)</span><br></pre></td></tr></table></figure>
<p>编译完成后会自动update-grub, 重启后选择编译好的kernel版本启动。</p>
<p>也可以设置默认启动的kernel，编辑&#x2F;etc&#x2F;default&#x2F;grub的<code>GRUB_DEFAULT=&quot;1&gt;X&quot;</code>, 其中1表示从advanced选项启动，X表示从哪个kernel启动(0 based)，例如下图如果默认要从5.19启动，X设置为0，默认从5.8.0-rc4启动，X设置为6.<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202208171414943.png"><br>配置完毕必须要update-grub重启生效</p>
<ul>
<li><p>遇到的问题</p>
<p>make有canonical-certs.pem证书问题：修改.config，取消证书要求：CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;””，CONFIG_SYSTEM_REVOCATION_KEYS&#x3D;””</p>
</li>
</ul>
<ol start="3">
<li>查看内核版本</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r #查看当前运行的kernel版本</span><br><span class="line">cat Makefile #查看待编译kernel源码的内核版本</span><br></pre></td></tr></table></figure>
<p>以linux-uhs2-gl9755-v3-patch为例，其根目录Makefile如下，表示kernel源码版本为 5.8.0-rc4<br>编译完成重启后应该选择5.8.0-rc4启动，进入桌面后用<code>uname -r</code>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VERSION = 5</span><br><span class="line">PATCHLEVEL = 8</span><br><span class="line">SUBLEVEL = 0</span><br><span class="line">EXTRAVERSION = -rc4</span><br><span class="line">NAME = Kleptomaniac Octopus</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编译报错记录<br>(1) 生成vmlinux Image时报错：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to generate BTF for vmlinux  </span><br><span class="line">Try to disable CONFIG_DEBUG_INFO_BTF</span><br></pre></td></tr></table></figure>
<p>修改Kernel源码根目录的.config文件，CONFIG_DEBUG_INFO_BTF&#x3D;n 关闭此选项</p>
<p>​      (2) 编译完成，但运行新kernel时报错<code>out of memory</code><br>解决办法：裁剪module大小，编译模块时使用 <code>make  INSTALL_MOD_STRIP=1 modules_install</code>，.ko被编译时会缩减非必要的debug信息。</p>
<h3 id="2-2-合并UHSII-patch后再编译整个Kernel"><a href="#2-2-合并UHSII-patch后再编译整个Kernel" class="headerlink" title="2.2 合并UHSII patch后再编译整个Kernel"></a>2.2 合并UHSII patch后再编译整个Kernel</h3><p>官方kernel源码可以到<a href="https://www.kernel.org/">kernel.org</a>下载</p>
<p>合并UHSII patch，仅涉及到mmc模块的代码，如果差异不大可以将linux-uhs2-gl9755-v3-patch的drivers&#x2F;mmc和include头文件直接拷到待编译kernel的drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc。</p>
<p>如果是手动合并UHS-II patch，需要考虑以下部分：</p>
<ul>
<li>源码，包括drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc</li>
<li>Makefile, 包括drivers&#x2F;mmc&#x2F;core和drivers&#x2F;mmc&#x2F;host</li>
<li>Kconfig, 包括drivers&#x2F;mmc，及其子目录core和host</li>
</ul>
<p>具体合并方法参考《Linux设备驱动开发详解》<br>合并完后，Kernel编译流程和上节相同</p>
<h3 id="2-3-单独编译MMC模块"><a href="#2-3-单独编译MMC模块" class="headerlink" title="2.3 单独编译MMC模块"></a>2.3 单独编译MMC模块</h3><p>一般的驱动开发，都是可以单独编译成module模块，然后用rmmod和insmod替换原系统的模块</p>
<p>但是UHS-II patch涉及到mmc&#x2F;core层的改动，而core是build-in的，不能作为模块编译，因此只能编译整个kernel。以后如果只修改host层的代码，可以将mmc&#x2F;host单独编译为module后安装。</p>
<p>待编译kernel目录是<code>~/linux-5.8-rc4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#编译模块，&quot;M=&quot;指定待编译源码，编译完拷贝.ko到&quot;-C&quot;指定的目录，此目录为系统存放模块的目录</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc</span><br><span class="line"></span><br><span class="line">#安装模块</span><br><span class="line">make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc modules_install</span><br><span class="line">	</span><br><span class="line">#清除模块,包括.o和.ko文件</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc clean</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.kernel.org/doc/html/latest/kbuild/modules.html"># Building External Modules</a></p>
<p>注意，<code>make xxx modules_install</code>是不能让模块自动加载的，只是安装到了&#x2F;lib&#x2F;modules位置。使用<code>modinfo</code>查看模块信息，似乎是使用了&#x2F;lib&#x2F;modules下的，但没有实际加载和生效。<br>要加载模块，两种方法：</p>
<ol>
<li>rmmod&#x2F;insmod 手动替换, 参考下一节</li>
<li>make modules_install 之后再 make install，更新整个kernel, 此后外部模块才会被内核自动加载（通常使用这种方式）</li>
</ol>
<h3 id="2-4-手动替换MMC模块"><a href="#2-4-手动替换MMC模块" class="headerlink" title="2.4 手动替换MMC模块"></a>2.4 手动替换MMC模块</h3><h4 id="2-4-1-UHS-II相关模块的依赖关系"><a href="#2-4-1-UHS-II相关模块的依赖关系" class="headerlink" title="2.4.1 UHS-II相关模块的依赖关系"></a>2.4.1 UHS-II相关模块的依赖关系</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301640662.png"></p>
<p>可以从mmc&#x2F;host的Kconfig得知依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config MMC_SDHCI_PCI</span><br><span class="line">	tristate &quot;SDHCI support on PCI bus&quot;</span><br><span class="line">	depends on MMC_SDHCI &amp;&amp; PCI</span><br><span class="line">	select MMC_SDHCI_UHS2</span><br><span class="line">	</span><br><span class="line">config MMC_SDHCI_UHS2</span><br><span class="line">	tristate &quot;UHS2 support on SDHCI controller&quot;</span><br><span class="line">	depends on MMC_SDHCI</span><br></pre></td></tr></table></figure>

<p>使用<code>lsmod</code>可以得知module依赖关系，如下图，sdhci_uhs2被sdhci_pci引用1次, sdhci被sdhci_uhs2和sdhci_pci引用2次<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645712.png"><br><code>modinfo</code>可以得知已加载module的.ko路径<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645737.png"></p>
<h4 id="2-4-2-手动卸载和装载module"><a href="#2-4-2-手动卸载和装载module" class="headerlink" title="2.4.2 手动卸载和装载module"></a>2.4.2 手动卸载和装载module</h4><p>卸载和装载都要按依赖顺序处理，shell脚本如下.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">sudo rmmod sdhci_pci</span><br><span class="line">sudo rmmod sdhci_uhs2</span><br><span class="line">sudo rmmod sdhci</span><br><span class="line"></span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-uhs2.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-pci.ko </span><br></pre></td></tr></table></figure>

<h2 id="3-调试过程"><a href="#3-调试过程" class="headerlink" title="3. 调试过程"></a>3. 调试过程</h2><h3 id="3-1-调试工具"><a href="#3-1-调试工具" class="headerlink" title="3.1 调试工具"></a>3.1 调试工具</h3><ol>
<li>printk<br>printk是很常用的driver调试手段，配合dmesg查看kernel log可以定位常见问题。<br>printk如何开启不同打印级别，参考<a href="https://www.kernel.org/doc/html/latest/core-api/printk-basics.html"># Message logging with printk</a></li>
</ol>
<p>例如，使用<code>dmesg -n 6</code>开启KERN_INFO级别，然后在driver中添加pr_info()作为info打印, 在dmesg中查看打印log。</p>
<p>注意KERN_DEBUG比较特殊，不仅要<code>dmesg -n 7</code>开启, 还需要在driver module的makefile添加Debug CFLAGS, 有两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#该Makefile相关模块全部启用debug</span><br><span class="line">EXTRA_CFLAGS += -DDEBUG</span><br><span class="line"></span><br><span class="line">#指定模块启用debug</span><br><span class="line">CFLAGS-xxx-mmc += -DDEBUG</span><br></pre></td></tr></table></figure>
<p>示例：使用<code>pr_info(“enter %s\n”, __FUNCTION__);</code> 打印函数调用流程</p>
<ol start="2">
<li>dmesg<br>示例参考 <a href="https://www.geeksforgeeks.org/how-to-use-the-dmesg-command-on-linux/"># How to use the dmesg Command on Linux</a><br>比较常用的有：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dmesg</span><br><span class="line">sudo dmesg -c </span><br><span class="line">sudo dmesg | head -100</span><br><span class="line">sudo dmesg | tail</span><br><span class="line">sudo dmesg | xxx</span><br></pre></td></tr></table></figure>

<p>3.vscode<br>vscode比vim&#x2F;gedit更方便直接改代码，用.deb安装容易失败，推荐命令行安装方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#更新相关microsoft源</span><br><span class="line">wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] \</span><br><span class="line">https://packages.microsoft.com/repos/code stable main&quot; &gt; /etc/apt/sources.list.d/vscode.list&#x27;</span><br><span class="line"></span><br><span class="line">rm -f packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install code</span><br></pre></td></tr></table></figure>
<h3 id="3-2-UHSII调试"><a href="#3-2-UHSII调试" class="headerlink" title="3.2 UHSII调试"></a>3.2 UHSII调试</h3><ol>
<li><p>模块加载初始化过程中dmesg显示直接dump<br>基本是空指针问题，例如：</p>
<ul>
<li>只编译UHSII host 模块，而不编译kernel的core层，insmod host模块时就会dump, 因为core层相关API不存在。</li>
<li>获取相关数据结构方法不对导致空指针<br>例如获取slot要使用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  struct sdhci_pci_slot *slot = sdhci_priv(host);</span><br><span class="line"></span><br><span class="line">static inline void *sdhci_priv(struct sdhci_host *host)&#123;</span><br><span class="line">   return host-&gt;private;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>而host-&gt;private实际指向sdhci_host结构体的最后定义的如下0长度数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long private[] ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct"># <a href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct">Explanation on private variable in c struct</a></a><br>基本含义是可以获取结构体外部的数据，而host指针本身确实属于slot结构体sdhci_pci_slot的一部分，所以host-&gt;private能访问到slot。</p>
</li>
<li><p>贴一段dmesg log，包含UHSII初始化过程直到最后一步GO_DORMANT fail<br>具体流程参考UHSII spec:  SD_Specifications_Part_1_UHS_II_Addendum</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  522.171631] sdhci_uhs2 [sdhci_uhs2_do_detect_init()]: sdhci_uhs2_do_detect_init: begin UHS2 init.</span><br><span class="line">[  522.171632] enter sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171632] exit sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171835] sdhci_uhs2 [sdhci_uhs2_interface_detect()]: mmc0: UHS2 Lane synchronized in UHS2 mode, PHY is initialized.</span><br><span class="line">[  522.171855] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171856] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 0</span><br><span class="line">[  522.171858] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171865] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.171874] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.171885] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.171887] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171887] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 1</span><br><span class="line">[  522.171888] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171894] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188184] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188205] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188254] [uhs2_dev_init()]: CF is set, device is initialized!</span><br><span class="line">[  522.188257] [uhs2_enum()]: Begin ENUMERATE, header=0x80, arg=0x392, payload=0xf0.</span><br><span class="line">[  522.188260] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x392</span><br><span class="line">[  522.188262] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=8</span><br><span class="line">[  522.188266] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188277] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188290] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188308] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188318] [uhs2_enum()]: id_f = 6, id_l = 6.</span><br><span class="line">[  522.188320] [uhs2_enum()]: Enumerate Cmd Completed. No. of Devices connected = 1</span><br><span class="line">[  522.188322] [uhs2_config_read()]: INQUIRY_CFG: read Generic Caps.</span><br><span class="line">[  522.188324] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x10.</span><br><span class="line">[  522.188326] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x10</span><br><span class="line">[  522.188328] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188331] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188342] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188363] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188392] mmc0: req done (CMD0): 0: 00010100 00000000 00000000 00000000</span><br><span class="line">[  522.188398] [uhs2_config_read()]: Device Generic Caps (0-31) is: 0x10100.</span><br><span class="line">[  522.188399] [uhs2_config_read()]: INQUIRY_CFG: read PHY Caps.</span><br><span class="line">[  522.188401] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x220.</span><br><span class="line">[  522.188404] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x220</span><br><span class="line">[  522.188410] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188415] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188427] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188447] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188476] mmc0: req done (CMD0): 0: 00008000 00000080 00000000 00000000</span><br><span class="line">[  522.188482] [uhs2_config_read()]: Device PHY Caps (0-31) is: 0x8000.</span><br><span class="line">[  522.188484] [uhs2_config_read()]: Device PHY Caps (32-63) is: 0x80.</span><br><span class="line">[  522.188487] [uhs2_config_read()]: INQUIRY_CFG: read LINK-TRAN Caps.</span><br><span class="line">[  522.188492] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x420.</span><br><span class="line">[  522.188499] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x420</span><br><span class="line">[  522.188504] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188507] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188516] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188554] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188582] mmc0: req done (CMD0): 0: 20024000 00000000 00000000 00000000</span><br><span class="line">[  522.188601] [uhs2_config_read()]: Device LINK-TRAN Caps (0-31) is: 0x20024000.</span><br><span class="line">[  522.188604] [uhs2_config_read()]: Device LINK-TRAN Caps (32-63) is: 0x0.</span><br><span class="line">[  522.188605] [uhs2_config_write()]: SET_COMMON_CFG: write Generic Settings.</span><br><span class="line">[  522.188607] [uhs2_config_write()]: Both Host and device support 2L-HD.</span><br><span class="line">[  522.188609] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0</span><br><span class="line">[  522.188611] [uhs2_config_write()]: UHS2 write Generic Settings 00000000 00000000</span><br><span class="line">[  522.188613] [uhs2_config_write()]: flags=00000005 dev_prop.n_lanes_set=0 host_caps.n_lanes_set=0</span><br><span class="line">[  522.188615] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188618] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188620] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188632] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188650] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188678] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188684] [uhs2_config_write()]: SET_COMMON_CFG: PHY Settings.</span><br><span class="line">[  522.188686] [uhs2_config_write()]: set dev_prop.speed_range_set to SPEED_B</span><br><span class="line">[  522.188689] [uhs2_config_write()]: UHS2 SET PHY Settings  40000000 04000000</span><br><span class="line">[  522.188691] [uhs2_config_write()]: host-&gt;flags=00000015 dev_prop.speed_range_set=1</span><br><span class="line">[  522.188693] [uhs2_config_write()]: dev_prop.n_lss_sync_set=4 host_caps.n_lss_sync_set=4</span><br><span class="line">[  522.188694] [uhs2_config_write()]: dev_prop.n_lss_dir_set=0 host_caps.n_lss_dir_set=8</span><br><span class="line">[  522.188696] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xaa0</span><br><span class="line">[  522.188698] [uhs2_config_write()]: 		payload[0]=0x40000000 payload[1]=0x4000000</span><br><span class="line">[  522.188700] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xaa0</span><br><span class="line">[  522.188703] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=4</span><br><span class="line">[  522.188705] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188715] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188730] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188741] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188746] [uhs2_config_write()]: SET_COMMON_CFG: LINK-TRAN Settings.</span><br><span class="line">[  522.188748] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xca0</span><br><span class="line">[  522.188750] [uhs2_config_write()]: 		payload[0]=0x80320 payload[1]=0x1000000</span><br><span class="line">[  522.188752] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xca0</span><br><span class="line">[  522.188754] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188756] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188766] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188780] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188808] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188813] [uhs2_config_write()]: SET_COMMON_CFG: Set Config Completion.</span><br><span class="line">[  522.188815] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0, payload[0] = 0x0.</span><br><span class="line">[  522.188817] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188819] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=5</span><br><span class="line">[  522.188821] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188831] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188842] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188855] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188862] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 0.</span><br><span class="line">[  522.201612] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 3.</span><br><span class="line">[  522.201614] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 2.</span><br><span class="line">[  522.201616] [uhs2_go_dormant()]: Begin GO_DORMANT_STATE, header=0x86, arg=0x192, payload=0x0.</span><br><span class="line">[  522.201617] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x192</span><br><span class="line">[  522.201618] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=0</span><br><span class="line">[  522.201619] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.201626] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x8c0 is set to UHS2 CMD register.</span><br><span class="line">[  522.218633] mmc0: sdhci: IRQ status 0x00008000</span><br><span class="line">[  522.218636] sdhci_uhs2 [sdhci_uhs2_irq()]: *** mmc0 got UHS2 interrupt: 0x00010000</span><br><span class="line">[  522.218651] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218652] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218652] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218654] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218659] mmc0: req done (CMD0): -110: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.218666] mmc0: uhs2_go_dormant: UHS2 CMD send fail, err= 0xffffff92!</span><br><span class="line">[  522.218668] mmc0: uhs2_change_speed: UHS2 GO_DORMANT_STATE fail, err= 0xfffffffb!</span><br><span class="line">[  522.218669] mmc0: UHS2 uhs2_change_speed() fail!</span><br></pre></td></tr></table></figure>
<p>含义是UHSII初始化接近完成，切换到高速的RangeB时，GO_DORMANT_STATE命令未完成，超时。<br>解决办法：先绕过RangeB模式，使用RangA(较低速度的UHSII模式)，为此要从一开始就上报host不支持RangeB。<br>修改mmc&#x2F;host&#x2F;sdhci-uhs2.c中的上报host能力(capability)的speed_range为不支持RangeB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mmc-&gt;uhs2_caps.speed_range =(caps_phy &amp; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_MASK) &gt;&gt; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_SHIFT;</span><br><span class="line"></span><br><span class="line">mmc-&gt;uhs2_caps.speed_range = 0; //Range-A</span><br></pre></td></tr></table></figure>
<p>重新编译安装module后，UHSII初始化正常，读写正常。</p>
<p>事实上此GO_DORMANT fail issue的根本原因是兼容性问题：<br>UHSII初始化流程中，SD host侧对lane speed的配置最好在卡处在dormant状态下进行，host侧提高速度（从Range-A提高到RangeB）以后，卡侧在退出dormant状态时重新配置速度，和host速度匹配。<br>如果host侧修改lane speed时间点错误，有的SD卡来不及反应，不能同步速度，所以GO_DORMANT fail；而有的SD 卡性能好，随时同步host侧的速度，没有此issue。</p>
<p>另外有的Issue和硬件特性相关，例如上电需要等待一定时间以后，才能启动UHSII设备初始化，这个等待时间取决于SD host厂商的硬件特性。</p>
]]></content>
      <categories>
        <category>linux驱动</category>
      </categories>
      <tags>
        <tag>mmc</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：SSD的S3/S4/S5压力测试脚本</title>
    <url>/2020/09/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9ASSD%E7%9A%84S3-S4-S5%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>存储设备产品（如SSD&#x2F;eMMC）的读写速度和稳定性测试，是量产前必不可少的步骤。除了常规的两个设备来回拷贝读写，存储设备做系统盘的情况下，反复的启动，睡眠，休眠，也是重要的测试项。本文介绍这几种测试的原理，工具实现，和调试过程</p>
<h1 id="系统电源状态"><a href="#系统电源状态" class="headerlink" title="系统电源状态"></a>系统电源状态</h1><p>ACPI（高级配置与电源接口）是电源配置和接口的规范，供操作系统和应用程序管理所有电源，其定义了几种状态（State）：S1~S6<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051553199.png" alt="image-20221205155311145"></p>
<p>操作系统在ACPI基础上实现各自的电源状态划分<br>Linux电源状态划分为如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554689.png" alt="image-20221205155406635"></p>
<p>其中，常见的几种状态有别称，如S3通常也称Suspend，S4也称Hibernation, S5即shutdown。下面描述这几种状态的区别</p>
<p>S3:<br>1、将系统当前的运行状态等数据保存在内存中，此时仍需要向RAM供电，以保证后续快速恢复至工作状态<br>2、冻结用户态的进程和内核态的任务（进入内核态的进程或内核自己的task）<br>3、关闭外围设备，如显示屏、鼠标等,中断唤醒外设不会关闭，如电源键<br>4、CPU停止工作</p>
<p>S4：<br>挂起到硬盘，俗称休眠（Hibernation）将系统当前的运行状态等数据保存到硬盘上，并自动关机。下次开机时便从硬盘上读取之前保存的数据，恢复到休眠关机之前的状态。<br>譬如在休眠关机时，桌面打开了一个应用，那么下一次开机启动时，该应用也处于打开状态。而正常的关机-开机流程，该应用是不会打开的</p>
<p>S5:<br>关机并断电，实际上，S5在不同场景下，可以指代关机和重启两种操作，关机是彻底power off的，而重启不是彻底断电，只是重新启动了系统，（当然基本所有设备都被reset），重启！&#x3D;关机再启动。</p>
<h1 id="测试工具设计"><a href="#测试工具设计" class="headerlink" title="测试工具设计"></a>测试工具设计</h1><p>需求：设计工具使系统从S0(working)进入S3&#x2F;S4&#x2F;S5状态，维持一段时间，然后退出该状态，在S0维持一段时间，再次进入S3&#x2F;S4&#x2F;S5状态，如此反复循环。用户输入工作模式（S3&#x2F;S4&#x2F;S5）和循环次数，工具输出运行日志，包含已运行次数和时间戳。</p>
<h2 id="Linux测试脚本实现"><a href="#Linux测试脚本实现" class="headerlink" title="Linux测试脚本实现"></a>Linux测试脚本实现</h2><p>Linux环境有现成的工具：rtcwake，参看其man page：</p>
<pre><code>NAME
       rtcwake - enter a system sleep state until specified wakeup time
SYNOPSIS
       rtcwake [options] [-d device] [-m standby_mode] {-s seconds|-t time_t}
DESCRIPTION
       This program is used to enter a system sleep state and to automatically wake from it at a specified time.
       This uses cross-platform Linux interfaces to enter a system sleep state, and leave it no later than a specified time.  It uses any RTC framework driver that supports standard driver model wakeup flags.
       This is normally used like the old apmsleep utility, to wake from a suspend state like ACPI S1 (standby) or S3 (suspend-to-RAM).  Most platforms can implement those without analogues of BIOS, APM, or ACPI.
       On some systems, this can also be used like nvram-wakeup, waking from states like ACPI S4 (suspend to disk).  Not all systems have persistent media that are appropriate for such suspend modes.
       Note that alarm functionality depends on hardware; not every RTC is able to setup an alarm up to 24 hours in the future.
       The suspend setup may be interrupted by active hardware; for example wireless USB input devices that continue to send events for some fraction of a second after the return key is pressed.  rtcwake tries to avoid this problem and it waits to terminal to settle down before entering a system sleep.
</code></pre>
<p>其重要option如下：</p>
<pre><code>      -m, --mode mode
              Go into the given standby state.  Valid values for mode are:

              standby
                     ACPI state S1.  This state offers minimal, though real,
                     power savings, while providing a very low-latency
                     transition back to a working system.  This is the
                     default mode.

              freeze The processes are frozen, all the devices are suspended
                     and all the processors idled.  This state is a general
                     state that does not need any platform-specific support,
                     but it saves less power than Suspend-to-RAM, because
                     the system is still in a running state.  (Available
                     since Linux 3.9.)

              mem    ACPI state S3 (Suspend-to-RAM).  This state offers
                     significant power savings as everything in the system
                     is put into a low-power state, except for memory, which
                     is placed in self-refresh mode to retain its contents.

              disk   ACPI state S4 (Suspend-to-disk).  This state offers the
                     greatest power savings, and can be used even in the
                     absence of low-level platform support for power
                     management.  This state operates similarly to Suspend-
                     to-RAM, but includes a final step of writing memory
                     contents to disk.

              off    ACPI state S5 (Poweroff).  This is done by calling
                     &#39;/sbin/shutdown&#39;.  Not officially supported by ACPI,
                     but it usually works.

              no     Don&#39;t suspend, only set the RTC wakeup time.

              on     Don&#39;t suspend, but read the RTC device until an alarm
                     time appears.  This mode is useful for debugging.

              disable
                     Disable a previously set alarm.

              show   Print alarm information in format: &quot;alarm: off|on
                     &lt;time&gt;&quot;.  The time is in ctime() output format, e.g.,
                     &quot;alarm: on  Tue Nov 16 04:48:45 2010&quot;.
                     
       -s, --seconds seconds
              Set the wakeup time to seconds in the future from now.

       -t, --time time_t
              Set the wakeup time to the absolute time time_t.  time_t is
              the time in seconds since 1970-01-01, 00:00 UTC.  Use the
              date(1) tool to convert between human-readable time and
              time_t.
</code></pre>
<p>只需要写shell script调用rtcwake即可<br>注意要求跨状态记录日志，S3&#x2F;S4很容易，运行信息只是被挪到内存、硬盘，不会丢失，但S5会shutdown, 因此循环次数和时间只能记录在掉电不丢失的硬盘里。<br>S3S4可以用一个脚本完成，而S5需要单独设计<br>S3S4.sh如下：<br>接受用户输入：<br>opt: S3或S4模式；COUNT：循环次数<br>每次执行rtcwake，日志写入LOG</p>
<pre><code>opt=$1
COUNT=$2
interval=30
s3timer=120
s4timer=120

mkdir -p log
DATE=$(date +%Y-%m-%d)
LOG=log/${opt}_${DATE}.log
cat /dev/null &gt; ${LOG}

echo &quot;=============================== $opt test start ===============================&quot; |tee -a ${LOG}

for (( i=1; i&lt;=$COUNT; i++ ))
do 
	if [ $opt == &quot;s3&quot; ];then
		echo &quot;************************* S3 Cycle: $i start *************************&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S3, Duration &quot;$s3timer&quot; sec&quot; |tee -a ${LOG}
		sudo rtcwake -m mem -s $s3timer &gt;&gt; ${LOG} 2&gt;&amp;1
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Waitable timer triggered.&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Wake up from S3, Cycle &quot;$i&quot;&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Successfully left sleep state S3...&quot; |tee -a ${LOG}
	elif [ $opt == &quot;s4&quot; ];then
		echo &quot;************************* S4 Cycle: $i start *************************&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S4, Duration &quot;$s4timer&quot; sec&quot; |tee -a ${LOG}
		sudo rtcwake -m disk -s $s4timer &gt;&gt; ${LOG} 2&gt;&amp;1
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Waitable timer triggered.&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Wake up from S4, Cycle &quot;$i&quot;&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Successfully left sleep state S4...&quot; |tee -a ${LOG}
	else
		echo &quot;error input, use s3 or s4 as input&quot;
	fi
	echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;wake up for $interval seconds&quot; |tee -a ${LOG}
	echo &quot;************************* $opt Cycle: $i finish *************************&quot; |tee -a ${LOG}
	#keep wake up time
	sleep $interval
done

echo &quot;=============================== $opt test finished =============================== &quot; |tee -a ${LOG}
</code></pre>
<p>S5必须要解决两个问题：<br>1.每次测试的信息如何跨越重启<br>2.如何使系统自动不断的重启</p>
<p>对于1，可以将日志写入固定文件，每次重启后读该文件并追加，知道S5循环结束<br>对于2，Linux有开机自动启动某些桌面程序、shellscript的机制</p>
<p>S5测试脚本分为三部分：<br>配置自启动并执行首次重启的脚本：s5_start.sh<br>执行单次S5的脚本，即自启动调用的脚本：s5.sh<br>停止S5，清楚自启动配置的脚本：s5_stop.sh</p>
<p>s5_start.sh</p>
<pre><code>#!/bin/bash
USER=$(users)
opt=s5
interval=30
s5timer=180

#config autostart
mkdir -p /home/$USER/.config/autostart
touch /home/$USER/.config/autostart/s5.desktop
echo &quot;
[Desktop Entry]
Type=Application
Exec=gnome-terminal -e /home/$USER/s5.sh
Terminal=true
X-GNOME-Autostart-enabled=true
&quot; &gt; /home/$USER/.config/autostart/s5.desktop
chmod 777 /home/$USER/.config/autostart/s5.desktop
echo &quot;config autostart finished&quot;

#config sudo
echo &quot;$USER ALL=(ALL) NOPASSWD:ALL&quot; &gt;&gt; /etc/sudoers

#config s5 log and temp file 
mkdir -p log
DATE=$(date +%Y-%m-%d)
LOG=log/${opt}_${DATE}.log
cat /dev/null &gt; ${LOG}
echo &quot;1&quot; &gt; ${opt}_cycle.txt
echo &quot;$LOG&quot; &gt; ${opt}_log.txt
chmod 777 -R ./*.sh ./log/*.log ./*.txt

echo &quot;System will shutdown after &quot;$interval&quot; sec, then restart after &quot;$s5timer&quot; sec&quot;
echo &quot;*********************** S5 Cycle: 1 *************************&quot; |tee -a ${LOG}
echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S5 after &quot;$interval&quot; sec&quot; |tee -a ${LOG}
sleep $interval

rtcwake -m off -s $s5timer &gt;&gt; ${LOG} 2&gt;&amp;1
</code></pre>
<p>s5.sh</p>
<pre><code>#!/bin/bash
COUNT=&quot;999&quot;
opt=s5
interval=30
s5timer=180
cycle=$(&lt;${opt}_cycle.txt)
LOG=$(&lt;${opt}_log.txt)

#update cycle
((cycle++))
echo &quot;$cycle&quot; &gt; ${opt}_cycle.txt 

#keep wake
echo &quot;*********************** S5 Cycle: $cycle *************************&quot; |tee -a ${LOG}
echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S5 after &quot;$interval&quot; sec&quot; |tee -a ${LOG}
sleep $interval

sudo rtcwake -m off -s $s5timer &gt;&gt; ${LOG} 2&gt;&amp;1
</code></pre>
<p>s5_stop.sh</p>
<pre><code>#!/bin/bash
USER=$(users)
opt=s5
rm -f /home/$USER/.config/autostart/s5.desktop
rm -f ${opt}_cycle.txt ${opt}_log.txt
sed -i &#39;/NOPASSWD/d&#39; /etc/sudoers
</code></pre>
<h2 id="测试脚本使用"><a href="#测试脚本使用" class="headerlink" title="测试脚本使用"></a>测试脚本使用</h2><h3 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h3><pre><code>./s3s4.sh s3 999      启动s3测试,运行999次
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554212.png" alt="image-20221205155429129"></p>
<h3 id="S4"><a href="#S4" class="headerlink" title="S4"></a>S4</h3><p>S4在内存和硬盘直接读写运行时映像，硬盘需要指定那一块区域用于和内存交换，即交换分区。Linux一切皆文件，交换分区也可以用swapfile配置。以下配置swapfile</p>
<ol>
<li><p>df –h 查看挂载点为&#x2F;对应的文件系统是&#x2F;dev&#x2F;nvme0n1p2,根据你具体情况记录<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554816.png"></p>
</li>
<li><p><code>blkid</code>查看UUID值，根据1对应的nvme文件系统记录UUID<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554581.png"></p>
</li>
<li><p><code>filefrag –v /swapfile</code>查看swapfile的物理起始地址，记录physical_offset左侧值<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554581.png"></p>
</li>
<li><p>将UUID和physical_offset值写入grub：<br>终端输入gedit &#x2F;etc&#x2F;default&#x2F;grub ，修改以下参数并保存<br><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash resume=UUID=你的UUID值 resume_offset=你的physical_offset值</code>“</p>
<p> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051555015.png" alt="image-20221205155518922"></p>
</li>
<li><p>   重新生成grub: 终端输入 <code>update-grub</code> 回车并重启电脑。</p>
</li>
</ol>
<p>启动S4脚本</p>
<pre><code>./s3s4.sh s4 999
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051557197.png" alt="image-20221205155749113"></p>
<h3 id="S5"><a href="#S5" class="headerlink" title="S5"></a>S5</h3><p>自动重启需要先解决账户密码问题<br>设置普通账户自动登录：<br>普通账户为装系统时设置的账户，重启后默认以普通账户登录<br>1.终端输入<code>gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</code>弹出编辑界面<br>设置以下参数，ctrl+s保存后关闭</p>
<pre><code>[Seat:*]
user-session=ubuntu
autologin-user=你的账户名
</code></pre>
<p>2.终端输入<code>gedit /etc/gdm3/custom.conf</code>，设置以下几行的值为如下</p>
<pre><code># Enabling automatic login
AutomaticLoginEnable = true
AutomaticLogin =你的账户名
</code></pre>
<p>重启，确认可免密码登录桌面。</p>
<pre><code>./s5_start.sh 启动s5
./s5_stop.sh 结束S5
</code></pre>
<h1 id="Dmesg分析和调试"><a href="#Dmesg分析和调试" class="headerlink" title="Dmesg分析和调试"></a>Dmesg分析和调试</h1><h2 id="dmesg简介"><a href="#dmesg简介" class="headerlink" title="dmesg简介"></a>dmesg简介</h2><p>dmesg命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备<br>注意：<br>dmesg只记录从启动到当前时间的信息，掉电丢失</p>
<p>使用示例：</p>
<pre><code>dmesg //默认输出
dmesg | less //从头分页显示
dmesg | tail -100 //显示最后100行
dmesg | head  -100 //显示最早100行
dmesg | grep -i usb //包含usb的信息，忽略大小写
dmesg -C //清除log
</code></pre>
<p>输出示例：</p>
<pre><code>[root]# dmesg | grep sda
 
[    1.280971] sd 2:0:0:0: [sda] 488281250 512-byte logical blocks: (250 GB/232 GiB)
[    1.281014] sd 2:0:0:0: [sda] Write Protect is off
[    1.281016] sd 2:0:0:0: [sda] Mode Sense: 00 3a 00 00
[    1.281039] sd 2:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn&#39;t support DPO or FUA
[    1.359585]  sda: sda1 sda2 &lt; sda5 sda6 sda7 sda8 &gt;
[    1.360052] sd 2:0:0:0: [sda] Attached SCSI disk
[    2.347887] EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
[   22.928440] Adding 3905532k swap on /dev/sda6.  Priority:-1 extents:1 across:3905532k FS
[   23.950543] EXT4-fs (sda1): re-mounted. Opts: errors=remount-ro
[   24.134016] EXT4-fs (sda5): mounted filesystem with ordered data mode. Opts: (null)
[   24.330762] EXT4-fs (sda7): mounted filesystem with ordered data mode. Opts: (null)
[   24.561015] EXT4-fs (sda8): mounted filesystem with ordered data mode. Opts: (null)
</code></pre>
<p>输出时间戳是从上电开始，到当前的时间，以秒为单位。</p>
<h2 id="调试S4-hang"><a href="#调试S4-hang" class="headerlink" title="调试S4 hang"></a>调试S4 hang</h2><p>在测试中发现，nvme存储设备，首次进入S4的时间较长，约30s, 且系统处于hang状态，鼠标无法移动。<br>dmesg查看单次S4 enter &amp; resume的过程，log如下</p>
<pre><code>[   43.090180] PM: hibernation entry          //开机43秒进s4流程
[   43.090579] PM: Syncing filesystems ...   
[   43.090682] PM: done.
[   43.090684] Freezing user space processes ... (elapsed 0.003 seconds) done.   //冻结用户进程，这个时候会hang
[   43.093699] OOM killer disabled.
[   43.093876] PM: Marking nosave pages: [mem 0x00000000-0x00000fff]       //准备哪些内存要转存到disk
[   43.093878] PM: Marking nosave pages: [mem 0x0005f000-0x0005ffff]
[   43.093880] PM: Marking nosave pages: [mem 0x000a0000-0x000fffff]
[   43.093887] PM: Marking nosave pages: [mem 0x80185000-0x80186fff]
[   43.093889] PM: Marking nosave pages: [mem 0x88c4f000-0x890acfff]
[   43.093944] PM: Marking nosave pages: [mem 0x89214000-0x89efefff]
[   43.094102] PM: Marking nosave pages: [mem 0x89f00000-0xffffffff]
[   43.098151] PM: Basic memory bitmaps created
[   43.098541] PM: Preallocating image memory... 
[   43.143802] hpet_rtc_timer_reinit: 29 callbacks suppressed
[   43.143803] hpet1: lost 2 rtc interrupts
[   43.197779] hpet1: lost 2 rtc interrupts
[   43.251708] done (allocated 333315 pages)               //分配内存侧的交换页
[   43.251709] PM: Allocated 1333260 kbytes in 0.15 seconds (8888.40 MB/s)
[   43.251710] Freezing remaining freezable tasks ... (elapsed 0.126 seconds) done.
[   43.379023] printk: Suspending console(s) (use no_console_suspend to debug)
[   43.381268] serial 00:02: disabled
[   43.382187] parport_pc 00:01: disabled
[   43.701432] ACPI: Preparing to enter system sleep state S4  //准备进S4, 关CPU, 中断，
[   44.400195] PM: Saving platform NVS memory
[   44.404308] Disabling non-boot CPUs ...
[   44.404935] IRQ 123: no longer affine to CPU1
[   44.404942] IRQ 132: no longer affine to CPU1
[   44.405979] smpboot: CPU 1 is now offline
[   44.410695] smpboot: CPU 2 is now offline
[   44.414738] IRQ 122: no longer affine to CPU3
[   44.415784] smpboot: CPU 3 is now offline
[   44.422078] PM: Creating hibernation image:           //准备创建disk映像
[   44.503241] PM: Need to copy 330336 pages
[   44.503242] PM: Normal pages needed: 330336 + 1024, available pages: 1731140
                                                                                       //磁盘写入操作和时间没有记录
[   44.901845] PM: free pages cleared after restore    //S4已被唤醒，这里不是绝对时间，S4休眠时间未记入
[   44.901889] PM: Restoring platform NVS memory  
[   44.903440] Enabling non-boot CPUs ...
[   44.903474] x86: Booting SMP configuration:
[   44.903474] smpboot: Booting Node 0 Processor 1 APIC 0x2
[   44.904974]  cache: parent cpu1 should not be sleeping
[   44.905085] CPU1 is up
[   44.905101] smpboot: Booting Node 0 Processor 2 APIC 0x4
[   44.905478]  cache: parent cpu2 should not be sleeping
[   44.905602] CPU2 is up
[   44.905618] smpboot: Booting Node 0 Processor 3 APIC 0x6
[   44.905995]  cache: parent cpu3 should not be sleeping
[   44.906125] CPU3 is up
[   44.908816] ACPI: Waking up from system sleep state S4
[   45.003392] usb usb1: root hub lost power or was reset
[   45.003393] usb usb2: root hub lost power or was reset
[   45.006573] sd 0:0:0:0: [sda] Starting disk
[   45.006732] parport_pc 00:01: activated
[   45.008262] serial 00:02: activated
[   45.384656] ata1: SATA link up 3.0 Gbps (SStatus 123 SControl 300)
[   45.384717] ata2: SATA link down (SStatus 4 SControl 300)
[   45.384741] ata3: SATA link down (SStatus 4 SControl 300)
[   45.384758] ata6: SATA link down (SStatus 4 SControl 300)
[   45.384779] ata5: SATA link down (SStatus 4 SControl 300)
[   45.384798] ata4: SATA link down (SStatus 4 SControl 300)
[   45.387712] ata1.00: configured for UDMA/100
[   45.500662] usb 1-9: reset low-speed USB device number 2 using xhci_hcd
[   46.056539] usb 1-10: reset low-speed USB device number 3 using xhci_hcd
[   46.318112] nvme nvme0: 4/0/0 default/read/poll queues
[   46.336791] nvme nvme0: ctrl returned bogus length: 2 for NVME_NIDT_EUI64
[   46.363904] acpi LNXPOWER:07: Turning OFF
[   46.363916] acpi LNXPOWER:06: Turning OFF
[   46.364472] PM: Basic memory bitmaps freed
[   46.364474] OOM killer enabled.
[   46.364475] Restarting tasks ... done.   //恢复进程
[   47.098831] e1000e: eno1 NIC Link is Up 100 Mbps Full Duplex, Flow Control: None
[   47.098837] e1000e 0000:00:1f.6 eno1: 10/100 speed: disabling TSO
[   49.489104] video LNXVIDEO:00: Restoring backlight state
[   49.489109] PM: hibernation exit    //S4退出完成
</code></pre>
<p>比较奇怪的是，dmesg没记录写磁盘的操作,时间戳上也反映不出来。可能这时候IO交给DMA了，kernel就挂起了，所以dmesg无法工作，包括时间戳记录？？<br>为了验证S4 hang原因在于写磁盘，对不同SSD做读写测速：</p>
<pre><code>DISK               :         R/W speed MB/s   :       S4 hang time
Samsung SATA SSD   :         567/529          :       4s
Our SSD            :         170.1/104.7      :       25s
</code></pre>
<p>基本验证读写速度和S4 hang是线性关系。</p>
]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：判断语句if-then-else-fi</title>
    <url>/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>shell中if-then-else-fi判断语句如下：</p>
<pre><code>a=&quot;abc&quot;

if [ $a = &quot;abc&quot; ]
then
   echo &quot;$a = $b&quot;
else
   echo &quot;$a != $b&quot;
fi
</code></pre>
<p>注意以下几点：</p>
<ul>
<li>shell中的等号：<code>=</code>可用于赋值，也可以用于判断；<code>==</code>只用于判断，更规范</li>
<li>shell中的if语句各符号间都要空格分隔：<code>if</code>和<code>[ ]</code>之间要空格；<code>[ ]</code>和<code>“ ”</code>之间要空格； <code>&quot;</code>和<code>=</code>之间要空格。否则if语句中的符号会解析失败。</li>
<li>shell变量没有数据类型的区分，把任何存储在变量中的值，皆视为“字符串”</li>
<li>对于变量可能为空的情况，需要用双括号<code>[[ $a = &quot;abc&quot; ]]</code></li>
<li>if-then可以写在同一行，用;分隔两个语句：<code>if [ $a = &quot;abc&quot; ];then</code></li>
</ul>
<h1 id="不同类型的判断语句"><a href="#不同类型的判断语句" class="headerlink" title="不同类型的判断语句"></a>不同类型的判断语句</h1><h2 id="关系运算符判断"><a href="#关系运算符判断" class="headerlink" title="关系运算符判断"></a>关系运算符判断</h2><p>-eq	检测两个数是否相等，相等返回 true。	[ $a -eq $b ] 返回 false。</p>
<p>-ne	检测两个数是否不相等，不相等返回 true。	[ $a -ne $b ] 返回 true。</p>
<p>-gt	检测左边的数是否大于右边的，如果是，则返回 true。	[ $a -gt $b ] 返回 false。</p>
<p>-lt	检测左边的数是否小于右边的，如果是，则返回 true。	[ $a -lt $b ] 返回 true。</p>
<p>-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 返回 false。</p>
<p>-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 返回 true。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>
<h2 id="布尔和逻辑运算符判断"><a href="#布尔和逻辑运算符判断" class="headerlink" title="布尔和逻辑运算符判断"></a>布尔和逻辑运算符判断</h2><p>!	非运算，表达式为 true 则返回 false，否则返回 true。	[ ! false ] 返回 true。</p>
<p>-o	或运算，有一个表达式为 true 则返回 true。	[ $a -lt 20 -o $b -gt 100 ] 返回 true。</p>
<p>-a	与运算，两个表达式都为 true 才返回 true。	[ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a == $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>
<p>&amp;&amp;	逻辑的 AND	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</p>
<p>||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<pre><code>#!/bin/bash

a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>
<h2 id="字符串运算符判断"><a href="#字符串运算符判断" class="headerlink" title="字符串运算符判断"></a>字符串运算符判断</h2><p>&#x3D;	检测两个字符串是否相等，相等返回 true。	[ $a &#x3D; $b ] 返回 false。</p>
<p>!&#x3D;	检测两个字符串是否相等，不相等返回 true。	[ $a !&#x3D; $b ] 返回 true。</p>
<p>-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。  </p>
<p>-n	检测字符串长度是否不为 0，不为 0 返回 true。	[ -n “$a” ] 返回 true。</p>
<p><code>$</code> 检测字符串是否为空，不为空返回 true。	[ $a ] 返回 true。</p>
<pre><code>#!/bin/bash

a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a != $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a = $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n &quot;$a&quot; ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>
<h2 id="文件检查运算符判断"><a href="#文件检查运算符判断" class="headerlink" title="文件检查运算符判断"></a>文件检查运算符判断</h2><p>b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 返回 false。</p>
<p>-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 返回 false。</p>
<p>-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。</p>
<p>-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。</p>
<p>-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ] 返回 false。</p>
<p>-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 返回 false。</p>
<p>-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 返回 false。</p>
<p>-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 返回 false。</p>
<p>-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 返回 true。</p>
<p>-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 返回 true。</p>
<p>-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 返回 true。</p>
<p>-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 返回 true。</p>
<p>-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 返回 true。</p>
<p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。</p>
<pre><code>#!/bin/bash

file=&quot;/root/test.sh&quot;

if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>
<h1 id="判断语句报错：”unary-operator-expected”"><a href="#判断语句报错：”unary-operator-expected”" class="headerlink" title="判断语句报错：”unary operator expected”"></a>判断语句报错：”unary operator expected”</h1><p>在匹配字符串相等时，用了类似这样的语句：</p>
<pre><code>if [ $STATUS == &quot;OK&quot; ]; then     
echo &quot;OK&quot;
fi
</code></pre>
<p>在运行时出现了 <code>[: =: unary operator expected</code> 的错误</p>
<pre><code>if [[ $STATUS == &quot;OK&quot; ]]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>究其原因，是因为如果变量STATUS值为空，那么就成了 [ &#x3D; “OK”] ，显然 [ 和 “OK” 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。<br>或者用下面的方法也能避免这种错误：</p>
<pre><code>if [ &quot;$STATUS&quot;x == &quot;OK&quot;x ]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>当然，x也可以是其他字符。shell中有没有双引号在很多情况下是一致的,因此x可以不加引号。</p>
]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：实现芯片固件的批量编译</title>
    <url>/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某软件有不同的配置参数，实现不同功能版本的编译<br>批量测试需要批量编译各种版本，实现方式为：<br>1.将编译参数组合，生成大量配置文件<br>2.编译过程遍历这些配置文件，依次编译对应版本<br>3.有参数加入，修改，删除，只需要更新这些配置文件<br>如何实现这些配置文件的更新？</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某芯片的Firmware批量编译实现：<br>Firmware代码为C, 配置参数用宏实现，后缀为.def<br>目录结构如下</p>
<p>|–project_folder<br>　　|–config<br>　　　|–build.def<br>　　　|–defs<br>　　　　　|–1.def 2.def … n.def<br>　　|–src<br>　　|–Makefile<br>　　|–build_All.sh<br>　　|–update.sh</p>
<h2 id="批量编译脚本"><a href="#批量编译脚本" class="headerlink" title="批量编译脚本"></a>批量编译脚本</h2><p>批量编译脚本如下<br>基本过程：<br>1.依次拷贝def文件夹中的每个def，替换默认的build.def<br>2.编译，接受所有编译参数<br>3.拷贝编译输出的image到包含git tag, def名，时间等信息的文件夹</p>
<pre><code>#!/bin/bash

echo &quot;Batch build support args:&quot;
echo &quot;1. functin version:&quot;
echo &quot;verargs=mp_fpga&quot;
echo &quot;verargs=mpw_asic&quot;
echo &quot;2. boot debug:&quot;
echo &quot;bootargs=debug&quot;

OUTPUT=batch_build_$1$2

mkdir -p ${OUTPUT}
rm -rf ./batch_build_*

build_time=`date +%Y%m%d%H%M%S`

#commit_id=`git rev-parse HEAD`

tag_name=`git describe --exact-match --tags 2&gt;/dev/null`

if [ -z &quot;${tag_name}&quot; ]; then
	tag_name=&quot;NO_TAG&quot;
fi

mv ./config/build.def ./config/build.def.bak 

for file in `ls ./config/defs/*.def`;
do
	file_name=${file##*/}
	config_name=${file_name%.def}
	
	cp -rf ${file} ./config/build.def
	make clean
	make -j4 $@
	#mv ./build/image ./batch_build/${tag_name}_${config_name}_time_${build_time}_cid_${commit_id}
	mkdir -p ./${OUTPUT}/${tag_name}_${config_name}_time_${build_time}
	mv ./build/image/* ./${OUTPUT}/${tag_name}_${config_name}_time_${build_time}
done

mv ./config/build.def.bak ./config/build.def
</code></pre>
<p>def文件内的.def文件即各种参数配置文件，.def文件名即参数功能的别名组合<br>例如：</p>
<pre><code>CQ_emmc_two_card_enhance_hs400_always_l0_MSIx_dllphase14_tuning_on.def
</code></pre>
<p>对应的内容是：</p>
<pre><code>/*0: Non-CQ mode 1:CQ mode enable*/
#define BB_CQ_MODE_ENABLE 1
/*the card number support emmc#0:0 emmc#1:1 two card:2*/
#define BB_CARD_NUMBER 2
/*0:legacy 1:High Speed 50MHz 2:HS200 3:HS400 4:Enhance HS400*/
#define BB_MAX_TRANSFER_MODE 4
/* power mode management: 0: Low Power 1:Balance 2:High Performance 3:Direct HP 4:Always L0*/
#define POWER_MANAGEMENT_MODE 4
/* INT_MODE: 0:MSI_X 1:INTx 2:MSI_MULTIPLE 3:MSI_SINGLE */
#define INT_MODE 0
/* The selection of DLL PHASE COUNT is 11 or 14 */
#define DLL_phase_cnt 14
/* 0: fixed output phase  1: auto output tuning */
#define AUTO_OUTPUT_TUNING 1
</code></pre>
<h2 id="批量编辑配置文件"><a href="#批量编辑配置文件" class="headerlink" title="批量编辑配置文件"></a>批量编辑配置文件</h2><p>配置文件def有两个属性<br>1.文件名每个词代表一个功能，各词用下划线“_”分隔<br>2.内部用宏定义实现功能配置，宏定义的值要和外部文件名匹配</p>
<p>基于以上属性，编辑脚本需求为：<br>1.新增：增加一个宏定义，并增加对应的功能缩写到文件名<br>2.修改：修改一个已存在的宏定义，并修改对应的功能缩写到文件名<br>3.删除：删除一个已存在的宏定义，并删除对应的功能缩写到文件名<br>4.其他功能，如直接删除含某缩写的文件，备份原配置文件</p>
<p>shell实现为update.sh,如下:</p>
<pre><code>#!/bin/bash

DEFS_PATH=&quot;./config/defs&quot;
DEFS_BACKUP_PATH=&quot;./config/defs_backup&quot;
DEFS_TEMP_PATH=&quot;./config/defs_temp&quot;

if [ $# -lt 1 ];then
		echo &quot;usage: ./update.sh [option] [args]&quot;

		echo &quot;example 0:&quot;
		echo &quot;		backup defs files:&quot;
		echo &quot;		./update.sh -bf&quot;
		echo &quot;&quot;

		echo &quot;example 1:&quot;
		echo &quot;		add a macro name and macro value to defs, and add file postfix:&quot;
		echo &quot;		./update.sh -b&quot;
		echo &quot;		./update.sh -a balance POWER_MANAGEMENT_MODE 1 &quot;
		echo &quot;		./update.sh -a high_performance POWER_MANAGEMENT_MODE 2 &quot;
		echo &quot;		add other values...&quot;
		echo &quot;&quot;

		echo &quot;example 2:&quot;
		echo &quot;		update a macro name and macro value to defs, and update file postfix:&quot;
		echo &quot;		./update.sh -u balance lowpower POWER_MANAGEMENT_MODE 1 &quot;
		echo &quot;&quot;

		echo &quot;example 3:&quot;
		echo &quot;		delete a macro name and macro value of defs, and delete file postfix:&quot;
		echo &quot;		./update.sh -d lowpower POWER_MANAGEMENT_MODE&quot;
		echo &quot;&quot;

		echo &quot;example 4:&quot;
		echo &quot;		delete target files:&quot;
		echo &quot;		./update.sh -df lowpower&quot;
		echo &quot;&quot;

		echo &quot;example 5:&quot;
		echo &quot;		clean backup defs files:&quot;
		echo &quot;		./update.sh -cf&quot;
		echo &quot;&quot;

		exit;
	fi

if [ $1 = &quot;-bf&quot; ];then #backup defs
	mkdir -p $DEFS_BACKUP_PATH
	mv $DEFS_PATH/*.def $DEFS_BACKUP_PATH

elif [ $1 = &quot;-cf&quot; ];then #clear backup defs
	rm -rf $DEFS_BACKUP_PATH
</code></pre>
<p>​<br>​    #add a macro name and macro value to defs, and add file postfix<br>​    elif [ $1 &#x3D; “-a” ];then<br>​<br>​    	if [ $# !&#x3D; 4 ];then<br>​    		echo “usage: .&#x2F;update.sh -a FILE_POSTFIX MACRO_NAME MACRO_VALUE”<br>​    		exit;<br>​    	fi<br>​<br>    	mkdir -p $DEFS_TEMP_PATH &amp;&amp; cp -rf $DEFS_BACKUP_PATH&#x2F;<em>.def $DEFS_TEMP_PATH<br>    	<br>    	FILE_POSTFIX&#x3D;$2<br>    	MACRO_NAME&#x3D;$3<br>    	MACRO_VALUE&#x3D;$4<br>    	# sed -i makes change on original file, otherwise on stream<br>    	# xargs transfer multiple output from stream to multiple args to sed<br>    	find ${DEFS_TEMP_PATH} -name ‘</em>.def’ | xargs sed -i ‘$a#define\ ‘“$MACRO_NAME”‘\ ‘“$MACRO_VALUE”‘’<br>    	<br>    	for file in <code>ls ${DEFS_TEMP_PATH}/*.def</code><br>    	do<br>    	 mv $file <code>echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;</code><br>    	done<br>    	<br>    	cp -rf $DEFS_TEMP_PATH&#x2F;*.def $DEFS_PATH<br>    	rm -rf $DEFS_TEMP_PATH</p>
<pre><code>#update a macro name and macro value to defs, and update file postfix
elif [ $1 = &quot;-u&quot; ];then

	if [ $# != 5 ];then
		echo &quot;usage: ./update.sh -u ORIGIN_POSTFIX UPDATED_POSTFIX MACRO_NAME MACRO_UPDATED_VALUE&quot;
		exit;
	fi

	ORIGIN_POSTFIX=$2
	UPDATED_POSTFIX=$3
	MACRO_NAME=$4
	MACRO_UPDATED_VALUE=$5

	#replace all lines that pattern matches $MACRO_NAME
	find ${DEFS_PATH} -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
	#update file postfix
	for file in `ls ${DEFS_PATH}/*$ORIGIN_POSTFIX*.def`
	do
	 	mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
	done
</code></pre>
<p>​<br>​    #delete a macro name and macro value of defs, and delete file postfix<br>​    elif [ $1 &#x3D; “-d” ];then<br>​    	<br>​    	if [ $# !&#x3D; 3 ];then<br>​    		echo “usage: .&#x2F;update.sh -d DELETE_POSTFIX MACRO_NAME”<br>​    		exit;<br>​    	fi<br>​<br>    	DELETE_POSTFIX&#x3D;$2<br>    	MACRO_NAME&#x3D;$3<br>    	#delete all lines that contain $MACRO_NAME<br>    	find ${DEFS_PATH} -name ‘*.def’ | grep $DELETE_POSTFIX | xargs sed -i ‘&#x2F;‘“$MACRO_NAME”‘&#x2F;d’<br>    	#delete file postfix<br>    	for file in <code>ls ${DEFS_PATH}/*.def</code><br>    	do<br>    	 	mv $file <code>echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;</code><br>    	done</p>
<pre><code>#delete target file by postfix
elif [ $1 = &quot;-df&quot; ];then
	
	if [ $# != 2 ];then
		echo &quot;usage: ./update.sh -df DELETE_POSTFIX&quot;
		exit;
	fi

	DELETE_POSTFIX=$2
	rm -f ${DEFS_PATH}/*$DELETE_POSTFIX*.def

fi
</code></pre>
<p><strong>重点讲下其中的几个sed和文件操作</strong><br>1.多个文件，每个文件最后一行追加内容</p>
<pre><code>find ${DEFS_TEMP_PATH} -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
</code></pre>
<ul>
<li>xargs的作用： find <path> -name <string> 输出的是多个文件名，不能直接传给sed， <strong>xargs将多个文件名转化成多个参数</strong>，每个参数是一个文件名，sed可以接收</li>
<li>-i的作用：sed本身是在文件的拷贝上操作，不直接在文件本身修改，-i（insert）使sed的操作在文件上生效，<strong>如果不加-i，源文件不会被修改</strong></li>
<li>$：表示最后一行，sed ‘a\string’是基础格式</li>
<li>注意sed怎么用带空格和变量的字符串：<strong>空格用转义’\ ‘表示，变量是单引号内加双引号</strong>，即’”$ARG”‘</li>
</ul>
<p>2.找到包含字符串A的所有文件，替换内容：将字符串B替换为C</p>
<pre><code>#replace all lines that pattern matches $MACRO_NAME
find ${DEFS_PATH} -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
</code></pre>
<ul>
<li>find | grep 是常用套路，先找在过滤，注意find -name 可以使用*， grep不要用*，否则grep会把它当成要匹配的字符</li>
<li>sed ‘s&#x2F;stringB&#x2F;stringC’是基础格式，g表示全局，注意要-i</li>
</ul>
<p>3.找到包含字符串A的所有文件，删除内容：包含字符串B的行</p>
<pre><code>#delete all lines that contain $MACRO_NAME
find ${DEFS_PATH} -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
</code></pre>
<p>4.对多个文件的文件名，增加，修改，删除特定字符串</p>
<pre><code>#在原文件名最后，后缀之前，增加字符串“_$FILE_POSTFIX”
for file in `ls ${DEFS_TEMP_PATH}/*.def`
	do
	 mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
	done

#替换文件名中匹配的字符
for file in `ls ${DEFS_PATH}/*$ORIGIN_POSTFIX*.def`
do
 	mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
done

#删除文件名指定字符
for file in `ls ${DEFS_PATH}/*.def`
do
 	mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
done
</code></pre>
<ul>
<li>for &lt; args &gt; in `ls &lt; path &gt;`是把多个文件名依次写入变量args的常用操作，类似于xargs，不过是用循环每次处理一个文件名变量</li>
<li>mv $file `echo $file | sed ‘s&#x2F;stringA&#x2F;stringB&#x2F;g’&#96;实际是两个步骤：先用echo把当前处理的文件名传给sed, sed处理完的输出文件名，作为mv的目标文件名，覆盖了原文件</li>
<li>注意，文件名xargs传给sed,处理的是文件内容，for-in-do一个个mv，才是处理文件名本身</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://linux.cn/article-11367-1.html">使用 sed 命令查找和替换文件中的字符串的 16 个示例</a><br><a href="https://blog.csdn.net/weixin_40572607/article/details/90812959">sed引入变量的几种方法</a><br><a href="https://blog.csdn.net/elong490/article/details/52587171">sed 批量替换文件内容</a></p>
]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell笔记：文本编辑利器sed+awk+grep</title>
    <url>/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/</url>
    <content><![CDATA[<h1 id="shell增删改查概述"><a href="#shell增删改查概述" class="headerlink" title="shell增删改查概述"></a>shell增删改查概述</h1><p>Linux Shell环境对文本增删改查，可以通过sed，awk和grep命令完成。</p>
<ul>
<li>sed: 支持特定模式匹配的增加、插入、删除、替换、提取等操作</li>
<li>awk: 支持特定模式匹配的过滤查找，如提取某行列的字符串</li>
<li>grep: 支持包含特定字符串的结果提取，可配合find和awk实现过滤查找</li>
</ul>
<p>这几种命令都支持流输入和文本输入，支持管道传递参数，也可以命令行传参。对于多个步骤的处理，可以几个命令串行使用。</p>
<h1 id="shell的输入参数概述"><a href="#shell的输入参数概述" class="headerlink" title="shell的输入参数概述"></a>shell的输入参数概述</h1><p>Shell的命令，如<code>cat, echo, sed, awk, grep</code>, 管道命令<code>|</code>等，都要有输入参数，即待处理的数据。<br>输入参数有两种类型：</p>
<ul>
<li>标准输入：本质是stdin文件，即读取该文件的内容作为命令的输入参数，该文件内容可由其他命令的输出，或者用户输入来产生</li>
<li>命令行输入：直接接受用户在命令行输入的字符串，一次性使用,不存储在stdin</li>
</ul>
<p>支持标准输入作为参数的命令：<code>cat, sed, awk, grep, |</code> 等<br>只支持命令行输入字符串的命令：<code>echo, ls</code>等<br>标准输入示例：</p>
<pre><code>cat /etc/passwd | grep root
</code></pre>
<p>上面的代码使用了管道命令<code>|</code>，管道命令的作用是将左侧命令<code>cat /etc/passwd</code>的标准输出转换为标准输入，提供给右侧命令<code>grep root</code>作为参数。<br>以上命令也可以写成命令行输入形式：</p>
<pre><code>grep root /etc/passwd
</code></pre>
<p>不支持标准输入的示例：</p>
<pre><code>echo &quot;hello world&quot; | echo
</code></pre>
<p>输出为空，管道右侧的echo不接受管道传来的标准输入作为参数。<br>xargs的作用：将标准输入转为命令行参数</p>
<pre><code>echo &quot;hello world&quot; | xargs echo
</code></pre>
<p>输出“hello world”，xargs和管道配合使用，能使管道也支持非标准输入命令。<br>xargs支持一些选项做进一步细化处理，如-p(打印), -d(分割) 等。</p>
<h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><h2 id="sed命令概述"><a href="#sed命令概述" class="headerlink" title="sed命令概述"></a>sed命令概述</h2><p>sed支持文本编辑，实现增、删、改的功能。<br>sed命令格式：</p>
<pre><code>sed [options] &#39;command&#39; filename
</code></pre>
<p>sed的输入参数可以用命令行，管道和xargs传入：</p>
<pre><code>//命令行传入文件名参数
sed [options] &#39;command&#39; filename 
//管道传入文件名参数
cat filename | sed [options] &#39;command&#39;
//xargs传入文件名参数
cat filename | xargs sed [options] &#39;command&#39;
</code></pre>
<p>sed对文件的编辑在缓冲区，不直接修改文本。要直接修改文本有以下方法：</p>
<ul>
<li>重定向覆盖文本， <code>sed - x &#39;XXX&#39; file.txt &gt; file.txt</code></li>
<li>特定的sed命令支持直接修改文本，如<code>sed -i &#39;XXX&#39; file.txt</code></li>
</ul>
<p>sed的常用选项：</p>
<pre><code>-n ：关闭默认输出,只显示匹配的行
-i ：直接修改读取的文件内容，而不是输出到终端。
-e ：直接在命令列模式上进行sed的动作编辑；
-f ：直接将sed的动作写在一个文件内，-f filename 则可以运行filename内的sed动作；
-r ：启用扩展的正则表达式
</code></pre>
<p>sed的常用命令：</p>
<pre><code>a ：新增行，在指定行的后面附加一行，[address]a\新文本内容
i ：插入行，在指定行的前面插入一行，[address]i\新文本内容
s ：替换特定模式匹配的字符串, [address]s/pattern/replacement/flags
c ：将指定行中的所有内容，替换成该选项后面的字符串, [address]c\用于替换的新文本
d ：删除行，[address]d
p ：打印， 通常与参数 -n 一起用，[address]p
w : 将文本中指定行的内容写入文件, [address]w filename
</code></pre>
<h2 id="sed命令详解"><a href="#sed命令详解" class="headerlink" title="sed命令详解"></a>sed命令详解</h2><p>本节从sed文本操作的“增删改查”举例说明其具体命令用法</p>
<h3 id="新增和插入：a和i"><a href="#新增和插入：a和i" class="headerlink" title="新增和插入：a和i"></a>新增和插入：a和i</h3><p>sed的命令a和i都能实现新增行，其区别在于：</p>
<ul>
<li>a ：append, 指定行后面新增一行</li>
<li>i : insert, 表示在指定行前面插入一行</li>
</ul>
<p>注意区分i命令和i选项<br>a和i命令的基本格式完全相同：</p>
<pre><code>[address]a（或 i）\新文本内容
</code></pre>
<p>将一个新行插入到数据流第三行前：</p>
<pre><code>sed &#39;3i\This is an inserted line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is an inserted line.
This is line number 3.
This is line number 4.
</code></pre>
<p>将一个新行附加到数据流中第三行后:</p>
<pre><code>sed &#39;3a\This is an appended line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is line number 3.
This is an appended line.
This is line number 4.
</code></pre>
<p>将一个多行数据添加到数据流中，只需对要行末尾添加反斜线即可，类似C语言的代码换行</p>
<pre><code>sed &#39;1i\
This is one line of new text.\
This is another line of new text.&#39; data6.txt

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
</code></pre>
<h3 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h3><ul>
<li>d: delete, 删除行</li>
</ul>
<p>格式：</p>
<pre><code>[address]d
</code></pre>
<p>删除第三行：</p>
<pre><code>[root@localhost ~]# cat data6.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
[root@localhost ~]# sed &#39;3d&#39; data6.txt
This is line number 1.
This is line number 2.
This is line number 4.
</code></pre>
<p>删除二、三行：</p>
<pre><code>sed &#39;2,3d&#39; data6.txt
This is line number 1.
This is line number 4.
</code></pre>
<p>删除第三行开始的后续所有行：</p>
<pre><code>[root@localhost ~]# sed &#39;3,$d&#39; data6.txt
This is line number 1.
This is line number 2.
</code></pre>
<p>注意：sed d 命令并不会修改原始文件，这里被删除的行只是从 sed 的缓冲区中消失了，原始文件没做任何改变，若要修改源文件，可重定向sed的输出到源文件，覆盖原内容使修改生效。</p>
<h3 id="匹配定位：-pattern"><a href="#匹配定位：-pattern" class="headerlink" title="匹配定位：&#x2F;pattern&#x2F;"></a>匹配定位：&#x2F;pattern&#x2F;</h3><p>sed的增删操作，可以针对包含匹配字符串的行进行操作，其原理是活用[address], 支持匹配字符串的定位，以插入命令’i’为例，匹配格式如下：</p>
<pre><code>sed [option] &#39;/匹配字符串/i \插入字符串&#39;
[option] 通常为 -i, 修改直接在源文件生效
</code></pre>
<p>原文件：</p>
<pre><code>cat testfile 
hello
</code></pre>
<p>在包含”hello”的一行的上一行，插入”upline”:</p>
<pre><code>sed -i &#39;/hello/i\upline&#39; testfile
</code></pre>
<p>“hello”下一行插入”upline”:</p>
<pre><code>sed -i &#39;/hello/a\down&#39; testfile
</code></pre>
<p>修改后的文件：</p>
<pre><code>cat testfile 
up
hello
down
</code></pre>
<p>删除匹配到”hello”的行：</p>
<pre><code>sed -i &#39;/hello/d&#39; testfile
</code></pre>
<p>如果匹配字符串有“&#x2F;”，为了和sed命令的分隔符“&#x2F;”，使用“\”转义。<br>例如删除匹配某个路径字符串的行：</p>
<pre><code>匹配&quot;\etc\install.sh&quot;
set -i &#39;/\/etc\/install.sh/d&#39; test.txt
</code></pre>
<p>sed 命令包含一些预定义特殊符号，代表行尾，行首等。<br>删除以A开头的行：</p>
<pre><code>sed -i &#39;/^A.*/d&#39; test.txt
^A表示开头是A, .*表示后跟任意字符串
</code></pre>
<p>在行尾追加一行内容:</p>
<pre><code>sed -i &#39;$a\added-content&#39; test.txt
$表示定位到行尾，a是追加命令，added-content是追加内容
</code></pre>
<h3 id="替换修改-s"><a href="#替换修改-s" class="headerlink" title="替换修改: s"></a>替换修改: s</h3><p>s替换命令内部格式为：</p>
<pre><code>[address]s/pattern/replacement/flags
</code></pre>
<ul>
<li>address 指定要操作的具体行</li>
<li>pattern 指定需要替换的内容</li>
<li>replacement 指定替换的新内容</li>
<li>flags 指定特殊功能</li>
</ul>
<p>常用的flags:</p>
<ul>
<li>n	1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换</li>
<li>g	对数据中所有匹配到的内容进行替换，否则只会在第一次匹配成功时做替换操作</li>
<li>p	会打印与替换命令中指定的模式匹配的行。此标记通常与 -n    选项一起使用</li>
<li>\	转义（转义替换部分包含：&amp;、\ 等）。</li>
</ul>
<p>替换每行第二个匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/2&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the trial script
This is second test of the trial script
</code></pre>
<p>只替换第二行的匹配字符串：</p>
<pre><code>sed &#39;2s/test/trial/&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the test script
This is second test of the trial script
</code></pre>
<p>全局替换所有匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/g&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first trial of the trial script
This is second trial of the trial script
</code></pre>
<h3 id="提取：p"><a href="#提取：p" class="headerlink" title="提取：p"></a>提取：p</h3><p>sed p命令配合字符串匹配，可以输出包含指定字符串的行内容。</p>
<pre><code>sed -n &#39;/string/p&#39; filename
提取filename文件中,所有包含string的行的内容，并打印到标准输出
-n是只打印匹配命中的内容
</code></pre>
<p>sed p和grep都能提取内容，其区别在于：</p>
<ul>
<li><code>sed &#39;/string/p&#39;</code>是提取指定文件的行内容，重点在内容提取</li>
<li><code>grep &quot;string&quot; path</code>是输出包含指定内容的所有文件路径，重点在查找文件位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452182.png" alt="image-20221205145238133"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452191.png" alt="image-20221205145248149"></p>
<h2 id="sed进阶与实战"><a href="#sed进阶与实战" class="headerlink" title="sed进阶与实战"></a>sed进阶与实战</h2><h3 id="多文件批量追加和删除"><a href="#多文件批量追加和删除" class="headerlink" title="多文件批量追加和删除"></a>多文件批量追加和删除</h3><p>背景介绍：<br>底层固件代码有一些功能由宏定义控制，不同功能需要不同的宏定义组合，因此有不同的宏定义文件，命名为.def后缀。批量编译不同版本，编译脚本依次提取def文件夹内的.def文件和源代码一起编译。单个def内容如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453765.png" alt="image-20221205145321718"></p>
<p>每一个宏都有多个取值，因此组合起来，需要生成一堆.def文件，批量编译才能覆盖各自功能。<br>每新增一个宏，都要修改所有.def文件，如果这个宏有两个取值，.def文件数量将翻倍。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453942.png" alt="image-20221205145327892"></p>
<p>人工修改过于低效，使用sed可解决此问题。</p>
<p>查找指定文件，并批量追加一行内容：</p>
<pre><code>find . -name &#39;*.def*&#39; | xargs sed -i &#39;$a\added-content&#39;
</code></pre>
<p>各命令含义：</p>
<pre><code>find [path] -name &quot;*.def&quot;
查找path路径下，以.def结尾的所有文件，结果存储在stdout
|
管道，将查找结果转存到标准输入stdin
xargs
查找结果有很多个，用xargs转成命令行输入，sed才能批量处理
sed -i &#39;$a\added-content&#39;
    -i 直接修改文件，&#39;$a\added-content&#39; 最后一行追加added-content
</code></pre>
<p>查找指定文件，并批量删除匹配某字符串的行：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/deleteString/d&quot;
</code></pre>
<p>查找指定文件，并批量替换匹配某字符串：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/oldString/newString/&quot;
</code></pre>
<p>在实际shell脚本中，通常由用户输入变量，<code>$1, $2, $@</code> 解析变量。a、i、d和s能否在命令中使用双引号解析变量，实现动态编辑？<br>实验如下：</p>
<pre><code>ARGS=&quot;AA BB&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$a\${ARGS}&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$i\${ARGS}&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/${ARGS}/d&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/aabb/$ARGS/&quot;
</code></pre>
<ul>
<li>i 和 a 命令不能解析变量，实际追加的就是是${ARGS}</li>
<li>d命令可以解析变量，实际删除的是有”AA BB”的行</li>
<li>s命令可以解析变量，实际替换后的结果是”AA BB”</li>
</ul>
<p>结论：将命令中的单引号改成双引号，理论上可以解析$包含的变量，实际上有的命令支持，有的命令不支持。</p>
<h3 id="提取文件中的关键内容"><a href="#提取文件中的关键内容" class="headerlink" title="提取文件中的关键内容"></a>提取文件中的关键内容</h3><p>背景介绍：<br>底层固件需要将代码段、数据段等关键信息存储在固件头部，编译过程中用编译器的size命令可以获取这些信息，并存储到文本，但是固件头部需要按自己的格式存储起始地址和大小信息，因此需要用sed提取并编辑该文本。</p>
<p>原文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453983.png" alt="image-20221205145348933"></p>
<p>提取后文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453414.png"></p>
<p>sed命令：</p>
<pre><code>sed -n &#39;/string/p&#39; oldFile | awk &#39;{print $3}&#39; &gt;&gt; newFile
提取oldFile内包含string的行，并用awk提取第三列，再写入newFile
</code></pre>
<p>该命令在Makefile实现，需要根据Makefile和shell特性做修改：</p>
<ul>
<li>@：编译过程隐藏命令输出，类似于后台执行</li>
<li>$(shell xxxx): Makefile执行shell命令</li>
<li>$$: Makefile不能直接用shell的“$”解析变量，用“$$”</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051454928.png" alt="image-20221205145409877"></p>
]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC笔记：多线程磁盘读写测试工具</title>
    <url>/2021/03/18/MFC%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MFC（Microsoft Foundation Classes）是微软在win32 API上，用C++封装的GUI框架，在现在，MFC相比其他的GUI框架有些过时，可以参考：<br><a href="https://www.zhihu.com/question/327876401">很多人说 C++ 的 MFC 已经过时了，那新入门的人到底应该学什么？</a><br>不同环境的选择：</p>
<ul>
<li>跨平台： QT</li>
<li>C#: WPF</li>
<li>Web：React，Vue，Electron</li>
</ul>
<p>既然如此，为何本文用MFC？<br>1.部分功能从老MFC项目移植，且VS环境能快速上手<br>2.技术本身不会过时，过时的是应用场景，GUI回调式的交互机制，以及Win32线程和进程的使用都是通用的技术。这是写本文的原因</p>
<p>本文源码：<a href="https://github.com/cursorhu/myMFCForAutoRWTest.git">cursorhu&#x2F;myMFCForAutoRWTest</a></p>
<p>GUI界面：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051510224.png" alt="1"></p>
<h1 id="初识MFC项目"><a href="#初识MFC项目" class="headerlink" title="初识MFC项目"></a>初识MFC项目</h1><p>VS新建MFC项目，例如“myMFC”，目录结构如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514738.png" alt="2"><br>myMFC.cpp是VS自动创建的MFC项目入口，其主要功能是：创建一个窗口实例，注册会话对象（Dialog)<br>界面的交互一定是分层的</p>
<ul>
<li>对用户的是控件层，即各种按钮，输入输出框等可见可操作的东西</li>
<li>处理数据的是逻辑层，例如从输入框输入，底层保存该字符串，点击运行，底层开始执行对应函数</li>
</ul>
<p>在MFC中，会话对象就是处理底层逻辑的类对象，其方法定义在myMFCDlg.cpp<br>也是开发的主要内容</p>
<h2 id="MFC入口"><a href="#MFC入口" class="headerlink" title="MFC入口"></a>MFC入口</h2><p>下面介绍myMFC.cpp的MFC入口：</p>
<pre><code>BOOL CmyMFCApp::InitInstance()
&#123;
	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// 将它设置为包括所有要在应用程序中使用的
	// 公共控件类。
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&amp;InitCtrls);

	CWinApp::InitInstance();
	
	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	CShellManager *pShellManager = new CShellManager;

	// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;));

	CmyMFCDlg dlg;
	m_pMainWnd = &amp;dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	&#123;
		// TODO: 在此放置处理何时用
		//  “确定”来关闭对话框的代码
	&#125;
	else if (nResponse == IDCANCEL)
	&#123;
		// TODO: 在此放置处理何时用
		//  “取消”来关闭对话框的代码
	&#125;
	else if (nResponse == -1)
	&#123;
		TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;);
		TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;);
	&#125;

	// 删除上面创建的 shell 管理器。
	if (pShellManager != nullptr)
	&#123;
		delete pShellManager;
	&#125;

#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)
	ControlBarCleanUp();
#endif

	return FALSE;
&#125;
</code></pre>
<p>只需要关注这几句</p>
<pre><code>CmyMFCDlg dlg;
m_pMainWnd = &amp;dlg;
INT_PTR nResponse = dlg.DoModal();
</code></pre>
<p>CmyMFCDlg类是在myMFCDlg.cpp定义的，即底层逻辑类。m_pMainWnd是myMFC.cpp的CmyMFCApp类(继承win32 API)的成员，表示主窗口，这两句就是把会话对象注册到窗口类，这样窗口运行时可以回调会话对象的方法。dlg.DoModal()是运行会话窗口，运行哪个会话？其调用者CmyMFCDlg类对象dlg。</p>
<h2 id="MFC逻辑层"><a href="#MFC逻辑层" class="headerlink" title="MFC逻辑层"></a>MFC逻辑层</h2><p>VS自动创建myMFC项目的会话逻辑层，myMFCDlg.cpp<br>几个自动生成的方法如下，这里为了作为示例，加了自定义的类成员m_src, m_dst和方法OnBnClickedButtonsrc，OnBnClickedButtondst<br>(1)会话类构造函数</p>
<pre><code>CmyMFCDlg::CmyMFCDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_MYMFC_DIALOG, pParent)
	, m_src(_T(&quot;&quot;)) //初始化为空串，_T是兼容不同编码的转换
    , m_dst(_T(&quot;&quot;))
&#123;
	m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
&#125;
</code></pre>
<p>(2)界面和类成员数据关联</p>
<pre><code>void CmyMFCDlg::DoDataExchange(CDataExchange* pDX)
&#123;
	CDialogEx::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT_src, m_src); //关联m_src和IDC_EDIT_src控件，该控件是界面输入框
	DDX_Text(pDX, IDC_EDIT_dst, m_dst);
&#125;
</code></pre>
<p>(3)界面和类方法的关联</p>
<pre><code>BEGIN_MESSAGE_MAP(CmyMFCDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON_src, &amp;CmyMFCDlg::OnBnClickedButtonsrc) //关联IDC_BUTTON_src按钮和OnBnClickedButtonsrc方法
	ON_BN_CLICKED(IDC_BUTTON_dst, &amp;CmyMFCDlg::OnBnClickedButtondst)
END_MESSAGE_MAP()
</code></pre>
<p>类在头文件的定义：</p>
<pre><code>class CmyMFCDlg : public CDialogEx
&#123;
// 构造
public:
	CmyMFCDlg(CWnd* pParent = nullptr);	// 标准构造函数

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum &#123; IDD = IDD_MYMFC_DIALOG &#125;;
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持

// 实现
protected:
	HICON m_hIcon;

	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
	
public:
	CString m_src; //CString: MFC的字符串类型
	CString m_dst;
	afx_msg void OnBnClickedButtonsrc(); //afx_msg: MFC的方法对应的消息响应类型
	afx_msg void OnBnClickedButtondst();
&#125;;
</code></pre>
<p>在VS环境下,这些变量和方法的定义都不需要写代码，在控件资源视图直接配置即可。</p>
<h2 id="界面资源层"><a href="#界面资源层" class="headerlink" title="界面资源层"></a>界面资源层</h2><p>注意项目文件有个Resource.h，包含界面相关的资源，如每个按钮有个ID，这个不要手动配置，在编辑UI控件时自动生成</p>
<pre><code>//&#123;&#123;NO_DEPENDENCIES&#125;&#125;
// Microsoft Visual C++ 生成的包含文件。
// 供 myMFC.rc 使用
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MYMFC_DIALOG                102
#define IDR_MAINFRAME                   128
#define IDC_BUTTON_src                  1000
#define IDC_BUTTON_dst                  1001
</code></pre>
<p>myMFC.rc是UI的资源文件，打开就是UI界面<br><img src="C:\Users\thomas.hu\Desktop\3.png" alt="3"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514703.png" alt="4"><br>可以看到界面的按钮，右键查看属性，可以修改标题和控件ID，会映射到Resource.h。双击按钮，myMFCDlg.cpp会自动创建方法<code>CmyMFCDlg::OnBnClickedButtondst()</code>，头文件自动加方法声明。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514147.png" alt="5"></p>
<p>前文的Dlg.cpp中的控件ID, dlg类的方法，变量，从一开始就可以从资源界面配置，自动生成：</p>
<ul>
<li>在资源界面选按钮或其他控件</li>
<li>右键配置控件ID</li>
<li>右键添加值变量或控件变量</li>
<li>双击添加方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515208.png" alt="6"><br>关于值变量和控件变量：<br>值变量用于关联界面和类成员，值变量就是类成员名，例如点击dst按钮调用其方法后，获得的路径，会写入m_dst值变量<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051512803.png" alt="7"><br>控件变量代表控件本身，用于底层逻辑中，直接调用控件的方法，例如控件变量叫dst_ctrl，可以在某个方法中<code>ctrl_dst.SetWindowText(_T(&quot;&quot;))</code>清空界面的字符串<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051512701.png" alt="8"></p>
<h1 id="简单拷贝校验的实现"><a href="#简单拷贝校验的实现" class="headerlink" title="简单拷贝校验的实现"></a>简单拷贝校验的实现</h1><p>实现从src目录拷贝所有文件到dst目录，并比较拷贝前后的文件是否一致</p>
<h2 id="获取文件路径"><a href="#获取文件路径" class="headerlink" title="获取文件路径"></a>获取文件路径</h2><p>两个路径选择按钮和对应的编辑框显示路径，一个Start按钮<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051513686.png" alt="9"></p>
<p>button src的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonsrc()
&#123;
	CString SrcPath;
	SrcPath = GetFolderPath(); //获取文件夹路径
	ctrl_src.SetWindowText(SrcPath); //显示获取的路径字符串
	m_src = SrcPath; //保存路径到会话对象的变量
&#125;
</code></pre>
<p>GetFolderPath打开一个目录框，让用户选择：<br>SHBrowseForFolder是win32 API，专用于打开目录</p>
<pre><code>CString CmyMFCDlg::GetFolderPath(void)
&#123;
	CString strPath;
	BROWSEINFO bInfo;
	ZeroMemory(&amp;bInfo, sizeof(bInfo));
	bInfo.hwndOwner = m_hWnd;
	bInfo.lpszTitle = _T(&quot;Select Folder: &quot;);
	bInfo.ulFlags = BIF_RETURNONLYFSDIRS;

	LPITEMIDLIST lpDlist;					
	lpDlist = SHBrowseForFolder(&amp;bInfo); //win32 API, 打开目录	
	if (lpDlist != NULL)						
	&#123;
		TCHAR chPath[255];					
		SHGetPathFromIDList(lpDlist, chPath);
		strPath = chPath;					
	&#125;
	return strPath;
&#125;
</code></pre>
<p>如果是打开文件，用CFileDialog</p>
<pre><code>CString CmyMFCDlg::GetFilePath(void)
&#123;
	CFileDialog mFileDlg(TRUE, NULL, NULL,
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_NOCHANGEDIR,
		_T(&quot;All Files(*.*)|*.*||&quot;), AfxGetMainWnd());
	CString str(&quot; &quot;, 10000);
	mFileDlg.m_ofn.lpstrFile = str.GetBuffer(10000);
	mFileDlg.m_ofn.lpstrTitle = _T(&quot;Select File&quot;);
	str.ReleaseBuffer();
	mFileDlg.DoModal();
	POSITION mPos = mFileDlg.GetStartPosition();
	CFileStatus status;
	CString strPath;
	while (mPos != NULL)
	&#123;
		strPath = mFileDlg.GetNextPathName(mPos);
		CFile::GetStatus(strPath, status);
	&#125;
	return strPath;
&#125;
</code></pre>
<p>不管哪一种，效果如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515196.png" alt="10"><br>选择完后，路径会在编辑框显示，这就是控件语句<code>ctrl_src.SetWindowText(SrcPath)</code>的效果<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515342.png" alt="11"></p>
<h2 id="拷贝和比较"><a href="#拷贝和比较" class="headerlink" title="拷贝和比较"></a>拷贝和比较</h2><p>拷贝函数如下，只需关注几个函数：</p>
<ul>
<li>CFileFind类的CFileFind(), FindNextFile(), GetFilePath(), GetFilePath()，这些都是afx.h定义，属于MFC库的类</li>
<li>CopyFile()， 执行拷贝，这个也是继承自MFC类</li>
</ul>
<p>代码：</p>
<pre><code>BOOL CmyMFCDlg::ModeTestCopyFileFromSRCtoDST(CString SRC, CString DST, CString&amp; StrResult)
&#123;

	CFileFind ff, ff_DST;
	CString SRCDir = SRC;                 //source folder path
	CString DSTDir = DST;
	UINT copyFileResult = 0;
	int i = 0;

	BOOL bmakedir = MakeDirectory(DSTDir);

	if (SRCDir.Right(1) != _T(&quot;\\&quot;))
		SRCDir += _T(&quot;\\&quot;);
	SRCDir += _T(&quot;*.*&quot;);

	if (DSTDir.Right(1) != _T(&quot;\\&quot;))
		DSTDir += _T(&quot;\\&quot;);
</code></pre>
<p>​<br>​    	SetLastError(0);<br>​    	CString DST_tmp &#x3D; DSTDir + _T(“<em>.</em>“);<br>​    	BOOL res_DST &#x3D; ff_DST.FindFile(DST_tmp);<br>​    	if (res_DST &#x3D;&#x3D; 0)<br>​    	{<br>​    		StrResult.Format(_T(“Access DST folder error, error code is %d. “), GetLastError());<br>​    	}<br>​    	BOOL res &#x3D; ff.FindFile(SRCDir);<br>​<br>​    	while (res)<br>​    	{<br>​    		res &#x3D; ff.FindNextFile();<br>​    		if (!ff.IsDirectory() &amp;&amp; !ff.IsDots())<br>​    		{<br>​    			CString DSTFildPath;<br>​    			CString SRCFilePath &#x3D; ff.GetFilePath();<br>​    			DSTFildPath &#x3D; DSTDir + ff.GetFileName();<br>​    			copyFileResult &#x3D; CopyFile(ff.GetFilePath(), DSTFildPath, FALSE);<br>​<br>​    			Sleep(2000);<br>​<br>    			if (copyFileResult &#x3D;&#x3D; 0)<br>    			{<br>    				DWORD ErrCode &#x3D; GetLastError();<br>    				StrResult.Format(_T(“CopyFile failed! The ErrCode is %d. “), ErrCode);</p>
<pre><code>				for (i = 0; i &lt; 10; i++)
				&#123;
					copyFileResult = CopyFile(ff.GetFilePath(), DSTFildPath, FALSE);
					Sleep(2000);
					if (copyFileResult == 0)
					&#123;
						ErrCode = GetLastError();
						StrResult.Format(_T(&quot;Retry CopyFile failed! The ErrCode is %d. &quot;), ErrCode);
					&#125;
					else
					&#123;
						break;
					&#125;
				&#125;

				if (copyFileResult == 0)
				&#123;
					ff.Close();
					return FALSE;
				&#125;
			&#125;
		&#125;
		else if (ff.IsDirectory() &amp;&amp; !ff.IsDots())
		&#123;
			CString DSTFildPath;
			DSTFildPath = DSTDir + ff.GetFileName();
			copyFileResult = ModeTestCopyFileFromSRCtoDST(ff.GetFilePath(), DSTFildPath, StrResult);
			if (copyFileResult == 0)
				break;
		&#125;
	&#125;

	ff.Close();
	if (copyFileResult == 0)
		return FALSE;
	else
		return TRUE;
&#125;
</code></pre>
<p>比较两个路径的文件：<br>其方法是，文件读到buffer, 再用memcmp比较buffer, 其FindNextFile也是如何从目录搜索到文件的关键方法</p>
<pre><code>BOOL CmyMFCDlg::ModeTestCompareFilesBetweenSRCandDST(CString SRC, CString DST, CString&amp; StrResult)
&#123;
	CFileFind ff;
	CString SRCDir = SRC;
	CString DSTDir = DST;
	BOOL bRes = TRUE;
	HANDLE hSrcFile, hDstFile;
	DWORD dwSRCFile, dwDSTFile, dwCB;

	if (SRCDir.Right(1) != _T(&quot;\\&quot;))
		SRCDir += _T(&quot;\\&quot;);
	SRCDir += _T(&quot;*.*&quot;);

	if (DSTDir.Right(1) != _T(&quot;\\&quot;))
		DSTDir += _T(&quot;\\&quot;);
	hSrcFile = hDstFile = NULL;
	BYTE* pSrcBuffer = new BYTE[M_BUFSIZE];
	BYTE* pDstBuffer = new BYTE[M_BUFSIZE];
	memset(pSrcBuffer, 0, M_BUFSIZE);
	memset(pSrcBuffer, 0, M_BUFSIZE);

	BOOL res = ff.FindFile(SRCDir);

	while (res)
	&#123;
		res = ff.FindNextFile();
		if (!ff.IsDirectory() &amp;&amp; !ff.IsDots())
		&#123;
			CString DSTFilePath;
			DSTFilePath = DSTDir + ff.GetFileName();
			CString SRCFilePath = ff.GetFilePath();

			if (hSrcFile)
			&#123;
				CloseHandle(hSrcFile);
				hSrcFile = NULL;
			&#125;

			if (hDstFile)
			&#123;
				CloseHandle(hDstFile);
				hSrcFile = NULL;
			&#125;

			hSrcFile = CreateFile(SRCFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hSrcFile == INVALID_HANDLE_VALUE)
			&#123;
				StrResult.Format(_T(&quot;\n Create Source file failed!! Error code = %d \n&quot;), GetLastError());
				bRes = FALSE;
				break;
			&#125;

			hDstFile = CreateFile(DSTFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hDstFile == INVALID_HANDLE_VALUE)
			&#123;
				StrResult.Format(_T(&quot;\n Create Destination file failed!! Error code = %d \n&quot;), GetLastError());
				bRes = FALSE;
				break;
			&#125;

			LARGE_INTEGER SrcFileSize, DstFileSize;

			dwSRCFile = GetFileSizeEx(hSrcFile, &amp;SrcFileSize);
			dwDSTFile = GetFileSizeEx(hDstFile, &amp;DstFileSize);

			if (SrcFileSize.LowPart != DstFileSize.LowPart)
			&#123;
				StrResult.Format(_T(&quot;\n Compare file is different!! Src Length = %d, Dest Length = %d \n&quot;), SrcFileSize.LowPart, DstFileSize.LowPart);
				bRes = FALSE;
				break;
			&#125;

			while (SrcFileSize.LowPart &gt; 0)
			&#123;
				BOOL bCmpResult;
				bCmpResult = ReadFile(hSrcFile, pSrcBuffer, M_BUFSIZE, &amp;dwCB, NULL);
				if (bCmpResult == 0)
				&#123;
					bRes = FALSE;
					break;
				&#125;
				bCmpResult = ReadFile(hDstFile, pDstBuffer, M_BUFSIZE, &amp;dwCB, NULL);
				if (bCmpResult == 0)
				&#123;
					bRes = FALSE;
					break;
				&#125;
				bCmpResult = memcmp(pSrcBuffer, pDstBuffer, dwCB);

				if (bCmpResult != 0)
				&#123;
					bRes = FALSE;
					CString DiffByte;

					CString PostCmpErrorStr;
					CString SrcDumpData, DstDumpData;
					StrResult.Format(_T(&quot;\n Fatal_Error: Src Data from %d to %d.\n&quot;), (DstFileSize.LowPart - SrcFileSize.LowPart), (DstFileSize.LowPart - SrcFileSize.LowPart + dwCB));

					PostCmpErrorStr = _T(&quot;SourceFilePath: &quot;) + SRCFilePath + _T(&quot; To \r\n&quot;) + _T(&quot;DstFilePath: &quot;) + DSTFilePath;
					StrResult = PostCmpErrorStr + _T(&quot;  has compare error! \r\n&quot;);
					//HugoPostMessageAndShowSD1(PostCmpErrorStr,1);
					//HugoPostMessageAndShowSD2(PostCmpErrorStr,1);

					::MessageBox(
						NULL,
						(LPCWSTR)L&quot;Compare error happened!!&quot;,
						(LPCWSTR)L&quot;Fatal Error!&quot;,
						MB_OK
					);

					break;
				&#125;
				SrcFileSize.LowPart -= dwCB;
			&#125;

			if (bRes == FALSE)
				break;
			else
				ReadFile(hDstFile, pDstBuffer, 512, &amp;dwCB, NULL);
		&#125;
		else if (ff.IsDirectory() &amp;&amp; !ff.IsDots())
		&#123;
			CString DSTFildPath;
			DSTFildPath = DSTDir + ff.GetFileName();
			bRes = ModeTestCompareFilesBetweenSRCandDST(ff.GetFilePath(), DSTFildPath, StrResult);
			if (bRes == FALSE)
				break;
		&#125;
	&#125;

	if (hSrcFile)
	&#123;
		CloseHandle(hSrcFile);
		hSrcFile = NULL;
	&#125;

	if (hDstFile)
	&#123;
		CloseHandle(hDstFile);
		hSrcFile = NULL;
	&#125;

	if (bRes == FALSE)
	&#123;
		delete[]pSrcBuffer;
		delete[]pDstBuffer;
		ff.Close();
		return FALSE;
	&#125;
	else
	&#123;
		delete[]pSrcBuffer;
		delete[]pDstBuffer;
		ff.Close();
		return TRUE;
	&#125;
&#125;
</code></pre>
<p>关于CString的格式化输出：<a href="https://blog.csdn.net/wangkaishou/article/details/5846152">MFC中CString.Format的详细用法</a><br>关于CFile文件操作：<a href="https://blog.csdn.net/perfectguyipeng/article/details/60148222">MFC——文件操作（CFile）</a></p>
<h2 id="开始按钮"><a href="#开始按钮" class="headerlink" title="开始按钮"></a>开始按钮</h2><p>一般操作顺序：选择src和dst，再点击Start按钮<br>start按钮的方法调用已保存的m_src和m_dst路径，传入拷贝和比较，再输出结果即可，大致流程如下</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonrun()
&#123;
    //读入所有界面数据
	UpdateData(true);
	
	BOOL ret;
	CString outStr;
	
	ret = ModeTestCopyFileFromSRCtoDST(m_src, m_dst, outStr);
	if (!ret)
			MessageBox(NULL, _T(outStr), _T(&quot;ERROR&quot;), MB_OK);
	
	ret = ModeTestCompareFilesBetweenSRCandDST(m_src, m_dst, outStr);
	if (!ret)
			MessageBox(NULL, _T(outStr), _T(&quot;ERROR&quot;), MB_OK);
&#125;
</code></pre>
<p>这里用messagebox输出结果，即弹窗，弹窗是阻塞式的。也可以用编辑框，写文件输出。<br>关于messagebox，参考：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox">MessageBox function (winuser.h)</a><br>关于updateData：<a href="https://www.cnblogs.com/lidabo/archive/2012/07/17/2595464.html">MFC中UpdateData()函数的使用</a><br>以上完成一个简单的文件拷贝和比较功能</p>
<h1 id="多线程文件拷贝和写日志"><a href="#多线程文件拷贝和写日志" class="headerlink" title="多线程文件拷贝和写日志"></a>多线程文件拷贝和写日志</h1><p>将简单拷贝扩展，支持：</p>
<ul>
<li>多线程拷贝和比较，每个线程完成简单拷贝比较的功能</li>
<li>在每个工作线程，输出打印到界面文本框，同时写到同一个日志文件</li>
<li>界面主线程需要等待所有工作线程完成后，输出测试完成信息到文本框和日志</li>
</ul>
<h2 id="线程列表获取各自路径"><a href="#线程列表获取各自路径" class="headerlink" title="线程列表获取各自路径"></a>线程列表获取各自路径</h2><p>add和delete配置几个工作线程，每个线程配置其src和dst路径</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516636.png" alt="12"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516611.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516530.png" alt="14"></p>
<p>这种动态增删的列表，在资源界面新建listbox类型变量和方法：</p>
<pre><code>CListBox m_rwlist;
afx_msg void OnLbnSelchangeListrwlist();
</code></pre>
<p>Add和Delete对应的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonadd()
void CmyMFCDlg::OnBnClickedButtondelete()
</code></pre>
<p>Add和Delete的方法控制listbox变量m_rwlist，选中任意m_rwlist后又会调用其方法OnLbnSelchangeListrwlist，获取每个线程各自的src、dst。</p>
<p>按键控制m_rwlist的实现：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonadd()
&#123;
	CString Threadtest = _T(&quot;TestThread&quot;);
	UINT ThreadCount = m_rwlist.GetCount();
	if (ThreadCount == 0)
	&#123;
		m_rwlist.AddString(_T(&quot;TestThread1&quot;));
	&#125;
	else if (ThreadCount &lt; MAX_THREAD_COUNT)
	&#123;
		CString ThreadNum;
		ThreadNum.Format(_T(&quot;%d&quot;), ThreadCount + 1);
		Threadtest = Threadtest + ThreadNum;
		m_rwlist.AddString(Threadtest);
	&#125;
	else if (ThreadCount == MAX_THREAD_COUNT)
	&#123;
		CString str;
		str.Format(_T(&quot;Only support %d threads at most!!&quot;), MAX_THREAD_COUNT);
		MessageBox(str);
	&#125;
	m_rwlist.SetCurSel(ThreadCount);
	if (ThreadCount &lt; MAX_THREAD_COUNT)
		totalThreadCount++;
&#125;

void CmyMFCDlg::OnBnClickedButtondelete()
&#123;
	UINT ThreadCount = m_rwlist.GetCount();
	if (ThreadCount != 0)
	&#123;
		m_rwlist.DeleteString(ThreadCount - 1);
		m_rwlist.SetCurSel(0);
	&#125;
	if (ThreadCount &gt; 0)
		totalThreadCount--;
&#125;
</code></pre>
<p>线程列表m_rwlist的方法读取路径到会话对象成员变量：</p>
<pre><code>void CmyMFCDlg::OnLbnSelchangeListrwlist()
&#123;
	UpdateData(true); //update true: 从界面读入值到变量（使上次编辑生效）
	if (m_rwlist.GetCount() != 0)
	&#123;
		UINT selectNum = m_rwlist.GetCurSel();
		RWTestParamArray[selectNum].ThreadNum = m_rwlist.GetCount();
		RefreshRWParam(RWTestParamArray, selectNum);
	&#125;
&#125;

void CmyMFCDlg::RefreshRWParam(TabDialogRWTestParam(&amp;Array)[MAX_THREAD_COUNT], UINT CSel)
&#123;
	ctrl_src.SetWindowText(Array[CSel].SRCFolder_Path);
	ctrl_dst.SetWindowText(Array[CSel].DSTFolder_Path);

	UpdateData(false); //update false: 把变量写入到界面（实时显示）
&#125;
</code></pre>
<p>真正读入路径的是dst、src按钮的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonsrc()
&#123;
	CString SrcPath;
	UINT ThreadCSelNum = m_rwlist.GetCurSel();
	SrcPath = GetFolderPath();
	ctrl_src.SetWindowText(SrcPath);
	RWTestParamArray[ThreadCSelNum].SRCFolder_Path = SrcPath;
&#125;

void CmyMFCDlg::OnBnClickedButtondst()
&#123;
	CString DstPath;
	UINT ThreadCSelNum = m_rwlist.GetCurSel();
	DstPath = GetFolderPath();
	ctrl_dst.SetWindowText(DstPath);
	RWTestParamArray[ThreadCSelNum].DSTFolder_Path = DstPath;
&#125;
</code></pre>
<p>线程数组定义在会话类，存储每个工作线程要用的数据</p>
<pre><code>TabDialogRWTestParam RWTestParamArray[MAX_THREAD_COUNT];
typedef struct TabRWParam
&#123;
	CString SRCFolder_Path;
	CString DSTFolder_Path;
	UINT ThreadNum;
	UINT TestTimes;
&#125;TabDialogRWTestParam;
</code></pre>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>创建线程参考MS文档：<a href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-160">beginthread、_beginthreadex</a><br>关注2点：</p>
<ul>
<li>传入线程内要执行的函数，和参数(可为NULL)</li>
<li>返回线程句柄，如果是多个线程则是个数组</li>
</ul>
<p>创建线程的部分代码：</p>
<pre><code>void CmyMFCDlg::RunModeTestInstance()
&#123;
    ....
    
	//线程内除了对象，还需要知道自己是哪个线程，因此打包this和ThreadCount
	pTransParam ThreadTransPArray[MAX_THREAD_COUNT];

	for (int i = 0; i &lt; totalThreadCount; i++)
	&#123;
		ThreadTransPArray[i] = new(TransParam);
		ThreadTransPArray[i]-&gt;i = i;
		ThreadTransPArray[i]-&gt;translpParam = this;

		unsigned int rwThreadID;

		//hThread defined as global data
		hThread[i] = (HANDLE)_beginthreadex(
			NULL,
			0,
			DoThreadProc,
			ThreadTransPArray[i],
			0,
			&amp;rwThreadID);

		if (hThread[i] == NULL)
			MessageBox(_T(&quot;CreateThread Fail!!&quot;), MB_OK);
		
		....
		
		//release resource
    	for (int i = 0; i &lt; totalThreadCount; i++)
    	&#123;
    		delete ThreadTransPArray[i];
    		ThreadTransPArray[i] = NULL;
    		CloseHandle(hThread[i]);
    	&#125;
	&#125;
</code></pre>
<p>由于要在线程内打印当前是哪个线程，这个从Dlg对象的this指针是获取不到的，因此把this指针和线程id打包结构体，传入DoThreadProc线程函数，结构体如下</p>
<pre><code>typedef struct transParam
&#123;
	LPVOID translpParam;
	int i;
&#125;TransParam, *pTransParam;

#define MAX_THREAD_COUNT 6
</code></pre>
<p>注意使用完后释放线程句柄和其他相关资源</p>
<h2 id="主线程和工作线程的通信：Message机制"><a href="#主线程和工作线程的通信：Message机制" class="headerlink" title="主线程和工作线程的通信：Message机制"></a>主线程和工作线程的通信：Message机制</h2><p>先明白几点：</p>
<ul>
<li>所有工作线程都共享主线程（界面线程）的数据，即会话类对象的成员</li>
<li>界面控件的操作函数，都是主线程独有的，工作线程不能调用</li>
<li>主线程如果要等待工作线程，一般会阻塞</li>
</ul>
<p>问题：<br>如何将工作线程的打印输出到主线程界面控件？</p>
<p>Windows消息机制可以解决工作线程和主线程通信问题，简单的讲，主线程有消息队列，工作线程可以发送消息到消息队列中，主线程用FIFO原则处理队列中的消息，在阻塞等待动作线程时，也支持消息队列的处理。<br>关于消息队列：<a href="https://www.jianshu.com/p/5fd5bdaac69c">windows消息机制（MFC）</a></p>
<p>（1）工作线程函数</p>
<pre><code>unsigned int WINAPI DoThreadProc(void *threadTransParam)
&#123;
	pTransParam pTrans = (pTransParam)threadTransParam;
	CString strResult;
	BOOL res = 0;

	CmyMFCDlg* pDlg = (CmyMFCDlg *)pTrans-&gt;translpParam;
	int thread_id = pTrans-&gt;i;

	for (int i = 0; i &lt; (int)pDlg-&gt;rwtime; i++)
	&#123;
		
		res = pDlg-&gt;ModeTestCopyFileFromSRCtoDST(pDlg-&gt;RWTestParamArray[thread_id].SRCFolder_Path, pDlg-&gt;RWTestParamArray[thread_id].DSTFolder_Path, strResult);

		res = pDlg-&gt;ModeTestCompareFilesBetweenSRCandDST(pDlg-&gt;RWTestParamArray[thread_id].SRCFolder_Path, pDlg-&gt;RWTestParamArray[thread_id].DSTFolder_Path, strResult);
		if (res)
		&#123;
			criticalSec.Lock();
			::PostMessage(pDlg-&gt;GetSafeHwnd(), WM_USER_MSG, WPARAM(thread_id + 1), LPARAM(i + 1));
			criticalSec.Unlock();
		&#125;
	&#125;

	return res;
&#125;
</code></pre>
<p>几点说明：</p>
<ul>
<li>线程函数要用WINAPI实现，不属于会话类内的方法，因此需要this指针显式调用</li>
<li>rwtime是测试次数，每个线程执行多次拷贝比较</li>
<li>PostMessage是发布消息到主线程消息队列，可以传参：WPARAM和LPARAM</li>
<li>由于不确定PostMessage是不是线程安全，这里加了锁：CCriticalSection类型的criticalSec</li>
</ul>
<p>(2)消息处理函数<br>来看message处理函数：</p>
<pre><code>LRESULT CmyMFCDlg::OnMsg(WPARAM wp, LPARAM lp)
&#123;
	strAppend.Format(_T(&quot;Thread %d src:%s ---&gt; des:%s, Copy&amp;Compare Pass: test loop: %d \n&quot;), wp, RWTestParamArray[wp-1].SRCFolder_Path, RWTestParamArray[wp-1].DSTFolder_Path, lp);
	ShowLogInEditBox(); //字符串显示到界面
	return 0;
&#125;
</code></pre>
<p>主界面字符串显示函数</p>
<pre><code>/* call by message handler, for multiple child thread*/
void CmyMFCDlg::ShowLogInEditBox()
&#123;
	CString str;
	UINT i;

	/*message 队列只在主线程内处理，无需加锁*/
	//criticalSec.Lock();
		WriteLogFile(this-&gt;strAppend); //only write append str
	//criticalSec.Unlock();

	this-&gt;GetDlgItemText(IDC_EDIT_logbox, str);
	str += this-&gt;strAppend; //update old+append str
	str += &quot;\r\n&quot;; //这里换行没用，要在控件设置中允许换行

	this-&gt;SetDlgItemText(IDC_EDIT_logbox, str);

	i = ((CEdit*)GetDlgItem(IDC_EDIT_logbox))-&gt;GetLineCount();
	((CEdit*)GetDlgItem(IDC_EDIT_logbox))-&gt;LineScroll(++i, 0); //定位到下一行

&#125;
</code></pre>
<p>写日志的相关方法如下：</p>
<pre><code>BOOL CmyMFCDlg::CreateLogFile()
&#123;
	CString strName;
	SYSTEMTIME st;

	GetLocalTime(&amp;st);
	strName.Format(_T(&quot;UtilityLogFile_%4d-%d-%d_%d-%d-%d.log&quot;), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);

	if (!m_File.Open(strName, (CFile::modeCreate | CFile::modeReadWrite), 0))
	&#123;
		::AfxMessageBox(_T(&quot;Create Utility Log File Error!!&quot;));
		return FALSE;
	&#125;

	m_logCreated = 1;
	return TRUE;
&#125;

void CmyMFCDlg::WriteLogFile(CString str)
&#123;
	BOOL CreateRes = TRUE;

	if (m_logCreated == 0)
		CreateRes = CreateLogFile();

	if (CreateRes)
	&#123;
		str += _T(&quot;\r\n&quot;);
		int length = str.GetLength();
		length *= 2;
		m_File.Write(str, length);
		m_File.Flush();
	&#125;
&#125;

void CmyMFCDlg::CloseLogFile()
&#123;
	if (m_logCreated == 1)
	&#123;
		m_File.Close();
		m_logCreated = 0;
	&#125;
&#125;
</code></pre>
<p>注意message处理函数的关键点：</p>
<ul>
<li>只在主线程中处理，不存在其他线程操作，无临界区问题。因此上述的窗口输出，日志文件写入都是线程安全的。</li>
</ul>
<p>编辑框作为输出要注意几点：</p>
<ul>
<li>换行要在设置里配置，字符串换行没用</li>
<li>设置输出滚动显示</li>
</ul>
<p>效果如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516097.png" alt="15"></p>
<p>（3）线程同步<br>日志完成的输出是主线程等待所有工作线程函数返回后才执行，如何实现？<br>参考：<a href="https://www.cnblogs.com/shangdawei/p/4015772.html">WaitForMultipleObject与MsgWaitForMultipleObjects用法</a><br>我们的需求是主线程在阻塞等待时要处理消息，因此用MsgWaitForMultipleObjects方法。<br>代码如下：</p>
<pre><code>//wait all child threads return

	/*
	//主线程阻塞，不能处理消息
	DWORD dwWaitResult = WaitForMultipleObjects(
		totalThreadCount,
		hThread,
		TRUE,
		INFINITE);
	*/
	//主线程阻塞，但不阻塞消息
	int nWaitCount = totalThreadCount;
	int nExitThreadCount = 0;      //标记已经有几个线程退出了
	BOOL bWaitAll = FALSE;		//不等待所有线程完成，实时处理。如果TRUE, 会阻塞到所有线程完成
	DWORD result;
	MSG msg;

	while (TRUE)
	&#123;
		/*该函数等待：多个线程的完成信号，或其他消息信号,有任意一种就返回
		*返回值为[WAIT_OBJECT_0, WAIT_OBJECT_0 + nWaitCount - 1]表示对应下标的线程已完成
		*返回值为WAIT_OBJECT_0 + nWaitCount表示有其他信号，如线程内发送的message
		*WAIT_OBJECT_0值为0
		*/
		result = MsgWaitForMultipleObjects(nWaitCount, hThread, bWaitAll, INFINITE, QS_ALLINPUT);

		if (result == WAIT_OBJECT_0 + nWaitCount) //表示收到消息
		&#123;
			while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) //处理所有已入队的消息
			&#123;
				TranslateMessage(&amp;msg); //message translat and format, add into message queue
				DispatchMessage(&amp;msg); //call message handler
			&#125;
		&#125;
		else if (result &gt;= WAIT_OBJECT_0 &amp;&amp; result &lt; WAIT_OBJECT_0 + nWaitCount) //表示收到了线程结束信号
		&#123;
			nExitThreadCount++;
			if (nExitThreadCount &lt; totalThreadCount)
			&#123;
				/*必须更新hThread，否则已退出的线程一直被检测到*/
				int nIndex = result - WAIT_OBJECT_0; //退出线程的index
				hThread[nIndex] = hThread[nWaitCount - 1]; //更新等待列表：hThread, 交换退出的成员和尾部成员
				hThread[nWaitCount - 1] = NULL;

				nWaitCount--; //更新要等待的线程数
			&#125;
			else
			&#123;
				break; //等待的所有线程都已完成
			&#125;
		&#125;
	&#125;

	//All threads returned
</code></pre>
<p>MsgWaitForMultipleObjects的MS说明文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects">MsgWaitForMultipleObjects function (winuser.h)</a><br>返回值的含义是重点，这个文档说的很隐晦：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051517122.png" alt="16"></p>
<p>大意是：等待n个线程</p>
<ul>
<li>如果返回的值i是属于0~n-1，说明第i个工作线程结束了</li>
<li>如果返回值是n，不是线程结束，而是收了到消息，例如工作线程内发送的消息。</li>
</ul>
<p>因此代码逻辑是：<br>1.如果有消息，就处理消息<br>关于message的peek,translate和dispatch:<br><a href="https://blog.csdn.net/caimagic/article/details/50629570">PeekMessage使用方法</a><br><a href="https://blog.csdn.net/wang15061955806/article/details/52066559">消息循环中TranslateMessage和Dispatch函数的作用</a></p>
<p>2.如果有线程结束，要更新线程句柄数组，只保留未等待到的线程；<br>当所有线程都等待到，退出等待循环</p>
<p>以上完成了主线程和多个工作线程的同步机制</p>
<h1 id="再进一步：调用其他进程"><a href="#再进一步：调用其他进程" class="headerlink" title="再进一步：调用其他进程"></a>再进一步：调用其他进程</h1><p>现需求如下：<br>有多个功能的FW需要测试，要求测试工具遍历每个FW, 调用其他的程序，更新到磁盘固件后，做之前的多进程读写比较流程<br>重点关注如何调用其他程序。假设FW更新程序是FirwmareUpdateTool.exe，接受FW相关的参数<br>需要实现：</p>
<ul>
<li>界面接收参数</li>
<li>调用其他程序，传参，且注意与主线程的同步</li>
</ul>
<p>代码：</p>
<pre><code>BOOL CmyMFCDlg::DoUpdateFirmware(CString filename)
&#123;
	TCHAR szFilePath[MAX_PATH + 1] = &#123; 0 &#125;;
	GetModuleFileName(NULL, szFilePath, MAX_PATH);
	(_tcsrchr(szFilePath, _T(&#39;\\&#39;)))[1] = 0;

	CString strToolPath(szFilePath);
	strToolPath = strToolPath + _T(&quot;FirwmareUpdateTool.exe&quot;);
	CString strPath;
	strPath.Format(_T(&quot;%s %s %s %d&quot;), strToolPath.GetBuffer(0), m_str_VendorID.GetBuffer(0), filename.GetBuffer(0), m_SlotID);
	
	strAppend = strPath;
	ShowLogInEditBox();

	if (!PathFileExists(strToolPath))
	&#123;
		strAppend.Format(_T(&quot;The %s is not exist!&quot;), strToolPath.GetBuffer(0));
		ShowLogInEditBox();
		MessageBox(strAppend, MB_OK);
		return FALSE;
	&#125;

	STARTUPINFO si = &#123; sizeof(STARTUPINFO) &#125;;//在产生子进程时，子进程的窗口相关信息
	PROCESS_INFORMATION pi;                  //子进程的ID/线程相关信息
	memset(&amp;pi, 0, sizeof(PROCESS_INFORMATION));
	DWORD returnCode = -1;              //用于保存子程进的返回值;

	BOOL bRet = CreateProcess(              //调用失败，返回0；调用成功返回非0；
		NULL,                               //一般都是空；（另一种批处理情况：此参数指定&quot;cmd.exe&quot;,下一个命令行参数 &quot;/c otherBatFile&quot;)
		strPath.GetBuffer(0),              //命令行参数         
		NULL,                               //_In_opt_    LPSECURITY_ATTRIBUTES lpProcessAttributes,
		NULL,                               //_In_opt_    LPSECURITY_ATTRIBUTES lpThreadAttributes,
		FALSE,                              //_In_        BOOL                  bInheritHandles,
		CREATE_NEW_CONSOLE,                 //新的进程使用新的窗口。
		NULL,                               //_In_opt_    LPVOID                lpEnvironment,
		NULL,                               //_In_opt_    LPCTSTR               lpCurrentDirectory,
		&amp;si,                                //_In_        LPSTARTUPINFO         lpStartupInfo,
		&amp;pi);                               //_Out_       LPPROCESS_INFORMATION lpProcessInformation

	if (bRet)
	&#123;
		while (TRUE) //这里也是为了输出打印和日志而等待进程，同时也阻塞了主线程
		&#123;
			DWORD result;
			MSG msg;
			result = MsgWaitForMultipleObjects(1, &amp;pi.hProcess, FALSE, INFINITE, QS_ALLINPUT);
			if (result == (WAIT_OBJECT_0))
			&#123;
				//获取子进程的返回值
				GetExitCodeProcess(pi.hProcess, &amp;returnCode);
				CloseHandle(pi.hThread);
				CloseHandle(pi.hProcess);
				break;
			&#125;
			else
			&#123;
				PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE);
				DispatchMessage(&amp;msg);
			&#125;
		&#125;
		strAppend.Format(_T(&quot;%s returnCode : %d &quot;), strToolPath.GetBuffer(0), returnCode);
		ShowLogInEditBox();
	&#125;
	else
	&#123;
		strAppend.Format(_T(&quot;Start the %s failed!&quot;), strToolPath.GetBuffer(0));
		ShowLogInEditBox();
		MessageBox(strAppend, MB_OK);
	&#125;

	if (!returnCode)
	&#123;
		return TRUE;
	&#125;
	return FALSE;
&#125;
</code></pre>
<p>CreateProcess创建进程，执行第三方程序<br>MsgWaitForMultipleObjects等待第三方进程返回，阻塞了当前主进程</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文涉及的知识点：</p>
<ul>
<li>界面控件与底层类的数据交互</li>
<li>MFC的文件，字符串操作</li>
<li>线程创建和线程同步</li>
<li>线程通信：消息机制</li>
<li>进程创建与同步</li>
</ul>
]]></content>
      <categories>
        <category>windows应用开发</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用笔记</title>
    <url>/2020/12/12/Markdown%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code>#
##
### 
</code></pre>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><pre><code>- line 
或者
* line
</code></pre>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. line</span><br><span class="line">2. line</span><br></pre></td></tr></table></figure>

<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>有的文字或代码和markdown解析有冲突<br>如$, @等<br>在这些字符前加转义字符即可：$, @</p>
<h2 id="tab缩进"><a href="#tab缩进" class="headerlink" title="tab缩进"></a>tab缩进</h2><p>markdown本身不支持tab缩进，有以下方法：<br>1.可以用全角输入+2个空格实现缩进<br>2.输入<code>&amp;emsp</code>，就是全角空格符号<br>3.输入<code>&gt;</code></p>
<h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><pre><code>[标题](URL)
</code></pre>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code>|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>
<h1 id="Typora使用"><a href="#Typora使用" class="headerlink" title="Typora使用"></a>Typora使用</h1><h2 id="导出和打印"><a href="#导出和打印" class="headerlink" title="导出和打印"></a>导出和打印</h2><p>有的markdown文本内容中带换行，而Typora阅读时也有换行，照成换行混乱</p>
<p>如果要打印，导出pdf的换行也混乱</p>
<p>解决办法是导出HTML(without style)，然后打印</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>NVMe设备的Firmware Update全栈分析（一）：基于Windows Storport环境</title>
    <url>/2022/11/30/NVMe%E8%AE%BE%E5%A4%87%E7%9A%84Firmware%20Update%E5%85%A8%E6%A0%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EWindows%20Storport%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update"><a href="#1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update" class="headerlink" title="1.1 Windows Storport Driver环境下的NVMe设备Firmware Update"></a>1.1 Windows Storport Driver环境下的NVMe设备Firmware Update</h2><p>Windows系统下，NVMe设备的Firmware Update都是基于以下Microsoft API文档 ：</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/upgrading-firmware-for-an-nvme-device">upgrading-firmware-for-an-nvme-device</a></p>
]]></content>
      <categories>
        <category>NVMe</category>
      </categories>
      <tags>
        <tag>NVMe</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用笔记</title>
    <url>/2023/10/07/Python%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="pip-install换源"><a href="#pip-install换源" class="headerlink" title="pip install换源"></a>pip install换源</h1><p>pip install，有的包一直timeout无法安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReadTimeoutError: HTTPSConnectionPool(host=&#x27;files.pythonhosted.org&#x27;, port=443): Read timed out</span><br></pre></td></tr></table></figure>

<p>解决办法参考：<a href="https://www.runoob.com/w3cnote/pip-cn-mirror.html">https://www.runoob.com/w3cnote/pip-cn-mirror.html</a></p>
<h2 id="单次换源"><a href="#单次换源" class="headerlink" title="单次换源"></a>单次换源</h2><p>使用 -i 指定国内源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple </span><br></pre></td></tr></table></figure>

<p>常用国内源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">清华大学：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple</span><br><span class="line">豆瓣：http://pypi.douban.com/simple</span><br></pre></td></tr></table></figure>

<h2 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用清华源更新pip版本</span><br><span class="line">python -m pip install --upgrade pip -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple </span><br><span class="line">#对当前pip版本，设置默认使用清华源</span><br><span class="line">pip config set global.index-url https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure>

<h2 id="全局换源"><a href="#全局换源" class="headerlink" title="全局换源"></a>全局换源</h2><p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\用户名\pip，即 %HOMEPATH%\pip，然后新建文件pip.ini，输入以下内容（以tsinghua镜像为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>

<p>Linux下，配置~&#x2F;.pip&#x2F;pip.conf，内容和windows .ini内容一样</p>
<h1 id="pip-install指定版本"><a href="#pip-install指定版本" class="headerlink" title="pip install指定版本"></a>pip install指定版本</h1><p>安装pandas报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host machine cpu: x86_64</span><br><span class="line">Program python found: YES (C:\Users\cursorhu\AppData\Local\Programs\Python\Python312-32\python.exe)</span><br><span class="line">Need python for x86_64, but found x86</span><br><span class="line">Run-time dependency python found: NO (tried sysconfig)</span><br><span class="line">..\..\pandas\_libs\tslibs\meson.build:32:7: ERROR: Python dependency not found</span><br></pre></td></tr></table></figure>

<p>当前使用的是32位Python（Python 3.12.0 32位），而pandas 2.2.3需要64位Python环境。</p>
<p>解决方案有两种：</p>
<ol>
<li><p>安装64位版本的Python</p>
</li>
<li><p>安装较旧版本的pandas，它可能兼容32位Python</p>
</li>
</ol>
<p>安装较旧版本的pandas，这样您可以不用更换Python环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pandas==1.5.3 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>要升级pandas可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#升级到最新版</span><br><span class="line">python -m pip install --upgrade pandas -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</span><br><span class="line">#升级到指定版</span><br><span class="line">python -m pip install --upgrade pandas==2.2.3 -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记：RGB调色器</title>
    <url>/2022/04/18/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ARGB%E8%B0%83%E8%89%B2%E5%99%A8/</url>
    <content><![CDATA[<p>本文基于Qt官方示例<a href="https://doc.qt.io/qt-5/designer-quick-start.html#:~:text=%20Using%20Qt%20Designer%20involves%20four%20basic%20steps%3A,the%20slots%204%20Preview%20the%20form%20More%20"> A Quick Start to Qt Designer</a>, 实现自定义的slot函数，新增RGB色彩窗口显示色彩。</p>
<ul>
<li>本文源码：<a href="https://github.com/cursorhu/QtSampleTest/tree/master/1.rgbSlider">QtSampleTest&#x2F;1.rgbSlider</a></li>
<li>环境：基于Qt5.9 + Qt creater</li>
</ul>
<p>本文只记录项目过程中的注意事项，以及增量开发，其他部分参考Qt官方示例。</p>
<h2 id="1-UI部分"><a href="#1-UI部分" class="headerlink" title="1.UI部分"></a>1.UI部分</h2><ul>
<li>建立带UI的项目rgbSlider, 基于Qwidget生成默认自定义类名widget</li>
<li>双击widget.ui进入UI编辑</li>
</ul>
<p>UI 编辑模式下使用两种模式：widget编辑模式， slot&#x2F;signal编辑模式</p>
<ol>
<li><p>widget编辑模式如下：使用水平、网格布局<br>RGB数值控制部分，使用Label,  spinBox和scrollBar三种控件，按先竖直，后水平排列<br>RGB颜色显示部分，使用 graphicsView窗口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181201206.png"><br>注意调整布局的比例需要先选中，然后在layout属性调整<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181202783.png"></p>
</li>
<li><p>slot&#x2F;signal编辑模式<br>直接拖拽起始控件和目标控件，设置控件的信号和槽<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181203784.png"></p>
</li>
</ol>
<h2 id="2-自定义槽"><a href="#2-自定义槽" class="headerlink" title="2.自定义槽"></a>2.自定义槽</h2><p>graphicsView窗口预期效果是：只要调整RGB数值，自动显示对应的颜色<br>UI界面不能设置控件信号触发自定义槽，需要在代码中实现信号和槽的连接。</p>
<ol>
<li>右键转到graphicsView窗口的槽函数，自定义为 <code>Widget::on_rgbChanged()</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181400431.png"><br>函数实现如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;QColor&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;QPalette&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_rgbChanged()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> QPalette pal = QPalette();</span><br><span class="line"></span><br><span class="line"> QColor color;</span><br><span class="line"></span><br><span class="line"> //分别设置R,G,B,透明度</span><br><span class="line"></span><br><span class="line"> color.setRgb(ui-&gt;spinBoxRed-&gt;value(), ui-&gt;spinBoxGreen-&gt;value(), ui-&gt;spinBoxBlue-&gt;value(), 255);</span><br><span class="line"></span><br><span class="line"> //QPalette::Base</span><br><span class="line"></span><br><span class="line"> //Used mostly as the background color for text entry widgets, It is usually white or another light color.</span><br><span class="line"></span><br><span class="line"> pal.setColor(QPalette::Base, color);</span><br><span class="line"></span><br><span class="line"> ui-&gt;graphicsView-&gt;setPalette(pal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在UI基础上使用控件对象的方法，只需要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ui-&gt;控件名-&gt;控件的方法</span><br></pre></td></tr></table></figure>

<p>注意<code>setColor</code>可以给不同图层上色，这里使用<code>QPalette::Base</code>，而不能是<code>QPalette::Window</code>或<code>QPalette::Background</code></p>
<p>代码设置信号与槽, 注意，手动设置的代码要在<code>ui-&gt;setupUi(this);</code>的后面添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line"></span><br><span class="line"> QWidget(parent),</span><br><span class="line"></span><br><span class="line"> ui(new Ui::Widget)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxRed, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxGreen, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxBlue, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3.测试效果"></a>3.测试效果</h2><ul>
<li>拖动滑块，对应数值会更新，颜色同步更新</li>
<li>修改数值，对应滑块更新，颜色更新<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181410181.png"></li>
</ul>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>SD/MMC -- PCIe通道SD命令的协议包分析</title>
    <url>/2023/11/22/SDMMC%20--%20PCIe%E9%80%9A%E9%81%93SD%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文记录用LeCroy PCIe协议分析仪debug SD host controller issue的方法。具体背景是该issue使用windbg或者打开driver debug log后无法复现，只能用PCIe协议分析仪分析。</p>
<h3 id="PCIe包解析的配置"><a href="#PCIe包解析的配置" class="headerlink" title="PCIe包解析的配置"></a>PCIe包解析的配置</h3><p>使用spread view模式：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221449131.png" alt="image-20231122144912104"></p>
<p>数据解析方式使用小端（Little-endian）+ MSB（高bit解析）</p>
<h3 id="寻找目标PCIe设备"><a href="#寻找目标PCIe设备" class="headerlink" title="寻找目标PCIe设备"></a>寻找目标PCIe设备</h3><p>本文的PCIe设备为SD host controller。</p>
<p>以下PCIe trace包含一次Memory read和Config read操作，以Memory read为例，一次通信流程是：</p>
<p>MRd 指定Address -&gt; MRd ACK -&gt; CpID包含设备返回的数据（98601217）-&gt; CpID的ACK </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221443875.png" alt="image-20231122144334835"></p>
<p>一般PCIe包开头会枚举设备，此CpID数据即目标设备的VendorID&#x2F;DeviceID，反推出此设备在PCIe config space的mapping起始地址是0x51200000</p>
<p>那么SD host设备的register被mapping到哪里？这是由PCIe config space的BAR0&#x2F;BAR1&#x2F;…地址指定。</p>
<p>如下图，SD host controller register space起使于PCIe config space的0x51200000，其中的0x10~0x27 offset内的值即BAR0&#x2F;BAR1&#x2F;…空间的地址</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221439448.png" alt="image-20231122143946372"></p>
<p>看PCIe包即可得到SD host controller的Bar0位于0x51201000，即PCIe config space的4KB位置。该空间包含SD host register(由该chip的设计决定)</p>
<h3 id="SD-command分析"><a href="#SD-command分析" class="headerlink" title="SD command分析"></a>SD command分析</h3><p>既然已知SD host register，那么查找SD command，实际就是查找对SD command register (如下图0Eh)的Memory write操作，根据写入数据查看SD command index。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221504817.png" alt="image-20231122150434747"></p>
<p>具体包分析如下：</p>
<p>下图0x5120100C中的0x0C即SD host register 0x0C，其写入数据Dword的高16bit即0x0E，所以最高byte即代表command index，即0x19是SD Command25: 多block写。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221512611.png" alt="image-20231122151211580"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221516595.png" alt="image-20231122151622555"></p>
<p>如何查看该SD command是否正常完成：</p>
<p>查看中断状态register 0x30h, 一般正常完成会返回command complete&#x2F; transfer complete等正常状态；未完成一般有Error interrupt。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221519332.png" alt="image-20231122151913284"></p>
<p>对于error interrupt，在0x32（即0x30高16bit）查看具体类型：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221520612.png" alt="image-20231122152004564">下面两个CpID分别是正常返回和错误返回：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221521406.png" alt="image-20231122152111371"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202311221520509.png" alt="image-20231122152045475"></p>
<p>正常返回的0x32(0x30高16bit)全为0，错误返回非0；错误类型为ADMA error + CRC error (data 0x32 &#x3D; 0x0220)</p>
]]></content>
      <categories>
        <category>SD/MMC</category>
      </categories>
      <tags>
        <tag>SD/MMC</tag>
      </tags>
  </entry>
  <entry>
    <title>SD/MMC -- SD Host Retimer简介</title>
    <url>/2025/10/30/SDMMC%20--%20SD%20Host%20Retimer%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="SD-Host-Retimer简介"><a href="#SD-Host-Retimer简介" class="headerlink" title="SD Host Retimer简介"></a>SD Host Retimer简介</h1><h2 id="信号完整性与Redriver-Retimer"><a href="#信号完整性与Redriver-Retimer" class="headerlink" title="信号完整性与Redriver&#x2F;Retimer"></a>信号完整性与Redriver&#x2F;Retimer</h2><h3 id="信号完整性-Signal-Integrity-SI"><a href="#信号完整性-Signal-Integrity-SI" class="headerlink" title="信号完整性(Signal Integrity, SI)"></a>信号完整性(Signal Integrity, SI)</h3><p>（1）数字信号与眼图</p>
<p>简单地讲，数字信号的逻辑0、1是依赖于模拟信号的高低电平</p>
<p>如下图，CMOS电平下，3.3V<del>2V为逻辑1，0.8V</del>0V(GND)为逻辑0；TTL电平下是5V<del>2V为逻辑1，0.8V</del>0V(GND)为逻辑0。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202410311100267.png" alt="image-20241031110053224"></p>
<p>考虑到模拟信号的跳变是有个过程的，如下图，在模拟电平还没达到数字逻辑0、1对应的电压时（下图Rise time和fall time的阶段），此时采样的数据是无效的。只有模拟电平达到逻辑0、1对应的电压时（下图Bit period），才能对信号采样，得到正确的逻辑0、1。</p>
<p>下图即眼图，能得到正确的逻辑0、1的采样区间越大，信号质量越好。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202410311106844.png" alt="image-20241031110611736"></p>
<p>（2）信号完整性</p>
<p>信号在传输过程中会参杂噪声信号，导致信号失真，眼图变差。信号失真太大，就会导致无法正确接收电路中传输的0或1信号，并导致错误的二进制值。</p>
<p>信号完整性即表示传输过程中的信号还保有多少原始信号的质量。</p>
<p>参考：<a href="https://www.ansys.com/zh-cn/simulation-topics/what-is-signal-integrity#what-is">ansys.com: 什么是信号完整性？</a></p>
<p>（3）高速信号的信号完整性</p>
<p>高速信号一般有两个特点：</p>
<ol>
<li>时钟周期短，对应时钟和数据采样频率高，即模拟信号跳变频繁，可采样时间更短，对传输线路的信号完整性要求高。</li>
<li>信号电压水平低，比如逻辑1在TTL是5V，CMOS是3.3V，更高速数字电路常用1.8V，1.2V作为高电平。低电压能减少模拟电路的电平建立时间，才能支持更短的信号周期；此外低电平也为了信号传输的功耗更低。信号电压水平低更容易收到噪声电平干扰（更小的噪声电压就能淹没信号电压），因此对传输线路的信号完整性要求高。</li>
</ol>
<p>因此信号完整性问题一般只在高速信号场景中需要重点考虑，低速信号一般没有信号完整性问题。</p>
<h3 id="提高信号完整性：Redriver和Retimer"><a href="#提高信号完整性：Redriver和Retimer" class="headerlink" title="提高信号完整性：Redriver和Retimer"></a>提高信号完整性：Redriver和Retimer</h3><p>既然信号质量变差是原始信号被传输过程的噪声干扰导致，有两种思路提高信号质量：</p>
<ol>
<li>改良派：通过模拟器件滤波过滤噪声，效果有限</li>
<li>改革派：直接重建信号，更彻底</li>
</ol>
<p>以上两种思路落地的方案分别是redriver和retimer</p>
<p>参考<a href="https://www.asteralabs.com/pci-express-retimers-vs-redrivers-an-eye-popping-difference/">PCI Express® Retimers vs. Redrivers: An Eye-Popping Difference</a></p>
<ul>
<li><strong>Redriver</strong>: A non-protocol-aware software-transparent extension device.</li>
<li><strong>Retimer</strong>: A physical layer protocol-aware, software-transparent extension device that forms two separate electrical link segments.</li>
</ul>
<p>Retimer和Redriver的主要区别在于：</p>
<p>A retimer is a mixed signal analog&#x2F;digital device that is protocol-aware and has the ability to fully recover the data, extract the embedded clock and retransmit a fresh copy of the data using a clean clock. </p>
<ol>
<li>retimer IC是包含模拟、数字的混合器件</li>
<li>retimer IC涉及到数据传输协议（例如<strong>PCIe protocol</strong>）：协议包含数据和时钟，retimer能接收原始数据信号再重新生成数据信号，能接收原始时钟信号再重新生成时钟信号，相当于retimer能完整地重建信号，相比redriver仅用模拟器件过滤噪声效果更好。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202410311049454.png" alt="image-20241031104940359"></p>
]]></content>
      <categories>
        <category>SD/MMC</category>
      </categories>
      <tags>
        <tag>SD/MMC</tag>
      </tags>
  </entry>
  <entry>
    <title>SD/MMC -- SD spec规范流程摘要</title>
    <url>/2025/10/30/SDMMC%20--%20SD%20spec%E8%A7%84%E8%8C%83%E6%B5%81%E7%A8%8B%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<h1 id="SD-Spec常用流程摘要"><a href="#SD-Spec常用流程摘要" class="headerlink" title="SD Spec常用流程摘要"></a>SD Spec常用流程摘要</h1><h2 id="SD-legacy初始化流程"><a href="#SD-legacy初始化流程" class="headerlink" title="SD legacy初始化流程"></a>SD legacy初始化流程</h2><p>SD legacy初始化是指所有SD卡在SD模式下的通用初始化流程，在此流程之后才可能指向UHS-I，UHS-II的初始化流程。</p>
<p>流程图见SD physical spec:</p>
<p>CMD0：GO_IDLE_STATE：使卡进入Idle state，即卡复位状态</p>
<p>CMD8：SEND_IF_COND：验证卡接口（I&#x2F;F）的operating conditon（COND），根据返回值的bit判断卡类型，这里不细讲，legacy初始化只看卡有没有返回CMD8，如果返回，获取到卡支持的电压（3.3V&#x2F;1.8V），后面再用这个电压值。</p>
<p>ACMD41（CMD55+CMD41）：SD_SEND_OP_COND：设置operating conditon，相当于根据CMD8的结果，host发起对卡的配置请求。ACMD41并不指向具体的卡设置，可理解为设置流程之前的握手。</p>
<p>CMD11：Voltage Switch：切换Host和SD card之间的信号电平，一般从3.3V切到1.8V，电压切换包括CLK，DATA，CMD线。注意这里的电压切换不是指通信电平的电压，而不是SD卡的供电电压VDD。</p>
<p>CMD2：SEND_CID：Card Identification，获取卡的CID，此命令完毕后卡从idle state进入identify state。</p>
<p>CMD3：SEND_RCA：Relative Card Address，获取卡的地址（来自于卡的RCA register），此命令完毕后卡进入stand-by state(属于data transfer mode中的一种子状态)。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031758279.png" alt="image-20250103175846219"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031918136.png" alt="image-20250103191821054"></p>
<p>下图详细描述ACMD41的S18R和S18A，以及CMD11电压切换</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031930634.png" alt="image-20250103193000571"></p>
<h2 id="SD-UHS-I的初始化流程"><a href="#SD-UHS-I的初始化流程" class="headerlink" title="SD UHS-I的初始化流程"></a>SD UHS-I的初始化流程</h2><p>legacy初始化的CMD3使卡进入transfer mode的standby状态后，CMD7-&gt;CMD42-&gt;ACMD6-&gt;CMD6-&gt;CMD19即UHS-I的初始化流程：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031933260.png" alt="image-20250103193305212"></p>
]]></content>
      <categories>
        <category>SD/MMC</category>
      </categories>
      <tags>
        <tag>SD/MMC</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 -- Keil ARM配置笔记</title>
    <url>/2024/03/02/STM32%20--%20Keil%20ARM%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Keil-ARM配置笔记"><a href="#Keil-ARM配置笔记" class="headerlink" title="Keil ARM配置笔记"></a>Keil ARM配置笔记</h1><h2 id="Keil-community版本"><a href="#Keil-community版本" class="headerlink" title="Keil community版本"></a>Keil community版本</h2><p><a href="https://www.keil.arm.com/mdk-community/">https://www.keil.arm.com/mdk-community/</a></p>
<h2 id="Keil-community安装ARM-compiler-v5"><a href="#Keil-community安装ARM-compiler-v5" class="headerlink" title="Keil community安装ARM compiler v5"></a>Keil community安装ARM compiler v5</h2><p>Keil community 5.37默认只包含ARM compile v6，编译v5的项目通常会报错（报错通常和v6要求C99相关），可以有两种方式解决：</p>
<p>（1）基于v6报错，更新代码，符合v6的规则要求</p>
<p>（2）安装v5 compiler，适配原项目</p>
<p>如何在Keil community &gt;&#x3D; 5.37版本上安装ARM compiler v5：</p>
<p>参考：<a href="https://community.arm.com/support-forums/f/keil-forum/52719/how-can-i-install-compiler-version-5-for-keil-vision-5">https://community.arm.com/support-forums/f/keil-forum/52719/how-can-i-install-compiler-version-5-for-keil-vision-5</a></p>
<p>1.下载ARM compiler v5</p>
<p><a href="https://developer.arm.com/documentation/ka005198/latest">https://developer.arm.com/documentation/ka005198/latest</a></p>
<p>登录ARM账户后，下载win32或者linux32版本</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412231526350.png" alt="image-20241223152607237"></p>
<p>2.安装ARM compiler v5</p>
<p>注意：安装路径必须是Keil路径下的ARM文件夹</p>
<p>For example, if your Keil MDK installation is in <code>C:\Keil_v5</code> the recommended installation path is <code>C:\Keil_v5\ARM\ARM_Compiler_5.06u7</code></p>
<p>如果不这样安装，Keil会找不到ARM compiler v5的license，编译会缺license报错；在Keil路径下安装会使用Keil已有的community license，不会报错。</p>
<p>3.配置Keil项目，添加v5选项</p>
<p><a href="https://developer.arm.com/documentation/101407/0541/Creating-Applications/Tips-and-Tricks/Manage-Arm-Compiler-Versions">https://developer.arm.com/documentation/101407/0541/Creating-Applications/Tips-and-Tricks/Manage-Arm-Compiler-Versions</a></p>
<p>如何知道项目是基于ARM compiler v5还是v6创建：</p>
<p>查看项目文件uvprojx，如果是 “礦ision5 Project (.uvprojx)”则是基于ARM compiler v5</p>
<h2 id="破解ARMCC-ARM-compiler-v5"><a href="#破解ARMCC-ARM-compiler-v5" class="headerlink" title="破解ARMCC(ARM compiler v5)"></a>破解ARMCC(ARM compiler v5)</h2><p>community的Keil license并不能支持ARMCC(ARM compiler v5)编译32K以上的项目，而一些老的严重依赖ARM v5项目移植到ARM v6不是很容易，还得用破解版ARMCC编译。</p>
<p>（1）下载ARM keygen2032注册机</p>
<p>（2）在File-&gt;License Management中deactive当前的community license，然后以管理员启动Keil，复制CID (Computer ID)到keygen，产生LIC</p>
<p>（3）禁用Keil联网：禁用UV4.exe出站规则 <a href="https://blog.csdn.net/weixin_41623723/article/details/105765273">https://blog.csdn.net/weixin_41623723/article/details/105765273</a></p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>Keil</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用CubeMX生成STM32代码</title>
    <url>/2024/03/12/STM32%20--%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CubeMX%E7%94%9F%E6%88%90STM32%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="如何使用CubeMX生成STM32代码"><a href="#如何使用CubeMX生成STM32代码" class="headerlink" title="如何使用CubeMX生成STM32代码"></a>如何使用CubeMX生成STM32代码</h1><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>STM32F0的firmware工程文件.ioc用CubeMX打开，如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405292028057.png" alt="image-20240529202815926"></p>
<p>现在要移植一些外设配置到STM32F4，使用UART2为示例：</p>
<p>1.对照F0的工程界面，打开F4的工程界面，搜索要配置的Pin，设置Pin模式和F0一致，为UART2_TX</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405292030441.png" alt="image-20240529203013390">2.对照F0的工程界面，打开F4的工程界面，配置UART2_TX的详细工作模式，例如波特率，中断…</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405292031748.png" alt="image-20240529203142664"></p>
<p>3.配置完毕后，点generate code生成代码</p>
<p>4.理解代码和工程配置的对应关系：</p>
<p>一般自动生成的代码都在Core里面：</p>
<p>（1）main查看该外设的初始化代码</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405292032897.png" alt="image-20240529203258870"></p>
<p>（2）中断查看中断配置相关的代码：it.c实现回调</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405292034688.png" alt="image-20240529203407652"></p>
<p>（2）msp是该外设的最底层配置，main的初始化和中断回调都以此配置为前提生效。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405292034549.png" alt="image-20240529203455499"></p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32--Firmware Architecture part2：业务代码分析</title>
    <url>/2024/10/30/STM32--Firmware%20Architecture%20part2%EF%BC%9ABMS%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AJEV323%E5%92%8CSkyways/</url>
    <content><![CDATA[<h1 id="STM32–Firmware-Architecture-part2：业务代码分析–o2link-FWs"><a href="#STM32–Firmware-Architecture-part2：业务代码分析–o2link-FWs" class="headerlink" title="STM32–Firmware Architecture part2：业务代码分析–o2link FWs"></a>STM32–Firmware Architecture part2：业务代码分析–o2link FWs</h1><h1 id="o2link-FWs的架构区别"><a href="#o2link-FWs的架构区别" class="headerlink" title="o2link FWs的架构区别"></a>o2link FWs的架构区别</h1><p>o2link FWs指三类：</p>
<ul>
<li>o2link original FW(gen2): 用于老项目的对外发布版FW</li>
<li>o2link JEV323 FW: 在o2link original FW上，针对JEV323做了功能改动和架构改动</li>
<li>o2link Skyways FW: 在o2link original FW上，针对Skyways做了功能改动</li>
</ul>
<h2 id="Bootloader和Firmware结构"><a href="#Bootloader和Firmware结构" class="headerlink" title="Bootloader和Firmware结构"></a>Bootloader和Firmware结构</h2><h3 id="bootloader和Firmware在Flash的分布"><a href="#bootloader和Firmware在Flash的分布" class="headerlink" title="bootloader和Firmware在Flash的分布"></a>bootloader和Firmware在Flash的分布</h3><ol>
<li>o2link original FW和o2link Skyways FW是分为bootloader和Firmware两部分，两者共同构成烧录的bin文件</li>
</ol>
<ul>
<li><p>bootloader：放在Flash的0x0800_0000 ~ 0x0x0800_8000空间，空间32KB；用作USB上位机烧录Firmware到Flash功能。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171036206.png" alt="image-20240517103655180"></p>
</li>
<li><p>Firmware: 放在Flash的0x0800_8000~ 0x0801_0000空间，空间32KB；用作处理USB上位机下发的各种控制、读写请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171037852.png" alt="image-20240517103700830"></p>
<p>bootloader和Firmware所有代码在Flash的分布如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171117725.png" alt="image-20240517111755697"></p>
<p>注意：ROM&#x2F;RAM空间分布对应到.sct的配置内容需要特别小心：</p>
<p>Bootloader的.sct:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00008000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00008000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x200000C0 0x00003F30  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Firmware的.sct: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x08008000 0x00008000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08008000 0x00008000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x200000C0 0x00003F30  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有正确配置.sct, 例如把Firmware的.sct LR&#x2F;ER起始地址配成0x0800_0000,后面用JLink烧录时就报错：No Algorithm for 0x80000000~0x….，Flash program fail. 因为JLink发现program的地址和.sct指定的LR&#x2F;ER地址不一致。</p>
<p>2.o2link JEV323 FW是简化后的架构，只包含firmware部分，不支持USB上位机烧录FW bin：</p>
<ul>
<li><p>Firmware: 放在Flash的0x0800_0000~ 0x0801_0000空间，空间64KB；用作处理USB上位机下发的各种控制、读写请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171037152.png" alt="image-20240517103730129"></p>
</li>
</ul>
<p>3.RAM空间的分布</p>
<p>上面bootloader+FW架构的Keil配置中，bootloader和FW的RAM空间都是从0xC0偏移开始的，不是从RAM的0x00，</p>
<p>而单FW架构，FW是从RAM的0开始。</p>
<p>原因是bootloader跳转执行FW时，需要从Flash拷贝中断向量表192bytes(0xC0)到RAM起始地址，所以FW代码的RAM数据区不划分这块空间。详见direct_jump_to_app()</p>
<h3 id="IAP和ICP的概念"><a href="#IAP和ICP的概念" class="headerlink" title="IAP和ICP的概念"></a>IAP和ICP的概念</h3><p>为什么有两种代码结构分布？涉及到以下两种烧录Firmware的方式：参考STM32 RM0091文档</p>
<p>• IAP (in-application programming): IAP is the ability to re-program the flash memory of a microcontroller while the user program is running.</p>
<p>• ICP (in-circuit programming): ICP is the ability to program the flash memory of amicrocontroller using the JTAG protocol, the SWD protocol or the bootloader while thedevice is mounted on the user application board.</p>
<p>o2link作为成熟的产品，需要支持用户侧烧录firmware(IAP)，因此开发了USB接口的IAP烧录功能，这部分划分为bootloader。</p>
<blockquote>
<p>An important requirement for most Flash-memory-based systems is the ability to update firmware when installed in the end product. This ability is referred to as in-application programming (IAP).</p>
<p>The IAP code uses the USB to:</p>
<p>● Download a binary file from the USB HID to the STM32F0xx’s internal Flash memory.</p>
<p>● Upload the STM32F0xx’s internal Flash memory content (starting from the defined user </p>
<p>application address) into a binary file.</p>
<p>● Execute the user program.</p>
</blockquote>
<p>（实质上这不是真正意义的bootloader，仅仅是firmware update功能；如果firmware代码在SRAM运行，这部分功能完全可以做到Firmware代码中去，不用占用32KB空间）</p>
<p>jev323 firmware目前是内部测试用，因此不需要IAP，用Jlink的ICP方式烧录。全部Flash空间(64KB)可用于业务流程。</p>
<h3 id="bootloader和firmware的执行流程"><a href="#bootloader和firmware的执行流程" class="headerlink" title="bootloader和firmware的执行流程"></a>bootloader和firmware的执行流程</h3><p>参考o2link spec:</p>
<ul>
<li><p>bootloader基本逻辑是：每次上电RESET时，先执行bootloader判断当前Flash的firmware区域（app）有没有valid FW能执行？如果有，就跳转firmware的main去执行；如果没有，bootloader启动IAP流程，响应USB上位机的erase flash、program firmware的指令，完成以后再跳转执行firmware指令；</p>
</li>
<li><p>firmware在执行时，如果收到USB上位机的IAP命令(USB_IAP_JUMP_TO_BOOT)，就是要跳转到bootloader，准备IAP去下载新的firmware bin；其他情况不会跳转到bootloader。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171055206.png" alt="image-20240517105536135"></p>
<h2 id="bootloader代码分析（重要-难点）"><a href="#bootloader代码分析（重要-难点）" class="headerlink" title="bootloader代码分析（重要+难点）"></a>bootloader代码分析（重要+难点）</h2><p>整个bootloader代码和Firmware流程都是main初始化+While1轮询USB请求的结构，区别在于执行流程。</p>
<h3 id="bootloader校验FW"><a href="#bootloader校验FW" class="headerlink" title="bootloader校验FW"></a>bootloader校验FW</h3><p>bootloader的main初始化系统时钟后，就立即check FW是否valid：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	HAL_Init();</span><br><span class="line">	SystemClock_Config();</span><br><span class="line">	//判断FW是否valid</span><br><span class="line">	check_if_jump_to_app();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_if_jump_to_app():</span><br><span class="line"></span><br><span class="line">    if(*(uint32_t *)RAM_FROM_APP_FLAG_ADDR != RAM_FROM_APP_FLAG_DATA)&#123;</span><br><span class="line">            *(uint32_t *)RAM_FROM_APP_FLAG_ADDR = 0;</span><br><span class="line">            if((*(uint32_t *)APP_FILE_EDN_ADDR == APP_FILE_END_DATA) &amp;&amp; </span><br><span class="line">                ( *(uint32_t *)APP_FILE_START_ADDR == APP_FILE_START_DATA) &amp;&amp;</span><br><span class="line">                (pin_state == GPIO_PIN_SET)) //PB4</span><br><span class="line">                direct_jump_to_app();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>校验FW有效包括三个条件都要满足：</p>
<ol>
<li>查看RAM 0x3f3C位置(0x20003f3C)的DWORD是否为RAM_FROM_APP_FLAG_DATA(0x6a756d70)，然后清0。这个flag是USB上位机下发USB_IAP_JUMP_TO_BOOT时调用jump_to_boot()设置的，这个USB请求在bootloader或FW阶段都可能被发起。</li>
</ol>
<p>​      目的：确认是上位机发起的jump to boot，而不是其他原因比如CPU异常reset进入的boot。</p>
<ol start="2">
<li><p>查看Flash的FW区域（0x0800_8000开始）的开始（0x08008014）和尾部区域（0x0800fffc）的两个DWORD是否分别为0x00617070和0x00656e64。</p>
<p>目的：确认Flash的FW是valid，确认尾部是确保数据完整</p>
</li>
<li><p>查看PB4 pin是否为高。</p>
<p>目的：根据原例图，可能是防止和one-wire功能冲突？待确认</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171138048.png" alt="image-20240517113801021"></p>
</li>
</ol>
<h3 id="bootloader跳转到FW代码的过程"><a href="#bootloader跳转到FW代码的过程" class="headerlink" title="bootloader跳转到FW代码的过程"></a>bootloader跳转到FW代码的过程</h3>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">direct_jump_to_app():</span><br><span class="line"></span><br><span class="line">#define  APPLICATION_ADDRESS   (0x08000000 + 0x8000) //FW在Flash的起始地址 </span><br><span class="line"></span><br><span class="line">void direct_jump_to_app(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	uint32_t JumpAddress;</span><br><span class="line">	pFunction Jump_To_Application;</span><br><span class="line">	</span><br><span class="line">	__disable_irq(); </span><br><span class="line">	</span><br><span class="line">	//拷贝Firmwware的192bytes的中断向量表到SRAM</span><br><span class="line">	for(i = 0; i &lt; 48; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		*((uint32_t*)(0x20000000 + (i &lt;&lt; 2)))=*(__IO uint32_t*)(APPLICATION_ADDRESS + (i&lt;&lt;2));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 /* Test if user code is programmed starting from address &quot;APPLICATION_ADDRESS&quot; */</span><br><span class="line">	 //判断栈指针是否位于SRAM</span><br><span class="line">	if (((*(__IO uint32_t*)APPLICATION_ADDRESS) &amp; 0x2FFE0000 ) == 0x20000000)</span><br><span class="line">    &#123; /* Jump to user application */</span><br><span class="line">      </span><br><span class="line">      	//设置函数指针，跳转到Firmware的RESET入口</span><br><span class="line">		JumpAddress = *(__IO uint32_t*) (APPLICATION_ADDRESS + 4);</span><br><span class="line">		Jump_To_Application = (pFunction) JumpAddress;</span><br><span class="line">		</span><br><span class="line">		/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">		__set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);</span><br><span class="line">		</span><br><span class="line">		//执行跳转</span><br><span class="line">		Jump_To_Application();</span><br><span class="line">	&#125;  </span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		__enable_irq();</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（1）拷贝Firmwware的192bytes的中断向量表到SRAM</strong></p>
<p><strong>Q1：为什么要拷贝？中断向量表放在Flash中不能执行吗？</strong></p>
<p>Cortex M0的限制：Flash的中断向量表一定要放在Flash开始的地方，不能relocation到Flash的其他偏移地址，参考Reference Manual RM0091：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171723698.png" alt="image-20240517172328661"></p>
<p>Firmware中断向量表是放在Flash的32KB offset的地方，是不能被硬件使用的；</p>
<p>RM0091给出Cortex M0对此问题的方案：将中断向量表拷贝到SRAM的0地址，再设置SYSCFG register，remap SRAM空间作为CPU 0地址。这样CPU异常、中断发生时，就能进入SRAM的中断向量表。</p>
<p><strong>Q2：为什么只需要拷贝中断向量表的192bytes，而不是拷贝整个Firmware的32KB？SRAM空间都remap为CPU 0地址了，Flash中的Firmware代码不拷贝到SRAM还能执行到吗？</strong></p>
<p>这里要分析MCU的PC指针取指令的流程：</p>
<ol>
<li>在bootloader开始阶段，PC指针取指令都是在Flash 起始地址~32KB之间取bootloader指令执行</li>
<li>bootloader拷贝FW中断向量表到SRAM的0地址，并设置CPU memory空间为SRAM空间 (注释1)</li>
<li>bootloader跳转，注意看上面代码，跳转到Flash的Firmware空间(Flash 32KB~64KB)的Firmware入口，也就是说，PC指针还是从Flash取指令，只不过指令是Firmware的main</li>
<li>Firmware执行main初始化和while1，PC指针始终在while1中转圈</li>
<li>如果中断或者异常发生，硬件跳转到SRAM的Firmware中断向量表，取中断回调指令执行，这个中断回调指令还是在Flash的Firmware空间(Flash 32KB~64KB)，中断返回后，PC指针恢复之前在Firmware while1里的位置。</li>
</ol>
<p>根据以上分析，PC指针仅仅在中断发生时需要用跳到SRAM的中断向量表，其他时间都在Flash的Firmware区域取指令，所有Firmware代码都能被执行到。因此SRAM remap不影响Flash的代码执行，不需要拷贝Firmware代码到SRAM (要拷贝FW到SRAM以提高执行速度也行，要改Firmware编译的基地址为SRAM)。</p>
<p>（注释1）CPU remap实际在main才设置（但应该在bootloader里设置），代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__HAL_REMAPMEMORY_SRAM();</span><br><span class="line"></span><br><span class="line">#define __HAL_REMAPMEMORY_SRAM                __HAL_SYSCFG_REMAPMEMORY_SRAM</span><br><span class="line">#define __HAL_SYSCFG_REMAPMEMORY_SRAM()         do &#123;SYSCFG-&gt;CFGR1 &amp;= ~(SYSCFG_CFGR1_MEM_MODE); \</span><br><span class="line">                                             SYSCFG-&gt;CFGR1 |= (SYSCFG_CFGR1_MEM_MODE_0 | SYSCFG_CFGR1_MEM_MODE_1); \</span><br><span class="line">                                            &#125;while(0) </span><br></pre></td></tr></table></figure>

<p><strong>关于CPU空间的remapping，有两个概念需清楚：</strong></p>
<ol>
<li><p>CPU空间remap到SRAM还是Flash，并不影响CPU对Flash和SRAM的访问；</p>
<p>不管谁被remap为CPU memory空间，pc取指令都可以用0x0800_0000 + offset访问Flash，0x2000_0000 + offset访问SRAM</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171747713.png" alt="image-20240517174752681"></p>
</li>
<li><p>CPU remap只影响”MCU的0地址在哪个设备空间“，和启动位置相关；</p>
<p>SYSCFG register的CPU memory mapping定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171745110.png" alt="image-20240517174553060"></p>
<p>注意该SYSCFG register配置会被reset，即reset启动后的CPU space是BOOT0 pin和nBOOT1 register共同决定的：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171756653.png" alt="image-20240517175619616"></p>
</li>
</ol>
<p><strong>Q3：Firmware和bootloader的中断向量表的指令应该差不多，为什么不能公用一套中断向量表？</strong></p>
<p>这个问题涉及到编译和链接：bootloader和Firmware的中断向量表的指令还是有区别，因为中断回调不同，导致必须要分两套中断向量表；</p>
<p>两套中断向量表编译出的基础地址不一样：如下图bootloader中断向量表指令都是基于0x0800_8000，FW的都是0x0800_0000。这个基础地址是.sct链接文件指定。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171859345.png" alt="image-20240517185911311"></p>
<p><strong>（2）跳转到Firmwware指令</strong></p>
<p>跳转的条件判断是个难点：为什么要判断FW代码的首个DWORD的值是否在SRAM空间？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (((*(__IO uint32_t*)APPLICATION_ADDRESS) &amp; 0x2FFE0000 ) == 0x20000000)</span><br></pre></td></tr></table></figure>

<p>FW代码的首个DWORD的值是什么：</p>
<p>参考FW的startup.s：是__initial_sp符号，找不到具体指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp                   ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                  ; Reset Handler</span><br></pre></td></tr></table></figure>

<p>__initial_sp符号符号是什么：</p>
<p>FW的startup.s只能找到声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack_Size		EQU     0x500</span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br></pre></td></tr></table></figure>

<p>对此代码的解释：</p>
<p>__initial_sp is a label which takes the origin (ORG) value of the assembler after it allocates the space. Look at a .LST or .MAP file.</p>
<p>参考：<a href="https://community.st.com/t5/stm32-mcus-products/about-initial-sp/td-p/551812">https://community.st.com/t5/stm32-mcus-products/about-initial-sp/td-p/551812</a></p>
<p>基于此解释，查看FW的.map，找到symbol的分布：</p>
<p>最后一个Data symbol是uwTick，尾部地址是0x20003514 + 4 &#x3D; 0x20003518；</p>
<p>__initial_sp符号的起始地址正好是0x20003518 + 0x500（startup.s指定的Stack_Size），因此验证了以上解释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Global Symbols</span><br><span class="line"></span><br><span class="line">    Symbol Name                              Value     Ov Type        Size  Object(Section)</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">    huart1                                   0x20001a3c   Data         132  usart.o(.bss.huart1)</span><br><span class="line">    huart2                                   0x20001ac0   Data         132  usart.o(.bss.huart2)</span><br><span class="line">    huart3                                   0x20001b44   Data         132  usart.o(.bss.huart3)</span><br><span class="line">    one_wire_data                            0x20001fcc   Data         152  one_wire.o(.bss.one_wire_data)</span><br><span class="line">    uart_rx_fifo_buf                         0x20002064   Data        5120  main.o(.bss.uart_rx_fifo_buf)</span><br><span class="line">    uwTick                                   0x20003514   Data           4  stm32f0xx_hal.o(.bss.uwTick)</span><br><span class="line">    __initial_sp                             0x20003a18   Data           0  startup_stm32f072xb.o(STACK)</span><br></pre></td></tr></table></figure>

<p>基于以上，__initial_sp 是编译器自动形成的值，作为RAM中的栈顶位置。</p>
<p>bootloader设置Stack_Size为0x500，编译器就在RAM中把所有全局变量排列完后，在加0x500作为栈空间，也就是说这个值最后是取决于代码数据占的RAM空间的，并不是固定的RAM最尾部的地址。</p>
<p>注：Stack_Size值应该根据.map情况，设置成和RAM可用栈空间接近，不然RAM空间没充分利用，形成爆栈。</p>
<p>所以FW的第一个指令保存了RAM中的栈顶（栈起始地址），第二个指令才是RESET。</p>
<p>前面代码是bootloader对__initial_sp 判断是否在RAM空间，因为跳转时要设置栈指针的安全性判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">__set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);</span><br></pre></td></tr></table></figure>

<p><strong>（3）Jump_To_Application函数指针</strong></p>
<p>这里不详细分析。STM32 bootloader跳转FW有模板代码，参考原厂固件库代码。</p>
<h2 id="Flash烧录问题（重要）"><a href="#Flash烧录问题（重要）" class="headerlink" title="Flash烧录问题（重要）"></a>Flash烧录问题（重要）</h2><h3 id="用Keil的JLink烧录Flash"><a href="#用Keil的JLink烧录Flash" class="headerlink" title="用Keil的JLink烧录Flash"></a>用Keil的JLink烧录Flash</h3><p>Keil内置安装JLink，Keil烧录.bin到开发板的Flash，实际是调用内置的JLink烧录。</p>
<p>对于Bootloader和Firmware，需要正确配置烧录区域：</p>
<ul>
<li>Address Range： .bin文件烧录到Flash的区域(一般是Flash空间)；这个区域应该和Keil项目配置的ROM区域一致</li>
<li>Erase Sectors：只擦除选中的Flash Address Range的sectors</li>
<li>RAM for Algorithm：这个跟烧录的.bin运行时RAM没关系，是指烧录程序本身要占用的RAM，参考：<a href="https://www.keil.com/support/man/docs/ulinkme/ulinkme_su_ram_for_algorithm.htm">https://www.keil.com/support/man/docs/ulinkme/ulinkme_su_ram_for_algorithm.htm</a></li>
</ul>
<p>o2link的bootloader：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201046576.png" alt="image-20240520104651534"></p>
<p>o2link的firmware：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201047437.png" alt="image-20240520104700405"></p>
<h3 id="如何确认Flash正确烧录"><a href="#如何确认Flash正确烧录" class="headerlink" title="如何确认Flash正确烧录"></a>如何确认Flash正确烧录</h3><p>参考： <a href="https://blog.csdn.net/lnfiniteloop/article/details/134575496?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-134575496-blog-118443669.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-134575496-blog-118443669.235%5Ev43%5Epc_blog_bottom_relevance_base4&utm_relevant_index=2">J-Flash读取STM32内部程序，导出Hex&#x2F;Bin文件</a></p>
<p>JLink安装，需要安装包里的USB驱动：SEGGER\JLink_V796e\USBDriver\x64\dpinst_x64.exe</p>
<p>使用JLink读Flash并比较：</p>
<ol>
<li>JLink: Target -&gt; Connect</li>
<li>读Flash(一般Range或者Entire chip)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112900.png" alt="image-20240520111220863"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112614.png" alt="image-20240520111250598"></p>
<ol start="3">
<li>保存数据到.bin</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112851.png" alt="image-20240520111256831"></p>
<ol start="4">
<li>比较bootloader.bin和从Flash读出的数据.bin是否一致：</li>
</ol>
<p>使用Winmerge比较二进制文件：</p>
<p>左侧bootloader.bin，右侧Flash读出的bootloader；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201104475.png" alt="image-20240520110440432"></p>
<p>可见bootloader真实数据约0x7524 bytes；Flash擦除整个bootloader区域0~0x8000, 所以Flash读的后部分数据为0xFF。</p>
<p>Firmware区域比较同理，JLink的Flash读出区域改成0x08008000~0x08010000</p>
<h2 id="特殊的编译和代码修改记录"><a href="#特殊的编译和代码修改记录" class="headerlink" title="特殊的编译和代码修改记录"></a>特殊的编译和代码修改记录</h2><p>编译问题：</p>
<ol>
<li><p>Firmware编译无法输出.bin文件但Keil没报错，输出了ER$$.ARM.__at_0x0800fffc文件</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201155089.png" alt="image-20240520115554066"></p>
<p>原因：main定义了以下section，但链接器找不到这个符号，所以生成bin时报error</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const uint32_t file_end __attribute__((section(&quot;.ARM.__at_0x0800fffc&quot;))) = 0x00656e64;</span><br></pre></td></tr></table></figure>

<p>目前没找到根本性的解决办法；因为代码没用到这个file_end，所以注释掉这个定义。这个定义地址本身是合理的，是Firmware的Flash区域的最后一个DWORD。</p>
<p>参考：</p>
<p><a href="https://developer.arm.com/documentation/dui0474/m/scatter-loading-features/root-execution-regions/methods-of-placing-functions-and-data-at-specific-addresses?lang=en">Methods of placing functions and data at specific addresses</a></p>
<p><a href="https://documentation-service.arm.com/static/63eb51fc9567172d4e2aa918">ARM asmlink User Guide</a></p>
</li>
</ol>
<p>代码问题：</p>
<p>bootloader+Firmware只支持用USB上位机更新Firmware，不支持JLink烧录Firmware，因为bootloader校验Dword不通过；所以需要修改bootloader代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void check_if_jump_to_app(void):</span><br><span class="line"></span><br><span class="line">#ifdef SKYWAYS_TEST</span><br><span class="line">	direct_jump_to_app(); //这里直接跳转，不校验是USB上位机发起的跳转</span><br><span class="line">#else</span><br><span class="line">	if (*(uint32_t *)RAM_FROM_APP_FLAG_ADDR != RAM_FROM_APP_FLAG_DATA)</span><br><span class="line">	&#123;</span><br><span class="line">		*(uint32_t *)RAM_FROM_APP_FLAG_ADDR = 0;</span><br><span class="line">		if ((*(uint32_t *)APP_FILE_EDN_ADDR == APP_FILE_END_DATA) &amp;&amp;</span><br><span class="line">			(*(uint32_t *)APP_FILE_START_ADDR == APP_FILE_START_DATA) &amp;&amp;</span><br><span class="line">			(pin_state == GPIO_PIN_SET))</span><br><span class="line">			direct_jump_to_app();</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="Skyways业务代码分析"><a href="#Skyways业务代码分析" class="headerlink" title="Skyways业务代码分析"></a>Skyways业务代码分析</h1><p>在《STM32–Firmware Architecture part1：开发环境和HAL API应用》中已经分析了整体的Firmware-USB上位机之间的请求处理流程，这里针对Skyways Firmware具体分析业务流程的差异点。</p>
<h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><h3 id="USB下发数据给UART（TX-no-buffer）"><a href="#USB下发数据给UART（TX-no-buffer）" class="headerlink" title="USB下发数据给UART（TX, no buffer）"></a>USB下发数据给UART（TX, no buffer）</h3><p>调用过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CUSTOM_HID_OutEvent_FS -&gt; write_uart_function() -&gt; HAL_UART_Transmit()</span><br></pre></td></tr></table></figure>

<p>Skyways版本的UART TX代码有几点需要注意：</p>
<ol>
<li>usb_send_buf[0] |&#x3D; 0x80;表示错误，用于通知USB上位机。Tx一次发送超过60bytes, 或者HAL_UART_Transmit有Timeout，则上报USB上位机有错。</li>
<li>以下代码的UART返回数据没发送给USB，和o2link Spec不一致：UART没有返回USB：0101+buffer data.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void write_uart_function()</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t ret = 0;</span><br><span class="line">	uint32_t i;</span><br><span class="line">	length = usb_send_buf[2] &lt;&lt; 8 | usb_send_buf[3];</span><br><span class="line">	if(length &gt; MAX_UART_WRITE_LENGTH)&#123; //60bytes</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = UART_PARAMETER_ERROR;</span><br><span class="line">		usb_send(usb_send_buf,USB_TIMEOUT_TIME);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cdc_receive_flag = CDC_FLAG_HID;</span><br><span class="line">	ret = HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;usb_send_buf[4],length,UART_TIMEOUT_TIME);</span><br><span class="line"></span><br><span class="line">	if(ret)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = ret;</span><br><span class="line">		usb_send(usb_send_buf,USB_TIMEOUT_TIME);</span><br><span class="line">	&#125;</span><br><span class="line">	//usb_send(usb_send_buf,USB_TIMEOUT_TIME); //这里和o2link Spec不一致，UART没有返回USB：0101+buffer.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="USB从UART接收数据（RX-1KB-buffer-DMA）"><a href="#USB从UART接收数据（RX-1KB-buffer-DMA）" class="headerlink" title="USB从UART接收数据（RX, 1KB buffer, DMA）"></a>USB从UART接收数据（RX, 1KB buffer, DMA）</h3><p>代码流程在《STM32–Firmware Architecture part1：开发环境和HAL API应用》的”UART2部分”有详细分析。</p>
<p>应用上的结论：UART2 DMA使用UART IDLE frame作为传输完成中断的触发源，只要应用上保证一次UART读数据中没有异常的IDLE frame，则UART2 DMA IDLE frame产生的完成中断可作为一次完整的UART数据传输结束标志。</p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>Skyways的SPI data transmission底层操作在的”8.1 usb_to_spi”有详细描述，这里看到以下区别：</p>
<ul>
<li>发起spi数据传输之前，Deinit了I2C，把I2C的SDA&#x2F;SCL两个pin作为GPIO输入模式拉高。</li>
<li>完成spi数据传输之后，重新init了I2C到100K速度.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void usb_handle_process(void):</span><br><span class="line"></span><br><span class="line">case USB_TO_SKYWAY_SPI_WRITE:</span><br><span class="line">		HAL_I2C_DeInit(&amp;hi2c1);</span><br><span class="line">		i2c_gpio_fun();</span><br><span class="line">		usb_to_spi_convert_skyway_write();</span><br><span class="line">		MX_I2C1_Init(100000, 7);</span><br><span class="line">		break;</span><br><span class="line">case USB_TO_SKYWAY_SPI_READ:</span><br><span class="line">		HAL_I2C_DeInit(&amp;hi2c1);</span><br><span class="line">		i2c_gpio_fun();</span><br><span class="line">		usb_to_spi_convert_skyway_read();</span><br><span class="line">		MX_I2C1_Init(100000, 7);</span><br><span class="line">		break;</span><br></pre></td></tr></table></figure>

<p>根据Skyways和MCU的连接，SPI和I2C并没有复用；Skyways和MCU的SPI通信也没要求对I2C的pin做什么特殊操作（测试SPI read、write甚至都没连接I2C），因此猜测此处代码只是早期开发时，预防I2C和SPI同时使用时有冲突，实际没这个需求。 – 下个版本删除此I2C代码，测试SPI read、write.</p>
<h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><p>TODO</p>
<h2 id="one-wire"><a href="#one-wire" class="headerlink" title="one-wire"></a>one-wire</h2><p>TODO</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32--Firmware Architecture part1：开发环境和HAL API应用</title>
    <url>/2024/10/30/STM32--Firmware%20Architecture%20part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL%20API%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="STM32–Firmware-Architecture-part1：开发环境和HAL-API应用"><a href="#STM32–Firmware-Architecture-part1：开发环境和HAL-API应用" class="headerlink" title="STM32–Firmware Architecture part1：开发环境和HAL API应用"></a>STM32–Firmware Architecture part1：开发环境和HAL API应用</h1><h1 id="STM32–开发环境"><a href="#STM32–开发环境" class="headerlink" title="STM32–开发环境"></a>STM32–开发环境</h1><p>当前主流的几种方案：(软件免费，无法律风险)：</p>
<p>1.STM32CubeMX + Keil（社区版）+ VSCode：使用CubeMX快速创建工程并导出为MDK-ARM项目文件，使用Keil编译调试MDK-ARM项目包，使用VSCode编辑代码和版本管理。</p>
<p>优势：兼容老项目，资料最多；Keil的调试经验可以复用到其他非STM32 ARM芯片；</p>
<p><a href="https://www.keil.arm.com/mdk-community/">https://www.keil.arm.com/mdk-community/</a></p>
<p><a href="https://www.st.com/en/development-tools/stm32cubemx.html">https://www.st.com/en/development-tools/stm32cubemx.html</a></p>
<p>2.STM32CubeIDE：ST主推的方式，专用于ST32芯片的IDE，本质是STM32CubeMX + Eclipse IDE + ST的编译调试工具链。</p>
<p>优势：集成度最高；缺陷：只用于STM32</p>
<p><a href="https://www.st.com/en/development-tools/stm32cubeide.html#overview">https://www.st.com/en/development-tools/stm32cubeide.html#overview</a></p>
<p>3.VSCode + ARM&#x2F;ST插件 + GDB + OpenOCD + + STM32CubeMX</p>
<p>优势：通用性最强，对各类ARM&#x2F;RISCV等SOC都适用此方案。</p>
<p>缺陷：资料少，GDB debug效率没有Keil高。</p>
<p><a href="https://stm32world.com/wiki/STM32_development_and_debugging_using_VSCode">https://stm32world.com/wiki/STM32_development_and_debugging_using_VSCode</a></p>
<p>结论：对于生产环境的STM32开发还是首选方案1，Keil社区版的功能和付费版基本一致。</p>
<h1 id="STM32–必读手册和固件"><a href="#STM32–必读手册和固件" class="headerlink" title="STM32–必读手册和固件"></a>STM32–必读手册和固件</h1><h2 id="STM32开发手册"><a href="#STM32开发手册" class="headerlink" title="STM32开发手册"></a>STM32开发手册</h2><p>helps-&gt;docs &amp; resource, 下载F0系列的：</p>
<p>Data Sheet(DS), Reference Manual(RM), Programming Manual(PM). </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101741846.png" alt="image-20240510174102795"></p>
<p>此外还有F1系列才有的<strong>User Manual UM1850</strong>，里面详细介绍各外设Driver的设计标准和API如何使用，对F0的Firmware也是通用，去ST官网下载。</p>
<h2 id="STM32固件包"><a href="#STM32固件包" class="headerlink" title="STM32固件包"></a>STM32固件包</h2><p>CubeMX&#x2F;CubeMXIDE首次运行STM32工程会要求安装STM32FXX的固件包，路径：CubeMX工程管理页面 -&gt; Firmware Package Path</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101708801.png" alt="image-20240510170810653"></p>
<p>原厂固件包的作用：</p>
<p>1.固件包是MCU厂商提供，学习任何一种MCU应该首先参考原厂固件包，不然容易被第三方教程误导。</p>
<p>2.对于STM32CubeMX, 其创建工程的原理是从固件包拷贝现成的模板代码，再根据用户在GUI界面配置的外设功能参数，自动输出项目代码。这个操作类似于VisualStudio开发MFC&#x2F;WinForm GUI应用，GUI模块被自动生成C#代码。</p>
<p>对于STM32F072xb的固件包，重点关注：</p>
<p>1.固件说明文档：STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Documentation\STM32CubeF0GettingStarted.pdf</p>
<p>2.模板代码和示例代码：STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Projects\STM32072B_EVAL\Examples</p>
<p>3.User Manual：整个固件库的代码文档，一般用HAL库关键词索引完整API定义</p>
<p>STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Drivers\STM32F0xx_HAL_Driver\STM32F072xB_User_Manual.chm</p>
<h2 id="小结：STM32项目的代码架构"><a href="#小结：STM32项目的代码架构" class="headerlink" title="小结：STM32项目的代码架构"></a>小结：STM32项目的代码架构</h2><p>根据开发手册和固件包文档做个小结。</p>
<p>STM32固件的架构，这也是STM32 Firmware项目的基本架构：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131502283.png" alt="image-20240513150236222"></p>
<ol>
<li>HAL和LL APIs是ST提供的STM32 chipset API，目的是hide theMCU and peripheral complexity to end user</li>
</ol>
<p>区别：</p>
<p>HAL drivers offer high-level and function-oriented APIs, with a high level of portability. Product&#x2F;IPs complexity is hidden for end users.</p>
<p>LL drivers offer low-layer APIs at registers level, with a better optimization but less portability. They require a deep knowledge of product&#x2F;IPs specifications.</p>
<p>HAL可以理解为硬件协议层，不直接配置register level，只实现通信协议和硬件配置流程。</p>
<p>LL是register level，完全不涉及通信协议和设备流程性的配置。</p>
<p>SysTick interrupts 只能在HAL使用，LL API无法调用SysTick interrupts，因为SysTick实际上是Hardware Timer的应用，而不是操作timer本身。</p>
<ol start="2">
<li><p>CMSIS（Cortex Microcontroller Software Interface Standard)  ARM指定的Cortex-M 硬件抽象层标准</p>
</li>
<li><p>Middleware：相当于应用层的基础库。The middleware is a set of libraries covering USB Device Libraries, STMTouch touch sensing, STemWin, FreeRTOS and FatFS</p>
</li>
</ol>
<h1 id="STM32–编译过程"><a href="#STM32–编译过程" class="headerlink" title="STM32–编译过程"></a>STM32–编译过程</h1><p>对于嵌入式代码的分析，首先应该看Makefile，去总览项目结构和编译过程。</p>
<p>以下有两种编译生态：</p>
<ol>
<li><p>Keil style：在Keil中编译MDK-ARM工程，编译过程被Keil隐藏到项目配置中；</p>
</li>
<li><p>Makefile style：CubeMX将MDK-ARM工程输出为Makefile工程，能一次看清整个编译过程。</p>
</li>
</ol>
<h2 id="Keil-style"><a href="#Keil-style" class="headerlink" title="Keil style"></a>Keil style</h2><h3 id="Keil编译配置"><a href="#Keil编译配置" class="headerlink" title="Keil编译配置"></a>Keil编译配置</h3><p>指定ARM编译器，指定代码目标是RAM\Flash位置的基地址</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102037591.png" alt="image-20240510203738554"></p>
<p>指定输出文件</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039243.png" alt="image-20240510203910212"></p>
<p>链接输出的符号总览文件.map</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039879.png" alt="image-20240510203928847"></p>
<p>编译的后处理过程，从hex生产bin</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102040886.png" alt="image-20240510204028853"></p>
<p>指定代码优化级别，警告级别，语言标准；指定头文件，组合成编译参数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102042899.png" alt="image-20240510204213867"></p>
<p>指定汇编器，一些伪汇编符号语法(syntax)和汇编器类型相关，例如Arm syntax和GUN syntax有很大差异</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102043211.png" alt="image-20240510204344181"></p>
<p>指定链接文件(scatter file), 功能对应Makefile的.ld链接脚本文件，用于指定各段分布。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102047297.png" alt="image-20240510204720264"></p>
<p>Debug和JLink烧录的配置，这里勾选JLink烧录后自动reset启动新程序:</p>
<p>这里实际是Keil调用JFlash烧写，需要指定Flash地址和大小，一般和Keil项目配置的ROM区间一致</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405170952108.png" alt="image-20240517095249013"></p>
<p>项目的目录配置中指定哪些.c参与编译:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102059394.png" alt="image-20240510205959362"></p>
<h3 id="Keil链接配置"><a href="#Keil链接配置" class="headerlink" title="Keil链接配置"></a>Keil链接配置</h3><p>Keil的链接脚本是.sct文件，链接配置的主要作用是在对.o文件链接时，指定链接基础地址，指定排列顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">LR_IROM1 0x08000000 0x00020000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00020000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00004000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个比较重要的概念：</p>
<ol>
<li>加载域与执行域</li>
</ol>
<p>LR： Load Address，MCU从哪个空间加载代码</p>
<p>ER：Execute Address，MCU在哪个空间执行代码</p>
<p>以上STM32链接脚本，所有Flash的代码(IROM: *.o, RO, XO)的执行域和加载域都是Flash(0x08000000 ~ 0x00020000)，且指定bootloader entry：RESET为最开始执行的函数。</p>
<p>RAM的代码(IRAM: RW, ZI)加载域是SRAM，这部分是数据是运行时直接在RAM初始化，不需要从Flash取指令。</p>
<p><img src="https://img-blog.csdnimg.cn/d8d908434dad4d18b654fdbefa5778b9.png#pic_center" alt="img"></p>
<p>下图示例是执行Flash的RO data时，RW数据段（有初始值的数据）应该被bootloader拷贝到RAM。</p>
<p><img src="https://img-blog.csdnimg.cn/fa87d75e57db492e8a86582baf8971be.png#pic_center" alt="img"></p>
<ol start="2">
<li>代码段，数据段，BSS段…</li>
</ol>
<p>STM32的代码段分布如下表, 其中CODE（包括RO&#x2F;RW CODE和TEXT），DATA(RO&#x2F;RW DATA)，ZI(BSS) 即常规意义的可执行程序的三段。</p>
<p>在.sct链接脚本中对应：RO，RW和ZI(zero initialized )<br>      RO是程序中的指令和常量<br>      RW是程序中已初始化变量<br>      ZI是程序中未初始化或初始化为0的变量</p>
<p><img src="https://img-blog.csdnimg.cn/4ccfeec4537a4a40ad5a8102707c2705.png" alt="img"></p>
<p>参考：<a href="https://blog.csdn.net/apythonlearner/article/details/133034055">【STM32】sct 分散加载文件的格式与应用</a></p>
<h2 id="Makefile-style"><a href="#Makefile-style" class="headerlink" title="Makefile style"></a>Makefile style</h2><h3 id="makefile编译配置"><a href="#makefile编译配置" class="headerlink" title="makefile编译配置"></a>makefile编译配置</h3><p>将已有的CubeMX+MDK工程输出为Makefile工程，产生Makefile和STM32F072C8Tx_FLASH.ld文件.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102056555.png" alt="image-20240510205610521"></p>
<p>Makefile分析：</p>
<p>指定编译目标，debug和优化级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># target</span><br><span class="line">TARGET = stm32f072c8t6</span><br><span class="line"># debug build?</span><br><span class="line">DEBUG = 1</span><br><span class="line"># optimization</span><br><span class="line">OPT = -Og</span><br></pre></td></tr></table></figure>

<p>指定参与编译的源码.c和.s  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># C sources</span><br><span class="line">C_SOURCES =  \</span><br><span class="line">Core/Src/main.c \</span><br><span class="line">Core/Src/gpio.c \</span><br><span class="line">Core/Src/can.c \</span><br><span class="line">Core/Src/i2c.c \</span><br><span class="line">Core/Src/spi.c \</span><br><span class="line">Core/Src/usart.c \</span><br><span class="line">Core/Src/stm32f0xx_it.c \</span><br><span class="line">Core/Src/stm32f0xx_hal_msp.c \</span><br><span class="line">....</span><br><span class="line">Core/Src/system_stm32f0xx.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_ctlreq.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_ioreq.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Class/CustomHID/Src/usbd_customhid.c \</span><br><span class="line">Core/Src/sysmem.c \</span><br><span class="line">Core/Src/syscalls.c </span><br><span class="line"></span><br><span class="line"># ASM sources</span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">startup_stm32f072xb.s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定目标平台的编译器和链接器，指定输出hex&#x2F;bin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PREFIX = arm-none-eabi-</span><br><span class="line"></span><br><span class="line">CC = $(PREFIX)gcc</span><br><span class="line">AS = $(PREFIX)gcc -x assembler-with-cpp</span><br><span class="line">CP = $(PREFIX)objcopy</span><br><span class="line">SZ = $(PREFIX)size</span><br><span class="line"></span><br><span class="line">HEX = $(CP) -O ihex</span><br><span class="line">BIN = $(CP) -O binary -S</span><br></pre></td></tr></table></figure>

<p>编译参数CFLAGS和ASFLAGS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU = -mcpu=cortex-m0</span><br><span class="line"># float-abi</span><br><span class="line">MCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)</span><br></pre></td></tr></table></figure>

<p>宏定义和头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># macros for gcc</span><br><span class="line"># AS defines</span><br><span class="line">AS_DEFS = </span><br><span class="line"></span><br><span class="line"># C defines</span><br><span class="line">C_DEFS =  \</span><br><span class="line">-DUSE_HAL_DRIVER \</span><br><span class="line">-DSTM32F072xB</span><br><span class="line"></span><br><span class="line"># AS includes</span><br><span class="line">AS_INCLUDES = </span><br><span class="line"></span><br><span class="line"># C includes</span><br><span class="line">C_INCLUDES =  \</span><br><span class="line">-ICore/Inc \</span><br><span class="line">-IUSB_DEVICE/App \</span><br><span class="line">-IUSB_DEVICE/Target \</span><br><span class="line">-IDrivers/STM32F0xx_HAL_Driver/Inc \</span><br><span class="line">-IDrivers/STM32F0xx_HAL_Driver/Inc/Legacy \</span><br><span class="line">-IMiddlewares/ST/STM32_USB_Device_Library/Core/Inc \</span><br><span class="line">-IMiddlewares/ST/STM32_USB_Device_Library/Class/CustomHID/Inc \</span><br><span class="line">-IDrivers/CMSIS/Device/ST/STM32F0xx/Include \</span><br><span class="line">-IDrivers/CMSIS/Include</span><br></pre></td></tr></table></figure>

<p>最终的完整GCC FLAGS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># compile gcc flags</span><br><span class="line">ASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line">CFLAGS += $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br></pre></td></tr></table></figure>

<p>链接脚本与库路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># link script</span><br><span class="line">LDSCRIPT = STM32F072C8Tx_FLASH.ld</span><br><span class="line"></span><br><span class="line"># libraries</span><br><span class="line">LIBS = -lc -lm -lnosys </span><br><span class="line">LIBDIR = </span><br><span class="line">LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections</span><br></pre></td></tr></table></figure>

<p>输出文件：elf + hex + bin，参考：[elf,hex,bin,axf的区别](# elf,hex,bin,axf的区别)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># default action: build all</span><br><span class="line">all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin</span><br></pre></td></tr></table></figure>

<p>编译执行部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># list of objects</span><br><span class="line">OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))</span><br><span class="line">vpath %.c $(sort $(dir $(C_SOURCES)))</span><br><span class="line"># list of ASM program objects</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))</span><br><span class="line">vpath %.s $(sort $(dir $(ASM_SOURCES)))</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASMM_SOURCES:.S=.o)))</span><br><span class="line">vpath %.S $(sort $(dir $(ASMM_SOURCES)))</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) </span><br><span class="line">	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)</span><br><span class="line">	$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(BUILD_DIR)/%.o: %.S Makefile | $(BUILD_DIR)</span><br><span class="line">	$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile</span><br><span class="line">	$(CC) $(OBJECTS) $(LDFLAGS) -o $@</span><br><span class="line">	$(SZ) $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	$(HEX) $&lt; $@</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	$(BIN) $&lt; $@	</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR):</span><br><span class="line">	mkdir $@</span><br></pre></td></tr></table></figure>

<p>清理编译输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">	-rm -fR $(BUILD_DIR)</span><br></pre></td></tr></table></figure>

<h3 id="makefile链接配置"><a href="#makefile链接配置" class="headerlink" title="makefile链接配置"></a>makefile链接配置</h3><p>GNU linker（LD）的语法参考：<a href="https://sourceware.org/binutils/docs/ld/index.html">GNU linker ld (GNU Binutils)</a></p>
<p>STM32F072C8Tx_FLASH.ld：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/* Entry Point */</span><br><span class="line">ENTRY(Reset_Handler)</span><br><span class="line"></span><br><span class="line">/* Highest address of the user mode stack */</span><br><span class="line">_estack = ORIGIN(RAM) + LENGTH(RAM);    /* end of RAM */</span><br><span class="line">/* Generate a link error if heap and stack don&#x27;t fit into RAM */</span><br><span class="line">_Min_Heap_Size = 0x300;      /* required amount of heap  */</span><br><span class="line">_Min_Stack_Size = 0x500; /* required amount of stack */</span><br><span class="line"></span><br><span class="line">/* Specify the memory areas */</span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 16K</span><br><span class="line">FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 64K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Define output sections */</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* The startup code goes first into FLASH */</span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    KEEP(*(.isr_vector)) /* Startup code */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* The program code and other data goes into FLASH */</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.text)           /* .text sections (code) */</span><br><span class="line">    *(.text*)          /* .text* sections (code) */</span><br><span class="line">    *(.glue_7)         /* glue arm to thumb code */</span><br><span class="line">    *(.glue_7t)        /* glue thumb to arm code */</span><br><span class="line">    *(.eh_frame)</span><br><span class="line"></span><br><span class="line">    KEEP (*(.init))</span><br><span class="line">    KEEP (*(.fini))</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _etext = .;        /* define a global symbols at end of code */</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* Constant data goes into FLASH */</span><br><span class="line">  .rodata :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.rodata)         /* .rodata sections (constants, strings, etc.) */</span><br><span class="line">    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH</span><br><span class="line">  .ARM : &#123;</span><br><span class="line">    __exidx_start = .;</span><br><span class="line">    *(.ARM.exidx*)</span><br><span class="line">    __exidx_end = .;</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .preinit_array     :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_start = .);</span><br><span class="line">    KEEP (*(.preinit_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .init_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.init_array.*)))</span><br><span class="line">    KEEP (*(.init_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .fini_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.fini_array.*)))</span><br><span class="line">    KEEP (*(.fini_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* used by the startup to initialize data */</span><br><span class="line">  _sidata = LOADADDR(.data);</span><br><span class="line"></span><br><span class="line">  /* Initialized data sections goes into RAM, load LMA copy after code */</span><br><span class="line">  .data : </span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _sdata = .;        /* create a global symbol at data start */</span><br><span class="line">    *(.data)           /* .data sections */</span><br><span class="line">    *(.data*)          /* .data* sections */</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _edata = .;        /* define a global symbol at data end */</span><br><span class="line">  &#125; &gt;RAM AT&gt; FLASH</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  /* Uninitialized data section */</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  .bss :</span><br><span class="line">  &#123;</span><br><span class="line">    /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">    _sbss = .;         /* define a global symbol at bss start */</span><br><span class="line">    __bss_start__ = _sbss;</span><br><span class="line">    *(.bss)</span><br><span class="line">    *(.bss*)</span><br><span class="line">    *(COMMON)</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _ebss = .;         /* define a global symbol at bss end */</span><br><span class="line">    __bss_end__ = _ebss;</span><br><span class="line">  &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">  /* User_heap_stack section, used to check that there is enough RAM left */</span><br><span class="line">  ._user_heap_stack :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">    PROVIDE ( end = . );</span><br><span class="line">    PROVIDE ( _end = . );</span><br><span class="line">    . = . + _Min_Heap_Size;</span><br><span class="line">    . = . + _Min_Stack_Size;</span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">  &#125; &gt;RAM</span><br></pre></td></tr></table></figure>

<h2 id="编译输出-elf-hex-bin-axf的区别"><a href="#编译输出-elf-hex-bin-axf的区别" class="headerlink" title="编译输出: elf,hex,bin,axf的区别"></a>编译输出: elf,hex,bin,axf的区别</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131142491.png" alt="image-20240513114246442"></p>
<h2 id="链接输出的-map符号表"><a href="#链接输出的-map符号表" class="headerlink" title="链接输出的.map符号表"></a>链接输出的.map符号表</h2><p>链接过程可以输出.map符号表，可用于分析代码和数据分布，再裁剪代码。</p>
<ol>
<li>ROM(Flash)的.hex&#x2F;bin文件的符号分布:</li>
</ol>
<p>可以看到，.sct指定的首个符号RESET在最开始位置，其他符号是链接器自动排列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Memory Map of the image</span><br><span class="line"></span><br><span class="line">  Image Entry point : 0x080000c1</span><br><span class="line"></span><br><span class="line">  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x000082f0, Max: 0x00020000, ABSOLUTE, COMPRESSED[0x00008148])</span><br><span class="line"></span><br><span class="line">    Execution Region ER_IROM1 (Exec base: 0x08000000, Load base: 0x08000000, Size: 0x00007f84, Max: 0x00020000, ABSOLUTE)</span><br><span class="line"></span><br><span class="line">    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object</span><br><span class="line"></span><br><span class="line">    0x08000000   0x08000000   0x000000c0   Data   RO            3    RESET               startup_stm32f072xb.o</span><br><span class="line">    0x080000c0   0x080000c0   0x00000000   Code   RO         2440  * .ARM.Collect$$$$00000000  mc_p.l(entry.o)</span><br><span class="line">    0x080000c0   0x080000c0   0x00000004   Code   RO         2728    .ARM.Collect$$$$00000001  mc_p.l(entry2.o)</span><br><span class="line">    0x080000c4   0x080000c4   0x00000004   Code   RO         2731    .ARM.Collect$$$$00000004  </span><br><span class="line">    </span><br><span class="line">    ....         </span><br><span class="line"></span><br><span class="line">mc_p.l(init.o)</span><br><span class="line">    0x08000244   0x08000244   0x00000020   Code   RO         2768    .text               mc_p.l(llshl.o)</span><br><span class="line">    0x08000264   0x08000264   0x00000056   Code   RO         2784    .text               mc_p.l(__dczerorl2.o)</span><br><span class="line">    0x080002ba   0x080002ba   0x00000002   PAD</span><br><span class="line">    0x080002bc   0x080002bc   0x00000064   Code   RO          769    .text.CDC_Control_FS  usbd_cdc_if.o</span><br><span class="line">    0x08000320   0x08000320   0x00000004   Code   RO          767    .text.CDC_DeInit_FS  usbd_cdc_if.o</span><br><span class="line">    0x08000324   0x08000324   0x00000024   Code   RO          765    .text.CDC_Init_FS   usbd_cdc_if.o</span><br><span class="line">    0x08000348   0x08000348   0x00000034   Code   RO          771    .text.CDC_Receive_FS  usbd_cdc_if.o</span><br><span class="line">    0x0800037c   0x0800037c   0x00000044   Code   RO          773    .text.CDC_Transmit_FS  usbd_cdc_if.o</span><br><span class="line">    0x080003c0   0x080003c0   0x00000010   Code   RO          136    .text.CEC_CAN_IRQHandler  stm32f0xx_it.o</span><br><span class="line">    0x080003d0   0x080003d0   0x00000004   Code   RO          750    .text.CUSTOM_HID_DeInit_FS  usbd_custom_hid_if.o</span><br><span class="line">    0x080003d4   0x080003d4   0x00000004   Code   RO          748    .text.CUSTOM_HID_Init_FS  usbd_custom_hid_if.o</span><br><span class="line"></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>RAM中的数据段分布，包括.data段和.bss段：</p>
<p>可以看到，有初始值和无初始值的全局变量分布在.data和.bss区域。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Execution Region RW_IRAM1 (Exec base: 0x20000000, Load base: 0x08007f88, Size: 0x000021b8, Max: 0x00004000, ABSOLUTE, COMPRESSED[0x000001c0])</span><br><span class="line"></span><br><span class="line">    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object</span><br><span class="line"></span><br><span class="line">    0x20000000   COMPRESSED   0x00000004   Data   RW         2742    .data               mc_p.l(stdout.o)</span><br><span class="line">    0x20000004   COMPRESSED   0x00000008   Data   RW         1117    .data..L_MergedGlobals  stm32f0xx_hal.o</span><br><span class="line">    0x2000000c   COMPRESSED   0x00000022   Data   RW          754    .data.CUSTOM_HID_ReportDesc_FS  usbd_custom_hid_if.o</span><br><span class="line">    0x2000002e   COMPRESSED   0x00000002   PAD</span><br><span class="line">    0x20000030   COMPRESSED   0x0000001c   Data   RW          733    .data.FS_Desc       usbd_desc.o</span><br><span class="line">    0x2000004c   COMPRESSED   0x00000004   Data   RW         2228    .data.SystemCoreClock  system_stm32f0xx.o</span><br><span class="line">    0x20000050   COMPRESSED   0x00000038   Data   RW         2427    .data.USBD_CDC      usbd_cdc.o</span><br><span class="line">    0x20000088   COMPRESSED   0x00000043   Data   RW         2429    .data.USBD_CDC_CfgFSDesc  usbd_cdc.o</span><br><span class="line">    0x200000cb   COMPRESSED   0x00000001   PAD</span><br><span class="line">    0x200000cc   COMPRESSED   0x00000043   Data   RW         2428    .data.USBD_CDC_CfgHSDesc  usbd_cdc.o</span><br><span class="line">    0x2000010f   COMPRESSED   0x00000001   PAD</span><br><span class="line">    0x20000110   COMPRESSED   0x0000000a   Data   RW         2431    .data.USBD_CDC_DeviceQualifierDesc  usbd_cdc.o</span><br><span class="line">    0x2000011a   COMPRESSED   0x00000002   PAD</span><br><span class="line">    0x2000011c   COMPRESSED   0x00000010   Data   RW          775    .data.USBD_CDC_Interface_fops_FS  usbd_cdc_if.o</span><br><span class="line">    0x2000012c   COMPRESSED   0x00000008   Data   RW          776    .data.USBD_CDC_LineCoding  usbd_cdc_if.o</span><br><span class="line">    0x20000134   COMPRESSED   0x00000043   Data   RW         2430    .data.USBD_CDC_OtherSpeedCfgDesc  usbd_cdc.o</span><br><span class="line">  </span><br><span class="line">  ....</span><br><span class="line">  </span><br><span class="line">    0x20000368        -       0x0000002c   Zero   RW           29    .bss..L_MergedGlobals  main.o</span><br><span class="line">    0x20000394        -       0x00000030   Zero   RW          287    .bss..L_MergedGlobals  systime.o</span><br><span class="line">    0x200003c4        -       0x00000024   Zero   RW          569    .bss..L_MergedGlobals  can.o</span><br><span class="line">    0x200003e8        -       0x00000048   Zero   RW          756    .bss..L_MergedGlobals  usbd_custom_hid_if.o</span><br><span class="line">    0x20000430        -       0x00000008   Zero   RW         2388    .bss..L_MergedGlobals  usbd_composite.o</span><br><span class="line">    0x20000438        -       0x00000400   Zero   RW           25    .bss.UART2_RxBuffer  main.o</span><br><span class="line">    0x20000838        -       0x00000001   Zero   RW         2299    .bss.USBD_SetConfig.cfgidx  usbd_ctlreq.o</span><br><span class="line">    0x20000839   COMPRESSED   0x00000003   PAD</span><br><span class="line">    0x2000083c        -       0x00000200   Zero   RW          737    .bss.USBD_StrDesc   usbd_desc.o</span><br><span class="line">    0x20000a3c        -       0x00000040   Zero   RW          778    .bss.UserRxBufferFS  usbd_cdc_if.o</span><br><span class="line">    0x20000a7c        -       0x00000040   Zero   RW          779    .bss.UserTxBufferFS  usbd_cdc_if.o</span><br><span class="line">    0x20000abc        -       0x00000001   Zero   RW          777    .bss.cdc_receive_flag  usbd_cdc_if.o</span><br><span class="line">    0x20000abd   COMPRESSED   0x00000003   PAD</span><br><span class="line">    0x20000ac0        -       0x000002c4   Zero   RW          712    .bss.hUsbDeviceFS   usb_device.o</span><br><span class="line">    0x20000d84        -       0x00000028   Zero   RW          568    .bss.hcan           can.o</span><br><span class="line">    0x20000dac        -       0x00000044   Zero   RW          109    .bss.hdma_usart2_rx  usart.o</span><br><span class="line">    0x20000df0        -       0x0000004c   Zero   RW           59    .bss.hi2c1          i2c.o</span><br><span class="line">    0x20000e3c        -       0x000002f4   Zero   RW          850    .bss.hpcd_USB_FS    usbd_conf.o</span><br><span class="line">    0x20001130        -       0x00000064   Zero   RW           77    .bss.hspi1          spi.o</span><br><span class="line">    0x20001194        -       0x00000048   Zero   RW          419    .bss.htim6          tim.o</span><br><span class="line">    0x200011dc        -       0x00000084   Zero   RW          106    .bss.huart1         usart.o</span><br><span class="line">    0x20001260        -       0x00000084   Zero   RW          107    .bss.huart2         usart.o</span><br><span class="line">    0x200012e4        -       0x00000084   Zero   RW          108    .bss.huart3         usart.o</span><br><span class="line">    0x20001368        -       0x00000001   Zero   RW          227    .bss.i2c_error      usb_handle.o</span><br><span class="line">    0x20001369        -       0x00000400   Zero   RW          239    .bss.inter_buffer   uart_data_analysis.o</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>输出的hex&#x2F;bin中，各.obj对应的Code， Data， ZI段大小：</p>
<p>可快速定位哪些代码占用Flash&#x2F;RAM空间过大。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Image component sizes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line">        26          4          0          0         76       4060   can.o</span><br><span class="line">        48          4          0          0          0       1769   dma.o</span><br><span class="line">       348          0          0          0          0       9083   fifo.o</span><br><span class="line">        92         16          0          0          0       3240   flash.o</span><br><span class="line">       258          0          0          0          0       4158   general_function.o</span><br><span class="line">       252         16          0          0          0       2882   gpio.o</span><br><span class="line">       428         72          0          0         76       7196   i2c.o</span><br><span class="line">         2          0          0          0          0      23860   jaguar.o</span><br><span class="line">       788        128          0          0       2092       8846   main.o</span><br><span class="line">       872        206         25          0        152      10137   one_wire.o</span><br><span class="line">       268         28          0         32        100       5426   spi.o</span><br><span class="line">        28          8        192          0       1280        656   startup_stm32f072xb.o</span><br><span class="line">       168         24          0          8          4       5420   stm32f0xx_hal.o</span><br><span class="line">       958          6          0          0          0      14230   stm32f0xx_hal_can.o</span><br><span class="line">       164         28          0          0          0       5576   stm32f0xx_hal_cortex.o</span><br><span class="line">       678         12          0          0          0       8163   stm32f0xx_hal_dma.o</span><br><span class="line">       694         32          0          0          0       4994   stm32f0xx_hal_gpio.o</span><br><span class="line">      1786         60          0          0          0      63508   stm32f0xx_hal_i2c.o</span><br><span class="line">       132          0          0          0          0       5319   stm32f0xx_hal_i2c_ex.o</span><br><span class="line">        44          4          0          0          0       1058   stm32f0xx_hal_msp.o</span><br><span class="line">      3124        100          0          0          0      15820   stm32f0xx_hal_pcd.o</span><br><span class="line">        96          0          0          0          0       5855   stm32f0xx_hal_pcd_ex.o</span><br><span class="line">      1672         52         32          0          0       8371   stm32f0xx_hal_rcc.o</span><br><span class="line">       328         12          0          0          0       6715   stm32f0xx_hal_rcc_ex.o</span><br><span class="line">      1544          8          0          0          0      27530   stm32f0xx_hal_spi.o</span><br><span class="line">       736         44          0          0          0      63633   stm32f0xx_hal_tim.o</span><br><span class="line">        96          0          0          0          0      22483   stm32f0xx_hal_tim_ex.o</span><br><span class="line">      2884         92         16          0          0      41313   stm32f0xx_hal_uart.o</span><br><span class="line">       122          0          0          0          0       8856   stm32f0xx_hal_uart_ex.o</span><br><span class="line">       106         20          0          0          0       2835   stm32f0xx_it.o</span><br><span class="line">      3540        152          0          0          0      23016   stm32f0xx_ll_usb.o</span><br><span class="line">         2          0         24          4          0       1745   system_stm32f0xx.o</span><br><span class="line">       236         36          0          0         48       2973   systime.o</span><br><span class="line">       152         20          0          0         72       5392   tim.o</span><br><span class="line">       160         12          0          0       1024       1279   uart_data_analysis.o</span><br><span class="line">       828         84          0          0        464       7567   usart.o</span><br><span class="line">        64         12          0          0        708       2859   usb_device.o</span><br><span class="line">      1268        120          0          0          1       9115   usb_handle.o</span><br><span class="line">       722         20          0        267         92      10062   usbd_cdc.o</span><br><span class="line">       260         24          0         24        129       4611   usbd_cdc_if.o</span><br><span class="line">       452         64          0        181          8       5864   usbd_composite.o</span><br><span class="line">       758         32          0          0        756      15665   usbd_conf.o</span><br><span class="line">       718          0          0          0          0       8036   usbd_core.o</span><br><span class="line">      1252         28          0          0          1       8339   usbd_ctlreq.o</span><br><span class="line">       140         16          0         50         72       3641   usbd_custom_hid_if.o</span><br><span class="line">       594         46          0        198         84       7979   usbd_customhid.o</span><br><span class="line">       504        144          0         76        512       4167   usbd_desc.o</span><br><span class="line">       162          0          0          0          0       4514   usbd_ioreq.o</span><br></pre></td></tr></table></figure>

<h1 id="STM32–启动过程"><a href="#STM32–启动过程" class="headerlink" title="STM32–启动过程"></a>STM32–启动过程</h1><p>本部分介绍从上电到进入main函数的过程。</p>
<h2 id="启动位置"><a href="#启动位置" class="headerlink" title="启动位置"></a>启动位置</h2><p>STM32能从Flash&#x2F;SRAM或System memory(远程)启动。启动位置直接决定链接脚本的加载和运行的基地址配置。</p>
<p>如何确认：</p>
<ol>
<li>查固件包Reference Manual：对于F0系列，由BOOT0 pin和nBOOT1 register bit决定启动位置。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131603031.png" alt="image-20240513160303987"></p>
<ol start="2">
<li>查开发板BOOT0 pin：下拉接地，因此开发板是Boot from Flash。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131605456.png" alt="image-20240513160533426"></p>
<ol start="3">
<li>顺便查一下nBOOT1 register：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131606693.png" alt="image-20240513160652648"></p>
<h2 id="startup-s"><a href="#startup-s" class="headerlink" title="startup.s"></a>startup.s</h2><p>根据链接脚本指定的asm找到启动文件startup_stm32f072xb.s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ASM sources</span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">startup_stm32f072xb.s</span><br></pre></td></tr></table></figure>

<p>根据链接脚本的RESET符号，找到CPU复位时执行指令的入口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp                   ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                  ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                    ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler              ; Hard Fault Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SVC_Handler                    ; SVCall Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     PendSV_Handler                 ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler                ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">                DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">                DCD     RCC_IRQHandler                 ; RCC</span><br><span class="line">                DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">                DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">                DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">                DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">                DCD     DMA1_Channel4_5_IRQHandler     ; DMA1 Channel 4 and Channel 5</span><br><span class="line">                DCD     ADC1_IRQHandler                ; ADC1 </span><br><span class="line">                DCD     TIM1_BRK_UP_TRG_COM_IRQHandler ; TIM1 Break, Update, Trigger and Commutation</span><br><span class="line">                DCD     TIM1_CC_IRQHandler             ; TIM1 Capture Compare</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM3_IRQHandler                ; TIM3</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM14_IRQHandler               ; TIM14</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM16_IRQHandler               ; TIM16</span><br><span class="line">                DCD     TIM17_IRQHandler               ; TIM17</span><br><span class="line">                DCD     I2C1_IRQHandler                ; I2C1</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SPI1_IRQHandler                ; SPI1</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     USART1_IRQHandler              ; USART1</span><br><span class="line">                DCD     USART2_IRQHandler              ; USART2</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     USB_IRQHandler                 ; USB</span><br><span class="line"></span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure>

<p>这里面的AREA&#x2F;DCD等伪汇编符号含义，参考[指令集与伪汇编](# 指令集与伪汇编)</p>
<p>以上代码声明了中断向量表，定义CPU中断、异常发生时的入口地址。</p>
<p>STM32 中断向量表的定义参考固件包Program Manual：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131542062.png" alt="image-20240513154213024"></p>
<p>MCU启动或者reset时：</p>
<p>PC指针从0x0: __initial_sp取指令，<del>此处没任何内容</del>  此处不是个指令，而是栈顶指针的值，由编译器根据代码量+StackSize自动生成；《STM32–Firmware Architecture part2》详细分析如何生成。</p>
<p>然后PC + 4，从0x4取指令，即执行Reset_Handler：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Reset handler routine</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler                 [WEAK]</span><br><span class="line">        IMPORT  __main</span><br><span class="line">        IMPORT  SystemInit  </span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>

<p>这里先后执行SystemInit和__main</p>
<ol>
<li>SystemInit的作用如下，o2link代码没有用此函数（空）</li>
</ol>
<p>This function is called at startup just after reset and before branch to main program. User can setups the default system clock (System clock source, PLL Multiplier and Divider factors, AHB&#x2F;APBx prescalers and Flash settings</p>
<ol start="2">
<li>__main符号即C的main函数 <em>int</em> main(<em>void</em>)，从此进入C代码执行。</li>
</ol>
<h2 id="指令集与伪汇编"><a href="#指令集与伪汇编" class="headerlink" title="指令集与伪汇编"></a>指令集与伪汇编</h2><p>指令集：MCU硬件决定的指令，例如STM32是Cortex M0指令集。 详见固件包Program Manual。</p>
<p>伪汇编指令：是编译器扩展的汇编语法，取决于编译器类型。根据汇编器找user guide，例如 armasm：</p>
<p><a href="https://documentation-service.arm.com/static/63eb50c09567172d4e2aa777">https://documentation-service.arm.com/static/63eb50c09567172d4e2aa777</a></p>
<ol>
<li>Cortex M0指令集：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557835.png" alt="image-20240513155719763"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557727.png" alt="image-20240513155736664"></p>
<ol start="2">
<li>armasm的一些伪汇编指令：</li>
</ol>
<blockquote>
<p>AREA:声明一块区域的属性，例如：AREA A64ex, CODE, READONLY;  Name this block of code A64ex</p>
<p>EXPORT：使符号对其他文件可见。Labels are local to the source file unless you make them global using the EXPORT directive  </p>
<p>DCD: Declares one or more words of store. 声明一块区域，如果区域是函数符号表示声明该函数所占用的区域。</p>
</blockquote>
<h1 id="STM32–main初始化流程"><a href="#STM32–main初始化流程" class="headerlink" title="STM32–main初始化流程"></a>STM32–main初始化流程</h1><h2 id="HAL-Init"><a href="#HAL-Init" class="headerlink" title="HAL_Init"></a>HAL_Init</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">	HAL_Init();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */</span><br><span class="line">HAL_InitTick(TICK_INT_PRIORITY);</span><br><span class="line">--&gt; HAL_SYSTICK_Config: Configure the SysTick to have interrupt in 1ms time basis</span><br><span class="line">--&gt; HAL_NVIC_SetPriority: Configure the SysTick IRQ priority</span><br></pre></td></tr></table></figure>

<ol>
<li>关于HAL_SYSTICK_Config的底层实现（参考HAL user manual.chm：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00043    (+) The HAL_SYSTICK_Config()function calls the SysTick_Config() function which</span><br><span class="line">00044        is a CMSIS function that:</span><br><span class="line">00045         (++) Configures the SysTick Reload register with value passed as function parameter.</span><br><span class="line">00046         (++) Configures the SysTick IRQ priority to the lowest value (0x03).</span><br><span class="line">00047         (++) Resets the SysTick Counter register.</span><br><span class="line">00048         (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).</span><br><span class="line">00049         (++) Enables the SysTick Interrupt.</span><br><span class="line">00050         (++) Starts the SysTick Counter.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关于systick的NVIC中断优先级：</li>
</ol>
<p> * <em>@note</em> In the default implementation, SysTick timer is the source of time base. </p>
<p> *    It is used to generate interrupts at regular time intervals. </p>
<p> *    Care must be taken if HAL_Delay() is called from a peripheral ISR process, </p>
<p> *    The SysTick interrupt must have higher priority (numerically lower) </p>
<p> *    than the peripheral interrupt. Otherwise the caller ISR process will be blocked.</p>
<ol start="3">
<li>STM32 所有的中断和异常的优先级总表，参考Reference Manual：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131633379.png" alt="image-20240513163316319"></p>
<h2 id="SystemClock-Config"><a href="#SystemClock-Config" class="headerlink" title="SystemClock_Config"></a>SystemClock_Config</h2><ol>
<li>整个时钟树配置参数可以在CubeMX初始化项目时配置，系统时钟SYSCLK有外部HSE（8M OSC）和内部HSI（内部RC）多个源，由下图当前配置生效的是HSI 48M RC作为源。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131647697.png" alt="image-20240513164731624"></p>
<p>不同外设模式对时钟树的要求：</p>
<blockquote>
<p>I2c input frequency should up to 48M to support 1M i2c clock.</p>
<p>UART input frequency should be changed to HIS 8M to support lower than 1K baud rate and changed to 48M to support 1M baud rate.</p>
<p>USB modules need 48M input frequency</p>
</blockquote>
<ol start="2">
<li>系统时钟配置过程：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Configure the system clock */</span><br><span class="line">	SystemClock_Config();</span><br></pre></td></tr></table></figure>

<p>主要分两步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initializes the RCC Oscillators</span><br><span class="line">Initializes the CPU, AHB and APB buses clocks</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>具体配置过程，以HAL_RCC_OscConfig的HSI Configuration为例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HAL_RCC_OscConfig：</span><br><span class="line"></span><br><span class="line">/*----------------------------- HSI Configuration --------------------------*/ </span><br><span class="line">  if(((RCC_OscInitStruct-&gt;OscillatorType) &amp; RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)</span><br><span class="line">  &#123;</span><br><span class="line">    /* Check the parameters */</span><br><span class="line">    assert_param(IS_RCC_HSI(RCC_OscInitStruct-&gt;HSIState));</span><br><span class="line">    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct-&gt;HSICalibrationValue));</span><br><span class="line">    </span><br><span class="line">    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ </span><br><span class="line">    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) </span><br><span class="line">       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) &amp;&amp; (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))</span><br><span class="line">    &#123;</span><br><span class="line">      /* When HSI is used as system clock it will not disabled */</span><br><span class="line">      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) &amp;&amp; (RCC_OscInitStruct-&gt;HSIState != RCC_HSI_ON))</span><br><span class="line">      &#123;</span><br><span class="line">        return HAL_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">      /* Otherwise, just the calibration is allowed */</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/</span><br><span class="line">        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct-&gt;HSICalibrationValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      /* Check the HSI State */</span><br><span class="line">      if(RCC_OscInitStruct-&gt;HSIState != RCC_HSI_OFF)</span><br><span class="line">      &#123;</span><br><span class="line">       /* Enable the Internal High Speed oscillator (HSI). */</span><br><span class="line">        __HAL_RCC_HSI_ENABLE();</span><br><span class="line">        </span><br><span class="line">        /* Get Start Tick */</span><br><span class="line">        tickstart = HAL_GetTick();</span><br><span class="line">        </span><br><span class="line">        /* Wait till HSI is ready */</span><br><span class="line">        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)</span><br><span class="line">        &#123;</span><br><span class="line">          if((HAL_GetTick() - tickstart ) &gt; HSI_TIMEOUT_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">            return HAL_TIMEOUT;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/</span><br><span class="line">        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct-&gt;HSICalibrationValue);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        /* Disable the Internal High Speed oscillator (HSI). */</span><br><span class="line">        __HAL_RCC_HSI_DISABLE();</span><br><span class="line">        </span><br><span class="line">        /* Get Start Tick */</span><br><span class="line">        tickstart = HAL_GetTick();</span><br><span class="line">        </span><br><span class="line">        /* Wait till HSI is disabled */</span><br><span class="line">        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)</span><br><span class="line">        &#123;</span><br><span class="line">          if((HAL_GetTick() - tickstart ) &gt; HSI_TIMEOUT_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">            return HAL_TIMEOUT;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里判断HSI时钟源Ready的代码逻辑：</p>
<ul>
<li><p>根据时钟类型，读对应的register的ready bit是否为0。</p>
</li>
<li><p>如果到超时没ready，即此时钟不可用，继续初始化其他时钟。</p>
</li>
</ul>
<p>这里有个问题：系统时钟源还没配置完，为什么可以用HAL_GetTick去判断Ready超时，systick从哪来？</p>
<p>原因：CPU Reset后默认使用HSI时钟，前面的HAL_Init利用HSI初始化了1ms systick功能，因此systick可用；SystemClock_Config只是再次配置时钟，并不是说此时没有时钟。</p>
<ol start="4">
<li>判断时钟源ready register相关的代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)：</span><br><span class="line"></span><br><span class="line">typedef enum </span><br><span class="line">&#123;</span><br><span class="line">  RESET = 0U, </span><br><span class="line">  SET = !RESET</span><br><span class="line">&#125; FlagStatus, ITStatus;</span><br><span class="line"></span><br><span class="line">#define RCC_FLAG_HSERDY                  ((uint8_t)((CR_REG_INDEX &lt;&lt; 5U) | RCC_CR_HSERDY_BitNumber))</span><br><span class="line">#define CR_REG_INDEX                     ((uint8_t)1U)</span><br><span class="line">#define RCC_CR_HSERDY_BitNumber           17</span><br><span class="line"></span><br><span class="line">#define __HAL_RCC_GET_FLAG(__FLAG__) (((((__FLAG__) &gt;&gt; 5U) == CR_REG_INDEX)? RCC-&gt;CR :      \</span><br><span class="line">                                       (((__FLAG__) &gt;&gt; 5U) == CR2_REG_INDEX)? RCC-&gt;CR2 :    \</span><br><span class="line">                                       (((__FLAG__) &gt;&gt; 5U) == BDCR_REG_INDEX) ? RCC-&gt;BDCR : \</span><br><span class="line">                                       RCC-&gt;CSR) &amp; (1U &lt;&lt; ((__FLAG__) &amp; RCC_FLAG_MASK)))</span><br></pre></td></tr></table></figure>

<p>RCC-&gt;CR的定义为例：bit17为HSE RDY bit.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131708364.png" alt="image-20240513170841325"></p>
<h2 id="MX-GPIO-Init"><a href="#MX-GPIO-Init" class="headerlink" title="MX_GPIO_Init"></a>MX_GPIO_Init</h2><p>GPIO初始化入口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Initialize all configured peripherals */</span><br><span class="line">	MX_GPIO_Init();</span><br></pre></td></tr></table></figure>

<p>GPIO重点描述几个话题：</p>
<ol>
<li><p>GPIO分组与复用</p>
<p>GPIO有A~F多组，各组的pin独立；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737151.png" alt="image-20240513173750127"></p>
<p>每组GPIO pin都有复用不同的功能；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737965.png" alt="image-20240513173701913"></p>
</li>
<li><p>GPIO的模式</p>
<p>参考Datasheet：Each of the GPIO pins can be configured by software as output (push-pull or open-drain), as input (with or without pull-up or pull-down) or as peripheral alternate function.   </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131747355.png" alt="image-20240513174736319"></p>
<p>输出模式的开漏和推挽模式的主要特性：</p>
<p>（1）开漏输出的高电平不是MCU驱动的，MCU仅作为控制源；输出高电平是借助外部上拉电平；可以自定义输出电平，例如3.3V&#x2F;5V只需要调节上拉电平，不需受到MCU驱动能力限制。</p>
<p>（2）推挽输出的高电平是MCU驱动，即MCU通过内部P&#x2F;N MOS结构真正输出电压（一般3.3V），MCU驱动能力有限。</p>
</li>
</ol>
<p>GPIO代码示例（输出模式）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化配置模式：输出，推挽</span><br><span class="line">//恢复默认值（GPIO_PIN_RESET，0）</span><br><span class="line">/*Configure GPIO pin Output Level */</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_8 | GPIO_PIN_15, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">//配置模式</span><br><span class="line">/*Configure GPIO pin : PA */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_8 | GPIO_PIN_15;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">//使用：翻转PA15</span><br><span class="line">HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_15);</span><br><span class="line">//使用：设置高</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);</span><br></pre></td></tr></table></figure>

<p>GPIO中断模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置中断模式和优先级</span><br><span class="line">/*Configure GPIO pin : PB */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_4;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING; //中断模式</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">//GPIO_MODE_IT_RISING_FALLING实际是设置EXTI中断</span><br><span class="line">#define  GPIO_MODE_IT_RISING_FALLING            (MODE_INPUT | EXTI_IT | TRIGGER_RISING | TRIGGER_FALLING) </span><br><span class="line"></span><br><span class="line">/* EXTI interrupt init*/</span><br><span class="line">HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);</span><br><span class="line">HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);</span><br><span class="line"></span><br><span class="line">//中断回调</span><br><span class="line">//GPIO4实际是PB4，因为仅PB4设置为INT模式</span><br><span class="line">void EXTI4_15_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MX-DMA-Init"><a href="#MX-DMA-Init" class="headerlink" title="MX_DMA_Init"></a>MX_DMA_Init</h2><h3 id="DMA的常规操作"><a href="#DMA的常规操作" class="headerlink" title="DMA的常规操作"></a>DMA的常规操作</h3><p>参考UM1850：</p>
<p>How to use this driver</p>
<ol>
<li>Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM &#x2F;FLASH memories: no initialization is necessary). Please refer to the Reference manual for connectionbetween peripherals and DMA requests.</li>
<li>For a given Channel, program the required configuration through the following parameters: Channel request,Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level,Source and Destination Increment mode using HAL_DMA_Init() function.</li>
<li>Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of errordetection.4. Use HAL_DMA_Abort() function to abort the current transfer</li>
</ol>
<p>轮询和中断两种模式：</p>
<p>Polling mode IO operation</p>
<p>• Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred</p>
<p>• Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can beconfigured by User depending from his application</p>
<p>Interrupt mode IO operation</p>
<p>• Configure the DMA interrupt priority using HAL_NVIC_SetPriority()</p>
<p>• Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()</p>
<p>• Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred. In this case the DMA interrupt is configured</p>
<p>• Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine</p>
<p>• At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can add his own functionby customization of function pointer XferCpltCallback and XferErrorCallback (i.e. a member of DMA handlestructure).</p>
<h3 id="DMA-Init和IRQ-handler"><a href="#DMA-Init和IRQ-handler" class="headerlink" title="DMA_Init和IRQ handler"></a>DMA_Init和IRQ handler</h3><p>DMA用于UART RX传输中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void MX_DMA_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* DMA controller clock enable */</span><br><span class="line">  __HAL_RCC_DMA1_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  /* DMA interrupt init */</span><br><span class="line">  /* DMA1_Channel4_5_6_7_IRQn interrupt configuration */</span><br><span class="line">  HAL_NVIC_SetPriority(DMA1_Channel4_5_6_7_IRQn, 0, 0);</span><br><span class="line">  HAL_NVIC_EnableIRQ(DMA1_Channel4_5_6_7_IRQn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DMA1_Channel4_5_6_7_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">  HAL_DMA_IRQHandler(&amp;hdma_usart2_rx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Drivers\CMSIS\Device\ST\STM32F0xx\Include\stm32f072xb.h:</span><br><span class="line">DMA1_Channel4_5_6_7_IRQn    = 11,     /*!&lt; DMA1 Channel 4 to Channel 7 Interrupt </span><br><span class="line"></span><br><span class="line">Drivers\CMSIS\Device\ST\STM32F0xx\Source\Templates\arm\startup_stm32f072xb.s:</span><br><span class="line">IRQ 11的handler即DMA1_Channel4_5_6_7_IRQHandler</span><br><span class="line">; External Interrupts</span><br><span class="line">DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">DCD     PVD_VDDIO2_IRQHandler          ; PVD through EXTI Line detect</span><br><span class="line">DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">DCD     RCC_CRS_IRQHandler             ; RCC and CRS</span><br><span class="line">DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">DCD     TSC_IRQHandler                 ; TS</span><br><span class="line">DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">DCD     DMA1_Channel4_5_6_7_IRQHandler ; DMA1 Channel 4, Channel 5, Channel 6 and Channel 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UART RX 使用DMA channel 5 处理接收数据中断</span><br><span class="line">HAL_UART_MspInit()：</span><br><span class="line">/* USART2 DMA Init */</span><br><span class="line">    /* USART2_RX Init */</span><br><span class="line">    hdma_usart2_rx.Instance = DMA1_Channel5;</span><br><span class="line">    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;</span><br><span class="line">    if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HAL_DMA_IRQHandler的具体操作:</p>
<p>处理DMA传输完成中断：分为half transfer complete和Transfer Complete两种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Transfer Complete Interrupt management ***********************************/</span><br><span class="line">  else if ((RESET != (flag_it &amp; (DMA_FLAG_TC1 &lt;&lt; hdma-&gt;ChannelIndex))) &amp;&amp; (RESET != (source_it &amp; DMA_IT_TC)))</span><br><span class="line">  &#123;</span><br><span class="line">  	if((hdma-&gt;Instance-&gt;CCR &amp; DMA_CCR_CIRC) == 0U)</span><br><span class="line">  	&#123;</span><br><span class="line">  		/* Disable the transfer complete  &amp; transfer error interrupts */</span><br><span class="line">  		/* if the DMA mode is not CIRCULAR */</span><br><span class="line">  		hdma-&gt;Instance-&gt;CCR &amp;= ~(DMA_IT_TC | DMA_IT_TE);</span><br><span class="line">  		</span><br><span class="line">  		/* Change the DMA state */</span><br><span class="line">  		hdma-&gt;State = HAL_DMA_STATE_READY;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	/* Clear the transfer complete flag */</span><br><span class="line">  	hdma-&gt;DmaBaseAddress-&gt;IFCR = DMA_FLAG_TC1 &lt;&lt; hdma-&gt;ChannelIndex;</span><br></pre></td></tr></table></figure>

<p>DMA传输完成的回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(hdma-&gt;XferCpltCallback != NULL)</span><br><span class="line">  	&#123;</span><br><span class="line">  		/* Transfer complete callback */</span><br><span class="line">  		hdma-&gt;XferCpltCallback(hdma);</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<p>o2link的UART2处理1KB DMA buffer的自定义逻辑，就是在此中断回调中实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UART_Start_Receive_DMA():</span><br><span class="line">/* Set the UART DMA transfer complete callback */</span><br><span class="line">    huart-&gt;hdmarx-&gt;XferCpltCallback = UART_DMAReceiveCplt;</span><br></pre></td></tr></table></figure>

<p>DMA传输错误中断的判断和回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Transfer Error Interrupt management ***************************************/</span><br><span class="line">  else if (( RESET != (flag_it &amp; (DMA_FLAG_TE1 &lt;&lt; hdma-&gt;ChannelIndex))) &amp;&amp; (RESET != (source_it &amp; DMA_IT_TE)))</span><br><span class="line">  &#123;</span><br><span class="line">  	/* When a DMA transfer error occurs */</span><br><span class="line">    /* A hardware clear of its EN bits is performed */</span><br><span class="line">    /* Then, disable all DMA interrupts */</span><br><span class="line">    hdma-&gt;Instance-&gt;CCR &amp;= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);</span><br><span class="line">    </span><br><span class="line">    /* Clear all flags */</span><br><span class="line">    hdma-&gt;DmaBaseAddress-&gt;IFCR = DMA_FLAG_GL1 &lt;&lt; hdma-&gt;ChannelIndex;</span><br><span class="line">    </span><br><span class="line">    /* Update error code */</span><br><span class="line">    hdma-&gt;ErrorCode = HAL_DMA_ERROR_TE;</span><br><span class="line">    </span><br><span class="line">    /* Change the DMA state */</span><br><span class="line">    hdma-&gt;State = HAL_DMA_STATE_READY;    </span><br><span class="line">    </span><br><span class="line">    /* Process Unlocked */</span><br><span class="line">    __HAL_UNLOCK(hdma); </span><br><span class="line">    </span><br><span class="line">    if(hdma-&gt;XferErrorCallback != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    	/* Transfer error callback */</span><br><span class="line">    	hdma-&gt;XferErrorCallback(hdma);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="DMA-channel和外设的对应关系"><a href="#DMA-channel和外设的对应关系" class="headerlink" title="DMA channel和外设的对应关系"></a>DMA channel和外设的对应关系</h3><p>参考（RM0091）：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132023514.png" alt="image-20240513202302455"></p>
<h2 id="MX-I2C1-Init"><a href="#MX-I2C1-Init" class="headerlink" title="MX_I2C1_Init"></a>MX_I2C1_Init</h2><p>首先明确一个问题：是硬件实现的I2C还是软件GPIO模拟的I2C？</p>
<p>怎么确认：看电路图+Datasheet+底层数据传输代码</p>
<ul>
<li>硬件I2C：此GPIO应该支持I2C功能，Datasheet确认，软件查看是否配成了I2C功能，数据传输是否配置I2C register</li>
<li>软件I2C：此GPIO是普通的GPIO功能，用软件控制high、low和delay控制I2C数据传输，底层操作不是用I2C register实现。</li>
</ul>
<p>根据以下，本环境是硬件I2C功能。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171539178.png" alt="image-20240517153927141"><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541038.png" alt="image-20240517154143995"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541688.png" alt="image-20240517154158646"></p>
<p>下面看初始化代码。</p>
<p>I2C初始化包括两步：</p>
<ol>
<li>设置I2C通信参数</li>
</ol>
<p>速度：standard (up to 100 kHz), Fast-mode (up to 400 kHz) or Fast-mode Plus (up to 1 MHz)  </p>
<p>寻址：7-bit&#x2F;10 bit addressing mode，决定i2c slave设备寻址空间</p>
<p>其他能力见RM0091:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132036579.png" alt="image-20240513203608542"></p>
<p>代码配置的速度和寻址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hi2c1.Init.Timing = SETTING_CLK_100K;</span><br><span class="line">hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置GPIO pin为I2C模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HAL_I2C_Init</span><br><span class="line"></span><br><span class="line">--&gt; HAL_I2C_MspInit:</span><br><span class="line"></span><br><span class="line">/**I2C1 GPIO Configuration</span><br><span class="line">PB6   ------&gt; I2C1_SCL</span><br><span class="line">PB7   ------&gt; I2C1_SDA</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_I2C1;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="MX-SPI1-Init"><a href="#MX-SPI1-Init" class="headerlink" title="MX_SPI1_Init"></a>MX_SPI1_Init</h2><p>和I2C初始化结构基本类似</p>
<ol>
<li><p>设置SPI通信参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hspi1.Init.Mode = SPI_MODE_MASTER;</span><br><span class="line">hspi1.Init.Direction = SPI_DIRECTION_2LINES; //双向</span><br><span class="line">hspi1.Init.DataSize = SPI_DATASIZE_8BIT; //数据是8bit模式</span><br><span class="line">hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH; //</span><br><span class="line">hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;</span><br></pre></td></tr></table></figure>

<p>关于SPI配置，主要关注数据模式是8bit还是16bit, 以及数据采样和传输的时间点(极性和相位)。</p>
<p>参考<a href="https://zhuanlan.zhihu.com/p/689464409">SPI的四种传输模式及工作机制分析</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132055783.png" alt="image-20240513205538749"></p>
<p>黑线为数据采样点，与之相反为数据发送点</p>
</li>
<li><p>设置GPIO为SPI模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**SPI1 GPIO Configuration</span><br><span class="line">PA5     ------&gt; SPI1_SCK</span><br><span class="line">PA6     ------&gt; SPI1_MISO</span><br><span class="line">PA7     ------&gt; SPI1_MOSI</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MX-USART1-UART-Init"><a href="#MX-USART1-UART-Init" class="headerlink" title="MX_USART1_UART_Init"></a>MX_USART1_UART_Init</h2><p>对于o2link board, 使用三个UART：</p>
<p>(1) UART 1 PA9 PA10 is used as debug port.</p>
<p>(2) UART 2 PA2 PA3 is used as USB TO UART port</p>
<p>(3) UART 3 PB10 PB11 is used as system communication port.</p>
<p>本节讨论UART1</p>
<ol>
<li><p>设置UART通信参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">huart1.Instance = USART1;</span><br><span class="line">huart1.Init.BaudRate = 115200; //波特率</span><br><span class="line">huart1.Init.WordLength = UART_WORDLENGTH_8B; //8-bit long UART frame(可配7,8,9bit)</span><br><span class="line">huart1.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">huart1.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">huart1.Init.Mode = UART_MODE_TX_RX; //双向</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置GPIO为UART模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**USART1 GPIO Configuration</span><br><span class="line">PA9     ------&gt; USART1_TX</span><br><span class="line">PA10     ------&gt; USART1_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_USART1;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
</li>
<li><p>UART Idle frame和Break frame的概念</p>
<p>为什么UART pin默认拉高？</p>
<p>UART除了正常的数据传输情况，还有idle和break frame的特殊情况：</p>
<p>An Idle character is interpreted as an entire frame of “1”s (the number of “1”s includes the number of stop bits).</p>
<p>A Break character is interpreted on receiving “0”s for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132106226.png" alt="image-20240513210648197"></p>
<p>默认上拉, 如果MCU没有drive UART RX&#x2F;TX pin为低，则可以识别为idle frame；</p>
<p>默认上拉，UART start时MCU开始drive RX&#x2F;TX, 直接拉低pin形成Start信号。</p>
</li>
</ol>
<h2 id="MX-USART2-UART-Init"><a href="#MX-USART2-UART-Init" class="headerlink" title="MX_USART2_UART_Init"></a>MX_USART2_UART_Init</h2><p>o2link的UART 2 PA2 PA3 is used as USB TO UART port.</p>
<p>什么是USB to UART：涉及USB CDC虚拟串口的概念，参考： <a href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#Communications_Devices_Class_-CDC-_2">Communications Devices Class (CDC)</a>，即USB实现的虚拟串口协议；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132127552.png" alt="image-20240513212722508"></p>
<p>MCU侧配置UART2参数是来自于USBD_CDC_LineCoding.</p>
<p>对于o2link的USB to UART2:</p>
<p>UART TX has no buffer, it will send data directly to the TX pin when it receives data from USB HID, the max data is 64 bytes one time. UART RX has 1K bytes buffer, it uses idle frame to receive data, when it sees this idle frame, it will generate interrupt to tell the app code, and the app code will split data into 64 bytes and transmit the data to the USB.  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132125954.png" alt="image-20240513212534924"></p>
<h3 id="UART2初始化过程"><a href="#UART2初始化过程" class="headerlink" title="UART2初始化过程"></a>UART2初始化过程</h3><ol>
<li>根据USB CDC的配置，设置UART2参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MX_USART2_UART_Init(uint32_t baurate)</span><br><span class="line">&#123;</span><br><span class="line">  USBD_CDC_LineCoding.bitrate = baurate; //1000 000</span><br><span class="line">  USBD_CDC_LineCoding.paritytype = UART_PARITY_NONE;</span><br><span class="line">  USBD_CDC_LineCoding.datatype = UART_WORDLENGTH_8B;</span><br><span class="line">  USBD_CDC_LineCoding.format = UART_STOPBITS_1;</span><br><span class="line">  UART2_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UART2_Init():</span><br><span class="line"></span><br><span class="line">huart2.Init.BaudRate = USBD_CDC_LineCoding.bitrate;</span><br><span class="line">switch (USBD_CDC_LineCoding.paritytype)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">    break;</span><br><span class="line">  case 1:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_ODD;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_EVEN;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart3.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (USBD_CDC_LineCoding.datatype)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0x07:</span><br><span class="line">    huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    break;</span><br><span class="line">  case 0x08:</span><br><span class="line">    if (huart2.Init.Parity == UART_PARITY_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">      huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      huart2.Init.WordLength = UART_WORDLENGTH_9B;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (USBD_CDC_LineCoding.format)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_2;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>配置GPIO，配置UART使用DMA模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**USART2 GPIO Configuration</span><br><span class="line">PA2     ------&gt; USART2_TX</span><br><span class="line">PA3     ------&gt; USART2_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_USART2;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">/* USART2 DMA Init */</span><br><span class="line">/* USART2_RX Init */</span><br><span class="line">hdma_usart2_rx.Instance = DMA1_Channel5;</span><br><span class="line">hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">hdma_usart2_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;</span><br><span class="line">if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__HAL_LINKDMA(uartHandle, hdmarx, hdma_usart2_rx);</span><br><span class="line"></span><br><span class="line">/* USART2 interrupt Init */</span><br><span class="line">HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);</span><br><span class="line">HAL_NVIC_EnableIRQ(USART2_IRQn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动DMA，随时准备处理UART RX的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset_uart_buffer() </span><br><span class="line">--&gt;</span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2, UART2_RxBuffer, UART_PACKAGE_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">参数如下：</span><br><span class="line">* @param huart UART handle.</span><br><span class="line">* @param pData Pointer to data buffer (uint8_t or uint16_t data elements).</span><br><span class="line">* @param Size  Amount of data elements (uint8_t or uint16_t) to be received.</span><br><span class="line"></span><br><span class="line">其中UART2_RxBuffer是1KB buffer， UART_PACKAGE_MAX_SIZE = 1024</span><br><span class="line"></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA的内容：</span><br><span class="line">/* Set Reception type to reception till IDLE Event*/</span><br><span class="line">huart-&gt;ReceptionType = HAL_UART_RECEPTION_TOIDLE; //Reception till completion or IDLE event. 即UART有idle frame能产生DMA中断，不一定要传输完整个buffer的1KB数据。</span><br><span class="line">//启动DMA</span><br><span class="line">status = UART_Start_Receive_DMA(huart, pData, Size);</span><br></pre></td></tr></table></figure>

<p>启动DMA传输的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UART_Start_Receive_DMA():</span><br><span class="line"></span><br><span class="line">/* Set the UART DMA transfer complete callback */</span><br><span class="line">huart-&gt;hdmarx-&gt;XferCpltCallback = UART_DMAReceiveCplt;</span><br><span class="line">/* Enable the DMA channel */</span><br><span class="line">HAL_DMA_Start_IT()    </span><br></pre></td></tr></table></figure>

<p>UART_DMAReceiveCplt里面自定义了完成的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UART_DMAReceiveCplt()</span><br><span class="line">--&gt; HAL_UARTEx_RxEventCallback():</span><br><span class="line"></span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">&#123;</span><br><span class="line">	/* Prevent unused argument(s) compilation warning */</span><br><span class="line">	UNUSED(huart);</span><br><span class="line">	UNUSED(Size);</span><br><span class="line"></span><br><span class="line">	if (huart-&gt;Instance == USART2)</span><br><span class="line">	&#123;</span><br><span class="line">	    //Size是DMA已传输完的总长度（DMA硬件自动计算）</span><br><span class="line">        //Rx_buf_pos是firmware自定义, 记录RX buffer的偏移。 </span><br><span class="line">		//Rx_length即当前DMA complete的传输数据长度（不包括历史总长度）</span><br><span class="line">		Rx_length = Size - Rx_buf_pos;</span><br><span class="line">		if ((Size &lt; Rx_buf_pos) || (Size &gt; UART_PACKAGE_MAX_SIZE))</span><br><span class="line">		&#123;</span><br><span class="line">			Rx_buf_pos = Size;</span><br><span class="line">			if (Rx_buf_pos &gt;= UART_PACKAGE_MAX_SIZE)</span><br><span class="line">				Rx_buf_pos = 0;</span><br><span class="line">			printf(&quot;dma buffer error\r\n &quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//这里uart_rx_fifo和UART2_RxBuffer都是1KB buffer，uart_rx_fifo用于每次DMA的buffer，每次数据都从0开始存；UART2_RxBuffer是存储多次DMA的总数据，按偏移组合；</span><br><span class="line">		fifo_s_puts(&amp;uart_rx_fifo, (char *)&amp;UART2_RxBuffer[Rx_buf_pos], Rx_length);</span><br><span class="line">		Rx_buf_pos += Rx_length;</span><br><span class="line">		if (Rx_buf_pos &gt;= UART_PACKAGE_MAX_SIZE) //1024</span><br><span class="line">			Rx_buf_pos = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解以上代码，就可以理解USB to UART2的RX机制，是将下位机的大量UART data(最多1024 bytes)，分多次DMA存到UART2_RxBuffer，再按64bytes&#x2F;USB buffer发给上位机。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141625450.png" alt="image-20240514162541398"></p>
</li>
</ol>
<h3 id="UART的DMA传输小结"><a href="#UART的DMA传输小结" class="headerlink" title="UART的DMA传输小结"></a>UART的DMA传输小结</h3><p>UART为什么使用DMA：</p>
<ol>
<li>常规的UART传输，不管是轮询还是中断，一般需要先指定好传输长度是多少个byte，即必须数据长度已知。</li>
</ol>
<p>常规的UART传输如何知道传输完成：</p>
<p>如果是轮询就预估超时时间，如果是中断就按传输完成多少byte作为标志。</p>
<ol start="2">
<li>使用DMA中断的UART传输，可以支持不定长度的数据。</li>
</ol>
<p>使用DMA的UART如何知道传输完成：</p>
<p>数据传输完成；或者有UART event如Idle event，RTO event…</p>
<h2 id="MX-USART3-UART-Init"><a href="#MX-USART3-UART-Init" class="headerlink" title="MX_USART3_UART_Init"></a>MX_USART3_UART_Init</h2><p>UART 3 PB10 PB11 is used as system communication port.</p>
<p>和UART1配置区别仅在波特率，uart3实例没实际使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">huart3.Init.BaudRate = 1000000;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**USART3 GPIO Configuration</span><br><span class="line">PB10     ------&gt; USART3_TX</span><br><span class="line">PB11     ------&gt; USART3_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_10 | GPIO_PIN_11;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF4_USART3;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<h2 id="MX-USB-DEVICE-Init"><a href="#MX-USB-DEVICE-Init" class="headerlink" title="MX_USB_DEVICE_Init"></a>MX_USB_DEVICE_Init</h2><p>USB设备的功能实现从上到下分为几层API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Middleware层的USB API：usbd_core (.c, .h), 例如USBD_Init</span><br><span class="line">--&gt; Low level层的USB API：例如USBD_LL_Init</span><br><span class="line">--&gt; HAL的USB host或peripheral API：例如HAL_PCD_Init</span><br><span class="line"></span><br><span class="line">HCD：USB host controller driver</span><br><span class="line">PCD：USB peripheral controller driver</span><br></pre></td></tr></table></figure>

<p>参考： <a href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#USB_device_library_overview">USB device library overview</a></p>
<p>下面具体分析USB初始化各层负责什么工作：</p>
<p>USBD_Init：Initializes the device stack and load the class driver. 负责USB协议范畴的设备class，设备descriptor等信息的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Unlink previous class*/</span><br><span class="line">  if (pdev-&gt;pClass != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    pdev-&gt;pClass = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Assign USBD Descriptors */</span><br><span class="line">  if (pdesc != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    pdev-&gt;pDesc = pdesc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Set Device initial State */</span><br><span class="line">  pdev-&gt;dev_state = USBD_STATE_DEFAULT;</span><br><span class="line">  pdev-&gt;id = id;</span><br></pre></td></tr></table></figure>

<p>USBD_LL_Init：Initializes the low level portion of the device driver. 负责PCD设备对象的初始化，包括设备属性，设备初始化，DMA配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PCD_HandleTypeDef hpcd_USB_FS;</span><br><span class="line"></span><br><span class="line">/* Link the driver to the stack. */</span><br><span class="line">hpcd_USB_FS.pData = pdev;</span><br><span class="line">pdev-&gt;pData = &amp;hpcd_USB_FS;</span><br><span class="line">//设备属性</span><br><span class="line">hpcd_USB_FS.Instance = USB;</span><br><span class="line">hpcd_USB_FS.Init.dev_endpoints = 8;</span><br><span class="line">hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;</span><br><span class="line">hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;</span><br><span class="line">hpcd_USB_FS.Init.low_power_enable = DISABLE;</span><br><span class="line">hpcd_USB_FS.Init.lpm_enable = DISABLE;</span><br><span class="line">hpcd_USB_FS.Init.battery_charging_enable = DISABLE;</span><br><span class="line"></span><br><span class="line">//设备初始化</span><br><span class="line">if (HAL_PCD_Init(&amp;hpcd_USB_FS) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//DMA配置</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , 0x00 , PCD_SNG_BUF, 0x28);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , 0x80 , PCD_SNG_BUF, 0x80);</span><br><span class="line"></span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CUSTOM_HID_EPIN_ADDR , PCD_SNG_BUF, 0xc0);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CUSTOM_HID_EPOUT_ADDR , PCD_SNG_BUF, 0x100);</span><br><span class="line"></span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_IN_EP , PCD_SNG_BUF, 0x140);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_OUT_EP , PCD_SNG_BUF, 0x180);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_CMD_EP , PCD_SNG_BUF, 0x1c0);</span><br></pre></td></tr></table></figure>

<p>USB设备对象PCD_HandleTypeDef的定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141148488.png" alt="image-20240514114808440"></p>
<p>初始化完成后是USBD_RegisterClass和USBD_Start，结构类似不细讲。</p>
<p>最终通过HAL_PCD_Start返回的USBD_OK status确认初始化OK。</p>
<h2 id="MX-CAN-Init"><a href="#MX-CAN-Init" class="headerlink" title="MX_CAN_Init"></a>MX_CAN_Init</h2><p>目前o2link没使用MX_CAN_Init，代码为空</p>
<h2 id="MX-TIM6-Init"><a href="#MX-TIM6-Init" class="headerlink" title="MX_TIM6_Init"></a>MX_TIM6_Init</h2><p>关于timer有两点背景：</p>
<ol>
<li>hardware timer和systick(Cortex System Timer)的区别：</li>
</ol>
<p>从大概功能上看，都是计时器计数产生中断；</p>
<p>主要是应用上的区别：</p>
<p>a. systick精度一般是1ms，属于系统运行时就一直产生中断，生命周期不停的计时器；常用于应用层的ms_delay延时。</p>
<p>b. hardware timer精度可以达到us, ns，属于即用即停，单次运行的计时器；常用于硬件操作相关的，比如时序要求的us_delay延时。</p>
<ol start="2">
<li>STM32的hardware timer有几类：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141206215.png" alt="image-20240514120637192"></p>
<p>o2link只用到base timer 6. 以下讨论都是针对base timer 6</p>
<ol>
<li>timer的计时原理图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141407505.png" alt="image-20240514140729465"></p>
<ol start="2">
<li><p>timer的计时精度和最大时间</p>
<p>对timer模块时钟的分频决定精度：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define TIME_BASE_1US 48</span><br><span class="line">#define TIME_BASE_100US 4800</span><br></pre></td></tr></table></figure>

<p> timer模块的时钟是48MHZ, 所以48分频为1us计时.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141409488.png" alt="image-20240514140933458"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htim6.Init.Prescaler = Prescaler - 1; //分频后的时钟，决定每个counter计数的时间间隔</span><br><span class="line">htim6.Init.CounterMode = TIM_COUNTERMODE_UP; //counter累加模式</span><br><span class="line">htim6.Init.Period = 0xffff; //最大counter数：65535</span><br><span class="line">htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE; //counter满后自动reload计数</span><br></pre></td></tr></table></figure>

<p>o2link设置timer6的Prescaler &#x3D; 4800, 即100us&#x2F;count，最大时间是100us*65535，约6.5s。</p>
<p>o2link对timer6的应用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim6);</span><br><span class="line">while (one_wire_timer_counter_100US &lt; one_wire_parameter.sync_high_time)&#123;&#125;;</span><br><span class="line">HAL_TIM_Base_Stop_IT(&amp;htim6);</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">#define one_wire_timer_counter_100US (htim6.Instance-&gt;CNT * 100) // 转化成微秒</span><br></pre></td></tr></table></figure>

<h2 id="使能irq和systick"><a href="#使能irq和systick" class="headerlink" title="使能irq和systick"></a>使能irq和systick</h2><p>全部外设配置完毕，启动系统：</p>
<p>enable irq：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  \brief   Enable IRQ Interrupts</span><br><span class="line">  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.</span><br><span class="line">           Can only be executed in Privileged modes.</span><br><span class="line"> */</span><br><span class="line">__STATIC_FORCEINLINE void __enable_irq(void)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM volatile (&quot;cpsie i&quot; : : : &quot;memory&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enable systick：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void systime_init()</span><br><span class="line">&#123;</span><br><span class="line">  systime_tick.tick_ms = 0;</span><br><span class="line">  systime_tick.tick_10ms = 0;</span><br><span class="line">  systime_tick.tick_100ms = 0;</span><br><span class="line">  systime_tick.tick_sec = 0;</span><br><span class="line">  systime_tick.tick_min = 0;</span><br><span class="line">  systime_tick.tick_hour = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  @brief:    Start systick, including IRQ (TBD)</span><br><span class="line"> *        Used when system is powered on</span><br><span class="line"> *  @param:    None</span><br><span class="line"> *  @return:  None</span><br><span class="line"> */</span><br><span class="line">void systime_start(void)</span><br><span class="line">&#123;</span><br><span class="line">  SysTick-&gt;CTRL |= (SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="STM32–while-loop业务流程"><a href="#STM32–while-loop业务流程" class="headerlink" title="STM32–while loop业务流程"></a>STM32–while loop业务流程</h1><p>以下分析基于o2link firmware</p>
<p>while(1)的处理主要分为几大类：</p>
<ol>
<li>用systick更新应用时间</li>
<li>处理UART DMA的RX buffer的数据</li>
<li>处理USB下发的控制信号</li>
</ol>
<h2 id="systick管理时间"><a href="#systick管理时间" class="headerlink" title="systick管理时间"></a>systick管理时间</h2><p>这个目前没什么应用，仅用于LED闪烁；真实用户场景可能用到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systime_update()：</span><br><span class="line">void systime_update(void)</span><br><span class="line">&#123;</span><br><span class="line">  if (systime_tick.tick_ms != HAL_GetTick())</span><br><span class="line">  &#123;</span><br><span class="line">    systime_tick.tick_ms = HAL_GetTick();</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_10MS) == (TICKRATE_10MS - 1))</span><br><span class="line">      systime_tick.tick_10ms++;</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_100MS) == (TICKRATE_100MS - 1))</span><br><span class="line">      systime_tick.tick_100ms++;</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_HZ) == (TICKRATE_HZ - 1))</span><br><span class="line">    &#123;</span><br><span class="line">      systime_tick.tick_sec++;</span><br><span class="line">      systime_tick.tick_min = (systime_tick.tick_sec / MIN_UNIT);</span><br><span class="line">      systime_tick.tick_hour = (systime_tick.tick_sec / HOUR_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理UART-RX的DMA数据"><a href="#处理UART-RX的DMA数据" class="headerlink" title="处理UART RX的DMA数据"></a>处理UART RX的DMA数据</h2><p>UART从RX的DMA buffer中返回给USB接口，有USB-HID和USB-CDC两种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uart_data_analysis():</span><br><span class="line">void uart_data_analysis(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t len;</span><br><span class="line">	uint8_t usb_back_buf[64] = &#123;0&#125;; //USB的buffer</span><br><span class="line">	uint8_t *buffer = inter_buffer;</span><br><span class="line">	len = fifo_s_used(&amp;uart_rx_fifo); // 待发送数据长度</span><br><span class="line">	if (len &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fifo_s_gets(&amp;uart_rx_fifo, (char *)inter_buffer, len); //从FIFO取数据</span><br><span class="line">		if (cdc_receive_flag == 0) //no CDC,即HID模式</span><br><span class="line">		&#123;</span><br><span class="line">			while (len &gt; 0) //fifo取到数据？</span><br><span class="line">			&#123;</span><br><span class="line">				usb_back_buf[0] = 0x01; //见o2link spec, 0101 for UART</span><br><span class="line">				usb_back_buf[1] = 0x01;</span><br><span class="line">				//fifo取了60bytes是否还有多的？4bytes是USB加的header</span><br><span class="line">				if (len &gt; MAX_USB_UART_PACKET_NUM)</span><br><span class="line">				&#123;</span><br><span class="line">					usb_back_buf[2] = (MAX_USB_UART_PACKET_NUM &amp; 0xff00) &gt;&gt; 8;</span><br><span class="line">					usb_back_buf[3] = (MAX_USB_UART_PACKET_NUM &amp; 0x00ff);</span><br><span class="line">					memcpy(&amp;usb_back_buf[4], buffer, MAX_USB_UART_PACKET_NUM);</span><br><span class="line">					usb_send(usb_back_buf, USB_TIMEOUT_TIME);</span><br><span class="line">					len -= MAX_USB_UART_PACKET_NUM;</span><br><span class="line">					buffer += MAX_USB_UART_PACKET_NUM;</span><br><span class="line">				&#125;</span><br><span class="line">				else //fifo数据小于60bytes</span><br><span class="line">				&#123;</span><br><span class="line">					usb_back_buf[2] = (len &amp; 0xff00) &gt;&gt; 8;</span><br><span class="line">					usb_back_buf[3] = (len &amp; 0x00ff);</span><br><span class="line">					memcpy(&amp;usb_back_buf[4], buffer, len);</span><br><span class="line">					usb_send(usb_back_buf, USB_TIMEOUT_TIME);</span><br><span class="line">					len = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else //USB-CDC模式</span><br><span class="line">			CDC_Transmit_FS(inter_buffer, len, USB_TIMEOUT_TIME);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>USB-HID发送数据的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t usb_send(uint8_t *send_data,uint32_t time_out)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t tickstart = 0U;</span><br><span class="line">	tickstart = HAL_GetTick();</span><br><span class="line">	</span><br><span class="line">	 while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(USBD_OK == USBD_CUSTOM_HID_SendReport(&amp;hUsbDeviceFS, send_data, USBD_CUSTOMHID_OUTREPORT_BUF_SIZE))</span><br><span class="line">			return USBD_OK;</span><br><span class="line">		if((HAL_GetTick() - tickstart) &gt; time_out)</span><br><span class="line">			return USB_SEND_TIMEOUT;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>USB Custom HID的实现在此不详细分析，参考固件库Sample code和 <a href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#CustomHID_Class">5.3.2.2 CustomHID Class</a></p>
<h3 id="USB-COMPOSITE设计"><a href="#USB-COMPOSITE设计" class="headerlink" title="USB COMPOSITE设计"></a>USB COMPOSITE设计</h3><p>为什么这里USB能同时支持HID和CDC两种方式？这里有USBD_COMPOSITE的概念：</p>
<p>USB设备初始化时，注册class是USBD_COMPOSITE类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USBD_RegisterClass(&amp;hUsbDeviceFS, &amp;USBD_COMPOSITE) != USBD_OK</span><br></pre></td></tr></table></figure>

<p>compisite指USB可以工作为不同设备类型，其描述符包含HID&#x2F;CDC多种模式：Middlewares\ST\STM32_USB_Device_Library\Class\usbd_composite.c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* USB composite device Configuration Descriptor */</span><br><span class="line">/*   All Descriptors (Configuration, Interface, Endpoint, Class, Vendor */</span><br><span class="line">__ALIGN_BEGIN uint8_t USBD_Composite_CfgFSDesc[USBD_COMPOSITE_DESC_SIZE] __ALIGN_END =</span><br><span class="line">    &#123;</span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        /************** Descriptor of Custom HID interface ****************/</span><br><span class="line">        /* 09 */</span><br><span class="line">        0x09,                    /*bLength: Interface Descriptor size*/</span><br><span class="line">        USB_DESC_TYPE_INTERFACE, /*bDescriptorType: Interface descriptor type*/</span><br><span class="line">        USBD_HID_INTERFACE,      /*bInterfaceNumber: Number of Interface 接口编号 0 */</span><br><span class="line">        0x00,                    /*bAlternateSetting: Alternate setting  备用接口 */</span><br><span class="line">        0x02,                    /*bNumEndpoints 使用的端点数 1 */</span><br><span class="line">        0x03,                    /*bInterfaceClass: HID*/</span><br><span class="line">        0x00,                    /*bInterfaceSubClass : 1=BOOT, 0=no boot*/</span><br><span class="line">        0x00,                    /*nInterfaceProtocol : 0=none, 1=keyboard, 2=mouse*/</span><br><span class="line">        0,                       /*iInterface: Index of string descriptor*/</span><br><span class="line">        /******************** Descriptor of Custom HID ********************/</span><br><span class="line">        /* 18 */</span><br><span class="line">        0x09,                       /*bLength: HID Descriptor size*/</span><br><span class="line">        CUSTOM_HID_DESCRIPTOR_TYPE, /*bDescriptorType: HID*/</span><br><span class="line">        0x11,                       /*bcdHID: HID Class Spec release number*/</span><br><span class="line">        0x01,</span><br><span class="line">        0x00,                             /*bCountryCode: Hardware target country*/</span><br><span class="line">        0x01,                             /*bNumDescriptors: Number of HID class descriptors to follow*/</span><br><span class="line">        0x22,                             /*bDescriptorType*/</span><br><span class="line">        USBD_CUSTOM_HID_REPORT_DESC_SIZE, /*wItemLength: Total length of Report descriptor*/</span><br><span class="line">        0x00,</span><br><span class="line">        </span><br><span class="line">        /* 27 */</span><br><span class="line">        0x07,                   /*bLength: Endpoint Descriptor size*/</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT, /*bDescriptorType:*/</span><br><span class="line"></span><br><span class="line">        CUSTOM_HID_EPIN_ADDR, /*bEndpointAddress: Endpoint Address (IN)*/</span><br><span class="line">        0x03,                 /*bmAttributes: Interrupt endpoint*/</span><br><span class="line">        CUSTOM_HID_EPIN_SIZE, /*wMaxPacketSize: 16 Byte max */</span><br><span class="line">        0x00,</span><br><span class="line">        CUSTOM_HID_FS_BINTERVAL, /*bInterval: Polling Interval */</span><br><span class="line">        /* 34 */</span><br><span class="line"></span><br><span class="line">        0x07,                   /* bLength: Endpoint Descriptor size */</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT, /* bDescriptorType: */</span><br><span class="line">        CUSTOM_HID_EPOUT_ADDR,  /*bEndpointAddress: Endpoint Address (OUT)*/</span><br><span class="line">        0x03,                   /* bmAttributes: Interrupt endpoint */</span><br><span class="line">        CUSTOM_HID_EPOUT_SIZE,  /* wMaxPacketSize: 2 Bytes max  */</span><br><span class="line">        0x00,</span><br><span class="line">        CUSTOM_HID_FS_BINTERVAL, /* bInterval: Polling Interval */</span><br><span class="line">        /* 41 */</span><br><span class="line"></span><br><span class="line">        /****************************CDC************************************/</span><br><span class="line">        /* IAD描述符 */</span><br><span class="line">        /* Interface Association Descriptor */</span><br><span class="line">        USBD_IAD_DESC_SIZE,       // bLength</span><br><span class="line">        USBD_IAD_DESCRIPTOR_TYPE, // bDescriptorType</span><br><span class="line">        0x01,                     // bFirstInterface 接口描述符是在总的配置描述符中的第几个从0开始数 1</span><br><span class="line">        0x02,                     // bInterfaceCount 接口描述符数量 2</span><br><span class="line">        0x02,                     // bFunctionClass     CDC Control</span><br><span class="line">        0x02,                     // bFunctionSubClass  Abstract Control Model</span><br><span class="line">        0x01,                     // bInterfaceProtocol  AT Commands: V.250 etc</span><br><span class="line">        0x00,                     // iFunction</span><br><span class="line"></span><br><span class="line">        /* CDC命令接口描述符 */</span><br><span class="line">        /*Interface Descriptor */</span><br><span class="line">        0x09,                    /* bLength: Interface Descriptor size 长度 */</span><br><span class="line">        USB_DESC_TYPE_INTERFACE, /* bDescriptorType: Interface 接口编号0x04 */</span><br><span class="line">        /* Interface descriptor type */</span><br><span class="line">        USBD_CDC_CMD_INTERFACE, /* bInterfaceNumber: Number of Interface 接口编号，第一个接口编号为1 */</span><br><span class="line">        0x00,                   /* bAlternateSetting: Alternate setting 接口备用编号 0 */</span><br><span class="line">        0x01,                   /* bNumEndpoints: One endpoints used 非0端点的数目 1 cdc接口只使用了一个中断输入端点 */</span><br><span class="line">        0x02,                   /* bInterfaceClass: Communication Interface Class 接口所使用的类0x02 */</span><br><span class="line">        0x02,                   /* bInterfaceSubClass: Abstract Control Model 接口所使用的子类0x02 */</span><br><span class="line">        0x01,                   /* bInterfaceProtocol: Common AT commands 使用AT命令协议 */</span><br><span class="line">        0x00,                   /* iInterface: 接口字符串索引值 0表示没有 */</span><br><span class="line"></span><br><span class="line">        /* 类特殊接口描述符--功能描述符 用来描述接口的功能 */</span><br><span class="line">        /*Header Functional Descriptor*/</span><br><span class="line">        0x05, /* bLength: Endpoint Descriptor size 描述符长度为5字节 */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x00, /* bDescriptorSubtype: Header Func Desc 子类为 Header Func Desc，编号0x00 */</span><br><span class="line">        0x10, /* bcdCDC: spec release number CDC版本 */</span><br><span class="line">        0x01,</span><br><span class="line"></span><br><span class="line">        /*Call Management Functional Descriptor*/</span><br><span class="line">        0x05, /* bFunctionLength */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x01, /* bDescriptorSubtype: Call Management Func Desc 子类为Call Management Func Desc 编号0x01*/</span><br><span class="line">        0x00, /* bmCapabilities: D0+D1 设备自己不管理call management */</span><br><span class="line">        0x01, /* bDataInterface: 1 有一个数据类接口用作call management */</span><br><span class="line"></span><br><span class="line">        /*ACM Functional Descriptor*/</span><br><span class="line">        0x04, /* bFunctionLength */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x02, /* bDescriptorSubtype: Abstract Control Management desc 子类为Abstract Control Management desc编号0x02*/</span><br><span class="line">        0x02, /* bmCapabilities 支持Set_Control_Line_State、Get_Line_Coding请求和Serial_State通知*/</span><br><span class="line"></span><br><span class="line">        /*Union Functional Descriptor*/</span><br><span class="line">        0x05,                    /* bFunctionLength */</span><br><span class="line">        0x24,                    /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE */</span><br><span class="line">        0x06,                    /* bDescriptorSubtype: Union func desc 子类为Union func desc 编号0x06*/</span><br><span class="line">        USBD_CDC_CMD_INTERFACE,  /* bMasterInterface: Communication class interface 编号为1的CDC接口 */</span><br><span class="line">        USBD_CDC_DATA_INTERFACE, /* bSlaveInterface0: Data Class Interface 编号为2的数据类接口 */</span><br><span class="line"></span><br><span class="line">        /*Endpoint 2 Descriptor*/</span><br><span class="line">        0x07,                        /* bLength: Endpoint Descriptor size */</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */</span><br><span class="line">        CDC_CMD_EP,                  /* bEndpointAddress */</span><br><span class="line">        0x03,                        /* bmAttributes: Interrupt */</span><br><span class="line">        LOBYTE(CDC_CMD_PACKET_SIZE), /* wMaxPacketSize: */</span><br><span class="line">        HIBYTE(CDC_CMD_PACKET_SIZE),</span><br><span class="line">        CDC_FS_BINTERVAL, /* bInterval: */</span><br><span class="line">        /*---------------------------------------------------------------------------*/</span><br><span class="line">        .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如何选择工作模式：取决于上位机</p>
<p>如果上位机发送CDC数据，就使能CDC处理；否则默认是USB-HID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USBD_CDC_ItfTypeDef USBD_CDC_Interface_fops_FS =</span><br><span class="line">&#123;</span><br><span class="line">  CDC_Init_FS,</span><br><span class="line">  CDC_DeInit_FS,</span><br><span class="line">  CDC_Control_FS,</span><br><span class="line">  CDC_Receive_FS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8_t cdc_receive_flag = 0;</span><br><span class="line">static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 6 */</span><br><span class="line">  USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[0]);</span><br><span class="line">  USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);</span><br><span class="line">  cdc_receive_flag = 1;</span><br><span class="line">  // 注意这里是中断回调，串口函数有锁</span><br><span class="line">  HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;Buf[0],*Len,UART_TIMEOUT_TIME);</span><br><span class="line">  return (USBD_OK);</span><br><span class="line">  /* USER CODE END 6 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理USB下发的控制信号"><a href="#处理USB下发的控制信号" class="headerlink" title="处理USB下发的控制信号"></a>处理USB下发的控制信号</h2><p>USB HID下发信号的处理函数是CUSTOM_HID_OutEvent_FS：</p>
<p>USB中断传输方式中，每次PC机发送数据后USB设备都会产生中断，设备每完成一次从PC机的Out data的接收都会响应一次OutEvent，因此可以通过修改usbd_custom_hid_if.c中的static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)来实现对接收到数据做处理。实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">USBD_CUSTOM_HID_ItfTypeDef USBD_CustomHID_fops_FS =</span><br><span class="line">&#123;</span><br><span class="line">  CUSTOM_HID_ReportDesc_FS,</span><br><span class="line">  CUSTOM_HID_Init_FS,</span><br><span class="line">  CUSTOM_HID_DeInit_FS,</span><br><span class="line">  CUSTOM_HID_OutEvent_FS //接收数据回调</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)</span><br><span class="line">&#123;</span><br><span class="line">	uint16_t command ;</span><br><span class="line"></span><br><span class="line">    USB_Received_Count = USBD_GetRxCount( &amp;hUsbDeviceFS,CUSTOM_HID_EPOUT_ADDR );</span><br><span class="line">    </span><br><span class="line">    USBD_CUSTOM_HID_HandleTypeDef   *hhid; </span><br><span class="line">    hhid = pHIDData;</span><br><span class="line">    </span><br><span class="line">    //copy和解析</span><br><span class="line">	memcpy(usb_send_buf, hhid-&gt;Report_buf, USB_Received_Count);</span><br><span class="line">	command = usb_send_buf[0] &lt;&lt; 8 | usb_send_buf[1];</span><br><span class="line">	//这里做了个流程区分：如果是USB to UART则调用uart write流程；其他控制信号仅设置计数+1.</span><br><span class="line">	if(command ==WRITE_UART_FUNCITON)</span><br><span class="line">		write_uart_function();</span><br><span class="line">	else</span><br><span class="line">		usb_flag++;</span><br><span class="line">			</span><br><span class="line">  return (USBD_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MCU的while(1)处理usb_flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(1):</span><br><span class="line">	if (usb_flag)</span><br><span class="line">		&#123;</span><br><span class="line">			usb_flag--;</span><br><span class="line">			usb_handle_process();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>usb_handle_process就是对USB buffer的64byte解析并分发到各处理函数，基本实现IO control的机制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void usb_handle_process(void)</span><br><span class="line">&#123;</span><br><span class="line">	command = usb_send_buf[0] &lt;&lt; 8 | usb_send_buf[1];</span><br><span class="line">	length = usb_send_buf[2] &lt;&lt; 8 | usb_send_buf[3];</span><br><span class="line"></span><br><span class="line">	switch (command)</span><br><span class="line">	&#123;</span><br><span class="line">	case UART_PARAMETER_SET:</span><br><span class="line">		uart_parameter_setting();</span><br><span class="line">		break;</span><br><span class="line">	case UART_PIN_LOW_SET:</span><br><span class="line">		uart_pin_low_set();</span><br><span class="line">		break;</span><br><span class="line">	case USB_TO_SPI_FUNCTION:</span><br><span class="line">		usb_to_spi_convert();</span><br><span class="line">		break;</span><br><span class="line">	case USB_TO_SPI_PARAMETER_SET:</span><br><span class="line">		spi_parameter_setting();</span><br><span class="line">		break;</span><br><span class="line">	....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不详细分析各switch case的内容，基本操作都是将usb_send_buf数据，通过SPI&#x2F;UART&#x2F;I2C….透传到MCU下游的芯片. </p>
<p>TODO：为什么UART write需要特殊处理，而不用usb_handle_process分发处理？</p>
<p>因为UART TX没有buffer，如果MCU收到UART write而不立即启动TX传输，上位机的USB 64bytes buffer可能被新的TX data覆盖掉？或者上位机有超时机制？</p>
<p>usb_handle_process只挑几个典型流程分析：</p>
<h3 id="jump-to-boot"><a href="#jump-to-boot" class="headerlink" title="jump_to_boot"></a>jump_to_boot</h3><p>这个用于MCU上直接升级Firmware（IAP）用到，目前开发阶段还没应用，以后用户升级可能用到。</p>
<p>使用函数指针，用调用函数的形式跳转到JumpAddress（0x08000004），即中断向量表的RESET入口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define BOOT_ADDR 0x08000000</span><br><span class="line">typedef void (*pFunction)(void);</span><br><span class="line"></span><br><span class="line">void jump_to_boot(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	uint32_t JumpAddress;</span><br><span class="line">	pFunction Jump_To_Application;</span><br><span class="line"></span><br><span class="line">	usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">	HAL_Delay(10);</span><br><span class="line">	__disable_irq();</span><br><span class="line"></span><br><span class="line">	JumpAddress = *(__IO uint32_t *)(BOOT_ADDR + 4);</span><br><span class="line">	Jump_To_Application = (pFunction)JumpAddress;</span><br><span class="line"></span><br><span class="line">	__HAL_RCC_SYSCFG_CLK_ENABLE();</span><br><span class="line">	__HAL_REMAPMEMORY_FLASH();</span><br><span class="line">	/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">	__set_MSP(*(__IO uint32_t *)BOOT_ADDR);</span><br><span class="line">	*(uint32_t *)RAM_FROM_APP_FLAG_ADDR = RAM_FROM_APP_FLAG_DATA; // jump</span><br><span class="line">	Jump_To_Application();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uart-pin-low"><a href="#uart-pin-low" class="headerlink" title="uart_pin_low"></a>uart_pin_low</h3><p>此功能是BMS业务的流程，BMS chip的wakeup操作使用RX pin，拉低UART TX为低并保持一段时间，再拉高TX，形成BMS chip的wakeup。</p>
<p>注意这里不是为了形成UART break frame（也是RX拉低，保持一个byte的周期，再拉高），所以UART RX pin需要先析构，在GPIO模式下才能无UART协议干扰的产生BMS wakeup信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void jaguar_uart_pin_low_fun(uint32_t ustimer)</span><br><span class="line">&#123;</span><br><span class="line">	MX_TIM6_Init(TIME_BASE_1US); //timer 1us精度</span><br><span class="line">	UART2_DeInit(); //uart2析构</span><br><span class="line">	jaguar_uart_gpio_fun(); //设置PA2,PA3为高，即UART的RX/TX pin</span><br><span class="line"></span><br><span class="line">	HAL_TIM_Base_Start_IT(&amp;htim6); //开始计时</span><br><span class="line">	jaguar_wire_pin_low(); //设置PA2（TX）为低</span><br><span class="line">	while (one_wire_timer_counter_1US &lt; ustimer) //ustimer来自USB-HID数据</span><br><span class="line">	&#123;</span><br><span class="line">		// printf(&quot;sync low tim:%d \r\n&quot;,one_wire_timer_counter100US);</span><br><span class="line">	&#125;;</span><br><span class="line">	jaguar_wire_pin_high(); //设置PA2（TX）为高</span><br><span class="line">	HAL_TIM_Base_Stop_IT(&amp;htim6); //结束计时</span><br><span class="line">	//设置波特率，这里如果UART之前设置过，就保持原值；否则默认值1M波特率</span><br><span class="line">	if (saved_baudrate != 0)</span><br><span class="line">		MX_USART2_UART_Init(saved_baudrate); // keep the baudrate(set by USB-HID uart-config command).</span><br><span class="line">	else</span><br><span class="line">		MX_USART2_UART_Init(1000000); // reset baud rate.</span><br><span class="line">	Rx_buf_pos = 0;</span><br><span class="line">	MX_TIM6_Init(TIME_BASE_100US);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usb-to-spi"><a href="#usb-to-spi" class="headerlink" title="usb_to_spi"></a>usb_to_spi</h3><p>前面没有详细分析SPI的传输，此处分析。</p>
<p>o2link spec定义的USB to SPI数据包格式：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141701291.png" alt="image-20240514170141237"></p>
<p>SPI数据通信的原理：</p>
<p>SPI一般设置为全双工双向通信，利用移位register交换master&#x2F;slave两端的数据register(FIFO)里的数据。</p>
<p>全双工时，SPI不存在单向的发送或单向的接收，数据一定是“交换”的。firmware的关注点是用RX register发数据，还是从Tx register拿数据。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141715633.png" alt="image-20240514171557572"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141705044.png" alt="image-20240514170528006"></p>
<p>代码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void usb_to_spi_convert(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t recive_buf[SPI_MAX_DATA_NUM] = &#123;0&#125;;</span><br><span class="line">	uint8_t ret = 0;</span><br><span class="line"></span><br><span class="line">	if (usb_send_buf[SPI_LENGTH_SITE] &gt; 60)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = SPI_INVALID_PARAMETER;</span><br><span class="line">		usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//按o2link spec解析为SPI命令参数和数据，数据内容决定对下层DFE芯片register是读还是写</span><br><span class="line">	ret = usb_spi_convert_data(usb_send_buf[SPI_CHIPID_SITE], usb_send_buf[SPI_LENGTH_SITE], &amp;usb_send_buf[SPI_DATA_SITE], recive_buf);</span><br><span class="line">	if (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = ret;</span><br><span class="line">	&#125;</span><br><span class="line">	//按o2link spec解析出返回数据</span><br><span class="line">	memcpy(&amp;usb_send_buf[SPI_DATA_SITE], recive_buf, usb_send_buf[SPI_LENGTH_SITE]);</span><br><span class="line">	usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint8_t usb_spi_convert_data(uint8_t dev_id,uint8_t data_num,uint8_t * write_buf,uint8_t *read_buf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    uint8_t ret = 0;</span><br><span class="line">    </span><br><span class="line">    //拉低CS片选</span><br><span class="line">    HAL_GPIO_WritePin(spi_gpio_cs_pins[dev_id].gpio_base,spi_gpio_cs_pins[dev_id].gpio_pin,GPIO_PIN_RESET);</span><br><span class="line">	//启动SPI传输</span><br><span class="line">    ret = HAL_SPI_TransmitReceive(&amp;hspi1, write_buf, read_buf, data_num ,SPI_TIMEOUT_TIME);</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_WritePin(spi_gpio_cs_pins[dev_id].gpio_base,spi_gpio_cs_pins[dev_id].gpio_pin,GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPI传输的8bit模式具体内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HAL_SPI_TransmitReceive():</span><br><span class="line"></span><br><span class="line">hspi-&gt;pRxBuffPtr  = (uint8_t *)pRxData; //RX buffer的指针</span><br><span class="line">hspi-&gt;RxXferCount = Size;</span><br><span class="line">hspi-&gt;RxXferSize  = Size;</span><br><span class="line">hspi-&gt;pTxBuffPtr  = (uint8_t *)pTxData; //TX buffer的指针</span><br><span class="line">hspi-&gt;TxXferCount = Size;</span><br><span class="line">hspi-&gt;TxXferSize  = Size;</span><br><span class="line"></span><br><span class="line">/* Enable SPI peripheral */</span><br><span class="line">__HAL_SPI_ENABLE(hspi);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">/* Transmit and Receive data in 8 Bit mode */</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    while ((hspi-&gt;TxXferCount &gt; 0U) || (hspi-&gt;RxXferCount &gt; 0U))</span><br><span class="line">    &#123;</span><br><span class="line">      /* Check TXE flag */</span><br><span class="line">      //SPI_FLAG_TXE: SPI status flag: Tx buffer empty flag, 表示当前TX FIFO数据为空，可能是首次启动还没填数据或上次已传完</span><br><span class="line">      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) &amp;&amp; (hspi-&gt;TxXferCount &gt; 0U) &amp;&amp; (txallowed == 1U))</span><br><span class="line">      &#123;</span><br><span class="line">       // DR: SPI data register, 按uint8（byte）填数据</span><br><span class="line">        *(__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR = (*hspi-&gt;pTxBuffPtr);</span><br><span class="line">        //更新数据指针(准备下次传输)</span><br><span class="line">        hspi-&gt;pTxBuffPtr++;</span><br><span class="line">        hspi-&gt;TxXferCount--;</span><br><span class="line">        /* Next Data is a reception (Rx). Tx not allowed */</span><br><span class="line">        //处理完TX，下面必须处理RX</span><br><span class="line">        txallowed = 0U;</span><br><span class="line">        </span><br><span class="line">        /* Wait until RXNE flag is reset */</span><br><span class="line">        //SPI_FLAG_RXNE: Rx buffer not empty flag, 有收到数据待处理</span><br><span class="line">          if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) &amp;&amp; (hspi-&gt;RxXferCount &gt; 0U))</span><br><span class="line">          &#123;</span><br><span class="line">          	//从DR register取数据到RX buffer</span><br><span class="line">            (*(uint8_t *)hspi-&gt;pRxBuffPtr) = *(__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR;</span><br><span class="line">            hspi-&gt;pRxBuffPtr++;</span><br><span class="line">            hspi-&gt;RxXferCount--;</span><br><span class="line">            /* Next Data is a Transmission (Tx). Tx is allowed */</span><br><span class="line">            //处理完RX，下一轮必须处理TX</span><br><span class="line">            txallowed = 1U;</span><br><span class="line">          &#125;</span><br><span class="line">          //超时判断</span><br><span class="line">          if ((((HAL_GetTick() - tickstart) &gt;=  Timeout) &amp;&amp; ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))</span><br><span class="line">          &#123;</span><br><span class="line">            errorcode = HAL_TIMEOUT;</span><br><span class="line">            goto error;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TX RX处理的判断标准是读SR register状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** @brief  Check whether the specified SPI flag is set or not.</span><br><span class="line">  * @param  __HANDLE__ specifies the SPI Handle.</span><br><span class="line">  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.</span><br><span class="line">  * @param  __FLAG__ specifies the flag to check.</span><br><span class="line">  *         This parameter can be one of the following values:</span><br><span class="line">  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag</span><br><span class="line">  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag</span><br><span class="line">  *            @arg SPI_FLAG_CRCERR: CRC error flag</span><br><span class="line">  *            @arg SPI_FLAG_MODF: Mode fault flag</span><br><span class="line">  *            @arg SPI_FLAG_OVR: Overrun flag</span><br><span class="line">  *            @arg SPI_FLAG_BSY: Busy flag</span><br><span class="line">  *            @arg SPI_FLAG_FRE: Frame format error flag</span><br><span class="line">  *            @arg SPI_FLAG_FTLVL: SPI fifo transmission level</span><br><span class="line">  *            @arg SPI_FLAG_FRLVL: SPI fifo reception level</span><br><span class="line">  * @retval The new state of __FLAG__ (TRUE or FALSE).</span><br><span class="line">  */</span><br><span class="line">#define __HAL_SPI_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)-&gt;Instance-&gt;SR) &amp; (__FLAG__)) == (__FLAG__))</span><br></pre></td></tr></table></figure>

<p>为什么SPI传输TX，RX是同时又交替的处理数据：</p>
<p>SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</p>
<p>因此HAL_SPI_TransmitReceive()同时处理RX和TX，和UART的RX&#x2F;TX单向传输不同。</p>
<p>​	</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32--串口：UART和USB-COM</title>
    <url>/2024/10/30/STM32--%E4%B8%B2%E5%8F%A3%EF%BC%9AUART%E5%92%8CUSB-COM/</url>
    <content><![CDATA[<h1 id="STM32–串口：UART和USB-COM"><a href="#STM32–串口：UART和USB-COM" class="headerlink" title="STM32–串口：UART和USB-COM"></a>STM32–串口：UART和USB-COM</h1><p>背景描述：STM32板子有TTL UART连接下游IC，同时有USB口连接上游的上位机PC。</p>
<p>本文描述STM32如何直接使用UART通信，如何用USB CDC实现虚拟串口USB-COM也用UART通信。</p>
<h2 id="UART项目配置"><a href="#UART项目配置" class="headerlink" title="UART项目配置"></a>UART项目配置</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301153104.png" alt="image-20240430115304007"></p>
<h2 id="UART的轮询与中断"><a href="#UART的轮询与中断" class="headerlink" title="UART的轮询与中断"></a>UART的轮询与中断</h2><h2 id="USB的CDC类实现USB-COM"><a href="#USB的CDC类实现USB-COM" class="headerlink" title="USB的CDC类实现USB-COM"></a>USB的CDC类实现USB-COM</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417744.png" alt="image-20240430141713692"></p>
<h2 id="双串口的实现：UART和USB-COM"><a href="#双串口的实现：UART和USB-COM" class="headerlink" title="双串口的实现：UART和USB-COM"></a>双串口的实现：UART和USB-COM</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417818.png" alt="image-20240430141738799"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417518.png" alt="image-20240430141746453"></p>
<p>参考：</p>
<p><a href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#Communications_Devices_Class_(CDC)">ST: Introduction to USB with STM32</a></p>
<p><a href="https://controllerstech.com/send-and-receive-data-to-pc-without-uart-stm32-usb-com/">send-and-receive-data-to-pc-without-uart-stm32-usb-com</a></p>
<p><a href="https://www.cnblogs.com/FBsharl/p/17847962.html">stm32：实现USB虚拟串口（CDC_VPC）</a></p>
<p><a href="https://shequ.stmicroelectronics.cn/thread-637593-1-1.html">如何让CDC类USB设备批量接收64字节以上数据</a></p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32--从0创建项目和设计架构</title>
    <url>/2024/10/30/STM32--%E4%BB%8E0%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="STM32–从0创建项目和设计架构"><a href="#STM32–从0创建项目和设计架构" class="headerlink" title="STM32–从0创建项目和设计架构"></a>STM32–从0创建项目和设计架构</h1><h2 id="野火STM32-F4创建项目："><a href="#野火STM32-F4创建项目：" class="headerlink" title="野火STM32 F4创建项目："></a>野火STM32 F4创建项目：</h2><p><a href="https://doc.embedfire.com/mcu/stm32/f4/hal_general/zh/latest/doc/chapter10/chapter10.html">https://doc.embedfire.com/mcu/stm32/f4/hal_general/zh/latest/doc/chapter10/chapter10.html</a></p>
<h2 id="STMF0创建项目："><a href="#STMF0创建项目：" class="headerlink" title="STMF0创建项目："></a>STMF0创建项目：</h2><p>（1）芯片型号启动创建</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221510696.png" alt="image-20240722151016542"></p>
<p>（2）配置时钟和各外设</p>
<p>这里参考已有的其他stm32f0项目，用CubeMX打开两个项目，在GUI对照配置新项目自动生成代码。要特别注意时钟的配置，如果使用外接晶振，和具体开发板环境有关。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221516703.png" alt="image-20240722151602583"></p>
<p>配置外设和GPIO有技巧：先配置外设（connectivity项，SPI，UART，I2C…），配好后会自动配置外设占用的GPIO；而独立的GPIO功能（一般作为debug pin）在外设配完后再补充。</p>
<p>外设pin脚可以设置标签，便于不看电路原理图就知道是做什么用，但是注意要保留pin本身的含义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221528881.png" alt="image-20240722152839824"></p>
<p>在配置pin功能如果有感叹号表示有部分功能和其他模块冲突，例如UART1的流控功能和USB冲突（红色），由于UART1并不开启流控，此处不需要管。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221600775.png" alt="image-20240722160043740"></p>
<p>(3)生成MDK-ARM项目</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>CubeMX项目要想可维护，后期能通过GUI方式更新配置同时不破坏用户自定义代码，有两种方式：</p>
<ul>
<li>在GUI生成代码内加User代码，即User Begin ~ User End的代码区域</li>
<li>创建独立的代码文件夹，和GUI创建的项目代码完全隔离。用户代码要使用GUI生成的函数和数据只引用GUI的外设头文件</li>
</ul>
<p>以下是使用独立代码文件夹的方式：</p>
<p>（1）Keil打开GUI自动创建的项目（包含USB middleware），首先配置好编译链接烧录等配置。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221630057.png" alt="image-20240722163031991"></p>
<p>（2）添加自定义文件夹的.c文件</p>
<p>这里的Group一般以文件夹结构命名，Files只是.c源文件，头文件.h不是在这里添加</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221648462.png" alt="image-20240722164837416"></p>
<p>（3）添加自定义文件夹的.h头文件</p>
<p>在项目option里加头文件路径</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221650166.png" alt="image-20240722165046119"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221652202.png" alt="image-20240722165206164"></p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32--搭建VSCode+STMCubeIDE开发环境</title>
    <url>/2024/10/30/STM32--%E6%90%AD%E5%BB%BAVSCode+STMCubeIDE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="STM32–搭建VSCode-STMCubeIDE开发环境"><a href="#STM32–搭建VSCode-STMCubeIDE开发环境" class="headerlink" title="STM32–搭建VSCode+STMCubeIDE开发环境"></a>STM32–搭建VSCode+STMCubeIDE开发环境</h1><h2 id="用STM32CubeIDE创建工程"><a href="#用STM32CubeIDE创建工程" class="headerlink" title="用STM32CubeIDE创建工程"></a>用STM32CubeIDE创建工程</h2><h2 id="用VSCode编辑代码"><a href="#用VSCode编辑代码" class="headerlink" title="用VSCode编辑代码"></a>用VSCode编辑代码</h2><h3 id="配置-vscode使能tab补全"><a href="#配置-vscode使能tab补全" class="headerlink" title="配置.vscode使能tab补全"></a>配置.vscode使能tab补全</h3><p>Stm32的HAL库默认是没有被VSCode的C&#x2F;C++ intelligence检测到，自动补全功能不完整，例如HAL_UART_XXX不能tab补全到HAL_UART_Transmit，这个API定义在Drivers&#x2F;Drivers&#x2F;STM32FXXX_HAL_Driver&#x2F;Inc里，C&#x2F;C++ intelligence没有检测到这个路径，因此需要配置C&#x2F;C++ intelligence的c_cpp_properties.json, 添加include和defines。</p>
<p>（1）打开STM32项目</p>
<p>注意：要配置哪个STM32项目就VSCode打开哪个目录，不要打开包括多个STM32项目的workspace，不然配置的.vscode是针对workspace目录的，不会对各项目生效。</p>
<p>比如以下workspace有几个STM32CubeIDE创建的项目，VSCode应该打开具体的项目serial-test-isr再配置该项目的.vscode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0&gt; ls</span><br><span class="line"></span><br><span class="line">    目录: C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2024/4/29     10:03                .metadata</span><br><span class="line">d-----         2024/4/29     10:34                .vscode</span><br><span class="line">d-----         2024/4/24     19:45                led-test</span><br><span class="line">d-----         2024/4/25     11:25                serial-test</span><br><span class="line">d-----         2024/4/29     10:06                serial-test-isr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0&gt; cd .\serial-test-isr\</span><br><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0\serial-test-isr&gt; ls</span><br><span class="line"></span><br><span class="line">    目录: C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0\serial-test-isr</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2024/4/28     22:33                .settings</span><br><span class="line">d-----         2024/4/29     10:06                .vscode</span><br><span class="line">d-----         2024/4/28     16:26                Core</span><br><span class="line">d-----         2024/4/28     17:51                Debug</span><br><span class="line">d-----         2024/4/28     16:26                Drivers</span><br><span class="line">-a----         2024/4/28     16:39          25210 .cproject</span><br><span class="line">-a----         2024/4/28     16:39           8275 .mxproject</span><br><span class="line">-a----         2024/4/28     16:30           1221 .project</span><br><span class="line">-a----         2024/4/28     17:56          10224 serial-test-isr Debug.launch</span><br><span class="line">-a----         2024/4/28     16:39           2975 serial-test-isr.ioc</span><br><span class="line">-a----         2024/4/28     16:39           5306 STM32F072C8TX_FLASH.ld</span><br></pre></td></tr></table></figure>

<p>（2）配置.vscode</p>
<p>VSCode左下角setting -&gt; Command Palette -&gt; 搜索: C&#x2F;C++ Edit Configurations (UI) 或者 (JSON)</p>
<p>C&#x2F;C++ Edit Configurations (UI) ：</p>
<p>在Include path添加HAL库定义的路径：这里直接用**递归搜索，类似.gitignore的语法，不需要指定到具体的Drivers&#x2F;STM32FXXX_HAL_Driver&#x2F;Inc路径。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404291104878.png" alt="image-20240429104934058"></p>
<p>C&#x2F;C++ Edit Configurations (JSON)方式的配置，UI配置也会反应在此 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;Drivers/**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;gnu++17&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）VSCode调用STM32 HAL 函数自动补全</p>
<p>现在可以tab补全STM32 HAL的所有库函数，可以彻底抛弃STM32CubeIDE的编辑界面：)</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404291104289.png" alt="image-20240429105530310"></p>
<h2 id="用STM32CubeIDE和J-link调试和烧录"><a href="#用STM32CubeIDE和J-link调试和烧录" class="headerlink" title="用STM32CubeIDE和J-link调试和烧录"></a>用STM32CubeIDE和J-link调试和烧录</h2>]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI开发（一）EDK2环境搭建</title>
    <url>/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89EDK2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="UEFI开发（一）EDK2环境搭建"><a href="#UEFI开发（一）EDK2环境搭建" class="headerlink" title="UEFI开发（一）EDK2环境搭建"></a>UEFI开发（一）EDK2环境搭建</h1><p>官方文档：</p>
<p><a href="https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-with-EDK-II">https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-with-EDK-II</a></p>
<p><a href="https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-User-Documentation">https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-User-Documentation</a></p>
<h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>参考：<a href="https://github.com/tianocore/edk2?tab=readme-ov-file#submodules">edk2&#x2F;Submodules</a></p>
<p>在C盘根目录用git命令下载edk2并下载submodule：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tianocore/edk2.git</span><br><span class="line">cd edk2</span><br><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure>

<p>如果要切换到stable tag版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -l #列出tag， -l: list</span><br><span class="line">git checkout edk2-stable202X0X #切table tag</span><br><span class="line">git submodule update #更新submodule（对应stable tag）</span><br></pre></td></tr></table></figure>

<p>我的环境是VS2022，当前edk2 master主线支持VS2022，而最新的stable tag不支持，所以用master版本，没必要checkout到stable tag。</p>
<h2 id="编译EDK2"><a href="#编译EDK2" class="headerlink" title="编译EDK2"></a>编译EDK2</h2><h3 id="编译环境准备"><a href="#编译环境准备" class="headerlink" title="编译环境准备"></a>编译环境准备</h3><p>参考：<a href="https://github.com/tianocore/tianocore.github.io/wiki/Windows-systems">https://github.com/tianocore/tianocore.github.io/wiki/Windows-systems</a></p>
<ol>
<li><p>按 <a href="edk2%5CBaseTools%5CBin"><strong>Build</strong></a> 下载NASM和ASL二进制包，放到C盘跟&#x3D;根目录（和edk2同路径）</p>
</li>
<li><p>运行edksetup.bat，编译edk2&#x2F;BaseTool</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\edk2&gt;edksetup.bat</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">** Visual Studio 2022 Developer Command Prompt v17.13.6</span><br><span class="line">** Copyright (c) 2022 Microsoft Corporation</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">[vcvarsall.bat] Environment initialized for: &#x27;x86&#x27;</span><br><span class="line">Using EDK2 in-source Basetools</span><br><span class="line">          PATH      = C:\edk2\BaseTools\BinWrappers\WindowsLike;D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\HostX86\x86;D:\Program Files\Microsoft Visual .... Studio\2022\Community\Common7\IDE\VC\Linux\bin\ConnectionManagerExe;D:\Program Files\Microsoft Visual Studio\2022\Community\VC\vcpkg</span><br><span class="line"></span><br><span class="line">     WORKSPACE      = C:\edk2</span><br><span class="line"></span><br><span class="line">EDK_TOOLS_PATH      = C:\edk2\BaseTools</span><br><span class="line">BASE_TOOLS_PATH     = C:\edk2\BaseTools</span><br><span class="line"> EDK_TOOLS_BIN      = C:\edk2\BaseTools\Bin\Win32</span><br><span class="line">     CONF_PATH      = C:\edk2\Conf</span><br><span class="line">     PYTHON_COMMAND = py -3</span><br><span class="line">         PYTHONPATH = C:\edk2\BaseTools\Source\Python;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!!! WARNING !!! NASM_PREFIX environment variable is not set</span><br><span class="line">  Found nasm.exe, setting the environment variable to C:\nasm\</span><br><span class="line"></span><br><span class="line">!!! WARNING !!! CLANG_BIN environment variable is not set</span><br></pre></td></tr></table></figure>

<p>log中的一些信息含义：</p>
<p>（1）新版本edk2已经包含python包，无需自己再去下载和指定python路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PYTHONPATH = C:\edk2\BaseTools\Source\Python;</span><br></pre></td></tr></table></figure>

<p>（2）已自动设置nasm路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Found nasm.exe, setting the environment variable to C:\nasm\</span><br></pre></td></tr></table></figure>

<p>（3）用VS2022编译，CLANG_BIN不用设置</p>
<p>编译输出二进制在edk2\BaseTools\Bin</p>
<h3 id="编译目标模块"><a href="#编译目标模块" class="headerlink" title="编译目标模块"></a>编译目标模块</h3><p>运行edksetup后，再执行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">build</span><br></pre></td></tr></table></figure>

<p>编译目标由edk2&#x2F;Conf&#x2F;target.txt的ACTIVE_PLATFORM和TARGET_ARCH指定</p>
<h3 id="终端乱码问题"><a href="#终端乱码问题" class="headerlink" title="终端乱码问题"></a>终端乱码问题</h3><p>在编译前可用以下命令将命令行的输出转成UTF8格式，防止输出乱码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure>

<p>下图说明从Conf&#x2F;target的产生到编译完成的全流程</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504141429251.png" alt="image-20250414142907112"></p>
<h2 id="搭建UEFI-shell启动盘"><a href="#搭建UEFI-shell启动盘" class="headerlink" title="搭建UEFI shell启动盘"></a>搭建UEFI shell启动盘</h2><h3 id="创建UEFI-shell盘"><a href="#创建UEFI-shell盘" class="headerlink" title="创建UEFI shell盘"></a>创建UEFI shell盘</h3><ol>
<li>找一个U盘，格式化成FAT32，然后在U盘根目录下建立&#x2F;efi&#x2F;boot目录。</li>
<li>自己编译UEFI shell.efi或者下载Shell.efi</li>
<li>把Shell.efi改名成BOOTX64.efi，然后把BOOTX64.efi拷贝到U盘&#x2F;efi&#x2F;boot&#x2F;目录下。</li>
<li>自己编译的其他UEFI程序，如MdeModulePkg Application efi或者DXE efi驱动，都可放到U盘根目录</li>
<li>U盘插入电脑，开机后按F12(不同厂商电脑可能有所不同)进入UEFI menu选择页面，选择从U盘启动</li>
</ol>
<p>(1) 如何自己编译UEFI shell.efi：</p>
<p>前面edk2编译环境ok后，改Conf&#x2F;target.txt为编译ShellPkg：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACTIVE_PLATFORM       = ShellPkg/ShellPkg.dsc</span><br><span class="line">TARGET_ARCH           = X64</span><br><span class="line">TOOL_CHAIN_TAG        = VS2019</span><br></pre></td></tr></table></figure>

<p>编译完成后输出Shell.efi在Build&#x2F;Shell&#x2F;<TOOL_CHAIN_TAG>&#x2F;<TARGET_ARCH>&#x2F;ShellPkg&#x2F;Application&#x2F;Shell&#x2F;Shell&#x2F;OUTPUT&#x2F;目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Finished generating code</span><br><span class="line">        &quot;GenFw&quot; -e UEFI_APPLICATION -o C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\OUTPUT\Shell.efi C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\DEBUG\Shell.dll</span><br><span class="line">        copy /y C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\OUTPUT\Shell.efi </span><br><span class="line"></span><br><span class="line">- Done -</span><br></pre></td></tr></table></figure>

<p>(2)下载编译好的Shell.efi</p>
<p><a href="https://github.com/pbatard/UEFI-Shell/releases">https://github.com/pbatard/UEFI-Shell/releases</a></p>
<p>包含各平台的shell.efi</p>
<h3 id="startup-nsh脚本"><a href="#startup-nsh脚本" class="headerlink" title="startup.nsh脚本"></a>startup.nsh脚本</h3><p>UEFI Shell.efi启动时会查找根目录下有没有startup.nsh脚本，如果有的话会自动执行startup.nsh脚本</p>
<p>比如U盘在UEFI shell下的盘符为 FS0: ，想要启动自动执行根目录的myUefiApp.efi程序，startup.nsh脚本如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#切换到FS0盘符的根目录</span><br><span class="line">FS0:</span><br><span class="line">#执行程序（预先放在根目录）</span><br><span class="line">MyUefiApp.efi</span><br></pre></td></tr></table></figure>

<p>也可以用绝对路径执行MyUefiApp.efi，即 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FS0:\MyUefiApp.efi</span><br></pre></td></tr></table></figure>

<h3 id="进入UEFI-shell"><a href="#进入UEFI-shell" class="headerlink" title="进入UEFI shell"></a>进入UEFI shell</h3><p>如图是F12进入U盘UEFI shell环境，其中：</p>
<p>UEFI shell版本v2.7，可见来源信息</p>
<p>map -r显示可识别设备信息：</p>
<ol>
<li><p>FS是filesystem文件系统设备。FS0是USB设备，位于PCi bridge 0x14上；FS1是Sata硬盘，位于PCi bridge 0x17上</p>
</li>
<li><p>BLK是文件分区。BLK0是USB的分区，BLK2和4都是Sata硬盘的文件分区</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504161706334.png" alt="image-20250416170607057"></p>
<h3 id="copy-startup加快测试"><a href="#copy-startup加快测试" class="headerlink" title="copy+startup加快测试"></a>copy+startup加快测试</h3><p><a href="https://ss64.com/nt/xcopy.html">https://ss64.com/nt/xcopy.html</a></p>
<p>调试efi经常要重新编译和拷贝efi到u盘，用copy命令自动化</p>
<p>build编译模块时，输出的efi已经拷贝过一次。这里再创建一个.bat拷到u盘（E盘根目录）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy /y C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\SdMmcPciHcDxe\OUTPUT\SdMmcPciHcDxe.efi C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\SdMmcPciHcDxe.efi</span><br><span class="line"></span><br><span class="line">copy /y C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\SdMmcPciHcDxe.efi E:\</span><br></pre></td></tr></table></figure>

<p>这样编译后自动拷贝到U盘，在UEFI测试机上创建startup.sh自动运行efi驱动加载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs0:</span><br><span class="line">load SdMmcPciHcDxe.efi</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UEFI开发</category>
      </categories>
      <tags>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI开发（二）</title>
    <url>/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="UEFI开发（二）"><a href="#UEFI开发（二）" class="headerlink" title="UEFI开发（二）"></a>UEFI开发（二）</h1><h2 id="Library库"><a href="#Library库" class="headerlink" title="Library库"></a>Library库</h2><p><a href="https://blog.csdn.net/weixin_45279063/article/details/115324601">https://blog.csdn.net/weixin_45279063/article/details/115324601</a></p>
<p>以后面要用到的DEBUG库为例：</p>
<p>库的调用方是MdeModulePkg下的某个INF模块，被调用方是MdePkg库（这个属于基础库很常用）</p>
<ol>
<li>调用方的INF中要导入库模块的dec和要用到的LibraryClasses</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Packages]</span><br><span class="line">  MdePkg/MdePkg.dec #这里包含了库模块MdePkg的dec声明，获取到MdePkg所有对外开放的库接口</span><br><span class="line">  MdeModulePkg/MdeModulePkg.dec #这是调用方模块</span><br><span class="line"></span><br><span class="line">[LibraryClasses]</span><br><span class="line">  DevicePathLib</span><br><span class="line">  UefiBootServicesTableLib</span><br><span class="line">  UefiRuntimeServicesTableLib</span><br><span class="line">  MemoryAllocationLib</span><br><span class="line">  BaseMemoryLib</span><br><span class="line">  UefiLib</span><br><span class="line">  BaseLib</span><br><span class="line">  UefiDriverEntryPoint</span><br><span class="line">  DebugLib #这里导入了MdePkg库的DebugLib类（头文件），类似其他语言的import或者include namespace</span><br><span class="line">  PcdLib</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用方的c代码中可以直接include库的头文件（不需要用相对地址包含头文件）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;Library/DebugLib.h&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用方使用库的函数体DEBUG();</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEBUG((DEBUG_INFO, &quot;Initializing XXX controller in slot %d\n&quot;, Slot));</span><br><span class="line"></span><br><span class="line">Status = InitController(PciIo, Slot);</span><br><span class="line">if (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG((DEBUG_ERROR, &quot;Failed to switch Host to PCIe mode: %r\n&quot;, Status));</span><br><span class="line">    return Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DEBUG打印"><a href="#DEBUG打印" class="headerlink" title="DEBUG打印"></a>DEBUG打印</h2><p><a href="https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging">https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging</a></p>
<p>在使用DEBUG INFO的MdeModulePkg模块的dsc中，声明DEBUG库的全局变量PcdDebugPropertyMask和PcdDebugPrintErrorLevel，指定支持INFO级别打印，否则默认只会打印DEBUG(ERROR)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[PcdsFixedAtBuild]</span><br><span class="line"># refer to https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging</span><br><span class="line">  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x0f</span><br><span class="line">  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x80000040</span><br></pre></td></tr></table></figure>

<p>再编译MdeModulePkg inf，输出的efi可见INFO级别的打印生效。</p>
<h2 id="UTF8中文报错"><a href="#UTF8中文报错" class="headerlink" title="UTF8中文报错"></a>UTF8中文报错</h2><p>问题log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\edk2\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\BayhubHost.h(1): error C2220: the following warning is treated as an error</span><br><span class="line">C:\edk2\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\BayhubHost.h(1): warning C4819: The file contains a character that cannot be represented in the current code page (936). Save the file in Unicode format to prevent data loss</span><br></pre></td></tr></table></figure>

<p>错误信息指出：<br>警告C4819被当作错误处理<br>文件包含无法在当前代码页(936，即中文GBK编码)中表示的字符</p>
<p>解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用Notepad++重新保存文件:</span><br><span class="line">打开文件，编码选择&quot;UTF-8 with signature (UTF-8-BOM)&quot;或者&quot;UTF-8&quot;</span><br><span class="line">保存文件</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件有非ASCII字符（特别是在注释中）</span><br><span class="line">有时文件的首行可能有不可见的BOM（字节顺序标记）或其他特殊字符</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UEFI开发</category>
      </categories>
      <tags>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu PC开发环境配置</title>
    <url>/2023/04/26/Ubuntu%20PC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Ubuntu-PC开发环境配置"><a href="#Ubuntu-PC开发环境配置" class="headerlink" title="Ubuntu PC开发环境配置"></a>Ubuntu PC开发环境配置</h1><p>本文基于Ubuntu 22.04 LTS</p>
<h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><h2 id="软件下载源"><a href="#软件下载源" class="headerlink" title="软件下载源"></a>软件下载源</h2><p>使用国内软件源下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">software&amp;updates -&gt; Ubuntu Software -&gt; download from -&gt; cn99.com或aliyun.com</span><br></pre></td></tr></table></figure>

<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>安装中文输入法(pinyin)的步骤：</p>
<p>安装中文支持：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Install/Remove Languages -&gt; 安装chinese simplified</span><br></pre></td></tr></table></figure>

<p>设置系统语言为中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成Chinese</span><br></pre></td></tr></table></figure>

<p>安装Fcitx框架和中文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-bin #安装fcitx框架</span><br><span class="line">sudo apt-get install fcitx-table #安装输入法栏，其中自动安装拼音输入法</span><br><span class="line">fcitx --version</span><br></pre></td></tr></table></figure>

<p>使用Fcitx框架，重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Keyboard input method system 选择Fcitx 4</span><br></pre></td></tr></table></figure>

<p>添加输入法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ubuntu右上角的小键盘图标 -&gt; configure -&gt; 添加pinyin（只有系统语言为中文时才能添加中文输入法）</span><br></pre></td></tr></table></figure>

<p>切换中英文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + space</span><br></pre></td></tr></table></figure>

<p>设置系统语言改回英文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成English</span><br></pre></td></tr></table></figure>

<h2 id="snap包管理工具"><a href="#snap包管理工具" class="headerlink" title="snap包管理工具"></a>snap包管理工具</h2><p><a href="https://snapcraft.io/store">Snap</a>是Canonical开发的Linux包管理和软件部署工具。 </p>
<p>安装和使用参考 <a href="https://phoenixnap.com/kb/install-snap-ubuntu#:~:text=1%20Start%20by%20updating%20packages%3A%0Asudo%20apt,update%202%20Enter%20the%20following%20command%3A"><strong>How to Install Snap on Ubuntu</strong></a></p>
<p>特点：丰富的第三方工具库，包括开源工具和闭源工具；二进制安装，不是源码编译</p>
<p>相比apt，其查找工具和安装极为简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap find &lt;keyword&gt; #查找keyword相关的工具，显示可安装的列表</span><br><span class="line">sudo snap install &lt;package&gt; #安装列表中的工具</span><br></pre></td></tr></table></figure>

<p>查看和卸载snap安装的包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snap list</span><br><span class="line">sudo snap remove &lt;package&gt;</span><br></pre></td></tr></table></figure>

<p>示例：安装VSCode和Chrome</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap find vscode #找到&lt;package&gt;为code</span><br><span class="line">sudo snap install code --classic</span><br><span class="line">sudo snap find chrome #找到&lt;package&gt;为chromium</span><br><span class="line">sudo snap install chromium</span><br></pre></td></tr></table></figure>

<h2 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h2><p>setting -&gt; keyboard -&gt; shortcuts -&gt; custom shortcut -&gt; 为应用程序添加快捷键</p>
<p>以截图工具flameshot为例，设置快捷键的command为调用flameshot的命令，截图默认保存到~&#x2F;Pictures</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051055723.png" alt="image-20230505105544618"></p>
<p>要配置其他flameshot命令的快捷键，用 <code>man flameshot</code> 查看，参考 <a href="https://flameshot.org/docs/guide/key-bindings/">Keyboard shortcuts for Flameshot</a></p>
<h2 id="Timeshift备份系统"><a href="#Timeshift备份系统" class="headerlink" title="Timeshift备份系统"></a>Timeshift备份系统</h2><p>22.04系统似乎比较容易挂，进不了系统显示”Oh no… system can’t recover…”，比如：</p>
<p>Nvdia驱动选择开源版本xserver就挂了一次, recovery模式看&#x2F;var&#x2F;log&#x2F;message有nouveau和nvidia module相关问题</p>
<p>学习xv6时安装编译环境时也挂了一次(不能安装到&#x2F;usr&#x2F;local，应该安装到&#x2F;home)，recovery模式dpkg report显示failure log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbol lookup error: /lib/x86_64-linux-gnu/libgnutls.so.30: undefined symbol: __gmpz_limbs_write </span><br></pre></td></tr></table></figure>

<p>都是找遍办法都修复不了，只能重装…</p>
<p>为了解决此问题，使用Timeshift将系统备份，参考: <a href="https://itsfoss.com/backup-restore-linux-timeshift/">How to Backup and Restore Linux System Settings With Timeshift</a></p>
<p>安装timeshift：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install timeshift</span><br></pre></td></tr></table></figure>

<p>备份整个系统，包括&#x2F;root和&#x2F;home&#x2F;user，设置定时备份</p>
<p>如何恢复：</p>
<p>情景一：系统无法进入桌面，但是可以进入recovery模式root操作：</p>
<p>如下图，用<code>timeshift --help</code>查看各种命令，使用<code>timeshift --restore</code>恢复指定snapshot</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305081931009.png" alt="image-20230508193100794"></p>
<p>情景二：系统无法进入recovery模式，但是备份的snapshot数据还在</p>
<p>使用<a href="https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows?ref=itsfoss.com">Ubuntu Live USB</a> ，即装系统的USB进入try ubuntu环境，联网换国内源安装timeshift，再恢复系统盘中的snapshot数据</p>
<p>情景三：磁盘中的snapshot数据损害：只能重装系统，为了避免此情况发生，应该将系统备份到其他硬盘而不仅仅在当前系统盘</p>
<h2 id="Clonezilla克隆系统"><a href="#Clonezilla克隆系统" class="headerlink" title="Clonezilla克隆系统"></a>Clonezilla克隆系统</h2><p>类似windows ghost的整盘克隆：</p>
<p><a href="https://www.linuxbabe.com/backup/how-to-use-clonezilla-live">https://www.linuxbabe.com/backup/how-to-use-clonezilla-live</a></p>
<p>至少需要三个盘：</p>
<p>在U盘写入Clonezilla的live usb iso生成Clonezilla live USB，再以Clonezilla live USB启动，对待备份的SSD盘做系统备份，到另一个SSD或者大USB盘；</p>
<p>恢复也是需要Clonezilla live USB + 有系统备份的盘 + 目标写入盘</p>
<h2 id="关于系统目录"><a href="#关于系统目录" class="headerlink" title="关于系统目录"></a>关于系统目录</h2><p>&#x2F;usr：系统级的目录，可以理解为C:&#x2F;Windows&#x2F;，apt安装的一般在&#x2F;usr&#x2F;bin和&#x2F;usr&#x2F;lib</p>
<p>&#x2F;usr&#x2F;lib：理解为C:&#x2F;Windows&#x2F;System32</p>
<p>&#x2F;usr&#x2F;local：用户级的程序目录，可以理解为C:&#x2F;Progrem Files&#x2F;，用户自己编译的软件默认安装到这个目录下</p>
<p>&#x2F;opt是用户级的目录用来安装大型的第三方附加软件包，可以理解为D:&#x2F;Software</p>
<p>开发过程中为了避免lib冲突，自己编译的包建议放在&#x2F;home&#x2F;&lt;具体的项目目录&gt;，此外注意自己编译基础库设置的LD_LIBRARY_PATH造成系统库链接冲突</p>
<h2 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h2><p>参考：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></p>
<h2 id="VNC远程桌面"><a href="#VNC远程桌面" class="headerlink" title="VNC远程桌面"></a>VNC远程桌面</h2><p>Ubuntu安装vino作为VNC server, windows端使用VNC Viewer作为client.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install vino</span><br><span class="line">setting -&gt; Sharing -&gt; Remote Desktop -&gt; On</span><br></pre></td></tr></table></figure>

<p>参考 <a href="https://www.answertopia.com/ubuntu/ubuntu-remote-desktop-access-with-vino/">Ubuntu 22.04 Remote Desktop Access with Vino</a></p>
<h1 id="分屏类配置"><a href="#分屏类配置" class="headerlink" title="分屏类配置"></a>分屏类配置</h1><h2 id="terminator终端分屏"><a href="#terminator终端分屏" class="headerlink" title="terminator终端分屏"></a>terminator终端分屏</h2><p>安装：<code>sudo apt-get install terminator</code></p>
<p>terminator分屏常用快捷键：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">在同一个标签内的操作：</span><br><span class="line">Ctrl+Shift+O</span><br><span class="line">Split terminals Horizontally.    //水平分割终端</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+E</span><br><span class="line">Split terminals Vertically.    //垂直分割终端</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+Right</span><br><span class="line">Move parent dragbar Right.    //在垂直分割的终端中将分割条向右移动</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+Left</span><br><span class="line">Move parent dragbar Left.    //在垂直分割的终端中将分割条向左移动</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+Up</span><br><span class="line">Move parent dragbar Up.        //在水平分割的终端中将分割条向上移动</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+Down</span><br><span class="line">Move parent dragbar Down.    //在水平分割的终端中将分割条向下移动</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+F</span><br><span class="line">Search within terminal scrollback    //搜索</span><br><span class="line"></span><br><span class="line">复制和粘贴：</span><br><span class="line">光标选中自动复制</span><br><span class="line">鼠标中键粘贴</span><br></pre></td></tr></table></figure>

<h2 id="Ubuntu多桌面"><a href="#Ubuntu多桌面" class="headerlink" title="Ubuntu多桌面"></a>Ubuntu多桌面</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建多桌面workspace： ctrl+alt+方向键（左右）</span><br><span class="line"></span><br><span class="line">将当期应用移动到workspace：ctrl+alt+shift+方向键（左右）</span><br></pre></td></tr></table></figure>

<h2 id="Ubuntu应用分屏"><a href="#Ubuntu应用分屏" class="headerlink" title="Ubuntu应用分屏"></a>Ubuntu应用分屏</h2><p>左右分屏：win键+方向键（左右）</p>
<p>上下分屏：不支持，建议使用多桌面</p>
<h1 id="截图类配置"><a href="#截图类配置" class="headerlink" title="截图类配置"></a>截图类配置</h1><h2 id="截图工具和屏幕缩放"><a href="#截图工具和屏幕缩放" class="headerlink" title="截图工具和屏幕缩放"></a>截图工具和屏幕缩放</h2><p>1.截图工具：</p>
<p>ubuntu默认开启了wayland，会阻碍第三方截图工具的功能。需要先关闭wayland，使用xorg桌面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/gdm3/custom.conf </span><br></pre></td></tr></table></figure>

<p>把 <code>#WaylandEnable=false</code> 的#注释去掉，重启生效。再安装flameshot等截图软件，能正常使用功能。</p>
<p>2.屏幕缩放：</p>
<p>setting -&gt; displays -&gt; Fractional Scaling打开，即可支持125%缩放。</p>
<p>屏幕缩放会引起flameshot截图闪烁问题，解决方案：使用以下命令启动flameshot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env QT_AUTO_SCREEN_SCALE_FACTOR=1 flameshot gui</span><br></pre></td></tr></table></figure>

<p>issue参考：<a href="https://github.com/flameshot-org/flameshot/issues/564">Fails when fractional scaling &lt;&gt; 100% #564</a></p>
<p>3.截图工具加到快捷键</p>
<p>将以上缩放+无闪烁的flameshot启动命令加到快捷键：</p>
<p>settings-&gt; keyboard -&gt; custom shortcuts -&gt; 添加command和shortcut</p>
<h1 id="远程与共享"><a href="#远程与共享" class="headerlink" title="远程与共享"></a>远程与共享</h1><h2 id="Ubuntu远程登录到Windows主机"><a href="#Ubuntu远程登录到Windows主机" class="headerlink" title="Ubuntu远程登录到Windows主机"></a>Ubuntu远程登录到Windows主机</h2><p>推荐remmina，同时支持RDP和VNC协议：<code>sudo apt install remmina</code></p>
<p>默认设置需要改：以目标主机的分辨率显示; 监听目标主机的键盘快捷键，在目标主机内的键盘都是对该主机的操作</p>
<h2 id="Ubuntu访问Windows共享路径"><a href="#Ubuntu访问Windows共享路径" class="headerlink" title="Ubuntu访问Windows共享路径"></a>Ubuntu访问Windows共享路径</h2><p>win10共享某个分区盘：右键分区-&gt;高级共享-&gt;打开读写访问；记录ipconfig的IP</p>
<p>Ubuntu已经安装samba后，在文件管理-&gt;其他位置-&gt;连接到服务器, 输入win10主机IP，会输入win10主机的用户名，密码，域名后可以连接；只能打开win10已共享的分区盘。</p>
]]></content>
      <categories>
        <category>ubuntu系统</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Samba配置笔记</title>
    <url>/2023/01/30/Ubuntu%20Samba%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Samba基本概念"><a href="#Samba基本概念" class="headerlink" title="Samba基本概念"></a>Samba基本概念</h2><p>Samba是SMB protocol的应用程序实现，分为服务端和客户端；</p>
<p>Samba通常的使用场景：在同一局域网内的的Linux主机安装Samba服务，windows主机可以访问Linux Samba服务指定的共享目录。</p>
<p>在嵌入式开发中通常在windows 上编辑Samba共享目录下的代码，通过 Linux环境编译代码，而无需在两个主机间拷贝代码文件。</p>
<h2 id="Ubuntu安装Samba服务"><a href="#Ubuntu安装Samba服务" class="headerlink" title="Ubuntu安装Samba服务"></a>Ubuntu安装Samba服务</h2><p>Ubuntu 20.04和22.04 版本，安装Samba服务参考：</p>
<p><a href="https://linux.how2shout.com/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux/#:~:text=Steps%20to%20install%20SAMBA%20on%20Ubuntu%2022.04%20LTS,...%206%206.%20Access%20the%20shared%20folder%20">www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux</a><br>主要流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#install and run samba service</span><br><span class="line">sudo apt install samba -y</span><br><span class="line"></span><br><span class="line">#enable auto start samba service</span><br><span class="line">sudo systemctl enable --now smbd</span><br><span class="line"></span><br><span class="line">#firewall allow samba</span><br><span class="line">sudo ufw allow samba</span><br><span class="line"></span><br><span class="line">#add system user to sambashare group</span><br><span class="line">sudo usermod -aG sambashare $USER</span><br><span class="line"></span><br><span class="line">#set passwd for sambashare</span><br><span class="line">sudo smbpasswd -a $USER</span><br><span class="line"></span><br><span class="line">#check samba service is running</span><br><span class="line">systemctl status smbd</span><br><span class="line"></span><br><span class="line">#share the folder in ubuntu GUI checkbox</span><br><span class="line">右键要共享的home文件夹properties -&gt; local Network Share -&gt; share this folder -&gt;share name不能直接用用户名，可以用&#x27;用户名+Home&#x27;</span><br></pre></td></tr></table></figure>

<p>显示无权共享：非root用户要共享&#x2F;home，需要修改smb.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br><span class="line">在[global]新增usershare owner only = false</span><br><span class="line">sudo systemctl restart smbd</span><br></pre></td></tr></table></figure>



<h2 id="Windows访问Samba共享目录"><a href="#Windows访问Samba共享目录" class="headerlink" title="Windows访问Samba共享目录"></a>Windows访问Samba共享目录</h2><p>windows下可以在文件浏览器直接访问Linux主机ip查看共享的Linux目录</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301103020.png" alt="image-20230130110305978"></p>
<p>首次windows访问共享目录有权限问题（不能写入），需要在Linux修改共享目录&#x2F;home的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /home -R </span><br></pre></td></tr></table></figure>

<p>为了以后方便连接，可以创建网络位置，参考：<a href="www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux">6. Access the shared folder On Windows 11 or 10</a></p>
<p>如果一个主机有两个samba共享目录，windows不允许多重连接；</p>
<p>要更改连接目录，操作如下：</p>
<p>win10系统在搜索框搜索【凭据管理器】，然后删除已有的windows samba网络连接凭据</p>
<p><code>win+R</code> CMD输入 <code>net use * /del /y</code>断开所有远程链接，包括samba网络连接</p>
<p>重新配置windows samba网络连接</p>
<h2 id="重装Samba"><a href="#重装Samba" class="headerlink" title="重装Samba"></a>重装Samba</h2><p>Samba的配置文件位于&#x2F;etc&#x2F;samba&#x2F;smb.conf，如果此文件被错误配置或者误删除，需要重装Samba，流程如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove samba --purge //删掉samba服务</span><br><span class="line">sudo apt-get remove samba-common --purge //这一步是关键，只重装samba不会恢复smb.conf</span><br><span class="line">sudo apt-get autoremove //删掉其他samba依赖库</span><br><span class="line">sudo apt-get install samba //重装，包括samba和samba-common等</span><br></pre></td></tr></table></figure>

<h2 id="Samba使用示例"><a href="#Samba使用示例" class="headerlink" title="Samba使用示例"></a>Samba使用示例</h2><p>Samba最重要的特性是两个主机之间直接共享目录，不需要用户去拷贝文件。</p>
<p>在代码开发中，在windows主机的VSCode或其他编辑器直接打开Linux主机共享目录的代码，然后SSH远程Linux主机去编译。</p>
]]></content>
      <categories>
        <category>ubuntu系统</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu SSH服务配置笔记</title>
    <url>/2023/02/02/Ubuntu-SSH%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h1><h2 id="SSH基本概念"><a href="#SSH基本概念" class="headerlink" title="SSH基本概念"></a>SSH基本概念</h2><ul>
<li>SSH是Secure Shell缩写，实现安全远程登录</li>
</ul>
<p>​	SSH的安全性好，原因是其对数据进行加密，方式主要有两种：对称加密（密钥加密）和非对称加密（公钥加密）<br>​	对称加密指加密解密使用的是同一套秘钥。Client端把密钥加密后发送给Server端，Server用同一套密钥解密。对称加密的加密强度比较高，很难破解。但是如果有一个Client端的密钥泄漏，那么整个系统的安全性就存在严重的漏洞。<br>​	为了解决对称加密的漏洞，于是就产生了非对称加密。<br>​	非对称加密有两个密钥：“公钥”和“私钥”。公钥加密后的密文，只能通过对应的私钥进行解密。想从公钥推理出私钥几乎不可能，所以非对称加密的安全性比较高。</p>
<ul>
<li>SSH的加密原理中，使用了RSA非对称加密算法。</li>
</ul>
<p>​	整个过程：</p>
<p>​	（1）远程主机收到用户的登录请求，把自己的公钥发给用户。</p>
<p>​	（2）用户使用这个公钥，将登录密码加密后，发送回来。</p>
<p>​	（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<ul>
<li>关于中间人攻击（Man-in-the-middle attack）</li>
</ul>
<p>​	中间人攻击的概念：如果有人冒充远程主机将伪造的公钥发给用户，用户很难辨别公钥真伪，用户	会和伪造主机通信而不是真正的主机。</p>
<p>​	因为SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，是主机和用户之间自己签	发的，所有SSH从原理上无法彻底防止中间人攻击</p>
<ul>
<li><p>SSH使用首次验证方式减少中间人攻击的概率：</p>
<p>SSH首次连接会下载服务端的公钥，用户确认后公钥将被保存并信任。</p>
<p>下次访问时客户端将会核对服务端发来的公钥和本地保存的是否相同，如果不同就发出中间人攻击的警告拒绝连接，除非用户手动清除已保存的公钥。</p>
<p>所以，只要SSH首次连接没有中间人攻击，之后的SSH连接就无需担心中间人攻击</p>
</li>
</ul>
<h2 id="Ubuntu安装SSH服务"><a href="#Ubuntu安装SSH服务" class="headerlink" title="Ubuntu安装SSH服务"></a>Ubuntu安装SSH服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ssh -y</span><br><span class="line">sudo service ssh start</span><br><span class="line">sudo service ssh status</span><br></pre></td></tr></table></figure>

<p>在系统重启后ssh service会自启动，不需要<code>systemctl enable</code>去配置自启动</p>
<h2 id="Windows访问SSH服务"><a href="#Windows访问SSH服务" class="headerlink" title="Windows访问SSH服务"></a>Windows访问SSH服务</h2><ul>
<li><p>使用win+R CMD验证SSH连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh 远程主机用户名@远程主机IP</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用putty，xshell等工具访问主机</p>
</li>
</ul>
<p>参考：<a href="https://www.how2shout.com/how-to/how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7.html#:~:text=How%20do%20I%20SSH%20into%20Ubuntu%20from%20Windows%3F,to%20Ubuntu%20server%20via%20Putty%20SSH%20client%20">how2shout.com&#x2F;how-to&#x2F;how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7</a></p>
<p>首次登陆会验证RSA公钥（1024位）的MD5 fingerprint（128位）</p>
<blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></blockquote>
<p>当首次连接的公钥被接受以后，会保存在本地文件。下次再连接这台主机会跳过公钥警告，直接提示输入密码。如果以后的连接是中间人攻击，其公钥和本地的首次公钥不同，从而保证安全性。</p>
<ul>
<li>使用xftp, filezilla工具传输文件</li>
</ul>
<p>和putty，xshell配置类似</p>
<ul>
<li>使用scp命令传输文件</li>
</ul>
<p>在linux主机之间可以用scp传输文件和目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#从远程cp到本地</span><br><span class="line">scp username@ip_address:/home/username/filename .</span><br><span class="line">#从本地cp到远程</span><br><span class="line">scp filename username@ip_address:/home/username</span><br><span class="line">#拷贝目录</span><br><span class="line">scp -r source_dir username@ip_address:/home/username/target_dir</span><br></pre></td></tr></table></figure>

<h2 id="SSH远程开发"><a href="#SSH远程开发" class="headerlink" title="SSH远程开发"></a>SSH远程开发</h2><p>示例一：在SSH server和客户端建立后，可以使用VSCode和source insight等代码编辑工具改代码，用xftp传输代码到SSH Linux主机，用xshell远程编译。</p>
<p>示例二：VSCode安装SSH远程开发插件，可以直接远程SSH Linux主机完成代码编辑、编译，<a href="https://code.visualstudio.com/docs/remote/ssh">visualstudio.com&#x2F;Remote Development using SSH</a></p>
<p>VSCode安装Remote-SSH插件后，添加远程host：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In VS Code, select **Remote-SSH: Connect to Host...** from the Command Palette (F1, Ctrl+Shift+P) and use the same `user@hostname`</span><br></pre></td></tr></table></figure>



<h1 id="远程连接相关的Ubuntu配置"><a href="#远程连接相关的Ubuntu配置" class="headerlink" title="远程连接相关的Ubuntu配置"></a>远程连接相关的Ubuntu配置</h1><h2 id="Ubuntu设置静态IP"><a href="#Ubuntu设置静态IP" class="headerlink" title="Ubuntu设置静态IP"></a>Ubuntu设置静态IP</h2><p>在使用SSH和Samba连远程Ubuntu PC时，发现IP有时候会改变，因此需要配置Ubuntu PC为静态IP</p>
<p>1.ifconfig查看ethernet接口和当前IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~$ ifconfig</span><br><span class="line">eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.52.4.71  netmask 255.255.255.0  broadcast 10.52.4.255</span><br></pre></td></tr></table></figure>

<p>2.编辑Ubuntu的netplan配置文件&#x2F;etc&#x2F;netplan&#x2F;*.yaml，用tab补全找到具体的yaml，制定静态IP和DNS</p>
<p>参考 <a href="https://linuxconfig.org/netplan-network-configuration-tutorial-for-beginners">Netplan network configuration tutorial for beginners</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">    eno1:</span><br><span class="line">      addresses:</span><br><span class="line">        - 10.52.4.71/24</span><br><span class="line">      nameservers:</span><br><span class="line">         addresses:</span><br><span class="line">            - 10.52.1.1</span><br><span class="line">            - 10.52.1.2</span><br><span class="line">      #gateway4: 10.52.0.1</span><br><span class="line">      routes:</span><br><span class="line">         - to: default</span><br><span class="line">           via: 10.52.0.1</span><br></pre></td></tr></table></figure>

<p>以上IP和nameservers(DNS)是必须的，gateway4是网关，在ubuntu22被废弃（ubuntu22显示 &#96;&#96;gateway4<code> has been deprecated, use default routes instead.</code>）使用routes配置网关，参考 <a href="https://askubuntu.com/questions/1410750/netplan-gateway-has-been-deprecated">netplan-gateway-has-been-deprecated</a>。怎么获取这三个值，参考以下网络命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有</span><br><span class="line">nmcli</span><br><span class="line">#查看gateway</span><br><span class="line">netstat -rn 或 route -n</span><br><span class="line">#DNS配置文件</span><br><span class="line">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>例如nmcli输出如下，其中 <code> inet4 10.52.4.71/24</code>即当前IP&#x2F;mask， <code>route4 default via 10.52.0.1</code>即默认网关，<code>DNS configuration servers: 10.52.1.1 10.52.1.2</code>即nameservers</p>
<blockquote>
<p>eno1: connected to netplan-eno1<br>        “Intel I219-V”<br>        ethernet (e1000e), 18:C0:4D:1F:BA:B7, hw, mtu 1500<br>        ip4 default<br>        inet4 10.52.4.71&#x2F;24<br>        route4 10.52.4.0&#x2F;24 metric 100<br>        route4 10.52.0.1&#x2F;32 metric 100<br>        route4 default via 10.52.0.1 metric 100<br>        inet6 fe80::1ac0:4dff:fe1f:bab7&#x2F;64<br>        route6 fe80::&#x2F;64 metric 256</p>
<p>virbr0: connected (externally) to virbr0<br>        “virbr0”<br>        bridge, 52:54:00:13:EB:68, sw, mtu 1500<br>        inet4 192.168.122.1&#x2F;24<br>        route4 169.254.0.0&#x2F;16 metric 1000<br>        route4 192.168.122.0&#x2F;24 metric 0</p>
<p>lo: unmanaged<br>        “lo”<br>        loopback (unknown), 00:00:00:00:00:00, sw, mtu 65536</p>
<p>DNS configuration:<br>        servers: 10.52.1.1 10.52.1.2<br>        interface: eno1</p>
</blockquote>
<p>3.生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<p>ping确认网络正常：</p>
<blockquote>
<p>ubuntu@ubuntu-Z390-GAMING-X:~$ ping <a href="http://www.bing.com/">www.bing.com</a><br>PING china.bing123.com (202.89.233.101) 56(84) bytes of data.<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;1 ttl&#x3D;117 time&#x3D;27.1 ms<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;2 ttl&#x3D;117 time&#x3D;27.2 ms<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;3 ttl&#x3D;117 time&#x3D;27.2 ms</p>
</blockquote>
<p>如果DNS server或gateway不符合当前网络状况，ping会失败，输出：</p>
<blockquote>
<p>Name or service not known</p>
</blockquote>
<h2 id="Ubuntu禁止自动登出"><a href="#Ubuntu禁止自动登出" class="headerlink" title="Ubuntu禁止自动登出"></a>Ubuntu禁止自动登出</h2><p>自动登出会使SSH断开链接，按如下禁用</p>
<blockquote>
<p>setting-&gt;Privacy-&gt;Screen-&gt;Automatic Screen Lock (OFF)</p>
</blockquote>
]]></content>
      <categories>
        <category>ubuntu系统</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode用Clangd高效阅读Linux Kernel.md</title>
    <url>/2023/05/29/VSCode%E7%94%A8Clangd%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BBLinux-Kernel/</url>
    <content><![CDATA[<p>安装kernel编译环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>

<p>安装bear</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install bear</span><br></pre></td></tr></table></figure>

<p>使用bear编译kernel，生成compile_commands.json，参考：<a href="https://forums.100ask.net/t/topic/1656/2">Ubuntu22 直接 make 内核成功，但不能使用 bear 命令</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bear -- make -j4</span><br></pre></td></tr></table></figure>

<p>在编译Kernel的源代码环境安装clangd服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install clangd</span><br></pre></td></tr></table></figure>

<p>在查看代码的VSCode环境安装clangd客户端(即VSCode的clangd插件)：一般通过windows机器的VSCode SSH连接Linux的clangd服务，因此需要将VSCode的remote SSH登陆到Linux机器（注意不要同时使用Xshell等其他SSH工具，否则VSCode remote SSH连不上）</p>
<p>VSCode remote SSH中打开代码后，clangd自动indexing(完成Kernel index需要相当长时间)，CTRL+鼠标左键查看定义，ALT+左键头返回跳转</p>
<p>clangd方式可以很方便找到C函数指针的实现，而VSCode的C++ intellisense跳转不到</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/558286384">使用VSCode进行linux内核代码阅读和开发</a></p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode配置笔记</title>
    <url>/2022/12/08/VSCode%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="VSCode配置笔记"><a href="#VSCode配置笔记" class="headerlink" title="VSCode配置笔记"></a>VSCode配置笔记</h1><h2 id="修改工作区存储目录"><a href="#修改工作区存储目录" class="headerlink" title="修改工作区存储目录"></a>修改工作区存储目录</h2><p>VSCode会将每个工作区的一些配置、扩展、缓存等默认保存在C盘的AppData\Code\workspaceStorage，使用一段时间后数据能达到上十GB。</p>
<p>当C盘空间不足，用SpaceSniffer可以找到这些“数据垃圾”，但每隔一段时间清理也不是一劳永逸。</p>
<p>修改workspaceStorage存储路径到非系统盘：</p>
<p>1.首先选择VSCode在开始栏，状态栏，或桌面栏的快捷方式图标，常用哪个就修改哪个，右键属性：</p>
<p>添加启动的命令行选项，指定user-data-dir:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--user-data-dir &quot;目标路径，例如F:\VSCodeWorkspaceStorage&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081200216.png" alt="image-20221208120051137"></p>
<p>2.转移已有的workspaceStorage.</p>
<p>修改完成后，将%AppData%\Code下的所有内容拷贝到设置的目录中;  也可以删除%AppData%\Code，但是需要重新配置VSCode。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>以双斜杠&#x2F;&#x2F;注释和取消注释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">注释：ctrl + / </span><br><span class="line">取消注释：ctrl + /</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法二：</span><br><span class="line">注释：ctrl + k, ctrl + c </span><br><span class="line">取消注释：ctrl + k, ctrl + u</span><br></pre></td></tr></table></figure>

<p>以星号&#x2F;**&#x2F;注释和取消注释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释：shift + alt + a </span><br><span class="line">取消注释：shift + alt + a</span><br></pre></td></tr></table></figure>

<h3 id="更改快捷键"><a href="#更改快捷键" class="headerlink" title="更改快捷键"></a>更改快捷键</h3><p>File-&gt;Preference-&gt;KeyboardShortCuts</p>
<p>例如可以把块注释&#x2F;**&#x2F;快捷键改成<code>ctrl+Alt+/</code>，和行注释<code>ctrl+/</code>达成统一：</p>
<p>选择recording keys，直接录入要修改的快捷键</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302201101988.png" alt="image-20230220110133891"></p>
<h2 id="项目文件过滤"><a href="#项目文件过滤" class="headerlink" title="项目文件过滤"></a>项目文件过滤</h2><p>在项目的顶层目录中新建 <strong>.vscode</strong> 文件夹，在该文件夹下面新建 <strong>settings.json</strong> 文件</p>
<p>例如，对于Linux kernel项目，编译过的目录有大量编译输出文件(.o, .ko, .mod等)，只想查看和搜索驱动目录下的源码，过滤示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;files.exclude&quot;: &#123;</span><br><span class="line">        &quot;**/*.cmd&quot;: true, //当前所有目录的所有以.cmd结尾的文件</span><br><span class="line">        &quot;**/*.a&quot;: true,</span><br><span class="line">        &quot;**/*.o&quot;: true,</span><br><span class="line">        &quot;**/*.d&quot;: true,</span><br><span class="line">        &quot;**/*.mod&quot;: true,</span><br><span class="line">        &quot;**/*.mod.c&quot;: true,</span><br><span class="line">        &quot;**/*.ko&quot;: true,</span><br><span class="line"></span><br><span class="line">        &quot;[^drivers]*&quot;: true, //除了包含&#x27;d&#x27;&#x27;r&#x27;&#x27;i&#x27;&#x27;v&#x27;&#x27;e&#x27;&#x27;r&#x27;&#x27;s&#x27;目录以外的所有目录，近似等效于除了&quot;drivers&quot;文件夹以外的文件都被files.exclude</span><br><span class="line">        &quot;[^include]*&quot;: true,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;search.exclude&quot;: &#123;</span><br><span class="line">        &quot;[^driver]*&quot;: true,</span><br><span class="line">        &quot;[^include]*&quot;: true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正则表达式参考 <a href="https://geek-docs.com/regexp/regexp-tutorials/75_regular_expression_exclude_characters.html#:~:text=Regex%20%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%83%BD%E5%A4%9F%E7%94%A8%E9%AB%98%E6%95%88%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2%E7%AD%89%E6%93%8D%E4%BD%9C%E3%80%82%20%E5%9C%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%EF%BC%8C%E6%9C%89%E6%97%B6%E9%9C%80%E8%A6%81%E6%8E%92%E9%99%A4%E6%9F%90%E4%BA%9B%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%82%20%E6%9C%AC%E6%96%87%E5%B0%86%E4%BB%8B%E7%BB%8D%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E6%8E%92%E9%99%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%82%20%E6%8E%92%E9%99%A4%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%20%E5%9C%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20%5E%20%E7%AC%A6%E5%8F%B7%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%8C%B9%E9%85%8D%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%82,%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%20%20a%5D%20%E4%B8%8A%E8%BF%B0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%20%5E%20%E8%A1%A8%E7%A4%BA%E6%8E%92%E9%99%A4%E5%AD%97%E7%AC%A6%EF%BC%8C%20%5B%5D%20%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88%E3%80%82">正则表达式排除字符</a></p>
<h2 id="VSCode-remote免密码登录-SSH密钥认证"><a href="#VSCode-remote免密码登录-SSH密钥认证" class="headerlink" title="VSCode remote免密码登录(SSH密钥认证)"></a>VSCode remote免密码登录(SSH密钥认证)</h2><p>Windows端的VSCode remote如何配置参考<a href="https://code.visualstudio.com/docs/remote/ssh">Remote Development using SSH</a>，Linux服务器配置好SSH服务后直接连接即可。</p>
<p>日常使用经常需要重启Linux服务端，需要重新输入密码登录；使用SSH密钥可以免密码登录。</p>
<p>SSH密钥登录的流程：</p>
<ul>
<li><p>在进行SSH连接之前，SSH客户端需要先生成自己的公钥私钥对，并将自己的公钥存放在SSH服务器上。</p>
</li>
<li><p>SSH客户端发送登录请求，SSH服务器就会根据请求中的用户名等信息在本地搜索客户端的公钥，并用这个公钥加密一个随机数发送给客户端。</p>
</li>
<li><p>客户端使用自己的私钥对返回信息进行解密，并发送给服务器。</p>
</li>
<li><p>服务器验证客户端解密的信息是否正确，如果正确则认证通过。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308221100363.png" alt="image-20230822110009079"></p>
</li>
</ul>
<p><strong>(1)Windows客户端生成ssh key</strong></p>
<p><code>win+R -&gt; ssh-keygen</code> 生成密钥对，id_rsa.pub是公钥，id_rsa是私钥；</p>
<p>如果已经有ssh-key, 不需要重新生成；如果已有的key不能配置生效，参考如下方式生成重命名的ssh-key，后续流程一致。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308221115183.png" alt="image-20230822111509800"></p>
<p><strong>(2)Linux服务端生成ssh key</strong></p>
<p>用xshell或samba拷贝windows端的<code>C:\Users\用户名\.ssh\id_rsa.pub</code>到Linux服务端的~&#x2F;<strong>.ssh</strong> </p>
<p>拷贝到authorized_keys，并修改权限，否则Vscode remote不能访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">chmod 777 authorized_keys </span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<p><strong>(3)配置VSCode remote</strong></p>
<p>ssh配置文件<code>C:\Users\用户名\.ssh\config</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308221047708.png" alt="image-20230822104703184"></p>
<p>添加IdentityFile字段，填写windows本机的id_rsa路径，注意没有.pub后缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 10.52.4.63</span><br><span class="line">  HostName 10.52.4.63</span><br><span class="line">  User cursorhu</span><br><span class="line">  IdentityFile &quot;C:\Users\thomas.hu\.ssh\id_rsa&quot;</span><br></pre></td></tr></table></figure>

<h2 id="关闭宏代码块变暗"><a href="#关闭宏代码块变暗" class="headerlink" title="关闭宏代码块变暗"></a>关闭宏代码块变暗</h2><p>setting -&gt; 搜索C_Cpp.dimInactiveRegions -&gt; 关闭</p>
<h2 id="代码跳转（Go-Back和-Go-Forword）"><a href="#代码跳转（Go-Back和-Go-Forword）" class="headerlink" title="代码跳转（Go Back和 Go Forword）"></a>代码跳转（Go Back和 Go Forword）</h2><p>VSCode代码跳转（Go Back和 Go Forword）在Ubuntu 和Windows 不一样，如何将Ubuntu改成和windows一致：</p>
<p>setting -&gt; 分别搜索Go Back和Go Forword -&gt; 分别设置快捷键 alt + 方向 -&gt; 提示和已有快捷键冲突，右键删除冲突的快捷键再添加</p>
<h2 id="代码跳转（Definition和Reference）"><a href="#代码跳转（Definition和Reference）" class="headerlink" title="代码跳转（Definition和Reference）"></a>代码跳转（Definition和Reference）</h2><p>安装C&#x2F;C++ intelligence插件即可支持</p>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>win: ctrl + p，输入文件名查找是否存在</p>
<h2 id="关闭悬浮框（类型提示）"><a href="#关闭悬浮框（类型提示）" class="headerlink" title="关闭悬浮框（类型提示）"></a>关闭悬浮框（类型提示）</h2><p>setting里面设置hover为false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;editor.hover.enabled&quot;: false,</span><br><span class="line">&quot;editor.parameterHints.enabled&quot;: false,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Windbg -- 蓝屏BSOD 0xCA分析</title>
    <url>/2024/07/30/Windbg%20--%20%E8%93%9D%E5%B1%8FBSOD%200xCA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Windows-BSOD-0xCA-Analysis"><a href="#Windows-BSOD-0xCA-Analysis" class="headerlink" title="Windows BSOD 0xCA Analysis."></a>Windows BSOD 0xCA Analysis.</h1><p>根据 Windbg Dump 分析，这个 BSOD 是由 IOMMU 操作失败导致的。具体来看：</p>
<p>错误发生在设备初始化阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DevNode State = DeviceNodeResourcesAssigned (0x306)</span><br><span class="line">Previous State = DeviceNodeDriversAdded (0x305)</span><br></pre></td></tr></table></figure>

<p>关键问题点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BUGCHECK_CODE: ca (PNP_DETECTED_FATAL_ERROR)</span><br><span class="line">Arg1: 13 (IOMMU operation failure)</span><br><span class="line">Arg2: 1000 (Unblock operation)</span><br></pre></td></tr></table></figure>

<p>解决 IOMMU 操作失败的问题。主要通过：</p>
<ol>
<li><p>正确初始化 DMA&#x2F;IOMMU 映射（当前代码已支持，不需修改）</p>
</li>
<li><p>确保状态转换时 DMA 操作安全完成 （当前代码待修改）</p>
</li>
</ol>
<p>代码改动：</p>
<p>设备进入D3&#x2F;D0以前Complete所有I&#x2F;O请求（SRB），使用Storport miniport要求的API RequestComplete ： We do not recommend that writers of Storport miniport drivers use this particular Storport interface routine. Instead, the miniport driver should call StorPortNotification( RequestComplete ) for each outstanding request.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202411052017667.png" alt="image-20241105201725563"></p>
<p>附录1：BSOD 0xCA的相关文档</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-0xca--pnp-detected-fatal-error?redirectedfrom=MSDN">https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-0xca--pnp-detected-fatal-error?redirectedfrom=MSDN</a></p>
<p><a href="https://www.sysnative.com/forums/threads/debugging-stop-0xca-dddriver-sys-dddriver64dcsa-sys.35039/">https://www.sysnative.com/forums/threads/debugging-stop-0xca-dddriver-sys-dddriver64dcsa-sys.35039/</a></p>
<p>附录2：BSOD 0xCA的Windbg分析log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!analyze -v</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*                        Bugcheck Analysis                                    *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line"></span><br><span class="line">PNP_DETECTED_FATAL_ERROR (ca)</span><br><span class="line">PnP encountered a severe error, either as a result of a problem in a driver or</span><br><span class="line">a problem in PnP itself.  The first argument describes the nature of the</span><br><span class="line">problem, the second argument is the address of the PDO.  The other arguments</span><br><span class="line">vary depending on argument 1.</span><br><span class="line">Arguments:</span><br><span class="line">Arg1: 0000000000000013, IOMMU operation failure</span><br><span class="line">	A critical IOMMU operation has failed.</span><br><span class="line">Arg2: 0000000000001000, Unblock operation</span><br><span class="line">Arg3: ffffffffc0350066, NT status code.</span><br><span class="line">Arg4: ffffb986629afc40, DevNode of the device.</span><br><span class="line"></span><br><span class="line">Debugging Details:</span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KEY_VALUES_STRING: 1</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.CPU.mSec</span><br><span class="line">    Value: 4546</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Elapsed.mSec</span><br><span class="line">    Value: 4604</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.IO.Other.Mb</span><br><span class="line">    Value: 17</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.IO.Read.Mb</span><br><span class="line">    Value: 2</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.IO.Write.Mb</span><br><span class="line">    Value: 24</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Init.CPU.mSec</span><br><span class="line">    Value: 968</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Init.Elapsed.mSec</span><br><span class="line">    Value: 4411983</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Memory.CommitPeak.Mb</span><br><span class="line">    Value: 92</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Version.DbgEng</span><br><span class="line">    Value: 10.0.27725.1000</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Version.Description</span><br><span class="line">    Value: 10.2408.27.01 amd64fre</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Version.Ext</span><br><span class="line">    Value: 1.2408.27.1</span><br><span class="line"></span><br><span class="line">    Key  : Bugcheck.Code.KiBugCheckData</span><br><span class="line">    Value: 0xca</span><br><span class="line"></span><br><span class="line">    Key  : Bugcheck.Code.LegacyAPI</span><br><span class="line">    Value: 0xca</span><br><span class="line"></span><br><span class="line">    Key  : Bugcheck.Code.TargetModel</span><br><span class="line">    Value: 0xca</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.AsUlong</span><br><span class="line">    Value: 21800</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.DiagDataWrittenToHeader</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.ErrorCode</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.LastLine</span><br><span class="line">    Value: Dump completed successfully.</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.ProgressPercentage</span><br><span class="line">    Value: 100</span><br><span class="line"></span><br><span class="line">    Key  : Failure.Bucket</span><br><span class="line">    Value: 0xCA_13_nt!PiDmaGuardProcessPreStart</span><br><span class="line"></span><br><span class="line">    Key  : Failure.Hash</span><br><span class="line">    Value: &#123;b367b2d8-0cc5-f3e0-e733-3787841dcdd2&#125;</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Enlightenments.ValueHex</span><br><span class="line">    Value: 7497cf94</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.AnyHypervisorPresent</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.ApicEnlightened</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.ApicVirtualizationAvailable</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.AsyncMemoryHint</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.CoreSchedulerRequested</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.CpuManager</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.DeprecateAutoEoi</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.DynamicCpuDisabled</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.Epf</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.ExtendedProcessorMasks</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.HardwareMbecAvailable</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.MaxBankNumber</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.MemoryZeroingControl</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.NoExtendedRangeFlush</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.NoNonArchCoreSharing</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.Phase0InitDone</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.PowerSchedulerQos</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.RootScheduler</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.SynicAvailable</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.UseQpcBias</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.Value</span><br><span class="line">    Value: 38408431</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.ValueHex</span><br><span class="line">    Value: 24a10ef</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.VpAssistPage</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.VsmAvailable</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.AccessStats</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.CrashdumpEnlightened</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.CreateVirtualProcessor</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.DisableHyperthreading</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.HostTimelineSync</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.HypervisorDebuggingEnabled</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.IsHyperV</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.LivedumpEnlightened</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.MapDeviceInterrupt</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.MceEnlightened</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.Nested</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.StartLogicalProcessor</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.Value</span><br><span class="line">    Value: 1015</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.ValueHex</span><br><span class="line">    Value: 3f7</span><br><span class="line"></span><br><span class="line">    Key  : SecureKernel.HalpHvciEnabled</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : WER.OS.Branch</span><br><span class="line">    Value: ge_release</span><br><span class="line"></span><br><span class="line">    Key  : WER.OS.Version</span><br><span class="line">    Value: 10.0.26100.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUGCHECK_CODE:  ca</span><br><span class="line"></span><br><span class="line">BUGCHECK_P1: 13</span><br><span class="line"></span><br><span class="line">BUGCHECK_P2: 1000</span><br><span class="line"></span><br><span class="line">BUGCHECK_P3: ffffffffc0350066</span><br><span class="line"></span><br><span class="line">BUGCHECK_P4: ffffb986629afc40</span><br><span class="line"></span><br><span class="line">FILE_IN_CAB:  MEMORY.DMP</span><br><span class="line"></span><br><span class="line">TAG_NOT_DEFINED_202b:  *** Unknown TAG in analysis list 202b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DUMP_FILE_ATTRIBUTES: 0x21800</span><br><span class="line"></span><br><span class="line">FAULTING_THREAD:  ffffb986625ef040</span><br><span class="line"></span><br><span class="line">DEVICE_OBJECT: 0000000000001000</span><br><span class="line"></span><br><span class="line">BLACKBOXBSD: 1 (!blackboxbsd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXNTFS: 1 (!blackboxntfs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXPNP: 1 (!blackboxpnp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXWINLOGON: 1</span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  System</span><br><span class="line"></span><br><span class="line">LOCK_ADDRESS:  fffff8019cd8a380 -- (!locks fffff8019cd8a380)</span><br><span class="line">KD: Scanning for held locks........................................................</span><br><span class="line"></span><br><span class="line">Resource @ nt!PiEngineLock (0xfffff8019cd8a380)    Exclusively owned</span><br><span class="line">    Contention Count = 23</span><br><span class="line">     Threads: ffffb986625ef040-01&lt;*&gt; </span><br><span class="line">1 total locks</span><br><span class="line"></span><br><span class="line">PNP_TRIAGE_DATA: </span><br><span class="line">	Lock address  : 0xfffff8019cd8a380</span><br><span class="line">	Thread Count  : 1</span><br><span class="line">	Thread address: 0xffffb986625ef040</span><br><span class="line">	Thread wait   : 0x281e98</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">ffffdf84`8a6b7158 fffff801`9c8e5bca     : 00000000`000000ca 00000000`00000013 00000000`00001000 ffffffff`c0350066 : nt!KeBugCheckEx</span><br><span class="line">ffffdf84`8a6b7160 fffff801`9c7db310     : ffffb986`629afc40 00000000`00000000 00000000`00000001 ffffb986`629afc40 : nt!PiDmaGuardProcessPreStart+0x10a7f6</span><br><span class="line">ffffdf84`8a6b71a0 fffff801`9c697621     : ffffb986`629afc40 ffffdf84`8a6b7261 00000000`00000000 00000000`00000001 : nt!PipProcessStartPhase1+0x4c</span><br><span class="line">ffffdf84`8a6b71e0 fffff801`9c8187a7     : ffffb986`36694b20 ffffb986`626da790 ffffdf84`8a6b7300 fffff801`00000002 : nt!PipProcessDevNodeTree+0x645</span><br><span class="line">ffffdf84`8a6b72b0 fffff801`9c2404bd     : 00000001`00000003 ffffb986`36694b20 ffffb986`626da790 00000000`00000000 : nt!PiProcessReenumeration+0x9f</span><br><span class="line">ffffdf84`8a6b7300 fffff801`9c1249d2     : ffffb986`625ef040 ffffb986`366b6cb0 fffff801`9c23fe80 ffffb986`00000000 : nt!PnpDeviceActionWorker+0x63d</span><br><span class="line">ffffdf84`8a6b73c0 fffff801`9c25a9ea     : ffffb986`625ef040 ffffb986`625ef040 fffff801`9c124820 ffffb986`366b6cb0 : nt!ExpWorkerThread+0x1b2</span><br><span class="line">ffffdf84`8a6b7570 fffff801`9c4736f4     : ffffce81`b4759180 ffffb986`625ef040 fffff801`9c25a990 00320033`006d0065 : nt!PspSystemThreadStartup+0x5a</span><br><span class="line">ffffdf84`8a6b75c0 00000000`00000000     : ffffdf84`8a6b8000 ffffdf84`8a6b1000 00000000`00000000 00000000`00000000 : nt!KiStartSystemThread+0x34</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYMBOL_NAME:  nt!PiDmaGuardProcessPreStart+10a7f6</span><br><span class="line"></span><br><span class="line">MODULE_NAME: nt</span><br><span class="line"></span><br><span class="line">IMAGE_NAME:  ntkrnlmp.exe</span><br><span class="line"></span><br><span class="line">STACK_COMMAND:  .process /r /p 0xffffb98636697040; .thread 0xffffb986625ef040 ; kb</span><br><span class="line"></span><br><span class="line">BUCKET_ID_FUNC_OFFSET:  10a7f6</span><br><span class="line"></span><br><span class="line">FAILURE_BUCKET_ID:  0xCA_13_nt!PiDmaGuardProcessPreStart</span><br><span class="line"></span><br><span class="line">OS_VERSION:  10.0.26100.1</span><br><span class="line"></span><br><span class="line">BUILDLAB_STR:  ge_release</span><br><span class="line"></span><br><span class="line">OSPLATFORM_TYPE:  x64</span><br><span class="line"></span><br><span class="line">OSNAME:  Windows 10</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH:  &#123;b367b2d8-0cc5-f3e0-e733-3787841dcdd2&#125;</span><br><span class="line"></span><br><span class="line">Followup:     MachineOwner</span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">1: kd&gt; !devnode ffffb986629afc40</span><br><span class="line">DevNode 0xffffb986629afc40 for PDO 0xffffb98665085060</span><br><span class="line">  Parent 0xffffb986629adc40   Sibling 0000000000   Child 0000000000   </span><br><span class="line">  InstancePath is &quot;PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_00021217&amp;REV_01\4&amp;32cd076f&amp;0&amp;0013&quot;</span><br><span class="line">  ServiceName is &quot;bhtsddr&quot;</span><br><span class="line">  State = DeviceNodeResourcesAssigned (0x306) @ 2024 Oct 24 21:26:21.411</span><br><span class="line">  Previous State = DeviceNodeDriversAdded (0x305) @ 2024 Oct 24 21:26:21.411</span><br><span class="line">  StateHistory[02] = DeviceNodeDriversAdded (0x305)</span><br><span class="line">  StateHistory[01] = DeviceNodeInitialized (0x304)</span><br><span class="line">  StateHistory[00] = DeviceNodeUninitialized (0x301)</span><br><span class="line">  StateHistory[19] = Unknown State (0x0)</span><br><span class="line">  StateHistory[18] = Unknown State (0x0)</span><br><span class="line">  StateHistory[17] = Unknown State (0x0)</span><br><span class="line">  StateHistory[16] = Unknown State (0x0)</span><br><span class="line">  StateHistory[15] = Unknown State (0x0)</span><br><span class="line">  StateHistory[14] = Unknown State (0x0)</span><br><span class="line">  StateHistory[13] = Unknown State (0x0)</span><br><span class="line">  StateHistory[12] = Unknown State (0x0)</span><br><span class="line">  StateHistory[11] = Unknown State (0x0)</span><br><span class="line">  StateHistory[10] = Unknown State (0x0)</span><br><span class="line">  StateHistory[09] = Unknown State (0x0)</span><br><span class="line">  StateHistory[08] = Unknown State (0x0)</span><br><span class="line">  StateHistory[07] = Unknown State (0x0)</span><br><span class="line">  StateHistory[06] = Unknown State (0x0)</span><br><span class="line">  StateHistory[05] = Unknown State (0x0)</span><br><span class="line">  StateHistory[04] = Unknown State (0x0)</span><br><span class="line">  StateHistory[03] = Unknown State (0x0)</span><br><span class="line">  Flags (0x6c0000f0)  DNF_ENUMERATED, DNF_IDS_QUERIED, </span><br><span class="line">                      DNF_HAS_BOOT_CONFIG, DNF_BOOT_CONFIG_RESERVED, </span><br><span class="line">                      DNF_NO_LOWER_DEVICE_FILTERS, DNF_NO_LOWER_CLASS_FILTERS, </span><br><span class="line">                      DNF_NO_UPPER_DEVICE_FILTERS, DNF_NO_UPPER_CLASS_FILTERS</span><br><span class="line">  CapabilityFlags (0x00002000)  WakeFromD3</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windbg</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Driver - Visual Studio配置</title>
    <url>/2024/08/30/Windows%20Driver%20-%20Visual%20Studio%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Windows-Driver-Visual-Studio配置"><a href="#Windows-Driver-Visual-Studio配置" class="headerlink" title="Windows Driver - Visual Studio配置"></a>Windows Driver - Visual Studio配置</h1><h2 id="安装VisualStudio-SDK-WDK环境"><a href="#安装VisualStudio-SDK-WDK环境" class="headerlink" title="安装VisualStudio+SDK+WDK环境"></a>安装VisualStudio+SDK+WDK环境</h2><p>全部流程：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk</a></p>
<p>注意：WDK安装前要求先安装适配版本的SDK：</p>
<p><a href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/">https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/</a></p>
<p>推荐按以上链接在VS安装程序中安装Windows 11 SDK (10.0.26100.0)，注意默认选中的不是这个版本，需要手动选择这个版本：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408121640199.png" alt="image-20240812164012107"></p>
<p>正常安装完SDK和WDK后，创建一个KMDF项目是像这样：如果缺少SDK和Driver Setting这些，说明SDK版本不匹配</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408121647174.png" alt="image-20240812164731134"></p>
<p>注意：如果在有问题的环境创建了项目编译会报错，在环境配好后该项目也不能用还是会编译报错，应该删除重新建。</p>
<h2 id="VS2019-SDK-WDK环境"><a href="#VS2019-SDK-WDK环境" class="headerlink" title="VS2019+SDK+WDK环境"></a>VS2019+SDK+WDK环境</h2><p>TODO</p>
<h2 id="搭建DVL环境（for-WHQL）"><a href="#搭建DVL环境（for-WHQL）" class="headerlink" title="搭建DVL环境（for WHQL）"></a>搭建DVL环境（for WHQL）</h2><p>前置环境：Visual Studio 2019 + SDK 22000 + WDK 22000 + 一些MSVC模块 </p>
<p>(Visual Studio 2022 + 24H2 WDK无法正常执行CodeQL(找不到x86\InfVerif.dll)，也没有自带SDV，暂时不用VS2022环境)</p>
<p>DVL：driver verification log</p>
<p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/develop/creating-a-driver-verification-log">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/develop/creating-a-driver-verification-log</a></p>
<p>The <a href="https://learn.microsoft.com/en-us/windows-hardware/design/compatibility/">Windows Hardware Certification Program</a> requires a driver verification log (DVL) for driver submissions. The DVL contains a summary of the results from static analysis tools, <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql">CodeQL</a>. The DVL doesn’t contain any source code information. Before creating a DVL for your driver, run CodeQL, the code analysis tool, and static driver verifier. </p>
<p>使用VS2019+WDK，WHQL的DVL生成依赖于三项文件：<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271608916.png" alt="image-20241227160816886"></p>
<ol>
<li>Code Analysis（CA） log： VS2019 + WDK 环境可以生成</li>
<li>Static Driver Verifier（SDV） log：VS2019 + WDK 环境可以生成</li>
<li>CodeQL Sarif log：需要配置CodeQL环境</li>
</ol>
<p>根据微软的SDV文档（<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-driver-verifier%EF%BC%89%EF%BC%9ACodeQL">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-driver-verifier）：CodeQL</a> 和SDV似乎是并列关系，都是静态代码分析，因此VS 2022直接不支持SDV，只推荐CodeQL。但不确定WHQL logo driver是不是必须要SDV，因此还是用VS2019环境以确保DVL需要的三种log都能生成。</p>
<h3 id="配置CodeQL环境"><a href="#配置CodeQL环境" class="headerlink" title="配置CodeQL环境"></a>配置CodeQL环境</h3><p>详细步骤参考：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql#queries-and-suites">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql#queries-and-suites</a></p>
<p><a href="https://github.com/microsoft/Windows-Driver-Developer-Supplemental-Tools">https://github.com/microsoft/Windows-Driver-Developer-Supplemental-Tools</a></p>
<p>WHQL的OS版本对CodeQL版本的兼容矩阵表：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271036011.png" alt="image-20241227103629965"></p>
<p>假如要发布24H2的WHQL driver，需要选用红框的版本。按以下几步配置CodeQL环境：</p>
<p>创建CodeQL环境的home目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; mkdir C:\codeql-home</span><br></pre></td></tr></table></figure>

<ol>
<li>下载CodeQL 2.15.4 二进制包</li>
</ol>
<p><a href="https://github.com/github/codeql-cli-binaries/releases/tag/v2.15.4">https://github.com/github/codeql-cli-binaries/releases/tag/v2.15.4</a></p>
<ol start="2">
<li><p>下载Windows Driver Developer Supplemental Tools的WHCP_24H2分支；或者git clone，再checkout到WHCP_24H2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）下载Windows Driver Developer Supplemental Tools的WHCP_24H2分支：</span><br><span class="line">git clone https://github.com/microsoft/Windows-Driver-Developer-Supplemental-Tools.git</span><br><span class="line">git branch -a</span><br><span class="line">git checkout WHCP_24H2</span><br><span class="line">也可以在github页面切换到WHCP_24H2分支后下载压缩包</span><br><span class="line"></span><br><span class="line">（2）查看分支：</span><br><span class="line">C:\codeql-home\Windows-Driver-Developer-Supplemental-Tools&gt;git branch</span><br><span class="line">* WHCP_24H2</span><br><span class="line">  main</span><br></pre></td></tr></table></figure>

<p>注意，不同的分支可能对应不同的<a href="https://github.com/microsoft/Windows-Driver-Developer-Supplemental-Tools/blob/main/suites/windows_driver_mustfix.qls">windows_driver_mustfix.qls</a></p>
</li>
<li><p>安装CodeQL query packages</p>
<p>如果不安装CodeQL query packages，直接执行codeql analyze会报package缺失，目前我是手动安装package：VS rebuild多次执行后处理脚本RunCodeQLRebuildQuery.bat，每次报错缺什么版本package就装什么，如下图，直到不再报错。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271547361.png" alt="image-20241227154734283"></p>
<p>安装单个query packages方法：在C:\codeql-home\codeql目录下（包含codeql.exe），执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeql pack download &lt;package&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure>

<p>安装所有依赖的query packages过程如下（仅针对CodeQL 2.15.4）：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Package specifications to check for download: codeql/cpp-queries@0.9.0</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/cpp-queries@0.9.0</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;</span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download microsoft/windows-drivers@1.1.0</span><br><span class="line">Package specifications to check for download: microsoft/windows-drivers@1.1.0</span><br><span class="line">Did not need to download any packs.</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Nothing downloaded.</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/cpp-all@0.12.1</span><br><span class="line">Package specifications to check for download: codeql/cpp-all@0.12.1</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/cpp-all@0.12.1 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;</span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/dataflow@0.1.4</span><br><span class="line">Package specifications to check for download: codeql/dataflow@0.1.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/dataflow@0.1.4 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/rangeanalysis@0.0.3</span><br><span class="line">Package specifications to check for download: codeql/rangeanalysis@0.0.3</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/rangeanalysis@0.0.3 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/ssa@0.2.4</span><br><span class="line">Package specifications to check for download: codeql/ssa@0.2.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/ssa@0.2.4 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/tutorial@0.2.4</span><br><span class="line">Package specifications to check for download: codeql/tutorial@0.2.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/tutorial@0.2.4 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/util@0.2.4</span><br><span class="line">Package specifications to check for download: codeql/util@0.2.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/util@0.2.4 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/typetracking@0.2.4</span><br><span class="line">Package specifications to check for download: codeql/typetracking@0.2.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/typetracking@0.2.4 (library)</span><br></pre></td></tr></table></figure>

<p>有时候网络不好下载失败，换个时间多次重试直到安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/cpp-queries@0.9.0</span><br><span class="line">Package specifications to check for download: codeql/cpp-queries@0.9.0</span><br><span class="line">A fatal error occurred: Error downloading blob.</span><br><span class="line">(eventual cause: SocketTimeoutException &quot;Read timed out&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="CodeQL生成-sarif"><a href="#CodeQL生成-sarif" class="headerlink" title="CodeQL生成.sarif"></a>CodeQL生成.sarif</h3><p>(1) 使用.BAT（参考 <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql#queries-and-suites">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql#queries-and-suites</a>  7. Visual Studio Post-Build Event (Optional)）</p>
<p>(2) RunCodeQLRebuildQuery.bat内容如下：</p>
<p>​    功能：在C:\codeql-home创建空目录databases，再执行codeql create database和codeql analyze database，其中codeql analyze database依赖于前面的CodeQL query packages和Windows Driver Developer Supplemental Tools。最后输出kmdf.sarif。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECHO &quot;&gt;&gt;&gt; Running CodeQL Security Rule V 1.0 &lt;&lt;&lt;&quot;</span><br><span class="line">ECHO &quot;Current directory:&quot; %cd%</span><br><span class="line"></span><br><span class="line">set HOME=C:\codeql-home</span><br><span class="line">set SRC=%cd%</span><br><span class="line"></span><br><span class="line">ECHO &quot;&gt;&gt;&gt; Removing previously created rules database &lt;&lt;&lt;&quot;</span><br><span class="line">if exist %HOME%\databases (</span><br><span class="line">	rmdir /s/q %HOME%\databases</span><br><span class="line">)</span><br><span class="line">mkdir %HOME%\databases</span><br><span class="line"></span><br><span class="line">ECHO &quot;&gt;&gt;&gt; codeql create database &lt;&lt;&lt;&quot;</span><br><span class="line">%HOME%\codeql\codeql database create &quot;%HOME%\databases&quot; -l=cpp -s=%SRC% -c &quot;msbuild %SRC%\bhtpcr.sln /p:Configuration=Win8.1Release /p:Platform=ARM64 /t:rebuild /p:PostBuildEventUseInBuild=false&quot;</span><br><span class="line">::ECHO &quot;&gt;&gt;&gt; codeql analyze database &lt;&lt;&lt;&quot;</span><br><span class="line">::codeql database analyze &lt;path to database&gt; &lt;path to query suite .qls file&gt;</span><br><span class="line">CALL %HOME%\codeql\codeql database analyze --download &quot;%HOME%\databases&quot; &quot;%HOME%\Windows-Driver-Developer-Supplemental-Tools\suites\windows_driver_mustfix.qls&quot; --format=sarifv2.1.0 --output=%HOME%\databases\kmdf.sarif --rerun</span><br><span class="line"></span><br><span class="line">ECHO &quot;&gt;&gt;&gt; Loading SARIF Results in Visual Studio &lt;&lt;&lt;&quot;</span><br><span class="line">CALL devenv /Edit %HOME%\databases\kmdf.sarif</span><br><span class="line">SET ERRORLEVEL = 0</span><br></pre></td></tr></table></figure>

<p>(3) 设置项目后处理脚本为RunCodeQLRebuildQuery.bat，并使能，如下图：</p>
<p>这个示例RunCodeQLRebuildQuery.bat位置是.vcxproj的上级目录，也可以放同级目录，不需要加..\</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271529699.png" alt="image-20241227152914648"></p>
<p>(4)运行项目rebuild，编译后会运行RunCodeQLRebuildQuery.bat，正常结果显示success，并能看到kmdf.sarif文件，如下图。如果有错一般是前面的query依赖库没装好，或者VS+WDK版本不兼容。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271544290.png" alt="image-20241227154401168"></p>
<p>(5) 最后将C:\codeql-home\databases\kmdf.sarif拷贝到Driver的vcproj目录，后面的DVL生成会用到。</p>
<p>(6) RunCodeQLRebuildQuery.bat的调试经验：</p>
<p>如果找不到msbuild，需要将msbuild.exe的路径加到系统PATH，例如（D:\Program Files\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin）</p>
<p>中文系统上执行msbuild可能输出乱码，CMD中设置中文编码支持：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure>

<h3 id="运行SDV和Code-Analysis，生成DVL"><a href="#运行SDV和Code-Analysis，生成DVL" class="headerlink" title="运行SDV和Code Analysis，生成DVL"></a>运行SDV和Code Analysis，生成DVL</h3><p>（1）生成SDV：VS2019 + WDK 22000安装后自带SDV（Static Driver Verifier）</p>
<p>VS2019 -&gt; Extension -&gt; Driver -&gt; Launch Static Driver Verifier</p>
<p>默认选择must fix项，但WHQL的HLK并不需要测所有，也不要求测试项必须通过，因此也可以选择default，或者自定义只测一项nullcheck。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271607797.png" alt="image-20241227160707770"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271607341.png" alt="image-20241227160717317"></p>
<p>（2）生成CA：VS2019 -&gt; Analyze -&gt; Run code analysis -&gt; Run code analysis on bhtsddr</p>
<p>（3）生成kmdf.sarif：已在项目目录下</p>
<p>（4）生成DVL：VS2019 -&gt; Extension -&gt; Driver -&gt; Create driver verification log</p>
<p>显示三种依赖log都detected，Create有警告无所谓，在项目目录下有DriverName.DVL.XML文件生成</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271630847.png" alt="image-20241227163042814"></p>
<p>DVL示例内容如下（SDV和CA有fail，但不影响WHQL HLK）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Data&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.XMLTimeStamp&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;12/27/2024 15:54:26&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.DriverBinary&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;bhtsdhubdr.sys&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.BinaryTimeStamp&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;01/01/1601 08:00:00&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.DriverType&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;generic&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.DriverSize&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;LOC&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.DriverVersion&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;0&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.Libs&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;Number of external libraries used&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.SDV.Version&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;sdv-2021-03-16&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.SDV.ActiveRuleTotal&quot; ScoreValue=&quot;4&quot; ScoreUnit=&quot;Total rules available&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.SDV.Rule.nullcheck&quot; ScoreValue=&quot;1&quot; ScoreUnit=&quot;SDV_FAILED&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.CodeAnalysis.Summary&quot; ScoreValue=&quot;2&quot; ScoreUnit=&quot;Types of defects seen&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.CodeAnalysis.Defect.6385&quot; ScoreValue=&quot;1&quot; ScoreUnit=&quot;CA_FAILED&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.CodeAnalysis.Defect.6001&quot; ScoreValue=&quot;1&quot; ScoreUnit=&quot;CA_MUSTFIX_FAILED&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.Semmle.Summary&quot; ScoreValue=&quot;1&quot; ScoreUnit=&quot;Types of defects seen&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.Semmle.Defect.cpp/comparison-with-wider-type&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;SEMMLE_FAILED&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.Checksum&quot; ScoreValue=&quot;4TYw1CLepWklxyssSBb7x9m/tAtAuZozCUvaOq7od2SAQZx6SRlBzEK1wIlqB34JiwSni1qyOrcXYr3C3mrXTA==&quot; ScoreUnit=&quot;DVL Checksum Value&quot;/&gt;</span><br><span class="line">&lt;/Data&gt;</span><br></pre></td></tr></table></figure>

<p>WHQL的HLK测试会用到此DVL文件。</p>
<h2 id="代码新项目相关的配置"><a href="#代码新项目相关的配置" class="headerlink" title="代码新项目相关的配置"></a>代码新项目相关的配置</h2><h3 id="VisualStudio新项目环境配置"><a href="#VisualStudio新项目环境配置" class="headerlink" title="VisualStudio新项目环境配置"></a>VisualStudio新项目环境配置</h3><h4 id="使用VSCode快捷键"><a href="#使用VSCode快捷键" class="headerlink" title="使用VSCode快捷键"></a>使用VSCode快捷键</h4><p>工具–&gt;选项-&gt;键盘-&gt;键盘映射方案选VSCode</p>
<h4 id="WDF项目找不到头文件问题"><a href="#WDF项目找不到头文件问题" class="headerlink" title="WDF项目找不到头文件问题"></a>WDF项目找不到头文件问题</h4><ol>
<li>找不到&lt;ntddk.h&gt;和&lt;wdf.h&gt;</li>
</ol>
<p>在项目配置-&gt; C&#x2F;C++ -&gt; General -&gt; Additional Include Directories -&gt; 加上WDK和WDF的include头文件路径</p>
<p>Ntddk.h contains core Windows kernel definitions for all drivers, while Wdf.h<br>contains definitions for drivers based on the Windows Driver Framework (WDF).  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408121042763.png" alt="image-20240812104158672"></p>
<p>注意WDF的版本，Win11选WDF 1.33，参考：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/wdf/kmdf-version-history">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/wdf/kmdf-version-history</a></p>
<ol start="2">
<li>找不到device.tmh</li>
</ol>
<p>项目设置 -&gt; WPP Tracing -&gt; 设置 “Run Wpp Tracing” 为 YES</p>
<h4 id="WDF项目找不到链接symbol"><a href="#WDF项目找不到链接symbol" class="headerlink" title="WDF项目找不到链接symbol"></a>WDF项目找不到链接symbol</h4><p><a href="https://learn.microsoft.com/en-us/cpp/error-messages/tool-errors/linker-tools-error-lnk2019?view=msvc-170#third-party-library-issues-and-vcpkg">https://learn.microsoft.com/en-us/cpp/error-messages/tool-errors/linker-tools-error-lnk2019?view=msvc-170#third-party-library-issues-and-vcpkg</a></p>
<p>如果是调用第三方库API报此问题，基本上是项目配置没有链接这个库</p>
<p>The object file or library that contains the definition of the symbol isn’t linked</p>
<p>以SDBUS驱动为例，ntddsd.h定义的SdBusSubmitRequest只有declaration，其函数体实现其实是在SDBUS.lib里，用everything搜索此lib（WDK路径），加到项目配置的Link dependence lib（Link -&gt; Input -&gt; Additional Dependence），即可编译通过。</p>
<p>The <em>ntddsd.h</em> header file, which is provided in the Windows Driver Kit (WDK), declares the prototypes for the routines exposed by the SD bus library.</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/sd/sd-card-driver-stack">https://learn.microsoft.com/en-us/windows-hardware/drivers/sd/sd-card-driver-stack</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408221950345.png" alt="image-20240822195016239"></p>
<p>另外一个示例：</p>
<p>RtlStringCbVPrintfA打印函数属于ntstrsafe.h定义，其lib同名，位于WDK的km目录；一般WDF驱动把km和kmdf的.lib都加到项目的linker路径：（Link -&gt; Input -&gt; Additional Dependence）</p>
<p>注意需要指定到.lib文件名，一般是用到哪个lib才链接哪个lib；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\km\x64\ntstrsafe.lib</span><br></pre></td></tr></table></figure>

<p>也可以用*匹配所有lib：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\km\x64\*.lib</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\wdf\kmdf\x64\1.33\*.lib</span><br></pre></td></tr></table></figure>

<h4 id="VS-Code配置项目包含WDF-WDM头文件"><a href="#VS-Code配置项目包含WDF-WDM头文件" class="headerlink" title="VS Code配置项目包含WDF&#x2F;WDM头文件"></a>VS Code配置项目包含WDF&#x2F;WDM头文件</h4><p>在.vscode的c_cpp_properties.json添加WDF&#x2F;WDM所在的头文件定义（即前面VisualStudio添加的Additional Include Directories），在WDK目录，用everything搜索wdf.h和wdm.h所在的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Include\\wdf\\kmdf\\1.15&quot;,</span><br><span class="line">                &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\km&quot;,</span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>

<p>注意上图windows路径需要将单斜杠全局替换成双斜杠，空格不需要加反斜杠</p>
<p>替换完毕查看是否能跳转，例如单击WdfIoQueueCreate能跳转到wdfio.h的函数体定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_Must_inspect_result_</span><br><span class="line">_IRQL_requires_max_(DISPATCH_LEVEL)</span><br><span class="line">NTSTATUS</span><br><span class="line">FORCEINLINE</span><br><span class="line">WdfIoQueueCreate(</span><br><span class="line">    _In_</span><br><span class="line">    WDFDEVICE Device,</span><br><span class="line">    _In_</span><br><span class="line">    PWDF_IO_QUEUE_CONFIG Config,</span><br><span class="line">    _In_opt_</span><br><span class="line">    PWDF_OBJECT_ATTRIBUTES QueueAttributes,</span><br><span class="line">    _Out_opt_</span><br><span class="line">    WDFQUEUE* Queue</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    return ((PFN_WDFIOQUEUECREATE) WdfFunctions[WdfIoQueueCreateTableIndex])(WdfDriverGlobals, Device, Config, QueueAttributes, Queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码中支持中文编码"><a href="#代码中支持中文编码" class="headerlink" title="代码中支持中文编码"></a>代码中支持中文编码</h4><p>Warning C4819 The file contains a character that cannot be represented in the current code page (936). Save the file in Unicode format to prevent data loss</p>
<p>这个警告是关于代码页(code page)编码的问题。警告 C4819 表示文件中包含无法在当前代码页(936,即GBK编码)中表示的字符。</p>
<p>解决这个问题有以下几种方法:</p>
<ol>
<li>最推荐的方法是将文件保存为 UTF-8 with BOM 格式:</li>
</ol>
<ul>
<li>在 Visual Studio 中打开文件</li>
<li>点击”文件” -&gt; “高级保存选项”</li>
<li>在编码下拉框中选择”UTF-8 with signature (Codepage 65001)”</li>
<li>点击保存</li>
</ul>
<ol start="2">
<li>如果需要保持当前编码,可以在文件开头添加编码指示:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma code_page(65001)  // 使用 UTF-8 编码</span><br><span class="line">// ... 其余代码 ...</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>也可以在项目设置中修改:</li>
</ol>
<ul>
<li>右键项目 -&gt; 属性</li>
<li>C&#x2F;C++ -&gt; 命令行</li>
<li>在”其他选项”中添加 <code>/utf-8</code></li>
</ul>
<p>尝试过最有效的是方法3，但需要注意 Release和Debug的项目配置是独立的，需要配置两次&#x2F;utf-8</p>
]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windows驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Driver -- INF Verifier使用笔记</title>
    <url>/2024/08/30/Windows%20Driver%20--%20INF%20Verifier%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Windows-Driver-–-INF-Verifier使用笔记"><a href="#Windows-Driver-–-INF-Verifier使用笔记" class="headerlink" title="Windows Driver – INF Verifier使用笔记"></a>Windows Driver – INF Verifier使用笔记</h1><p>WDK有INF verifier用于检测Driver安装包的INF信息文件的内容是否符合要求：如果INF不符合要求，可能在安装Driver报错或者Driver运行时功能报错。</p>
<h2 id="INF-verifier使用"><a href="#INF-verifier使用" class="headerlink" title="INF verifier使用"></a>INF verifier使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\infverif.exe /w /v C:\path\driver.inf</span><br></pre></td></tr></table></figure>

<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/running-infverif-from-the-command-line">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/running-infverif-from-the-command-line</a></p>
<h2 id="排错示例"><a href="#排错示例" class="headerlink" title="排错示例"></a>排错示例</h2><p>新建WDF驱动项目时产生默认的INF，但其中一些符号需要替换，否则安装driver时会直接报错安装失败</p>
<ol>
<li>DIRID 13问题</li>
</ol>
<p>driver.sys一般的路径符号 DIRID是12，较新的OS WDK要求DIRID使用13，用于实现driver package isolation：</p>
<p>参考：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/porting-inf-to-windows-driver">https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/porting-inf-to-windows-driver</a></p>
<p>错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Program Files (x86)\Windows Kits\10\Tools\10.0.26100.0\x64&gt;</span><br><span class="line">ARM64\Debug\O2SD\O2SD.inf</span><br><span class="line">ERROR(1322) in C:\Users\cursorhu\source\repos\O2SD\ARM64\Debug\O2SD\O2SD.inf, line 49: Destination file path &#x27;C:\Windows\System32\drivers&#x27; for file &#x27;O2SD.sys&#x27; is not isolated to DIRID 13.</span><br></pre></td></tr></table></figure>

<p>解决(git diff)：设置DestinationDirs &#x3D; 13，并设置SourceDisksNames的TargetOSVersion</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> [DestinationDirs]</span><br><span class="line">-DefaultDestDir = 12 ;DIRID_DRIVERS; </span><br><span class="line">+DefaultDestDir = 13 ;DIRID_DRIVERS; %13% only supported since OS build 16299</span><br><span class="line"></span><br><span class="line">[SourceDisksNames]</span><br><span class="line">...</span><br><span class="line">+%ManufacturerName% = Generic,NTarm64.10.0...26100 ; with TargetOSVersion</span><br><span class="line"></span><br><span class="line">+[Generic.NTarm64.10.0...26100]</span><br><span class="line"> ServiceType    = 1               ; SERVICE_KERNEL_DRIVER</span><br><span class="line"> StartType      = 3               ; SERVICE_DEMAND_START</span><br><span class="line"> ErrorControl   = 1               ; SERVICE_ERROR_NORMAL</span><br><span class="line">-ServiceBinary  = %12%\O2SD.sys</span><br><span class="line">+ServiceBinary  = %13%\O2SD.sys  ; DestinationDirs</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>变量未定义问题</li>
</ol>
<p>错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">报错1：Unresolved $ARCH$ token for section [generic.nt$arch$]. Must run stampinf tool to resolve case sensitive $ARCH$ tokens.</span><br><span class="line"></span><br><span class="line">报错2：KmdfLibraryVersion directive has invalid value &quot;$KmdfLibraryVersion&quot;</span><br></pre></td></tr></table></figure>

<p>解决(git diff)：根据平台环境指定变量值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-%ManufacturerName% = Generic,NT$ARCH$</span><br><span class="line">+%ManufacturerName% = Generic,NTarm64.10.0...26100 </span><br><span class="line"></span><br><span class="line">-[Generic.NT$ARCH$]</span><br><span class="line">+[Generic.NTarm64.10.0...26100]</span><br><span class="line"></span><br><span class="line">-KmdfLibraryVersion = $KMDFVERSION$</span><br><span class="line">+KmdfLibraryVersion = 1.33</span><br></pre></td></tr></table></figure>

<p>全部错误修复后，显示如下：INF is VALID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\infverif.exe /w /v C:\Users\cursorhu\source\repos\O2SD\O2SD.inf</span><br><span class="line">Running in Verbose</span><br><span class="line">Running Windows Driver INF check</span><br><span class="line"></span><br><span class="line">Validating O2SD.inf</span><br><span class="line">INF is VALID</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windows驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>WDF PCIe-SD Host Controller Driver Analysis</title>
    <url>/2024/08/30/Windows%20Driver%20--%20WDF%20PCIe-SD%20Host%20Controller%20Driver%20Analysis/</url>
    <content><![CDATA[<h1 id="Windows-WDF-PCIe-SD-Host-Controller-Driver-Analysis"><a href="#Windows-WDF-PCIe-SD-Host-Controller-Driver-Analysis" class="headerlink" title="Windows WDF PCIe-SD Host Controller Driver Analysis"></a>Windows WDF PCIe-SD Host Controller Driver Analysis</h1><h2 id="Current-Status-Analysis"><a href="#Current-Status-Analysis" class="headerlink" title="Current Status Analysis"></a>Current Status Analysis</h2><p>Based on the dumpfile information:</p>
<h3 id="1-Driver-Stack-Structure-Correct"><a href="#1-Driver-Stack-Structure-Correct" class="headerlink" title="1. Driver Stack Structure - Correct"></a>1. Driver Stack Structure - Correct</h3><ul>
<li><p>Device stack is properly established: partmgr → disk → sdhcstor</p>
</li>
<li><p>Upper layer device (disk.sys) successfully starts and attaches to your driver</p>
</li>
<li><p>ServiceName is “disk”, DeviceInst shows correct device path</p>
</li>
</ul>
<h3 id="2-Critical-Issue-ExtensionFlags-Inconsistency"><a href="#2-Critical-Issue-ExtensionFlags-Inconsistency" class="headerlink" title="2. Critical Issue: ExtensionFlags Inconsistency"></a>2. Critical Issue: ExtensionFlags Inconsistency</h3><p>Device object ffffc701663ddc80 (Upper device):</p>
<ul>
<li><p>⚠️ ExtensionFlags &#x3D; 0x0000000000 (Highlighted in orange - THIS IS THE PROBLEM)</p>
</li>
<li><p>This device object is missing necessary extension flags</p>
</li>
</ul>
<p>Device object ffffc70162a1aa0 (Driver object):</p>
<ul>
<li><p>✓ ExtensionFlags &#x3D; 0x00000800 (DOE_DEFAULT_SD_PRESENT)</p>
</li>
<li><p>This flag indicates SD card present - this is correct</p>
</li>
</ul>
<h3 id="3-BSOD-Root-Cause-Analysis"><a href="#3-BSOD-Root-Cause-Analysis" class="headerlink" title="3. BSOD Root Cause Analysis"></a>3. BSOD Root Cause Analysis</h3><p>ExtensionFlags being 0 indicates:</p>
<ul>
<li><p>Device extension object may not be properly initialized</p>
</li>
<li><p>I&#x2F;O buffer management related extension information is missing</p>
</li>
<li><p>Likely missing proper setup during IRP_MJ_CREATE or device creation</p>
</li>
</ul>
<h2 id="Solution-Correctness-Assessment"><a href="#Solution-Correctness-Assessment" class="headerlink" title="Solution Correctness Assessment"></a>Solution Correctness Assessment</h2><h3 id="✓-Correct-Aspects"><a href="#✓-Correct-Aspects" class="headerlink" title="✓ Correct Aspects:"></a>✓ Correct Aspects:</h3><ol>
<li><p>I&#x2F;O Queue Implementation - Sequential handling of Read&#x2F;Write requests is correct</p>
</li>
<li><p>Driver Stack Architecture - Functioning as port driver below disk.sys is standard architecture</p>
</li>
<li><p>Device Attachment - Upper device successfully attaching indicates AddDevice is fundamentally correct</p>
</li>
</ol>
<h3 id="Areas-Requiring-Correction"><a href="#Areas-Requiring-Correction" class="headerlink" title="Areas Requiring Correction:"></a>Areas Requiring Correction:</h3><ol>
<li>Device Extension Object Initialization</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Check your EvtDeviceAdd or device creation code</span><br><span class="line">// Ensure proper Device Extension setup</span><br><span class="line">WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&amp;attributes, DEVICE_CONTEXT);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ExtensionFlags Configuration</li>
</ol>
<ul>
<li><p>Verify proper call to WdfDeviceInitSetDeviceType()</p>
</li>
<li><p>Ensure device characteristics flags are correctly set:</p>
</li>
<li><p>FILE_AUTOGENERATED_DEVICE_NAME</p>
</li>
<li><p>FILE_DEVICE_SECURE_OPEN</p>
</li>
<li><p>FILE_PORTABLE_DEVICE</p>
</li>
</ul>
<ol start="3">
<li>I&#x2F;O Buffer Management Critical Points</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Set correct buffer method during device initialization</span><br><span class="line">WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoDirect); // or WdfDeviceIoBuffered</span><br><span class="line"></span><br><span class="line">// Ensure proper alignment requirements are set</span><br><span class="line">WdfDeviceInitSetIoInCallerContextCallback(DeviceInit, YourPreprocessCallback);</span><br></pre></td></tr></table></figure>

<h2 id="Recommended-Debugging-Steps"><a href="#Recommended-Debugging-Steps" class="headerlink" title="Recommended Debugging Steps"></a>Recommended Debugging Steps</h2><ol>
<li>Verify Device Extension Allocation</li>
</ol>
<ul>
<li><p>Confirm DEVICE_CONTEXT structure is properly allocated and initialized</p>
</li>
<li><p>Use !wdfkd.wdfdevice command to inspect WDF device object state</p>
</li>
</ul>
<ol start="2">
<li>Add Tracing</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Add DbgPrint or WPP tracing at critical points:</span><br><span class="line">- EvtDeviceAdd</span><br><span class="line">- EvtDevicePrepareHardware</span><br><span class="line">- I/O Queue callbacks</span><br><span class="line">- Buffer mapping/locking operations</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Validate DMA&#x2F;Buffer Operations</li>
</ol>
<ul>
<li><p>Check if DMA Enabler is properly created (if using DMA)</p>
</li>
<li><p>Verify MDL (Memory Descriptor List) handling</p>
</li>
<li><p>Ensure all buffer pointers are properly locked and mapped before use</p>
</li>
</ul>
<ol start="4">
<li>Inspect IRP Handling</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Ensure proper handling of these IRPs during mount:</span><br><span class="line">- IRP_MJ_CREATE</span><br><span class="line">- IRP_MJ_DEVICE_CONTROL (IOCTL_MOUNTDEV_*)</span><br><span class="line">- IRP_MJ_PNP (especially IRP_MN_QUERY_CAPABILITIES)</span><br></pre></td></tr></table></figure>

<h2 id="Specific-Code-Areas-to-Review"><a href="#Specific-Code-Areas-to-Review" class="headerlink" title="Specific Code Areas to Review"></a>Specific Code Areas to Review</h2><h3 id="Device-Initialization-Priority-1"><a href="#Device-Initialization-Priority-1" class="headerlink" title="Device Initialization (Priority #1)"></a>Device Initialization (Priority #1)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">YourEvtDeviceAdd(</span><br><span class="line">    WDFDRIVER Driver,</span><br><span class="line">    PWDFDEVICE_INIT DeviceInit</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    WDF_OBJECT_ATTRIBUTES deviceAttributes;</span><br><span class="line">    WDFDEVICE device;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    </span><br><span class="line">    // CRITICAL: Set device type</span><br><span class="line">    WdfDeviceInitSetDeviceType(DeviceInit, FILE_DEVICE_MASS_STORAGE);</span><br><span class="line">    </span><br><span class="line">    // CRITICAL: Set I/O type</span><br><span class="line">    WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoDirect);</span><br><span class="line">    </span><br><span class="line">    // CRITICAL: Set device characteristics</span><br><span class="line">    WdfDeviceInitSetCharacteristics(DeviceInit,</span><br><span class="line">        FILE_AUTOGENERATED_DEVICE_NAME |</span><br><span class="line">        FILE_DEVICE_SECURE_OPEN |</span><br><span class="line">        FILE_PORTABLE_DEVICE,</span><br><span class="line">        FALSE);</span><br><span class="line">    </span><br><span class="line">    // Initialize device context</span><br><span class="line">    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&amp;deviceAttributes, DEVICE_CONTEXT);</span><br><span class="line">    </span><br><span class="line">    status = WdfDeviceCreate(&amp;DeviceInit, &amp;deviceAttributes, &amp;device);</span><br><span class="line">    if (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Initialize device extension here</span><br><span class="line">    PDEVICE_CONTEXT context = GetDeviceContext(device);</span><br><span class="line">    // Ensure all fields are properly initialized</span><br><span class="line">    </span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Buffer-Handling-in-I-O-Queue"><a href="#Buffer-Handling-in-I-O-Queue" class="headerlink" title="Buffer Handling in I&#x2F;O Queue"></a>Buffer Handling in I&#x2F;O Queue</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VOID</span><br><span class="line">YourEvtIoRead(</span><br><span class="line">    WDFQUEUE Queue,</span><br><span class="line">    WDFREQUEST Request,</span><br><span class="line">    size_t Length</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    WDFMEMORY memory;</span><br><span class="line">    PVOID buffer;</span><br><span class="line">    </span><br><span class="line">    // CRITICAL: Proper buffer retrieval</span><br><span class="line">    status = WdfRequestRetrieveOutputMemory(Request, &amp;memory);</span><br><span class="line">    if (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        WdfRequestComplete(Request, status);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buffer = WdfMemoryGetBuffer(memory, NULL);</span><br><span class="line">    if (buffer == NULL) &#123;</span><br><span class="line">        WdfRequestComplete(Request, STATUS_INSUFFICIENT_RESOURCES);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Ensure buffer is locked/mapped before hardware access</span><br><span class="line">    // Your DMA or PIO operation here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><ol>
<li><p>Immediate Action: Review Device Extension initialization code, ensure all necessary flags are set during device creation</p>
</li>
<li><p>Set Breakpoints: On all I&#x2F;O request handlers before mount operation</p>
</li>
<li><p>Verify: WdfDeviceInitSetDeviceType() and related device characteristics configuration</p>
</li>
<li><p>Analyze: Specific bugcheck code and parameters from the BSOD (if complete minidump available)</p>
</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Overall Assessment: Your architecture is fundamentally correct. The issue is concentrated in device object initialization and extension flags configuration. This is a typical detail that’s easy to overlook in WDF driver development, but critical for proper I&#x2F;O buffer management.</p>
<p>The fact that:</p>
<ul>
<li><p>Device stack builds correctly</p>
</li>
<li><p>Upper device attaches successfully</p>
</li>
<li><p>Queue shows “not busy”</p>
</li>
</ul>
<p>…indicates the framework is mostly correct. The ExtensionFlags discrepancy is the smoking gun pointing to incomplete device initialization during the AddDevice routine.</p>
<p>Confidence Level: High - This is a common pattern in WDF driver issues related to mount failures and I&#x2F;O buffer management.</p>
<p>Would you like me to review your source code to provide more specific corrections?</p>
]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windows驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Driver -- Windbg联调环境配置</title>
    <url>/2024/08/30/Windows%20Driver%20--%20Windbg%E8%81%94%E8%B0%83%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Windows-Driver-–-Windbg联调环境配置"><a href="#Windows-Driver-–-Windbg联调环境配置" class="headerlink" title="Windows Driver – Windbg联调环境配置"></a>Windows Driver – Windbg联调环境配置</h1><p>参考：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection-automatically">https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection-automatically</a></p>
<h2 id="Target-PC配置"><a href="#Target-PC配置" class="headerlink" title="Target PC配置"></a>Target PC配置</h2><p>注意：</p>
<p>Target PC要先开测试模式，且关闭系统所有网络防火墙。</p>
<p>Target PC要能Ping通Host PC，即Host PC和Target PC可以用同一局域网的路由器(Router)或交换机(Hub)的网口相连。</p>
<p>Target PC的kdnet创建一次以后再创建也不会变。</p>
<p>Kdnet配置完成后，设备管理器的网络设备会有Kernel Debug Network设备（KDNET），且网口设备（例如下面的Intel Ethernet）会有感叹号Code53是正常的，表示此网口正作为KDNET debug端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32&gt;</span><br><span class="line">C:\Windows\System32&gt;cd c:\kdnet</span><br><span class="line"></span><br><span class="line">c:\kdnet&gt;kdnet.exe</span><br><span class="line"></span><br><span class="line">Network debugging is supported on the following NICs:</span><br><span class="line">busparams=0.31.6, Intel(R) Ethernet Connection (7) I219-V, KDNET is running on this NIC.</span><br><span class="line"></span><br><span class="line">Network debugging is supported on the following USB controllers:</span><br><span class="line">busparams=0.20.0, Intel(R) USB 3.1 eXtensible Host Controller - 1.10 (Microsoft)</span><br><span class="line"></span><br><span class="line">This Microsoft hypervisor supports using KDNET in guest VMs.</span><br><span class="line"></span><br><span class="line">c:\kdnet&gt;</span><br><span class="line">c:\kdnet&gt;kdnet.exe 10.52.4.41 50000</span><br><span class="line"></span><br><span class="line">Enabling network debugging on Intel(R) Ethernet Connection (7) I219-V.</span><br><span class="line"></span><br><span class="line">To debug this machine, run the following command on your debugger host machine.</span><br><span class="line">windbg -k net:port=50000,key=3s1m4bjm7ihi7.3b8dig9hl019g.2fyvva9v1ie3a.38mfaw4eweiuo</span><br><span class="line"></span><br><span class="line">Then reboot this machine by running shutdown -r -t 0 from this command prompt.</span><br><span class="line"></span><br><span class="line">c:\kdnet&gt;ping 10.52.4.41</span><br><span class="line"></span><br><span class="line">Pinging 10.52.4.41 with 32 bytes of data:</span><br><span class="line">Reply from 10.52.4.41: bytes=32 time=4ms TTL=128</span><br><span class="line">Reply from 10.52.4.41: bytes=32 time=1ms TTL=128</span><br><span class="line">Reply from 10.52.4.41: bytes=32 time=1ms TTL=128</span><br><span class="line">Reply from 10.52.4.41: bytes=32 time=1ms TTL=128</span><br><span class="line"></span><br><span class="line">Ping statistics for 10.52.4.41:</span><br><span class="line">    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</span><br><span class="line">Approximate round trip times in milli-seconds:</span><br><span class="line">    Minimum = 1ms, Maximum = 4ms, Average = 1ms</span><br></pre></td></tr></table></figure>

<h2 id="Host-PC配置"><a href="#Host-PC配置" class="headerlink" title="Host PC配置"></a>Host PC配置</h2><p>Host PC也关闭系统网络防火墙。</p>
<p>用Microsoft Store安装的Windbg Preview，Attach to Kernel，填入Target PC生成的Port和Key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port=50000,key=3s1m4bjm7ihi7.3b8dig9hl019g.2fyvva9v1ie3a.38mfaw4eweiuo</span><br></pre></td></tr></table></figure>

<p>连接成功后显示Connected to target ….</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using NET for debugging</span><br><span class="line">Opened WinSock 2.0</span><br><span class="line">Waiting to reconnect...</span><br><span class="line"></span><br><span class="line">Connected to target 10.52.5.0 on port 50000 on local IP 10.52.4.41.</span><br></pre></td></tr></table></figure>

<h2 id="Windbg联机观测DbgPrint"><a href="#Windbg联机观测DbgPrint" class="headerlink" title="Windbg联机观测DbgPrint"></a>Windbg联机观测DbgPrint</h2><h3 id="Windbg显示DbgPrint"><a href="#Windbg显示DbgPrint" class="headerlink" title="Windbg显示DbgPrint"></a>Windbg显示DbgPrint</h3><p>需要打开Target PC的“Enabling verbose kernel output”</p>
<p>可用方法：</p>
<p>（1）在Target PC安装DebugView( <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview">Sysinternals DebugView</a>)，需要运行DebugView，选项勾选“Enable Kernel Debug”和“Enabling verbose kernel output”，才可以在DebugView和Host PC的Windbg同时观测到DbgPrint的打印。</p>
<p>（2）或者在Target PC安装DebugLogger(<a href="https://github.com/tandasat/DebugLogger">DebugLogger</a>, open source implementation of <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview">Sysinternals DebugView</a>)，安装后默认打开了“Enabling verbose kernel output”，无需运行DebugLogger就可以在Host PC的Windbg观测到DebugPrint打印。这种方式可以记录系统重启中的Kernel过程。</p>
<p>注意：以下方法只是在Target PC手动设置打开所有过滤级别，并不能在Host PC的Windbg观测到Target PC的DebugPrint打印：</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/reading-and-filtering-debugging-messages">Reading and Filtering Debugging Messages</a></p>
<h3 id="Windbg记录DbgPrint到log文件："><a href="#Windbg记录DbgPrint到log文件：" class="headerlink" title="Windbg记录DbgPrint到log文件："></a>Windbg记录DbgPrint到log文件：</h3><p>Command -&gt; Save Window to File。使用Log中的特定关键字过滤，另存为Filtered log再查看</p>
<h2 id="Windbg的联机调试方法"><a href="#Windbg的联机调试方法" class="headerlink" title="Windbg的联机调试方法"></a>Windbg的联机调试方法</h2><p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debug-universal-drivers---step-by-step-lab--echo-kernel-mode-">Debug Windows drivers step-by-step lab (echo kernel mode)</a></p>
]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windows驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Driver -- 通过IDA逆向分析.sys</title>
    <url>/2024/08/30/Windows%20Driver%20--%20%E9%80%9A%E8%BF%87IDA%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.sys/</url>
    <content><![CDATA[<h1 id="Windows-Driver-–-通过IDA逆向分析-sys"><a href="#Windows-Driver-–-通过IDA逆向分析-sys" class="headerlink" title="Windows Driver – 通过IDA逆向分析.sys"></a>Windows Driver – 通过IDA逆向分析.sys</h1><p>背景：因业务需要规划下一代PCIe SD host的Windows驱动，要支持Win11和以后的最新特性，因为现有的SD驱动是基于Storport-miniport架构，在Win11上有诸多限制严重影响业务，因此决定转型为WDF驱动。本文浅显分析Realtek的Win11 PCIe SD Card reader驱动是用什么架构，内部如何实现。</p>
<h2 id="IDA反汇编工具"><a href="#IDA反汇编工具" class="headerlink" title="IDA反汇编工具"></a>IDA反汇编工具</h2><p>IDA能将二进制文件反汇编(disassemble)成为汇编代码，还支持将汇编代码进一步显示成C代码(decompile)。</p>
<p>下载IDA free版本就够用</p>
<p><a href="https://hex-rays.com/products/ida/support/%20download_freeware%20/">https://hex-rays.com/products/ida/support/%20download_freeware%20/</a></p>
<h2 id="IDA分析驱动-sys文件"><a href="#IDA分析驱动-sys文件" class="headerlink" title="IDA分析驱动.sys文件"></a>IDA分析驱动.sys文件</h2><h3 id="IDA常用快捷键"><a href="#IDA常用快捷键" class="headerlink" title="IDA常用快捷键"></a>IDA常用快捷键</h3><p>F5：汇编代码转C代码显示（IDA称为伪代码，因为不是纯C）</p>
<p>Shift + F12：显示所有符号的字符串。可以全览所有函数，弄清用的什么技术栈</p>
<p>x：查看函数和变量的交叉引用，即被谁调用</p>
<p>esc：返回上个页面位置</p>
<h3 id="驱动分析示例"><a href="#驱动分析示例" class="headerlink" title="驱动分析示例"></a>驱动分析示例</h3><h4 id="RtsPer-sys下载"><a href="#RtsPer-sys下载" class="headerlink" title="RtsPer.sys下载"></a>RtsPer.sys下载</h4><p><a href="https://www.driverscloud.com/en/services/GetInformationDriver/75616-0/realtek-cardreader-win10-win11-1002262121361zip">https://www.driverscloud.com/en/services/GetInformationDriver/75616-0/realtek-cardreader-win10-win11-1002262121361zip</a></p>
<h4 id="INF分析"><a href="#INF分析" class="headerlink" title="INF分析"></a>INF分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Version]</span><br><span class="line">Signature=&quot;$Windows NT$&quot;</span><br><span class="line">Class=MTD</span><br><span class="line">ClassGuid = &#123;4d36e970-e325-11ce-bfc1-08002be10318&#125;</span><br><span class="line">Provider=%RTS%</span><br><span class="line">CatalogFile = RtsPer64.cat</span><br><span class="line">DriverVer=11/14/2022,10.0.22621.21361</span><br><span class="line"></span><br><span class="line">... 以下以Rts5227CR为例</span><br><span class="line"></span><br><span class="line">[DestinationDirs]</span><br><span class="line">CopyFilesSYS = 12     ; should it be 10 to take care of 98 stuff</span><br><span class="line">CopyFilesDLL = 11     ; %SystemRoot%\system or system32 - 98 or Win2000</span><br><span class="line">CopyFilesDLL64 = 10,SysWOW64</span><br><span class="line"></span><br><span class="line">[Manufacturer]</span><br><span class="line">%VENDOR%=Vendor, NTamd64</span><br><span class="line"></span><br><span class="line">[Vendor.NTamd64]</span><br><span class="line">%Rts5227CR%=RTS5264.Inst, PCI\VEN_10EC&amp;DEV_5264&amp;CC_FF00</span><br><span class="line"></span><br><span class="line">[RTS5264.Inst.ntamd64]</span><br><span class="line">CopyFiles = CopyFilesSYS, CopyFilesDLL64</span><br><span class="line"></span><br><span class="line">[RTS5264.Inst.NTamd64.HW]</span><br><span class="line">AddReg=MsiEnable_addreg</span><br><span class="line"></span><br><span class="line">[RTS5264.Inst.ntamd64.Services]</span><br><span class="line">AddService = RTSPER, 0x00000002, RTS5264_Service_Inst</span><br><span class="line"></span><br><span class="line">[RTS5264_Service_Inst]</span><br><span class="line">DisplayName    = %Rts5227PER%</span><br><span class="line">ServiceType    = %SERVICE_KERNEL_DRIVER%</span><br><span class="line">StartType      = %SERVICE_DEMAND_START%</span><br><span class="line">ErrorControl   = %SERVICE_ERROR_IGNORE%</span><br><span class="line">ServiceBinary  = %12%\RtsPer.sys</span><br><span class="line">AddReg         = RTS5264.AddReg</span><br><span class="line"></span><br><span class="line">[RTS5264.AddReg]</span><br><span class="line">HKR,&quot;RTS5264&quot;,&quot;MSIEnable&quot;,0x10001,1</span><br><span class="line">HKR,&quot;RTS5264&quot;,&quot;FirstLoad&quot;,0x10001,1</span><br><span class="line">HKR,&quot;RTS5264&quot;,&quot;NonRemovable&quot;,0x10001,1</span><br><span class="line">HKR,&quot;RTS5264&quot;,&quot;SupportPoFx&quot;,0x10001,1</span><br><span class="line">HKR,&quot;Parameters&quot;,&quot;DmaRemappingCompatible&quot;,0x10001,1</span><br><span class="line"></span><br><span class="line">[Strings]</span><br><span class="line">;Localizable Strings needed for HBA naming in Windows UI</span><br><span class="line">;*******************************************</span><br><span class="line">;Non-Localizable strings</span><br><span class="line">RTS = &quot;Realtek Semiconductor Corp.&quot;</span><br><span class="line">VENDOR         = &quot;Realtek Semiconductor Corp.&quot;</span><br><span class="line">Rts5227CR      = &quot;Realtek PCIE CardReader&quot;</span><br><span class="line">Rts5227PER      = &quot;Realtek PCIE Card Reader - PER&quot;</span><br><span class="line">DiskDesc = &quot;Realtek PCIE Card Reader Source Disk&quot;</span><br><span class="line">DriverVersion = &quot;10.0.22621.21361&quot;</span><br><span class="line">SERVICE_ASSOCSERVICE = 0x00000002</span><br><span class="line">SERVICE_BOOT_START     = 0x0</span><br><span class="line">SERVICE_SYSTEM_START   = 0x1</span><br><span class="line">SERVICE_AUTO_START     = 0x2</span><br><span class="line">SERVICE_DEMAND_START   = 0x3</span><br><span class="line">SERVICE_DISABLED       = 0x4</span><br><span class="line">SERVICE_KERNEL_DRIVER  = 0x1</span><br><span class="line">SERVICE_ERROR_IGNORE   = 0x0</span><br><span class="line">SERVICE_ERROR_NORMAL   = 0x1</span><br><span class="line">SERVICE_ERROR_SEVERE   = 0x2</span><br><span class="line">SERVICE_ERROR_CRITICAL = 0x3</span><br><span class="line">REG_EXPAND_SZ          = 0x00020000</span><br><span class="line">REG_DWORD              = 0x00010001</span><br><span class="line">REG_MULTI_SZ           = 0x00010000</span><br><span class="line">REG_BINARY             = 0x00000001</span><br><span class="line">REG_SZ                 = 0x00000000</span><br></pre></td></tr></table></figure>

<p>设备类型是MTD：<strong>Memory Technology Driver</strong></p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/system-defined-device-setup-classes-available-to-vendors">https://learn.microsoft.com/en-us/windows-hardware/drivers/install/system-defined-device-setup-classes-available-to-vendors</a></p>
<p>从INF可以推测：</p>
<p>（1）这是SD host设备的驱动，直连PCIe接口（没通过USB），作用是SD card的控制器。</p>
<p>（2）没有用WDF(KMDF)框架，因为KMDF的INF一般定义KmdfService字段，以上INF没有定义。</p>
<p>（3）结合Windows Driver Sample，MTD类属于SD BUS&#x2F;Device的设备驱动，但微软的SD框架不支持SD BUS只支持SD Device，因此该驱动应该是用WDM写的SD BUS驱动，不是依赖于微软的SD BUS框架。</p>
<p>INF详细WDK 文档：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/looking-at-an-inf-file">https://learn.microsoft.com/en-us/windows-hardware/drivers/install/looking-at-an-inf-file</a></p>
<h4 id="sys分析"><a href="#sys分析" class="headerlink" title=".sys分析"></a>.sys分析</h4><ol>
<li><p>IDA打开.sys (有pdb文件更好)，找到DriverEntry入口</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408161541633.png" alt="image-20240816154137481"></p>
</li>
<li><p>F5显示成C伪代码，可以双击函数跳转</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408161542515.png" alt="image-20240816154235494"></p>
</li>
<li><p>详细分析一下Driver Entry做了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_1400DEE88(_QWORD *a1) //DriverEntry主功能在这里实现，所有叫sub_xxx函数都是没有符号表解析不出名字的函数，看函数体即可.</span><br><span class="line">&#123;</span><br><span class="line">  __int64 CurrentThreadId; // rax</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  __int64 v4; // rcx</span><br><span class="line">  __int64 v5; // rax</span><br><span class="line">  __int64 v7; // [rsp+30h] [rbp-148h]</span><br><span class="line">  struct _OSVERSIONINFOW VersionInformation; // [rsp+40h] [rbp-138h] BYREF</span><br><span class="line"></span><br><span class="line">  CurrentThreadId = PsGetCurrentThreadId(); //获取当前线程ID</span><br><span class="line">  sub_1400DE608( //根据函数体，这里只是个打印函数，打印当前时间和线程ID.</span><br><span class="line">    2LL,</span><br><span class="line">    &quot;%I64d (%d) %s : -&gt; DriverEntry built on %s at %s \n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    CurrentThreadId,</span><br><span class="line">    &quot;DriverEntry&quot;,</span><br><span class="line">    &quot;Nov 14 2022&quot;,</span><br><span class="line">    &quot;15:12:36&quot;);</span><br><span class="line">  v3 = PsGetCurrentThreadId();</span><br><span class="line">  sub_1400DE608(</span><br><span class="line">    2LL,</span><br><span class="line">    &quot;%I64d (%d) %s : -&gt; DriverEntry Driver version : %s \n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    v3,</span><br><span class="line">    &quot;DriverEntry&quot;,</span><br><span class="line">    &quot;10.0.22621.21361&quot;);</span><br><span class="line">  VersionInformation.dwOSVersionInfoSize = 276;</span><br><span class="line">  if ( RtlGetVersion(&amp;VersionInformation) &gt;= 0 //获取操作系统版本</span><br><span class="line">    &amp;&amp; (VersionInformation.dwMajorVersion &gt; 6</span><br><span class="line">     || VersionInformation.dwMajorVersion == 6 &amp;&amp; VersionInformation.dwMinorVersion &gt;= 2) )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_140140110 = 512;</span><br><span class="line">    dword_140140114 = 0x40000000;</span><br><span class="line">  &#125;</span><br><span class="line">  qword_140140278 = MEMORY[0xFFFFF78000000008];</span><br><span class="line">  sub_1400DEC80();</span><br><span class="line">  sub_1400109EC();</span><br><span class="line">  a1[28] = sub_140003340; //sub_xxx都是函数，所以这里是注册很多回调，根据WDM开发一般是PNP回调</span><br><span class="line">  a1[29] = sub_1400057A0;</span><br><span class="line">  a1[36] = sub_1400EFA30;</span><br><span class="line">  a1[13] = sub_1400E0670;</span><br><span class="line">  v4 = a1[6];</span><br><span class="line">  a1[41] = sub_1400E5480;</span><br><span class="line">  a1[14] = sub_140003000;</span><br><span class="line">  a1[16] = sub_140002DC0;</span><br><span class="line">  a1[32] = sub_140002910;</span><br><span class="line">  a1[30] = sub_140008B40;</span><br><span class="line">  a1[37] = sub_1401071C0;</span><br><span class="line">  a1[18] = sub_140006EA0;</span><br><span class="line">  a1[17] = sub_140006EA0;</span><br><span class="line">  *(_QWORD *)(v4 + 8) = sub_1400DF0F0;</span><br><span class="line">  sub_1400011E4();</span><br><span class="line">  sub_1400E0188();</span><br><span class="line">  v5 = PsGetCurrentThreadId();</span><br><span class="line">  LODWORD(v7) = 0;</span><br><span class="line">  sub_1400DE608(</span><br><span class="line">    0x2000LL,</span><br><span class="line">    &quot;%I64d (%d) %s : &lt;- %s, ret = 0x%x\n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    v5,</span><br><span class="line">    &quot;DriverEntry&quot;,</span><br><span class="line">    &quot;DriverEntry&quot;,</span><br><span class="line">    v7);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体看一下注册的回调函数的内容：在函数上按x找到所有引用，再F5查看C伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_1400057A0(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; // rdi</span><br><span class="line">  __int64 CurrentThreadId; // rax</span><br><span class="line">  unsigned int v5; // ebx</span><br><span class="line">  __int64 v6; // rax</span><br><span class="line">  int v8; // [rsp+30h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v2 = *(_QWORD *)(a1 + 64);</span><br><span class="line">  if ( *(_BYTE *)v2 != 1 )</span><br><span class="line">    return sub_1400058A0();</span><br><span class="line">  CurrentThreadId = PsGetCurrentThreadId();</span><br><span class="line">  sub_1400DE608(</span><br><span class="line">    0x2000,</span><br><span class="line">    &quot;%I64d (%d) %s : -&gt; %s\n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    CurrentThreadId,</span><br><span class="line">    &quot;rts_internalctrl&quot;,</span><br><span class="line">    &quot;rts_internalctrl&quot;);</span><br><span class="line">  ++*(_BYTE *)(a2 + 67);</span><br><span class="line">  *(_QWORD *)(a2 + 184) += 72LL;</span><br><span class="line">  </span><br><span class="line">  //注意这个IofCallDriver，用于转发IRP给设备的driver function.</span><br><span class="line">  //可以推测DriverEntry注册的那些回调函数就是注册PNP请求列表对应的处理函数</span><br><span class="line">  //这里仅转发，真正的处理逻辑还在下层函数</span><br><span class="line">  v5 = IofCallDriver(*(_QWORD *)(v2 + 16), a2);</span><br><span class="line">  v6 = PsGetCurrentThreadId();</span><br><span class="line">  v8 = v5;</span><br><span class="line">  sub_1400DE608(</span><br><span class="line">    0x2000,</span><br><span class="line">    &quot;%I64d (%d) %s : &lt;- %s, ret = 0x%x\n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    v6,</span><br><span class="line">    &quot;rts_internalctrl&quot;,</span><br><span class="line">    &quot;rts_internalctrl&quot;,</span><br><span class="line">    v8);</span><br><span class="line">  return v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PNP的回调函数参考：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/dispatchpnp-routines">https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/dispatchpnp-routines</a></p>
</li>
<li><p>全览.sys有哪些函数符号</p>
<p>用shift + F12打开strings页面，ctrl+F 搜索关键词，选中结果后删除搜索框去浏览上下文。</p>
<p>   以DriverEntry为例，符号字符上下文如下，符号的地址分布是连续的，不考虑跳转可视为调用顺序。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000014012A550	0000000C	C	DriverEntry //入口</span><br><span class="line">.text:000000014012A560	00000033	C	%I64d (%d) %s : -&gt; DriverEntry built on %s at %s \n</span><br><span class="line">.text:000000014012A5A0	00000035	C	%I64d (%d) %s : -&gt; DriverEntry Driver version : %s \n</span><br><span class="line">.text:000000014012A5E0	0000000B	C	rts_unload</span><br><span class="line">.text:000000014012A5F0	00000031	C	%I64d (%d) %s : -&gt; Driver Unload, version : %s \n</span><br><span class="line">.text:000000014012A630	00000031	C	%I64d (%d) %s : &lt;- Driver Unload, version : %s \n</span><br><span class="line">.text:000000014012A670	0000000E	C	rts_adddevice</span><br><span class="line">.text:000000014012A6C0	00000031	C	%I64d (%d) %s : Failed to create device object \n</span><br><span class="line">.text:000000014012A700	00000031	C	%I64d (%d) %s : fdx is 0x%p, PAGE_SIZE is 0x%x \n</span><br><span class="line">.text:000000014012A740	00000035	C	%I64d (%d) %s : IoAttachDeviceToDeviceStack failed \n</span><br><span class="line"></span><br><span class="line">//操作系统判断，为了后面差异化配置</span><br><span class="line"></span><br><span class="line">.text:000000014012A780	0000001E	C	%I64d (%d) %s : OS is Win10 \n</span><br><span class="line">.text:000000014012A7A0	00000020	C	%I64d (%d) %s : OS is WinBlue \n</span><br><span class="line">.text:000000014012A7C0	0000001D	C	%I64d (%d) %s : OS is Win8 \n</span><br><span class="line">.text:000000014012A7E0	0000001D	C	%I64d (%d) %s : OS is Win7 \n</span><br><span class="line">.text:000000014012A800	00000024	C	%I64d (%d) %s : OS is Server 2008 \n</span><br><span class="line">.text:000000014012A830	0000001E	C	%I64d (%d) %s : OS is VISTA \n</span><br><span class="line">.text:000000014012A850	00000024	C	%I64d (%d) %s : OS is Server 2003 \n</span><br><span class="line">.text:000000014012A880	0000001E	C	%I64d (%d) %s : OS is WinXp \n</span><br><span class="line">.text:000000014012A8A0	0000001E	C	%I64d (%d) %s : OS is Win2k \n</span><br><span class="line">.text:000000014012A8C0	00000023	C	%I64d (%d) %s : OS is NotDefined \n</span><br><span class="line">.text:000000014012A8F0	0000001E	C	%I64d (%d) %s : OS is 64bit \n</span><br><span class="line">.text:000000014012A910	0000003A	C	%I64d (%d) %s : rts_pcie_init_bus_interface failed (%x) \n</span><br><span class="line">.text:000000014012A950	00000035	C	%I64d (%d) %s : rts_pcie_get_dev_info failed: 0x%x \n</span><br><span class="line">.text:000000014012A990	0000003B	C	%I64d (%d) %s : IoRegisterDeviceInterface failed with %x \n</span><br><span class="line">.text:000000014012A9D0	00000032	C	%I64d (%d) %s : GetMcfgEntryFromAuxKlib success \n</span><br><span class="line">.text:000000014012AA10	00000031	C	%I64d (%d) %s : GetMcfgEntryFromAuxKlib failed \n</span><br><span class="line">.text:000000014012AA50	0000002E	C	%I64d (%d) %s : GetMcfgEntryFromReg success \n</span><br><span class="line">.text:000000014012AA80	0000002D	C	%I64d (%d) %s : GetMcfgEntryFromReg failed \n</span><br><span class="line">.text:000000014012AAB0	00000027	C	%I64d (%d) %s : host_cfg_disable: %d \n</span><br><span class="line">.text:000000014012AAE0	00000034	C	%I64d (%d) %s : bMcfgEntry %d, BaseAddr is 0x%llx \n</span><br><span class="line"></span><br><span class="line">//初始化DPC，PDO; Rts自定义的PNP/POFX回调函数也初始化（估计是绑定到函数指针数组）</span><br><span class="line"></span><br><span class="line">.text:000000014012AB20	00000041	C	%I64d (%d) %s : initialize the DPC NoSSDpcWorkItemPendingEvent \n</span><br><span class="line">.text:000000014012AB70	00000039	C	%I64d (%d) %s : IoRegisterShutdownNotification success \n</span><br><span class="line">.text:000000014012ABB0	0000003B	C	%I64d (%d) %s : IoRegisterShutdownNotification fail 0x%x \n</span><br><span class="line">.text:000000014012ABF0	00000015	C	rts_create_child_pdo</span><br><span class="line">.text:000000014012AC10	0000005A	C	%I64d (%d) %s : Create Pdo %i successfully, status is 0x%x, Child-&gt;ReferenceCount is %i \n</span><br><span class="line">.text:000000014012AC70	00000035	C	%I64d (%d) %s : Create Pdo %i fail with status 0x%x\n</span><br><span class="line">.text:000000014012ACE0	00000017	C	rts_init_pofx_routines</span><br><span class="line">.text:000000014012AD00	0000002D	C	%I64d (%d) %s : pPoFxActivateComponent=0x%p\n</span><br><span class="line">.text:000000014012AD60	00000029	C	%I64d (%d) %s : pPoFxIdleComponent=0x%p\n</span><br><span class="line">.text:000000014012ADC0	0000002C	C	%I64d (%d) %s : pPoFxSetComponentWake=0x%p\n</span><br><span class="line">.text:000000014012AE20	0000002D	C	%I64d (%d) %s : pPoFxCompleteIdleState=0x%p\n</span><br><span class="line">.text:000000014012AE90	00000031	C	%I64d (%d) %s : pPoFxCompleteIdleCondition=0x%p\n</span><br><span class="line">.text:000000014012AF10	00000031	C	%I64d (%d) %s : pPoFxReportDevicePoweredOn=0x%p\n</span><br><span class="line">.text:000000014012AFA0	0000003A	C	%I64d (%d) %s : pPoFxCompleteDevicePowerNotRequired=0x%p\n</span><br><span class="line">.text:000000014012B010	0000002A	C	%I64d (%d) %s : pPoFxRegisterDevice=0x%p\n</span><br><span class="line">.text:000000014012B070	0000002C	C	%I64d (%d) %s : pPoFxUnregisterDevice=0x%p\n</span><br><span class="line">.text:000000014012B0E0	00000036	C	%I64d (%d) %s : pPoFxStartDevicePowerManagement=0x%p\n</span><br><span class="line">.text:000000014012B160	00000035	C	%I64d (%d) %s : pPoFxCompleteDirectedPowerDown=0x%p\n</span><br><span class="line"></span><br><span class="line">//从注册表拿到用户自定义的功能配置信息</span><br><span class="line"></span><br><span class="line">.text:000000014012B1B0	00000014	C	GetMcfgEntryFromReg</span><br><span class="line">.text:000000014012B220	00000028	C	%s : Get SubKey %ws, Update Key to %ws\n</span><br><span class="line">.text:000000014012B250	0000003F	C	%I64d (%d) %s : EnumOneSubValue return %d, pMcfgSdtTabke 0x%x\n</span><br><span class="line">.text:000000014012B290	00000023	C	%I64d (%d) %s : NULL == pMcfgAddr\n</span><br><span class="line">.text:000000014012B2C0	00000018	C	GetMcfgEntryFromAuxKlib</span><br><span class="line">.text:000000014012B2E0	00000030	C	%I64d (%d) %s : Enum firmware table return %#x\n</span><br><span class="line">.text:000000014012B310	00000041	C	%I64d (%d) %s : AuxKlibEnumerateSystemFirmwareTables return %#x\n</span><br><span class="line">.text:000000014012B360	00000023	C	%I64d (%d) %s : cannot find MCFG \n</span><br><span class="line">.text:000000014012B390	0000002C	C	%I64d (%d) %s : Get MCFG Table as follow: \n</span><br><span class="line">.text:000000014012B3C0	00000031	C	%I64d (%d) %s : Allocate for MCFG table failed \n</span><br><span class="line">.text:000000014012B400	0000000E	C	EnumOneSubKey</span><br><span class="line">.text:000000014012B410	00000029	C	%s : Open register key %ws failed, 0x%x\n</span><br><span class="line">.text:000000014012B440	00000010	C	EnumOneSubValue</span><br><span class="line">.text:000000014012B450	00000026	C	%I64d (%d) %s : Allocate pfi failed \n</span><br><span class="line">.text:000000014012B480	00000027	C	%I64d (%d) %s : Allocate pvfi failed \n</span><br><span class="line">.text:000000014012B4B0	00000024	C	%I64d (%d) %s : DataLength is 0x%x\n</span><br><span class="line">.text:000000014012B4E0	0000000E	C	ParseSdtTable</span><br><span class="line">.text:000000014012B4F0	0000002F	C	%I64d (%d) %s : Check physical address %#llx \n</span><br><span class="line">.text:000000014012B520	0000002D	C	%I64d (%d) %s : Check physical address %#x \n</span><br><span class="line"></span><br><span class="line">//从PCIe bridge拿到SD host设备信息，包括能力寄存器，电源ASPM等</span><br><span class="line"></span><br><span class="line">.text:000000014012B550	00000018	C	rts_get_pci_bridge_info</span><br><span class="line">.text:000000014012B570	00000048	C	%I64d (%d) %s : Single Function Device: bus = %#x, dev = %#x, func=%#x\n</span><br><span class="line">.text:000000014012B5C0	0000003C	C	%I64d (%d) %s : Find Device(%X:%X)  bus=%d dev=%d, func=%d\n</span><br><span class="line">.text:000000014012B600	00000031	C	%I64d (%d) %s : Save host configure space 0x%p \n</span><br><span class="line">.text:000000014012B640	00000033	C	%I64d (%d) %s : Cannot Find PciBridge for Device \n</span><br><span class="line">.text:000000014012B680	0000001B	C	rts_get_dev_link_ctl_field</span><br><span class="line">.text:000000014012B6A0	00000039	C	%I64d (%d) %s : Get PCI_COMMON_CONFIG fail, ulResult=%d\n</span><br><span class="line">.text:000000014012B6E0	00000033	C	%I64d (%d) %s : Get linkCtrlReg fail, ulResult=%d\n</span><br><span class="line">.text:000000014012B720	00000022	C	%I64d (%d) %s : linkCtrlReg 0x%x\n</span><br><span class="line">.text:000000014012B750	00000022	C	rts_get_bridge_link_control_field</span><br><span class="line">.text:000000014012B780	0000002E	C	%I64d (%d) %s : fail to find PCIe Capability\n</span><br><span class="line">.text:000000014012B7B0	0000003B	C	%I64d (%d) %s : CapabilityOffset - Config from MMCFG 0x%x\n</span><br><span class="line">.text:000000014012B7F0	00000038	C	%I64d (%d) %s : CapabilityOffset - Config from IO 0x%x\n</span><br><span class="line">.text:000000014012B830	00000038	C	%I64d (%d) %s : CapabilityHdr - Config from MMCFG 0x%x\n</span><br><span class="line">.text:000000014012B870	00000035	C	%I64d (%d) %s : CapabilityHdr - Config from IO 0x%x\n</span><br><span class="line">.text:000000014012B8B0	00000036	C	%I64d (%d) %s : LinkCtrlReg - Config from MMCFG 0x%x\n</span><br><span class="line">.text:000000014012B8F0	00000033	C	%I64d (%d) %s : LinkCtrlReg - Config from IO 0x%x\n</span><br><span class="line">.text:000000014012B930	00000048	C	%I64d (%d) %s : pciBridgePCIeHdrOffset 0x%x, pciBridgeLinkCtrlReg 0x%x\n</span><br><span class="line">.text:000000014012B980	0000002D	C	%I64d (%d) %s : Cannot Find PCIe Capability\n</span><br><span class="line">.text:000000014012B9B0	00000038	C	%I64d (%d) %s : cannot find the Bus of PCI,do nothing \n</span><br><span class="line">.text:000000014012B9F0	00000023	C	%I64d (%d) %s : MapPhyMem failed \n</span><br><span class="line">.text:000000014012BA20	0000005F	C	%I64d (%d) %s : PciBridge BusNumber[%x], DevNumbe[%x], FuncNumber[%x], Write reg[0x%x] = 0x%x\n</span><br><span class="line">.text:000000014012BA80	00000016	C	rts_disable_host_aspm</span><br><span class="line">.text:000000014012BAA0	0000004A	C	%I64d (%d) %s : recognize the Bus of PCI(Bridge) as UNKNOWN, do nothing \n</span><br><span class="line">.text:000000014012BAF0	0000001F	C	%I64d (%d) %s : PhyAddr 0x%x \n</span><br><span class="line">.text:000000014012BB10	0000002A	C	%I64d (%d) %s : Offset 0x%x, Value 0x%x \n</span><br><span class="line">.text:000000014012BB40	00000012	C	rts_set_host_aspm</span><br><span class="line">.text:000000014012BB60	0000002A	C	%I64d (%d) %s : Offset 0x%x, value 0x%x \n</span><br><span class="line">.text:000000014012BB90	00000012	C	rts_get_host_aspm</span><br><span class="line">.text:000000014012BBB0	0000001D	C	rts_pci_find_host_capability</span><br><span class="line">.text:000000014012BBD0	00000019	C	cr_read_host_config_byte</span><br><span class="line">.text:000000014012BBF0	0000001A	C	cr_write_host_config_byte</span><br><span class="line">.text:000000014012BC10	0000002F	C	%I64d (%d) %s : Write configure through MMIO \n</span><br><span class="line">.text:000000014012BC40	00000007	C	UNKNOW</span><br><span class="line"></span><br><span class="line">//以下是PNP的回调函数的注册（函数指针绑定），具体函数体实现在rts_pnp_fdo</span><br><span class="line"></span><br><span class="line">.text:000000014012BC70	00000011	C	DispatchPnP_Fdo </span><br><span class="line">.text:000000014012BC90	0000000C	C	rts_pnp_fdo</span><br><span class="line">.text:000000014012BCA0	0000001E	C	%I64d (%d) %s : -&gt; %s %s %s \n</span><br><span class="line">.text:000000014012BCC0	00000032	C	%I64d (%d) %s : rts_pnp_fdo: fdx DeviceState %i \n</span><br><span class="line">.text:000000014012BD00	00000052	C	%I64d (%d) %s : IRP_MN_REMOVE_DEVICE, NotStarted == fdx-&gt;DeviceState, do nothing\n</span><br><span class="line">.text:000000014012BD60	0000002D	C	%I64d (%d) %s : Removed == fdx-&gt;DeviceState\n</span><br><span class="line">.text:000000014012BD90	00000028	C	%I64d (%d) %s : call rts_ss_cancel_ss \n</span><br><span class="line">.text:000000014012BDD0	0000004F	C	%I64d (%d) %s : MSI not enable,IRP_MN_FILTER_RESOURCE_REQUIREMENTS to default\n</span><br><span class="line">.text:000000014012BE20	00000035	C	%I64d (%d) %s : Unprocessed pnp,to default process \n</span><br><span class="line">.text:000000014012BE60	00000011	C	DispatchPnP_Pdo </span><br><span class="line">.text:000000014012BE80	0000000C	C	rts_pnp_pdo</span><br><span class="line">.text:000000014012BE90	00000061	C	%I64d (%d) %s : NULL == Fdo, not IRP_MN_REMOVE_DEVICE,so return fail with STATUS_DELETE_PENDING\n</span><br><span class="line">.text:000000014012BF00	00000037	C	%I64d (%d) %s : Removed == fdx-&gt;DeviceState, so quit \n</span><br><span class="line">.text:000000014012BF40	00000027	C	%I64d (%d) %s : NULL == fdx, so quit \n</span><br><span class="line">.text:000000014012BF70	0000001F	C	%I64d (%d) %s : BusRelations \n</span><br><span class="line">.text:000000014012BF90	00000024	C	%I64d (%d) %s : EjectionRelations \n</span><br><span class="line">.text:000000014012BFC0	00000021	C	%I64d (%d) %s : PowerRelations \n</span><br><span class="line">.text:000000014012BFF0	00000023	C	%I64d (%d) %s : RemovalRelations \n</span><br><span class="line">.text:000000014012C020	00000027	C	%I64d (%d) %s : TargetDeviceRelation \n</span><br><span class="line">.text:000000014012C050	00000097	C	%I64d (%d) %s : deviceCapabilities-&gt;Removable is %i,deviceCapabilities-&gt;SurpriseRemovalOK is %i,deviceCapabilities-&gt;UniqueID is %i, ntStatus is 0x%x \n</span><br><span class="line">.text:000000014012C0F0	00000017	C	rts_tr_pcie_option_set</span><br><span class="line">.text:000000014012C110	00000024	C	%I64d (%d) %s : sd_capability=%#x \n</span><br><span class="line">.text:000000014012C140	00000023	C	%I64d (%d) %s : card_spt_map=%#x \n</span><br><span class="line">.text:000000014012C170	0000002D	C	%I64d (%d) %s : cr-&gt;option.dev_flags = %#x \n</span><br><span class="line">.text:000000014012C1A0	0000002F	C	%I64d (%d) %s : cr-&gt;option.patch_flags = %#x \n</span><br><span class="line"></span><br><span class="line">//以下是设备资源分配（xxx_alloc）和硬件寄存器值初始化（bios_setting/init_hw），由于是PCIe的SD host设备，主要分配SD host设备空间到PCIe bar地址</span><br><span class="line"></span><br><span class="line">.text:000000014012C1D0	00000045	C	%I64d (%d) %s : DriverFirstLoad, set delink_delay_max_cnt to %d ms \n</span><br><span class="line">.text:000000014012C220	00000026	C	%I64d (%d) %s : Clar firstload flag \n</span><br><span class="line">.text:000000014012C250	00000036	C	%I64d (%d) %s : fdx-&gt;cr-&gt;option.remote_wakeup_en=%#x\n</span><br><span class="line">.text:000000014012C290	00000038	C	%I64d (%d) %s : fdx-&gt;CurrentPara-&gt;remote_wakeup_en=%#x\n</span><br><span class="line">.text:000000014012C2D0	00000036	C	%I64d (%d) %s : fdx-&gt;cr-&gt;option.host_cfg_disable=%#x\n</span><br><span class="line">.text:000000014012C310	00000020	C	rts_tr_pcie_backup_bios_setting</span><br><span class="line">.text:000000014012C330	00000015	C	rts_cr_bind_together</span><br><span class="line">.text:000000014012C350	0000002F	C	%I64d (%d) %s : cr=%p, cm =%p, tr=%p, scsi=%p\n</span><br><span class="line">.text:000000014012C380	00000033	C	%I64d (%d) %s : cr-&gt;cm=%p, cr-&gt;tr=%p, cr-&gt;scsi=%p\n</span><br><span class="line">.text:000000014012C3C0	00000033	C	%I64d (%d) %s : cm-&gt;cr=%p, cm-&gt;tr=%p, scsi-&gt;cr=%p\n</span><br><span class="line">.text:000000014012C400	0000000B	C	scsi_alloc</span><br><span class="line">.text:000000014012C410	0000002E	C	%I64d (%d) %s : Unable to allocate the scsi \n</span><br><span class="line">.text:000000014012C440	0000000D	C	scsi_release</span><br><span class="line">.text:000000014012C450	0000001B	C	rts_option_set_bef_init_hw</span><br><span class="line">.text:000000014012C470	00000059	C	%I64d (%d) %s : read config addr 0x0E to judge multi function fail, bytesread(%i) != 1 \n</span><br><span class="line">.text:000000014012C4D0	00000036	C	%I64d (%d) %s : read config addr 0x0E success(0x%x) \n</span><br><span class="line">.text:000000014012C510	00000006	C	multi</span><br><span class="line">.text:000000014012C520	00000007	C	single</span><br><span class="line">.text:000000014012C530	00000029	C	%I64d (%d) %s : Device is %s-functioned\n</span><br><span class="line">.text:000000014012C560	0000002F	C	%I64d (%d) %s : fdx-&gt;cr-&gt;option.adma_mode %d \n</span><br><span class="line">.text:000000014012C590	0000001D	C	rts_option_set_after_init_hw</span><br><span class="line">.text:000000014012C5B0	0000002C	C	%I64d (%d) %s : option.cq_rand_enable = %d\n</span><br><span class="line">.text:000000014012C5E0	0000002B	C	%I64d (%d) %s : option.cq_seq_enable = %d\n</span><br><span class="line">.text:000000014012C610	00000030	C	%I64d (%d) %s : option.cq_ban_card_enable = %d\n</span><br><span class="line">.text:000000014012C640	00000020	C	Realtek PCIE Card Reader Driver</span><br><span class="line">.text:000000014012C660	00000011	C	rts_cr_init_comm</span><br><span class="line">.text:000000014012C680	0000001E	C	%I64d (%d) %s : %s detected \n</span><br><span class="line">.text:000000014012C6A0	00000023	C	%I64d (%d) %s : option-&gt;ss_en %d \n</span><br><span class="line">.text:000000014012C6D0	00000013	C	rts_cr_uninit_comm</span><br><span class="line"></span><br><span class="line">//以下是电源管理POFX的回调函数的注册（函数指针绑定），具体实现在rts_pofx/dfx</span><br><span class="line"></span><br><span class="line">.text:000000014012C6F0	00000018	C	ActiveConditionCallback</span><br><span class="line">.text:000000014012C710	0000003A	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx ActiveConditionCallback\n</span><br><span class="line">.text:000000014012C750	0000003A	C	%I64d (%d) %s : ===&gt;&lt;=== &lt;- PoFx ActiveConditionCallback\n</span><br><span class="line"></span><br><span class="line">.text:000000014012C790	00000016	C	IdleConditionCallback</span><br><span class="line">.text:000000014012C7B0	00000038	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx IdleConditionCallback\n</span><br><span class="line">.text:000000014012C7F0	00000038	C	%I64d (%d) %s : ===&gt;&lt;=== &lt;- PoFx IdleConditionCallback\n</span><br><span class="line">.text:000000014012C830	00000012	C	IdleStateCallback</span><br><span class="line">.text:000000014012C850	0000003E	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx IdleStateCallback, State=%d\n</span><br><span class="line">.text:000000014012C890	00000034	C	%I64d (%d) %s : ===&gt;&lt;=== &lt;- PoFx IdleStateCallback\n</span><br><span class="line"></span><br><span class="line">.text:000000014012C8D0	0000001C	C	DevicePowerRequiredCallback</span><br><span class="line">.text:000000014012C8F0	00000037	C	%I64d (%d) %s : ===&gt; PoFx DevicePowerRequiredCallback\n</span><br><span class="line">.text:000000014012C930	00000041	C	%I64d (%d) %s : PoFx DeviePowerRequiredCallback:queue work item\n</span><br><span class="line">.text:000000014012C980	00000053	C	%I64d (%d) %s : PoFx DeviePowerRequiredCallback:Cannot alloc memory for work item\n</span><br><span class="line">.text:000000014012C9E0	0000002A	C	%I64d (%d) %s :  fdx-&gt;PoFxActive = TRUE \n</span><br><span class="line">.text:000000014012CA10	0000003E	C	%I64d (%d) %s : ===&gt;&lt;=== &lt;- PoFx DevicePowerRequiredCallback\n</span><br><span class="line"></span><br><span class="line">.text:000000014012CA50	0000001F	C	DevicePowerNotRequiredCallback</span><br><span class="line">.text:000000014012CA70	0000003A	C	%I64d (%d) %s : ===&gt; PoFx DevicePowerNotRequiredCallback\n</span><br><span class="line">.text:000000014012CAB0	00000043	C	%I64d (%d) %s : ===&gt;&lt;=== PoFx pPoFxCompleteDevicePowerNotRequired\n</span><br><span class="line">.text:000000014012CB00	0000002B	C	%I64d (%d) %s :  fdx-&gt;PoFxActive = FALSE \n</span><br><span class="line">.text:000000014012CB30	0000003A	C	%I64d (%d) %s : &lt;=== PoFx DevicePowerNotRequiredCallback\n</span><br><span class="line"></span><br><span class="line">//以下是电源管理POFX的回调函数体实现，rts_xxx_pofx</span><br><span class="line"></span><br><span class="line">.text:000000014012CB70	00000025	C	rts_dev_pwr_completion_for_DFx_child</span><br><span class="line">.text:000000014012CBA0	0000004A	C	%I64d (%d) %s : powerContext-&gt;DeviceObject is 0x%p, DeviceObject is 0x%p\n</span><br><span class="line">.text:000000014012CBF0	00000027	C	%I64d (%d) %s : IoStatus-&gt;Status=%#x \n</span><br><span class="line"></span><br><span class="line">.text:000000014012CC20	0000001F	C	rts_dev_pwr_completion_for_DFx</span><br><span class="line">.text:000000014012CC40	00000079	C	%I64d (%d) %s : powerContext-&gt;DeviceObject is 0x%p, DeviceObject is 0x%p,deviceExtension-&gt;PhysicalDeviceObject is 0x%p \n</span><br><span class="line">.text:000000014012CCC0	00000030	C	%I64d (%d) %s : For power up, queue work item \n</span><br><span class="line">.text:000000014012CCF0	00000041	C	%I64d (%d) %s : For power up, cannot alloc memory for work item\n</span><br><span class="line">.text:000000014012CD40	00000038	C	%I64d (%d) %s : ===&gt;&lt;=== PoFxCompleteDirectedPowerDown\n</span><br><span class="line">.text:000000014012CD80	0000002D	C	%I64d (%d) %s : Set Power Failed, resume IO\n</span><br><span class="line"></span><br><span class="line">.text:000000014012CDB0	00000018	C	DirectedPowerUpCallback</span><br><span class="line">.text:000000014012CDD0	0000003A	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx DirectedPowerUpCallback\n</span><br><span class="line">.text:000000014012CE10	0000003A	C	%I64d (%d) %s : Failed to alloc memory for powerContext \n</span><br><span class="line">.text:000000014012CE50	0000003E	C	%I64d (%d) %s : DirectedPowerUpCallback SetPower to D0 fail \n</span><br><span class="line"></span><br><span class="line">.text:000000014012CE90	0000001A	C	DirectedPowerDownCallback</span><br><span class="line">.text:000000014012CEB0	0000003C	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx DirectedPowerDownCallback\n</span><br><span class="line">.text:000000014012CEF0	0000002E	C	%I64d (%d) %s : Set enter_rtd3 to 1 for DFx \n</span><br><span class="line">.text:000000014012CF20	00000040	C	%I64d (%d) %s : DirectedPowerDownCallback SetPower to D3 fail \n</span><br><span class="line"></span><br><span class="line">.text:000000014012CF60	00000012	C	rts_register_pofx</span><br><span class="line">.text:000000014012CF80	00000035	C	%I64d (%d) %s : supportPoFx=0, do not register PoFx\n</span><br><span class="line">.text:000000014012CFC0	00000033	C	%I64d (%d) %s : ===&gt;&lt;=== PoFx already registered!\n</span><br><span class="line">.text:000000014012D000	00000042	C	%I64d (%d) %s : ===&gt;&lt;=== Invalid PoFx routines, pls check again!\n</span><br><span class="line">.text:000000014012D050	00000037	C	%I64d (%d) %s : ===&gt;&lt;=== OS Ver: size %d, %d.%d.%d.%d\n</span><br><span class="line">.text:000000014012D090	00000033	C	%I64d (%d) %s : ===&gt;&lt;=== Register PO_FX_DEVICE_V3\n</span><br><span class="line">.text:000000014012D0D0	00000033	C	%I64d (%d) %s : ===&gt;&lt;=== Register PO_FX_DEVICE_V2\n</span><br><span class="line">.text:000000014012D110	00000038	C	%I64d (%d) %s : ===&gt;&lt;=== PoFxRegisterDevice return %#x\n</span><br><span class="line"></span><br><span class="line">.text:000000014012D150	00000014	C	rts_unregister_pofx</span><br><span class="line">.text:000000014012D170	0000002F	C	%I64d (%d) %s : ===&gt;&lt;=== PoFxUnregisterDevice\n</span><br><span class="line">.text:000000014012D1A0	00000020	C	rts_pnp_fdo_start_dev_delaywork</span><br><span class="line">.text:000000014012D1C0	0000002E	C	%I64d (%d) %s : rts_create_childen_pdos fail\n</span><br><span class="line">.text:000000014012D1F0	00000039	C	%I64d (%d) %s : Start after stop,so no need create pdos\n</span><br><span class="line">.text:000000014012D230	00000039	C	%I64d (%d) %s : IoSetDeviceInterfaceState:enable:failed\n</span><br><span class="line">.text:000000014012D270	00000039	C	%I64d (%d) %s : ===&gt;&lt;=== PoFxStartDevicePowerManagement\n</span><br><span class="line"></span><br><span class="line">//以下是PNP回调的函数体实现，rts_pnp_fdo_xxx</span><br><span class="line"></span><br><span class="line">//对应PNP: IRP_MN_START_DEVICE</span><br><span class="line">.text:000000014012D3E0	00000016	C	rts_pnp_fdo_start_dev</span><br><span class="line">.text:000000014012D400	0000001C	C	rts_pnp_fdo_cancel_stop_dev</span><br><span class="line">.text:000000014012D420	0000002F	C	%I64d (%d) %s : Cancel stop after query stop \n</span><br><span class="line">.text:000000014012D450	00000073	C	%I64d (%d) %s : spurious cancel-stop without query stop first,we still pass it down,Irp-&gt;IoStatus.Status is 0x%x \n</span><br><span class="line"></span><br><span class="line">//对应PNP: IRP_MN_WAIT_WAKE?</span><br><span class="line">.text:000000014012D4D0	00000019	C	rts_pnp_wait_d0_complete</span><br><span class="line">.text:000000014012D4F0	0000003F	C	%I64d (%d) %s : 0 == fdx-&gt;CancelSSIsCalling, return directly \n</span><br><span class="line">.text:000000014012D530	00000037	C	%I64d (%d) %s : Wait cancel ss finished for the %ith \n</span><br><span class="line"></span><br><span class="line">//对应PNP: IRP_MN_STOP_DEVICE</span><br><span class="line">.text:000000014012D570	00000015	C	rts_pnp_fdo_stop_dev</span><br><span class="line">.text:000000014012D590	00000044	C	%I64d (%d) %s : KeWaitForSingleObject NoSSDpcWorkItemPendingEvent \n</span><br><span class="line">.text:000000014012D5E0	0000003B	C	%I64d (%d) %s : IoSetDeviceInterfaceState::disable:failed\n</span><br><span class="line"></span><br><span class="line">.... //略</span><br></pre></td></tr></table></figure>

<p>Import页面查看导入的符号，都是WDM （NTOS kernel）的符号链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Address	Ordinal	Name	Library</span><br><span class="line">			</span><br><span class="line">cng			</span><br><span class="line">0000000140138010		BCryptSetProperty	cng</span><br><span class="line">0000000140138018		BCryptCloseAlgorithmProvider	cng</span><br><span class="line">0000000140138020		BCryptGenerateSymmetricKey	cng</span><br><span class="line">0000000140138028		BCryptGenerateKeyPair	cng</span><br><span class="line">0000000140138030		BCryptEncrypt	cng</span><br><span class="line">0000000140138038		BCryptExportKey	cng</span><br><span class="line">0000000140138040		BCryptGetProperty	cng</span><br><span class="line">0000000140138048		BCryptFinalizeKeyPair	cng</span><br><span class="line">0000000140138050		BCryptDestroyKey	cng</span><br><span class="line">0000000140138058		BCryptDestroySecret	cng</span><br><span class="line">0000000140138060		BCryptSecretAgreement	cng</span><br><span class="line">0000000140138068		BCryptDeriveKey	cng</span><br><span class="line">0000000140138070		BCryptGenRandom	cng</span><br><span class="line">0000000140138078		BCryptImportKeyPair	cng</span><br><span class="line">0000000140138080		BCryptOpenAlgorithmProvider	cng</span><br><span class="line"></span><br><span class="line">ntoskrnl			</span><br><span class="line">0000000140138090		KeReadStateEvent	ntoskrnl</span><br><span class="line">0000000140138098		KeReleaseSemaphore	ntoskrnl</span><br><span class="line">00000001401380A0		KeWaitForMultipleObjects	ntoskrnl</span><br><span class="line">00000001401380A8		KeWaitForSingleObject	ntoskrnl</span><br><span class="line">00000001401380B0		ExAllocatePoolWithTag	ntoskrnl</span><br><span class="line">00000001401380B8		ExRaiseStatus	ntoskrnl</span><br><span class="line">00000001401380C0		ProbeForWrite	ntoskrnl</span><br><span class="line">00000001401380C8		MmProbeAndLockPages	ntoskrnl</span><br><span class="line">00000001401380D0		MmMapLockedPagesSpecifyCache	ntoskrnl</span><br><span class="line">00000001401380D8		IoAllocateMdl	ntoskrnl</span><br><span class="line">00000001401380E0		IofCallDriver	ntoskrnl</span><br><span class="line">00000001401380E8		IofCompleteRequest	ntoskrnl</span><br><span class="line">00000001401380F0		IoFreeMdl	ntoskrnl</span><br><span class="line">00000001401380F8		IoIs32bitProcess	ntoskrnl</span><br><span class="line">0000000140138100		IoCsqInsertIrp	ntoskrnl</span><br><span class="line">0000000140138108		IoCsqRemoveNextIrp	ntoskrnl</span><br><span class="line">0000000140138110		__C_specific_handler	ntoskrnl</span><br><span class="line">0000000140138118		wcscat_s	ntoskrnl</span><br><span class="line">0000000140138120		wcscpy_s	ntoskrnl</span><br><span class="line">0000000140138128		wcsncpy_s	ntoskrnl</span><br><span class="line">0000000140138130		RtlInitAnsiString	ntoskrnl</span><br><span class="line">0000000140138138		RtlInitUnicodeString	ntoskrnl</span><br><span class="line">0000000140138140		RtlQueryRegistryValues	ntoskrnl</span><br><span class="line">0000000140138148		MmGetSystemRoutineAddress	ntoskrnl</span><br><span class="line">0000000140138150		RtlAnsiStringToUnicodeString	ntoskrnl</span><br><span class="line">0000000140138158		RtlFreeUnicodeString	ntoskrnl</span><br><span class="line">0000000140138160		RtlCompareMemory	ntoskrnl</span><br><span class="line">0000000140138168		KeInsertQueueDpc	ntoskrnl</span><br><span class="line">0000000140138170		KeSetEvent	ntoskrnl</span><br><span class="line">0000000140138178		KeDelayExecutionThread	ntoskrnl</span><br><span class="line">0000000140138180		KeAcquireSpinLockRaiseToDpc	ntoskrnl</span><br><span class="line">0000000140138188		KeReleaseSpinLock	ntoskrnl</span><br><span class="line">0000000140138190		ExFreePoolWithTag	ntoskrnl</span><br><span class="line">0000000140138198		MmBuildMdlForNonPagedPool	ntoskrnl</span><br><span class="line">00000001401381A0		IoDeleteDevice	ntoskrnl</span><br><span class="line">00000001401381A8		IoAllocateWorkItem	ntoskrnl</span><br><span class="line">00000001401381B0		IoFreeWorkItem	ntoskrnl</span><br><span class="line">00000001401381B8		IoQueueWorkItem	ntoskrnl</span><br><span class="line">00000001401381C0		IoInvalidateDeviceRelations	ntoskrnl</span><br><span class="line">00000001401381C8		IoOpenDeviceRegistryKey	ntoskrnl</span><br><span class="line">00000001401381D0		ObReferenceObjectByHandle	ntoskrnl</span><br><span class="line">00000001401381D8		ObfDereferenceObject	ntoskrnl</span><br><span class="line">00000001401381E0		ZwCreateFile	ntoskrnl</span><br><span class="line">00000001401381E8		ZwClose	ntoskrnl</span><br><span class="line">00000001401381F0		ZwCreateKey	ntoskrnl</span><br><span class="line">00000001401381F8		ZwOpenKey	ntoskrnl</span><br><span class="line">0000000140138200		ZwDeleteKey	ntoskrnl</span><br><span class="line">0000000140138208		ZwEnumerateKey	ntoskrnl</span><br><span class="line">0000000140138210		ZwFlushKey	ntoskrnl</span><br><span class="line">0000000140138218		ZwQueryKey	ntoskrnl</span><br><span class="line">0000000140138220		ZwQueryValueKey	ntoskrnl</span><br><span class="line">0000000140138228		ZwSetValueKey	ntoskrnl</span><br><span class="line">0000000140138230		ZwPowerInformation	ntoskrnl</span><br><span class="line">0000000140138238		ObQueryNameString	ntoskrnl</span><br><span class="line">0000000140138240		swprintf_s	ntoskrnl</span><br><span class="line">0000000140138248		strncpy_s	ntoskrnl</span><br><span class="line">0000000140138250		DbgPrint	ntoskrnl</span><br><span class="line">0000000140138258		PsGetCurrentThreadId	ntoskrnl</span><br><span class="line">0000000140138260		KfRaiseIrql	ntoskrnl</span><br><span class="line">0000000140138268		IoBuildPartialMdl	ntoskrnl</span><br><span class="line">0000000140138270		RtlGetVersion	ntoskrnl</span><br><span class="line">0000000140138278		RtlIsNtDdiVersionAvailable	ntoskrnl</span><br><span class="line">0000000140138280		KeInitializeDpc	ntoskrnl</span><br><span class="line">0000000140138288		KeInitializeEvent	ntoskrnl</span><br><span class="line">0000000140138290		KeInitializeSemaphore	ntoskrnl</span><br><span class="line">0000000140138298		KeInitializeTimerEx	ntoskrnl</span><br><span class="line">00000001401382A0		IoAttachDeviceToDeviceStack	ntoskrnl</span><br><span class="line">00000001401382A8		IoDetachDevice	ntoskrnl</span><br><span class="line">00000001401382B0		IoRegisterShutdownNotification	ntoskrnl</span><br><span class="line">00000001401382B8		IoCsqInitialize	ntoskrnl</span><br><span class="line">00000001401382C0		IoRegisterDeviceInterface	ntoskrnl</span><br><span class="line">00000001401382C8		ExFreePool	ntoskrnl</span><br><span class="line">00000001401382D0		MmMapIoSpace	ntoskrnl</span><br><span class="line">00000001401382D8		MmUnmapIoSpace	ntoskrnl</span><br><span class="line">00000001401382E0		ZwEnumerateValueKey	ntoskrnl</span><br><span class="line">00000001401382E8		KeCancelTimer	ntoskrnl</span><br><span class="line">00000001401382F0		IoBuildDeviceIoControlRequest	ntoskrnl</span><br><span class="line">00000001401382F8		IoDisconnectInterrupt	ntoskrnl</span><br><span class="line">0000000140138300		IoGetAttachedDeviceReference	ntoskrnl</span><br><span class="line">0000000140138308		IoUnregisterShutdownNotification	ntoskrnl</span><br><span class="line">0000000140138310		IoSetDeviceInterfaceState	ntoskrnl</span><br><span class="line">0000000140138318		PoRequestPowerIrp	ntoskrnl</span><br><span class="line">0000000140138320		PoSetPowerState	ntoskrnl</span><br><span class="line">0000000140138328		ObfReferenceObject	ntoskrnl</span><br><span class="line">0000000140138330		ExUuidCreate	ntoskrnl</span><br><span class="line">0000000140138338		KeSetTimerEx	ntoskrnl</span><br><span class="line">0000000140138340		IoCancelIrp	ntoskrnl</span><br><span class="line">0000000140138348		PoCallDriver	ntoskrnl</span><br><span class="line">0000000140138350		PoStartNextPowerIrp	ntoskrnl</span><br><span class="line">0000000140138358		PsCreateSystemThread	ntoskrnl</span><br><span class="line">0000000140138360		PsTerminateSystemThread	ntoskrnl</span><br><span class="line">0000000140138368		KeAcquireSpinLockAtDpcLevel	ntoskrnl</span><br><span class="line">0000000140138370		KeReleaseSpinLockFromDpcLevel	ntoskrnl</span><br><span class="line">0000000140138378		MmUnlockPages	ntoskrnl</span><br><span class="line">0000000140138380		MmAllocateContiguousMemory	ntoskrnl</span><br><span class="line">0000000140138388		MmFreeContiguousMemory	ntoskrnl</span><br><span class="line">0000000140138390		IoAllocateIrp	ntoskrnl</span><br><span class="line">0000000140138398		IoBuildSynchronousFsdRequest	ntoskrnl</span><br><span class="line">00000001401383A0		IoConnectInterrupt	ntoskrnl</span><br><span class="line">00000001401383A8		IoFreeIrp	ntoskrnl</span><br><span class="line">00000001401383B0		IoGetDmaAdapter	ntoskrnl</span><br><span class="line">00000001401383B8		IoGetDeviceProperty	ntoskrnl</span><br><span class="line">00000001401383C0		MmGetPhysicalAddress	ntoskrnl</span><br><span class="line">00000001401383C8		RtlUnicodeToMultiByteN	ntoskrnl</span><br><span class="line">00000001401383D0		KeClearEvent	ntoskrnl</span><br><span class="line">00000001401383D8		KeQueryActiveProcessors	ntoskrnl</span><br><span class="line">00000001401383E0		KeBugCheckEx	ntoskrnl</span><br><span class="line">00000001401383E8		ZwSetSecurityObject	ntoskrnl</span><br><span class="line">00000001401383F0		IoDeviceObjectType	ntoskrnl</span><br><span class="line">00000001401383F8		IoCreateDevice	ntoskrnl</span><br><span class="line">0000000140138400		ObOpenObjectByPointer	ntoskrnl</span><br><span class="line">0000000140138408		RtlGetDaclSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138410		RtlGetGroupSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138418		RtlGetOwnerSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138420		RtlGetSaclSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138428		SeCaptureSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138430		_snwprintf	ntoskrnl</span><br><span class="line">0000000140138438		RtlLengthSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138440		SeExports	ntoskrnl</span><br><span class="line">0000000140138448		RtlCreateSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138450		_wcsnicmp	ntoskrnl</span><br><span class="line">0000000140138458		wcschr	ntoskrnl</span><br><span class="line">0000000140138460		RtlAbsoluteToSelfRelativeSD	ntoskrnl</span><br><span class="line">0000000140138468		RtlAddAccessAllowedAce	ntoskrnl</span><br><span class="line">0000000140138470		RtlLengthSid	ntoskrnl</span><br><span class="line">0000000140138478		IoIsWdmVersionAvailable	ntoskrnl</span><br><span class="line">0000000140138480		RtlSetDaclSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138488		ExAllocatePoolWithQuotaTag	ntoskrnl</span><br><span class="line">0000000140138490		PsGetVersion	ntoskrnl</span><br><span class="line">0000000140138498		ZwQuerySystemInformation	ntoskrnl</span><br><span class="line">00000001401384A0		KeLowerIrql	ntoskrnl</span><br><span class="line"></span><br><span class="line">HAL			</span><br><span class="line">0000000140138000		KeStallExecutionProcessor	HAL</span><br></pre></td></tr></table></figure>

<p>结论：根据.sys的分析，此驱动是纯WDM实现的。因为内核接口全部调用WDM&#x2F;NT kernel接口， 完全没有调用微软的miniport框架例如Storport, SDHC，SDBUS框架封装后的接口。</p>
<p>但微软已不推荐WDM驱动开发，参考：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-wdm">Introduction to WDM</a> 。新驱动优先使用KMDF框架。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://voidsec.com/windows-drivers-reverse-engineering-methodology/#remote-kernel-debugging">https://voidsec.com/windows-drivers-reverse-engineering-methodology/#remote-kernel-debugging</a></p>
<p><a href="https://blog.csdn.net/qq_24481913/article/details/131643283">https://blog.csdn.net/qq_24481913/article/details/131643283</a></p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/">https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/</a></p>
]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windows驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Driver Model Architecture for SD Host projects</title>
    <url>/2024/08/30/Windows%20Driver%20Model%20Architecture%20for%20SD%20Host%20projects/</url>
    <content><![CDATA[<h1 id="Windows-Driver-Model-Architecture-for-SD-Host-projects"><a href="#Windows-Driver-Model-Architecture-for-SD-Host-projects" class="headerlink" title="Windows Driver Model Architecture for SD Host projects"></a>Windows Driver Model Architecture for SD Host projects</h1><h2 id="Driver-Pair-Model和Device-Driver-Interface-DDI-的概念"><a href="#Driver-Pair-Model和Device-Driver-Interface-DDI-的概念" class="headerlink" title="Driver Pair Model和Device Driver Interface(DDI)的概念"></a>Driver Pair Model和Device Driver Interface(DDI)的概念</h2><h3 id="Driver-Pair-Model"><a href="#Driver-Pair-Model" class="headerlink" title="Driver Pair Model"></a>Driver Pair Model</h3><p>Microsoft provides the general driver, and typically an independent hardware vendor provides the specific driver.</p>
<p>Driver Pair Model有两种不同层次的实现方式：</p>
<p>(1) Microsoft定义的某类设备的driver pair model: Microsoft实现XX device port driver + 设备厂商实现XX device miniport driver。这类driver pair model包括：</p>
<ul>
<li>(display miniport driver, display port driver)</li>
<li>(audio miniport driver, audio port driver)</li>
<li>(storage miniport driver, storage port driver)</li>
<li>(battery miniclass driver, battery class driver)</li>
<li>(HID minidriver, HID class driver)</li>
<li>(changer miniclass driver, changer port driver)</li>
<li>(NDIS miniport driver, NDIS library)</li>
</ul>
<p>Miniport Driver Pair Model：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs">https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs</a></p>
<p>(2) Microsoft定义的general driver pair model：Microsoft实现WDF框架 + 设备厂商实现KMDF(Kernel Mode WDF)驱动。</p>
<ul>
<li>The driver is split into two pieces: one that handles general processing and one that handles processing that is specific to a particular device.</li>
<li>The general piece, called the Framework, is written by Microsoft.</li>
<li>The specific piece, called the KMDF driver, may be written by Microsoft or an independent hardware vendor.</li>
</ul>
<p> KMDF as a generic driver pair model: <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/kmdf-as-a-generic-pair-model">https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/kmdf-as-a-generic-pair-model</a></p>
<h3 id="Device-Driver-Interface-DDI"><a href="#Device-Driver-Interface-DDI" class="headerlink" title="Device Driver Interface(DDI)"></a>Device Driver Interface(DDI)</h3><p>The DDI Compliance rules define requirements for the proper interaction between a driver and the kernel interface of the operating system</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-driver-verifier-rules">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-driver-verifier-rules</a></p>
<p>DDI相当于应用层的API规范，对于每种类型的Driver Pair Mode，都有对应的DDI要求：</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/rules-for-audio-drivers">Rules for Audio Drivers</a><br><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/rules-for-avstream-drivers">Rules for AVStream Drivers</a><br><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/sdv-rules-for-wdm-drivers">Rules for WDM Drivers</a><br><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/sdv-rules-for-kmdf-drivers">Rules for KMDF Drivers</a><br><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/sdv-rules-for-ndis-drivers">Rules for NDIS Drivers</a><br><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/sdv-rules-for-storport-drivers">Rules for Storport Drivers</a></p>
<p>重点对比以下KMDF（Kernel Mode WDF）的DDI和Storport的DDI：</p>
<p>KMDF DDI rules：只说明了一些WDF函数接口的调用条件和先后顺序要求，没有禁用任何WDF函数接口。</p>
<p>Storport DDI rules: 专门定义了禁用的WDM函数列表HwStorPortProhibitedDDIs: a list of WDM DDIs that should not be called in physical StorPort miniport drivers</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/ddi-usage-rule-set--storport-">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/ddi-usage-rule-set--storport-</a></p>
<h3 id="几个关键问题"><a href="#几个关键问题" class="headerlink" title="几个关键问题"></a>几个关键问题</h3><p>（1）Driver Pair Model和Dirver接口函数DDI是什么关系？</p>
<p>Driver Pair Model是Diver接口函数DDI的集合，独立的功能例如创建设备，处理中断，处理IO请求，这些都是Diver接口函数去实现；这些Diver接口函数的集合使用分层设计（部分是Microsoft实现，部分是设备厂商实现）就是Driver Pair Model。</p>
<p>举个例子：Storport-miniport的Driver Pair Model中，默认使用WDM DDI去实现port driver部分和miniport driver部分。</p>
<p>（2）为什么Storport Driver Pair Model会禁用很多WDM接口函数(WDM DDI)，尤其是从Win11开始？</p>
<p>原因：微软定义的Storport driver pair model本身也是基于WDM和WDF函数(DDI)上实现，即用WDM或者WDF Model去实现Storage设备（例如SCSI, NVMe）的数据结构和特殊流程函数，封装成Storport的DDI。而微软的Driver开发趋势是弃用WDM逐步过渡到WDF，因此Storport为了适配Win11系统，可能有很多Storport DDI用WDF DDI重写了，因此Storport禁用了设备厂商去直接调用很多WDM DDI，避免造成同一个功能用WDM和WDF都去实现了而产生冲突。</p>
<h2 id="SD-host的Driver-Model选型"><a href="#SD-host的Driver-Model选型" class="headerlink" title="SD host的Driver Model选型"></a>SD host的Driver Model选型</h2><h3 id="支持SD-host驱动开发的Driver-Model"><a href="#支持SD-host驱动开发的Driver-Model" class="headerlink" title="支持SD host驱动开发的Driver Model"></a>支持SD host驱动开发的Driver Model</h3><p>对于SD设备生态可用的Driver Pair Model有：</p>
<ul>
<li><p>KMDF Framework + KMDF driver：通用框架，任意厂商可用KMDF去实现任意类型设备的host&#x2F;slave驱动；微软也在KMDF去升级已有的特定设备框架，例如微软定义的usbport驱动框架：USB 1.0&#x2F;2.0使用WDM（usbport.sys），USB 3.0使用WDF（Wdf01000.sys）</p>
</li>
<li><p>Storport + storage miniport：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/storport-miniport-drivers">https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/storport-miniport-drivers</a></p>
<p>这个Driver Model支持厂商实现SD host驱动，但其数据和流程定义很多是针对SCSI&#x2F;NVMe等大容量Disk设备，对于SD host&#x2F;device没有专门的定义；此外Storport从Win11开始禁用了很多WDM DDI，代码开发限制多。</p>
</li>
<li><p>sdport + sdhci-miniport：<a href="https://learn.microsoft.com/en-us/samples/microsoft/windows-driver-samples/standard-sd-host-controller-miniport/">https://learn.microsoft.com/en-us/samples/microsoft/windows-driver-samples/standard-sd-host-controller-miniport/</a></p>
<p>实现SD protocol的port driver框架，支持厂商实现vendor SD host驱动，但API文档已停止维护, sample code有维护（win11）。</p>
</li>
<li><p>sdbus + sddisk: <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/sd/sd-card-driver-stack">https://learn.microsoft.com/en-us/windows-hardware/drivers/sd/sd-card-driver-stack</a></p>
<p>微软的Inbox SD驱动使用此框架；只支持SD&#x2F;SDIO device厂商去写device driver，不支持厂商实现SD host驱动。</p>
</li>
</ul>
<h3 id="微软的Driver-Model选型的参考文档"><a href="#微软的Driver-Model选型的参考文档" class="headerlink" title="微软的Driver Model选型的参考文档"></a>微软的Driver Model选型的参考文档</h3><p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/creating-a-new-driver">https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/creating-a-new-driver</a></p>
<p>其中分为两种选项：</p>
<p>（1）KMDF框架</p>
<p>（2）miniport框架</p>
<p>微软推荐miniport框架都用WDM DDI开发；不推荐miniport + WDF DDI的混合开发方式（尽管可行），参考：</p>
<p>If your device technology has a minidriver model, and you aren’t able to find a specific template for your type of minidriver, the Windows Driver Model (WDM) template is most likely going to be your starting point. Refer to your technology-specific documentation for guidance. In rare cases, you can use KMDF to write a minidriver, but usually the starting point is WDM.</p>
<p>微软开发论坛（OSR）也提出过storport的WDM不够灵活，又不能兼容WDF DDI的问题：</p>
<p><a href="https://www.osr.com/nt-insider/2014-issue4/win7-vs-win8-storport-miniports/">https://www.osr.com/nt-insider/2014-issue4/win7-vs-win8-storport-miniports/</a></p>
<p><a href="https://community.osr.com/t/wdfdeviceminiportcreate-and-virtual-storport/46617/8">https://community.osr.com/t/wdfdeviceminiportcreate-and-virtual-storport/46617/8</a></p>
<p>结论：KMDF框架是万能方案</p>
<h2 id="从Storport-miniport框架过渡到KMDF框架"><a href="#从Storport-miniport框架过渡到KMDF框架" class="headerlink" title="从Storport-miniport框架过渡到KMDF框架"></a>从Storport-miniport框架过渡到KMDF框架</h2><p>（1）问题：Storport-miniport框架一定能porting到KMDF框架吗？</p>
<p>参考：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/wdf/which-drivers-can-be-ported">https://learn.microsoft.com/en-us/windows-hardware/drivers/wdf/which-drivers-can-be-ported</a></p>
<p>Which WDM drivers can I port to WDF?</p>
<p>For some device types, system-supplied device class and port drivers provide driver dispatch functions and call a vendor-supplied miniport driver to handle specific I&#x2F;O details. These miniport drivers are essentially callback libraries and are not supported by WDF.</p>
<p>结论1：如果该Storage设备驱动依赖于Storport框架定义的流程，例如SCSI， NVMe设备依赖于Storport定义的SCSI和NVMe初始化和I&#x2F;O流程。那么就不能直接porting到WDF，因为WDF没有定义特定设备的请求流程。</p>
<p>结论2：对于SD设备，Storport框架本身就没有实现SD协议的初始化和I&#x2F;O流程。SD host设备的Storport-miniport驱动完全可以porting到WDF框架，<strong>唯一可能有问题的是SD disk相关的Storport请求对应WDF的哪些请求？移植到WDF必须要求SD host和Disk整个生态都能顺利过渡</strong>。</p>
<p>（2）问题：Storport代码如何porting到KMDF</p>
<p>主要工作是将Storport-miniport中的DDI函数，映射到KMDF的DDI函数。</p>
<p>Storport-miniport的DDI列表：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/storport-driver-support-routines">https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/storport-driver-support-routines</a></p>
<p>KMDF的DDI列表：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/_wdf/">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/_wdf/</a></p>
<p>基于此方法，后面两章分为两部分：</p>
<ul>
<li><p>Storport DDI在SD host miniport driver中的使用（第4章）：SD host miniport driver用到了哪些DDI，实现什么功能。</p>
</li>
<li><p>从Storport DDI到KMDF DDI（第5章）：SD host miniport driver用到的Storport DDI应该用哪些KMDF DDI去重写功能。</p>
</li>
</ul>
<h2 id="Storport-DDI在SD-host-miniport-driver中的使用"><a href="#Storport-DDI在SD-host-miniport-driver中的使用" class="headerlink" title="Storport DDI在SD host miniport driver中的使用"></a>Storport DDI在SD host miniport driver中的使用</h2><p>Storport DDI routine分为两大类：</p>
<p>（1）callback routine：是Storport定义函数形式，miniport实现函数内容</p>
<p>（2）normal routine：是Storport定义函数形式和内容，miniport只调用</p>
<table>
<thead>
<tr>
<th>Storport Callback Routine</th>
<th>sub-function parameter</th>
<th>Function Description</th>
<th>SD miniport driver’s implementation for this callback</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HwStorInitialize</strong></td>
<td><strong>HwStorPassiveInitializeRoutine</strong></td>
<td>The <strong>HwStorInitialize</strong> routine initializes the miniport driver after a system reboot or power failure occurs. It is called by StorPort after <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwStorFindAdapter</strong></a> successfully returns. <strong>HwStorInitialize</strong> initializes the HBA and finds all devices that are of interest to the miniport driver.<br/>The following responsibilities are shared between HwStorInitialize and HwStorPassiveInitializeRoutine:<br/>Initialize hardware for the HBA registers and buffers.<br/>Initialize and allocate all DeviceExtension fields.<br/>Set up and initialize all events and DPCs that are used by the miniport driver.<br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_initialize">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_initialize</a>  <br/> <br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_passive_initialize_routine">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_passive_initialize_routine</a></td>
<td>Support. <br/>HwStorPassiveInitializeRoutine中注册了Adapter的POFX数据（StorPortInitializePoFxPower）</td>
</tr>
<tr>
<td><strong>HwStorInterrupt</strong></td>
<td>N&#x2F;A</td>
<td>The Storport driver calls the <strong>HwStorInterrupt</strong> routine after the HBA generates an interrupt request. The <strong>HwStorInterrupt</strong> routine should return within 50 microseconds, ideally as short a time as possible. Therefore, all activity does not have to occur at high IRQL should be deferred to the [<strong>HwStorDpcRoutine</strong>]</td>
<td>Support. <br/>用于SD card的插拔卡中断和数据传输完成或错误中断的处理入口</td>
</tr>
<tr>
<td><strong>HwStorFindAdapter</strong></td>
<td><strong>PORT_CONFIGURATION_INFORMATION</strong> contains configuration information for a host bus adapter (HBA). <br/><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/storport/ns-storport-_port_configuration_information">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/storport/ns-storport-_port_configuration_information</a></td>
<td>The <strong>HwStorFindAdapter</strong> routine uses the supplied configuration to determine whether a specific HBA is supported and, if it is, to return configuration information about that adapter.<br/><br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter</a><br/><br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-_port_configuration_information">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-_port_configuration_information</a></td>
<td>Support. <br/>Main tasks:<br/>1. Zero the device extention<br/>2. Get the memory base, the vendor ID and the device ID<br/>3. Port Configuration Information initialization<br/>4. Driver used memory allocation<br/>5. Initialize the timer, tag queue, host capability, vendor register settings, host software structure<br/></td>
</tr>
<tr>
<td><strong>HwStorAdapterControl</strong></td>
<td><strong>SCSI_ADAPTER_CONTROL_TYPE</strong> <br/> <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ne-storport-scsi_adapter_control_type">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ne-storport-scsi_adapter_control_type</a></td>
<td>A miniport driver’s <strong>HwStorAdapterControl</strong> routine is called to perform synchronous operations to control the state or behavior of an adapter, such as stopping or restarting the host bus adapter (HBA) for power management. <br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_adapter_control">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_adapter_control</a></td>
<td>支持部分ControlTypes：<br/>ScsiQuerySupportedControlTypes, ScsiStopAdapter, ScsiRestartAdapter, ScsiSetBootConfig, ScsiSetRunningConfig, ScsiPowerSettingNotification, ScsiAdapterPoFxPowerActive, ScsiAdapterPower, ScsiAdapterPrepareForBusReScan, ScsiAdapterSystemPowerHints,</td>
</tr>
<tr>
<td></td>
<td>ScsiQuerySupportedControlTypes</td>
<td>Reports the adapter-control operations implemented by the miniport driver. A miniport must support this control type. Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-scsi_supported_control_type_list"><strong>SCSI_SUPPORTED_CONTROL_TYPE_LIST</strong></a> structure</td>
<td>support.</td>
</tr>
<tr>
<td></td>
<td>ScsiStopAdapter</td>
<td>Shuts down the HBA. A miniport must support this control type.</td>
<td>support. <br/>但什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiRestartAdapter</td>
<td>Reinitializes an HBA. A miniport must support this control type.</td>
<td>support. <br/>调用req_enter_d0()函数，做host reset &amp; init，然后判断卡在位，发起card-change event去处理Adapter Stop期间的card insert or card remove操作。</td>
</tr>
<tr>
<td></td>
<td>ScsiSetBootConfig</td>
<td>Restores any settings on an HBA that the BIOS might need to reboot. A miniport driver must implement <strong>ScsiSetBootConfig</strong> if it must call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportgetbusdata"><strong>StorPortGetBusData</strong></a> or <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportsetbusdatabyoffset"><strong>StorPortSetBusDataByOffset</strong></a> before the system will be able to reboot.</td>
<td>support. <br/>但什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiSetRunningConfig</td>
<td>Restores any settings on an HBA that the miniport driver might need to control the HBA while the system is running. A miniport driver must implement <strong>ScsiSetRunningConfig</strong> if it must call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportgetbusdata"><strong>StorPortGetBusData</strong></a> or <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportsetbusdatabyoffset"><strong>StorPortSetBusDataByOffset</strong></a> to restore the appropriate running configuration to the HBA before it can be restarted.</td>
<td>support. <br/>调用pcr_part_a_restore和pcr_part_b_restore函数去配置SD host PCR register的一些默认值</td>
</tr>
<tr>
<td></td>
<td>ScsiPowerSettingNotification</td>
<td>Notification for a registered power setting change. Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_power_setting_info"><strong>STOR_POWER_SETTING_INFO</strong></a> structure</td>
<td>support. <br/>但什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPower</td>
<td>Reports the adapter power on or power off states. Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_adapter_control_power"><strong>STOR_ADAPTER_CONTROL_POWER</strong></a> structure. 其中包括<strong>STOR_POWER_ACTION</strong>和<strong>STOR_DEVICE_POWER_STATE</strong> 两个子参数</td>
<td>support. <br/>实现STOR_DEVICE_POWER_STATE &#x3D; D0~D3和STOR_POWER_ACTION &#x3D; Sleep&#x2F;Hibernate&#x2F;Shutdown&#x2F;ShutdownReset&#x2F;ShutdownOff&#x2F;StorPowerActionNone的设备、系统的电源状态请求</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPoFxPowerRequired</td>
<td>Notifies the miniport whether power is required or not for the adapter component.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPoFxPowerActive</td>
<td>Notifies the miniport whether the adapter component is active or idle.using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_active_context"><strong>STOR_POFX_ACTIVE_CONTEXT</strong></a> structure</td>
<td>support<br/>只读了Storport下发的STOR_POFX_ACTIVE_CONTEXT，而没使用。相当于什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPoFxPowerSetFState</td>
<td>Notifies the miniport to set the adapter component to the given F-state. using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_fstate_context"><strong>STOR_POFX_FSTATE_CONTEXT</strong></a> structure</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPoFxPowerControl</td>
<td>Requests that the miniport execute a private power control operation that was initiated for the adapter by a power engine plug-in (PEP). using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_power_control"><strong>STOR_POFX_POWER_CONTROL</strong></a> structure.</td>
<td>support. <br/>但什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPrepareForBusReScan</td>
<td>Notifies the miniport to prepare the adapter for bus enumeration.</td>
<td>support. <br/>但什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterSystemPowerHints</td>
<td>Provides system power hints to the miniport. using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_system_power_hints"><strong>STOR_SYSTEM_POWER_HINTS</strong></a> structure</td>
<td>support. <br/>但什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterFilterResourceRequirements</td>
<td>Filters the required resources for the adapter. Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_filter_resource_requirements"><strong>STOR_FILTER_RESOURCE_REQUIREMENTS</strong></a> structure.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPoFxMaxOperationalPower</td>
<td>Communicates a maximum operational power value to the miniport. Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_max_operational_power"><strong>STOR_MAX_OPERATIONAL_POWER</strong></a> structure</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPoFxSetPerfState</td>
<td>Informs the miniport of the status of a P-State transition requested by a call to <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportpofxsetperfstate"><strong>StorPortPoFxSetPerfState</strong></a>. Using STOR_POFX_PERF_STATE_CONTEXT**](<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_perf_state_context">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_perf_state_context</a>) structure</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterSurpriseRemoval</td>
<td>Notifies the miniport that the unit has been surprise-removed.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterSerialNumber</td>
<td>Requests that the miniport retrieve the adapter’s serial number.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterQueryFruId</td>
<td>Available starting in Windows 10 version 21H1. Queries the ID of a fault replacement unit (FRU) of the adapter. Storport sends this control only if a miniport has also previously called <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportsetfeaturelist"><strong>StorPortSetFeatureList</strong></a> in its <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwFindAdapter</strong></a> routine with <strong>StorportFeatureFruIdAdapterControl</strong> specified.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterSetEventLogging</td>
<td>Available starting in Windows 10 version 21H1. Notifies the miniport about whether a specific event channel is enabled or disabled for an adapter. Storport sends this control only if a miniport has also previously called <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportsetfeaturelist"><strong>StorPortSetFeatureList</strong></a> in its <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwFindAdapter</strong></a> routine with <strong>StorportFeatureFruIdAdapterControl</strong> specified.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterResetBusSynchronous</td>
<td>Available starting in Windows 11, version 22H2. Storport sends this control during the handling of an IOCTL_STORAGE_DEVICE_RESET. The miniport driver should handle this control similar to what it does in its <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_reset_bus"><strong>HwResetBus</strong></a> callback routine. Storport sends this control only if a miniport has also previously called <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportsetfeaturelist"><strong>StorPortSetFeatureList</strong></a> in its <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwFindAdapter</strong></a> routine with <strong>StorportFeatureResetBusSynchronous</strong> specified.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiAdapterPreparePLDR</td>
<td>Storport sends this control to notify miniport to do necessary work before invoking PLDR. Available starting in Windows 11, version 24H2</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiNvmeofAdapterOperation</td>
<td>Indicates whether ScsiNvmeofAdapterOperation is supported. Available starting in Windows 11, version 24H2.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>HwStorStartIo</strong> and <strong>HwStorBuildIo</strong></td>
<td><strong>HwStorBuildIo</strong> and <strong>HwStorStartIo</strong> receive the following Srb function types:</td>
<td>The Storport driver calls the <strong>HwStorStartIo</strong> routine one time for each incoming I&#x2F;O request.<br/><strong>HwStorStartIo</strong> initiates an I&#x2F;O operation. StorPort is designed to use a miniport’s private data that is prepared in <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_buildio"><strong>HwStorBuildIo</strong></a> and stored in either <strong>DeviceExtension</strong> or <strong>Srb-&gt;SrbExtension</strong>. Because <strong>HwStorBuildIo</strong> is called without spin locks, the best driver performance is achieved by preparing as much data as possible in <strong>HwStorBuildIo</strong>. <br/><br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_startio">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_startio</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>The <strong>HwStorBuildIo</strong> routine processes the SRB with unsynchronized access to shared system data structures before passing it to <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_startio"><strong>HwStorStartIo</strong></a>.</td>
<td></td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_EXECUTE_SCSI</td>
<td>Sends a CDB to the specified bus&#x2F;target&#x2F;lun.</td>
<td>根据如下SCSI operation code分别处理：<br/>SCSIOP_TEST_UNIT_READY, SCSIOP_REQUEST_SENSE, SCSIOP_INQUIRY, SCSIOP_READ_CAPACITY, SCSIOP_READ, SCSIOP_WRITE, SCSIOP_MODE_SENSE, SCSIOP_VERIFY, SCSIOP_LOAD_UNLOAD, SCSIOP_MEDIUM_REMOVAL<br/>注：这部分代码有多存疑的地方，代码本身是从老的SCSI驱动移植过来，SD设备不属于SCSI disk类型，这些SCSI请求哪些应该在SD disk上用哪些不该用，没有微软文档说明</td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_IO_CONTROL</td>
<td>Miniport defined.</td>
<td>直接返回SRB_STATUS_SUCCESS</td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_RESET_LOGICAL_UNIT</td>
<td>Reset the specified logical unit (if the device is capable).</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_RESET_DEVICE</td>
<td>Reset the specified Scsi Target.</td>
<td></td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_RESET_BUS</td>
<td>Reset all of the targets on the specified SCSI bus.</td>
<td>直接返回SRB_STATUS_SUCCESS</td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_FLUSH</td>
<td>Instructs the miniport driver to flush all cached data.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_SHUTDOWN</td>
<td>Instructs the miniport driver to flush all cached data preparatory to shut down.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_DUMP_POINTERS</td>
<td>Supplies information needed for the miniport driver to support crash dump and hibernation. This request is sent to a Storport virtual miniport driver that is used to control the disk that holds the crash dump data. Starting with Windows 8, non-virtual miniport drivers can optionally receive this request.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_FREE_DUMP_POINTERS</td>
<td>Starting with Windows 8, this request is sent to the miniport to free resources allocated during the SRB_FUNCTION_DUMP_POINTERS request.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>SRB_FUNCTION_PNP</td>
<td><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/srb/ns-srb-_stor_device_capabilities_ex">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/srb/ns-srb-_stor_device_capabilities_ex</a></td>
<td>只处理STOR_DEVICE_CAPABILITIES_EX定义的StorQueryCapability请求类型去上报Removable，EjectSupported等能力<br/>The <strong>STOR_DEVICE_CAPABILITIES_EX</strong> structure reports device capabilities to the SCSI port driver in response to a capabilities query in a SCSI request block (SRB) with a function of SRB_FUNCTION_PNP<br/>注：此请求是否兼容Storport存疑，因为是作为SCSI port driver定义的结构</td>
</tr>
<tr>
<td><strong>HwStorResetBus</strong></td>
<td>N&#x2F;A</td>
<td>The <strong>HwStorResetBus</strong> routine is called by the port driver to clear error conditions.</td>
<td>support. <br/>其中实现card关电，host reset，cancel所有IO的操作</td>
</tr>
<tr>
<td><strong>HwStorUnitControl</strong></td>
<td><strong>SCSI_UNIT_CONTROL_TYPE</strong> enumeration contains unit control operations, where each control type initiates an action on a unit by the miniport driver. <br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ne-storport-scsi_unit_control_type">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ne-storport-scsi_unit_control_type</a></td>
<td>A miniport driver’s <strong>HwStorUnitControl</strong> routine is called to perform synchronous operations to control the state of storage unit device. <br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_unit_control">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_unit_control</a></td>
<td>Support.</td>
</tr>
<tr>
<td></td>
<td>ScsiQuerySupportedUnitControlTypes</td>
<td>Reports the unit-control operations implemented by the miniport driver. A miniport must support this control type.</td>
<td>Support ScsiQuerySupportedUnitControlTypes, ScsiUnitStart, ScsiUnitPower, ScsiUnitPoFxPowerInfo, ScsiUnitPoFxPowerActive, ScsiUnitPoFxPowerSetFState</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitUsage</td>
<td>Notifies the miniport whether the logical unit is used for any supported usage types.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitStart</td>
<td>Notifies the miniport to start a unit device.</td>
<td>support. 但实际什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitPower</td>
<td>Reports the unit power on or power off states.If the miniport supports this control type, it will not receive a storage request block with SRB_FUNCTION_POWER.</td>
<td>support. 但实际什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitPoFxPowerInfo</td>
<td>Notifies the miniport if idle power management is enabled or disabled on the unit component. The miniport should call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportinitializepofxpower"><strong>StorPortInitializePoFxPower</strong></a> within this unit control if idle power management was enabled and if it supports runtime power management for the unit device.</td>
<td>support. 对Disk注册了Pofx(StorPortInitializePoFxPower). <br/>注：这里合理性存疑：Host Driver需要给Disk注册Pofx吗？</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitPoFxPowerRequired</td>
<td>Notifies the miniport whether power is required for the unit component. Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_power_required_context"><strong>STOR_POFX_POWER_REQUIRED_CONTEXT</strong></a> structure</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitPoFxPowerActive</td>
<td>Notifies the miniport that the unit component is either active or idle. Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_active_context"><strong>STOR_POFX_ACTIVE_CONTEXT</strong></a> structure</td>
<td>support. 但实际什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitPoFxPowerSetFState</td>
<td>Notifies the miniport to set the unit component to the given functional power state (F-state). Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_fstate_context"><strong>STOR_POFX_FSTATE_CONTEXT</strong></a> structure</td>
<td>support. 但实际什么都没干</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitPoFxPowerControl</td>
<td>Requests that the miniport execute a private power control operation that was initiated for the unit by a power engine plug-in (PEP). Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_pofx_power_control"><strong>STOR_POFX_POWER_CONTROL</strong></a> structure</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitRemove</td>
<td>Notifies the miniport that the unit has been removed.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitSurpriseRemoval</td>
<td>Notifies the miniport that the unit has been surprise-removed.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitRichDescription</td>
<td>The miniport can choose to support this if the device reports a longer vendor ID, model number, or firmware revision than is defined in the SCSI spec</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitQueryBusType</td>
<td>Queries whether the miniport wants to specify a bus type for a given logical unit (LUN). Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-stor_unit_control_query_bus_type"><strong>STOR_UNIT_CONTROL_QUERY_BUS_TYPE</strong></a> structure. In Windows 10 version 21H1 and later, Storport sends this control only if a miniport has also previously called <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportsetfeaturelist"><strong>StorPortSetFeatureList</strong></a> in its <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwFindAdapter</strong></a> routine with <strong>StorportFeatureBusTypeUnitControl</strong> specified.</td>
<td>Not support</td>
</tr>
<tr>
<td></td>
<td>ScsiUnitQueryFruId</td>
<td>Queries the ID of a fault replacement unit (FRU). Available in Windows 10 version 21H1 and later.</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Storport Normal Routine that used by SD miniport driver.</th>
<th>Function Description</th>
<th>SD miniport driver’s purpose to use the routine</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>StorPortWaitForSingleObject</td>
<td>A miniport can call <strong>StorPortWaitForSingleObject</strong> function to put the current thread into a wait state until the given dispatcher object is set to signaled state or optionally times out. dispatcher object (event, mutex, semaphore, thread, or timer)<br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportwaitforsingleobject">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportwaitforsingleobject</a></td>
<td>用于Storport routine和miniport thread的同步：storport routine发起dispatcher object(event), miniport thread使用StorPortWaitForSingleObject等待event信号产生后进入处理流程此时开始占用CPU；如果没有event，miniport thread将sleep，不会占用CPU.</td>
</tr>
<tr>
<td>StorPortInitializeEvent</td>
<td><strong>StorPortInitializeEvent</strong> initializes an event object as a synchronization or notification type event, and sets it to a signaled or not-signaled state.<br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportinitializeevent">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportinitializeevent</a></td>
<td>初始化event事件对象，但不设置事件产生的信号。注意：如果没有初始化event就使用会产生空指针访问，系统会BSOD.</td>
</tr>
<tr>
<td>StorPortSetEvent</td>
<td>A miniport can call <strong>StorPortSetEvent</strong> to set an event object to the signaled state.<br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportsetevent">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportsetevent</a></td>
<td>设置事件产生的信号</td>
</tr>
<tr>
<td>StorPortInitializeDpc</td>
<td>The <strong>StorPortInitializeDpc</strong> routine initializes a StorPort DPC.<br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportinitializedpc">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportinitializedpc</a></td>
<td>创建DPC对象：用于在高IRQL的Storport routine(IRQL &gt;&#x3D;中断级别)中设置延迟处理任务，目的是减少CPU处在高IRQL的时间，将不紧急的任务放到低IRQL(IRQL &lt;&#x3D; DPC)执行。这是Driver设计的基本要求。</td>
</tr>
<tr>
<td>StorPortIssueDpc</td>
<td>The <strong>StorPortIssueDpc</strong> routine issues a deferred procedure call (DPC).<br/><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportissuedpc">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportissuedpc</a></td>
<td>发起DPC任务：将延迟处理的任务加到DPC队列</td>
</tr>
<tr>
<td>StorPortCancelDpc</td>
<td><strong>StorPortCancelDpc</strong> attempts to cancel the execution of a StorPort deferred procedure call (DPC).</td>
<td>销毁DPC对象：Driver卸载时清理资源</td>
</tr>
<tr>
<td>StorPortRequestTimer</td>
<td>Schedules a callback event for a Storport timer context object.</td>
<td>启动Timer：OS提供的定时器模块，miniport driver用于定时任务，例如设置指定disk idle时间后进入runtime D3.</td>
</tr>
<tr>
<td>StorPortFreeTimer</td>
<td>Frees a Storport timer context object previously created by the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportinitializetimer">StorPortInitializeTimer</a> routine.</td>
<td>销毁Timer：Driver卸载时清理资源</td>
</tr>
<tr>
<td>StorPortStallExecution</td>
<td>The <strong>StorPortStallExecution</strong> routine stalls the miniport driver. This call ties up a processor, doing no useful work while stalling in the driver. <br/> 参考：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/srb/nf-srb-scsiportstallexecution">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/srb/nf-srb-scsiportstallexecution</a></td>
<td>使当前storport routine忙等待：miniport driver用于卸载driver时，等待miniport thread退出；如果不等待miniport thread退出就完成storport卸载routine，miniport创建的thread将会在卸载后继续运行，应用层会卸载报错。</td>
</tr>
<tr>
<td>StorPortDelayExecution</td>
<td>The <strong>StorPortDelayExecution</strong> function delays the current thread by the given amount of time, in microseconds. If the current IRQL is lower than DISPATCH_LEVEL then the current thread is simply put in the wait state and other threads are allowed to run. Otherwise, this routine performs a busy-wait.</td>
<td>miniport driver用于将当前miniport thread放到Sleep状态，释放CPU的占用，使其它thread（不管是storport还是miniport）可以运行。</td>
</tr>
<tr>
<td>StorPortGetCurrentIrql</td>
<td><strong>StorPortGetCurrentIrql</strong> retrieves the current interrupt request level (IRQL).</td>
<td>miniport driver用于配合StorPortDelayExecution使用：如果当前IRQL高，Sleep实际是忙等.</td>
</tr>
<tr>
<td>StorPortAllocateRegistryBuffer</td>
<td>The <strong>StorPortAllocateRegistryBuffer</strong> routine is called by the miniport driver to allocate a buffer that can be used to read and write registry data.</td>
<td>以下几个Registry Routine都是Windows Registry的访问操作，INF里面配置的Registry默认值通过这些Registry Routine去写入注册表，Driver动态功能开关是通过Registry Routine去读取注册表</td>
</tr>
<tr>
<td>StorPortRegistryRead</td>
<td>The <strong>StorPortRegistryRead</strong> routine reads the registry data for the indicated device and value.</td>
<td></td>
</tr>
<tr>
<td>StorPortRegistryWrite</td>
<td>The <strong>StorPortRegistryWrite</strong> routine is called by the miniport driver to convert the registry data contained in a specified buffer from ASCII to Unicode and to then write the data to the miniport driver’s per-HBA storage area.</td>
<td></td>
</tr>
<tr>
<td>StorPortFreeRegistryBuffer</td>
<td>The <strong>StorPortFreeRegistryBuffer</strong> routine frees the buffer that was allocated for storing registry data.</td>
<td></td>
</tr>
<tr>
<td>StorPortNotification</td>
<td>The miniport driver uses the <strong>StorPortNotification</strong> routine to notify the Storport driver of certain events and conditions. <strong>StorPortNotification</strong> takes a variable number of parameters depending on the notification type specified. <br/>NotificationType：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportnotification">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nf-storport-storportnotification</a></td>
<td>miniport对storport的反向通知机制</td>
</tr>
<tr>
<td></td>
<td>BusChangeDetected: Indicates that a target device might have been added or removed from a dynamic bus.</td>
<td>miniport driver用于：当disk有插拔或者card模式切换，都会发BusChangeDetected去通知OS</td>
</tr>
<tr>
<td></td>
<td>RequestComplete: Indicates that the given SRB has finished. After this notification is sent, the port driver owns the request.</td>
<td>miniport driver用于返回Storport的每一个SRB请求，包括inquiry查询和i&#x2F;O读写等各类收到的SRB请求。</td>
</tr>
<tr>
<td></td>
<td>ResetDetected: Indicates that the HBA has detected a reset on the bus. After this notification is sent, the miniport driver is still responsible for completing any active requests. The port driver will manage all required bus-reset delays.</td>
<td>miniport driver没使用此notification类型</td>
</tr>
<tr>
<td></td>
<td>RequestTimerCall: Indicates that the miniport driver requires the port driver to call the miniport driver’s <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/nc-storport-hw_timer">HwStorTimer</a> routine in the requested number of microseconds.</td>
<td>miniport driver用于在Storport routine里面，将一部分任务放到指定时间后开始执行，相当于一种不精确的DPC.</td>
</tr>
<tr>
<td></td>
<td>IoTargetRequestServiceTime: Indicates to Storport the amount of time that was required to process a specified request.</td>
<td>miniport driver用于指定tagIO任务的完成时间，让Storport driver有个预期不要误判请求完成超时。</td>
</tr>
<tr>
<td>StorPortGetBusData</td>
<td>The <strong>StorPortGetBusData</strong> routine retrieves the bus-specific configuration information necessary to initialize the HBA.</td>
<td>miniport driver用于获取Bus(PCIe Bus)的数据，拿到SD host device在PCIe Bus的信息。例如VendorID，DeviceID，区分SD host类型。</td>
</tr>
<tr>
<td>StorPortGetUncachedExtension</td>
<td>The <strong>StorPortGetUncachedExtension</strong> routine allocates an uncached common buffer to be shared by the CPU and the device.</td>
<td>在HwStorFindAdapter Callback创建DMA Buffer时使用</td>
</tr>
<tr>
<td>StorPortGetPhysicalAddress</td>
<td>The <strong>StorPortGetPhysicalAddress</strong> routine converts a given virtual address range to a physical address range for a DMA operation.</td>
<td>在HwStorFindAdapter Callback创建DMA Buffer时使用</td>
</tr>
<tr>
<td>StorPortInitialize</td>
<td>The <strong>StorPortInitialize</strong> routine initializes the port driver parameters and extension data. <strong>StorPortInitialize</strong> also saves the adapter information provided from the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/storage-miniport-drivers">miniport driver</a> <strong>DriverEntry</strong> routine.</td>
<td>miniport driver将Storport指定的HW_INITIALIZATION_DATA全部初始化完成后调用，上报miniport的所有能力配置和回调函数。</td>
</tr>
<tr>
<td>StorPortReadRegisterBuffer</td>
<td>reads a value from a specified register address.</td>
<td>miniport driver用于register读（包括SD host register和PCIe Config register，register address由PCIe bar address + offset指定）</td>
</tr>
<tr>
<td>StorPortWriteRegisterBuffer</td>
<td>transfers a given number of unsigned bytes from a buffer to the HBA.</td>
<td>miniport driver用于register写（包括SD host register和PCIe Config register，register address由PCIe bar address + offset指定）</td>
</tr>
<tr>
<td>StorPortWritePort</td>
<td>transfers an unsigned byte to the HBA</td>
<td>miniport driver没有使用，只遗留历史代码</td>
</tr>
<tr>
<td>StorPortReadPort</td>
<td>reads a value from a specified port address</td>
<td>miniport driver没有使用，只遗留历史代码</td>
</tr>
<tr>
<td>StorPortInitializePoFxPower</td>
<td>A miniport driver calls <strong>StorPortInitializePoFxPower</strong> to register a storage device with the power management framework (PoFx). Using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/storport/ns-storport-_stor_pofx_device">STOR_POFX_DEVICE</a>, <strong>STOR_POFX_DEVICE_V2</strong>, or <strong>STOR_POFX_DEVICE_V3</strong></td>
<td>miniport driver用于注册Adapter和Disk Unit的pofx</td>
</tr>
<tr>
<td>StorPortPoFxIdleComponent</td>
<td>The <strong>StorPortPoFxIdleComponent</strong> routine decrements the activation reference count of a specified component of a storage device.</td>
<td>在remove card， auto power off时调用</td>
</tr>
<tr>
<td>StorPortPoFxActivateComponent</td>
<td>The <strong>StorPortPoFxActivateComponent</strong> routine increments the activation reference count on the specified component of a storage device.</td>
<td>在insert card调用</td>
</tr>
<tr>
<td>StorPortGetD3ColdSupport</td>
<td>Get D3Cold support or not by this HBA</td>
<td>StorPortInitializePoFxPower其中一个参数是D3Cold enable or not</td>
</tr>
<tr>
<td>StorPortGetDeviceObjects</td>
<td>Returns the device objects that are associated with the adapter device stack</td>
<td>处理PNP请求用到，根据SD host extension获取<em>AdapterDeviceObject</em>和<em>PhysicalDeviceObject</em>和LowerDeviceObject</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windows驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Hardware driver submission问题记录</title>
    <url>/2024/08/30/Windows%20Hardware%20driver%20submission%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Windows-Hardware-driver-submission问题记录"><a href="#Windows-Hardware-driver-submission问题记录" class="headerlink" title="Windows Hardware driver submission问题记录"></a>Windows Hardware driver submission问题记录</h1><h2 id="Driver-Update-failure-rejected-问题分析"><a href="#Driver-Update-failure-rejected-问题分析" class="headerlink" title="Driver Update failure (rejected) 问题分析"></a>Driver Update failure (rejected) 问题分析</h2><h3 id="背景描述："><a href="#背景描述：" class="headerlink" title="背景描述："></a>背景描述：</h3><p>V10700 + Hardware ID：PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_389517aa</p>
<p>在windows hardware driver submission被reject，提交单和关键信息如下：</p>
<p><a href="https://partner.microsoft.com/en-us/dashboard/hardware/driver/14391505706251263/submission/1152921505697924694/ShippingLabel/401531646">https://partner.microsoft.com/en-us/dashboard/hardware/driver/14391505706251263/submission/1152921505697924694/ShippingLabel/401531646</a></p>
<p>Rejection Theme: Measure Failure Rejection Reason: Systemic Measure Failure Provide Measure ID(s): 26387215 ADO bugId: 55312863: Bug ID(s) and Partner ID(s): Link to documentation: Link to reliability report (if applicable): Details: Rejected because Measure ID 26387215 (Percent of machines where the driver install process completes successfully) is failing. Please read more on “<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/pct-machines-where-driver-install-completes-successfully">https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/pct-machines-where-driver-install-completes-successfully</a>“ See the Plug and Play Extended Flight Report document for additional information on the failures. The “driver flight report” bug can be found by searching on Collaborate with the Submission ID. More info: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/pnp-failure-report">https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/pnp-failure-report</a> and <a href="https://docs.microsoft.com/en-us/collaborate/feedback-items-search#search">https://docs.microsoft.com/en-us/collaborate/feedback-items-search#search</a></p>
<h3 id="报告分析"><a href="#报告分析" class="headerlink" title="报告分析"></a>报告分析</h3><p>根据以上信息，在Microsoft partner center的feedback&#x2F;bugs页面找到提交单对应的failure报告：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031506203.png" alt="image-20250103150628028"></p>
<p>（1）RejectionReport中的关键信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031520135.png" alt="image-20250103152056064"></p>
<p>小结：微软测试了118个machine，其中在10台硬件平台ID PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA的机器上发生install failure. </p>
<p>错误码是ERROR_ACCESS_DENIED, 可能是微软环境问题或者硬件访问异常导致。</p>
<p>（2）report.html中的关键信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031513121.png" alt="image-20250103151330025"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031514877.png" alt="image-20250103151409828"></p>
<p>小结：Driver install failure基本都发生在硬件平台ID PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上，而且是不带Problem Code Description &amp; Problem Status 类型的安装错误，也就是说不是PNP error引起的install failure。</p>
<h3 id="Driver分析"><a href="#Driver分析" class="headerlink" title="Driver分析"></a>Driver分析</h3><p>为了确认此install error是driver相关还是硬件平台相关（PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA），做如下对比：</p>
<p>1.找到相同Driver installer V10700的其他提交单，和当前failure提交单的区别只在于支持的硬件平台ID不一样：</p>
<p><a href="https://partner.microsoft.com/en-us/dashboard/hardware/driver/14391505706251263">https://partner.microsoft.com/en-us/dashboard/hardware/driver/14391505706251263</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031536917.png" alt="image-20250103153612882"></p>
<p>2.两个提交单只有Hardware ID有区别，系统都是Win11 24H2：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031534126.png" alt="image-20250103153449036"></p>
<p>3.两个提交单的微软反馈报告的区别：一个pass，一个failure（failure install发生在Bad hardware ID上）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031538765.png" alt="image-20250103153815661"></p>
<p><a href="https://partner.microsoft.com/en-us/dashboard/collaborate/engagements/5133/feedback/wits/Bugs/1056149">https://partner.microsoft.com/en-us/dashboard/collaborate/engagements/5133/feedback/wits/Bugs/1056149</a></p>
<p><a href="https://partner.microsoft.com/en-us/dashboard/collaborate/engagements/5133/feedback/wits/Bugs/1069371">https://partner.microsoft.com/en-us/dashboard/collaborate/engagements/5133/feedback/wits/Bugs/1069371</a></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>分析小结：</strong></p>
<p>微软的自动化测试流程发现V10700 installer在平台PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上有install failure，超出了允许的failure rate（&lt;5%）,所以reject driver提交单。</p>
<p>根据Driver提交单对比分析，这不是Driver installer的问题，因为相同的driver在其他平台的提交单是100% pass，此问题只发生在平台PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上。</p>
<p><strong>Debug方向：</strong></p>
<p>不确定微软是如何在平台PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上测试此driver install，有可能是物理机器或者虚拟机器上测试，也就是说，不排除是微软软件环境问题引起。</p>
<p>另外一方面，如果是物理机器确实有此问题，建议检查平台PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上是否有特殊系统设置，或者PCIe bug，导致Bayhub SD Host硬件有时无法访问？</p>
<p><strong>当前解决办法：</strong></p>
<p>重新提交此driver，不需要做修改，以排除是微软软件环境引起的偶然性问题。</p>
]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windows驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Office常用操作笔记</title>
    <url>/2019/07/06/Windows%20Office%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h1><h2 id="Word设置自动推导的标题列表"><a href="#Word设置自动推导的标题列表" class="headerlink" title="Word设置自动推导的标题列表"></a>Word设置自动推导的标题列表</h2><p>word自动标题列表的是写文档必不可少的，自动标题能自动推导更新各级标题的序号，增删改查任何标题都不需要手动的写标题序号。</p>
<p>（1）创建多级列表<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423943.png" alt="image-20221206142307899"></p>
<p>（2）设置一级标题</p>
<ul>
<li>设置一级标题的序号样式为1,2,3</li>
<li>链接一级标题的字体样式到word文档的一级标题字体样式<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423121.png" alt="image-20221206142315070"></li>
</ul>
<p>（2）设置二级、三级、n级标题</p>
<p>需要设置列表序号，标题字体两部分。注意列表序号的正确设置是序号自动推导的关键。<br>以二级标题为例，其他子级类推。</p>
<ul>
<li><p>设置二级标题中的一级序号来自于level1。这一步保证二级标题中的一级序号是自动推导的。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423795.png" alt="image-20221206142327739"></p>
</li>
<li><p>设置二级标题中的二级序号的样式，二级标题中的一、二级序号用.号隔开<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424185.png" alt="image-20221206142401132"></p>
</li>
<li><p>二级标题最终的序号样式如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424492.png" alt="image-20221206142411436"></p>
</li>
<li><p>然后设置二级标题的字体风格，直接链接到word的二级标题字体风格<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424730.png" alt="image-20221206142420685"></p>
</li>
<li><p>二级标题列表的所有设置完毕，如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424880.png" alt="image-20221206142428828"></p>
</li>
</ul>
<p>(3)依次完成所有标题列表设置，例如三级标题，前两级的值来自于level1,level2，第三级设置数字格式即可，中间用.号隔开。完成以后各级标题就可以自动推导。</p>
<h2 id="Word导出原图"><a href="#Word导出原图" class="headerlink" title="Word导出原图"></a>Word导出原图</h2><p>Word默认图片如果直接复制出来，不是原图是压缩后的图。<br>保存原图方法： 文档另存为html网页格式，会把word文档转换成资源文件夹，里面有原始图片。</p>
<h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><h2 id="excel设置筛选"><a href="#excel设置筛选" class="headerlink" title="excel设置筛选"></a>excel设置筛选</h2><p>参考<a href="https://support.microsoft.com/zh-cn/office/%E7%AD%9B%E9%80%89%E5%8C%BA%E5%9F%9F%E6%88%96%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE-01832226-31b5-4568-8806-38c37dcc180e#:~:text=%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E7%AD%9B%E9%80%89%201%20%E9%80%89%E6%8B%A9%E8%A6%81%E7%AD%9B%E9%80%89%20%E5%88%97%E7%9A%84%E5%88%97%E6%A0%87%E9%A2%98%E7%AE%AD%E5%A4%B4%E3%80%82%202%20%E5%8F%96%E6%B6%88%20%28%E9%80%89%E6%8B%A9%22%29%20%22%EF%BC%8C,%E5%8D%95%E5%87%BB%E2%80%9C%20%E7%A1%AE%E5%AE%9A%20%E2%80%9D%E3%80%82%20%E5%88%97%E6%A0%87%E9%A2%98%E7%AE%AD%E5%A4%B4%20%22%E7%AD%9B%E9%80%89%20%E6%9B%B4%E6%94%B9%20%E3%80%82%20%E9%80%89%E6%8B%A9%E6%AD%A4%E5%9B%BE%E6%A0%87%E5%8F%AF%E6%9B%B4%E6%94%B9%E6%88%96%E6%B8%85%E9%99%A4%E7%AD%9B%E9%80%89%E3%80%82">筛选区域或表中的数据</a></p>
<ol>
<li><p>选中列，点击筛选</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302091144706.png" alt="image-20230209114432580"></p>
</li>
<li><p>可以按文字或者颜色筛选</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302091145967.png" alt="image-20230209114508910"></p>
</li>
</ol>
<h2 id="冻结首行"><a href="#冻结首行" class="headerlink" title="冻结首行"></a>冻结首行</h2><p>筛选行一般需要固定显示，因此设置冻结首行：</p>
<p>选中要固定显示行的下一行, 视图 -&gt; 冻结窗格 -&gt; 冻结首行</p>
]]></content>
      <categories>
        <category>windows系统</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title>windows PC开发环境配置</title>
    <url>/2024/08/30/Windows%20PC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="windows-PC开发环境配置"><a href="#windows-PC开发环境配置" class="headerlink" title="windows PC开发环境配置"></a>windows PC开发环境配置</h1><h2 id="多桌面和分屏"><a href="#多桌面和分屏" class="headerlink" title="多桌面和分屏"></a>多桌面和分屏</h2><p>Win+Ctrl+D， 新建桌面窗口</p>
<p>Win+Ctrl + ←&#x2F;→，切换桌面窗口</p>
<p>win+Tab， 任务视图，常用操作：拖动程序到指定窗口</p>
<p>win键+←&#x2F;→，快速分屏成两列</p>
<p>win键 + ←&#x2F;→ + ↑&#x2F;↓，快速4分屏</p>
<p>注意：多个桌面的相同应用是独立的，例如某桌面打开chrome很多页面，其他桌面打开chrome会是新网页</p>
<h2 id="区分Linux文件大小写"><a href="#区分Linux文件大小写" class="headerlink" title="区分Linux文件大小写"></a>区分Linux文件大小写</h2><p>需要4个条件：</p>
<p>Windows 10 1803以上版本<br>启用 Linux 子系统，即 Windows Subsystem for Linux<br>所在分区为 NTFS 格式<br>以管理员权限运行 PowerShell</p>
<p>必须启用WSL环境。powershell管理员运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure>

<p>再将指定目录启用大小写 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt; fsutil.exe file setCaseSensitiveInfo C:\github enable</span><br><span class="line">已启用目录 C:\github 的区分大小写属性。</span><br></pre></td></tr></table></figure>

<p>之后解压linux kernel就不会报错同名大小写文件重复。</p>
<h2 id="未激活Windows去水印和关闭WindowsUpdate和桌面壁纸"><a href="#未激活Windows去水印和关闭WindowsUpdate和桌面壁纸" class="headerlink" title="未激活Windows去水印和关闭WindowsUpdate和桌面壁纸"></a>未激活Windows去水印和关闭WindowsUpdate和桌面壁纸</h2><p>win+R regedit设置Start值为4，去桌面水印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc -&gt; Start -&gt; 4</span><br></pre></td></tr></table></figure>

<p>永久关闭WindowsUpdate，否则下次Update之后又有水印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services.msc -&gt; Windows Update -&gt; </span><br><span class="line">(1)常规 -&gt; 禁用</span><br><span class="line">(2)恢复 -&gt; 第一次失败 -&gt; 无操作, 重置计数 -&gt; 9999</span><br></pre></td></tr></table></figure>

<p>更换壁纸：下载图片直接右键设置为壁纸</p>
]]></content>
      <categories>
        <category>windows系统</category>
      </categories>
      <tags>
        <tag>windows系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows CMD常用命令笔记</title>
    <url>/2023/01/30/Windows-CMD-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Tree命令生成目录树"><a href="#Tree命令生成目录树" class="headerlink" title="Tree命令生成目录树"></a>Tree命令生成目录树</h1><blockquote>
<p>tree 命令的目录格式：TREE 【drive：】【path】【&#x2F;F】【&#x2F;A】</p>
<ul>
<li>可在cmd内输入（help tree 或 tree &#x2F; ？）查看</li>
<li>&#x2F;F  显示每个文件夹中文件的名称</li>
<li>&#x2F;A  使用ASCII字符，而不使用拓展字符</li>
</ul>
</blockquote>
<p>示例一：只显示路径名不显示文件名</p>
<p><code>TREE 【drive：】【path】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301049746.png" alt="image-20230130104934713"></p>
<p>示例二：显示路径名和文件名</p>
<p><code>TREE 【drive：】【path】【/F】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301048851.png" alt="image-20230130104835813"></p>
<p>示例三：将目录树存入指定文件</p>
<p><code>TREE 【drive：】【path】 &gt; 文件路径】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301051100.png" alt="image-20230130105102054"></p>
]]></content>
      <categories>
        <category>windows系统</category>
      </categories>
      <tags>
        <tag>windows系统</tag>
      </tags>
  </entry>
  <entry>
    <title>esp32笔记之PWM实现LED呼吸灯</title>
    <url>/2023/05/05/esp32%E7%AC%94%E8%AE%B0%E4%B9%8BPWM%E5%AE%9E%E7%8E%B0LED%E5%91%BC%E5%90%B8%E7%81%AF/</url>
    <content><![CDATA[<h2 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h2><p>先从应用上讲讲PWM：</p>
<p>有一盏日光灯，一般我们只能打开它或者关闭它，不存在中间状态；</p>
<p>有另一个LED灯，支持在一秒以内极快速的速度开关开关，其变化超过人眼识别的24帧率，LED灯看上去就像一直开着，但亮度比常开暗一些；如果控制灯快速开关过程中的打开时间和关闭时间的比例，就可以调节人眼看到的灯亮度。</p>
<p>以上就是PWM的大概应用原理：用高频率的开关信号，控制输出信号的平均强度，使输出信号能在0%到100%强度间任意调节。</p>
<p>用电路语句讲PWM原理：用数字信号的占空比来调制模拟信号的幅度(电压)。</p>
<p>PWM详细介绍参考：<a href="https://circuitdigest.com/tutorial/what-is-pwm-pulse-width-modulation">What is PWM: Pulse Width Modulation</a></p>
<p>脉冲宽度(pulse width)是指单位时间的高电平的持续时间，脉冲宽度越大被调制的模拟信号电压越大。</p>
<ul>
<li>在一定的频率下，通过不同的(高电平)占空比即可得到不同脉冲宽度，进而调节输出的模拟电压信号</li>
<li>在一定的占空比下，通过不同的频率实现不同的调节速度；频率要适配不同设备，不能任意设置，例如电机频率50HZ，MCU外设1000Hz。频率不决定被调制电压的幅度。</li>
</ul>
<p>PWM的调制信号如下：</p>
<p><img src="https://circuitdigest.com/sites/default/files/inlineimages/pulse-width-modulation-duty-cycle.gif" alt="img"></p>
<p>PWM调制电路通常用RC filter实现：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051659127.jpg" alt="Converting-PWM-signals-into-Analog"></p>
<p>PWM一般对具体设备使用固定频率，再调整高电平的占空比决定模拟信号的幅度。</p>
<p>如下图，占空比从0%调节到100%，对应输出电压为0V~5V</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305061100234.jpg" alt="Pulse-Width-Modulation"></p>
<p>从原理上讲就是开关控制，在一个周期内调制信号的高电平时间越长，RC电荷积分更多，输出电压越大：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051657299.png" alt="image-20230505165748199"></p>
<h2 id="MicroPython控制PWM"><a href="#MicroPython控制PWM" class="headerlink" title="MicroPython控制PWM"></a>MicroPython控制PWM</h2><p>官方tutorial参考：</p>
<p><a href="https://docs.micropython.org/en/latest/esp32/quickref.html">Quick reference for the ESP32</a> PWM (pulse width modulation)</p>
<p><a href="https://docs.micropython.org/en/latest/esp32/tutorial/pwm.html#esp32-pwm">Pulse Width Modulation</a> 其中有调整频率和占空比的sample code:</p>
<ul>
<li><p>Example of a smooth frequency change:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">F_MIN = 500</span><br><span class="line">F_MAX = 1000</span><br><span class="line"></span><br><span class="line">f = F_MIN</span><br><span class="line">delta_f = 1</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), f)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.freq(f)</span><br><span class="line"></span><br><span class="line">    sleep(10 / F_MIN)</span><br><span class="line"></span><br><span class="line">    f += delta_f</span><br><span class="line">    if f &gt;= F_MAX or f &lt;= F_MIN:</span><br><span class="line">        delta_f = -delta_f</span><br></pre></td></tr></table></figure>
</li>
<li><p>Example of a smooth duty change:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">DUTY_MAX = 2**16 - 1</span><br><span class="line"></span><br><span class="line">duty_u16 = 0</span><br><span class="line">delta_d = 16</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), 1000, duty_u16=duty_u16)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.duty_u16(duty_u16)</span><br><span class="line"></span><br><span class="line">    sleep(1 / 1000)</span><br><span class="line"></span><br><span class="line">    duty_u16 += delta_d</span><br><span class="line">    if duty_u16 &gt;= DUTY_MAX:</span><br><span class="line">        duty_u16 = DUTY_MAX</span><br><span class="line">        delta_d = -delta_d</span><br><span class="line">    elif duty_u16 &lt;= 0:</span><br><span class="line">        duty_u16 = 0</span><br><span class="line">        delta_d = -delta_d</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="呼吸灯示例"><a href="#呼吸灯示例" class="headerlink" title="呼吸灯示例"></a>呼吸灯示例</h2><p>参考：<a href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/03.PWMhuxideng">itproject.cn&#x2F;Python+ESP32快速上手&#x2F;3.PWM呼吸灯</a></p>
<p>esp32的micropython代码以script形式执行，主程序必须命名为main.py(参考 <a href="https://docs.micropython.org/en/v1.9.3/pyboard/pyboard/tutorial/script.html">Running your first script</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from machine import Pin, PWM</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">led2 = PWM(Pin(2))</span><br><span class="line">led2.freq(1000)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    for i in range(0, 1024):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br><span class="line">        </span><br><span class="line">    for i in range(1023, -1, -1):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br></pre></td></tr></table></figure>

<p>LED渐变呼吸闪烁：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305052003803.gif" alt="mmexport1683287925729"></p>
<p>如果将led duty调整为512，最大亮度会变小，验证了最大占空比决定最大电压</p>
<p>如果将led freq调整为50，最大亮度不变，但led渐变过程中会闪烁，也就是说开关调节频率太低，导致人眼都可以观察到led的开关电，看上去就是led闪烁</p>
]]></content>
      <categories>
        <category>esp32</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title>esp32笔记之环境搭建</title>
    <url>/2023/05/04/esp32%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>esp32是乐鑫的SOC，支持Wifi, BLE等IOT功能；官方教程：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html">ESP-IDF编程指南</a></p>
<h1 id="ESP-IDF环境搭建"><a href="#ESP-IDF环境搭建" class="headerlink" title="ESP-IDF环境搭建"></a>ESP-IDF环境搭建</h1><p>按官方教程在Linux ubuntu搭建ESP-IDF开发环境，有clone idf一直失败的问题</p>
<p>本节记录不用翻墙搭建ESP-ID环境的过程，视频参考：<a href="https://b23.tv/VCYbC2m">Linux 如何安装 ESP-IDF ESP32 开发环境搭建</a></p>
<h2 id="版本发布、下载"><a href="#版本发布、下载" class="headerlink" title="版本发布、下载"></a>版本发布、下载</h2><p><a href="https://github.com/espressif/esp-idf/releases">https://github.com/espressif/esp-idf/releases</a></p>
<p>手动下载release版本的idf压缩包，例如下载esp-idf-v5.0.1.zip</p>
<p>解压到 ~&#x2F;esp&#x2F;esp-idf (<code>mv esp-idf-v5.0.1 esp-idf</code>)</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git wget flex bison gperf python3 python3-venv python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0</span><br></pre></td></tr></table></figure>

<h2 id="安装-ESP-IDF"><a href="#安装-ESP-IDF" class="headerlink" title="安装 ESP-IDF"></a>安装 ESP-IDF</h2><p>安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">./install.sh esp32 #esp32 chip,用此命令即可</span><br><span class="line">./install.sh all #所有esp chips</span><br></pre></td></tr></table></figure>

<p>如果安装遇到网络问题，需要设置下载服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">export IDF_GITHUB_ASSETS=&quot;dl.espressif.com/github_assets&quot;</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>如果遇到 Python 包安装问题则需要设置 Python 源</p>
<h2 id="设置环境变量："><a href="#设置环境变量：" class="headerlink" title="设置环境变量："></a>设置环境变量：</h2><p>每次运行都export环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. $HOME/esp/esp-idf/export.sh</span><br></pre></td></tr></table></figure>

<p>或把将以下语句加入 ~&#x2F;.bashrc，每次执行只需要 <code>get_idf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias get_idf=&#x27;. $HOME/esp/esp-idf/export.sh&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="串口相关设置"><a href="#串口相关设置" class="headerlink" title="串口相关设置"></a>串口相关设置</h2><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/establish-serial-connection.html">与 ESP32 创建串口连接</a></p>
<p>查看串口: ls &#x2F;dev&#x2F;tty* (esp32应该是ttyUSB0)</p>
<p>必须将将用户添加到 <code>dialout</code> 组，从而获许串口读写权限，否则串口无法连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br></pre></td></tr></table></figure>

<h2 id="编译和烧录"><a href="#编译和烧录" class="headerlink" title="编译和烧录"></a>编译和烧录</h2><ul>
<li>设置：idf.py menuconfig</li>
<li>编译：idf.py build</li>
<li>烧录：idf.py -p PORT 【-b BAUD】 flash</li>
<li>监视：idf.py -p PORT monitor，使用快捷键 <code>Ctrl+]</code>，退出 IDF 监视器</li>
<li>一次性执行构建、烧录和监视过程：idf.py -p PORT flash monitor</li>
</ul>
<h1 id="MicroPython环境搭建"><a href="#MicroPython环境搭建" class="headerlink" title="MicroPython环境搭建"></a>MicroPython环境搭建</h1><p>分为esp32侧的Firmware和PC侧的IDE两部分。</p>
<p>本文是Linux环境，windows环境参考：<a href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/01.dajianhuanjing">Thonny+MicroPython+ESP32开发环境搭建</a></p>
<h2 id="ESP32安装MicroPython"><a href="#ESP32安装MicroPython" class="headerlink" title="ESP32安装MicroPython"></a>ESP32安装MicroPython</h2><p>Micropython是在嵌入式平台上运行Python的基础库，参考：<a href="https://docs.micropython.org/en/latest/">https://docs.micropython.org/en/latest/</a></p>
<p>下载和安装esp32的Micropython，参考：<a href="https://micropython.org/download/esp32/">Installation instructions</a></p>
<p>先擦除flash, 其中esptool.py已经被esp-idf&#x2F;export.sh导出到环境变量；如果ls &#x2F;dev&#x2F;tty*显示有ttyUSB0，但esptool.py还找不到ttyUSB0，需要重启并用<code>get_idf</code>重新export idf，再插拔esp32就可以找到.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash</span><br></pre></td></tr></table></figure>

<p>烧写支持micropython的 &lt;esp32-firmware.bin&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 &lt;esp32-firmware.bin&gt;</span><br></pre></td></tr></table></figure>

<p>例如我的Firmware使用的是：</p>
<p><strong><a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.bin">v1.20.0 (2023-04-26) .bin</a></strong> [<a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.elf">.elf]</a> [<a href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.map">.map]</a> [<a href="https://github.com/micropython/micropython/releases/tag/v1.20.0">Release notes]</a> (latest)</p>
<h2 id="使用VScode-Pymakr搭建Micropython开发环境"><a href="#使用VScode-Pymakr搭建Micropython开发环境" class="headerlink" title="使用VScode+Pymakr搭建Micropython开发环境"></a>使用VScode+Pymakr搭建Micropython开发环境</h2><p>总体的安装流程参考：<a href="https://randomnerdtutorials.com/micropython-esp32-esp8266-vs-code-pymakr/">MicroPython: Program ESP32&#x2F;ESP8266 using VS Code and Pymakr</a></p>
<p>Pymakr如何使用，参考<a href="https://github.com/pycom/pymakr-vsc/blob/next/GET_STARTED.md">Pymakr Getting Started</a></p>
<p>写一个LED闪烁的sample code验证开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from machine import Pin</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">led = Pin(2, Pin.OUT) #GPIO2, output mode</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">  led.value(not led.value())</span><br><span class="line">  sleep(0.5)</span><br></pre></td></tr></table></figure>

<p>LED如何控制，要根据esp32具体开发板的电路图找到LED相关的GPIO，以及配什么输入&#x2F;输出模式使GPIO导通&#x2F;关闭。</p>
<p>如下图，我的esp32 LED连接到GPIO2(IO2)，并且GPIO2输出高电平时LED导通</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042003091.png" alt="image-20230504200335998"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042004848.png" alt="image-20230504200411499"></p>
<p>选择VSCode的Pymakr Project -&gt; connect device -&gt; ’sync project to device‘，上传该LED python代码到esp32上运行；右键Pymakr Project的Hard reset device以后执行python代码</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051116409.png" alt="image-20230505111655320"></p>
<p>esp32 GPIO2的LED不停闪烁</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051156061.gif" alt="mmexport1683202673677"></p>
]]></content>
      <categories>
        <category>esp32</category>
      </categories>
      <tags>
        <tag>esp32</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客和next主题环境搭建</title>
    <url>/2025/11/17/hexo%E5%8D%9A%E5%AE%A2%E5%92%8Cnext%E4%B8%BB%E9%A2%98%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="hexo博客和next主题环境搭建"><a href="#hexo博客和next主题环境搭建" class="headerlink" title="hexo博客和next主题环境搭建"></a>hexo博客和next主题环境搭建</h1><p>本文描述搭建hexo博客环境以及配置next主题的过程</p>
<h2 id="主环境安装"><a href="#主环境安装" class="headerlink" title="主环境安装"></a>主环境安装</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node js"></a>安装node js</h3><p><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p>用cmd检验一下是否安装成功：用 node -v 和 npm -v 命令检查版本</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>新建文件夹 如hexo-blog，在此目录安装hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装完的目录如下，详细见：<a href="https://hexo.io/zh-cn/docs/setup">https://hexo.io/zh-cn/docs/setup</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>测试一下创建默认页面从本地访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\hexo-blog&gt;hexo g  #将blog资料创建为css,html静态文件</span><br><span class="line">INFO  Generated: archives/index.html </span><br><span class="line">D:\hexo-blog&gt;hexo s  #运行hexo server</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<h3 id="安装next主题"><a href="#安装next主题" class="headerlink" title="安装next主题"></a>安装next主题</h3><p>在hexo-blog目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>主题位于hexo的theme子目录，结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">├── layout</span><br><span class="line">├── scripts</span><br><span class="line">└── source</span><br></pre></td></tr></table></figure>

<p>含义见：<a href="https://hexo.io/zh-cn/docs/themes">https://hexo.io/zh-cn/docs/themes</a></p>
<h3 id="安装部署插件"><a href="#安装部署插件" class="headerlink" title="安装部署插件"></a>安装部署插件</h3><p>后面部署博客到github会用到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h2 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h2><p>在默认的hexo config.yaml改以下部分：</p>
<h3 id="配置主页信息"><a href="#配置主页信息" class="headerlink" title="配置主页信息"></a>配置主页信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: ThinkNotes</span><br><span class="line">subtitle: &#x27;Simple is not easy&#x27;</span><br><span class="line">description: &#x27;&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: cursorhu</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h3 id="配置部署"><a href="#配置部署" class="headerlink" title="配置部署"></a>配置部署</h3><p>部署到github repo(没有的话要先创建一个公开repo)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: https://github.com/cursorhu/cursorhu.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>注意git部署需要hexo-deployer-git已安装</p>
<h2 id="next主题配置"><a href="#next主题配置" class="headerlink" title="next主题配置"></a>next主题配置</h2><p>编辑themes\next_config.yml主题配置文件，改动如下：</p>
<p>选择next子主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="主页菜单设置"><a href="#主页菜单设置" class="headerlink" title="主页菜单设置"></a>主页菜单设置</h3><p>配置文件去掉#注释，打开tags，categories，about页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Usage: `Key: /link/ || icon`</span><br><span class="line"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span><br><span class="line"># Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line"># When running the site in a subdirectory (e.g. yoursite.com/blog), remove the leading slash from link value (/archives -&gt; archives).</span><br><span class="line"># External url should start with http:// or https://</span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<p>只是主页打开还不行，还需要手动创建page页面，否则报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cannot GET /about/</span><br><span class="line">Cannot GET /tags/</span><br><span class="line">Cannot GET /categories/</span><br></pre></td></tr></table></figure>

<p>在hexo根目录手动创建page页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会新建 <code>about</code>、<code>tags</code>、<code>categories</code>文件夹，每个文件夹下还会创建一个<code>index.md</code>文件，编辑各页面对应的<code>index.md</code>文件，增加 type字段 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about # 这里可以中英文，显示为页面的标题</span><br><span class="line">date: 2025-11-13 15:21:30 # 这个实际可以删掉，用不上</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line">title: tages # 这里可以中英文，如 标签</span><br><span class="line">date: 2025-11-13 15:21:30</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line">title: categories # 这里可以中英文，如 分类</span><br><span class="line">date: 2025-11-13 15:21:30</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>注意，这几个页面用本地server测试：hexo g + hexo s并不能看到内容，只有hexo d部署后才能看到。</p>
<h3 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h3><p>修改主页显示的社交链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/cursorhu || fab fa-github</span><br><span class="line">  E-Mail: mailto:2449055512@qq.com || fa fa-envelope</span><br><span class="line">  </span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>推荐英文字体使用Roboto，中文字体使用 Noto Serif SC(宋体思源)</p>
<p>在<a href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索框搜索字体英文名添加以上两种字体，产生URI(Uniform Resource Identifier)，复制href字段的引号内容。</p>
<p>如下图只是示例，实际需要替换URI，将fonts.googlefonts.cn替换为fonts.googleapis.com，Noto Serif替换为Noto Serif SC。</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/11/17/8756b9beefdaee51.png" alt="image-20251117170618261"></p>
<p>在config.yml的font字段添加host URI和字体名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span><br><span class="line">  host: https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: x.x`. Use `em` as unit. Default: 1 (16px)</span><br><span class="line"></span><br><span class="line">  # Global font settings used for all elements inside &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Noto Serif SC</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for site title (.site-title).</span><br><span class="line">  title:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for posts (.post-body).</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto</span><br></pre></td></tr></table></figure>

<p>在静态页面的base style配置文件<code>hexo\themes\next\source\css\_variables\base.styl</code>指定中文字体font-family-chinese为’Noto Serif SC’，base.styl是所有主题使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// Font families.</span><br><span class="line">$font-family-chinese      = &quot;Noto Serif SC&quot;;</span><br><span class="line"></span><br><span class="line">$font-family-base         = $font-family-chinese, sans-serif;</span><br><span class="line">$font-family-base         = get_font_family(&#x27;global&#x27;), $font-family-chinese, sans-serif if get_font_family(&#x27;global&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-logo         = $font-family-base;</span><br><span class="line">$font-family-logo         = get_font_family(&#x27;title&#x27;), $font-family-base if get_font_family(&#x27;title&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-headings     = $font-family-base;</span><br><span class="line">$font-family-headings     = get_font_family(&#x27;headings&#x27;), $font-family-base if get_font_family(&#x27;headings&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-posts        = $font-family-base;</span><br><span class="line">$font-family-posts        = get_font_family(&#x27;posts&#x27;), $font-family-base if get_font_family(&#x27;posts&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-monospace    = consolas, Menlo, monospace, $font-family-chinese;</span><br><span class="line">$font-family-monospace    = get_font_family(&#x27;codes&#x27;), consolas, Menlo, monospace, $font-family-chinese if get_font_family(&#x27;codes&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="访问统计"><a href="#访问统计" class="headerlink" title="访问统计"></a>访问统计</h3><p>config.yaml先打开卜算子统计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

<p><code>\themes\next\layout\_partials</code>找到<code>footer.swig</code>文件，添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.footer.counter %&#125;</span><br><span class="line">    &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>src见官网说明：<a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a></p>
<h3 id="站点图标"><a href="#站点图标" class="headerlink" title="站点图标"></a>站点图标</h3><p>博客站点图标默认为next的logo, 可修改为自定义图标集合。</p>
<p>使用<a href="https://www.favicon-generator.org/">https://www.favicon-generator.org</a> 创建图标包，放到next&#x2F;images下，例如&#x2F;images&#x2F;my_icon&#x2F;，再修改config.yaml配置不同客户端的图标路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/my_icon/favicon-16x16.ico #用my_icon</span><br><span class="line">  medium: /images/my_icon/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png #这里用默认的</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  android_manifest: /images/my_icon/manifest.json #用my_icon</span><br><span class="line">  ms_browserconfig: /images/my_icon/browserconfig.xml</span><br></pre></td></tr></table></figure>

<h3 id="主页头像"><a href="#主页头像" class="headerlink" title="主页头像"></a>主页头像</h3><p>将图片放在<code>\MyBlog\themes\next\source\images</code>下，并修改<code>头像名.后缀</code>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/头像名.后缀</span><br></pre></td></tr></table></figure>

<h3 id="主页菜单图标"><a href="#主页菜单图标" class="headerlink" title="主页菜单图标"></a>主页菜单图标</h3><p>打开<code>主题配置文件</code>，找到<code>menu</code>字段</p>
<p>以<code>about</code>菜单项为例，可以看到<code>about: /about/ || fa fa-user</code>这一行，其中<code>||</code>后面的<code>fa fa-user</code>即为本菜单项的图标</p>
<p>如果需要更改图标，可以进入<a href="https://sspai.com/link?target=https://fontawesome.dashgame.com/">Font Awesome</a>获取新图标，只需将文件改为“fa + 复制的图标”即可</p>
<h3 id="主页文章预览"><a href="#主页文章预览" class="headerlink" title="主页文章预览"></a>主页文章预览</h3><p>config设置 excerpt_description: true，然后下面方法二选一：</p>
<p>自己手写概述，在文件头添加到description：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo</span><br><span class="line">categories:  Hexo</span><br><span class="line">tags: Hexo</span><br><span class="line">description: XXXXXXXXX</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>或者文章截断，在文章中间加入 <code>&lt;!--more--&gt;</code></p>
<h3 id="全局搜索栏"><a href="#全局搜索栏" class="headerlink" title="全局搜索栏"></a>全局搜索栏</h3><p>在hexo的config.yaml添加如下，目的是在主页显示搜索菜单项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Search Config</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 100</span><br></pre></td></tr></table></figure>

<p>安装hexo search插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>在next的config.yaml使能search</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><ol>
<li><strong>系统</strong>切换至深色模式时启动暗黑模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">darkmode: true</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一键复制代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock: </span><br><span class="line">	copy_button:</span><br><span class="line">    	enable: true</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关掉Powered by Hexo &amp; NexT：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powered: false</span><br></pre></td></tr></table></figure>

<h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p>创建新文章</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;blog&quot; #new</span><br></pre></td></tr></table></figure>

<p>创建指定tags和categories的new post文章</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;blog&quot; --tags &quot;tags&quot; --categories &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>将常规markdown转化为可以发布的博客：在markdown源码模式下，手动复制文章头到文件，也是和hexo n命令创建头一样效果</p>
<p>tags可以支持多个：</p>
<ol>
<li><p>单标签，<code>tags: 标签名</code></p>
</li>
<li><p>多标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tags: </span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="本地部署测试"><a href="#本地部署测试" class="headerlink" title="本地部署测试"></a>本地部署测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean #删除缓存，重新生成public博客静态文件</span><br><span class="line">hexo g #generate新博客静态文件</span><br><span class="line">hexo s #server，运行本地服务，用于测试</span><br></pre></td></tr></table></figure>

<h3 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d #deploy到服务器，如github repo，网络不好需要梯子</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://sspai.com/post/85116">https://sspai.com/post/85116</a></p>
<p><a href="https://maphical.cn/2020/03/build-blog-using-hexo/">https://maphical.cn/2020/03/build-blog-using-hexo/</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo和next主题的配置笔记</title>
    <url>/2023/03/15/hexo%E5%92%8Cnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="hexo相关配置"><a href="#hexo相关配置" class="headerlink" title="hexo相关配置"></a>hexo相关配置</h3><p>hexo各页面的配置，参考 <a href="https://www.jianshu.com/p/3a05351a37dc">jianshu-Hexo的Next主题详细配置</a></p>
<p>hexo主页显示摘要，参考 <a href="https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%20Next%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E6%96%87%EF%BC%89/">Hexo Next主题首页配置为只显示部分摘要</a></p>
<h3 id="next设置字体"><a href="#next设置字体" class="headerlink" title="next设置字体"></a>next设置字体</h3><p>参考 <a href="https://tzynwang.github.io/2021/next-theme-edit/#:~:text=Search%20for%20the%20font%20family%20%E2%80%9CRoboto%E2%80%9D%20Click%20%E2%80%9C%2B,as%20the%20value%20for%20%E2%80%9Chost%E2%80%9D%20key%20in%20_config.next.yml">tzynwang.github.io&#x2F;2021&#x2F;next-theme-edit</a></p>
<p>下面重点描述如何使用Google Font来配置next主题的字体，基于next version 8.0.0</p>
<ul>
<li>推荐英文字体使用Roboto，中文字体使用 Noto Serif (注：Noto Serif字符集包含chinese&#x2F;Japanese&#x2F;korea等，参考 <a href="https://github.com/notofonts/noto-cjk">noto-cjk</a>；Noto Serif 是宋体但不是宋体思源，见后文)</li>
<li>在<a href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索框搜索字体英文名添加以上两种字体，产生URI(Uniform Resource Identifier)，复制href字段的引号内容</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151454240.png" alt="image-20230315145422134"></p>
<ul>
<li>在hexo的next配置文件<code>hexo\themes\next\_config.yml</code>的font字段添加host URI和字体名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span><br><span class="line">  host: https://fonts.googlefonts.cn/css?family=Noto+Serif|Roboto</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: x.x`. Use `em` as unit. Default: 1 (16px)</span><br><span class="line"></span><br><span class="line">  # Global font settings used for all elements inside &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Noto Serif</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for site title (.site-title).</span><br><span class="line">  title:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for posts (.post-body).</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto</span><br></pre></td></tr></table></figure>

<ul>
<li>在静态页面的base style配置文件<code>hexo\themes\next\source\css\_variables\base.styl</code>指定中文字体font-family-chinese为’Noto Serif’（注意看这里get_font_family解析到next配置文件_config.yml的字段’global’, ‘title’ … ‘codes’等作为静态页面的配置）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Font families.</span><br><span class="line">$font-family-chinese      = &#x27;Noto Serif&#x27;;</span><br><span class="line"></span><br><span class="line">$font-family-base         = $font-family-chinese, sans-serif;</span><br><span class="line">$font-family-base         = get_font_family(&#x27;global&#x27;), $font-family-chinese, sans-serif if get_font_family(&#x27;global&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-logo         = $font-family-base;</span><br><span class="line">$font-family-logo         = get_font_family(&#x27;title&#x27;), $font-family-base if get_font_family(&#x27;title&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-headings     = $font-family-base;</span><br><span class="line">$font-family-headings     = get_font_family(&#x27;headings&#x27;), $font-family-base if get_font_family(&#x27;headings&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-posts        = $font-family-base;</span><br><span class="line">$font-family-posts        = get_font_family(&#x27;posts&#x27;), $font-family-base if get_font_family(&#x27;posts&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-monospace    = monospace, consolas, Menlo, $font-family-chinese;</span><br><span class="line">$font-family-monospace    = get_font_family(&#x27;codes&#x27;), monospace, consolas, Menlo, $font-family-chinese if get_font_family(&#x27;codes&#x27;);</span><br></pre></td></tr></table></figure>

<p>自此next中英文字体都应该生效，<code>hexo g + hexo s</code> 重新部署验证一下发现中文字体似乎不是思源宋体？</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151606100.png" alt="image-20230315160648032"></p>
<p>原因是Noto Serif !&#x3D; Noto Serif SC (simplified chinese)，Noto Serif SC才是思源宋体</p>
<p><a href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索不到思源宋体，<a href="https://fonts.google.com/">google font原站</a>又打不开，因此需要直接替换URI，将fonts.googlefonts.cn替换为fonts.googleapis.com，Noto Serif替换为Noto Serif SC</p>
<p>next配置文件改动如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo\themes\next\_config.yml:</span><br><span class="line"></span><br><span class="line">font:</span><br><span class="line">    - host: https://fonts.googlefonts.cn/css?family=Noto+Serif|Roboto</span><br><span class="line">    + host: https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto</span><br><span class="line"></span><br><span class="line">    global:</span><br><span class="line">    - family: Noto Serif</span><br><span class="line">    + family: Noto Serif SC</span><br><span class="line">    </span><br><span class="line">hexo\themes\next\source\css\_variables\base.styl:</span><br><span class="line"></span><br><span class="line">// Font families.</span><br><span class="line">- $font-family-chinese = &#x27;Noto Serif&#x27;;</span><br><span class="line">+ $font-family-chinese = &#x27;Noto Serif SC&#x27;;</span><br></pre></td></tr></table></figure>

<p>验证结果为思源宋体：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151559719.png" alt="image-20230315155911647"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础 -- GCC使用笔记</title>
    <url>/2020/06/22/linux%E5%9F%BA%E7%A1%80%20--%20GCC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="gcc编译选项"><a href="#gcc编译选项" class="headerlink" title="gcc编译选项"></a>gcc编译选项</h1><p>gcc提供了大量的警告选项，对代码中可能存在的问题提出警告，通常可以使用-Wall来开启以下警告:</p>
<pre><code>   -Waddress -Warray-bounds (only with -O2) -Wc++0x-compat
   -Wchar-subscripts -Wimplicit-int -Wimplicit-function-declaration
   -Wcomment -Wformat -Wmain (only for C/ObjC and unless
   -ffreestanding) -Wmissing-braces -Wnonnull -Wparentheses
   -Wpointer-sign -Wreorder -Wreturn-type -Wsequence-point
   -Wsign-compare (only in C++) -Wstrict-aliasing -Wstrict-overflow=1
   -Wswitch -Wtrigraphs -Wuninitialized (only with -O1 and above)
   -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value
   -Wunused-variable

unused-function:警告声明但是没有定义的static函数;
unused- label:声明但是未使用的标签;
unused-parameter:警告未使用的函数参数;
unused-variable:声明但是未使用的本地变量;
unused-value:计算了但是未使用的值;
format:printf和scanf这样的函数中的格式字符串的使用不当;
implicit-int:未指定类型;
implicit-function:函数在声明前使用;
char- subscripts:使用char类作为数组下标(因为char可能是有符号数);
missingbraces:大括号不匹配;
parentheses: 圆括号不匹配;
return-type:函数有无返回值以及返回值类型不匹配;
sequence-point:违反顺序点的代码,比如 a[i] = c[i++];
switch:switch语句缺少default或者switch使用枚举变量为索引时缺少某个变量的case;
strict- aliasing=n:使用n设置对指针变量指向的对象类型产生警告的限制程度,默认n=3;只有在-fstrict-aliasing设置的情况下有效;
unknow-pragmas:使用未知的#pragma指令;
uninitialized:使用的变量为初始化,只在-O2时有效;
</code></pre>
<p>以下是在-Wall中不会激活的警告选项:</p>
<pre><code>cast-align:当指针进行类型转换后有内存对齐要求更严格时发出警告;
sign- compare:当使用signed和unsigned类型比较时;
missing-prototypes:当函数在使用前没有函数原型时;
packed:packed 是gcc的一个扩展,是使结构体各成员之间不留内存对齐所需的空间,有时候会造成内存对齐的问题;
padded:也是gcc的扩展,使结构体成员之间进行内存对齐的填充,会造成结构体体积增大.
unreachable-code:有不会执行的代码时.
inline:当inline函数不再保持inline时 (比如对inline函数取地址);
disable-optimization:当不能执行指定的优化时.(需要太多时间或系统资源).
可以使用 -Werror时所有的警告都变成错误,使出现警告时也停止编译.需要和指定警告的参数一起使用.
</code></pre>
<p>编译的优化级别:<br>gcc默认提供了5级优化选项的集合:</p>
<pre><code>-O0:无优化(默认)
-O和-O1:使用能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化.在编译大型程序的时候会显著增加编译时内存的使用.
-O2: 包含-O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化.编译器不执行循环展开以及函数内联.此选项将增加编译时间和目标文件的执行性能.
-Os:专门优化目标文件大小,执行所有的不增加目标文件大小的-O2优化选项.并且执行专门减小目标文件大小的优化选项.
-O3: 打开所有-O2的优化选项并且增加 -finline-functions, -funswitch-loops,-fpredictive-commoning, -fgcse-after-reload and -ftree-vectorize优化选项.
</code></pre>
<p>-O1包含的选项-O1通常可以安全的和调试的选项一起使用:</p>
<pre><code>   -fauto-inc-dec -fcprop-registers -fdce -fdefer-pop -fdelayed-branch
   -fdse -fguess-branch-probability -fif-conversion2 -fif-conversion
   -finline-small-functions -fipa-pure-const -fipa-reference
   -fmerge-constants -fsplit-wide-types -ftree-ccp -ftree-ch
   -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse
   -ftree-fre -ftree-sra -ftree-ter -funit-at-a-time
</code></pre>
<p>以下所有的优化选项需要在名字前加上-f,如果不需要此选项可以使用-fno-前缀</p>
<pre><code>defer-pop:延迟到只在必要时从函数参数栈中pop参数;
thread- jumps:使用跳转线程优化,避免跳转到另一个跳转;
branch-probabilities:分支优化;
cprop- registers:使用寄存器之间copy-propagation传值;
guess-branch-probability:分支预测;
omit- frame-pointer:可能的情况下不产生栈帧;
</code></pre>
<p>-O2:以下是-O2在-O1基础上增加的优化选项:</p>
<pre><code>    -falign-functions  -falign-jumps -falign-loops  -falign-labels
   -fcaller-saves -fcrossjumping -fcse-follow-jumps  -fcse-skip-blocks
   -fdelete-null-pointer-checks -fexpensive-optimizations -fgcse
   -fgcse-lm -foptimize-sibling-calls -fpeephole2 -fregmove
   -freorder-blocks  -freorder-functions -frerun-cse-after-loop
   -fsched-interblock  -fsched-spec -fschedule-insns
   -fschedule-insns2 -fstrict-aliasing -fstrict-overflow -ftree-pre
   -ftree-vrp
</code></pre>
<p>cpu架构的优化选项,通常是-mcpu(将被取消);-march,-mtune</p>
<p>Debug选项:</p>
<pre><code>在 gcc编译源代码时指定-g选项可以产生带有调试信息的目标代码,gcc可以为多个不同平台上帝不同调试器提供调试信息,默认gcc产生的调试信息是为 gdb使用的,可以使用-gformat 指定要生成的调试信息的格式以提供给其他平台的其他调试器使用.常用的格式有
-ggdb:生成gdb专用的调试信息,使用最适合的格式(DWARF 2,stabs等)会有一些gdb专用的扩展,可能造成其他调试器无法运行.
-gstabs:使用 stabs格式,不包含gdb扩展,stabs常用于BSD系统的DBX调试器.
-gcoff:产生COFF格式的调试信息,常用于System V下的SDB调试器;
-gxcoff:产生XCOFF格式的调试信息,用于IBM的RS/6000下的DBX调试器;
-gdwarf- 2:产生DWARF version2 的格式的调试信息,常用于IRIXX6上的DBX调试器.GCC会使用DWARF version3的一些特性.
</code></pre>
<p>可以指定调试信息的等级:在指定的调试格式后面加上等级:<br>如: -ggdb2 等,0代表不产生调试信息.在使用-gdwarf-2时因为最早的格式为-gdwarf2会造成混乱,所以要额外使用一个-glevel来指定调试信息的等级,其他格式选项也可以另外指定等级.<br>gcc可以使用-p选项指定生成信息以供porf使用.</p>
<h1 id="gcc配置选项"><a href="#gcc配置选项" class="headerlink" title="gcc配置选项"></a>gcc配置选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727329.png" alt="6"></p>
<h1 id="gcc常用选项"><a href="#gcc常用选项" class="headerlink" title="gcc常用选项"></a>gcc常用选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081725642.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726685.png" alt="2"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726022.png" alt="3"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726272.png" alt="4"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727091.png" alt="5"></p>
]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础 -- Makefile使用笔记</title>
    <url>/2020/06/10/linux%E5%9F%BA%E7%A1%80%20--%20Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="文件名替换"><a href="#文件名替换" class="headerlink" title="文件名替换"></a>文件名替换</h1><p>1.wildcard<br>展开多个文件为使用空格分开的、匹配此模式的列表参数<br>格式<br><code>$(wildcard PATTERN...)</code></p>
<p>示例：</p>
<pre><code>SRC=$(wildcard *.c)
</code></pre>
<p>2.patsubst<br>替换通配符<br>格式</p>
<pre><code>$(patsubst %.c,%.o,$(dir))
</code></pre>
<p>示例：</p>
<pre><code>obj := $(patsubst %.c,%.o,$(wildcard *.c))
</code></pre>
<p>3.替换引用<br>patsubst的示例等价于：</p>
<pre><code>obj=$(dir:%.c=%.o)
</code></pre>
<p>引用替换：</p>
<pre><code>$(var:a=b) 或 ${var:a=b}
</code></pre>
<p>含义是把变量var中的每一个值，用b替换掉a</p>
<h1 id="PHONY"><a href="#PHONY" class="headerlink" title="PHONY"></a>PHONY</h1><p>Makefile执行的规则是A:B，表示A依赖于B</p>
<ul>
<li>有B才能执行A对应的编译操</li>
<li>B有更新(检测文件时间)，则A会执行，若B没有更新，不执行A</li>
</ul>
<p>问题来了，clean: 不需要依赖任何对象，如何执行<br>PHONY定义伪目标,可以解决源文件不是最终目标直接依赖（即间接依赖）带来的不能自动检查更新规则, 示例如下</p>
<pre><code>.PHONY: clean
clean:
    rm -f *.o
</code></pre>
<p>PHONY不仅用于clean，对于间接依赖也有用，例如A:B， B:C ，有时C为空，就需要把B定义为PHONY</p>
<pre><code>OBJS = *.o
program:  $(OBJS)
        gcc *.o -o program
 
.PHONY : $(OBJS)
$(OBJS):
        make -C $(dir $@)
</code></pre>
<p>不过一般情况，obj依赖于%.c，总之，对于没有依赖项的对象，需要定义为PHONY</p>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>常见通配符</p>
<pre><code>$@, $^, $&lt;, $?

$@  表示目标文件
$^  表示所有的依赖文件
$&lt;  表示第一个依赖文件
$?  表示比目标还要新的依赖文件列表
</code></pre>
<p>示例：<br>编译Test目录下的.cpp文件，输出test可执行程序<br>直接指定依赖文件名的makefile写法：</p>
<pre><code>test: $(wildcard Test/*.cpp)
	$(CXX) $(CFLAGS) -o test $(wildcard Test/*.cpp) 
</code></pre>
<p>虽然wildcard实现了所有依赖的.cpp的通配，编译语句再用wildcard写一次依赖文件不优雅，而且test在依赖中已经写了，编译语句又写一遍 -o test。<br>编译语句使用通配, 称为通用格式：</p>
<pre><code>test: $(wildcard Test/*.cpp)
	$(CXX) $(CFLAGS) -o $@ $^
</code></pre>
<h1 id="多个源文件分别编译"><a href="#多个源文件分别编译" class="headerlink" title="多个源文件分别编译"></a>多个源文件分别编译</h1><p>目录下有很多源文件，每个单独编译和执行的，将每一个文件编译成可执行文件，不用单独命名如：gcc -c xxx.c -o xxx<br>(1)Makefile实现</p>
<pre><code>SRC=$(wildcard *.c)
OBJ=$(SRC:%.c=%.o)
BIN=$(OBJ:%.o=%)
 
CC=gcc
CFLAGS=-Wall -g -c
 
all:$(BIN)

$(BIN):%:%.o
        $(CC) $^ -o $@
$(OBJ):%.o:%.c
        $(CC) $(CFLAGS) $^ -o $@

.PHONY: clean
clean:
        rm -rf $(OBJ) $(BIN)
</code></pre>
<p>(2)Shell实现</p>
<pre><code>#! /bin/bash
for file in ./*.c
do
if [ -f $file ]
then
file=${file#./}
target=${file%.c}
gcc -o $target $file
echo $target
fi
if [ -d $file ]
then
echo $file is mu lu
fi
done
</code></pre>
<p>(2)Makefile编译指定目录<br>Makefile可以输入参数，直接在make命令的后面加上参数，如:</p>
<pre><code>make BUILD_DIR=./foldername/
</code></pre>
<p>传入的变量将会覆盖相应Makefile中的<code>BUILD_DIR</code></p>
]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础 -- Vim使用笔记</title>
    <url>/2021/04/17/linux%E5%9F%BA%E7%A1%80%20--%20Vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最近在ChromeOS上做一些shell script测试用例开发，ChromeOS基于Debian9，但没有Ubuntu那种GNOME的gedit编辑器，更不谈安装Linux版VSCode，正好借此机会练习一下之前一直不熟悉的vim编辑器。</p>
<p>ChromeOS不方便截图，所以本文以ubuntu上的linux0.11代码为例，整理vim最常用的操作。</p>
<p>关于Linux上的文本编辑器基础概念，可以参考&lt;Linux命令行与shell脚本编程大全.第3版&gt;</p>
<h2 id="1-三种编辑模式"><a href="#1-三种编辑模式" class="headerlink" title="1. 三种编辑模式"></a>1. 三种编辑模式</h2><p>我将vim归为三种编辑模式：</p>
<ul>
<li><p>文本编辑模式<br>文本编辑模式是默认模式，vim编辑器会将按键解释成命令。在任意模式按esc进入此默认模式。</p>
</li>
<li><p>文本插入模式<br>文本插入模式， vim会将你在当前光标位置输入的每个键都插入到缓冲区，即文本输入字符。在普通模式下按下”i 键” 进入(含义:insert)</p>
</li>
<li><p>命令行模式<br>命令行模式和shell命令行类似，在普通模式下按下”: 键”进入(形似shell terminal的冒号)</p>
</li>
</ul>
<p>怎么知道当前处于哪种模式？<br>vim左下角是状态行，以下是三种模式的状态示例：</p>
<ul>
<li><code>vim init/main.c</code>默认进入文本编辑模式，下面显示文件名和行号<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171047554.png"></li>
</ul>
<p>输入i, 进入文本插入模式，下面显示insert状态<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171052433.png"></p>
<p>按esc退出文本编辑，再输入<code>:</code> 进入命令行模式，例如输入<code>:wq</code>保存文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171053124.png"></p>
<p>还有一种visual模式是复制粘贴时会用到：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181032041.png"></p>
<p>下面讲文本编辑模式和命令行模式的常用命令<br>主要分为几类场景：</p>
<ul>
<li>光标移动</li>
<li>增删改查</li>
<li>文件保存</li>
</ul>
<p>光标移动类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>移到第一行 (gg重来)</td>
</tr>
<tr>
<td>G</td>
<td>移到最后一行 (记为大G)</td>
</tr>
<tr>
<td>PageUp&#x2F;PageDown</td>
<td>翻页</td>
</tr>
<tr>
<td>:行号</td>
<td>光标移动到指定行(属于命令行模式)</td>
</tr>
</tbody></table>
<p>增删改查类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>进入insert模式，在当前光标的左侧输入</td>
</tr>
<tr>
<td>a</td>
<td>追加文本（append），在当前光标的右侧输入</td>
</tr>
<tr>
<td>o</td>
<td>插入空行，在空行光标处可输入</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行 (记为双击delete)</td>
</tr>
<tr>
<td>dw</td>
<td>删除当前词（记为delete word）</td>
</tr>
<tr>
<td>delete键，或x键</td>
<td>删除当前字符，注意，Backspace在vim没有删除的作用！</td>
</tr>
<tr>
<td>v+方向键选中+y</td>
<td>复制选中的文本，v: visual，可视光标选中的文本范围， y: yank 复制</td>
</tr>
<tr>
<td>yw</td>
<td>复制当前词</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p</td>
<td>在复制之后，粘贴文本(paste)，注意粘贴内容来自vim缓冲区，而不是外部剪切板的</td>
</tr>
<tr>
<td>dw&#x2F;dd + p</td>
<td>剪切，d操作删除的文本位于缓冲区，可以直接用p粘贴</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>(当前文件内)查找字符串，按n查找下一个</td>
</tr>
<tr>
<td>:s&#x2F;old&#x2F;new&#x2F;g</td>
<td>(当前文件内)全局查找和替换</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步</td>
</tr>
</tbody></table>
<p>文件保存类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:q!</td>
<td>不保存文件退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存文件退出</td>
</tr>
</tbody></table>
<h2 id="2-多文件编辑"><a href="#2-多文件编辑" class="headerlink" title="2.多文件编辑"></a>2.多文件编辑</h2><p>下面讲多个文本的常用命令<br>主要分为几类场景：</p>
<ul>
<li>多文本搜索</li>
<li>多文件编辑</li>
</ul>
<p>多文本搜索类：<br>参考<a href="https://thevaluable.dev/vim-search-find-replace/"># Vim Search and Replace With Examples</a><br>本文只以quickfix方式为例：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>:vimgrep pattern **</code></td>
<td>搜索当前目录和子目录的包含指定pattern的文件，vimgrep可缩写为vim, ** 表示递归子目录</td>
</tr>
<tr>
<td><code>:vimgrep pattern **/*.c</code></td>
<td>同上，只搜索.c文件</td>
</tr>
<tr>
<td>:copen</td>
<td>搜索完后使用此命令打开文件列表，才能用光标选择</td>
</tr>
<tr>
<td>:cn (cnext) 和 :cp (cprev)</td>
<td>上下选择搜索文件列表</td>
</tr>
</tbody></table>
<p>示例：搜索linux0.11下的所有包含main的.c文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171959744.png"></p>
<p>quickfix list即文件列表，copen后可方向键选择打开文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205172002631.png"></p>
<ul>
<li>多文件编辑<br><strong>打开多个文件，分隔并列显示</strong></li>
</ul>
<ol>
<li>用vim打开文件后，命令行输入<code>:vs newfile</code>，竖排并列打开新文件（vs是vertical split缩写，竖排分隔）</li>
<li>特殊用法：<code>:vs ./</code>可以打开当前路径下的所有文件列表</li>
<li>在窗口间切换：<code>ctrl + ww</code></li>
<li>关闭文件只需要先切换到窗口再<code>:q!</code></li>
<li>调整竖排的窗口比例：<br> 先按ctrl+w选择窗口模式，再按&lt;&gt;+-调整。&lt; 左移，&gt; 右移，+ 上移， - 下移。</li>
</ol>
<p>示例：实现类似IDE的界面，左侧是文件列表，下侧是查找栏，右侧文件内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181006035.png"></p>
<p>  <strong>打开多个文件，不并列显示</strong><br>直接<code>:open file</code>打开新文件, 用 <code>:bn 和 :bN</code> (buffer next)切换文件, </p>
<p>  <strong>多文件之间复制粘贴</strong><br>vim的多个文件直接可以直接用 y + p 命令复制粘贴，因为共用vim环境的缓冲区</p>
<p>  退出所有文件<br><code>:qall!</code> 和 <code>:wqall</code></p>
<h2 id="3-类似IDE的跳转功能"><a href="#3-类似IDE的跳转功能" class="headerlink" title="3.类似IDE的跳转功能"></a>3.类似IDE的跳转功能</h2><p>推荐cscope插件，具体参考<a href="http://cscope.sourceforge.net/cscope_vim_tutorial.html">## The Vim&#x2F;Cscope tutorial</a></p>
<p>关键步骤：</p>
<ul>
<li>建立cscope.vim<br>将  <a href="http://cscope.sourceforge.net/cscope_maps.vim">http://cscope.sourceforge.net/cscope_maps.vim</a>  另存到文件<code>~/.vim/plugin/cscope_maps.vim</code></li>
<li>源码目录建立cscope.out<br><code>cscope -R</code> 建立符号索引，<code>ctrl+D</code> 退出</li>
<li>打开某符号的代码<br>例如 <code>vim -t main</code> 打开main所在文件</li>
<li>查找函数的定义和调用<br>如果光标已经在函数上，用 “<code>ctrl +＼</code>“ 再输入s，查找所有调用、定义该函数的列表，输入索引号回车<br>更推荐用cscope的命令行，<code>:cs f s 函数名</code> 是一样的结果，且光标不需要位于函数上。参数含义 f: find, s: symbol<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181103274.png"></li>
<li>跳转回之前的位置<br>“<code>ctrl + t</code></li>
</ul>
<h2 id="4-vim配置文件修改配色，行号"><a href="#4-vim配置文件修改配色，行号" class="headerlink" title="4.vim配置文件修改配色，行号"></a>4.vim配置文件修改配色，行号</h2><p>在有的Linux服务器上，Vim默认深蓝色亮瞎眼，修改配色为流行的Molokai.</p>
<p>效果对比:</p>
<p>默认配色看不清注释内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061435384.png" alt="image-20221206143528332"><br>Molokai配色<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061437401.png" alt="image-20221206143701354"></p>
<p>配置过程：</p>
<p>默认的配色方案：</p>
<pre><code>ls /usr/share/vim/vim74/colors
</code></pre>
<p>下载molokai配色文件,拷贝到vim配色文件目录</p>
<pre><code>cd ~
git clone git@github.com:tomasr/molokai.git
cd molokai/colors
cp molokai.vim /usr/share/vim/vim74/colors
</code></pre>
<p>在home下创建.vimrc用于配色详细设置</p>
<pre><code>cd ~
vim .vimrc
</code></pre>
<p>.vimrc设置如下：</p>
<pre><code>  set t_Co=256
  set background=dark
  set ts=4
  set nu!
  syntax on
  colorscheme molokai
</code></pre>
<p><code>:wq</code>保存后即生效<br>如果要全局用户通用，<code>vim /etc/vimrc</code></p>
]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础 -- 命令行笔记</title>
    <url>/2020/02/15/linux%E5%9F%BA%E7%A1%80%20--%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="查找包含指定内容的文件"><a href="#查找包含指定内容的文件" class="headerlink" title="查找包含指定内容的文件"></a>查找包含指定内容的文件</h2><pre><code>grep -r 字符串 目录
</code></pre>
<p>示例：查找当前目录的包含“stream”内容的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -r &quot;stream&quot; ./</span><br></pre></td></tr></table></figure>

<h2 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip xxx.zip -r &lt;DIR&gt;  </span><br><span class="line">unzip xxx.zip -d &lt;DIR&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统 -- Arch Linux安装和配置笔记</title>
    <url>/2023/07/12/linux%E7%B3%BB%E7%BB%9F%20--%20Arch%20Linux%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近Debian12发布，尝鲜在移动硬盘装了Debian12+KDE，但不习惯Debian繁琐的包管理和Ubuntu越来越商业化的行为，最终切换到ArchLinux，进入Pacman和AUR的包管理和滚动更新风格。此文记录ArchLinux安装配置过程。</p>
<h2 id="构建多系统的U盘启动盘"><a href="#构建多系统的U盘启动盘" class="headerlink" title="构建多系统的U盘启动盘"></a>构建多系统的U盘启动盘</h2><p>使用<a href="https://www.ventoy.net/en/doc_start.html">ventoy&#x2F;Start to use Ventoy</a>，将各系统镜像放到Ventoy目录即可，不需要用传统的UltraISO那种一个系统ISO要占用整个U盘。<br>Arch Linux的ISO<a href="https://archlinux.org/download/">在此下载</a></p>
<h2 id="使用archinstall安装ArchLinux"><a href="#使用archinstall安装ArchLinux" class="headerlink" title="使用archinstall安装ArchLinux"></a>使用archinstall安装ArchLinux</h2><p><a href="https://wiki.archlinux.org/title/Installation_guide">传统的ArchLinux安装方式</a>过于繁琐，现在Arch Linux安装包提供一个类GUI的脚本<a href="https://wiki.archlinux.org/title/Archinstall">archinstall</a>，按需求配置即可，可以一键处理包括KDE&#x2F;GNOME&#x2F;I3W等桌面在内的全部安装过程。</p>
<p>参考 <a href="https://www.linuxmi.com/archinstall-auto-arch-linux.html">使用 archinstall 自动化脚本安装 Arch Linux 完整指南</a>，<a href="https://u.sb/archlinux-archinstall/">使用 archinstall 安装 Arch Linux 和 KDE 桌面环境</a>。</p>
<p>我的配置如下。Profile选择安装desktop Kde, Network选择Use NetworkManager后，Kde Plasma被自动安装，不需要按参考文章手动安装桌面：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307121642425.png" alt="image-20230712164243209"></p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>kde主题应用直接安装主题基本会失败，需要去<a href="https://store.kde.org/browse/">KDE store</a>下载主题并按主题的README配置</p>
<p>一个风格统一的主题包含几个部分：Global theme，包括桌面(desktop)，图标(icon)，鼠标(cursor)，壁纸(wallpaper)，也可以包含登录界面(sddm)和启动界面(GRUB)</p>
<p>(1)配置桌面</p>
<p>下面配置MacOS风格的 <a href="https://store.kde.org/p/1400424/">WhiteSur Dark</a>，建议在Github下载完整主题:<a href="https://github.com/vinceliuice/WhiteSur-kde">WhiteSur-kde</a></p>
<p>使用<code>./install.sh</code>安装主题，其内部操作就是拷贝各部分配置文件到系统配置目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r $&#123;SRC_DIR&#125;/aurorae/normal/$&#123;name&#125;$&#123;color&#125;* $&#123;AURORAE_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/Kvantum/$&#123;name&#125; $&#123;KVANTUM_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/wallpaper/$&#123;name&#125;* $&#123;WALLPAPER_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/latte-dock/* $&#123;LATTE_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/color-schemes/* $&#123;SCHEMES_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/plasma/desktoptheme/$&#123;name&#125;$&#123;pcolor&#125; $&#123;PLASMA_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/plasma/desktoptheme/icons $&#123;PLASMA_DIR&#125;/$&#123;name&#125;$&#123;pcolor&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中的latte-dock只是配置文件，需要先安装latte-dock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -S latte-dock</span><br></pre></td></tr></table></figure>

<p>主题安装完毕后，在系统System Setting -&gt; Appearance -&gt; Global Theme的子目录apply各模块</p>
<p>(2)配置登录界面</p>
<p>登录界面SDDM需要独立安装，在WhiteSur-kde的sddm目录运行<code>install.sh</code>安装sddm，之后可在系统System Setting -&gt; Startup and Shutdown中设置sddm为WhiteSur。</p>
<p>(3)配置启动界面</p>
<p>Arch linux默认没有GRUB，需要<a href="https://wiki.archlinux.org/title/GRUB">安装GRUB</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S grub efibootmgr</span><br><span class="line">sudo grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br></pre></td></tr></table></figure>

<p>以 <a href="https://store.kde.org/p/1603282">Dark Matter GRUB Theme</a>为例，按github的install guide安装即可。</p>
<p>GRUB配置文件位于&#x2F;etc&#x2F;default&#x2F;grub，修改后使用update-grub生效。</p>
<h2 id="中文显示和中文输入法"><a href="#中文显示和中文输入法" class="headerlink" title="中文显示和中文输入法"></a>中文显示和中文输入法</h2><p>打开网页有中文乱码（方框），需要安装noto-fonts相关字体包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br></pre></td></tr></table></figure>

<p>安装中文输入法框架（包含pinyin输入法）并配置fcitx5，具体含义参考 <a href="https://wiki.archlinux.org/title/Input_method">Input method</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im fcitx5-chinese-addons  fcitx5-rime</span><br></pre></td></tr></table></figure>
<p>在desktop environment配置fcitx:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/environment</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>

<p>重启，按 <code>Win</code> 键搜索 <code>Input Method</code>, 点击 <code>Add Input Method...</code>搜索 <code>pinyin</code> 然后添加，按 <code>Ctrl</code> + <code>空格</code>可切换输入法</p>
<h2 id="安装yay以使用AUR"><a href="#安装yay以使用AUR" class="headerlink" title="安装yay以使用AUR"></a>安装yay以使用AUR</h2><p><a href="https://aur.archlinux.org/packages/yay">yay</a>: Yet another yogurt. Pacman wrapper and AUR helper written in go.</p>
<p>yay的安装参考: <a href="https://www.debugpoint.com/install-yay-arch/">How to Install yay AUR Helper in Arch Linux [Beginner’s Guide]</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S base-devel git</span><br><span class="line">cd /opt</span><br><span class="line">sudo git clone https://aur.archlinux.org/yay.git</span><br><span class="line">cd yay</span><br><span class="line">sudo chown -R 用户名:users .   #必须修改yay目录的owner, yay不能被sudo编译</span><br><span class="line">makepkg -si  #编译yay</span><br></pre></td></tr></table></figure>

<h2 id="Go语言包换源"><a href="#Go语言包换源" class="headerlink" title="Go语言包换源"></a>Go语言包换源</h2><p>安装yay时makepkg会显示go包安装timeout, 需要换国内源 <a href="https://goproxy.cn/">goprixy.cn</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#临时生效</span><br><span class="line">$ export GO111MODULE=on</span><br><span class="line">$ export GOPROXY=https://goproxy.cn</span><br><span class="line"></span><br><span class="line">#永久生效</span><br><span class="line">$ echo &quot;export GO111MODULE=on&quot; &gt;&gt; ~/.profile</span><br><span class="line">$ echo &quot;export GOPROXY=https://goproxy.cn&quot; &gt;&gt; ~/.profile</span><br><span class="line">$ source ~/.profile</span><br></pre></td></tr></table></figure>

<h2 id="pacman-yay换源"><a href="#pacman-yay换源" class="headerlink" title="pacman&#x2F;yay换源"></a>pacman&#x2F;yay换源</h2><p>在archinstall时如果Mirror region选择China，则默认使用官方提供的China源，见&#x2F;etc&#x2F;pacman.conf的[core&#x2F;extra]字段都版本了&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist. </p>
<p>但官方源速度有时很慢，建议手动添加<a href="https://mirrors.tuna.tsinghua.edu.cn/help/archlinuxcn/">archlinuxcn源</a>，如果包在国内源有的话，yay速度直接起飞</p>
<p>有网上建议生成aur配置文件换国内源：<code>yay --aururl “https://aur.tuna.tsinghua.edu.cn” --save</code> 此处不建议，如果国内源没有的包将无法下载；换回官方源：<code>yay --aururl &quot;https://aur.archlinux.org&quot; --save</code>，并删除yay源配置文件<code>~/.config/yay/config.json</code></p>
<h2 id="yay常用命令"><a href="#yay常用命令" class="headerlink" title="yay常用命令"></a>yay常用命令</h2><p>从仓库和 AUR 中交互式搜索和安装软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay &#123;&#123;软件包|搜索词&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>同步并更新所有来自仓库和 AUR 的软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay</span><br></pre></td></tr></table></figure>

<p>从仓库和 AUR 中安装一个新的软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -S &#123;&#123;软件包&#125;&#125;</span><br><span class="line">yay -Sy &#123;&#123;软件包&#125;&#125; #默认yes</span><br></pre></td></tr></table></figure>

<p>从仓库和 AUR 中搜索软件包数据库中的关键词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -Ss &#123;&#123;关键词&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>显示已安装软件包和系统健康状况的统计数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -Ps</span><br></pre></td></tr></table></figure>
<p>卸载包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -R </span><br></pre></td></tr></table></figure>

<h2 id="pacman更新系统"><a href="#pacman更新系统" class="headerlink" title="pacman更新系统"></a>pacman更新系统</h2><p>更新所有安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syu #仅更新</span><br><span class="line">sudo pacman -Syyu #如果系统有损坏包，能覆盖下载</span><br></pre></td></tr></table></figure>

<h2 id="Host-DNS设置"><a href="#Host-DNS设置" class="headerlink" title="Host DNS设置"></a>Host DNS设置</h2><p>NetworkManager会自动配置DNS域名解析文件&#x2F;etc&#x2F;resolv.conf，且手动修改的内容每次重启会被NetworkManager覆盖。</p>
<p>如果要手动配置，参考 <a href="https://wiki.archlinux.org/title/NetworkManager">&#x2F;etc&#x2F;resolv.conf</a>，设置dns.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/NetworkManager/conf.d/dns.conf</span><br><span class="line">[main]</span><br><span class="line">dns=none</span><br></pre></td></tr></table></figure>

<h2 id="KDE-Discover显示unable-to-load-applications"><a href="#KDE-Discover显示unable-to-load-applications" class="headerlink" title="KDE Discover显示unable to load applications"></a>KDE Discover显示unable to load applications</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S packagekit-qt5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux系统</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统 -- Debian12 Gnome配置笔记</title>
    <url>/2023/08/11/linux%E7%B3%BB%E7%BB%9F%20--%20Debian12%20Gnome%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="设置sudo"><a href="#设置sudo" class="headerlink" title="设置sudo"></a>设置sudo</h3><p>普通用户(以username为例)并没有被加入sudo用户组，不能使用sudo命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username@debian:~$ sudo apt install xxx</span><br><span class="line">username is not in the sudoers file.</span><br></pre></td></tr></table></figure>

<p>有两种方式：</p>
<ol>
<li><p>在su下用visudo(nano也可以)编辑&#x2F;etc&#x2F;sudoers文件，新增username使sudo能获取root权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">username ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
</li>
<li><p>在su下用usermod -aG sudo username，将username添加到sudo组，由于&#x2F;etc&#x2F;sudoers的如下设置已经将sudo组设为root权限，所以这个操作等效于使username能用sudo获取root权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%sudo ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>sbin的命令not found问题：执行visudo或usermod时，发现command not found. Debug过程如下：</li>
</ul>
<p>​		使用whereis visudo查看路径是&#x2F;usr&#x2F;sbin；echo $PATH没有&#x2F;usr&#x2F;sbin，因此是环境变量问题。</p>
<p>   方式一：在username的~&#x2F;.bashrc下添加sbin到PATH，生效之后sbin目录的命    令才可执行：</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano .bashrc</span><br><span class="line">export PATH=$PATH:/usr/sbin</span><br><span class="line">source ~/.bashrc</span><br><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p>   方式二：另外一种方式是加软链接，需要一个个添加</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/sbin/visudo /usr/bin/visudo</span><br></pre></td></tr></table></figure>

<ul>
<li>如何退出su：使用exit，或su username，切换到username用户</li>
</ul>
<h3 id="设置apt源"><a href="#设置apt源" class="headerlink" title="设置apt源"></a>设置apt源</h3><ul>
<li>使用iso安装的debian，首先需要取消从iso安装软件的选项：</li>
</ul>
<p>​		software&amp;update -&gt; Other Software -&gt; 取消勾选cdrom</p>
<ul>
<li>再选择国内源, 例如China-&gt; mirrors.163.com&#x2F;debian，并选中main&#x2F;free&#x2F;non-free各种下载选项。</li>
<li>如果refresh cache界面卡死，使用<code>apt update</code>手动更新源。</li>
</ul>
<h3 id="设置gnome-shell"><a href="#设置gnome-shell" class="headerlink" title="设置gnome shell"></a>设置gnome shell</h3><p>gnome shell即gnome的桌面</p>
<p>(1)通过extensions自定义桌面插件</p>
<p>参考：<a href="https://itsfoss.com/gnome-shell-extensions/#:~:text=Installing%20GNOME%20Shell%20Extensions%201%20Use%20gnome-shell-extensions%20package,3%20Install%20GNOME%20Shell%20Extensions%20manually.%20See%20More.">How to Use GNOME Shell Extensions [Complete Guide]</a></p>
<p>可以通过gnome-shell-extension-manager直接安装extension，无需到网站下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-shell-extension-manager</span><br></pre></td></tr></table></figure>

<p>推荐安装Dash to Dock和Arc Menu</p>
<p>(2)修改主题(theme)</p>
<p>参考 <a href="https://itsfoss.com/install-switch-themes-gnome-shell/">How to Install and Change GNOME Theme in Linux</a></p>
<p>打开extensions的User Themes插件后才可以安装自定义themes</p>
<p>手动安装单个GTK主题的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建放置themes的目录</span><br><span class="line">mkdir ~/.themes</span><br><span class="line">#从gnome-look下载themes,放到.themes目录，Ctrl+H打开隐藏目录</span><br><span class="line">https://www.gnome-look.org/browse/</span><br><span class="line">#打开gnome tweak(默认已安装)，Appearance -&gt; Shell -&gt; 使用themes</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>要完整桌面主题效果，需要安装gtk-theme，icon-theme，cursor-theme等多类theme。例如WhileSur，要达到和MacOS一样的效果，需要去GTK3&#x2F;4 themes, Full Icon Themes，Cursors分别下载top5的WhileSur主题。一个主题可能有多种模式，按github install.sh能完整安装各种模式，手动下载只能安装一种模式。</li>
<li>注意gnome桌面是基于GTK，GTK is a multi-platform toolkit for creating graphical user interfaces. 所以是在gtk-theme而不是gnome-shell找。</li>
<li>要自定义登录界面的主题，去GDM themes找top5(改GDM需要先安装loginized)；要自定义GRUB主题，去GRUB themes找。</li>
<li>Top 10 themes: <a href="https://itsfoss.com/best-gtk-themes/">best-gtk-themes</a></li>
</ul>
]]></content>
      <categories>
        <category>linux系统</category>
      </categories>
      <tags>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动 -- PCI访问硬件分析与SD express调试记录</title>
    <url>/2023/08/25/linux%E9%A9%B1%E5%8A%A8%20--%20PCI%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6%E5%88%86%E6%9E%90%E4%B8%8ESD%20express%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="linux驱动-–-PCI访问硬件分析与SD-express调试记录"><a href="#linux驱动-–-PCI访问硬件分析与SD-express调试记录" class="headerlink" title="linux驱动 – PCI访问硬件分析与SD express调试记录"></a>linux驱动 – PCI访问硬件分析与SD express调试记录</h1><h2 id="系统侧调试PCI设备"><a href="#系统侧调试PCI设备" class="headerlink" title="系统侧调试PCI设备"></a>系统侧调试PCI设备</h2><h3 id="PCI-tree结构"><a href="#PCI-tree结构" class="headerlink" title="PCI tree结构"></a>PCI tree结构</h3><p>关于PCIe tree的bus&#x2F;device的详细architecture，参考LDD3和Mastering Linux Device Driver Development - John Madieu</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291114824.png" alt="image-20230829111444515"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291117111.png" alt="image-20230829111727760"></p>
<blockquote>
<p>Root complex (RC): This refers to the PCIe host controller in the SoC. It can access the main memory without CPU intervening, which is a feature used by other devices to access the main memory. They are also known as Host-to-PCI bridges.</p>
<p>Bridges: These provide an interface to other buses, such as PCI or PCI X, or even another PCIe bus. A bridge can also provide an interface to the same bus</p>
<p>Endpoint (EP): Endpoints are PCIe devices, and are represented by type 00h configuration space headers. They never appear on a switch’s internal bus and have no downstream port</p>
</blockquote>
<h3 id="lspci使用示例"><a href="#lspci使用示例" class="headerlink" title="lspci使用示例"></a>lspci使用示例</h3><p>下面介绍如何找到一个PCI(e)设备的信息，及其上游端口信息，以及设备的register space内容</p>
<p>(1)查看所有pci设备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 11th Gen Core Processor Host Bridge/DRAM Registers (rev 01)</span><br><span class="line">00:02.0 VGA compatible controller: Intel Corporation TigerLake-LP GT2 [Iris Xe Graphics] (rev 01)</span><br><span class="line">00:04.0 Signal processing controller: Intel Corporation TigerLake-LP Dynamic Tuning Processor Participant (rev 01)</span><br><span class="line">00:05.0 Multimedia controller: Intel Corporation Device 9a19 (rev 01)</span><br><span class="line">00:07.0 PCI bridge: Intel Corporation Tiger Lake-LP Thunderbolt 4 PCI Express Root Port #0 (rev 01)</span><br><span class="line">00:07.1 PCI bridge: Intel Corporation Tiger Lake-LP Thunderbolt 4 PCI Express Root Port #1 (rev 01)</span><br><span class="line">00:07.2 PCI bridge: Intel Corporation Tiger Lake-LP Thunderbolt 4 PCI Express Root Port #2 (rev 01)</span><br><span class="line">00:07.3 PCI bridge: Intel Corporation Tiger Lake-LP Thunderbolt 4 PCI Express Root Port #3 (rev 01)</span><br><span class="line">...</span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation Tiger Lake-LP PCI Express Root Port #8 (rev 20)</span><br><span class="line">...</span><br><span class="line">a9:00.0 Non-Volatile memory controller: Device 0012:1cc1</span><br></pre></td></tr></table></figure>

<p>(2)查看PCI设备上下游信息</p>
<p>下面关注PCIe device a9:00.0, 用 lspci -v (verbose)查看详细信息:</p>
<p>是一个nvme设备，使用的driver是nvme；device id是0012:1cc1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~$ lspci -v</span><br><span class="line">a9:00.0 Non-Volatile memory controller: Device 0012:1cc1 (prog-if 02 [NVM Express])</span><br><span class="line">	Subsystem: Device 3456:5344</span><br><span class="line">	Physical Slot: 7</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 19, NUMA node 0, IOMMU group 20</span><br><span class="line">	Memory at 88c00000 (64-bit, non-prefetchable) [size=16K]</span><br><span class="line">	Capabilities: &lt;access denied&gt;</span><br><span class="line">	Kernel driver in use: nvme</span><br><span class="line">	Kernel modules: nvme</span><br></pre></td></tr></table></figure>

<p>查看这个设备的上游信息，包括它所在的PCIe bridge（即PCIe port，端口也是PCI设备）</p>
<p>如下lspci -t (tree)列出PCI tree，其中[]内的是bus号，-xx.x是设备号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~$ lspci -t</span><br><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-02.0</span><br><span class="line">           +-04.0</span><br><span class="line">           +-05.0</span><br><span class="line">           +-07.0-[01-2a]--</span><br><span class="line">           +-07.1-[2b-54]--</span><br><span class="line">           +-07.2-[55-7e]--</span><br><span class="line">           +-07.3-[7f-a8]--</span><br><span class="line">          ....</span><br><span class="line">           +-1c.0-[a9]----00.0</span><br><span class="line">           +-1d.0-[aa]--</span><br><span class="line">          ....</span><br><span class="line">           \-1f.6</span><br></pre></td></tr></table></figure>

<p>我们关注的设备a9:00.0表示该设备的 bus是a9, device是00.0，对应PCI tree的 [a9]—-00.0</p>
<p>其上游设备是1c.0，完整设备号为00:1c.0，是个PCIe bridge；每个bridge都是PCIe设备，只不过它比较特殊，是连接其他PCIe设备的设备。根据lspci信息查看该PCIe bridge为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00:1c.0 PCI bridge: Intel Corporation Tiger Lake-LP PCI Express Root Port #8 (rev 20)</span><br></pre></td></tr></table></figure>

<p>PCIe bridge的更上游即bus 00，是PCIe RC (root complex)</p>
<p>上图中有的bridge可以支持一定范围的bus号，例如bus范围为01-2a：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-07.0-[01-2a]--</span><br></pre></td></tr></table></figure>

<p>(3)查看PCI设备的register space</p>
<p>使用<code>lspci -s [bus]:[device].[function] -xxxx</code> 查看完整的PCIe register space(需要root权限)， -s: show, <code>lspci --help</code>查看各选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~$ sudo lspci -s 00:1c.0 -xxxx (或者-xxx，显示00~ff)</span><br><span class="line">[sudo] password for cursorhu: </span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation Tiger Lake-LP PCI Express Root Port #8 (rev 20)</span><br><span class="line">00: 86 80 bf a0 07 04 10 00 20 00 04 06 00 00 81 00</span><br><span class="line">10: 00 00 00 00 00 00 00 00 00 a9 a9 00 40 40 00 20</span><br><span class="line">20: c0 88 50 89 01 7e 91 7e 60 00 00 00 60 00 00 00</span><br><span class="line">30: 00 00 00 00 40 00 00 00 00 00 00 00 ff 04 02 00</span><br><span class="line">40: 10 80 42 01 01 80 00 00 20 00 11 00 13 4c 72 08</span><br><span class="line">50: 42 00 13 70 60 b2 3c 00 08 10 40 00 08 00 00 00</span><br><span class="line">60: 00 00 00 00 37 08 00 00 00 04 00 00 0e 00 00 00</span><br><span class="line">70: 03 00 1f 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">80: 05 90 01 00 78 02 e0 fe 00 00 00 00 00 00 00 00</span><br><span class="line">90: 0d a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">a0: 01 00 03 c8 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">d0: 11 10 00 07 42 18 01 40 0a 00 9e 09 00 00 00 00</span><br><span class="line">e0: 00 03 e3 00 03 90 03 90 16 00 10 00 00 00 00 00</span><br><span class="line">f0: 50 01 00 00 00 00 00 4c b5 0f 21 01 04 00 00 84</span><br><span class="line">100: 01 00 01 22 00 00 00 00 00 40 00 00 11 00 06 00</span><br><span class="line">110: 01 20 00 00 00 20 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们要确认PCI bridge的 link status register(位于capability register offset 0x12, bit 13 Link active bit) 以知道 PCIe link 是否 active.<br>如何查看：如下图 0x00 ~ 0x3C 是config space标准空间；0x34 capability pointer是地址，指向capability register空间，其值为0x40，因此capability register空间是从0x40开始；因此 link status regsiter 是 0x40+0x12 &#x3D; 0x52, 其bit13 即 0x53 的 bit5. </p>
<p>详细register mapping参考PCI Express Base Spec.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291129433.png" alt="image-20230829112915119"></p>
<h3 id="PCI-device的创建过程"><a href="#PCI-device的创建过程" class="headerlink" title="PCI device的创建过程"></a>PCI device的创建过程</h3><p>参考LDD3 LDM(Linux Device Model)</p>
<p>PCI device包括PCI driver, PCI core driver, Kobject三个层次，并在用户层sysfs反映device和driver。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308301706671.png" alt="image-20230830170650433"></p>
<h3 id="使用sysfs操作pci-device"><a href="#使用sysfs操作pci-device" class="headerlink" title="使用sysfs操作pci device"></a>使用sysfs操作pci device</h3><p><strong>(1)使用&#x2F;sys&#x2F;bus&#x2F;pci文件接口对device操作：</strong></p>
<p>remove设备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /sys/bus/pci/devices/AAAA:BB:CC.D/remove</span><br></pre></td></tr></table></figure>

<p>AAAA:BB:CC.D为bus-info，分别为<a href="https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-bus-pci">Domain:Bus:Device.Function</a></p>
<p>rescan设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /sys/bus/pci/rescan</span><br></pre></td></tr></table></figure>

<p>reset设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /sys/bus/pci/devices/AAAA:BB:CC.D/reset</span><br></pre></td></tr></table></figure>

<p><strong>(2) lspci &amp; dmesg &amp; 源码 分析：</strong></p>
<p>首先lspci设备，以设备03:00.0 (SD Host controller)为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~/linuxkernel/linux-6.2$ lspci</span><br><span class="line">...</span><br><span class="line">00:1c.7 PCI bridge: Intel Corporation Cannon Lake PCH PCI Express Root Port #8 (rev f0)</span><br><span class="line">...</span><br><span class="line">03:00.0 SD Host controller: O2 Micro, Inc. Device 9862 (rev 01)</span><br></pre></td></tr></table></figure>

<p>remove设备：</p>
<p>非root用户执行时需要用sudo sh -c “命令内容”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo 1 &gt; /sys/bus/pci/devices/0000:03:00.0/remove&quot;</span><br></pre></td></tr></table></figure>

<p>dmesg显示remove调用了该device driver的 .remove</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 241.962185] BHT-OSENTRY: BHT sd remove begin</span><br></pre></td></tr></table></figure>

<p>remove之后<code>lspci</code>看不到设备03:00.0，<code>lspci -t</code>可见其bus号03下挂的设备为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~/linuxkernel/linux-6.2$ lspci -t</span><br><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-02.0</span><br><span class="line">           +-12.0</span><br><span class="line">           +-14.0</span><br><span class="line">           +-14.2</span><br><span class="line">           +-16.0</span><br><span class="line">           +-17.0</span><br><span class="line">           +-1b.0-[01]--</span><br><span class="line">           +-1c.0-[02]--</span><br><span class="line">           +-1c.7-[03]--</span><br><span class="line">           +-1d.0-[04]--</span><br><span class="line">           +-1f.0</span><br><span class="line">           +-1f.3</span><br><span class="line">           +-1f.4</span><br><span class="line">           +-1f.5</span><br><span class="line">           \-1f.6</span><br></pre></td></tr></table></figure>

<p>rescan设备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo 1 &gt; /sys/bus/pci/rescan&quot;</span><br></pre></td></tr></table></figure>

<p>再<code>lspci -t</code>可见其bus号03下挂的设备为为00.0，即设备的[bus:device.function]为03:00.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-02.0</span><br><span class="line">           +-12.0</span><br><span class="line">           +-14.0</span><br><span class="line">           +-14.2</span><br><span class="line">           +-16.0</span><br><span class="line">           +-17.0</span><br><span class="line">           +-1b.0-[01]--</span><br><span class="line">           +-1c.0-[02]--</span><br><span class="line">           +-1c.7-[03]----00.0</span><br><span class="line">           +-1d.0-[04]--</span><br><span class="line">           +-1f.0</span><br><span class="line">           +-1f.3</span><br><span class="line">           +-1f.4</span><br><span class="line">           +-1f.5</span><br><span class="line">           \-1f.6</span><br></pre></td></tr></table></figure>

<p>dmesg显示rescan调用了该device driver的 .probe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 617.171735] BHT-OSENTRY: BHT sd probe begin</span><br></pre></td></tr></table></figure>

<p>reset设备：</p>
<p>备份设备的config register 0x0~0x3C，然后调用<a href="https://elixir.bootlin.com/linux/latest/source/drivers/pci/pci.c#L5555">pci_dev_restore</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* This function does not just reset the PCI portion of a device, but</span><br><span class="line"> * clears all the state associated with the device.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 1116.993784] bht-sd 0000:03:00.0: saving config space at offset 0x0 (reading 0x98621217)</span><br><span class="line">[ 1116.993790] bht-sd 0000:03:00.0: saving config space at offset 0x4 (reading 0x100406)</span><br><span class="line">[ 1116.993793] bht-sd 0000:03:00.0: saving config space at offset 0x8 (reading 0x8050101)</span><br><span class="line">[ 1116.993796] bht-sd 0000:03:00.0: saving config space at offset 0xc (reading 0x10)</span><br><span class="line">[ 1116.993798] bht-sd 0000:03:00.0: saving config space at offset 0x10 (reading 0x51100000)</span><br><span class="line">[ 1116.993801] bht-sd 0000:03:00.0: saving config space at offset 0x14 (reading 0x51101000)</span><br><span class="line">[ 1116.993804] bht-sd 0000:03:00.0: saving config space at offset 0x18 (reading 0x0)</span><br><span class="line">[ 1116.993806] bht-sd 0000:03:00.0: saving config space at offset 0x1c (reading 0x0)</span><br><span class="line">[ 1116.993809] bht-sd 0000:03:00.0: saving config space at offset 0x20 (reading 0x0)</span><br><span class="line">[ 1116.993811] bht-sd 0000:03:00.0: saving config space at offset 0x24 (reading 0x0)</span><br><span class="line">[ 1116.993813] bht-sd 0000:03:00.0: saving config space at offset 0x28 (reading 0x0)</span><br><span class="line">[ 1116.993816] bht-sd 0000:03:00.0: saving config space at offset 0x2c (reading 0x21217)</span><br><span class="line">[ 1116.993818] bht-sd 0000:03:00.0: saving config space at offset 0x30 (reading 0x0)</span><br><span class="line">[ 1116.993821] bht-sd 0000:03:00.0: saving config space at offset 0x34 (reading 0x6c)</span><br><span class="line">[ 1116.993823] bht-sd 0000:03:00.0: saving config space at offset 0x38 (reading 0x0)</span><br><span class="line">[ 1116.993826] bht-sd 0000:03:00.0: saving config space at offset 0x3c (reading 0x10b)</span><br><span class="line">[ 1118.015083] pcieport 0000:00:1c.7: re-enabling LTR</span><br><span class="line">[ 1118.015133] bht-sd 0000:03:00.0: restoring config space at offset 0x3c (was 0x100, writing 0x10b)</span><br><span class="line">[ 1118.015170] bht-sd 0000:03:00.0: restoring config space at offset 0x14 (was 0x0, writing 0x51101000)</span><br><span class="line">[ 1118.015191] bht-sd 0000:03:00.0: restoring config space at offset 0x10 (was 0x0, writing 0x51100000)</span><br><span class="line">[ 1118.015205] bht-sd 0000:03:00.0: restoring config space at offset 0xc (was 0x0, writing 0x10)</span><br><span class="line">[ 1118.015227] bht-sd 0000:03:00.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100406)</span><br></pre></td></tr></table></figure>

<h2 id="PCI驱动寄存器访问接口"><a href="#PCI驱动寄存器访问接口" class="headerlink" title="PCI驱动寄存器访问接口"></a>PCI驱动寄存器访问接口</h2><h3 id="PCI-driver的register-access-API分析"><a href="#PCI-driver的register-access-API分析" class="headerlink" title="PCI driver的register access API分析"></a>PCI driver的register access API分析</h3><p>API在LDD3的PCI driver一章已经有较详细说明：</p>
<p>*<em>Linux offers a standard interface to access the configuration space.</em><br><em>As far as the driver is concerned, the configuration space can be accessed through 8-</em><br><em>bit, 16-bit, or 32-bit data transfers. The relevant functions are prototyped in &lt;linux&#x2F;*<br>pci.h&gt;</em>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pci_read_config_byte(struct pci_dev *dev, int where, u8 *val);</span><br><span class="line">int pci_read_config_word(struct pci_dev *dev, int where, u16 *val);</span><br><span class="line">int pci_read_config_dword(struct pci_dev *dev, int where, u32 *val);</span><br><span class="line">int pci_write_config_byte(struct pci_dev *dev, int where, u8 val);</span><br><span class="line">int pci_write_config_word(struct pci_dev *dev, int where, u16 val);</span><br><span class="line">int pci_write_config_dword(struct pci_dev *dev, int where, u32 val);</span><br></pre></td></tr></table></figure>

<p>内部实现实际是pci_bus_read_config_word，参考：<a href="https://elixir.bootlin.com/linux/latest/source/drivers/pci/access.c#L554">access.c#L554</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pci_read_config_word(const struct pci_dev *dev, int where, u16 *val)</span><br><span class="line">&#123;</span><br><span class="line">	if (pci_dev_is_disconnected(dev)) &#123;</span><br><span class="line">		PCI_SET_ERROR_RESPONSE(val);</span><br><span class="line">		return PCIBIOS_DEVICE_NOT_FOUND;</span><br><span class="line">	&#125;</span><br><span class="line">	return pci_bus_read_config_word(dev-&gt;bus, dev-&gt;devfn, where, val);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(pci_read_config_word);</span><br></pre></td></tr></table></figure>

<p>pci_bus_read_config_word的内部实现LDD3也说了：</p>
<p><em><em>The actual implementation of pci_read_config_byte(dev, where, val), for instance, expands to:</em><br>dev-&gt;bus-&gt;ops-&gt;read(bus, devfn, where, 8, val);</em>  </p>
<p>其中bus-&gt;ops使用pci_ops结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct pci_ops &#123;</span><br><span class="line">int (*read)(struct pci_bus *bus, unsigned int devfn, int where, int size,</span><br><span class="line">u32 *val);</span><br><span class="line">int (*write)(struct pci_bus *bus, unsigned int devfn, int where, int size,</span><br><span class="line">u32 val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pci_read_config_byte的实现是宏函数，使用##连接符动态定义byte, word, dword，因此直接搜索不到，实际还是在<a href="https://elixir.bootlin.com/linux/latest/source/drivers/pci/access.c#L74">access.c#L74</a>，就在EXPORT_SYMBOL(pci_bus_read_config_word); 的前面定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PCI_OP_READ(size, type, len) \</span><br><span class="line">int noinline pci_bus_read_config_##size \</span><br><span class="line">	(struct pci_bus *bus, unsigned int devfn, int pos, type *value)	\</span><br><span class="line">&#123;									\</span><br><span class="line">	int res;							\</span><br><span class="line">	unsigned long flags;						\</span><br><span class="line">	u32 data = 0;							\</span><br><span class="line">	if (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	\</span><br><span class="line">	pci_lock_config(flags);						\</span><br><span class="line">	res = bus-&gt;ops-&gt;read(bus, devfn, pos, len, &amp;data);		\</span><br><span class="line">	if (res)							\</span><br><span class="line">		PCI_SET_ERROR_RESPONSE(value);				\</span><br><span class="line">	else								\</span><br><span class="line">		*value = (type)data;					\</span><br><span class="line">	pci_unlock_config(flags);					\</span><br><span class="line">	return res;							\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么bus-&gt;ops-&gt;read的底层实现到底是什么？取决于cpu和pci架构，例如arm&#x2F;x86&#x2F;ia64…</p>
<p>全局搜索定义struct pci_ops的代码即可见，以<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/pci/common.c#L72">x86为例</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct pci_ops pci_root_ops = &#123;</span><br><span class="line">	.read = pci_read,</span><br><span class="line">	.write = pci_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *value)</span><br><span class="line">&#123;</span><br><span class="line">	return raw_pci_read(pci_domain_nr(bus), bus-&gt;number,</span><br><span class="line">				 devfn, where, size, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int raw_pci_read(unsigned int domain, unsigned int bus, unsigned int devfn,</span><br><span class="line">						int reg, int len, u32 *val)</span><br><span class="line">&#123;</span><br><span class="line">	if (domain == 0 &amp;&amp; reg &lt; 256 &amp;&amp; raw_pci_ops)</span><br><span class="line">		return raw_pci_ops-&gt;read(domain, bus, devfn, reg, len, val);</span><br><span class="line">	if (raw_pci_ext_ops)</span><br><span class="line">		return raw_pci_ext_ops-&gt;read(domain, bus, devfn, reg, len, val);</span><br><span class="line">	return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>struct</em> pci_raw_ops有几处定义，direct.c, mmconfig_32.c, mmconfig_64.c, 分别对应不同的访问方式。下面以<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/pci/direct.c#L83">direct.c中的实现</a>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const struct pci_raw_ops pci_direct_conf1 = &#123;</span><br><span class="line">	.read =		pci_conf1_read,</span><br><span class="line">	.write =	pci_conf1_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct pci_raw_ops pci_direct_conf2 = &#123;</span><br><span class="line">	.read =		pci_conf2_read,</span><br><span class="line">	.write =	pci_conf2_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有两种direct config访问方式，区别在于指令结构不一样，参考PCI express base spec 的 Configuration Space Header。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Functions for accessing PCI base (first 256 bytes) and extended</span><br><span class="line"> * (4096 bytes per PCI function) configuration space with type 1</span><br><span class="line"> * accesses.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define PCI_CONF1_ADDRESS(bus, devfn, reg) \</span><br><span class="line">	(0x80000000 | ((reg &amp; 0xF00) &lt;&lt; 16) | (bus &lt;&lt; 16) \</span><br><span class="line">	| (devfn &lt;&lt; 8) | (reg &amp; 0xFC))</span><br><span class="line">	</span><br><span class="line">/*</span><br><span class="line"> * Functions for accessing PCI configuration space with type 2 accesses</span><br><span class="line"> */</span><br><span class="line">#define PCI_CONF2_ADDRESS(dev, reg)	(u16)(0xC000 | (dev &lt;&lt; 8) | reg)</span><br></pre></td></tr></table></figure>

<p>以pci_conf1_read的内部实现为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int pci_conf1_read(unsigned int seg, unsigned int bus,</span><br><span class="line">			  unsigned int devfn, int reg, int len, u32 *value)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (seg || (bus &gt; 255) || (devfn &gt; 255) || (reg &gt; 4095)) &#123;</span><br><span class="line">		*value = -1;</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">	outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);</span><br><span class="line"></span><br><span class="line">	switch (len) &#123;</span><br><span class="line">	case 1:</span><br><span class="line">		*value = inb(0xCFC + (reg &amp; 3));</span><br><span class="line">		break;</span><br><span class="line">	case 2:</span><br><span class="line">		*value = inw(0xCFC + (reg &amp; 2));</span><br><span class="line">		break;</span><br><span class="line">	case 4:</span><br><span class="line">		*value = inl(0xCFC);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最底层调用的是x86的in, out汇编指令，也是宏函数封装，参考<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/shared/io.h#L27">arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;shared&#x2F;io.h#L27</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static __always_inline void __out##bwl(type value, u16 port)		\</span><br><span class="line">&#123;									\</span><br><span class="line">	asm volatile(&quot;out&quot; #bwl &quot; %&quot; #bw &quot;0, %w1&quot;			\</span><br><span class="line">		     : : &quot;a&quot;(value), &quot;Nd&quot;(port));			\</span><br><span class="line">&#125;									\</span><br><span class="line">									\</span><br><span class="line">static __always_inline type __in##bwl(u16 port)				\</span><br><span class="line">&#123;									\</span><br><span class="line">	type value;							\</span><br><span class="line">	asm volatile(&quot;in&quot; #bwl &quot; %w1, %&quot; #bw &quot;0&quot;			\</span><br><span class="line">		     : &quot;=a&quot;(value) : &quot;Nd&quot;(port));			\</span><br><span class="line">	return value;							\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此pci_read_config_byte一类的PCI register acess API分析完毕。</p>
<h2 id="SD-express-on-PCIe的报错分析"><a href="#SD-express-on-PCIe的报错分析" class="headerlink" title="SD express on PCIe的报错分析"></a>SD express on PCIe的报错分析</h2><h3 id="PCIe-AER-driver分析和debug记录"><a href="#PCIe-AER-driver分析和debug记录" class="headerlink" title="PCIe AER driver分析和debug记录"></a>PCIe AER driver分析和debug记录</h3><p>AER: Advanced Error Reporting  </p>
<p>PCIe的AER是PCIe spec协议的标准功能，AER涉及到Error信号产生，上报，处理，错误恢复等。</p>
<h4 id="PCIe-base-spec摘要："><a href="#PCIe-base-spec摘要：" class="headerlink" title="PCIe base spec摘要："></a>PCIe base spec摘要：</h4><p>Error分类：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308251714033.png" alt="image-20230825171440881"></p>
<p>Error信号在数字逻辑的处理流水：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308251714855.png" alt="image-20230825171423678"></p>
<p>AER的capability regsiter:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308251715226.png" alt="image-20230825171511047"></p>
<h4 id="PCIe-AER-driver摘要"><a href="#PCIe-AER-driver摘要" class="headerlink" title="PCIe AER driver摘要"></a>PCIe AER driver摘要</h4><p>PCIe driver的使用aer service driver实现软件处理流程，aer service属于PCIe bus driver的子功能，而PCIe driver又属于PCI driver字类。</p>
<p>什么是PCIe service driver: <a href="https://www.kernel.org/doc/html/v6.1/PCI/pciebus-howto.html">2. The PCI Express Port Bus Driver Guide HOWTO</a></p>
<p>什么是PCIe AER driver: <a href="https://www.kernel.org/doc/html/v6.1/PCI/pcieaer-howto.html">8. The PCI Express Advanced Error Reporting Driver Guide HOWTO</a></p>
<h4 id="PCIe-AER-driver在Kconfig的开关"><a href="#PCIe-AER-driver在Kconfig的开关" class="headerlink" title="PCIe AER driver在Kconfig的开关"></a>PCIe AER driver在Kconfig的开关</h4><p>配置Kconfig可开关：make menuconfig -&gt; &#x2F; -&gt; 搜索PCIEAER -&gt; n关闭，y打开</p>
<p>如下Kconfig的AER三个相关项都被关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_PCIAER=n</span><br><span class="line">CONFIG_ACPI_APEI_PCIEAER=n</span><br><span class="line">CONFIG_PCIAER_INJECT=n</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308251756929.png" alt="image-20230825175611772"></p>
<h4 id="示例：ACS-violation-error的debug过程"><a href="#示例：ACS-violation-error的debug过程" class="headerlink" title="示例：ACS violation error的debug过程"></a>示例：ACS violation error的debug过程</h4><p>在调试SD express host controller driver过程中，发现部分SD express card（ADATA &amp; Lexar）在linux下无法正常初始化，windows下正常。以下为issue debug过程。</p>
<p>(1)首先打开PCI driver的debug打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig -&gt; /搜索 -&gt; PCI_DEBUG -&gt; y</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://cursorhu.github.io/2023/08/02/Linux-driver%E9%80%9A%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">Linux driver常用调试技术记录</a></p>
<p>(2)对比Good Case和Bad case</p>
<p>SD express card的切换是包含PCIe linkdown和linkup的过程，会有两次hot-plug中断处理。</p>
<p>Bad case的log中，发现如下两种AER error report:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291149954.png" alt="image-20230829114906631"></p>
<p>a. RxErr</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link Training Error：一插卡就有此error. 此error发生在hot-plug中断之前</span><br><span class="line">[  106.119856] pcie port 0000:00:1b.4: pciehp: pending interrupts 0x0100 from Slot Status</span><br><span class="line">[  106.119863] pcieport 0000:00:1b.4: PCIe Bus Error: severity=Corrected, type=Physical Layer, (Receiver ID) //PCI driver检测到error属于Physical Layer</span><br><span class="line">[  106.119864] pcieport 0000:00:1b.4:   device [8086:43c4] error status/mask=00000001/00002000 //error status bit0 =1</span><br><span class="line">[  106.119866] pcieport 0000:00:1b.4:    [ 0] RxErr                  (First) //error的含义：在old version of PCIe spec表示Link Training Error.</span><br></pre></td></tr></table></figure>

<p>b. ACS Violation</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ACS Violation error: 在hot-plug driver检测到hot-plug中断之后正在处理hot-plug的card/link状态检测过程中，PCIe driver检测到此error</span><br><span class="line">[  107.493928] enter pciehp_ist</span><br><span class="line">[  107.494136] pcieport 0000:00:1b.4: DPC: containment event, status:0x1f01 source:0x0000</span><br><span class="line">[  107.494140] pcieport 0000:00:1b.4: DPC: unmasked uncorrectable error detected //PCI driver检测到error</span><br><span class="line">[  107.494145] pcieport 0000:00:1b.4: PCIe Bus Error: severity=Uncorrected (Non-Fatal), type=Transaction Layer, (Receiver ID) //PCI driver检测到error属于Transaction Layer</span><br><span class="line">[  107.494148] pcieport 0000:00:1b.4:   device [8086:43c4] error status/mask=00200000/00004000  //error status bit21 =1</span><br><span class="line">[  107.494151] pcieport 0000:00:1b.4:    [21] ACSViol                (First)     //error的含义：ACS Violation</span><br></pre></td></tr></table></figure>

<p>在此ACS error发生之后，hot-plug driver检测不到LinkUp（1st 检测）, polling 10s后也检测不到LinkUp（2nd 检测），最终打印No link，PCIe设备未启动configuration。</p>
<p>(3) ACS violation分析</p>
<p>PCIe协议分析抓包发现一个可疑的vendor defined message，可能是对应上述错误信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291158420.png" alt="image-20230829115802177"></p>
<p>ACS violation在PCIe spec描述如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291151689.png" alt="image-20230829115115392"></p>
<p>(4)原因和解决办法</p>
<p>逻辑链：PCIe Link training到L0之后，PCI driver还没发送Config Write操作定义Bus number的时候, SD express卡就发送了一个Vendor Specific defined message，这个是违反spec规定的；而RC side ACS 功能是enable的，会检测收到的包中的bus number是否和自己已扫描的bus相符，如果不符就报错ACS violation，并放弃卡初始化。</p>
<p>解决办法(workaround)：关闭PCIe bridge driver的ACS enable bit (ACS Control register bit0&#x3D;1’b0):</p>
<p>具体代码改动为：</p>
<p>1). drivers&#x2F;pci&#x2F;pci.c -&gt; pci_std_enable_acs ：pcie默认enable ACS Control register的ACS violation bit，此处修改为disable ACS violation bit.</p>
<p>2). drivers&#x2F;pci&#x2F;quirk.c -&gt; pci_quirk_enable_intel_spt_pch_acs: 此处为Intel PCIe的特有配置，此处也 disable ACS violation bit</p>
]]></content>
      <categories>
        <category>linux驱动</category>
      </categories>
      <tags>
        <tag>PCI</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动 -- 代码提交和使用patch</title>
    <url>/2023/03/09/linux%E9%A9%B1%E5%8A%A8%20--%20%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%92%8C%E4%BD%BF%E7%94%A8patch/</url>
    <content><![CDATA[<p>本文描述：如何参与到Linux kernel社区中，为Linux kernel提交Patch代码；以Linux子系统MMC&#x2F;SD为例介绍如何使用patch。</p>
<h2 id="Linux-kernel提交代码的基本概念"><a href="#Linux-kernel提交代码的基本概念" class="headerlink" title="Linux kernel提交代码的基本概念"></a>Linux kernel提交代码的基本概念</h2><h3 id="如何参与Linux内核开发"><a href="#如何参与Linux内核开发" class="headerlink" title="如何参与Linux内核开发"></a>如何参与Linux内核开发</h3><p>Linux kernel的官方网站：<a href="https://kernel.org/">kernel.org</a></p>
<p>kernel.org内的中文文档：<a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/process/howto.html">如何参与Linux内核开发</a>, 其中最常用的：</p>
<ul>
<li>内核源码库：<a href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a> 在线查看kernel源码而无需git下载</li>
<li>内核子系统(subsystem)的补丁(patch)列表：<a href="https://patchwork.kernel.org/">https://patchwork.kernel.org/</a> 显示正在发布、评论或修订的patch： </li>
<li>内核邮件列表的存档(archive)：<a href="https://lore.kernel.org/lkml/">https://lore.kernel.org/lkml/</a> 所有正在进行或已存档的patchwork都能在此找到邮件记录：</li>
</ul>
<h3 id="如何提交Patch"><a href="#如何提交Patch" class="headerlink" title="如何提交Patch"></a>如何提交Patch</h3><p>Patch是提交到kernel之前的一个阶段，由kernel subsystem maintainer review后<strong>有机会</strong>进入Linux kernel Mainline。事实上绝大所述patch最终未进入Linux kernel Mainline，仅存档到了邮件列表，在lore&#x2F;patchwork.kernel.org可查看这部分patch的内容和提交过程。</p>
<ul>
<li><p>提交Patch的总体规范参考：</p>
<p><a href="https://docs.kernel.org/translations/zh_CN/process/submitting-patches.html">提交补丁：如何让你的改动进入内核</a></p>
</li>
<li><p>具体地讲如何向kernel提交patch和使用patch（需要详细看）: </p>
<p><a href="https://www.kernel.org/doc/html/v4.11/process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></p>
<p><a href="https://www.kernel.org/doc/html/v4.11/process/applying-patches.html?highlight=applying%20patches%20linux%20kernel">Applying Patches To The Linux Kernel</a></p>
</li>
<li><p>关于patch命令如何使用，参考： </p>
<p><a href="https://www.thegeekstuff.com/2014/12/patch-command-examples/">patch-command-examples</a></p>
<p><a href="https://www.man7.org/linux/man-pages/man1/patch.1.html">patch(1) — Linux manual page</a> </p>
<p><a href="https://blog.csdn.net/dl0914791011/article/details/17299103">Linux下生成patch和打patch</a></p>
</li>
</ul>
<h2 id="示例：Linux-MMC子系统中UHS-II-Patch的演化过程"><a href="#示例：Linux-MMC子系统中UHS-II-Patch的演化过程" class="headerlink" title="示例：Linux MMC子系统中UHS-II Patch的演化过程"></a>示例：Linux MMC子系统中UHS-II Patch的演化过程</h2><h3 id="Linux-MMC子系统的现状"><a href="#Linux-MMC子系统的现状" class="headerlink" title="Linux MMC子系统的现状"></a>Linux MMC子系统的现状</h3><p>MMC子系统主要包含SD card, eMMC card, SDIO几部分，Kernel Mainline的支持情况参考：<a href="https://elinux.org/images/9/91/Clement-sd-mmc-high-speed-support-in-linux-kernel_0.pdf#:~:text=%E2%96%B6New%20speed%20modes%20%28name%20are%20base%20on%20the,the%203.3V%20forDS%28Default%20Speed25MHz%29%20andHS%28High%20Speed%20at%2050MHz%29">SD&#x2F;eMMC: new speed modes and their support in Linux</a></p>
<p>这里只关注SD card, Kernel Mainline在当前时间点（kernel 6.2）：</p>
<ul>
<li>不支持UHS-II (SD 4.0 specification)</li>
<li>SD express(SD 7.0 specification)在Kernel 5.11版本以后是支持的</li>
<li>SD UHS-I (SD 3.0 specification)和更老版本的SD协议则在kernel 3.0就已经支持</li>
</ul>
<h3 id="Linux-MMC-UHS-II-patch的演变"><a href="#Linux-MMC-UHS-II-patch的演变" class="headerlink" title="Linux MMC UHS-II patch的演变"></a>Linux MMC UHS-II patch的演变</h3><p>Linux MMC子系统的维护者可以在<a href="https://patchwork.kernel.org/">patchwork.kernel.org</a>的MMC development的about页面看到：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091635752.png" alt="image-20230309163541697"></p>
<p>在patch页面可以搜索以<a href="https://patchwork.kernel.org/project/linux-mmc/list/?q=UHS-II&archive=both&series=&submitter=&delegate=&state=*">UHS-II为关键字的相关patch</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091621148.png" alt="image-20230309162128061">结果如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091623615.png" alt="image-20230309162327522"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091623615.png"> </p>
<p>具体看一下上面这些UHS-II patch的内容和reviewer的评论：</p>
<p>1.首次提交是<a href="https://patchwork.kernel.org/project/linux-mmc/patch/1419672479-30852-2-git-send-email-yi.y.sun@intel.com/">Intel的yisun</a>, 该patch被MMC维护者Ulf Hansson评论：应该split it up，之后就没有再修改和提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RFC,1/2] mmc: core: support UHS-II in core stack.</span><br><span class="line"></span><br><span class="line">Commit Message</span><br><span class="line"></span><br><span class="line">[yisun1](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=102631)Dec. 27, 2014, 9:27 a.m. UTC</span><br><span class="line"></span><br><span class="line">This patch adds the UHS-II support in core layer. This is a RFC patch for</span><br><span class="line">community review.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Yi Sun &lt;yi.y.sun@intel.com&gt;</span><br><span class="line">---</span><br><span class="line"> drivers/mmc/core/Makefile |    3 +-</span><br><span class="line"> drivers/mmc/core/bus.c    |    5 +-</span><br><span class="line"> drivers/mmc/core/core.c   |   89 ++++-</span><br><span class="line"> drivers/mmc/core/sd.c     |   15 +</span><br><span class="line"> drivers/mmc/core/sd_ops.c |   12 +</span><br><span class="line"> drivers/mmc/core/uhs2.c   |  908 +++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> drivers/mmc/core/uhs2.h   |   26 ++</span><br><span class="line"> include/linux/mmc/core.h  |    6 +</span><br><span class="line"> include/linux/mmc/host.h  |   27 ++</span><br><span class="line"> include/linux/mmc/uhs2.h  |  274 ++++++++++++++</span><br><span class="line"> 10 files changed, 1356 insertions(+), 9 deletions(-)</span><br><span class="line"> create mode 100644 drivers/mmc/core/uhs2.c</span><br><span class="line"> create mode 100644 drivers/mmc/core/uhs2.h</span><br><span class="line"> create mode 100644 include/linux/mmc/uhs2.h</span><br><span class="line"></span><br><span class="line">Comments</span><br><span class="line"></span><br><span class="line">[Ulf Hansson](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=45281)Jan. 21, 2015, 10:31 a.m. UTC | [#1](https://patchwork.kernel.org/comment/12007791/)</span><br><span class="line"></span><br><span class="line">Even if this an RFC, me and likely everybody else just stops from</span><br><span class="line">reviewing this patch by looking at the above change log.</span><br><span class="line"></span><br><span class="line">Is there a way to split it up?</span><br><span class="line"></span><br><span class="line">Kind regards</span><br><span class="line">Uffe</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Genesys的Ben Chuang, Jason Lai, Victor.shih 和linaro 的akashi 在Intel的UHS-II patch上不断提交修改后的UHS-II patch（V3~V6）跟随着Kernel版本不断演化，此patch完整内容可在GitLab查看 <a href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755">linux-uhs2-gl9755</a>，在patchwork也可以查看commit内容和review意见：<a href="https://patchwork.kernel.org/project/linux-mmc/patch/20221213090047.3805-7-victor.shih@genesyslogic.com.tw/">V6 patch的第6&#x2F;24提交</a>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[V6,06/24] mmc: core: Support UHS-II card control and access</span><br><span class="line"></span><br><span class="line">Commit Message </span><br><span class="line"></span><br><span class="line">[Victor Shih](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=207469) Dec. 13, 2022, 9 a.m. UTC</span><br><span class="line"></span><br><span class="line">Embed UHS-II access/control functionality into the MMC request</span><br><span class="line">processing flow.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Ulf Hansson &lt;ulf.hansson@linaro.org&gt;</span><br><span class="line">Signed-off-by: Jason Lai &lt;jason.lai@genesyslogic.com.tw&gt;</span><br><span class="line">Signed-off-by: Victor Shih &lt;victor.shih@genesyslogic.com.tw&gt;</span><br><span class="line">---</span><br><span class="line"> drivers/mmc/core/block.c   |    6 +-</span><br><span class="line"> drivers/mmc/core/core.c    |   20 +</span><br><span class="line"> drivers/mmc/core/mmc_ops.c |   25 +-</span><br><span class="line"> drivers/mmc/core/mmc_ops.h |    1 +</span><br><span class="line"> drivers/mmc/core/sd.c      |   11 +-</span><br><span class="line"> drivers/mmc/core/sd.h      |    3 +</span><br><span class="line"> drivers/mmc/core/sd_ops.c  |   13 +</span><br><span class="line"> drivers/mmc/core/sd_ops.h  |    3 +</span><br><span class="line"> drivers/mmc/core/sd_uhs2.c | 1171 +++++++++++++++++++++++++++++++++++-</span><br><span class="line"> 9 files changed, 1206 insertions(+), 47 deletions(-)</span><br><span class="line"></span><br><span class="line">Comments</span><br><span class="line"></span><br><span class="line">[Adrian Hunter](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=31052) Jan. 5, 2023, 9:26 p.m. UTC | [#1](https://patchwork.kernel.org/comment/25148889/)</span><br><span class="line"></span><br><span class="line">&gt; +u32 sd_uhs2_select_voltage(struct mmc_host *host, u32 ocr)</span><br><span class="line">&gt; +&#123;</span><br><span class="line">...</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +	if (host-&gt;caps2 &amp; MMC_CAP2_FULL_PWR_CYCLE) &#123;</span><br><span class="line">&gt; +		bit = ffs(ocr) - 1;</span><br><span class="line">&gt; +		ocr &amp;= 3 &lt;&lt; bit;</span><br><span class="line">&gt; +		/* Power cycle */</span><br><span class="line">&gt; +		err = sd_uhs2_power_off(host);</span><br><span class="line">&gt; +		if (err)</span><br><span class="line">&gt; +			return 0;</span><br><span class="line">&gt; +		err = sd_uhs2_reinit(host);</span><br><span class="line"></span><br><span class="line">This looks circular:</span><br><span class="line"></span><br><span class="line">sd_uhs2_select_voltage</span><br><span class="line">-&gt; sd_uhs2_reinit</span><br><span class="line">   -&gt; sd_uhs2_init_card</span><br><span class="line">      -&gt; sd_uhs2_legacy_init</span><br><span class="line">         -&gt; sd_uhs2_select_voltage</span><br><span class="line"></span><br><span class="line">[Ulf Hansson](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=45281) Feb. 8, 2023, 3:30 p.m. UTC | [#2](https://patchwork.kernel.org/comment/25202573/)</span><br><span class="line"></span><br><span class="line">&gt; diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span><br><span class="line">&gt; index 20da7ed43e6d..d3e8ec43cdd5 100644</span><br><span class="line">&gt; --- a/drivers/mmc/core/block.c</span><br><span class="line">&gt; +++ b/drivers/mmc/core/block.c</span><br><span class="line">&gt; @@ -1596,6 +1596,9 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;         struct request *req = mmc_queue_req_to_req(mqrq);</span><br><span class="line">&gt;         struct mmc_blk_data *md = mq-&gt;blkdata;</span><br><span class="line">&gt;         bool do_rel_wr, do_data_tag;</span><br><span class="line">&gt; +       bool do_multi;</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +       do_multi = (card-&gt;uhs2_state &amp; MMC_UHS2_INITIALIZED) ? true : false;</span><br><span class="line">&gt;</span><br><span class="line">&gt;         mmc_blk_data_prep(mq, mqrq, recovery_mode, &amp;do_rel_wr, &amp;do_data_tag);</span><br><span class="line">&gt;</span><br><span class="line">&gt; @@ -1606,7 +1609,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;                 brq-&gt;cmd.arg &lt;&lt;= 9;</span><br><span class="line">&gt;         brq-&gt;cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;</span><br><span class="line">&gt;</span><br><span class="line">&gt; -       if (brq-&gt;data.blocks &gt; 1 || do_rel_wr) &#123;</span><br><span class="line">&gt; +       if (brq-&gt;data.blocks &gt; 1 || do_rel_wr || do_multi) &#123;</span><br><span class="line"></span><br><span class="line">This looks wrong to me. UHS2 can use single block read/writes too. Right?</span><br><span class="line"></span><br><span class="line">&gt;                 /* SPI multiblock writes terminate using a special</span><br><span class="line">&gt;                  * token, not a STOP_TRANSMISSION request.</span><br><span class="line">&gt;                  */</span><br><span class="line">&gt; @@ -1619,6 +1622,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;                 brq-&gt;mrq.stop = NULL;</span><br><span class="line">&gt;                 readcmd = MMC_READ_SINGLE_BLOCK;</span><br><span class="line">&gt;                 writecmd = MMC_WRITE_BLOCK;</span><br><span class="line">&gt; +               brq-&gt;cmd.uhs2_tmode0_flag = 1;</span><br><span class="line"></span><br><span class="line">As &quot;do_multi&quot; is always set for UHS2, setting this flag here seems to</span><br><span class="line">be wrong/redundant.</span><br><span class="line"></span><br><span class="line">Anyway, if I understand correctly, the flag is intended to be used to</span><br><span class="line">inform the host driver whether the so-called 2L_HD_mode (half-duplex</span><br><span class="line">or full-duplex) should be used for the I/O request or not.</span><br><span class="line"></span><br><span class="line">To fix the above behaviour, I suggest we try to move the entire</span><br><span class="line">control of the flag into mmc_uhs2_prepare_cmd(). We want the flag to</span><br><span class="line">be set for multi block read/writes (CMD18 and CMD25), but only if the</span><br><span class="line">host and card supports the 2L_HD_mode too. According to my earlier</span><br><span class="line">suggestions, we should be able to check that via the bits we set</span><br><span class="line">earlier in the ios-&gt;timing.</span><br><span class="line"></span><br><span class="line">Moreover, by making mmc_uhs2_prepare_cmd() responsible for setting the</span><br><span class="line">flag, I think we can also move the definition of the flag into the</span><br><span class="line">struct uhs2_command. While at it, I suggest we also rename the flag</span><br><span class="line">into &quot;tmode_half_duplex&quot;, to better describe its purpose, which also</span><br><span class="line">means the interpretation of the flag becomes inverted.</span><br></pre></td></tr></table></figure>

<h2 id="详解Patch的使用"><a href="#详解Patch的使用" class="headerlink" title="详解Patch的使用"></a>详解Patch的使用</h2><p>Kernel document: <a href="https://www.kernel.org/doc/html/latest/process/applying-patches.html#:~:text=A%20patch%20is%20a%20small%20text%20document%20containing,the%20patch%20will%20change%20the%20source%20tree%20into.">Applying Patches To The Linux Kernel</a></p>
<h3 id="Patch与git-diff"><a href="#Patch与git-diff" class="headerlink" title="Patch与git diff"></a>Patch与git diff</h3><p>Patch文件的内容实际是<code>git diff</code>命令的输出，git diff的输出定义为.diff文件或.patch文件，即可作为patch使用。打patch实际上就是按diff规则，解析diff&#x2F;patch文件，去改变本地的代码树和内容。</p>
<p>git diff说明文档参考 <a href="https://git-scm.com/docs/git-diff">git-diff</a>，比较常用的是使用<code>git diff [&lt;path&gt;…]</code>输出某个路径&#x2F;文件的差异；如果path为空，则输出当前git仓库所有文件的差异。</p>
<p>如下示例：在drivers&#x2F;mmc&#x2F;core&#x2F;block.c增加修改了<code>//AAAAAAAAA</code>，在drivers&#x2F;mmc&#x2F;core&#x2F;block.h增加了<code>//BBBBBBBBB</code>，以下详细说明git diff 输出的含义：</p>
<ul>
<li>diff –git a&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c b&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c：用git diff命令，比较a和b版本的drivers&#x2F;mmc&#x2F;core&#x2F;block.c，a和b是diff用来区分同名文件的标识，不是实际路径。</li>
<li>index 7fa83e5..8963e57：这个diff如果被commit提交，commit-id将是index值7fa83e5..8963e57。</li>
<li>— a&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c 和+++ b&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c 同时存在：表示是对已存在的block.c文件有内容修改；与之相对的是某个文件只有+++或—，表示是新增文件文件，或者是删除了文件。</li>
<li>@@ -1829,6 +1829,8 @@ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)：该修改代码所在的行数以及所在的函数名。</li>
<li>+&#x2F;&#x2F;AAAAAAAAA：具体的修改内容，+是新增，-是删除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span><br><span class="line">index 7fa83e5..8963e57 100644</span><br><span class="line">--- a/drivers/mmc/core/block.c</span><br><span class="line">+++ b/drivers/mmc/core/block.c</span><br><span class="line">@@ -1829,6 +1829,8 @@ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)</span><br><span class="line">        u32 blocks;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">+//AAAAAAAAA</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">diff --git a/drivers/mmc/core/block.h b/drivers/mmc/core/block.h</span><br><span class="line">index 31153f6..5501895 100644</span><br><span class="line">--- a/drivers/mmc/core/block.h</span><br><span class="line">+++ b/drivers/mmc/core/block.h</span><br><span class="line">@@ -17,4 +17,6 @@ struct work_struct;</span><br><span class="line"></span><br><span class="line"> void mmc_blk_mq_complete_work(struct work_struct *work);</span><br><span class="line"></span><br><span class="line">+//BBBBBBBBB</span><br><span class="line"></span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure>

<p>如果是已经git commit的两个版本之间的diff, 可直接产生所有修改内容的diff文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff commit-a commit-b</span><br></pre></td></tr></table></figure>

<p>一般提交给Kernel社区的patch需要按功能和文件拆分成多个patch提交，也就是说应该对某个文件或者路径git diff, 而不建议直接对版本所有文件git diff。例如以上patch可以分为两个diff，内容等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff drivers/mmc/core/block.c</span><br><span class="line"></span><br><span class="line">git diff drivers/mmc/core/block.h</span><br></pre></td></tr></table></figure>

<h3 id="Patch与kernel版本"><a href="#Patch与kernel版本" class="headerlink" title="Patch与kernel版本"></a>Patch与kernel版本</h3><p>为了正确打一个补丁，你需要知道这个补丁是从哪个基础代码版本(base)产生的，以及这个补丁会使源码树升级成哪个版本。</p>
<h4 id="用于Kernel升级的官方patch"><a href="#用于Kernel升级的官方patch" class="headerlink" title="用于Kernel升级的官方patch"></a>用于Kernel升级的官方patch</h4><p>在kernel.org可以看到有很多Kernel版本之间有patch可以用于升级kernel，例如从kernel 4.19.275升级到5.4.234，可以下载并安装patch-5.4.234.xz</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091942357.png" alt="image-20230309194230288"></p>
<h4 id="patchwork社区的第三方patch"><a href="#patchwork社区的第三方patch" class="headerlink" title="patchwork社区的第三方patch"></a>patchwork社区的第三方patch</h4><p>可以下载diff或者series去获取patch文件，根据patch提交时间和代码上下文大致估计当时的Kernel版本</p>
<ul>
<li>diff: 当前patch的diff, 由于一个大patch可能被拆分为多个小patch，此文件通常为某个小patch</li>
<li>mbox: 在diff基础上包含了邮件信息（MIME信息）</li>
<li>series: 整个功能的所有patch系列的mbox合并内容，包括邮件信息（MIME信息）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091945285.png" alt="image-20230309194559245"></p>
<p>Patch命令使用以上的.diff文件，有的也命名为.patch文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch -p1 &lt; xxx.diff</span><br></pre></td></tr></table></figure>

<p>-p 表示path：跳过第几级目录；1 表示忽略第一级目录</p>
<p>例如diff如下时，第一级目录用a, b表示，patch -p1将忽略a, b，将drivers&#x2F;mmc&#x2F;xxx的diff内容打patch到当前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c</span><br><span class="line">index 86d2711..6565754 100644</span><br><span class="line">--- a/drivers/mmc/core/bus.c</span><br><span class="line">+++ b/drivers/mmc/core/bus.c</span><br><span class="line">@@ -308,8 +308,9 @@ int mmc_add_card(struct mmc_card *card)</span><br><span class="line"> 	&#125; else &#123;</span><br><span class="line"> 		pr_info(&quot;%s: new %s%s%s%s%s card at address %04x\n&quot;,</span><br><span class="line"> 			mmc_hostname(card-&gt;host),</span><br><span class="line">-			mmc_card_uhs(card) ? &quot;ultra high speed &quot; :</span><br><span class="line">-			(mmc_card_hs(card) ? &quot;high speed &quot; : &quot;&quot;),</span><br><span class="line">+			mmc_card_uhs2(card) ? &quot;ultra high speed 2 &quot; :</span><br><span class="line">+			(mmc_card_uhs(card) ? &quot;ultra high speed 1&quot; :</span><br><span class="line">+			(mmc_card_hs(card) ? &quot;high speed &quot; : &quot;&quot;)),</span><br><span class="line"> 			mmc_card_hs400(card) ? &quot;HS400 &quot; :</span><br><span class="line"> 			(mmc_card_hs200(card) ? &quot;HS200 &quot; : &quot;&quot;),</span><br><span class="line"> 			mmc_card_ddr52(card) ? &quot;DDR &quot; : &quot;&quot;,</span><br></pre></td></tr></table></figure>

<p>对于一个大功能的多个patch series，需要分别下载各diff文件； 或者一次下载series后手动删除所有MIME信息。</p>
<h4 id="如何寻找Patch对应的kernel版本"><a href="#如何寻找Patch对应的kernel版本" class="headerlink" title="如何寻找Patch对应的kernel版本"></a>如何寻找Patch对应的kernel版本</h4><p>如果Patch和kernel版本不匹配，patch命令无法合并patch到此kernel中，导致patch失败，因此打patch首先要确定其对应哪个kernel版本。</p>
<p>（1）如果patch commit是已提交到kernel的官方patch，则可以根据commit-id查找包含此commit的kernel版本，参考：<a href="https://lwn.net/Articles/392293/">Finding a patch’s kernel version with git</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git describe --contains &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>

<p>（2）大多数patch是没提交到kernel的第三方patch，因此patch中的index在kernel是找不到的，所以只能通过提交邮件的信息确定适用的kernel版本。</p>
<p>以前文提到的 <a href="https://lore.kernel.org/all/20201106022726.19831-2-takahiro.akashi@linaro.org/T/#u">RFC PATCH v3.1 16&#x2F;27</a>为例，patch是在提交时间点的kernel master版本或tag版本上测试的。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[auto build test WARNING on linus/master]</span><br><span class="line">[also build test WARNING on v5.10-rc2]</span><br><span class="line">[cannot apply to v3.1 next-20201105]</span><br><span class="line">[If your patch is applied to the wrong git tree, kindly drop us a note</span><br></pre></td></tr></table></figure></blockquote>
<p>另外一个示例：提交者在提交信息中写了基于哪个kernel版本：<a href="https://lore.kernel.org/all/20221213090047.3805-24-victor.shih@genesyslogic.com.tw/T/#u">Add support UHS-II for GL9755</a></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes in v6 (Dec. 12, 2022)</span><br><span class="line">* rebased to the linux-kernel-v6.1.0-rc8 in Ulf Hansson next branch.</span><br><span class="line"></span><br><span class="line">Changes in v5 (Oct. 19, 2022)</span><br><span class="line">* rebased to the linux-kernel-v6.1-rc1 in Ulf Hansson next branch.</span><br></pre></td></tr></table></figure></blockquote>
<p>如果一个第三方patch没有任何kernel版本的信息，只能通过提交时间来尝试kernel，一般情况下不建议这种尝试，因为提交者使用的可能是当时最新的kernel, 也可能是一两个月前的kernel, 中间可能有很多-rc版本。</p>
<p>下面以<a href="https://lore.kernel.org/all/525EAED47491124EB5123A51BD2FC79101A30EE2@SHSMSX101.ccr.corp.intel.com/">RFC 0&#x2F;2 mmc: UHS-II implementation</a>为例，尝试寻找此patch可应用的kernel版本，此patch提交信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* RE: [RFC 0/2] mmc: UHS-II implementation</span><br><span class="line">  2014-12-27  9:27 [RFC 0/2] mmc: UHS-II implementation Yi Sun</span><br><span class="line">  2014-12-27  9:27 ` [RFC 1/2] mmc: core: support UHS-II in core stack Yi Sun</span><br><span class="line">  2014-12-27  9:27 ` [RFC 2/2] mmc: sdhci: support UHS-II in SDHCI host Yi Sun</span><br></pre></td></tr></table></figure>

<p>（1）首先在linux kernel git tag时间记录找到接近此patch提交时间的kernel版本：</p>
<p>在<a href="https://github.com/torvalds/linux">linux kernel github</a> 下拉tag列表，找接近patch申请时间的kernel release版本，可见kernel version &lt; 4.0是此patch可能适用的版本</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131133722.png" alt="image-20230313113324650"></p>
<p>（2）patch内容的函数名和上下文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@ -248,6 +252,12 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)</span><br><span class="line"> 			mrq-&gt;stop-&gt;mrq = mrq;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">+</span><br><span class="line">+	if (host-&gt;flags &amp; MMC_UHS2_SUPPORT &amp;&amp;</span><br><span class="line">+	    host-&gt;flags &amp; MMC_UHS2_INITIALIZED)</span><br><span class="line">+		if (mrq-&gt;cmd-&gt;uhs2_cmd == NULL)</span><br><span class="line">+			uhs2_prepare_sd_cmd(host, mrq);</span><br><span class="line">+</span><br><span class="line"> 	mmc_host_clk_hold(host);</span><br><span class="line"> 	led_trigger_event(host-&gt;led, LED_FULL);</span><br><span class="line"> 	host-&gt;ops-&gt;request(host, mrq);</span><br></pre></td></tr></table></figure>

<p>（3）在 <a href="https://elixir.bootlin.com/linux/v4.9/source/drivers/mmc/core/core.c#L264">bootlin</a> 找到kernel的同函数并对比上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mrq-&gt;data) &#123;</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">	mrq-&gt;cmd-&gt;data = mrq-&gt;data;</span><br><span class="line">	mrq-&gt;data-&gt;error = 0;</span><br><span class="line">	mrq-&gt;data-&gt;mrq = mrq;</span><br><span class="line">	if (mrq-&gt;stop) &#123;</span><br><span class="line">		mrq-&gt;data-&gt;stop = mrq-&gt;stop;</span><br><span class="line">		mrq-&gt;stop-&gt;error = 0;</span><br><span class="line">		mrq-&gt;stop-&gt;mrq = mrq;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///// 此处为patch添加处</span><br><span class="line"></span><br><span class="line">led_trigger_event(host-&gt;led, LED_FULL);</span><br><span class="line">__mmc_start_request(host, mrq);</span><br><span class="line"></span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<p>在stable kernel版本上尝试此patch (跳过-rc版本)，首先找kernel tag早于此patch邮件的时间，尝试了kernel 3.18, 3.17都有patch fail，如下可见patch和kernel有少量代码offset能自动匹配，但是有些差异patch搞不定，例如有merge代码冲突会导致对应的Hunk # FAILED，hunk是patch中的diff –git的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~/linux-4.9$ patch -p1 &lt; RFC-1-2-mmc-core-support-UHS-II-in-core-stack..diff </span><br><span class="line">patching file drivers/mmc/core/Makefile</span><br><span class="line">Hunk #1 FAILED at 7.</span><br><span class="line">1 out of 1 hunk FAILED -- saving rejects to file drivers/mmc/core/Makefile.rej</span><br><span class="line">patching file drivers/mmc/core/bus.c</span><br><span class="line">Hunk #1 succeeded at 334 with fuzz 2 (offset 26 lines).</span><br><span class="line">patching file drivers/mmc/core/core.c</span><br><span class="line">Hunk #2 FAILED at 36.</span><br><span class="line">Hunk #3 succeeded at 63 with fuzz 2 (offset 6 lines).</span><br><span class="line">Hunk #4 FAILED at 250.</span><br><span class="line">Hunk #5 succeeded at 503 (offset 116 lines).</span><br><span class="line">Hunk #6 succeeded at 518 (offset 116 lines).</span><br><span class="line">Hunk #7 FAILED at 425.</span><br><span class="line">...</span><br><span class="line">6 out of 17 hunks FAILED -- saving rejects to file drivers/mmc/core/core.c.rej</span><br></pre></td></tr></table></figure>

<p>在kernel 3.18打此patch，只有一个fail，可以根据此fail进一步定位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hunk #13 FAILED at 2339.</span><br><span class="line">1 out of 17 hunks FAILED -- saving rejects to file drivers/mmc/core/core.c.rej</span><br></pre></td></tr></table></figure>

<p>core.c.rej 内容如下，注意这里的行号是已经经过patch操作被偏移的代码的行号，实际行号应该去patch原文件查看此hunk的行号，这里只看是什么函数名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- drivers/mmc/core/core.c</span><br><span class="line">+++ drivers/mmc/core/core.c</span><br><span class="line">@@ -2339,7 +2391,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Set initial state and call mmc_set_ios */</span><br><span class="line">-       mmc_set_initial_state(host);</span><br><span class="line">+       /* TODO: need verify this for UHS2. */</span><br><span class="line">+       if (!host-&gt;flags &amp; MMC_UHS2_SUPPORT)</span><br><span class="line">+               mmc_set_initial_state(host);</span><br><span class="line"></span><br><span class="line">        mmc_host_clk_release(host);</span><br></pre></td></tr></table></figure>

<p>patch原文件drivers&#x2F;mmc&#x2F;core&#x2F;core.c搜索函数名对应的hunk内容，得知代码行数是2287：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@ -2287,7 +2339,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	/* Set initial state and call mmc_set_ios */</span><br><span class="line">-	mmc_set_initial_state(host);</span><br><span class="line">+	/* TODO: need verify this for UHS2. */</span><br><span class="line">+	if (!host-&gt;flags &amp; MMC_UHS2_SUPPORT)</span><br><span class="line">+		mmc_set_initial_state(host);</span><br><span class="line"> </span><br><span class="line"> 	mmc_host_clk_release(host);</span><br></pre></td></tr></table></figure>

<p>去bootlin.com查找<a href="https://elixir.bootlin.com/linux/v3.18/source/drivers/mmc/core/core.c">kernel 3.18的core.c代码</a>如下(直接搜索drivers&#x2F;mmc&#x2F;core&#x2F;core.c定位到文件，然后在core.c文件ctrl+F查找行数2287)，2287行对不上当然patch fail。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131921412.png" alt="image-20230313192134365"></p>
<p>根据patch提交时间，其大概率是使用3.18~4.0之间的kernel版本，因此搜寻3.18以后，且符合上面fail点的代码，首先就是<a href="https://elixir.bootlin.com/linux/v3.19/source/drivers/mmc/core/core.c">3.19版本</a>对比代码如下，可见2287开始的几行和patch完全对应：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131917802.png" alt="image-20230313191733743"></p>
<p>打patch也全部通过未报错，所以3.19是此patch可适配的kernel版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~/linux-3.19$ patch -p1 &lt; RFC-1-2-mmc-core-support-UHS-II-in-core-stack..diff</span><br><span class="line">patching file drivers/mmc/core/Makefile</span><br><span class="line">patching file drivers/mmc/core/bus.c</span><br><span class="line">patching file drivers/mmc/core/core.c</span><br><span class="line">patching file drivers/mmc/core/sd.c</span><br><span class="line">patching file drivers/mmc/core/sd_ops.c</span><br><span class="line">patching file drivers/mmc/core/uhs2.c</span><br><span class="line">patching file drivers/mmc/core/uhs2.h</span><br><span class="line">patching file include/linux/mmc/core.h</span><br><span class="line">patching file include/linux/mmc/host.h</span><br><span class="line">patching file include/linux/mmc/uhs2.h</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux驱动</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动 -- 常用调试技术</title>
    <url>/2023/08/02/linux%E9%A9%B1%E5%8A%A8%20--%20%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="Printk详解"><a href="#Printk详解" class="headerlink" title="Printk详解"></a>Printk详解</h2><p>printk参考Kernel document: <a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/core-api/printk-basics.html">使用printk记录消息</a></p>
<p>其中printk是一组4个值,分别是:<em>current</em>, <em>default</em>, <em>minimum</em> 和 <em>boot-time-default</em>. 调试打印一般只配置current和boot-time-default &#x3D; 7 (支持&lt; pr_debug的打印)或者8 (支持&#x3D; pr_debug的打印).</p>
<h3 id="printk的基础用法"><a href="#printk的基础用法" class="headerlink" title="printk的基础用法"></a>printk的基础用法</h3><p>常用示例如下，一般是手动添加打印代码时使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step1: 例如要打印当前函数被调用，添加pr_info(&quot;%s\n&quot;, __FUNCTION__)</span><br><span class="line">step2: echo 7 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p><strong>Tips1: 非root用户不能成功执行<code>sudo echo 7 &gt; /proc/sys/kernel/printk</code>，显示permission denied</strong></p>
<p>原因：因为sudo仅让echo按root权限执行，没有让&gt;按root权限执行</p>
<p>解决办法一：<code>sudo su</code>进入root用户</p>
<p>解决办法二：dmesg配置printk级别：<code>sudo dmesg -n 7</code></p>
<p>解决办法三：解决任何sudo echo写入的权限问题：</p>
<p><code>sudo sh -c &quot;cmd&quot;</code>，让bash将整个cmd字符串当一个命令执行，并赋予root权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo 7 &gt; /proc/sys/kernel/printk&quot;</span><br></pre></td></tr></table></figure>

<p>再<code>cat /proc/sys/kernel/printk</code>可见printk已变成7,4,1,7(默认是4,4,1,7)</p>
<p><strong>Tips2: (printk持久化)系统启动自动设置打印级别：</strong></p>
<p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk每次启动后都恢复为默认值4,4,1,7.</p>
<p>在&#x2F;etc&#x2F;sysctl.conf添加kernel.printk可以系统启动时自动配置打印级别, 通常用于记录kernel boot阶段的打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br><span class="line">kernel.printk = 8 4 1 8   #8: 打开包括pr_debug的所有打印级别 </span><br></pre></td></tr></table></figure>

<p>小结:</p>
<p><strong>如果要观测系统启动中的driver debug打印，必须&#x2F;etc&#x2F;sysctl.conf配置kernel.printk</strong></p>
<p><strong>如果要观测系统启动后的driver debug打印，建议使用dmesg -n修改printk</strong></p>
<h3 id="printk在driver-subsystem中的使用"><a href="#printk在driver-subsystem中的使用" class="headerlink" title="printk在driver subsystem中的使用"></a>printk在driver subsystem中的使用</h3><p>Linux driver子系统通常使用printk的封装版。以pci driver为例，pci driver代码已经提供了pci_dbg, pci_info, pci_err等打印函数，其不仅打印arg信息，也打印pci port设备信息，例如以下PCIe driver的log:</p>
<p>pcieport 0000:00:1b.4 显示了当前的PCIe port。如果有多个PCIe port的打印，可以区分是哪个port的打印输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   44.713266] pcieport 0000:00:1b.4: DPC: containment event, status:0x1f01 source:0x0000</span><br><span class="line">[   44.713268] pcieport 0000:00:1b.4: DPC: unmasked uncorrectable error detected</span><br><span class="line">[   44.713274] pcieport 0000:00:1b.4: PCIe Bus Error: severity=Uncorrected (Non-Fatal), type=Transaction Layer, (Receiver ID)</span><br><span class="line">[   44.713277] pcieport 0000:00:1b.4:   device [8086:43c4] error status/mask=00200000/00004000</span><br><span class="line">[   44.713280] pcieport 0000:00:1b.4:    [21] ACSViol                (First)</span><br></pre></td></tr></table></figure>

<p><strong>如何设置dev_info, dev_err:</strong></p>
<p>pci_info, pci_err的打开和pr_info, pr_err一致，只需要设置打印级别大于info&#x2F;err即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 7 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p>其他驱动模块的xxx_info, xxx_err也是一样</p>
<p><strong>如何设置dev_dbg:</strong></p>
<p>dev_dbg是比较特殊但常用的打印方式，定义如下。</p>
<p>可见dev_dbg的开启依赖于两个条件：</p>
<ul>
<li><p>driver定义了CONFIG_DYNAMIC_DEBUG 或者 DEBUG 宏才能开启，一般使用DEBUG宏</p>
</li>
<li><p>printk级别需要为8（7为debug level, 8 &gt; debug level，才能开启debug打印）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#if defined(CONFIG_DYNAMIC_DEBUG) || \</span><br><span class="line">	(defined(CONFIG_DYNAMIC_DEBUG_CORE) &amp;&amp; defined(DYNAMIC_DEBUG_MODULE))</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">	dynamic_dev_dbg(dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="line">#elif defined(DEBUG)</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">	dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">(&#123;									\</span><br><span class="line">	if (0)								\</span><br><span class="line">		dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \</span><br><span class="line">&#125;)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>以pci_dbg为例(内部实现是dev_dbg)，要打开pci_dbg设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Kernel Makefile定义DEBUG宏，可以在driver/pci的Makefile定义，也可以在Kernel根目录Makefile定义：</span><br><span class="line"></span><br><span class="line">方式一：DEBUG宏定义在KCFLAG，即编译此目录的任何driver .o, .ko都定义了DEBUG宏</span><br><span class="line">KCFLAGS += -DDEBUG </span><br><span class="line"></span><br><span class="line">方式二：DEBUG宏定义在某一个driver模块，即编译此模块时定义了DEBUG宏，例如</span><br><span class="line">obj-$&#123;CONFIG_PCI&#125; += -DDEBUG </span><br></pre></td></tr></table></figure>

<p>以上是对任意Driver模块打开DEBUG宏的通用方法；实际上drivers&#x2F;pci已经定义了KCONFIG可选项如下，只需要make menuconfig时设置PCI_DEBUG &#x3D; y 即可对drivers&#x2F;pci的当前目录和子目录的模块编译都定义DEBUG宏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### Makefile:</span><br><span class="line">subdir-ccflags-$(CONFIG_PCI_DEBUG) := -DDEBUG</span><br><span class="line"></span><br><span class="line">### Kconfig:</span><br><span class="line">config PCI_DEBUG</span><br><span class="line">	bool &quot;PCI Debugging&quot;</span><br><span class="line">	depends on DEBUG_KERNEL</span><br><span class="line">	help</span><br><span class="line">	  Say Y here if you want the PCI core to produce a bunch of debug</span><br><span class="line">	  messages to the system log.  Select this if you are having a</span><br><span class="line">	  problem with PCI support and want to see more of what is going on.</span><br><span class="line"></span><br><span class="line">	  When in doubt, say N.</span><br></pre></td></tr></table></figure>

<p>最后设置printk level大于DEBUG level：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 8 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p>此后dmesg可查看drivers&#x2F;pci下的所有pci_dbg都被打印（当然也包括pci_info, pci_err等）。</p>
<h2 id="make-menuconfig配置技巧"><a href="#make-menuconfig配置技巧" class="headerlink" title="make menuconfig配置技巧"></a>make menuconfig配置技巧</h2><h3 id="如何快速定位CONFIG项"><a href="#如何快速定位CONFIG项" class="headerlink" title="如何快速定位CONFIG项"></a>如何快速定位CONFIG项</h3><p>以PCIe driver为例，drivers&#x2F;pci的Makefile有以下CONFIG</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subdir-ccflags-$(CONFIG_PCI_DEBUG) := -DDEBUG</span><br></pre></td></tr></table></figure>

<p>现在make menuconfig时想快速定位CONFIG_PCI_DEBUG对应的位置再设置为y，定位操作如下：</p>
<p>step1: 输入<code>/</code> 打开查找，输入要查找的CONFIG名，注意这里不支持模糊匹配</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031201872.png" alt="Screenshot from 2023-08-03 11-52-54"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031201364.png" alt="Screenshot from 2023-08-03 11-51-31"></p>
<p>step2: 按1跳转到CONFIG对应位置</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031202070.png" alt="Screenshot from 2023-08-03 11-51-55"></p>
<h3 id="直接修改-config文件"><a href="#直接修改-config文件" class="headerlink" title="直接修改.config文件"></a>直接修改.config文件</h3><p>make menuconfig本质是配置.config文件，可以手动修改CONFIG_XXX &#x3D; y&#x2F;m</p>
<h2 id="Ftrace详解"><a href="#Ftrace详解" class="headerlink" title="Ftrace详解"></a>Ftrace详解</h2><p>ftrace是printk之外，能观测driver&#x2F;kernel的函数(symbol)调用流程和执行时间的重要debug功能。</p>
<p>ftrace的系统框图如下，只需要配置用户空间暴露的trace文件，就可以读取kernel的trace buffer信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202309071044981.jpg" alt="524572_1276915819YAfE"></p>
<p>ftrace的完整使用教程和原理，参考：</p>
<p><a href="https://vdoc.pub/documents/mastering-embedded-linux-programming-2pons0ikdkb0">Mastering Embedded Linux Programming</a></p>
<p><a href="https://www.kernel.org/doc/html/v6.1/trace/index.html">Linux Tracing Technologies</a></p>
<h3 id="function-graph使用示例"><a href="#function-graph使用示例" class="headerlink" title="function_graph使用示例"></a>function_graph使用示例</h3><p>在ftrace相关Kconfig和debugfs已开启情况下，如下是查询sleep调用了哪些function</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su	#用root操作debugfs</span><br><span class="line">cd /sys/kernel/debug/tracing	#进入tracing目录，方便操作trace文件</span><br><span class="line">echo function_graph &gt; current_tracer	当前tracer使用function_graph模式</span><br><span class="line">echo 1 &gt; tracing_on	#开启trace</span><br><span class="line">sleep 1	#执行要trace的操作</span><br><span class="line">echo 0 &gt; tracing_on	#(可选)关闭trace</span><br><span class="line">cat trace #查看trace的输出文件</span><br></pre></td></tr></table></figure>

<p>部分关键函数调用流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="line"># |     |   |                     |   |   |   |</span><br><span class="line"></span><br><span class="line"> 3)               |    cpuidle_enter() &#123;</span><br><span class="line"> 3)   0.271 us    |      tick_nohz_get_next_hrtimer();</span><br><span class="line"> 3)               |      cpuidle_enter_state() &#123;</span><br><span class="line"> 3)               |        leave_mm() &#123;</span><br><span class="line"> 3)               |          switch_mm() &#123;</span><br><span class="line"> 3)               |            switch_mm_irqs_off() &#123;</span><br><span class="line"> 3)   0.441 us    |              load_new_mm_cr3();</span><br><span class="line"> 3)   0.299 us    |              switch_ldt();</span><br><span class="line"> 3)   1.661 us    |            &#125;</span><br><span class="line"> 3)   2.193 us    |          &#125;</span><br><span class="line"> 3)   2.721 us    |        &#125;</span><br><span class="line"> 3)   0.271 us    |        sched_idle_set_state();</span><br><span class="line"> 3)               |        intel_idle_ibrs() &#123;</span><br><span class="line"> 3)   0.273 us    |          spec_ctrl_current();</span><br><span class="line"> 3) # 8916.545 us |        &#125;</span><br><span class="line"> 3)   0.608 us    |        sched_idle_set_state();</span><br><span class="line"> 3)               |        irq_enter_rcu() &#123;</span><br><span class="line"> 3)               |          tick_irq_enter() &#123;</span><br><span class="line"> 3)   0.394 us    |            tick_check_oneshot_broadcast_this_cpu();</span><br><span class="line"> 3)   0.466 us    |            ktime_get();</span><br><span class="line"> 3)   0.337 us    |            nr_iowait_cpu();</span><br><span class="line"> 3)   0.379 us    |            tick_do_update_jiffies64();</span><br><span class="line"> 3)   3.274 us    |          &#125;</span><br><span class="line"> 3)   3.996 us    |        &#125;</span><br><span class="line"> 3)               |        __common_interrupt() &#123;</span><br><span class="line"> 3)               |          handle_edge_irq() &#123;</span><br><span class="line"> 3)   0.348 us    |            _raw_spin_lock();</span><br><span class="line"> 3)               |            irq_chip_ack_parent() &#123;</span><br><span class="line"> 3)   0.526 us    |              apic_ack_irq();</span><br><span class="line"> 3)   1.275 us    |            &#125;</span><br><span class="line"> 3)               |            handle_irq_event() &#123;</span><br><span class="line"> 3)   0.332 us    |              _raw_spin_unlock();</span><br><span class="line"> 3)               |              __handle_irq_event_percpu() &#123;</span><br><span class="line"> 3)               |                e1000_intr_msi [e1000e]() &#123;</span><br><span class="line"> 3)   0.322 us    |                  napi_schedule_prep();</span><br><span class="line"> 3)               |                  __napi_schedule() &#123;</span><br><span class="line"> 3)   0.320 us    |                    __raise_softirq_irqoff();</span><br><span class="line"> 3)   0.982 us    |                  &#125;</span><br><span class="line"> 3)   4.938 us    |                &#125;</span><br><span class="line"> 3)   5.759 us    |              &#125;</span><br><span class="line"> 3)               |              add_interrupt_randomness() &#123;</span><br><span class="line"> 3)   0.334 us    |                fast_mix();</span><br><span class="line"> 3)   0.982 us    |              &#125;</span><br><span class="line"> 3)   0.340 us    |              note_interrupt();</span><br><span class="line"> 3)   0.322 us    |              _raw_spin_lock();</span><br><span class="line"> 3)   9.578 us    |            &#125;</span><br><span class="line"> 3)   0.323 us    |            _raw_spin_unlock();</span><br><span class="line"> 3) + 13.112 us   |          &#125;</span><br><span class="line"> 3) + 13.883 us   |        &#125;</span><br><span class="line"> 3)               |        irq_exit_rcu() &#123;</span><br><span class="line"> 3)               |          __do_softirq() &#123;</span><br><span class="line">                             ....</span><br><span class="line"> 3) ! 135.293 us  |          &#125;</span><br><span class="line"> 3)   0.371 us    |          idle_cpu();</span><br><span class="line"> 3) ! 136.785 us  |        &#125;</span><br><span class="line"> 3) # 9079.848 us |      &#125;</span><br><span class="line"> 3) # 9080.993 us |    &#125;</span><br></pre></td></tr></table></figure>

<p>和<a href="https://elixir.bootlin.com/linux/latest/source/drivers/cpuidle/cpuidle.c#L372">cpuidle_enter</a>源码对照一致</p>
<p>注意多个CPU的trace可能混杂，例如下面是CPU1和3交替执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="line"># |     |   |                     |   |   |   |</span><br><span class="line"> 1)               |    cpuidle_enter() &#123;</span><br><span class="line"> 1)   0.158 us    |      tick_nohz_get_next_hrtimer();</span><br><span class="line"> 1)               |      cpuidle_enter_state() &#123;</span><br><span class="line"> 1)   0.174 us    |        leave_mm();</span><br><span class="line"> 1)   0.158 us    |        sched_idle_set_state();</span><br><span class="line"> 1)               |        intel_idle_ibrs() &#123;</span><br><span class="line"> 1)   0.158 us    |          spec_ctrl_current();</span><br><span class="line"> 1) # 3924.061 us |        &#125;</span><br><span class="line"> 3) # 7847.617 us |        &#125;</span><br><span class="line"> 1)   0.337 us    |        sched_idle_set_state();</span><br><span class="line"> 3)   0.323 us    |        sched_idle_set_state();</span><br><span class="line"> 1)               |        irq_enter_rcu() &#123;</span><br><span class="line"> 1)               |          tick_irq_enter() &#123;</span><br><span class="line"> 3)               |        irq_enter_rcu() &#123;</span><br><span class="line"> 1)   0.210 us    |            tick_check_oneshot_broadcast_this_cpu();</span><br></pre></td></tr></table></figure>

<h3 id="trace函数的过滤-ftrace-filter"><a href="#trace函数的过滤-ftrace-filter" class="headerlink" title="trace函数的过滤(ftrace_filter)"></a>trace函数的过滤(ftrace_filter)</h3><p>查看有哪些symbol(function)可以作为trace过滤关键字，一般kernel和已加载的driver函数都在此列表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat available_filter_functions #查看所有symbol</span><br><span class="line">cat available_filter_functions | grep pci #查看所有名字带pci的symbol</span><br></pre></td></tr></table></figure>

<p>一个symbol list示例如下(grep pci)，其中带[]的是Driver Module的symbol, 不带的为build-in kernel的symbol：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_pci_config</span><br><span class="line">read_pci_config_byte</span><br><span class="line">write_pci_config</span><br><span class="line">write_pci_config_byte</span><br><span class="line">...</span><br><span class="line">pciehp_probe</span><br><span class="line">pciehp_configure_device</span><br><span class="line">pciehp_isr</span><br><span class="line">pciehp_ist</span><br><span class="line">...</span><br><span class="line">sdhci_pci_enable_dma [sdhci_pci]</span><br><span class="line">sdhci_pci_remove_slot [sdhci_pci]</span><br><span class="line">nvme_pci_complete_rq [nvme]</span><br><span class="line">nvme_pci_enable [nvme]</span><br></pre></td></tr></table></figure>

<p>trace带pci关键字的symbol，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;&quot; &gt; trace #清空现有trace信息</span><br><span class="line">echo &quot;*pci*&quot; &gt; set_ftrace_filter	#设置过滤关键字</span><br><span class="line">echo 1 &gt; /sys/bus/pci/rescan	#执行trace操作：rescan所有pci设备</span><br></pre></td></tr></table></figure>

<p>关键流程的trace输出如下，<a href="https://elixir.bootlin.com/linux/latest/source/drivers/pci/probe.c#L2674">pci_scan_slot</a>是rescan的核心操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)               |      pci_scan_slot() &#123;</span><br><span class="line">1)               |        pci_scan_single_device() &#123;</span><br><span class="line">1)               |          pci_get_slot() &#123;</span><br><span class="line">1)   0.912 us    |            pci_dev_get();</span><br><span class="line">1)   2.467 us    |          &#125;</span><br><span class="line">1)               |          pci_bus_generic_read_dev_vendor_id() &#123;</span><br><span class="line">1)               |            pci_bus_read_config_dword() &#123;</span><br><span class="line">1)               |              pci_read() &#123;</span><br><span class="line">1)   9.293 us    |                pci_conf1_read();</span><br><span class="line">1) + 10.669 us   |              &#125;</span><br><span class="line">1) + 12.057 us   |            &#125;</span><br><span class="line">1) + 18.047 us   |          &#125;</span><br><span class="line">1) + 31.012 us   |        &#125;</span><br><span class="line">1) + 32.412 us   |      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="trace过滤的高级用法"><a href="#trace过滤的高级用法" class="headerlink" title="trace过滤的高级用法"></a>trace过滤的高级用法</h3><p>假设想trace某个driver module的所有symbol, 如果仅靠函数关键字很难实现</p>
<p>解决办法：将available_filter_functions经过文本处理(sed&#x2F;awk&#x2F;grep)后，输出要trace的driver module的所有symbol列表，再写入set_ftrace_filter文件。</p>
<p>以下示例trace driver module名为bht_sd的所有symbol:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsmod | grep bht_sd	#首先确认module已加载</span><br><span class="line">cat available_filter_functions | grep bht_sd	#查看module的symbol是否存在于available_filter_functions</span><br></pre></td></tr></table></figure>

<p>grep bht_sd输出的部分symbol如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bht_sd_resume [bht_sd]</span><br><span class="line">bht_sd_suspend [bht_sd]</span><br><span class="line">bht_sd_pci_release [bht_sd]</span><br><span class="line">bht_sd_remove [bht_sd]</span><br><span class="line">bht_sd_probe [bht_sd]</span><br></pre></td></tr></table></figure>

<p>用grep, awk过滤一下，只保留函数名，去掉[module名]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat available_filter_functions | grep bht_sd | awk &#x27;&#123; print $1 &#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bht_sd_resume </span><br><span class="line">bht_sd_suspend </span><br><span class="line">bht_sd_pci_release</span><br><span class="line">bht_sd_remove </span><br><span class="line">bht_sd_probe</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>再写入set_ftrace_filter(要一段时间)，用一个命令处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat available_filter_functions | grep bht_sd | awk &#x27;&#123; print $1 &#125;&#x27; &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>

<p>查看set_ftrace_filter可见Driver module的symbol又添加了[module名]，可能是ftrace_filter自己添加的索引信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bht_sd_resume [bht_sd]</span><br><span class="line">bht_sd_suspend [bht_sd]</span><br><span class="line">bht_sd_pci_release [bht_sd]</span><br><span class="line">bht_sd_remove [bht_sd]</span><br><span class="line">bht_sd_probe [bht_sd]</span><br></pre></td></tr></table></figure>

<p>对该Driver设备操作(例如device rescan)，cat&#x2F;vim trace输出正常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2)               |    bht_sd_probe [bht_sd]() &#123;</span><br><span class="line">2)   2.516 us    |      os_memset [bht_sd]();</span><br><span class="line">2)               |      DbgInfo [bht_sd]() &#123;</span><br><span class="line">2)   0.911 us    |        fls32 [bht_sd]();</span><br><span class="line">2)   0.850 us    |        os_memcpy [bht_sd]();</span><br><span class="line">2)   5.089 us    |        os_print [bht_sd]();</span><br><span class="line">2) + 12.315 us   |      &#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外一种对.ko用nm命令输出symbol，参考：<a href="https://blog.csdn.net/defeattroy/article/details/5618099">defeattroy&#x2F;用Ftrace跟踪内核模块</a></p>
]]></content>
      <categories>
        <category>linux驱动</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用笔记</title>
    <url>/2022/03/09/python%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Python使用正则表达式示例"><a href="#Python使用正则表达式示例" class="headerlink" title="Python使用正则表达式示例"></a>Python使用正则表达式示例</h2><p>Python的正则表达式比较全面的教程，参考<a href="https://www.programiz.com/python-programming/regex"># Python RegEx</a></p>
<p>使用背景：芯片ATE测试中，不同ATE平台的测试模式文件格式有不同，需要匹配字符串并按特定转换<br>转换前：</p>
<blockquote>
<p>Pattern “pll_dll_100m_test” {<br>waveform_start:<br>W pll_dll_100m_wft;</p>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>转后后：</p>
<blockquote>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;} W pll_dll_100m_wft;<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>规则：将以“W_xxx”的字符串放到下一个以“V_xxx”的字符串后面</p>
<p>利用python正则匹配，配合读取文件到字符串数组，实现如下转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">infile_name = <span class="built_in">input</span>(<span class="string">&quot;Please input the name of file in current directory to convert: &quot;</span>)</span><br><span class="line">name_flag = infile_name.find(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> name_flag == -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file name error, need input the suffix of file name&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(infile_name):</span><br><span class="line">        outfile_name = infile_name[<span class="number">0</span>:name_flag] + <span class="string">&quot;_updated&quot;</span> + infile_name[name_flag:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no such file!&quot;</span>)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">infile = <span class="built_in">open</span>(infile_name, <span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(outfile_name, <span class="string">&quot;w&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lines = infile.readlines()</span><br><span class="line">infile.close()</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">    str_obj = re.<span class="keyword">match</span>(<span class="string">&#x27;[\s]*W[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;W ...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        temp_index = index</span><br><span class="line">        temp_str = str_obj.group()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_obj = re.<span class="keyword">match</span>(<span class="string">&#x27;[\s]*V[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;V ...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                lines[temp_index] = <span class="string">&#x27;\n&#x27;</span> <span class="comment">#clear last &quot;W ...&quot;</span></span><br><span class="line">                lines[index] = str_obj.group() + <span class="string">&#x27; &#x27;</span> + temp_str + <span class="string">&#x27;\n&#x27;</span> <span class="comment">#add the &quot;W ...&quot; from &quot;V ...&quot; end</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">outfile.writelines(lines)</span><br><span class="line">outfile.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;outputfile is &quot;</span> + outfile_name)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的W和V前面加了额外的匹配项：<code>[\s]*</code>，是因为文件存在不可见的回车换行等引起，如果不加匹配不到</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu搭建跨平台markdown写作环境</title>
    <url>/2024/08/30/ubuntu%E6%90%AD%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0markdown%E5%86%99%E4%BD%9C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="ubuntu搭建跨平台markdown写作环境"><a href="#ubuntu搭建跨平台markdown写作环境" class="headerlink" title="ubuntu搭建跨平台markdown写作环境"></a>ubuntu搭建跨平台markdown写作环境</h1><h2 id="ubuntu安装picgo"><a href="#ubuntu安装picgo" class="headerlink" title="ubuntu安装picgo"></a>ubuntu安装picgo</h2><h3 id="下载picgo安装包："><a href="#下载picgo安装包：" class="headerlink" title="下载picgo安装包："></a>下载picgo安装包：</h3><p>github：<a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.1">https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.1</a></p>
<p>下载慢可以搜索国内镜像，bing搜索安装包名能找到国内镜像：</p>
<p><a href="https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/v2.3.1/">https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/v2.3.1/</a></p>
<p>注意：安装PicGo AppImage，不要使用snap包，否则typora配置上传功能有问题</p>
<h3 id="安装PicGo-AppImage"><a href="#安装PicGo-AppImage" class="headerlink" title="安装PicGo AppImage"></a>安装PicGo AppImage</h3><p>AppImage是可以直接运行而不需要安装的包：Unlike other applications, AppImages do not need to be installed before they can be used. However, they need to be marked as executable before they can be run. This is a Linux security feature.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x PicGo-2.3.1.AppImage </span><br><span class="line"> ./PicGo-2.3.1.AppImage</span><br></pre></td></tr></table></figure>

<p>运行picgo有个小图标，需要右键打开主窗口。</p>
<h2 id="Picgo配置Github图床"><a href="#Picgo配置Github图床" class="headerlink" title="Picgo配置Github图床"></a>Picgo配置Github图床</h2><p>建议使用Jsdelivr加速配置github图床。参考：<a href="https://blog.csdn.net/yefcion/article/details/88412025">PicGo + GitHub 搭建个人图床工具</a></p>
<p>我个人的github图床配置如下（见picgo配置文件）：</p>
<pre><code>&quot;github&quot;: {
  &quot;repo&quot;: &quot;cursorhu/blog-images-on-picgo&quot;,
  &quot;branch&quot;: &quot;master&quot;,
  &quot;token&quot;: &quot;ghp_xxxxxxxxxxxxxxxxx&quot;,
  &quot;path&quot;: &quot;images/&quot;,
  &quot;customUrl&quot;: &quot;https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master&quot;
}
</code></pre>
<p>如果Jsdelivr挂了就用github raw url： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;customUrl&quot;: &quot;https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master&quot;</span><br></pre></td></tr></table></figure>

<p>Picgo其他配置如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404181738880.png" alt="image-20240418173835825"></p>
<p>Picgo配置完需要测试在GUI上传图片OK.</p>
<p>注意：如果已经传了很多文章和图片，jsdelivr突然挂了，如何修复图床链接：</p>
<p>全局替换已写文章中的图片链接：将<code>https://cdn.jsdelivr.net/gh/账户名/图床仓库名@master</code> 改为： <code>https://raw.githubusercontent.com/账户名/图床仓库名/master</code></p>
<h2 id="Typora使用Picgo-Appimage上传图片"><a href="#Typora使用Picgo-Appimage上传图片" class="headerlink" title="Typora使用Picgo Appimage上传图片"></a>Typora使用Picgo Appimage上传图片</h2><p>Picgo测试OK之后，直接配置Typora的粘贴图片 &#x3D;&#x3D; 使用PicGo AppImage上传图片。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404181717983.png" alt="image-20240418171743929"></p>
<p>注意：使用剪贴板图片上传，需要<code>apt install xclip</code>，一般系统自带。</p>
<h2 id="附录（配置Picgo桌面图标）"><a href="#附录（配置Picgo桌面图标）" class="headerlink" title="附录（配置Picgo桌面图标）"></a>附录（配置Picgo桌面图标）</h2><p>可解压AppImage去配置Picgo桌面图标：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./PicGo-2.3.1.AppImage --appimage-extract</span><br><span class="line"></span><br><span class="line">cd squashfs-root</span><br><span class="line"></span><br><span class="line">#设置图标</span><br><span class="line"></span><br><span class="line">vim picgo.desktop </span><br><span class="line"></span><br><span class="line">#设置以下Exec和Icon为绝对路径：</span><br><span class="line"></span><br><span class="line">Exec=/home/xxx/Download/squashfs-root/AppRun</span><br><span class="line"></span><br><span class="line">Icon=/home/xxx/Download/squashfs-root/picgo.png</span><br><span class="line"></span><br><span class="line">#加权限</span><br><span class="line"></span><br><span class="line">chmod +x picgo.desktop</span><br><span class="line"></span><br><span class="line">将 picgo.desktop 复制到 `/usr/share/applications/`，应用程序列表就有Picgo图标</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="附录（废弃方案记录）"><a href="#附录（废弃方案记录）" class="headerlink" title="附录（废弃方案记录）"></a>附录（废弃方案记录）</h2><p>最开始打算用smms图床或者gitee图床+picgo+typora， 配置没有成功，换github就OK了。这里只记录不成功过程。</p>
<h3 id="本地安装-snap包：picgo-snap包不能正常上传，这里只记录安装方式"><a href="#本地安装-snap包：picgo-snap包不能正常上传，这里只记录安装方式" class="headerlink" title="本地安装.snap包：picgo snap包不能正常上传，这里只记录安装方式"></a>本地安装.snap包：picgo snap包不能正常上传，这里只记录安装方式</h3><p>直接snap install xxx.snap会报错：</p>
<p>cannot find signatures with metadata for snap “picgo_2.3.1_amd64.snap</p>
<p>.snap本地离线安装的标准流程是snap download xxx + snap ack xxx + snap install xxx：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ snap download hello-world</span><br><span class="line">Fetching snap &quot;hello-world&quot;</span><br><span class="line">Fetching assertions for &quot;hello-world&quot;</span><br><span class="line"></span><br><span class="line">$ sudo snap ack hello-world_27.assert </span><br><span class="line"></span><br><span class="line">$ sudo snap install hello-world_27.snap</span><br><span class="line">hello-world 6.3 from &#x27;canonical&#x27; installed</span><br><span class="line"></span><br><span class="line">$ snap list</span><br><span class="line">Name                   Version                   Rev   Developer      Notes</span><br><span class="line">&lt;snip&gt;</span><br><span class="line">hello-world            6.3                       27    canonical      -</span><br></pre></td></tr></table></figure>

<p><a href="https://askubuntu.com/questions/1266894/how-can-i-install-a-snap-package-from-a-local-file">https://askubuntu.com/questions/1266894/how-can-i-install-a-snap-package-from-a-local-file</a></p>
<p>但gicgo包没有assert，只能用另外的dangerous模式安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap install /path/to/my-snap.snap --dangerous</span><br></pre></td></tr></table></figure>



<h3 id="安装Node-js环境：为了安装picgo-core，这里只记录node安装方式"><a href="#安装Node-js环境：为了安装picgo-core，这里只记录node安装方式" class="headerlink" title="安装Node.js环境：为了安装picgo-core，这里只记录node安装方式"></a>安装Node.js环境：为了安装picgo-core，这里只记录node安装方式</h3><p>安装nodejs（包括npm包管理工具）：<code>sudo apt install nodejs npm</code> 这种方式能用，但nodejs版本可能太低，因此建议指定nodejs版本 &gt;&#x3D;16 再apt install：</p>
<p><a href="https://www.linode.com/docs/guides/install-nodejs-on-ubuntu-22-04/">https://www.linode.com/docs/guides/install-nodejs-on-ubuntu-22-04/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_20.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">sudo npm install -g npm@latest</span><br></pre></td></tr></table></figure>

<p>如果已经安装低版本，需要apt remove nodejs + apt autoremove彻底清除再装。</p>
<h3 id="typora使用picgo-core上传（失败）"><a href="#typora使用picgo-core上传（失败）" class="headerlink" title="typora使用picgo core上传（失败）"></a>typora使用picgo core上传（失败）</h3><p>1.安装picgo core配置文件</p>
<p>参考：</p>
<p><a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/getting-started.html#%E4%B8%B4%E6%97%B6%E5%B0%9D%E9%B2%9C">https://picgo.github.io/PicGo-Core-Doc/zh/guide/getting-started.html#%E4%B8%B4%E6%97%B6%E5%B0%9D%E9%B2%9C</a></p>
<p><a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装picgo-core</span><br><span class="line">cursorhu@ubuntu-PC:~/Downloads$ sudo npm install picgo -g</span><br><span class="line"></span><br><span class="line">#配置picgo-core</span><br><span class="line">cursorhu@ubuntu-PC:~/Downloads$ picgo set uploader</span><br><span class="line">? Choose a(n) uploader </span><br><span class="line">  aliyun </span><br><span class="line">  tcyun </span><br><span class="line">❯ smms </span><br><span class="line">  github </span><br><span class="line"></span><br><span class="line">配置完毕的输出：</span><br><span class="line">cursorhu@ubuntu-PC:~/Downloads$ picgo set uploader</span><br><span class="line">? Choose a(n) uploader smms</span><br><span class="line">? api token [hidden]</span><br><span class="line">备用上传域名 例如 smms.app smms.app</span><br><span class="line">[PicGo SUCCESS]: Configure config successfully!</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404181714768.png" alt="image-20240416171654570"></p>
<h3 id="typora使用自定义命令上传（成功但不适用）"><a href="#typora使用自定义命令上传（成功但不适用）" class="headerlink" title="typora使用自定义命令上传（成功但不适用）"></a>typora使用自定义命令上传（成功但不适用）</h3><p>参考：<a href="https://picgo.github.io/PicGo-Doc/en/guide/advance.html#upload-using-command-line">https://picgo.github.io/PicGo-Doc/en/guide/advance.html#upload-using-command-line</a></p>
<p>命令行验证是可以上传已复制到剪贴板的图片：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./PicGo-2.3.1.AppImage upload</span><br></pre></td></tr></table></figure>

<p>配置Typora使用该自定义命令：</p>
<p>效果：不方便，粘贴图片后的上传完成链接在剪贴板上，需要再粘贴一遍才是上传到服务器的图片链接。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404181714278.png" alt="image-20240416170333787"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/yefcion/article/details/88412025">https://blog.csdn.net/yefcion/article/details/88412025</a></p>
<p><a href="https://blog.csdn.net/weixin_45636061/article/details/124335243">https://blog.csdn.net/weixin_45636061/article/details/124335243</a></p>
<p><a href="https://www.cnblogs.com/usmile/p/14842233.html">https://www.cnblogs.com/usmile/p/14842233.html</a></p>
<p><a href="https://blog.csdn.net/qq_42584874/article/details/116534328">https://blog.csdn.net/qq_42584874/article/details/116534328</a></p>
<p><a href="https://blog.csdn.net/qq_39974578/article/details/122117699">https://blog.csdn.net/qq_39974578/article/details/122117699</a></p>
]]></content>
      <categories>
        <category>ubuntu系统</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>windows core dump的配置和测试</title>
    <url>/2023/07/24/windows-coredump%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>在存储设备的windows系统环境下调试时，因为存储设备本身的问题，有时候coredump不能成功生成到系统目录，本文记录如何修改coredump路径，以及用键盘测试coredump生成符合预期。</p>
<h2 id="使能windows的coredump"><a href="#使能windows的coredump" class="headerlink" title="使能windows的coredump"></a>使能windows的coredump</h2><p><a href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/debugger/enabling-a-kernel-mode-dump-file">Enabling a Kernel-Mode Dump File</a></p>
<h2 id="修改coredump路径"><a href="#修改coredump路径" class="headerlink" title="修改coredump路径"></a>修改coredump路径</h2><p><a href="https://learn.microsoft.com/zh-cn/troubleshoot/windows-server/performance/memory-dump-file-options">Windows 的内存转储文件选项概述</a></p>
<p>可以修改注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\CrashControl</code>的DumpFile键值对，默认路径%SystemRoot%在cmd echo出来是”C:&quot;, 修改为指定路径例如”E:\Memory.dmp”。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241555783.png" alt="image-20230724155525547"></p>
<p>此操作也可以在控制面板完成，两者等效。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241555568.PNG" alt="crashcontrol2"></p>
<h2 id="使用键盘手动生成coredump"><a href="#使用键盘手动生成coredump" class="headerlink" title="使用键盘手动生成coredump"></a>使用键盘手动生成coredump</h2><p><a href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/debugger/forcing-a-system-crash-from-the-keyboard">Forcing a system crash from the keyboard</a></p>
<p>以USB keyboards为例：</p>
<p>修改注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\kbdhid\Parameters</code>，创建CrashOnCtrlScroll &#x3D; 0x01，重启后“Hold down the rightmost CTRL key, and press the SCROLL LOCK key twice.”系统会直接蓝屏，重启即可查看coredump文件。如果用windbg查看KeBugCheck查看错误码是0xE2: MANUALLY_INITIATED_CRASH。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241554830.png" alt="image-20230724155442525"></p>
]]></content>
      <categories>
        <category>windows系统</category>
      </categories>
      <tags>
        <tag>windows系统</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：使用GDB调试多线程</title>
    <url>/2021/07/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-GDB简介"><a href="#1-GDB简介" class="headerlink" title="1.GDB简介"></a>1.GDB简介</h1><p>官网文档：<br><a href="https://www.gnu.org/software/gdb/documentation/">GDB: The GNU Project Debugger</a></p>
<p>关于GDB的原理：<br><a href="https://cloud.tencent.com/developer/article/1365186">GDB实现原理和使用范例</a><br><a href="http://oenhan.com/gdb-principle">GDB工作原理和内核实现</a><br><a href="http://www.docin.com/p-18618736.html">GDB的基本工作原理</a></p>
<p>其他教程：<a href="http://c.biancheng.net/gdb/">GDB调试教程</a></p>
<p>几个重点：</p>
<ul>
<li>多种运行方式：gdb启动程序再调试(独立功能程序)，gdb attach进程再调试(服务端程序)，gdb加载core dump调试(离线调试)</li>
<li>GDB的本质是“截获”被调试程序，attach用ptrace截获了OS和应用程序之间的通信, 端点本质是trap中断，截获了CPU正常取指执行流程</li>
</ul>
<p>本文源码：<a href="https://github.com/cursorhu/SimpleMultiThread/tree/master/4.gdb_thread">cursorhu&#x2F;SimpleMultiThread&#x2F;4.gdb_thread&#x2F;</a></p>
<h1 id="2-多线程程序的GDB调试"><a href="#2-多线程程序的GDB调试" class="headerlink" title="2.多线程程序的GDB调试"></a>2.多线程程序的GDB调试</h1><p>待调试代码：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 0;
std::mutex g_mutex;

void thread_func1()
{
	while (true)
	{
		g_mutex.lock();
		++g_mydata;
		if(g_mydata == 1024)
			g_mydata = 0;
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

void thread_func2()
{
	while (true)
	{
		g_mutex.lock();
		std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

int main()
{
	std::thread t1(thread_func1);
	std::thread t2(thread_func2);
	t1.join();
	t2.join();
	return 0;
}
</code></pre>
<p>编译：</p>
<pre><code>g++ -g -std=c++11 cppthread.cpp -o cppthread -lpthread
</code></pre>
<p>-g: 带debug信息，gdb要用<br>-lpthread：链接pthread库。当应用直接调用POSIX&#x2F;pthread接口，或Linux环境中运行多线程都需要</p>
<h2 id="attach方式调试"><a href="#attach方式调试" class="headerlink" title="attach方式调试"></a>attach方式调试</h2><p>(1)后台运行并获取PID</p>
<ul>
<li>GDB调试已运行的程序，cppthread线程写成死循环，后台运行。</li>
<li>ps -ef | grep NAME 获取PID</li>
<li>pstree可以查看线程关系</li>
<li>LWP:轻量级进程，是用户线程和内核的中间接口。用户级线程连接LWP上便具有内核线程的所有属性。因此可以认为LWP ID对应线程ID</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534342.png" alt="1"></p>
<p>(2)gdb attach，管控进程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051544779.png" alt="2"></p>
<p>(3)查看所有线程信息<br>*表示当前在1号线程，注意这个ID是GDB attach后分配的，真实线程ID参考LWP<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534546.png" alt="3"></p>
<p>(4)查看线程backtrace<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535566.png" alt="4"></p>
<p>(5)切换线程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535346.png" alt="5"></p>
<p>(6)单步调试线程</p>
<ul>
<li>注意，GDB调试时是支持线程切换的，等同正常执行多线程，也可以禁用切换：<code>set scheduler-locking on</code>。本示例有mutex锁,未见到切换</li>
<li><code>next</code>: 单步（一步），<code>next n</code>: 单步n步</li>
<li><code>watch 变量</code>，可见<code>next 6</code>后g_mydata + 1</li>
<li><code>watch</code>会自动隐式的加断点，后文会看到断点信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535751.png" alt="6"></p>
<p>(7)断点</p>
<ul>
<li><code>break i</code>: 在代码i行加断点， <code>break func</code>:在函数加断点</li>
<li><code>clear i</code>: 清除i行的断点， <code>delete id</code>: 清除指定id的断点</li>
<li>注意看watch引入了一个断点11</li>
<li><code>continue</code>：继续执行，通常配合断点使用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535502.png" alt="7"></p>
<p>(8)线程外调试+多断点<br>两个工作线程都加断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535139.png" alt="8"><br>一次运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535180.png" alt="9"><br>继续运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536672.png" alt="10"></p>
<ul>
<li>Thread2和Thread3即工作线程，Thread1为主线程</li>
<li>Thread1会切到工作线程，LWP&#x3D;6080或6081</li>
<li>两次运行,Thread1切到的LWP不一样</li>
</ul>
<p>GDB显示主线程切到哪个工作线程，实际是CPU当前在执行哪个工作线程，因此两次运行到断点时，当前执行线程分别是Thread2和Thread3，主线程实际是阻塞的。</p>
<h2 id="GDB直接运行程序"><a href="#GDB直接运行程序" class="headerlink" title="GDB直接运行程序"></a>GDB直接运行程序</h2><p>用GDB运行程序的调试方式：</p>
<pre><code> gdb &lt; prog_name &gt;
</code></pre>
<p>(1)运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536065.png" alt="11"></p>
<p>(2)加断点和执行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536275.png" alt="12"></p>
<p>(3)查看变量值<br><code>p 变量</code>：打印变量，和<code>watch</code>相比不会加隐含的断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536108.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051537112.png" alt="14"></p>
<h2 id="core-dump文件方式调试"><a href="#core-dump文件方式调试" class="headerlink" title="core dump文件方式调试"></a>core dump文件方式调试</h2><p>有关core dump<br><a href="https://www.cnblogs.com/computer1-2-3/p/11114981.html">Linux 下如何产生core文件（core dump设置）</a><br><a href="https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/">Understand and configure core dumps on Linux</a><br><a href="https://www.cnblogs.com/uhziel/p/cpp_segmentation_fault.html">C++中段错误的常见情况</a><br><a href="https://blog.csdn.net/xuzhina/category_1322964.html">coredump问题原理探究(Linux版)
</a></p>
<p>下面修改前面的程序，制造core dump<br>(1)数组越界<br>cppthread_dump_array.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int g_mydata = 0;
std::mutex g_mutex;

char test_dump_buf[10] = {0};

void thread_func1()
{
	while (true)
	{
		g_mutex.lock();
		++g_mydata;
		char c;
		sprintf(&amp;c, &quot;%d&quot;, g_mydata);
		std::strcat(test_dump_buf, &amp;c); //持续追加g_mydata字符串
		if(g_mydata == 1024)
			g_mydata = 0;
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

void thread_func2()
{
	while (true)
	{
		g_mutex.lock();
		std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
		std::cout &lt;&lt; &quot;test_dump_buf: &quot; &lt;&lt; test_dump_buf &lt;&lt; std::endl;
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

int main()
{
	std::thread t1(thread_func1);
	std::thread t2(thread_func2);

	t1.join();
	t2.join();

	return 0;
}
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538738.png" alt="15"><br>并未发生段错误，更不谈core dump。因为CPP对数组没有越界限制，这是个“合法”行为</p>
<p>(2)使用空指针<br>cppthread_dump_nullptr.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
{
	public:
		Foo(int m)
		{
			m_data = m;
		}
		~Foo(){}
		void printval() 
		{
			std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
		}
		void increase()
		{
			++m_data;
		}
		int getval()
		{
			return m_data;
		}
		void resetval()
		{
			m_data = 0;
		}
		
	private:
		int m_data;
};

void thread_func1(Foo&amp; p)
{
	while (true)
	{
		g_mutex.lock();
		p.increase();
		if(p.getval() == 1024)
			p.resetval();
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

void thread_func2(Foo&amp; p)
{
	while (true)
	{
		g_mutex.lock();
		p.printval();
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

int main()
{	
	Foo *pFoo = new Foo(0);

	std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
	std::thread t2(thread_func2, std::ref(*pFoo));

	//t1.join();  //这里故意不join
	//t2.join();
	sleep(10);  //sleep等一下thread1,2
	
	delete pFoo; 
	pFoo = NULL;  //这时thread1,2还没执行完，形成了使用空指针的条件
			
	return 0;
}
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538644.png" alt="16"></p>
<p>下面gdb调试这个core dump</p>
<ul>
<li><p>设置core dump文件大小限制为不受限<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538876.png" alt="17"><br>最好写入配置文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538835.png" alt="18"></p>
</li>
<li><p>gdb加载程序和core dump文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538139.png" alt="19"><br>可见siganl 6发生，使进程终止</p>
</li>
<li><p>看dump位置，bt或where都可以<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538557.png" alt="20"></p>
</li>
<li><p>看所有线程的栈<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538027.png" alt="21"></p>
</li>
<li><p>直接看dump附近的代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051539217.png"></p>
</li>
</ul>
<p>结论：根据bt&#x2F;where, dump发生时，主进程在在执行67行：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542767.png" alt="image-20221205154207720"></p>
<p>根据源码，具体是工作线程调用对象的方法时发生<br>再看dump打印，正好要打印<code>m_data = 10</code>的时候dump，结合main中sleep(10)和工作线程sleep(1)，dump原因是main把对象指针置空了，而两个工作线程还在调用对象的方法，位置是thread_func2的p.printval()处</p>
<h2 id="一个示例：调试死锁"><a href="#一个示例：调试死锁" class="headerlink" title="一个示例：调试死锁"></a>一个示例：调试死锁</h2><p>最常见的死锁是双重加锁，和双重delete的道理一样，代码复杂了，层层调用的情况下容易出现<br>示例代码cppthread_deadlock.cpp：<br>线程函数和其调用的类方法都加锁了，形成死锁</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
{
	public:
		Foo(int m)
		{
			m_data = m;
		}
		~Foo(){}
		void printval() 
		{
			std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
		}
		void increase()
		{
			g_mutex.lock(); //故意制造双重加锁
			++m_data;
			g_mutex.unlock();
		}
		int getval()
		{
			return m_data;
		}
		void resetval()
		{
			m_data = 0;	
		}
		
	private:
		int m_data;
};

void thread_func1(Foo&amp; p)
{
	while (true)
	{
		g_mutex.lock();
		p.increase();
		if(p.getval() == 1024)
			p.resetval();
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

void thread_func2(Foo&amp; p)
{
	while (true)
	{
		g_mutex.lock();
		p.printval();
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

int main()
{	
	Foo *pFoo = new Foo(0);

	std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
	std::thread t2(thread_func2, std::ref(*pFoo));

	t1.join();
	t2.join();
	
	delete pFoo;
	pFoo = NULL;
			
	return 0;
}
</code></pre>
<p>调试：</p>
<ul>
<li>直接运行方式，要run起来才有线程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542989.png" alt="23"></p>
<ul>
<li>backtrace可见两个线程都停止于lock_wait()，其中thread2回溯看到死锁代码在45行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051546645.png" alt="24"></p>
<p>对于互斥锁推荐用RAII机制的<code>std::lock_guard&lt;mutex&gt; lockGuard(m)</code>，能避免忘记unlock情况。但在此示例中，lock_guard也会双重加锁。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：多线程的同步机制</title>
    <url>/2021/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>本文讲解并发环境中的几个线程同步示例<br>线程同步，即多个线程如何协调，谁先谁后<br>本文基于Linux&#x2F;POSIX API<br>本系列源码：<a href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p>生产者&#x2F;消费者模式是并发环境常见的模式，简单地讲，通过中介缓冲，支持多组任务并发执行，避免任务间发生通信阻塞。<br>参考：<a href="https://blog.csdn.net/darkdragonking/article/details/89208124">生产者&#x2F;消费者模式的理解及实现</a></p>
<p>常用的实现方式</p>
<ul>
<li>互斥量(参考<a href="http://47.100.221.149:9010/blog/post/admin/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89">多线程入门（一）</a>)</li>
<li>信号量</li>
<li>条件变量</li>
<li>读写锁</li>
</ul>
<h1 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h1><p>关于LInux信号量：<a href="https://www.jianshu.com/p/6e72ff770244">Linux信号量</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
{
public:
	Task(int taskID)
	{
		this-&gt;taskID = taskID;
	}
	
	void doTask()
	{
		std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
	}
	
private:
	int taskID;
};

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
sem_t            mysemaphore;

void* consumer_thread(void* param)
{	
	Task* pTask = NULL;
	while (true)
	{
		struct timespec ts;
		ts.tv_sec = 3;
		ts.tv_nsec = 0;
		
		if (sem_timewait(&amp;mysemaphore, &amp;ts) != 0)
		{
			if (errno == ETIMEOUT)
			{
				std::cout &lt;&lt; &quot;ETIMEOUT&quot; &lt;&lt; std::endl;
			}
			continue;
		}
		
		if (tasks.empty())
			continue;
		
		pthread_mutex_lock(&amp;mymutex);	
		pTask = tasks.front();
		tasks.pop_front();
		pthread_mutex_unlock(&amp;mymutex);
		
		pTask-&gt;doTask();
		delete pTask;
	}
	
	return NULL;
}

void* producer_thread(void* param)
{
	int taskID = 0;
	Task* pTask = NULL;
	
	while (true)
	{
		pTask = new Task(taskID);
			
		pthread_mutex_lock(&amp;mymutex);
		tasks.push_back(pTask);
		std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
		
		pthread_mutex_unlock(&amp;mymutex);
		
		//释放信号量，通知消费者线程
		sem_post(&amp;mysemaphore);
		
		taskID ++;

		//休眠1秒
		sleep(1);
	}
	
	return NULL;
}

int main()
{
	pthread_mutex_init(&amp;mymutex, NULL);
	//初始信号量资源计数为0
	sem_init(&amp;mysemaphore, 0, 0);

	//创建5个消费者线程
	pthread_t consumerThreadID[5];
	for (int i = 0; i &lt; 5; ++i)
	{
		pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
	}
	
	//创建一个生产者线程
	pthread_t producerThreadID;
	pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

	pthread_join(producerThreadID, NULL);
	
	for (int i = 0; i &lt; 5; ++i)
	{
		pthread_join(consumerThreadID[i], NULL);
	}
	
	sem_destroy(&amp;mysemaphore);
	pthread_mutex_destroy(&amp;mymutex);

	return 0;
}
</code></pre>
<p>说明几点：</p>
<ul>
<li>信号量和锁一样，全局的</li>
<li>sem_post和sem_wait是P(), V()操作的具体实现，即计数+1，-1</li>
</ul>
<h1 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h1><p>关于条件变量(cv)：<a href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量(condition variables)</a><br>条件变量同锁一起使用使得线程可以以一种无竞争的方式等待任意条件的发生。所谓无竞争就是，条件改变这个信号会发送到所有等待这个信号的线程。</p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
{
public:
	Task(int taskID)
	{
		this-&gt;taskID = taskID;
	}
	
	void doTask()
	{
		std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
	}
	
private:
	int taskID;
};

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
pthread_cond_t   mycv;

void* consumer_thread(void* param)
{	
	Task* pTask = NULL;
	while (true)
	{
		pthread_mutex_lock(&amp;mymutex);
		while (tasks.empty())
		{				
			//如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
			//当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
			pthread_cond_wait(&amp;mycv, &amp;mymutex);
		}
		
		pTask = tasks.front();
		tasks.pop_front();

		pthread_mutex_unlock(&amp;mymutex);
		
		if (pTask == NULL)
			continue;

		pTask-&gt;doTask();
		delete pTask;
		pTask = NULL;		
	}
	
	return NULL;
}

void* producer_thread(void* param)
{
	int taskID = 0;
	Task* pTask = NULL;
	
	while (true)
	{
		pTask = new Task(taskID);
			
		pthread_mutex_lock(&amp;mymutex);
		tasks.push_back(pTask);
		std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
		
		pthread_mutex_unlock(&amp;mymutex);
		
		//释放条件信号，通知消费者线程
		pthread_cond_signal(&amp;mycv);
		
		taskID ++;

		//休眠1秒
		sleep(1);
	}
	
	return NULL;
}

int main()
{
	pthread_mutex_init(&amp;mymutex, NULL);
	pthread_cond_init(&amp;mycv, NULL);

	//创建5个消费者线程
	pthread_t consumerThreadID[5];
	for (int i = 0; i &lt; 5; ++i)
	{
		pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
	}
	
	//创建一个生产者线程
	pthread_t producerThreadID;
	pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

	pthread_join(producerThreadID, NULL);
	
	for (int i = 0; i &lt; 5; ++i)
	{
		pthread_join(consumerThreadID[i], NULL);
	}
	
	pthread_cond_destroy(&amp;mycv);
	pthread_mutex_destroy(&amp;mymutex);

	return 0;
}
</code></pre>
<h1 id="读写锁实现"><a href="#读写锁实现" class="headerlink" title="读写锁实现"></a>读写锁实现</h1><p>关于读写锁，参考：<a href="https://www.cnblogs.com/love-DanDan/p/8723931.html">Linux：使用读写锁使线程同步</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;

int resourceID = 0;
pthread_rwlock_t myrwlock;

void* read_thread(void* param)
{	
	while (true)
	{
		//请求读锁
		pthread_rwlock_rdlock(&amp;myrwlock);

		std::cout &lt;&lt; &quot;read thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
				
		//使用睡眠模拟读线程读的过程消耗了很久的时间
		sleep(1);
				
		pthread_rwlock_unlock(&amp;myrwlock);
	}
	
	return NULL;
}

void* write_thread(void* param)
{
	while (true)
	{
		//请求写锁
		pthread_rwlock_wrlock(&amp;myrwlock);

		++resourceID;
		std::cout &lt;&lt; &quot;write thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
				
		//使用睡眠模拟读线程读的过程消耗了很久的时间
		sleep(1);
				
		pthread_rwlock_unlock(&amp;myrwlock);
	}
	
	return NULL;
}

int main()
{
	pthread_rwlock_init(&amp;myrwlock, NULL);

	//创建5个请求读锁线程
	pthread_t readThreadID[5];
	for (int i = 0; i &lt; 5; ++i)
	{
		pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);
	}
	
	//创建一个请求写锁线程
	pthread_t writeThreadID;
	pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);

	pthread_join(writeThreadID, NULL);
	
	for (int i = 0; i &lt; 5; ++i)
	{
		pthread_join(readThreadID[i], NULL);
	}
	
	pthread_rwlock_destroy(&amp;myrwlock);

	return 0;
}
</code></pre>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：线程库的使用</title>
    <url>/2021/07/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>多线程概述：应用层的多线程的目的就是让每一个任务（例如一系列函数调用）都认为自己独占CPU资源，即宏观上，多个任务可以同时执行（实际可能是轮转的串行执行）。<br>代码实现：线程库可以由编程语言的标准库或者操作系统的库实现，具体包含的头文件如下：</p>
<ul>
<li>C&#x2F;C++ : &lt; thread &gt;</li>
<li>POSIX(Portable Operating System Interface of UNIX, Linux环境使用较多) ：&lt; pthread.h &gt;</li>
<li>Windows OS : &lt; windows.h &gt;</li>
</ul>
<p>具体环境使用哪个库，有不同的观点，参考<br><a href="https://www.zhihu.com/question/36236334/answer/98422670">c++多线程编程主要用pthread还是c++11中的thread类？</a><br>即使是同一环境，也有不同封装层次的API<br><a href="https://blog.csdn.net/qq_22642239/article/details/90445414">CreateThread()与_beginthread()的区别详细解析</a></p>
<p>主线程与工作线程：<br>一般应用程序都有主要的执行流程，例如C&#x2F;C++的main入口函数，主要执行流程是在进程中执行的，也可以认为main是线程，独占了进程的全部资源，称为主线程。如果在该进程执行时，创建多个线程，用于并行处理其他任务，称为工作线程。</p>
<p>本文讲不同风格的线程创建\销毁，和访问共享数据的锁操作<br>本系列源码：<a href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="Windows风格多线程"><a href="#Windows风格多线程" class="headerlink" title="Windows风格多线程"></a>Windows风格多线程</h1><p>(1)双线程打印</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
{
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s &lt;&lt; endl;
    return 0;
}
 
int main()
{
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
	CloseHandle(hThread);
	
    return 0;
}
</code></pre>
<p>主线程和工作线程都运行Print()，各线程的栈空间保存自己的局部数据。<br>windows API使用CreateThread和CloseHandle创建线程、释放线程句柄，说明如下</p>
<pre><code>HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD：线程安全相关的属性，常置为NULL
    SIZE_T dwStackSize,//initialstacksize：新线程的初始化栈的大小，可设置为0
    LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction：被线程执行的回调函数，也称为线程函数
    LPVOID lpParameter,//threadargument：传入线程函数的参数，不需传递参数时为NULL
    DWORD dwCreationFlags,//creationoption：控制线程创建的标志
    LPDWORD lpThreadId//threadidentifier：传出参数，用于获得线程ID，如果为NULL则不返回线程ID
    )
 
/*
lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，决定返回的句柄是否可被子进程继承，如果为NULL则表示返回的句柄不能被子进程继承。
dwStackSize：设置初始栈的大小，以字节为单位，如果为0，那么默认将使用与调用该函数的线程相同的栈空间大小。
任何情况下，Windows根据需要动态延长堆栈的大小。
lpStartAddress：指向线程函数的指针，函数名称没有限制，但是必须以下列形式声明：
DWORD WINAPI 函数名 (LPVOID lpParam) ，格式不正确将无法调用成功。
lpParameter：向线程函数传递的参数，是一个指向结构的指针，不需传递参数时，为NULL。
dwCreationFlags：控制线程创建的标志，可取值如下：
（1）CREATE_SUSPENDED(0x00000004)：创建一个挂起的线程（就绪状态），直到线程被唤醒时才调用
（2）0：表示创建后立即激活。
（3）STACK_SIZE_PARAM_IS_A_RESERVATION(0x00010000)：dwStackSize参数指定初始的保留堆栈的大小，
如果STACK_SIZE_PARAM_IS_A_RESERVATION标志未指定，dwStackSize将会设为系统预留的值
lpThreadId:保存新线程的id
返回值：函数成功，返回线程句柄，否则返回NULL。如果线程创建失败，可通过GetLastError函数获得错误信息。
*/
 
BOOL WINAPI CloseHandle(HANDLE hObject);        //关闭一个被打开的对象句柄
/*可用这个函数关闭创建的线程句柄，如果函数执行成功则返回true(非0),如果失败则返回false(0)，
如果执行失败可调用GetLastError.函数获得错误信息。
*/
</code></pre>
<p>LPVOID 与 std::string类型的转换，需要用char*类型作中介，LPVOID接受buffer数组类型的转换<br>注意CloseHandle只是释放句柄资源，线程的资源释放是其函数执行完毕自动销毁的。</p>
<p>2次的运行结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png" alt="image-20221205152628474"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png"></p>
<p>可见，两个线程是随机切换的，导致如下现象：</p>
<ul>
<li>Print()内的<code>cout &lt;&lt; s</code>和<code>&lt;&lt;endl</code>之间线程被切换，导致没有换行+双重换行。</li>
<li>存在工作线程没执行完，主线程就执行完导致main return，整个进程销毁的情况。</li>
</ul>
<p>改进如下：</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
{
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s;
    return 0;
}
 
int main()
{
    std::string s1 = &quot;Work thread\n&quot;;
    std::string s2 = &quot;Main thread\n&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
	CloseHandle(hThread);
    Sleep(100);
    return 0;
}
</code></pre>
<p>使用以下方法解决上述问题</p>
<ul>
<li><p>主线程完成Print后，休眠100s，这个时间足够工作线程完成，Sleep结束后，main进程执行完毕</p>
</li>
<li><p>把换行放到字符串中，使该字符串的完整打印成为不可被中途切换的操作，即原子操作</p>
</li>
</ul>
<p>输出如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526645.png" alt="image-20221205152645608"></p>
<p>如果Print有很多句打印，又不希望中途切换线程，如何做？</p>
<ul>
<li>互斥锁可以实现“大块代码的原子操作”</li>
<li>锁是全局变量，因为主线程main和工作线程Print都能看到全局变量，而看不到对方的局部变量</li>
</ul>
<p>代码如下:</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
HANDLE hMutex = NULL;//互斥锁的句柄

DWORD WINAPI Print(LPVOID lpParamter)
{
    std::string s = (char*)lpParamter;

    for (int i = 0; i &lt; 10; i++)
    {
        WaitForSingleObject(hMutex, INFINITE);//请求锁
        cout &lt;&lt; s &lt;&lt; endl;
        ReleaseMutex(hMutex);//释放锁
    }

    return 0;
}
 
int main()
{
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;

    hMutex = CreateMutex(NULL, FALSE, NULL); //创建互斥锁
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
	
    CloseHandle(hThread);
    CloseHandle(hMutex);//销毁互斥锁
    
    return 0;
}
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526485.png" alt="image-20221205152654439"><br>关于windows的互斥锁：</p>
<pre><code>互斥量：
        采用互斥对象机制。互斥锁，像一个物件，这个物件只能同时被一个线程持有。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。
        一、创建 创建互斥锁的方法是调用函数CreateMutex： CreateMutex(&amp;sa, bInitialOwner, szName);第一个参数是一个指向SECURITY_ATTRIBUTES结构体的指针，一般的情况下，可以是nullptr。 第二个参数类型为BOOL，表示互斥锁创建出来后是否被当前线程持有。 第三个参数类型为字符串（const TCHAR*），是这个互斥锁的名字，如果是nullptr，则互斥锁是匿名的。 例： HANDLE hMutex = CreateMutex(nullptr, FALSE, nullptr);上面的代码创建了一个匿名的互斥锁，创建出来后，当前线程不持有这个互斥锁。

         二、持有 WaitForSingleObject函数可以让一个线程持有互斥锁。用法： WaitForSingleObject(hMutex, dwTimeout);这个函数的作用比较多。这里只介绍第一个参数为互斥锁句柄时的作用。 它的作用是等待，直到一定时间之后，或者，其他线程均不持有hMutex。第二个参数是等待的时间（单位：毫秒），如果该参数为INFINITE，则该函数会一直等待下去。

        三、释放 用ReleaseMutex函数可以让当前线程“放开”一个互斥锁（不持有它了），以便让其他线程可以持有它。用法 ReleaseMutex(hMutex)

         四、销毁 当程序不再需要互斥锁时，要销毁它。 CloseHandle(hMutex)

         五、命名互斥锁 如果CreateMutex函数的第三个参数传入一个字符串，那么所创建的锁就是命名的。当一个命名的锁被创建出来以后，当前进程和其他进程如果试图创建相同名字的锁，CreateMutex会返回原来那把锁的句柄，并且GetLastError函数会返回ERROR_ALREADY_EXISTS。这个特点可以使一个程序在同一时刻最多运行一个实例
</code></pre>
<h1 id="C-风格多线程"><a href="#C-风格多线程" class="headerlink" title="C++风格多线程"></a>C++风格多线程</h1><p>双线程分别实现计算和打印</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 1;
std::mutex g_mutex;

void thread_func1()
{
	while (g_mydata &lt; INT_MAX)
	{
		g_mutex.lock();
		++g_mydata;
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

void thread_func2()
{
	while (g_mydata &lt; INT_MAX)
	{
		g_mutex.lock();
		std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
		g_mutex.unlock();
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

int main()
{
	std::thread t1(thread_func1);
	std::thread t2(thread_func2);

	t1.join();
	t2.join();

	return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li>C++使用&lt; thread &gt;调用线程库</li>
<li>std::thread t(thread_func)创建一个thread对象，传入参数为thread_fun，即线程内执行的函数</li>
<li>t.join()的含义是，线程t执行完毕后，join函数才能返回，主线程才能继续向后执行，宏观上就是，主线程被t线程阻塞在join函数处，这也许就是join的含义，t线程“加入”主线程的队伍，主线程必须原地等待t准备好了（执行完了）才能继续向后走。</li>
<li>由于全局数据g_mydata和打印语句都不是原子操作，要保证完整操作，需要加锁，库定义在&lt; mutex &gt;</li>
<li>为什么要sleep? 注意两个工作线程都while循环操作，sleep是手动使当前线程休眠，操作系统会轮换到其他active状态的线程执行，如果不sleep, 一个线程一直执行再被OS切换，间隔可能很久。&lt; chrono &gt;库用于时间</li>
<li>INT_MAX是C++定义的int类最大值，2^31-1</li>
</ul>
<p>运行结果:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051527091.png" alt="image-20221205152705047"></p>
<h1 id="POSIX-Linux风格"><a href="#POSIX-Linux风格" class="headerlink" title="POSIX&#x2F;Linux风格"></a>POSIX&#x2F;Linux风格</h1><p>逻辑同上节，代码如下</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;limits.h&gt; //for INT_MAX

int g_mydata = 1;
pthread_mutex_t m;

void* thread_function1(void* args)
{
	while (g_mydata &lt; INT_MAX)
	{
		pthread_mutex_lock(&amp;m);
		++g_mydata;
		pthread_mutex_unlock(&amp;m);
		sleep(1);
	}
	
	return NULL;
} 

void* thread_function2(void* args)
{
	while (g_mydata &lt; INT_MAX)
	{	
		pthread_mutex_lock(&amp;m);
		std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl;
		pthread_mutex_unlock(&amp;m);
		sleep(1);
	}
	
	return NULL;
} 

int main()
{
	pthread_mutex_init(&amp;m, NULL);
	
	pthread_t threadIDs[2];	
	pthread_create(&amp;threadIDs[0], NULL, thread_function1, NULL);
	pthread_create(&amp;threadIDs[1], NULL, thread_function2, NULL);
	
	for(int i = 0; i &lt; 2; ++i)
	{
		pthread_join(threadIDs[i], NULL);
	}
	
	pthread_mutex_destroy(&amp;m);

	return 0;
}
</code></pre>
<p>win32应用程序使用pthread，需要配置pthread dll库，下载地址和配置方法：<br><a href="http://sourceware.org/pthreads-win32/">pthreads-win32</a><br><a href="https://www.cnblogs.com/lizhigang/p/7326022.html">VS2013 配置pthread</a></p>
<p>pthread的几个锁，参考：<br><a href="https://blog.csdn.net/guotianqing/article/details/80559865">linux线程互斥量pthread_mutex_t使用简介</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记：线程池</title>
    <url>/2021/07/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>线程池的概念和相关示例可以参考：<br><a href="https://blog.csdn.net/MOU_IT/article/details/88712090">C++实现线程池</a><br><a href="https://www.cnblogs.com/ailumiyana/p/10016965.html">基于C++11实现线程池的工作原理</a></p>
<p>本代码相关的C++基础，参考：<br><a href="https://www.cnblogs.com/alantu2018/p/8459250.html">c++拷贝构造函数详解</a><br><a href="https://www.cnblogs.com/jiayayao/archive/2016/12/03/6128877.html">智能指针shared_ptr的用法</a><br><a href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量</a></p>
<p>其他相关文章<br><a href="https://www.jianshu.com/u/9456fecb5f96">jorion&#x2F;c++11 多线程（X）</a><br><a href="https://github.com/jorionwen/threadtest">jorionwen&#x2F;threadtest</a></p>
<h1 id="线程池示例"><a href="#线程池示例" class="headerlink" title="线程池示例"></a>线程池示例</h1><h2 id="调用线程池"><a href="#调用线程池" class="headerlink" title="调用线程池"></a>调用线程池</h2><pre><code>#include &quot;TaskPool.h&quot;
#include &lt;chrono&gt;

int main()
{
    TaskPool threadPool;
    threadPool.init(); //初始化线程对象队列

    Task* task = NULL;
    for (int i = 0; i &lt; 10; ++i)
    {
        task = new Task();
        threadPool.addTask(task); //初始化任务对象队列，调度线程时会取出执行
    }
    
    std::this_thread::sleep_for(std::chrono::seconds(2));

    threadPool.stop(); //等待所有工作线程结束

    return 0; //析构
}
</code></pre>
<h2 id="线程池的方法"><a href="#线程池的方法" class="headerlink" title="线程池的方法"></a>线程池的方法</h2><pre><code>#include &quot;TaskPool.h&quot;

TaskPool::TaskPool() : m_bRunning(false)
{

}

TaskPool::~TaskPool()
{
    removeAllTasks();
}

void TaskPool::init(int threadNum/* = 5*/)
{
    if (threadNum &lt;= 0)
        threadNum = 5;

    m_bRunning = true;

    for (int i = 0; i &lt; threadNum; ++i)
    {
        std::shared_ptr&lt;std::thread&gt; spThread;
        //shared_ptr.reset带参数是初始化，指向new出的thread对象
        //bind绑定了thread对象和其执行函数threadFunc
        spThread.reset(new std::thread(std::bind(&amp;TaskPool::threadFunc, this))); 
        m_threads.push_back(spThread); //thread对象入队
    }
}

void TaskPool::threadFunc() //thread对象唤醒时执行
{
    std::shared_ptr&lt;Task&gt; spTask;
    while (true)
    {
        std::unique_lock&lt;std::mutex&gt; guard(m_mutexList); //RAII实现，作用域结束自动解锁
        while (m_taskList.empty())
        {                 
            if (!m_bRunning)
                break;
            
            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
            m_cv.wait(guard);
        }

        if (!m_bRunning)
            break;

        spTask = m_taskList.front(); //取m_taskList的task对象
        m_taskList.pop_front(); //更新m_taskList

        if (spTask == NULL)
            continue;

        spTask-&gt;doIt(); //执行task
        spTask.reset(); //shared_ptr.reset不带参数，指向对象的计数-1
    }

    std::unique_lock&lt;std::mutex&gt; guard(m_mutexList); //为了打印的原子性，再加锁
    {
        std::cout &lt;&lt; &quot;Exit thread, threadID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    }
    
}

void TaskPool::stop()
{
    m_bRunning = false;
    m_cv.notify_all(); //唤醒所有等待条件变量的线程

    //等待所有线程退出
    for (auto&amp; iter : m_threads)
    {
        if (iter-&gt;joinable())   //该线程是否可join
            iter-&gt;join();       //主线程等待该线程
    }
}

void TaskPool::addTask(Task* task)
{
    std::shared_ptr&lt;Task&gt; spTask;
    spTask.reset(task); //shared_ptr初始化，指向task

    {
        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);       
        //m_taskList.push_back(std::make_shared&lt;Task&gt;(task));
        m_taskList.push_back(spTask); //Task对象入队
        std::cout &lt;&lt; &quot;Add a Task.&quot; &lt;&lt; std::endl;
    }
    
    m_cv.notify_one(); //唤醒随机一个等待条件变量的线程
}

void TaskPool::removeAllTasks()   //析构时调用
{
    {
        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);
        for (auto&amp; iter : m_taskList)
        {
            iter.reset();
        }
        m_taskList.clear();
    }
}
</code></pre>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><pre><code>#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt; //for visual studio build

class Task
{
public:
    virtual void doIt()
    {
        std::cout &lt;&lt; &quot;Do a task...&quot; &lt;&lt; std::endl;
    }

    virtual ~Task()
    {
        //为了看到一个task的销毁，这里刻意补上其析构函数
        std::cout &lt;&lt; &quot;A task destructed...&quot; &lt;&lt; std::endl;
    }
};

class TaskPool final
{
public:
    TaskPool();
    ~TaskPool();
    TaskPool(const TaskPool&amp; rhs) = delete;     //delete: 禁用某函数（C++11），阻止拷贝和赋值构造，C++98用private
    TaskPool&amp; operator=(const TaskPool&amp; rhs) = delete;

public:
    void init(int threadNum = 5);   //默认初始化
    void stop();

    void addTask(Task* task);
    void removeAllTasks();

private:
    void threadFunc();

private:
    std::list&lt;std::shared_ptr&lt;Task&gt;&gt;            m_taskList;
    std::mutex                                  m_mutexList;
    std::condition_variable                     m_cv;
    bool                                        m_bRunning;
    std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt;   m_threads;
};
</code></pre>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221205152435385.png" alt="image-20221205152435385"></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>开发基础 -- 如何看懂UML类图</title>
    <url>/2020/12/09/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%20--%20%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。<br>统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。<br>UML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图<br>本文介绍开发中常用的类图</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。<br>首先讲解关系, 先来看一个例子：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148263.png" alt="image-20221205114810203"></p>
<p>分析一下上面的图, 首先从动物开始<br>动物是一个类 动物依赖氧气和水<br>然后鸟继承了动物，所以鸟的父类是动物 所以鸟是属于动物<br>然后鸟和翅膀是组合关系 一只鸟有两个翅膀<br>大雁鸭子和企鹅都是鸟所以继承了鸟类<br>大雁会有大雁群，大雁群是由大雁组成所以是聚合关系<br>企鹅和气候是关联关系因为企鹅需要依赖气候<br>然后再看大雁 大雁会飞翔 所以就实现了飞翔接口<br>唐老鸭是属于鸭子的 所以唐老鸭继承了鸭子这个类<br>上图是借鉴了大话设计模式里面的图。下面具体介绍各个符号的作用</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类一般是用三层矩形框表示，第一层表示类的名称，第二层表示的是字段和属性，第三层则是类的方法。第一层中，如果是抽象类，需用斜体显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148740.png" alt="image-20221205114819689"></p>
<h2 id="类符号"><a href="#类符号" class="headerlink" title="类符号"></a>类符号</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148030.png" alt="image-20221205114830981"><br>看上面的学生类里面有五个属性和两个方法</p>
<pre><code>+号表示公共的 public
-表示 私有的 private
#表示protected
</code></pre>
<p>带下划线表示静态属性，一般表示方法: +属性:类型。<br>括号内表示参数，后面是返回类型, 没有表示无返回值</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包(Package)： 是一种常规用途的组合机制。在UML中用一个Tab框表示，Tab里写上包的名称，框里则用来放一些其他子元素，比如类，子包等等。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148985.png" alt="image-20221205114837947"></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口(interface)：接口包含操作但不包含属性，且它没有对外界可见的关联<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148968.png" alt="image-20221205114843929"></p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>依赖(Dependency) 表示的是类之间的调用关系。UML中用带箭头的虚线表示依赖关系，而箭头所指的则是被依赖的类。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148704.png" alt="image-20221205114849672"></p>
<h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>泛化(Generalization)： 表示的是类之间的继承关系，注意是子类指向父类。UML中用带空心三角箭头的实线表示泛化关系，箭头指向的是一般个体。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148143.png" alt="image-20221205114855112"></p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联(Association) 表示的是类与类之间存在某种特定的对应关系。UML中用双向带箭头的虚线表示关联关系，箭头两端为相互关联的两个类<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051149187.png" alt="image-20221205114902153"></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合(Aggregation)： 是关联关系的一种特例，表示的是整体与部分之间的关系，部分不能离开整体单独存在。UML中用空心菱形头的实线表示聚合关系，菱形头指向整体<br><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221205114909206.png" alt="image-20221205114909206"></p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合(Composition)： 是聚合的一种特殊形式，表示的是类之间更强的组合关系。UML中用实心菱形头的实线来表示组合，菱形头指向整体。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051149567.png" alt="image-20221205114949528"></p>
]]></content>
      <categories>
        <category>开发基础</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>开发工具 -- Sourcetrail代码调用链可视化</title>
    <url>/2023/09/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%20--%20Sourcetrail%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E9%93%BE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>多种代码可视化分析工具<a href="https://www.slant.co/topics/16888/~code-visualization-and-analysis-tools">What are the best code visualization and analysis tools?</a></p>
<h2 id="Sourcetrail"><a href="#Sourcetrail" class="headerlink" title="Sourcetrail"></a>Sourcetrail</h2><p>官方文档：<a href="https://github.com/CoatiSoftware/Sourcetrail/blob/master/DOCUMENTATION.md#getting-started">Sourcetrail&#x2F;getting-started</a></p>
<p>使用方式：</p>
<p>(1) Linux kernel生成代码调用图</p>
<p>需要用bear编译kernel生成compile_commands.json作为索引数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bear -- make -j4</span><br></pre></td></tr></table></figure>

<p>sourcetrail导入compile_commands.json之后即可索引源码，生成调用链图</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202309181628303.png" alt="Screenshot from 2023-09-18 16-19-29"></p>
<p>(2) C++项目生成代码调用图</p>
<p>以Visual Studio编译的MFC项目为例，需要在Visual Studio安装sourcetrail插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Visual Studio-&gt;拓展-&gt;管理插件-&gt;联机VisualStudioMarket-&gt;搜索sourcetrail extension -&gt;安装</span><br></pre></td></tr></table></figure>

<p>安装之后生成database:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Visual Studio-&gt;拓展-&gt;sourcetrail -&gt; Create compilation database</span><br></pre></td></tr></table></figure>

<p>sourcetrail即可用compilation databas索引源码，生成调用链图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202309181634851.png" alt="image-20230918163406747"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>sourcetrail</tag>
      </tags>
  </entry>
  <entry>
    <title>开发工具 -- Xshell配置笔记</title>
    <url>/2019/12/06/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%20--%20Xshell%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>配置x’shell的默认字体以及一些操作设置</p>
<h1 id="会话设置"><a href="#会话设置" class="headerlink" title="会话设置"></a>会话设置</h1><p>设置主机<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457347.png" alt="1"><br>设置主机账号密码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457719.png" alt="2"><br>设置xshell字体<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457495.png" alt="3"></p>
<h1 id="操作设置"><a href="#操作设置" class="headerlink" title="操作设置"></a>操作设置</h1><p>设置Ctrl+c,Ctrl+v复制粘贴<br>工具-&gt;选项-&gt;编辑按键<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457000.png" alt="4"><br>新建按键，按ctrl+c<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061458030.png" alt="5"><br>设置功能为复制<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061458880.png" alt="6"><br>同理设置ctrl+v为粘贴<br>注意,原shell的ctrl+c终止程序，被替换成了shift+ctrl+c</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>开发工具 -- drawio绘图笔记</title>
    <url>/2023/09/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%20--%20drawio%E7%BB%98%E5%9B%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>advanced -&gt; 使用central idea, sub-topic, branch绘制</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202309201009000.png" alt="image-20230920100931945"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>drawio</tag>
      </tags>
  </entry>
  <entry>
    <title>开源学习 -- linked-list-good-taste</title>
    <url>/2023/03/28/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0%20--%20linked-list-good-taste/</url>
    <content><![CDATA[<p>本文转载自 <a href="https://github.com/mkirchner/linked-list-good-taste">linked-list-good-taste</a>，添加了个人理解的注释</p>
<h1 id="Linked-lists-pointer-tricks-and-good-taste"><a href="#Linked-lists-pointer-tricks-and-good-taste" class="headerlink" title="Linked lists, pointer tricks and good taste"></a>Linked lists, pointer tricks and good taste</h1><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-code">The code</a><ul>
<li><a href="#the-cs101-version">The CS101 version</a></li>
<li><a href="#a-more-elegant-solution">A more elegant solution</a></li>
</ul>
</li>
<li><a href="#how-does-it-work">How does it work?</a><ul>
<li><a href="#integrating-the-head-pointer">Integrating the head pointer</a></li>
<li><a href="#maintaining-a-handle">Maintaining a handle</a></li>
</ul>
</li>
<li><a href="#going-beyond">Going beyond</a><ul>
<li><a href="#inserting-before-existing-items">Inserting before existing items</a></li>
<li><a href="#quick-refactor">Quick refactor</a></li>
<li><a href="#implementing-insert_before">Implementing insert_before()</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In a 2016 <a href="https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux">TED interview</a> (14:10) Linus Torvalds speaks about what he considers <em>good taste</em> in coding. As an example, he presents two implementations of item removal in singly linked lists (reproduced below).  In order to remove the first item from a list, one of the implementations requires a special case, the other one does not.  Linus, obviously, prefers the latter.</p>
<p>His comment is:</p>
<blockquote>
<p>[…] I don’t want you to understand why it doesn’t have the if statement.<br>But I want you to understand that sometimes you can see a problem in a<br>different way and rewrite it so that a special case goes away and becomes the<br>normal case, and that’s <em>good code</em>. […] – L. Torvalds</p>
</blockquote>
<p>The code snippets he presents are C-style pseudocode and are simple enough to follow. However, as Linus mentions in the comment, the snippets lack a conceptual explanation and it is not immediately evident how the more elegant solution actually works.</p>
<p>The next two sections look at the technical approach in detail and demonstrate how and why the indirect addressing approach is so neat. The last section extends the solution from item deletion to insertion.</p>
<h2 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h2><p>The basic data structure for a singly linked list of integers is shown in Figure 1.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281032617.png" alt="linked list"></p>
<p>Numbers are arbitrarily chosen integer values and arrows indicate pointers. <code>head</code> is a pointer of type <code>list_item *</code> and each of the boxes is an instance of an <code>list_item</code> struct, each with a member variable (called <code>next</code> in the code) of type <code>list_item *</code> that points to the next item.</p>
<p>The C implementation of the data structure is:</p>
<p><strong>注释：list的item包含两个成员：值和指针变量；list本身是用head指针表示</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> <span class="title">list_item</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We also include a (minimal) API:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The textbook version */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br><span class="line"><span class="comment">/* A more elegant solution */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br></pre></td></tr></table></figure>

<p>With that in place, let’s have a look at the implementations of <code>remove_cs101()</code> and <code>remove_elegant()</code>. The code of these examples is true to the pseudocode from Linus’ example and also compiles and runs.</p>
<h3 id="The-CS101-version"><a href="#The-CS101-version" class="headerlink" title="The CS101 version"></a>The CS101 version</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281919267.png" alt="image-20230328191958119"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item *cur = l-&gt;head, *prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != target) &#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev)</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                l-&gt;head = cur-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释：如果将list理解为(值+指针变量)成员组成的一串数据，那么访问一个成员的前置成员就得用经典的双指针法，因为单链表没有”记忆性”，要额外的前置指针保存前置位置。</strong></p>
<p><strong>考虑边界条件：1.遍历完了都找不到目标成员；2.前置指针在使用前要判空，如果为空，表明第一个节点就是目标节点，这两种情况都属于上述代码的else case处理</strong></p>
<p>The standard CS101 approach makes use of two traversal pointers <code>cur</code> and <code>prev</code>, marking the current and previous traversal position in the list, respectively.  <code>cur</code> starts at the list head <code>head</code>, and advances until the target is found.  <code>prev</code> starts at <code>NULL</code> and is subsequently updated with the previous value of <code>cur</code> every time <code>cur</code> advances. After the target is found, the algorithm tests if <code>prev</code> is non-<code>NULL</code>. If yes, the item is not at the beginning of the list and the removal consists of re-routing the linked list around <code>cur</code>. If <code>prev</code> is <code>NULL</code>, <code>cur</code> is pointing to the first element in the list, in which case, removal means moving the list head forward.</p>
<h3 id="A-more-elegant-solution"><a href="#A-more-elegant-solution" class="headerlink" title="A more elegant solution"></a>A more elegant solution</h3><p>The more elegant version has less code and does not require a separate branch to deal with deletion of the first element in a list.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code uses an indirect pointer <code>p</code> that holds the address of a pointer to a list item, starting with the address of <code>head</code>.  In every iteration, that pointer is advanced to hold the address of the pointer to the next list item, i.e. the address of the <code>next</code> element in the current <code>list_item</code>.<br>When the pointer to the list item <code>*p</code> equals <code>target</code>, we exit the search loop and remove the item from the list.</p>
<h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h2><p>The key insight is that using an indirect pointer <code>p</code> has two conceptual benefits:</p>
<ol>
<li>It allows us to interpret the linked list in a way that makes the <code>head</code> pointer an integral part the data structure. This eliminates the need for a special case to remove the first item.</li>
<li>It also allows us to evaluate the condition of the <code>while</code> loop without having to let go of the pointer that points to <code>target</code>. This allows us to modify the pointer that points to <code>target</code> and to get away with a single iterator as opposed to <code>prev</code> and <code>cur</code>.</li>
</ol>
<p>Let’s look each of these points in turn.</p>
<h3 id="Integrating-the-head-pointer"><a href="#Integrating-the-head-pointer" class="headerlink" title="Integrating the head pointer"></a>Integrating the <code>head</code> pointer</h3><p>The standard model interprets the linked list as a sequence of <code>list_item</code> instances. The beginning of the sequence can be accessed through a <code>head</code> pointer. This leads to the conceptual model illustrated in Figure 2 above. The <code>head</code> pointer is merely considered as a handle to access the start of the list. <code>prev</code> and <code>cur</code> are pointers of type <code>list_item *</code> and always point to an item or <code>NULL</code>.</p>
<p>The elegant implementation uses indirect addressing scheme that yields a different view on the data structure:</p>
<p><strong>注释：核心就是改变对链表数据结构的理解，将链表的最小单元理解为：前置指针 + (值+指针变量)成员，这样需要一个二级指针指向成员内的指针变量，链表也没有特殊性，每个成员一定有非空的前置指针和(值+指针变量)，如下图的蓝色框。</strong></p>
<p><strong>这个方法本质上是双指针的优化，只用一个二级指针就可以同时访问目标节点和前置的节点的指针变量，解决了单链表遍历过程中，找到目标节点后无法反向获得前置节点的指针变量的问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281920824.png" alt="image-20230328192017690"></p>
<p>Here, <code>p</code> is of type <code>list_item **</code> and holds the address of the pointer to the current list item. When we advance the pointer, we forward to the address of the pointer to the next list item.</p>
<p>In code, this translates to <code>p = &amp;(*p)-&gt;next</code>, meaning we</p>
<ol>
<li><code>(*p)</code>: dereference the address to the pointer to the current list item</li>
<li><code>-&gt;next</code>: dereference that pointer again and select the field that holds the address of the next list item</li>
<li><code>&amp;</code>: take the address of that address field (i.e. get a pointer to it)</li>
</ol>
<p>This corresponds to an interpretation of the data structure where the list is a a sequence of pointers to <code>list_item</code>s (cf. Figure 3).</p>
<h3 id="Maintaining-a-handle"><a href="#Maintaining-a-handle" class="headerlink" title="Maintaining a handle"></a>Maintaining a handle</h3><p>An additional benefit of that particular interpretation is that it supports editing the <code>next</code> pointer of the predecessor of the current item throughout the entire traversal.</p>
<p>With <code>p</code> holding the address of a pointer to a list item, the comparison in the search loop becomes</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (*p != target)</span><br></pre></td></tr></table></figure>

<p>The search loop will exit if <code>*p</code> equals <code>target</code>, and once it does, we are still able to modify <code>*p</code> since we hold its address <code>p</code>. Thus, despite iterating the loop until we hit <code>target</code>, we still maintain a handle (the address of the <code>next</code> field or the <code>head</code> pointer) that can be used to directly modify the pointer that points <em>to</em> the item.</p>
<p>This is the reason why we can modify the incoming pointer to an item to point to a different location using <code>*p = target-&gt;next</code> and why we do not need <code>prev</code> and <code>cur</code> pointers to traverse the list for item removal.</p>
<h2 id="Going-beyond"><a href="#Going-beyond" class="headerlink" title="Going beyond"></a>Going beyond</h2><p>It turns out that the idea behind <code>remove_elegant()</code> can be applied to yield a particularly concise implementation of another function in the list API:<code>insert_before()</code>, i.e. inserting a given item before another one.</p>
<h3 id="Inserting-before-existing-items"><a href="#Inserting-before-existing-items" class="headerlink" title="Inserting before existing items"></a>Inserting before existing items</h3><p>First, let’s add the following declaration to the list API in <code>list.h</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span>;</span><br></pre></td></tr></table></figure>

<p>The function will take a pointer to a list <code>l</code>, a pointer <code>before</code> to an item in that list and a pointer to a new list item <code>item</code> that the function will insert before <code>before</code>.</p>
<h3 id="Quick-refactor"><a href="#Quick-refactor" class="headerlink" title="Quick refactor"></a>Quick refactor</h3><p><strong>注释：单链表的删除节点和前向插入节点有共同的痛点：找到目标节点后无法反向获得前置节点的指针变量，此二级指针方法完美解决这类问题。</strong></p>
<p>Before we move on, we refactor the search loop into a separate function</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> list_item **<span class="title function_">find_indirect</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>and use that function in <code>remove_elegant()</code> like so</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, target);</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Implementing-insert-before"><a href="#Implementing-insert-before" class="headerlink" title="Implementing insert_before()"></a>Implementing <code>insert_before()</code></h3><p>Using <code>find_indirect()</code>, it is straightforward to implement <code>insert_before()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, before);</span><br><span class="line">        *p = item;</span><br><span class="line">        item-&gt;next = before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A particularly beautiful outcome is that the implementation has consistent semantics for the edge cases: if <code>before</code> points to the list head, the new item will be inserted at the beginning of the list, if <code>before</code> is <code>NULL</code> or invalid (i.e. the item does not exist in <code>l</code>), the new item will be appended at the end.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The premise of the more elegant solution for item deletion is a single, simple change: using an indirect <code>list_item **</code> pointer to iterate over the pointers to the list items.  Everything else flows from there: there is no need for a special case or branching and a single iterator is sufficient to find and remove the target item.<br>It also turns out that the same approach provides an elegant solution for item insertion in general and for insertion <em>before</em> an existing item in particular.</p>
<p>So, going back to Linus’ initial comment: is it good taste? Hard to say, but it’s certainly a different, creative and very elegant solution to a well-known CS task.</p>
]]></content>
      <categories>
        <category>开源学习</category>
      </categories>
      <tags>
        <tag>开源学习</tag>
      </tags>
  </entry>
  <entry>
    <title>开源学习 -- nodejs使用pm2部署项目</title>
    <url>/2020/05/20/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0%20--%20nodejs%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>nodejs服务可以用<code>nohup node xxx.js &amp;</code>后台启动，但是实际使用发现不太稳定，使用专门的node后台服务管理工具：pm2解决此问题</p>
<h1 id="pm2特性"><a href="#pm2特性" class="headerlink" title="pm2特性"></a>pm2特性</h1><p>1、内建负载均衡（使用Node cluster 集群模块）<br>2、后台运行<br>3、0秒停机重载<br>4、具有Ubuntu和CentOS 的启动脚本<br>5、停止不稳定的进程（避免无限循环）<br>6、控制台检测<br>7、提供 HTTP API<br>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p>
<h1 id="pm2安装"><a href="#pm2安装" class="headerlink" title="pm2安装"></a>pm2安装</h1><pre><code>npm install -g pm2
</code></pre>
<h1 id="pm2用法"><a href="#pm2用法" class="headerlink" title="pm2用法"></a>pm2用法</h1><pre><code>pm2 start app.js        //启动进程
pm2 start app.js -i 4   // 后台运行pm2，启动4个app.js
pm2 start app.js -i max //启动，使用所有CPU核心
pm2 start app.js --name my-api // 命名进程
pm2 list               // 显示所有进程状态
pm2 monit              // 监视所有进程
pm2 logs               //  显示所有进程日志
pm2 stop all           // 停止所有进程
pm2 restart all        // 重启所有进程
pm2 reload all         // 0秒停机重载进程 (用于 NETWORKED 进程)
pm2 stop 0             // 停止指定的进程
pm2 restart 0          // 重启指定的进程
pm2 startup            // 产生 init 脚本 保持进程活着
pm2 web                // 运行健壮的 computer API endpoint 
pm2 delete 0           // 杀死指定的进程
pm2 delete all         // 杀死全部进程
</code></pre>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>部署Github项目NodeMail，每天给指定邮箱发邮件。</p>
<p>后台启动main.js并监测状态：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427417.png" alt="image-20221206142729375"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427110.png" alt="image-20221206142743066"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427682.png" alt="image-20221206142752627"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061428280.png" alt="image-20221206142800236"></p>
]]></content>
      <categories>
        <category>开源学习</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>开源学习 -- tinyhttpd</title>
    <url>/2020/12/03/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0%20--%20tinyhttpd/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Tinyhttpd是一个C + CGI实现的简单http server，适合初学者学习。代码许可协议：GPL，copyright 1999, by J. David Blackstone.<br>本文对Tinyhttp稍作注释和改动，验证并理解其主要流程, 本文源码：<br>Github: <a href="https://github.com/cursorhu/myTinyHttpd">cursorhu&#x2F;myTinyHttpd</a></p>
<h1 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2.背景知识"></a>2.背景知识</h1><h2 id="TCP套接字的通信流程"><a href="#TCP套接字的通信流程" class="headerlink" title="TCP套接字的通信流程"></a>TCP套接字的通信流程</h2><p>网络协议栈的核心是TCP&#x2F;IP协议，HTTP本质上是对TCP的应用层封装，要理解HTTP服务程序，首先要理解TCP层的通信机制，在Linux环境中TCP采用socket接口通信，流程如下图<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121451104.png" alt="image-20221212145149039"><br>关于Linux网络编程相关知识，参考《Linux网络编程-第二版》<br>TinyHttpd实现服务端的流程。</p>
<h2 id="HTTP的请求方式"><a href="#HTTP的请求方式" class="headerlink" title="HTTP的请求方式"></a>HTTP的请求方式</h2><p>参考：<br><a href="https://www.cnblogs.com/williamjie/p/9099940.html">浅谈HTTP中GET、POST用法以及它们的区别</a><br><a href="https://blog.csdn.net/eson_15/article/details/88083280">99%的人都理解错了HTTP中GET与POST的区别</a><br>理解以下几点：</p>
<ul>
<li>GET，POST，PUT，DELETE是http层对数据操作的封装，底层本质还是TCP的read&#x2F;write过程</li>
<li>http server处理请求的基本流程：读取-拆解-处理-封装-回写，拆解和封装的就是http层的请求和数据格式，处理是指TCP层能理解的数据。就像快递退货时的流程：取件-拆包-查看-装包-寄出</li>
</ul>
<h2 id="CGI的时代背景"><a href="#CGI的时代背景" class="headerlink" title="CGI的时代背景"></a>CGI的时代背景</h2><p>参考：<a href="https://www.jianshu.com/p/c4dc22699a42">CGI是什么</a></p>
<ul>
<li>CGI是2000年的web接口标准，后端部署perl-CGI脚本，连接server处理程序和web客户端</li>
<li>CGI目前还应用在嵌入式web等C-based环境，这个和当前web主流的Java Spring + Vue(JS)是完全不同的应用场景，所以CGI技术本身并无过时一说。</li>
</ul>
<h1 id="3-调试httpd"><a href="#3-调试httpd" class="headerlink" title="3.调试httpd"></a>3.调试httpd</h1><h2 id="部署httpd服务"><a href="#部署httpd服务" class="headerlink" title="部署httpd服务"></a>部署httpd服务</h2><p>Aliyun CentOS环境，运行如下deploy.sh：</p>
<pre><code>#!/bin/bash
chmod +x htdocs/*.cgi
yum install -y perl perl-CGI
make clean &amp;&amp; make
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452836.png" alt="image-20221212145206784"></p>
<h2 id="浏览器访问httpd"><a href="#浏览器访问httpd" class="headerlink" title="浏览器访问httpd"></a>浏览器访问httpd</h2><p>服务端直接运行httpd，会分配随机可用端口，本地chrome浏览器访问该服务所在的ip:端口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452831.png" alt="image-20221212145218796"></p>
<p>这里ip即为httpd所在主机ip，默认访问资源是htdocs&#x2F;index.html，原因可见httpd.c的http Get请求解析url的处理<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452854.png" alt="image-20221212145227807"></p>
<p>index.h调用color.cgi脚本：</p>
<pre><code>&lt;HTML&gt;
&lt;TITLE&gt;Index&lt;/TITLE&gt;
&lt;BODY&gt;
&lt;P&gt;Welcome to J. David&#39;s webserver.
&lt;H1&gt;CGI demo: get color
&lt;FORM ACTION=&quot;color.cgi&quot; METHOD=&quot;POST&quot;&gt;
Enter color(example: red, pink, blue): &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;color&quot;&gt;
&lt;INPUT TYPE=&quot;submit&quot;&gt;
&lt;/FORM&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p>color.cgi内容：</p>
<pre><code>#!/usr/bin/perl -Tw

use strict;
use CGI;

my($cgi) = new CGI;

print $cgi-&gt;header;
my($color) = &quot;blue&quot;;
$color = $cgi-&gt;param(&#39;color&#39;) if defined $cgi-&gt;param(&#39;color&#39;);

print $cgi-&gt;start_html(-title =&gt; uc($color),
                       -BGCOLOR =&gt; $color); 
print $cgi-&gt;h1(&quot;This is $color&quot;);
print $cgi-&gt;end_html;
</code></pre>
<p>干了两件事：</p>
<ul>
<li>html页面的bgcolor参数设置成了用户输入的color变量字符串</li>
<li>显示字符串：This is $color</li>
</ul>
<p>输入“red”, 浏览器显示效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452042.png" alt="image-20221212145241997"></p>
<p>F12打开浏览器调试窗口，可见：</p>
<ul>
<li>访问资源为color.cgi</li>
<li>查看http head内容，浏览器客户端的请求是POST，类型是text文本，表单数据(Form data):color的值是red</li>
<li>查看http response内容，即httpd返回的内容。返回了html文本，即浏览器可见的红色页面</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452614.png" alt="image-20221212145258548"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121455408.png" alt="image-20221212145533364"></p>
<p>现在理解以下整个流程：</p>
<ul>
<li>服务器上httpd先运行，处于监听(listen)客户端请求的状态</li>
<li>本地浏览器输入服务器ip：端口，访问httpd，发送的http请求类型是GET,即获取文本</li>
<li>httpd收到请求，在处理过程中调用cgi脚本，生成response的内容</li>
<li>httpd打包内容成http层的格式(head+body+…)，返回浏览器客户端</li>
<li>浏览器客户端解析html文本并显示成可见的页面。</li>
</ul>
<p>再看另外一个获取时间的功能：<br>浏览器输入<code>ip:port/date.html</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453695.png" alt="image-20221212145316645"><br>访问的资源是date.cgi，返回了显示当前时间的页面<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453222.png" alt="image-20221212145338163"><br>看下http请求和响应<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453850.png" alt="image-20221212145345780"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453273.png" alt="image-20221212145353230"></p>
<p>date.cgi的实现：shell直接调用linux <code>date</code>命令</p>
<pre><code>#!/bin/bash
echo &quot;Content-Type: text/html&quot;
echo
echo &quot;&lt;HTML&gt;&lt;BODY&gt;&quot;
echo &quot;&lt;CENTER&gt;Today is:&lt;/CENTER&gt;&quot;
echo &quot;&lt;CENTER&gt;&lt;B&gt;&quot;
date
echo &quot;&lt;/B&gt;&lt;/CENTER&gt;&quot;
echo &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;
</code></pre>
<h2 id="TCP-socket访问httpd-测试"><a href="#TCP-socket访问httpd-测试" class="headerlink" title="TCP socket访问httpd(测试)"></a>TCP socket访问httpd(测试)</h2><p>client.c直接使用socket接口访问httpd，这是个测试功能，因此用编译参数控制了该功能, <code>make test_sock=y</code>编译该版本的httpd<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454984.png" alt="image-20221212145401934"><br>client和httpd在同一主机，直接访问回环地址127.0.0.1，可见httpd返回了client发送的字符’A’</p>
<h1 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h1><h2 id="1-httpd的处理http请求的主要流程"><a href="#1-httpd的处理http请求的主要流程" class="headerlink" title="(1) httpd的处理http请求的主要流程"></a>(1) httpd的处理http请求的主要流程</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454501.png" alt="image-20221212145417431"></p>
<ol>
<li>服务器启动，在指定端口或随机选取端口绑定 httpd 服务</li>
<li>收到一个 HTTP 请求时（其实就是 listen 的端口 accpet 的时候），派生一个线程运行 accept_request 函数</li>
<li>取出 HTTP 请求中的 method (GET 或 POST) 和 url,。对于 GET 方法，如果有携带参数，则 query_string 指针指向 url 中 ？ 后面的 GET 参数</li>
<li>格式化 url 到 path 数组，表示浏览器请求的服务器文件路径，在 tinyhttpd 中服务器文件是在 htdocs 文件夹下。当 url 以 &#x2F; 结尾，或 url 是个目录，则默认在 path 中加上 index.html，表示访问主页</li>
<li>如果文件路径合法，对于无参数的 GET 请求，直接输出服务器文件到浏览器，即用 HTTP 格式写到套接字上，然后跳到（10）。其他情况（带参数 GET，POST 方式，url 为可执行文件），则调用 excute_cgi 函数执行 cgi 脚本</li>
<li>读取整个 HTTP 请求并丢弃，如果是 POST 则找出 Content-Length. 把 HTTP 200 状态码写到套接字</li>
<li>建立两个管道，cgi_input 和 cgi_output, 并 fork 一个进程</li>
<li>在子进程中，把 STDOUT 重定向到 cgi_outputt 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端，设置 request_method 的环境变量，GET 的话设置 query_string 的环境变量，POST 的话设置 content_length 的环境变量，这些环境变量都是为了给 cgi 脚本调用，接着用 execl 运行 cgi 程序</li>
<li>在父进程中，关闭 cgi_input 的读取端 和 cgi_output 的写入端，如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT。接着关闭所有管道，等待子进程结束。管道状态参考下图。</li>
<li>关闭与浏览器的连接，完成了一次 HTTP 请求与回应， HTTP是无连接的。</li>
</ol>
<p>管道初始状态：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454140.png" alt="image-20221212145427091"><br>管道最终状态：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454591.png" alt="image-20221212145432542"></p>
<p>主要函数：</p>
<ul>
<li>startup: 初始化httpd服务，包括建立服务端的套接字，绑定端口，进行监听等</li>
<li>accept_request: 处理从套接字上监听到的一个 HTTP 请求，是服务器处理请求的主流程</li>
<li>execute_cgi: 运行cgi程序的处理，对应POST请求</li>
<li>sever_file: 调用cat把服务器文件返回给浏览器，对应GET请求</li>
</ul>
<p>辅助功能函数：</p>
<ul>
<li>get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束</li>
<li>unimplemented: 返回给浏览器表明收到的HTTP请求所用的method不支持，httpd只支持GET和POST</li>
<li>headers: 把HTTP响应的头部写到套接字</li>
<li>cat: 读取服务器上的指定文件写到socket套接字</li>
</ul>
<h2 id="2-httpd处理client的socket请求"><a href="#2-httpd处理client的socket请求" class="headerlink" title="(2)httpd处理client的socket请求"></a>(2)httpd处理client的socket请求</h2><p>参考TCP套接字流程，注意一点，server端回写数据后，要close掉，client才能正常close。<br>编译选项的实现讲一下：<br>Makefile根据输入参数，定义宏, 如果编译输入带参<code>make test_sock=y</code>，则定义宏TEST_SOCK，等价于在源码<code>#define TEST_SOCK</code></p>
<pre><code>#用编译选项定义宏
ifeq ($(test_sock), y)
CFLAGS+= -D TEST_SOCK
endif
</code></pre>
<p>httpd.c对宏的处理：</p>
<pre><code>#ifdef TEST_SOCK
void test_sock(int);
#else
#define test_sock(...)  do{}while(0)
#endif
</code></pre>
<p>这里如果没定义TEST_SOCK，直接把test_sock函数声明成do{}while(0)形式，这种控制在linux kernel源码中很常见，好处是不需要在调用处加宏控制，若TEST_SOCK未定义，调用test_sock()等价于空语句。<code>...</code>代表所有入参</p>
<p>扩展：httpd能否同时支持浏览器和client程序访问?<br>一个socket描述符只能对应一个客户端，如果server想要一对多的IO复用，需要select-poll机制，参考：<br><a href="https://www.cnblogs.com/feily/articles/14030297.html">IO多路复用之select、poll、epoll</a><br><a href="https://blog.csdn.net/zouli415/article/details/79696766">linux下socket编程实现一个服务器连接多个客户端</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/nengm1988/p/7816618.html">Tinyhttpd精读解析</a><br><a href="https://github.com/EZLippi/Tinyhttpd">EZLippi&#x2F;Tinyhttpd</a></p>
]]></content>
      <categories>
        <category>开源学习</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>开源学习 -- xv6环境搭建</title>
    <url>/2023/05/06/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0%20--%20xv6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本文在Ubuntu22.04上搭建xv6(x86版本)的开发环境，用于编译、调试xv6源码。</p>
<ul>
<li>xv6 x86版本参考<a href="https://pdos.csail.mit.edu/6.828/2018/overview.html">MIT6.828&#x2F;2018</a></li>
<li>xv6 riscv版本参考<a href="https://pdos.csail.mit.edu/6.828/2020/">MIT6.S081</a> ，MIT6.828从2019年以后以RISCV指令集实现，并拆分了课程</li>
</ul>
<p>两者的课程内容区别：</p>
<p>6.828 and 6.S081 will be offered as two separate classes. 6.S081 (Introduction to Operating Systems) will be taught as a stand-alone AUS subject for undergraduates, and will provide an introduction to operating systems. 6.828 will be offered as a graduate-level seminar-style class focused on research in operating systems. 6.828 will assume you have taken 6.S081 or an equivalent class.</p>
<p>为什么选用x86版本：</p>
<p>x86版本有更完善的资料和更细节的代码讲解，参考：</p>
<p><a href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p><a href="https://github.com/woai3c/MIT6.828">woai3c&#x2F;MIT6.828</a></p>
<p>学完x86版本再学riscv版本，只需要关注指令集差异即可</p>
<h2 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h2><p>主流程参考：<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">Tools Used in 6.828</a></p>
<p>这里只记录我操作过程中和该wiki的差异点</p>
<p>1.下载包有的连接失败，bing搜索到合适的下载源后，最终成功下载的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br></pre></td></tr></table></figure>

<p>2.编译Toolchain中的问题：</p>
<p>(0)<strong>注意!!!</strong> 在编译Toolchain完成以后要恢复默认的LD_LIBRARY_PATH，不要在toolchain配置了LD_LIBRARY_PATH的情况下去完成后续的安装qemu等其他任何操作，否则可能系统损害无法进入桌面且不能recovery，报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libgnutls.so.30 undefined symbol: __gmpz_limbs_write</span><br></pre></td></tr></table></figure>

<p>问题原因和解决办法参考：<a href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined"><a href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined">apt-get wants an older GNUTLS version to be defined</a></a></p>
<p><strong>LIB PATH导致系统损坏的经验：搭建开发环境配置的LD_LIBRARY_PATH不要随便export；在使用时export, 使用完毕后恢复</strong></p>
<p>(1)如果安装在&#x2F;usr&#x2F;local，所有make install都要sudo；安装在home不需要sudo</p>
<p>(2)编译gcc时报错：<code>configure: error: cannot compute suffix of object files: cannot compile</code></p>
<p>需要export PATH，由于所有编译包都安装在&#x2F;usr&#x2F;local&#x2F;，所以export PATH也为&#x2F;usr&#x2F;local&#x2F;，保存为export-path.sh方便重启后使用，也可以加到~&#x2F;.bashrc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>(3)编译gdb时报错：<code>error: no termcap library found</code></p>
<p>要手动下载termcap包并编译，操作过程和toolchain一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>完整的编译脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export PFX=~/xv6/toolchain #这里编译到home,也可以用/usr/local</span><br><span class="line">mkdir -p $PFX</span><br><span class="line">cd $PFX</span><br><span class="line"></span><br><span class="line">#install a development environment.</span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line">sudo apt-get install gcc-multilib</span><br><span class="line"></span><br><span class="line">#Building Your Own Compiler Toolchain</span><br><span class="line">#wget容易失败，因此这部分最好手动执行，确保全部下载成功</span><br><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br><span class="line"></span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">tar xjf gmp-5.0.2.tar.bz2</span><br><span class="line">cd gmp-5.0.2</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf mpfr-3.1.2.tar.bz2</span><br><span class="line">cd mpfr-3.1.2</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xzf mpc-0.9.tar.gz</span><br><span class="line">cd mpc-0.9</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf binutils-2.21.1.tar.bz2</span><br><span class="line">cd binutils-2.21.1</span><br><span class="line">./configure --prefix=$PFX --target=i386-jos-elf --disable-werror</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gcc-core-4.6.4.tar.bz2</span><br><span class="line">cd gcc-4.6.4</span><br><span class="line">mkdir build              # GCC will not compile correctly unless you build in a separate directory</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=$PFX \ </span><br><span class="line">    --with-gmp=$PFX --with-mpfr=$PFX --with-mpc=$PFX \ #指定gmp, mpfr, mpc位置</span><br><span class="line">    --target=i386-jos-elf --disable-werror \</span><br><span class="line">    --disable-libssp --disable-libmudflap --with-newlib \</span><br><span class="line">    --without-headers --enable-languages=c MAKEINFO=missing</span><br><span class="line">make all-gcc</span><br><span class="line">make install-gcc         # This step may require privilege (sudo make install-gcc)</span><br><span class="line">make all-target-libgcc</span><br><span class="line">make install-target-libgcc     # This step may require privilege (sudo make install-target-libgcc)</span><br><span class="line">cd ../..</span><br><span class="line"></span><br><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gdb-7.3.1.tar.bz2</span><br><span class="line">cd gdb-7.3.1</span><br><span class="line">./configure --prefix=$PFX \</span><br><span class="line">    --target=i386-jos-elf --program-prefix=i386-jos-elf- \</span><br><span class="line">    --disable-werror</span><br><span class="line">make all</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">i386-jos-elf-objdump -i</span><br><span class="line"># Should produce output like:</span><br><span class="line"># BFD header file version (GNU Binutils) 2.21.1</span><br><span class="line"># elf32-i386</span><br><span class="line">#  (header little endian, data little endian)</span><br><span class="line">#   i386...</span><br><span class="line"></span><br><span class="line">i386-jos-elf-gcc -v</span><br><span class="line"># Should produce output like:</span><br><span class="line"># Using built-in specs.</span><br><span class="line"># COLLECT_GCC=i386-jos-elf-gcc</span><br><span class="line"># COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/i386-jos-elf/4.6.4/lto-wrapper</span><br><span class="line"># Target: i386-jos-elf</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=&quot;&quot; #恢复系统本身的libpath(默认空)，避免装其他软件有lib冲突造成系统损坏</span><br></pre></td></tr></table></figure>

<h2 id="交叉编译的参数"><a href="#交叉编译的参数" class="headerlink" title="交叉编译的参数"></a>交叉编译的参数</h2><p>在交叉编译configure时，通常会需要设置–build、–host和–target选项。各个选项的含义如下：</p>
<ul>
<li>–build：编译所用的机器的平台。</li>
<li>–host：编译出的代码运行的平台。</li>
<li>–target：编译出来的工具链生成的代码的运行平台。这个选项不常用，一般只在编译gcc、ld等工具链的过程中用到。</li>
</ul>
<p>在不涉及到交叉编译的时候，–build、–host、–target缺省值都是本机平台，不需要特别设置。</p>
<p>在交叉编译的时候，比如需要在x86平台编译arm程序，就需要设置–build和–host选项；其中host的内容为目标平台名称，通常编译器的名字前缀就是目标平台名称，例如用arm-unknown-linux-gnueabi-gcc编译，–host设置为arm-unknown-linux-gnueabi；–build可以缺省不设置就是使用当前平台名称</p>
<h2 id="编译QEMU"><a href="#编译QEMU" class="headerlink" title="编译QEMU"></a>编译QEMU</h2><p>xv6使用的QEMU是patched version，要手动编译，过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/mit-pdos/6.828-qemu.git qemu</span><br><span class="line"></span><br><span class="line">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span><br><span class="line"></span><br><span class="line">#此qemu版本需要python2 (2.7), 由于python2和3不兼容, 且系统只有Python3, 因此需要安装</span><br><span class="line">sudo apt install python2</span><br><span class="line">python2 -V</span><br><span class="line">cd qemu</span><br><span class="line"></span><br><span class="line">./configure --disable-kvm --disable-werror --prefix=$PFX --target-list=&quot;i386-softmmu x86_64-softmmu&quot; --python=/usr/bin/python2</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>qemu编译错误的解决办法：<a href="https://github.com/woai3c/MIT6.828/blob/master/docs/install.md">MIT6.828 实验环境安装教程</a></p>
<p>其中以下错误的解决方法： 在 <code>qga/commands-posix.c</code> 文件中加 <code>#include &lt;sys/sysmacros.h&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qga/commands-posix.c: In function ‘dev_major_minor’:</span><br><span class="line">qga/commands-posix.c:633:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;.</span><br></pre></td></tr></table></figure>

<h2 id="运行xv6"><a href="#运行xv6" class="headerlink" title="运行xv6"></a>运行xv6</h2><p>下载6.828的jos lab，make产生kernel.img</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></pre></td></tr></table></figure>

<p>运行qemu的xv6之前，需要export PATH和LD_LIBRARY_PATH；运行之后要清掉LD_LIBRARY_PATH为空(重启或手动清除)</p>
<p>写export_xv6.sh如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PFX=~/xv6/toolchain</span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>建议给调用export_xv6.sh的命令加别名(alias)到.bashrc，可以用get-xv6命令一键export：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias get_xv6=&#x27;. $HOME/xv6/export_xv6.sh&#x27;</span><br></pre></td></tr></table></figure>

<p>如果是本地执行qemu(带GUI)用<code>make qemu</code>; 如果是远程终端执行用<code>make qemu-nox</code>。qemu内容如下表示qemu环境搭建OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit</span><br><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log </span><br><span class="line">VNC server running on `127.0.0.1:5900&#x27;</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源学习</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派：使用ALSA+A2DP+PulseAudio自制蓝牙音箱</title>
    <url>/2021/09/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8ALSA-A2DP-PulseAudio%E8%87%AA%E5%88%B6%E8%93%9D%E7%89%99%E9%9F%B3%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>树莓派4B自带蓝牙和Wifi, 无需外接 USB dongle；<br>蓝牙最常见的应用是近距离传输数据，比如蓝牙传文件，蓝牙音箱等。正好家里有个普通的usb供电的便携音箱；</p>
<p>本文用树莓派蓝牙+普通音箱，实现简单的蓝牙音箱。</p>
<p>首先需要了解Linux音频系统的整体框架：<br><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221208194352559.png" alt="image-20221208194352559"></p>
<p>大致分为三个部分：</p>
<ul>
<li>kernel&#x2F;driver层的ALSA驱动框架</li>
<li>蓝牙音频协议栈：A2DP, 这是使蓝牙具有传输音频流能力的基石; Linux官方的bluez包实现了A2DP</li>
<li>音频应用层, Linux最常用的音频服务器是Pulse Audio</li>
</ul>
<p>怎样理解这三层：可以类比Linux网络层：<br>ALSA 类似网络驱动框架<br>A2DP 类似TCP&#x2F;UDP层<br>PulseAudio 类似HTTP层的服务器，类比Apache</p>
<p>而蓝牙连接类似http连接和会话；<br>声卡(输入、输出)类似网卡(Ethernet和wifi)，音频设备(音箱，麦克风)类似具体的网口设备</p>
<p>深入了解 ALSA 音频驱动和 A2DP 蓝牙音频协议，参考：<br><a href="https://www.alsa-project.org/wiki/Main_Page">Advanced Linux Sound Architecture (ALSA) project homepage</a><br><a href="http://www.dslreports.com/r0/download/2285126~a70eb148e16b921dc323dbb977d4b4b1/A2DP_SPEC.pdf">A2DP Spec</a></p>
<p>本文的环境<br>树莓派4B, 系统: ubuntu-server raspberry pi版本<br>音箱：usb供电，音频线<br>安卓手机：用于配对树莓派的蓝牙音频服务</p>
<p>连接示意图</p>
<pre><code> Audio source (i.e. smartphone) 
                |
                v
 (((  Wireless Bluetooth Channel  )))
                |
                v
  Raspberry PI (with A2DP service)
                |
                v
         Audio Interface
                |
                v
             Speakers
</code></pre>
<h1 id="使用alsa-utils测试音频设备"><a href="#使用alsa-utils测试音频设备" class="headerlink" title="使用alsa-utils测试音频设备"></a>使用alsa-utils测试音频设备</h1><p>首先测试Linux上如何使用普通音箱<br>将音箱USB连到树莓派USB, 音频线连到音频接口</p>
<h2 id="查看音频设备"><a href="#查看音频设备" class="headerlink" title="查看音频设备"></a>查看音频设备</h2><p>ALSA在应用层提供了alsa-utils包，其含有arecord、aplay等工具来查看和使用音频设备。</p>
<pre><code>apt-get install alsa-utils
</code></pre>
<p>查看声卡列表：</p>
<pre><code>cat /proc/asound/cards
</code></pre>
<p>可以看到当前有两张声卡</p>
<p>card 0是树莓派的bcm2835集成声卡，card 1 是另外接的USB麦克风</p>
<p>注意区分声卡和音频设备，一个声卡可以管理多个音频设备，类似于”总线”和”设备”的关系。</p>
<p>音频设备可以细分为输入和输出两种：例如音箱是播放音频，属于输出；麦克风是录入音频，属于输入。下面分别查看这两类设备。</p>
<p>查看音频输入设备：</p>
<pre><code>arecord -l
</code></pre>
<p>查看音频输出设备：</p>
<pre><code>aplay -l
</code></pre>
<h2 id="使用音频设备"><a href="#使用音频设备" class="headerlink" title="使用音频设备"></a>使用音频设备</h2><p>(1)测试音频输出：</p>
<pre><code>aplay test.wav -D plughw:CARD=0,DEV=0
</code></pre>
<p>音频设备用 CARD 和 DEV 指定，来自于前文<code>aplay -l</code>查看音频设备的输出<br>测试音频(wav格式)可以在此下载：<a href="https://www.ape8.cn/wav/">ape8.cn</a></p>
<p>(2)测试音频输入：</p>
<p>使用arecord录制音频输入<br>-f 录制音频格式。例如 cd 表示 (16 bit little endian, 44100, stereo)<br>-d 录制时间，单位秒<br>-c 输入通道的个数，如果是麦克风阵列可能有多通道<br>-D 使用的设备：-D hw:1,0 表示使用 card 1 下的device 0设备</p>
<p>测试如下：</p>
<pre><code>arecord -f cd -d 5 -c 1 -D hw:1,0 &gt; test.pcm
</code></pre>
<p>然后播放此音频：</p>
<pre><code>aplay test.pcm
</code></pre>
<h1 id="蓝牙服务相关配置"><a href="#蓝牙服务相关配置" class="headerlink" title="蓝牙服务相关配置"></a>蓝牙服务相关配置</h1><h2 id="蓝牙协议栈和服务的安装"><a href="#蓝牙协议栈和服务的安装" class="headerlink" title="蓝牙协议栈和服务的安装"></a>蓝牙协议栈和服务的安装</h2><p>首先确保系统软件是最新：</p>
<pre><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>安装 bluez，pulseaudio 等蓝牙基础组件，对于树莓派还要安装pi-bluetooth</p>
<pre><code>sudo apt-get install pi-bluetooth bluez bluez-tools pulseaudio pulseaudio-module-bluetooth
</code></pre>
<p>bluez 是Linux官方的蓝牙协议栈，其内部实现 A2DP 蓝牙音频协议，参考<a href="http://www.bluez.org/about/">bluez.org</a></p>
<p>PulseAudio 是Linux音频服务器, 其最主要的作用是：<br>PulseAudio clients can send audio to “sinks” and receive audio from “sources”</p>
<p>参考<a href="https://www.freedesktop.org/wiki/Software/PulseAudio/About/">PulseAudio&#x2F;About</a></p>
<p>简单说明下蓝牙的发送、接收的概念：<br>蓝牙的Source端为发送码流的端，Sink端为接收码流的端；可类比生产者和消费者模型</p>
<h2 id="启动音频服务"><a href="#启动音频服务" class="headerlink" title="启动音频服务"></a>启动音频服务</h2><p>PulseAudio服务需要创建用户名和用户组，示例如下：</p>
<pre><code>sudo usermod -G bluetooth -a ubuntu
</code></pre>
<p>启动服务器</p>
<pre><code>pulseaudio --start
</code></pre>
<h2 id="启动蓝牙配对"><a href="#启动蓝牙配对" class="headerlink" title="启动蓝牙配对"></a>启动蓝牙配对</h2><p>蓝牙首次连接需要配对，使用 bluez 的 <code>bluetoothctl</code>工具</p>
<p>参考：<a href="https://www.makeuseof.com/manage-bluetooth-linux-with-bluetoothctl/">How to Manage Bluetooth Devices on Linux Using bluetoothctl</a></p>
<pre><code>bluetoothctl //进入蓝牙配置模式，会显示用户为[bluetooth]#
[bluetooth]# list //列出树莓派的蓝牙控制器列表
[bluetooth]# agent on //注册蓝牙代理
[bluetooth]# default-agent //使用默认代理
[bluetooth]# discoverable on //树莓派的蓝牙可被其他设备发现
[bluetooth]# scan on //开始扫描可连接蓝牙设备
</code></pre>
<p>此后选择要连接的蓝牙设备，手机蓝牙打开，<code>scan on</code>列表找到手机的 MAC地址 进行连接配对。<br>手机的MAC可在设置-&gt;系统信息查看</p>
<pre><code>[bluetooth]# pair &lt;dev&gt; //配对设备，首次需要密码
[bluetooth]# trust &lt;dev&gt; //信任该设备，此后可以自动配对无需密码
[bluetooth]# connect &lt;dev&gt; //建立连接
</code></pre>
<p>现在可以退出 bluetoothctl模式，然后测试蓝牙音频播放：</p>
<pre><code>[bluetooth]# quit
aplay test.wav
</code></pre>
<p>关于蓝牙的agent，参考<a href="https://askubuntu.com/questions/763939/bluetoothctl-what-is-a-bluetooth-agent">bluetoothctl - What is a bluetooth agent?</a></p>
<h2 id="设置自动配对连接"><a href="#设置自动配对连接" class="headerlink" title="设置自动配对连接"></a>设置自动配对连接</h2><p>为了避免每次pair都要指定设备，可以配置蓝牙打开时，自动pair上次的设备。</p>
<p>编辑PulseAudio配置文件 <code>/etc/pulse/default.pa</code> </p>
<pre><code># automatically switch to newly-connected devices
load-module module-switch-on-connect
</code></pre>
<p>编辑bluez配置文件 <code>/etc/bluetooth/main.conf</code></p>
<pre><code>[Policy]
AutoEnable=true
</code></pre>
<p>系统重启后只需要重启PulseAudio服务：</p>
<pre><code>pulseaudio --start
</code></pre>
<h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><h2 id="找不到蓝牙controller"><a href="#找不到蓝牙controller" class="headerlink" title="找不到蓝牙controller"></a>找不到蓝牙controller</h2><p>最开始bluetoothctl list显示的蓝牙控制器列表是空的，我一度怀疑买了假的raspi-4B</p>
<p>原因是树莓派需要安装专门的蓝牙包 pi-bluetooth，参考<a href="https://raspberrypi.stackexchange.com/questions/114586/rpi-4b-bluetooth-unavailable-on-ubuntu-20-04">rpi-4b-bluetooth-unavailable-on-ubuntu</a></p>
<p>树莓派很多功能都要求系统有定制包，大多数硬件失效都是定制包未安装。</p>
<h2 id="蓝牙连接正常，播放没声音"><a href="#蓝牙连接正常，播放没声音" class="headerlink" title="蓝牙连接正常，播放没声音"></a>蓝牙连接正常，播放没声音</h2><p>首先确认音频设备物理连接是否正常；</p>
<p>然后确认PulseAudio音频服务是否正常，检查服务状态和配置文件；</p>
<pre><code>pacmd info
pactl info
</code></pre>
<p>问题仍没有解决，仔细听似乎有很小的声音，检测音量配置：</p>
<pre><code>pacmd list-sinks //找到sink设备，即音箱
pacmd set-sink-volume &lt;sink&gt; &lt;value&gt; //设置音量，value取值 [0, 65536] 代表标准音量 0~100%
</code></pre>
<p>参考：<a href="https://askubuntu.com/questions/219739/adjust-max-possible-volume-in-pulseaudio#:~:text=pactl%20set-sink-volume%200%20100%25%20Where%200%20is%20the,100%25%20to%20get%20audio%20boost%20%28200%25%20for%20example%29.">adjust max possible volume in pulseaudio</a></p>
<p>此时播放音乐可以听到但声音极小；<br>检查音箱的线控音量调节，调到最大；<br>此时蓝牙音乐只有正常音箱大概 30% 的播放音量。</p>
<p>原因是树莓派的USB供电驱动能力有限，同一音箱，在PC-USB供电下30%的音量大小等同于树莓派上100%的音量大小。</p>
<p>自此蓝牙播放音量可以达到正常水平，需要更高音量和音质建议220V供电的音箱。</p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p><a href="https://www.jianshu.com/p/1b79537da86d">Ubuntu音频设备检测</a><br><a href="https://www.nicolabs.net/2020/Make-RPi-bluetooth-speaker-part-1">Make-RPi-bluetooth-speaker-part-1</a><br><a href="https://gist.github.com/actuino/9548329d1bba6663a63886067af5e4cb">actuino&#x2F;bt_speaker-raspberry_pi-zero_w</a><br><a href="https://gist.github.com/oleq/24e09112b07464acbda1#file-a2dp-autoconnect-L17">A2DP audio streaming using Raspberry PI</a></p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派：使用mjpg-streamer+Apache+SSH自制网络摄像头</title>
    <url>/2021/08/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8mjpg-streamer-Apache+SSH%E8%87%AA%E5%88%B6%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h1><ul>
<li>为什么用树莓派4：</li>
</ul>
<p>资料多遇到容易解决问题；<br>性能较强适合作为终端服务器；<br>自带WIFI, BT5.0，GPIO 方便拓展开发IOT相关项目；<br>适配系统丰富，基本PC上linux版本树莓派都有对应版本</p>
<ul>
<li>为什么用USB摄像头：</li>
</ul>
<p>为了快速实现，Linux对USB设备支持非常好，USB设备基本都是免驱；<br>USB摄像头支持高分辨率，带麦克风，满足其他项目拓展应用；<br>当然CSI接口摄像头也有优势，同等条件下其CPU占用率比USB低；不过本地测试中CPU并不是USB摄像头性能瓶颈<br>关于CSI和USB 摄像头区别：<a href="https://blog.csdn.net/ZhaoDongyu_AK47/article/details/103981905">CSI摄像头 vs USB摄像头</a></p>
<ul>
<li>树莓派用什么系统：</li>
</ul>
<p>看个人喜好，我用的ubuntu server的树莓派版本，软件源基本最新；</p>
<ul>
<li>用什么云服务器：</li>
</ul>
<p>看个人喜好和价格；云服务器最大价值在于公网IP<br>我目前用的Aliyun + CentOS7 系统</p>
<p>系统实拍：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081944910.png" alt="image-20221208194427802"></p>
<h1 id="树莓派系统安装"><a href="#树莓派系统安装" class="headerlink" title="树莓派系统安装"></a>树莓派系统安装</h1><p>准备：电源，网线，SD卡<br>安装步骤：</p>
<ul>
<li>1.下载ubuntu server for raspi</li>
</ul>
<p>注意一定要下载raspi版本的镜像，普通ubuntu server版本安装完不能直接使用SSH<br><a href="https://ubuntu.com/download/raspberry-pi">Install Ubuntu on a RaspberryPi</a></p>
<ul>
<li>2.Win32DiskImager写.img镜像到SD卡，作为系统盘</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/bhniunan/article/details/104790090">使用win32DiskImager为树莓派4B安装系统</a></p>
<ul>
<li>3.SSH 登陆</li>
</ul>
<p>ubuntu server for raspi系统装机启动后，连接网线到主机局域网后就可以SSH登陆<br>树莓派连到主机网段路由器的LAN口，树莓派系统默认开了dhcp, 用Advanced IP Scanner扫描树莓派IP</p>
<p>树莓派4b：mac地址“dc-a6-32”开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081944582.png" alt="image-20221208194446543"></p>
<p>SSH 软件看个人喜好，putty, SecureCRT, Xshell都可以，我个人使用的SecureCRT</p>
<p>ubuntu server for raspi系统的SSH会话初始化如下：<br>新建会话-&gt; SSH2链接-&gt; 树莓派ip -&gt; 账户名(默认ubuntu)<br>初始密码：ubuntu，登陆成功后需要重设密码。</p>
<p>wifi配置方式参考 <a href="https://blog.csdn.net/weixin_42378324/article/details/114631521">树莓派安装ubuntu server, 无显示屏和键盘</a></p>
<ul>
<li>4.固定树莓派IP</li>
</ul>
<p>DHCP方式每次启动树莓派IP可能不一样，有两种方式固定IP</p>
<ul>
<li>MAC绑定IP<br>参考<a href="https://blog.csdn.net/Echozi/article/details/104210167">TL-WR886N路由器+树莓派绑定IP地址</a></li>
<li>手动配置固定ip<br><a href="https://blog.csdn.net/u010169607/article/details/111316624">Pi4B 树莓派 ubuntu20.04 设置固定IP地址</a></li>
</ul>
<h1 id="USB摄像头测试"><a href="#USB摄像头测试" class="headerlink" title="USB摄像头测试"></a>USB摄像头测试</h1><ul>
<li>首先主机win10上验证摄usb像头功能正常</li>
</ul>
<p>设备管理器禁用笔记本原装摄像头驱动，搜索相机-&gt; 打开视频，视频流应该正常</p>
<ul>
<li>在树莓派上验证摄像头设备</li>
</ul>
<p>usb摄像头设备既是usb设备又是v4l2设备，应该挂载在&#x2F;dev&#x2F;videoX</p>
<pre><code>ls /dev/video*
ls /dev | grep video
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945191.png" alt="image-20221208194510165"><br>插拔摄像头确认usb摄像头对应设备是video0</p>
<h1 id="树莓派安装mjpg-streamer"><a href="#树莓派安装mjpg-streamer" class="headerlink" title="树莓派安装mjpg-streamer"></a>树莓派安装mjpg-streamer</h1><p>mjpg-streamer的作用是将摄像头采集的YUV&#x2F;JPEG数据，封装成流服务，其他设备可以通过http方式获取图片或视频流。<br>mjpg-streamer属于应用层实现流媒体服务端，其底层调用的是Linux V4L2框架接口。</p>
<p>安装过程：</p>
<ol>
<li><p>依赖库安装</p>
<p>sudo apt-get install subversion libjpeg8-dev imagemagick libv4l-dev cmake git</p>
</li>
<li><p>安装mjpg-streamer</p>
<p>git clone <a href="https://github.com/jacksonliam/mjpg-streamer.git">https://github.com/jacksonliam/mjpg-streamer.git</a><br>cd mjpg-streamer&#x2F;mjpg-streamer-experimental&#x2F;<br>make all<br>sudo make install</p>
</li>
</ol>
<h1 id="局域网测试mjpg-streamer"><a href="#局域网测试mjpg-streamer" class="headerlink" title="局域网测试mjpg-streamer"></a>局域网测试mjpg-streamer</h1><p>mjpg-streamer&#x2F;mjpg-streamer-experimental目录下有测试脚本：<code>start.sh</code><br>环境变量添加依赖库路径：</p>
<pre><code>export LD_LIBRARY_PATH=&quot;$(pwd)&quot; 
</code></pre>
<p>运行示例：</p>
<pre><code>./mjpg_streamer -i &quot;./input_uvc.so&quot; -o &quot;./output_http.so -w ./www&quot; 
</code></pre>
<p>其YUV&#x2F;MJPEG的输入使用 input_uvc.so， 输出流到 http依赖于 output_http.so，<code>-w ./www</code> 表示http客户端访问时返回www文件夹下的资源，即对应的浏览器页面。</p>
<p>可以自定义参数，参考：</p>
<pre><code>mjpg_streamer -i &quot;input_uvc.so --help&quot;
</code></pre>
<p>修改start.sh的自定义启动语句如下：</p>
<pre><code>./mjpg_streamer -i &quot;./input_uvc.so -n -f 30 -r 640x480 -d /dev/video0&quot;  -o &quot; ./output_http.so -w ./www&quot;
</code></pre>
<p>-n 用于跳过一些ioctrl请求，我的摄像头如果不用-n，有一些ioctrl会返回错误，尽管不影响流传输功能，还是跳过。<br>-f 设置fps，如果有卡顿考虑降低该值<br>-r 分辨率，1080P摄像头可以支持到1920x1080<br>-d 设备名，默认&#x2F;dev&#x2F;video0</p>
<p>一般USB摄像头支持直接输出压缩后的MJPEG格式图像，有的只支持YUV格式图像；<br>摄像头优先使用MJPEG格式，因为不用mjpg-streamer软件边采集边做压缩，减少CPU使用</p>
<p>启动信息：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945245.png" alt="image-20221208194525192"></p>
<p>此时流服务已运行，在局域网任意设备用浏览器访问<code>树莓派ip:流服务端口</code>即可获取www目录的网页资源<br>192.168.0.105是我树莓派固定ip, 8080是mjpg-streamer服务默认端口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945636.png" alt="image-20221208194549504"><br>局域网下即使是1080p 30fps也非常流畅，看不出卡顿</p>
<h1 id="公网服务器搭建反向代理"><a href="#公网服务器搭建反向代理" class="headerlink" title="公网服务器搭建反向代理"></a>公网服务器搭建反向代理</h1><h2 id="反向代理的概念"><a href="#反向代理的概念" class="headerlink" title="反向代理的概念"></a>反向代理的概念</h2><p>正向代理和反向代理的概念图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946618.png" alt="image-20221208194609572"></p>
<p>正向代理：代理的是客户端，例如GFW禁止某用户直接访问目标服务器的8080端口，但没有禁止访问正向代理服务器，客户端访问正向代理服务器，代理服务将用户请求转发给目标服务器，实现“蛙跳式”访问。对于目标服务器来说，正向代理服务器才是其客户端，用户ip对其是不可见的。<br>反向代理：代理的是服务端，应用于以下场景：</p>
<ul>
<li>出于安全考虑，目标服务器不直接暴露其ip和端口，用户通过访问反向代理服务器来间接访问目标服务器</li>
<li>保证系统稳定性：反向代理服务器可以代理多个目标服务器，当用户请求量大时作为负载均衡(<a href="https://blog.csdn.net/ywd1992/article/details/112858537">负载均衡和反向代理的区别</a>); 支持目标服务器作为集群管理，当某个目标服务器失效时将请求转发到其他服务器, 参考<a href="https://www.cnblogs.com/jkko123/p/6426857.html">centos7下apache2.4反向代理</a></li>
</ul>
<p>对于本项目，树莓派的mjpg-streamer进程是真正提供流媒体服务的目标服务器，阿里云公网服务器上安装apache服务，实现反向代理。</p>
<h2 id="安装apache服务"><a href="#安装apache服务" class="headerlink" title="安装apache服务"></a>安装apache服务</h2><p>Apache实现http web服务器；没有apache, 客户浏览器页面没办法访问对应服务。<br>阿里云主机 cent-OS 7 上的安装过程：</p>
<pre><code>//安装Apache
yum install httpd
//设置服务器开机自动启动Apache
systemctl enable httpd.service
//启动Apache
systemctl start httpd.service
//重启
systemctl restart httpd.service
//停止
systemctl stop httpd.service    
</code></pre>
<p>启动apache后，直接访问阿里云ip，默认端口 80 即为 apache 进程端口，得到如下页面说明服务正常<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946493.png" alt="image-20221208194622426"></p>
<h2 id="配置apache为反向代理"><a href="#配置apache为反向代理" class="headerlink" title="配置apache为反向代理"></a>配置apache为反向代理</h2><p>apache相关配置路径在&#x2F;etc&#x2F;httpd的几个conf目录<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946576.png" alt="image-20221208194635517"></p>
<p><code>vim /etc/httpd/conf/httpd.conf</code> 查看关键内容如下:</p>
<pre><code>Listen 80 //监听80端口
Include conf.modules.d/*.conf //包含module.d目录的所有conf
DocumentRoot &quot;/var/www/html&quot; //默认返回该目录的html资源
IncludeOptional conf.d/*.conf //包含conf.d目录的所有conf
</code></pre>
<p><code>/etc/httpd/conf.modules.d</code>目录下的<code>00-proxy.conf</code>是针对代理的配置项，其中有大量LoadModule加载proxy模块。<br>配置内容是XML格式，在此自定义反向代理，追加以下内容：</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ProxyRequests off
    &lt;Proxy raspi&gt;
        Order allow,deny
        Allow from all
    &lt;/Proxy&gt;
    ProxyPass /raspi http://127.0.0.1:9020
    ProxyPassReverse /raspi http://127.0.0.1:9020
&lt;/VirtualHost&gt;
</code></pre>
<p>含义：<br><code>&lt;VirtualHost *:80&gt;</code> 定义一个虚拟主机，<em>表示任意命名，端口80<br><code>ProxyRequests off</code> 关闭正向代理<br><code>&lt;Proxy raspi&gt;</code>定义一个代理对象，可以命名为</em>，这里命名为raspi因为后端服务是raspi流服务<br><code>ProxyPass</code> 和 <code>ProxyPassReverse</code> 内容要完全一样，<code>ProxyPassReverse /raspi http://127.0.0.1:9020</code> 表示用户访问&#x2F;raspi资源实际访问的是本地（apache所在云主机）的9020端口。</p>
<p>注意阿里云端口要支持外部可访问，需要在控制台配置安装组，参考：<a href="https://developer.aliyun.com/article/767328">阿里云服务器开放端口教程</a></p>
<p>我个人的配置是直接(1~65535)全部端口打开（不推荐，有风险）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946296.png" alt="image-20221208194652256"></p>
<p>配置完毕重启apache服务</p>
<h2 id="配置SSH反向隧道"><a href="#配置SSH反向隧道" class="headerlink" title="配置SSH反向隧道"></a>配置SSH反向隧道</h2><p>树莓派的mjpg-streamer服务如何连接到阿里云的apache服务？<br>使用SSH连通。关于SSH，参考<a href="https://www.ssh.com/academy/ssh">SSH (Secure Shell) Home Page</a></p>
<p>前文的SecureCRT登陆树莓派就是使用SSH2协议，下面将树莓派的mjpg-streamer服务端口通过SSH反向隧道连接到apache的代理端口</p>
<pre><code>ssh -fN -R &lt;阿里云apache代理端口&gt;:&lt;树莓派localhost&gt;:&lt;树莓派mjpg-streamer服务端口&gt; &lt;阿里云服务器用户名&gt;@&lt;服务器IP&gt;
</code></pre>
<p>例如 <code>ssh -fN -R 9020:localhost:8080 root@47.100.221.149</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947690.png" alt="image-20221208194724640"></p>
<p>输入服务器的登录密码完成通道建立，在阿里云可以查看：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947971.png" alt="image-20221208194733933"></p>
<h1 id="验证公网可访问-mjpg-streamer-服务"><a href="#验证公网可访问-mjpg-streamer-服务" class="headerlink" title="验证公网可访问 mjpg-streamer 服务"></a>验证公网可访问 mjpg-streamer 服务</h1><ul>
<li><p>1.验证树莓派到apache的视频流通道：</p>
<ol>
<li>阿里云服务器启动apache</li>
<li>树莓派建立SSH反向隧道</li>
<li>树莓派启动mjpg-streamer</li>
<li>在阿里云curl访问本地的代理端口</li>
</ol>
<p> curl 127.0.0.1:9020&#x2F;?action&#x3D;stream</p>
</li>
</ul>
<p>如果有大量数据输出，说明连接没问题</p>
<ul>
<li>2.验证apache到客户端浏览器的反向代理通道：</li>
</ul>
<p>使用处于任意网络的设备的浏览器，访问：</p>
<pre><code>http://云服务器IP / Apache代理名 / ?action=stream
</code></pre>
<p>本文中配置对应的输入是：<code>47.100.221.149/raspi/?action=stream</code>，注意<code>?action=stream</code>不能掉，直接访问<code>/raspi</code>得到的是静态页面，跳转不到<code>action=stream</code>的页面<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947462.png" alt="image-20221208194745374"></p>
<p>直接访问 SSH 通道的 9020 端口支持主页面访问和跳转到<code>action=stream</code>页面：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947787.png" alt="image-20221208194754703"></p>
<p>自此验证完毕公网可访问树莓派的视频流服务</p>
<h1 id="性能测试与优化"><a href="#性能测试与优化" class="headerlink" title="性能测试与优化"></a>性能测试与优化</h1><p>实测发现mjpg-streamer启动时使用 640x480分辨率, 30fps，MJPEG格式，延迟卡顿严重</p>
<p>树莓派 ping 阿里云延迟很小：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081948699.png" alt="image-20221208194803656"><br>可能是阿里云带宽不足以支撑大数据量，只能降低分辨率和帧率</p>
<p>我的阿里云服务器只有 3M 带宽，计算一下合适的配置：</p>
<pre><code>3 * 1M/8 = 3 * 128KB = 384KB
</code></pre>
<p>理论上当分辨率 640x480 &#x3D; 300KB, fps 要设置为 1 才几乎无延迟</p>
<p>测试一： 分辨率&#x3D;640x480, fps&#x3D;5<br>结果：初始延迟在 1s 以内，之后延迟增加到几秒；</p>
<p>测试二： 分辨率&#x3D;640x480, fps&#x3D;1<br>结果：初始延迟在 0.5s 左右，半小时后延迟也稳定在1s以内，效果明显比 fps&#x3D;5 好；<br>测试符合理论预期，分辨率 和 FPS 要满足带宽</p>
<p>延迟的测试方法：手机计时，网页视频显示，放一起拍照，时间差即视频延迟<br>以下显示都在1分47秒，延迟小于 1s<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081948279.png" alt="image-20221208194813177"></p>
<p>注意: 树莓派长时间运行发热较明显，需要配散热片。</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C++实现单例模式</title>
    <url>/2020/11/20/%E6%B5%85%E8%B0%88C-%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>相信大家面试都逃不开设计模式话题，本节将阐述面试中的最常用的设计模式(单例模式)，从分类，线程安全，不基于C++11标准的角度与基于C++11标准的角度，有哪些解决线程安全的单例模式方案，相信认真看完本篇文章，在以后面试中就不用担忧了。</p>
<p>众所周知的单例：<br>在一般书籍中或者大家比较是熟知的单例模式是下面这样：</p>
<pre><code>class singleton {
private:
    singleton() {}
    static singleton *p;
public:
    static singleton *instance();
};

singleton *singleton::p = nullptr;

singleton* singleton::instance() {
    if (p == nullptr)
        p = new singleton();
    return p;
}
</code></pre>
<p>这是一个非常简单的实现，将构造函数声明为private或protect防止被外部函数实例化，内部有一个静态的类指针保存唯一的实例，实例的实现由一个public方法来实现，该方法返回该类的唯一实例。</p>
<p>当然这个代码只适合在单线程下，当多线程时，是不安全的。考虑两个线程同时首次调用instance方法且同时检测到p是nullptr，则两个线程会同时构造一个实例给p，这将违反了单例的准则。</p>
<h1 id="2-懒汉与饿汉"><a href="#2-懒汉与饿汉" class="headerlink" title="2.懒汉与饿汉"></a>2.懒汉与饿汉</h1><p>单例分为两种实现方法：</p>
<p>懒汉:第一次用到类实例的时候才会去实例化，上述就是懒汉实现。<br>饿汉:单例类定义的时候就进行了实例化。</p>
<p>这里也给出饿汉的实现：</p>
<pre><code>class singleton {
private:
    singleton() {}
    static singleton *p;
public:
    static singleton *instance();
};

singleton *singleton::p = new singleton();
singleton* singleton::instance() {
    return p;
}
</code></pre>
<p>当然这个是线程安全的，对于我们通常阐述的线程不安全，为懒汉模式，下面会阐述懒汉模式的线程安全代码优化。</p>
<h1 id="3-多线程加锁"><a href="#3-多线程加锁" class="headerlink" title="3.多线程加锁"></a>3.多线程加锁</h1><p>在C++中加锁有个类实现原理采用RAII，不用手动管理unlock，那就是lock_guard，这里采用其进行加锁。</p>
<pre><code>class singleton {
private:
    singleton() {}
    static singleton *p;
    static mutex lock_;
public:
    static singleton *instance();
};

singleton *singleton::p = nullptr;

singleton* singleton::instance() {
    lock_guard&lt;mutex&gt; guard(lock_);
    if (p == nullptr)
        p = new singleton();
    return p;
}
</code></pre>
<p>这种写法不会出现上面两个线程都执行到p&#x3D;nullptr里面的情况，当线程A在执行p &#x3D; new Singleton()的时候，线程B如果调用了instance()，一定会被阻塞在加锁处，等待线程A执行结束后释放这个锁。从而是线程安全的。</p>
<p>但是这种写法性能非常低下，因为每次调用instance()都会加锁释放锁，而这个步骤只有在第一次new Singleton()才是有必要的，只要p被创建出来了，不管多少线程同时访问，使用if (p &#x3D;&#x3D; nullptr)进行判断都是足够的（只是读操作，不需要加锁），没有线程安全问题，加了锁之后反而存在性能问题。</p>
<p>因此引出<strong>双重检查锁(DCL)</strong>。</p>
<h1 id="4-双重检查锁模式"><a href="#4-双重检查锁模式" class="headerlink" title="4.双重检查锁模式"></a>4.双重检查锁模式</h1><p>上面写法是不管任何情况都会去加锁，然后释放锁，而对于读操作是不存在线程安全的，故只需要在第一次实例创建的时候加锁，以后不需要。下面先看一下DCLP的实现：</p>
<pre><code>singleton* singleton::instance() {
    if(p == nullptr) {  // 第一次检查
        Lock lock;
        if(p == nullptr){ // 第二次检查
            p = new singleton;
        }
    }
    return p;
}
</code></pre>
<p>基于上述，我们可以写出<strong>双重检查锁+自动回收(DCLP)</strong></p>
<pre><code>class singleton {
private:
    singleton() {}

    static singleton *p;
    static mutex lock_;
public:
    singleton *instance();

    // 实现一个内嵌垃圾回收类
    class CGarbo
    {
    public:
        ~CGarbo()
        {
            if(singleton::p)
                delete singleton::p;
        }
    };
    static CGarbo Garbo; // 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象
};

singleton *singleton::p = nullptr;
singleton::CGarbo Garbo;

singleton* singleton::instance() {
    if (p == nullptr) {
        lock_guard&lt;mutex&gt; guard(lock_);
        if (p == nullptr)
            p = new singleton();
    }
    return p;
}
</code></pre>
<p>DCLP的关键在于，大多数对instance的调用会看到p是非空的，因此甚至不用尝试去初始化它。因此，DCLP在尝试获取锁之前检查p是否为空。只有当检查成功（也就是p还没有被初始化）时才会去获得锁，然后再次检查p是否仍然为空（因此命名为双重检查锁）。第二次检查是必要，因为就像我们刚刚看到的，很有可能另一个线程偶然在第一次检查之后，获得锁成功之前初始化p。</p>
<p>看起来上述代码非常美好，可是过了相当一段时间后，才发现这个漏洞，原因是：<strong>内存读写的乱序执行(编译器问题)。</strong></p>
<p>再次考虑初始化p的那一行：</p>
<pre><code>p = new singleton;
</code></pre>
<p>这条语句会导致三个事情的发生：</p>
<ul>
<li>分配能够存储singleton对象的内存；</li>
<li>在被分配的内存中构造一个singleton对象；</li>
<li>让p指向这块被分配的内存。</li>
</ul>
<p>可能会认为这三个步骤是按顺序执行的，但实际上只能确定步骤1是最先执行的，步骤2，3却不一定。问题就出现在这。</p>
<ol>
<li>线程A调用instance，执行第一次p的测试，获得锁，按照1,3,执行，然后被挂起。此时p是非空的，但是p指向的内存中还没有Singleton对象被构造。</li>
<li>线程B调用instance，判定p非空，</li>
<li>将其返回给instance的调用者。调用者对指针解引用以获得singleton，噢，一个还没有被构造出的对象。bug就出现了。</li>
</ol>
<p>DCLP能够良好的工作仅当步骤一和二在步骤三之前被执行，但是并没有并没有方法在C或C++中表达这种限制。这就像是插在DCLP心脏上的一把匕首：我们需要在相对指令顺序上定义限制，但是我们的语言没有给出表达这种限制的方法。</p>
<h1 id="5-memory-barrier指令"><a href="#5-memory-barrier指令" class="headerlink" title="5.memory barrier指令"></a>5.memory barrier指令</h1><p>DCLP问题在C++11中，这个问题得到了解决。</p>
<p>因为新的C++11规定了新的内存模型，保证了执行上述3个步骤的时候不会发生线程切换，相当这个初始化过程是“原子性”的的操作，DCL又可以正确使用了，不过在C++11下却有更简洁的多线程singleton写法了，这个留在后面再介绍。</p>
<p>C++11之前解决方法是barrier指令。要使其正确执行的话，就得在步骤2、3直接加上一道memory barrier。强迫CPU执行的时候按照1、2、3的步骤来运行。</p>
<p>第一种实现：</p>
<p>基于operator new + placement new，遵循1,2,3执行顺序依次编写代码。</p>
<pre><code>// method 1 operator new + placement new
singleton *instance() {
    if (p == nullptr) {
        lock_guard&lt;mutex&gt; guard(lock_);
        if (p == nullptr) {
            singleton *tmp = static_cast&lt;singleton *&gt;(operator new(sizeof(singleton)));
            new(p)singleton();
            p = tmp;
        }
    }
    return p;
}
</code></pre>
<p>第二种实现：</p>
<p>基于直接嵌入ASM汇编指令mfence，uninx的barrier宏也是通过该指令实现的。</p>
<pre><code>#define barrier() __asm__ volatile (&quot;lwsync&quot;)
singleton *singleton::instance() {
    if (p == nullptr) {
        lock_guard&lt;mutex&gt; guard(lock_);
        barrier();
        if (p == nullptr) {
            p = new singleton();
        }
    }
    return p;
}
</code></pre>
<p>通常情况下是调用cpu提供的一条指令，这条指令的作用是会阻止cpu将该指令之前的指令交换到该指令之后，这条指令也通常被叫做barrier。 </p>
<p>上面代码中的asm表示这个是一条汇编指令，volatile是可选的，如果用了它，则表示向编译器声明不允许对该汇编指令进行优化。lwsync是POWERPC提供的barrier指令。</p>
<h1 id="6-静态局部变量"><a href="#6-静态局部变量" class="headerlink" title="6.静态局部变量"></a>6.静态局部变量</h1><p>Scott Meyer在《Effective C++》中提出了一种简洁的singleton写法</p>
<pre><code>singleton *singleton::instance() {
    static singleton p;
    return &amp;p;
}
</code></pre>
<ul>
<li>单线程下，正确。</li>
<li>C++11及以后的版本（如C++14）的多线程下，正确。</li>
<li>C++11之前的多线程下，不一定正确。</li>
</ul>
<p>原因在于在C++11之前的标准中并没有规定local static变量的内存模型。于是乎它就是不是线程安全的了。但是在C++11却是线程安全的，这是因为新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它。</p>
<p>上述使用的内存序：</p>
<p>memory_order_relaxed：松散内存序，只用来保证对原子对象的操作是原子的<br>memory_order_acquire：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见<br>memory_order_release：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</p>
<h1 id="7-Atomic"><a href="#7-Atomic" class="headerlink" title="7.Atomic"></a>7.Atomic</h1><p>在C++11之前的版本下，除了通过锁实现线程安全的Singleton外，还可以利用各个编译器内置的atomic operation来实现。</p>
<p>java和c#发现乱序问题后，就加了一个关键字volatile，在声明p变量的时候，要加上volatile修饰，编译器看到之后，就知道这个地方不能够reorder（一定要先分配内存，在执行构造器，都完成之后再赋值）。</p>
<p>而对于c++标准却一直没有改正，所以VC++在2005版本也加入了这个关键字，但是这并不能够跨平台（只支持微软平台）。</p>
<p>而到了c++ 11版本，为了从根本上消除这些漏洞，引入了适合多线程的内存模型。终于有了这样的机制帮助我们实现跨平台的方案。</p>
<pre><code>mutex singleton::lock_;
atomic&lt;singleton *&gt; singleton::p;

/*
* std::atomic_thread_fence(std::memory_order_acquire); 
* std::atomic_thread_fence(std::memory_order_release);
* 这两句话可以保证他们之间的语句不会发生乱序执行。
*/
singleton *singleton::instance() {
    singleton *tmp = p.load(memory_order_relaxed);
    atomic_thread_fence(memory_order_acquire);
    if (tmp == nullptr) {
        lock_guard&lt;mutex&gt; guard(lock_);
        tmp = p.load(memory_order_relaxed);
        if (tmp == nullptr) {
            tmp = new singleton();
            atomic_thread_fence(memory_order_release);
            p.store(tmp, memory_order_relaxed);
        }
    }
    return p;
}
</code></pre>
<p>值得注意的是，上述代码使用两个比较关键的术语，获得与释放：</p>
<ul>
<li>获得是一个对内存的读操作，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去。</li>
<li>释放是一个对内存的写操作，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去。</li>
</ul>
<p>acquire 和 release 通常都是配对出现的，目的是保证如果对同一个原子对象的 release 发生在 acquire 之前的话，release 之前发生的内存修改能够被 acquire 之后的内存读取全部看到。</p>
<h1 id="8-pthread-once"><a href="#8-pthread-once" class="headerlink" title="8.pthread_once"></a>8.pthread_once</h1><p>如果是在unix平台的话，除了使用atomic operation外，在不适用C++11的情况下，还可以通过pthread_once来实现Singleton。</p>
<p>原型如下：</p>
<pre><code>int pthread_once(pthread_once_t once_control, void (init_routine) (void))；
</code></pre>
<p>实现：</p>
<pre><code>class singleton {
private:
    singleton(); //私有构造函数，不允许使用者自己生成对象
    singleton(const singleton &amp;other);

    //要写成静态方法的原因：类成员函数隐含传递this指针（第一个参数）
    static void init() {
        p = new singleton();
    }

    static pthread_once_t ponce_;
    static singleton *p; //静态成员变量 
public:
    singleton *instance() {
        // init函数只会执行一次
        pthread_once(&amp;ponce_, &amp;singleton::init);
        return p;
    }
};
</code></pre>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>本文讲解了几种单例模式，并讲解了线程安全的单例模式，以及不用C++11实现的几种线程安全的单例模式：memory barrier，静态局部变量，pthread_once方式，C++11的atomic实现等。</p>
<p>最后值得注意的是，针对上述单例类的析构函数请参考双重锁检查模式+自动回收实现，必须在类中声明一个静态局部变量，静态局部变量可以理解为全局变量，在程序结束时，自动调用该静态局部变量的析构函数，这就是为什么要在类中声明与定义嵌套类，而不是直接编写单例的析构函数。</p>
<p>本文参考：<a href="https://light-city.club/sc/design_pattern/singleton/singleton/">C++那些事-&gt;设计模式-&gt;单例模式</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C++的RAII机制</title>
    <url>/2020/11/08/%E6%B5%85%E8%B0%88C-%E7%9A%84RAII%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-资源与内存分配"><a href="#1-资源与内存分配" class="headerlink" title="1.资源与内存分配"></a>1.资源与内存分配</h1><p>资源的概念:资源是数量有限且对系统正常运转具有一定作用的元素。比如，内存，文件句柄，网络套接字（network sockets），互斥锁（mutex locks）等等<br>对于进程，这些资源都作为某种数据结构存储在内存中。<br>程序运行需要分配内存来管理以上资源，内存分配可以分为三类：</p>
<ul>
<li>静态分配：如创建一个进程执行某段代码，需要加载该代码的代码段，数据段等数据到内存中，其中数据段包含已初始化的全局数据，可以称为是静态的内存分配</li>
<li>自动分配：进程内函数的调用和返回，以及其内部的局部变量创建和销毁，对应该进程高地址的入栈出栈，这个是操作系统自动处理的，无需应用程序控制</li>
<li>动态分配：静态数据和堆栈之前的空间（称为堆），可由应用程序动态分配，同时，也必须由应用程序释放。所谓的内存的动态分配与释放，通常讨论的是这种情况</li>
</ul>
<p>以32位Linux环境的应用程序为例，每个进程可见的（虚拟）内存分布如下，C&#x2F;C++常用的malloc&#x2F;free, new&#x2F;delete对应的内存分配释放都在.heap段内<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081658341.png" alt="image-20221208165846274"></p>
<h1 id="2-动态内存管理的缺陷"><a href="#2-动态内存管理的缺陷" class="headerlink" title="2.动态内存管理的缺陷"></a>2.动态内存管理的缺陷</h1><p>我们在使用资源时必须严格遵循的步骤是：</p>
<ol>
<li>获取资源</li>
<li>使用资源</li>
<li>释放资源</li>
</ol>
<p>代码形式：</p>
<pre><code>void UseResources()    
{  
    // 获取资源1  
    // ...  
    // 获取资源n  
     
    // 使用这些资源  
     
    // 释放资源n  
    // ...  
    // 释放资源1  
} 
</code></pre>
<p>当代码量和复杂度达到一定程度，这种手动资源管理容易出错，且难以避免<br>例如C++使用new和delete时可能发生的一些错误是：</p>
<ul>
<li>内存泄漏：例如，使用new分配对象，而忘记删除该对象，打开文件，忘记关闭文件等等</li>
<li>过早删除（或悬挂引用）：持有指向对象的另一个指针，删除该对象，但是还有其他指针在引用它。</li>
<li>双重删除：尝试两次删除一个对象</li>
</ul>
<h1 id="3-RAII：将资源管理交给系统"><a href="#3-RAII：将资源管理交给系统" class="headerlink" title="3.RAII：将资源管理交给系统"></a>3.RAII：将资源管理交给系统</h1><ul>
<li>自动内存管理，局部变量能在调用函数时分配，退出函数时释放</li>
<li>类是 C++ 中的主要抽象工具，将资源抽象为类，用局部对象来表示资源，把管理资源的任务转化为管理局部对象的任务</li>
</ul>
<p>RAII 就是基于以上思想，折中了全手动和全自动的内存管理，手动的选择管理哪些资源，自动的分配和释放资源。有效地实现了 C++ 资源管理的自动化</p>
<p>RAII（Resource Acquisition Is Initialization, 资源获取即初始化）:<br>是80年代，Bjarne Stroustrup为C++发明了的范例。<br>具体实现方法：将资源的声明周期，绑定到对象的生命周期，即将资源分配和释放操作，包含到指定对象的构造函数和析构函数中，这些构造函数和析构函数在适当的时候由编译器自动调用，资源数据包含到对象的成员中。</p>
<p>一个简单示例：</p>
<p>（1）常规内存管理</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std; 
int main() 
{ 
    int *testArray = new int [10]; 
    // Here, you can use the array 
    delete [] testArray; 
    testArray = NULL ; 
    return 0; 
}
</code></pre>
<p>（2）RAII方式</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std; 

class ArrayOperation 
{ 
public : 
    ArrayOperation() 
    { 
        m_Array = new int [10]; //构造函数包含资源的分配
    } 
 
    void InitArray()  //使用资源
    { 
        for (int i = 0; i &lt; 10; ++i) 
        { 
            *(m_Array + i) = i; 
        } 
    } 
 
    void ShowArray() //使用资源
    { 
        for (int i = 0; i &lt;10; ++i) 
        { 
            cout&lt;&lt;m_Array[i]&lt;&lt;endl; 
        } 
    } 
 
    ~ArrayOperation()  //析构函数包含资源的释放
    { 
        cout&lt;&lt; &quot;~ArrayOperation is called&quot; &lt;&lt;endl; 
        if (m_Array != NULL ) 
        { 
            delete[] m_Array;  
            m_Array = NULL ; 
        } 
    } 
 
private : 
    int *m_Array;  //成员变量包含资源
}; 
 
int main() 
{ 
    ArrayOperation arrayOp; //资源自动分配
    arrayOp.InitArray(); 
    arrayOp.ShowArray(); 
    return 0;           //资源自动释放
}
</code></pre>
<p>根据RAII对资源的所有权控制，分为常性类型和外部初始化类型<br>上述示例即为常性类型，也是最纯粹的RAII形式，最容易理解，最容易编码。获取资源的地点是构造函数，释放点是析构函数，并且在这两点之间的一段时间里，任何对该RAII类型实例的操纵都不应该从它手里夺走资源的所有权<br>外部初始化类型是指资源在外部被创建，并被传给RAII实例的构造函数，后者进而接管了其所有权。boost::shared_ptr&lt;&gt;和std::auto_ptr&lt;&gt;都是此类型</p>
<h1 id="4-RAII的应用场景"><a href="#4-RAII的应用场景" class="headerlink" title="4.RAII的应用场景"></a>4.RAII的应用场景</h1><p>常见的应用有：</p>
<ul>
<li>文件操作</li>
<li>智能指针</li>
<li>互斥量</li>
</ul>
<h2 id="4-1文件操作"><a href="#4-1文件操作" class="headerlink" title="4.1文件操作"></a>4.1文件操作</h2><p>（1）常规形式</p>
<pre><code>void UseFile(char const* fn)  
{  
    FILE* f = fopen(fn, &quot;r&quot;);        // 获取资源  
    // 在此处使用文件句柄f...代码          // 使用资源  
    fclose(f);                       // 释放资源  
}  
</code></pre>
<p>（2）RAII<br>文件类：</p>
<pre><code>class FileHandle {  
public:  
    FileHandle(char const* n, char const* a) { p = fopen(n, a); } 
    ~FileHandle() { fclose(p); }  
private:   
    FileHandle(FileHandle const&amp;);  
    FileHandle&amp; operator= (FileHandle const&amp;); // 禁止拷贝操作  
    FILE *p;  
}; 
</code></pre>
<p> FileHandle 类的构造函数调用 fopen() 获取资源；FileHandle类的析构函数调用 fclose()释放资源。请注意，考虑到FileHandle对象代表一种资源，它并不具有拷贝语义，因此将拷贝构造函数和赋值运算符声明为私有成员<br> 使用：</p>
<pre><code>void UseFile(char const* fn)  
{  
    FileHandle file(fn, &quot;r&quot;);  
    // 在此处使用文件句柄  
    // 超出此作用域时，系统会自动调用file的析构函数，从而释放资源
}  
</code></pre>
<h2 id="4-2互斥量"><a href="#4-2互斥量" class="headerlink" title="4.2互斥量"></a>4.2互斥量</h2><p>C++标准库提供lock_guard类实现mutex分配与释放，其实现就是RAII方式。</p>
<pre><code>template&lt;class... _Mutexes&gt;
	class lock_guard
	{	// class with destructor that unlocks mutexes
public:
	explicit lock_guard(_Mutexes&amp;... _Mtxes)
		: _MyMutexes(_Mtxes...)
		{	// construct and lock
		_STD lock(_Mtxes...);
		}
 
	lock_guard(_Mutexes&amp;... _Mtxes, adopt_lock_t)
		: _MyMutexes(_Mtxes...)
		{	// construct but don&#39;t lock
		}
 
	~lock_guard() _NOEXCEPT
		{	// unlock all
		_For_each_tuple_element(
			_MyMutexes,
			[](auto&amp; _Mutex) _NOEXCEPT { _Mutex.unlock(); });
		}
 
	lock_guard(const lock_guard&amp;) = delete;
	lock_guard&amp; operator=(const lock_guard&amp;) = delete;
private:
	tuple&lt;_Mutexes&amp;...&gt; _MyMutexes;
	};
</code></pre>
<p>使用多线程时，经常会涉及到共享数据的问题，C++中通过实例化std::mutex创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。不过这意味着必须记住在每个函数出口都要去调用unlock()，也包括异常的情况，这非常麻烦，而且不易管理。C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，其会在构造函数的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。上面的代码属于mutex头文件</p>
<h2 id="4-3智能指针"><a href="#4-3智能指针" class="headerlink" title="4.3智能指针"></a>4.3智能指针</h2><p>先看一个例子，用RAII管理指针</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;fstream&gt;
using namespace std;

enum class shape_type {
    circle,
    rectangle,
};

class shape {
public:
    shape() { cout &lt;&lt; &quot;shape&quot; &lt;&lt; endl; }
    virtual void print() {
        cout &lt;&lt; &quot;I am shape&quot; &lt;&lt; endl;
    }
    virtual ~shape() {}
};

class circle : public shape {
public:
    circle() { cout &lt;&lt; &quot;circle&quot; &lt;&lt; endl; }
    void print() {
        cout &lt;&lt; &quot;I am circle&quot; &lt;&lt; endl;
    }
};

class rectangle : public shape {
public:
    rectangle() { cout &lt;&lt; &quot;rectangle&quot; &lt;&lt; endl; }
    void print() {
        cout &lt;&lt; &quot;I am rectangle&quot; &lt;&lt; endl;
    }
};

// 利用多态上转,如果返回值为shape,会存在对象切片问题。
shape *create_shape(shape_type type) {
    switch (type) {
        case shape_type::circle:
            return new circle();
        case shape_type::rectangle:
            return new rectangle();
    }
}

class shape_wrapper {
public:
    explicit shape_wrapper(shape *ptr = nullptr) : ptr_(ptr) {}

    ~shape_wrapper() {
        delete ptr_;
    }

    shape *get() const {
        return ptr_;
    }

private:
    shape *ptr_;
};
</code></pre>
<p>​<br>​<br>    int main() {</p>
<pre><code>    // 第一种方式, 手动管理指针
    shape *sp = create_shape(shape_type::circle);
    sp-&gt;print();
    delete sp; //显式delete

    // 第二种方式， RAII管理指针，一般封装到函数，更快释放
    shape_wrapper ptr(create_shape(shape_type::circle));
    ptr.get()-&gt;print();

    return 0;
}
</code></pre>
<p>C++标准库的智能指针：auto_ptr(C++11弃用), unique_ptr,shared_ptr, weak_ptr<br>可以参考<a href="https://www.cnblogs.com/WindSun/p/11444429.html">WindSun:详解C++11智能指针</a></p>
<h2 id="4-4实现自己的RAII类"><a href="#4-4实现自己的RAII类" class="headerlink" title="4.4实现自己的RAII类"></a>4.4实现自己的RAII类</h2><p>一般情况下，RAII临时对象不允许复制和赋值，当然更不允许在heap上创建，所以先写下一个RAII的base类，使子类私有继承Base类来禁用这些操作：</p>
<pre><code>class RAIIBase  
{  
public:  
    RAIIBase(){}  
    ~RAIIBase(){}//由于不能使用该类的指针，定义虚函数是完全没有必要的  
      
    RAIIBase (const RAIIBase &amp;);  
    RAIIBase &amp; operator = (const RAIIBase &amp;);  
    void * operator new(size_t size);   
    // 不定义任何成员  
};
</code></pre>
<p>要写自己的RAII类时就可以直接继承该类的实现</p>
<pre><code>template&lt;typename T&gt;  
class ResourceHandle: private RAIIBase //私有继承 禁用Base的所有继承操作  
{  
public:  
    explicit ResourceHandle(T * aResource):r_(aResource){}//获取资源  
    ~ResourceHandle() {delete r_;} //释放资源  
    T *get()    {return r_ ;} //访问资源  
private:  
    T * r_;  
};
</code></pre>
<p>将Handle类做成模板类，这样就可以将class类型放入其中。另外，ResourceHandle可以根据不同资源类型的释放形式来定义不同的析构函数。由于不能使用该类的指针，所以不使用虚函数。</p>
<h1 id="5-GC和RAII"><a href="#5-GC和RAII" class="headerlink" title="5.GC和RAII"></a>5.GC和RAII</h1><p>在没有RAII的时代，GC和非GC语言是水火不容，GC追求开发效率和稳健设计，非GC如C++最求极致性能和绝对控制。RAII的设计机制，兼顾了两者的优点。<br>如果用三个等级代表程序员对系统资源的使用权限，如下：</p>
<ul>
<li>动态分配：C++的new&#x2F;delete之类，程序员100%负责内存使用和释放，编译器、操作系统不额外干预</li>
<li>垃圾回收(GC)：java&#x2F;go语言之类，程序员只负责要内存，而不用管，也管不了内存释放，其由该语言运行环境管理，规则可以描述成：如果一个资源没被任何对象使用(例如没有指针指向它)，运行环境定时或者其他方式检测到后，自动释放该资源，该过程对程序员不可控。可以说程序员有50%的权限，即想要就能要，但想甩却不能甩</li>
<li>RAII：程序员负责资源编排，运行时的分配与释放由系统自动完成，可以说程序员有90%的权限，放权10%给系统</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>RAII的本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来，从而确保在对象的生存期内资源始终有效，对象销毁时资源必被释放。换句话说，拥有对象就等于拥有资源，对象存在则资源必定存在。<br>具体实现：</p>
<ul>
<li>资源在构造函数中获取</li>
<li>资源在析构函数中释放</li>
<li>资源是类的成员变量</li>
<li>类的实例是堆栈分配的</li>
</ul>
<p>相关文章<br><a href="https://light-city.club/sc/codingStyleIdioms/RAII/">C++那些事：RAII</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的函数指针</title>
    <url>/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="1-函数指针基本概念"><a href="#1-函数指针基本概念" class="headerlink" title="1. 函数指针基本概念"></a>1. 函数指针基本概念</h2><p>C语言调用函数的本质是什么？</p>
<ol>
<li>CPU PC指针(program counter)跳转到函数的入口地址，传入参数，传入返回位置</li>
<li>在函数栈内生成临时变量并执行函数内容指令，执行完毕后返回参数</li>
<li>CPU返回原调用处执行</li>
</ol>
<p>这里，函数的入口地址实际上就存储在函数名中，也就是说，C代码中的函数名就是函数的入口地址。<br>既然是地址，就可以用来初始化一个指针，使指针指向该地址。<br>函数指针，就是存放函数首地址的指针。</p>
<h3 id="1-2-函数指针变量"><a href="#1-2-函数指针变量" class="headerlink" title="1.2 函数指针变量"></a>1.2 函数指针变量</h3><p>首先声明普通函数是如下格式：<br><code>void Func(int);</code><br>定义一个同类型函数的函数指针变量，只需要用<code>*p</code>表示函数名即可：<br><code>void (*p)(int);</code><br>注意，上面是定义了函数指针变量，而不是声明函数指针类型。</p>
<p>函数指针变量的定义，和普通变量格式不一样。</p>
<ul>
<li>普通变量： &lt;类型&gt; &lt;变量名&gt;</li>
<li>函数指针：&lt;函数类型 变量名&gt;，按函数声明的格式定义，变量是包含在类型内部</li>
</ul>
<p>那么此函数指针的类型是什么：<br><code>void (*)(int);</code></p>
<p>怎么使用此函数指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Func(int x) // 声明一个函数*/</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line">void (*p)(int); // 定义一个函数指针*/</span><br><span class="line">p = Func; // 将Func函数的首地址赋给函数指针变量p*/</span><br><span class="line">(*p)(100);  // 通过函数指针调用Func函数</span><br></pre></td></tr></table></figure>

<h3 id="1-3-函数指针类型"><a href="#1-3-函数指针类型" class="headerlink" title="1.3 函数指针类型"></a>1.3 函数指针类型</h3><p>typedef可以定义某种类型的别名，例如将unsigned char定义为u8<br><code>typedef unsigned char u8;</code><br>可见其格式是：typedef &lt;原类型&gt; &lt;别名类型&gt;</p>
<p>那么如何定义函数指针类型：<br>只需要在函数指针声明的格式前加typedef, p就定义为函数指针类型而不是变量:<br><code>typedef void (*p)(int);</code></p>
<p>这里定义了<code>void (*)(int)</code>类型的函数指针类型，其别名为p</p>
<p>怎么使用此函数指针类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义类型</span><br><span class="line">typedef void (*pFuncType)(int); </span><br><span class="line">//定义变量  </span><br><span class="line">pFuncType p;   </span><br><span class="line"></span><br><span class="line">void Func(int x)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%d&quot;,x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main()   </span><br><span class="line">&#123;   </span><br><span class="line">    p = Func; //初始化变量   </span><br><span class="line">    (*p)(100);   //使用变量</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-函数指针的应用"><a href="#2-函数指针的应用" class="headerlink" title="2. 函数指针的应用"></a>2. 函数指针的应用</h2><h3 id="2-1-Linux驱动软件设计的分层"><a href="#2-1-Linux驱动软件设计的分层" class="headerlink" title="2.1 Linux驱动软件设计的分层"></a>2.1 Linux驱动软件设计的分层</h3><p>C++中有多态的概念，父类定义某种函数类型，子类实现具体的函数内容，之后父类对象就可以调用子类的实现内容。<br>这样实现“父类定义格式，子类实现细节”的软件分层设计。</p>
<p>Linux驱动中也大量使用这种分层设计，C使用结构体和函数指针，分别对应C++的类和方法。<br>例如某驱动模块，顶层框架定义open, read, write, 而底层驱动根据具体硬件，实现xxx_open, xxx_read, xxx_write，然后按结构体成员赋值实现上下层联通：</p>
<p>以s3c的SDHCI驱动为例：<br>sdhci_ops即父类框架结构体，sdhci_s3c_ops为s3c芯片的具体实现结构体。<br><code>.set_clock = sdhci_s3c_set_clock</code>就实现了父类的set_clock方法被子类sdhci_s3c_set_clock实现的效果。<br>其本质是函数指针的赋值，父类和子类的函数名都指向同一个函数地址，所以父类可以通过调用set_clock来实现调用sdhci_s3c_set_clock的效果。<br>这样，父类设计者根本不关心底层用什么函数名实现set_clock的功能，只需要调用set_clock这个函数名即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct sdhci_ops sdhci_s3c_ops = &#123;</span><br><span class="line">	.get_max_clock		= sdhci_s3c_get_max_clk,</span><br><span class="line">	.set_clock		= sdhci_s3c_set_clock,</span><br><span class="line">	.get_min_clock		= sdhci_s3c_get_min_clock,</span><br><span class="line">	.set_bus_width		= sdhci_set_bus_width,</span><br><span class="line">	.reset			= sdhci_reset,</span><br><span class="line">	.set_uhs_signaling	= sdhci_set_uhs_signaling,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数指针实现指令跳转"><a href="#2-2-函数指针实现指令跳转" class="headerlink" title="2.2 函数指针实现指令跳转"></a>2.2 函数指针实现指令跳转</h3><p>调用一个函数，其内部就包含跳转操作(jump指令)<br>那么，如何用C语言实现跳转到某个绝对地址去执行？具体场景：<br>在Bootloader过程中，加载完kernel到RAM后，要跳转到kernel首地址开始执行，如何实现？</p>
<p>方案一：C嵌入汇编<br>以下是基于SPARC CPU的汇编，跳转到0x40000000, 即RAM首地址执行firmware.<br>对于其他CPU，汇编实现也不同，因此此方法不能跨平台。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void boot_exit()</span><br><span class="line">&#123;</span><br><span class="line">    /* jump to RAM entry to execute firmware. */</span><br><span class="line"></span><br><span class="line">    asm(</span><br><span class="line">        &quot;set 0x40000000, %g2\n&quot;</span><br><span class="line">        &quot;jmp %g2\n&quot;</span><br><span class="line">        &quot;nop&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：函数指针<br>Bootloader中很常用的一种跳转方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef void (*pFuncType)(); //定义无入参无返回类型的函数指针类型</span><br><span class="line">pFuncType Reset = (pFuncType)0xF000FFF0; //函数指针指向待跳转地址</span><br><span class="line">Reset(); //调用函数，实际上执行了跳转</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的宏函数</title>
    <url>/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="1-连接操作符"><a href="#1-连接操作符" class="headerlink" title="1. 连接操作符:##"></a>1. 连接操作符:##</h1><pre><code>#define Conn(x,y) x##y
</code></pre>
<p><code>##</code> 表示连接 , <code>x##y</code> 表示x连接y</p>
<p>示例：</p>
<pre><code>int n = Conn(123,456);
     ==&gt; int n=123456;
char* str = Conn(&quot;asdf&quot;, &quot;adf&quot;);
     ==&gt; char* str = &quot;asdfadf&quot;;
</code></pre>
<p><code>##</code> 的左右符号必须能够组成一个有意义的符号，否则预处理器会报错</p>
<h1 id="2-字符串化和字符化"><a href="#2-字符串化和字符化" class="headerlink" title="2.字符串化和字符化: #, #@"></a>2.字符串化和字符化: #, #@</h1><p>(1) # 把任意类型的宏入参转化成字符串：</p>
<pre><code>#define ToString(x) #x
</code></pre>
<p>符号 # 表示字符串化操作符（stringification）。<br>其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。<br>其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</p>
<p>示例：</p>
<pre><code> char* str = ToString(123132);
 ==&gt; char* str=&quot;123132&quot;;
</code></pre>
<p>如果要对展开后的宏参数进行字符串化，则需要使用两层宏。</p>
<pre><code>#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
     ==&gt; &quot;foo&quot;
xstr (foo)
     ==&gt; xstr (4)
     ==&gt; str (4)
     ==&gt; &quot;4&quot;
</code></pre>
<p>(2) #@ 把任意类型的宏入参转化成单字符：</p>
<pre><code>#define ToChar(x) #@x
</code></pre>
<p>示例：</p>
<pre><code>char a = ToChar(1);
     ==&gt; char a=&#39;1&#39;
</code></pre>
<h1 id="3-不定参数宏-VA-ARGS"><a href="#3-不定参数宏-VA-ARGS" class="headerlink" title="3. 不定参数宏: __VA_ARGS__"></a>3. 不定参数宏: <code>__VA_ARGS__</code></h1><p><code>__VA_ARGS__</code>宏用来接受不定数量的参数。例如：</p>
<pre><code>#define eprintf(...) fprintf (stderr, __VA_ARGS__)

eprintf (&quot;%s:%d: &quot;, input_file, lineno)
==&gt;  fprintf (stderr, &quot;%s:%d: &quot;, input_file, lineno)
</code></pre>
<p>当<code>__VA_ARGS__</code>宏前面加 <code>##</code> 时，可以省略参数输入。<br>例如：</p>
<pre><code>#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

eprintf (&quot;success!\n&quot;)
==&gt; fprintf(stderr, &quot;success!\n&quot;);
</code></pre>
<h1 id="4-宏函数定义-do-while-0-与换行"><a href="#4-宏函数定义-do-while-0-与换行" class="headerlink" title="4. 宏函数定义: do-while(0)与换行"></a>4. 宏函数定义: do-while(0)与换行</h1><p>(1) 用 do{}while(0) 定义宏函数</p>
<pre><code>#define foo() do{...}while(0)
</code></pre>
<p>宏函数可能在任意地方被调用，如果在if-else语句中，为了确保宏函数作为整体单元被编译器替换后不产生歧义，一般用do-while(0)包起来定义<br>这种定义有点像其他语言的“闭包函数”，纯粹是C语言中为了避免语法歧义的可靠性定义。</p>
<p>(2) 用显式换行符</p>
<p>宏函数定义不能直接回车换行，需要在回车换行前，用\（反斜线）表示下一行继续此宏的定义<br>预处理器在编译之前会自动将\与换行回车去掉。</p>
<p>例如：</p>
<pre><code>#define PRINT_INT(a)    \
do{                     \
    printf(&quot;%d \n&quot;, a); \
}while(0)
</code></pre>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈C的结构体与面向对象</title>
    <url>/2020/02/29/%E6%B5%85%E8%B0%88C%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>结构体（Struct）：存放一组不同类型的数据的数据结构。<br>数组（Array）：存放一组相同类型的数据的数据结构。<br>结构体和int,char，指针等基础数据类型一样，也是一种数据类型。格式定义如下：</p>
<pre><code>struct 结构体名&#123;
    成员类型1 成员名1;
    成员类型2 成员名2；
&#125;实例1，实例2;
</code></pre>
<p>结构体的成员（Member）可以为任意类型，如int,char，指针，甚至结构体类型。<br>结构体可以配合结构体数组、普通指针、函数指针、以及自身嵌套的使用方法，实现复杂数据结构，以及面向对象的代码风格。</p>
<h1 id="1-结构体声明"><a href="#1-结构体声明" class="headerlink" title="1.结构体声明"></a>1.结构体声明</h1><p>声明是告诉编译器某个数据结构的定义。一般在头文件对结构体、函数等类型声明。声明过程不分配内存。<br>一个结构体类型的声明：</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125;;
</code></pre>
<p>注意：<br>1.结构体声明类似于函数声明，是一个语句，末尾加；<br>2.结构体声明只声明了类型，不实例化变量，因此不分配内存。<br>3.结构体成员的变量只在实例结构体才分配内存。</p>
<h1 id="2-结构体实例"><a href="#2-结构体实例" class="headerlink" title="2.结构体实例"></a>2.结构体实例</h1><h2 id="2-1基础方法"><a href="#2-1基础方法" class="headerlink" title="2.1基础方法"></a>2.1基础方法</h2><p>结构体变量是结构体类型的实例，实例化就是在内存分配一个结构体类型的变量空间。<br>方法一：先声明结构体类型stu，再实例变量stu1,stu2。<br>该方法结构体类型声明和实例化分离。声明一次，到处实例化。注意实例变量要带struct关键字。</p>
<pre><code>struct stu stu1, stu2;
</code></pre>
<p>方法二：声明的时候也实例变量stu1,stu2。</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<p>方法三：不声明接头体名，直接实例变量。<br>适用于只需要 stu1、stu2两个变量，后面不需要再使用结构体名定义其他变量的情况</p>
<pre><code>struct&#123;             //没有写stu
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<h2 id="2-2重定义方法"><a href="#2-2重定义方法" class="headerlink" title="2.2重定义方法"></a>2.2重定义方法</h2><p>结构体类型通常配合typedef重定义后声明。<br>声明一次，到处实例化。不需要带struct关键字。</p>
<pre><code>    typedef struct stu&#123; //stu可省略
        char *name;     //姓名
        int num;        //学号
        int age;        //年龄
        char group;     //所在小组
        float score;    //成绩
    &#125;stu_t, *stu_p;    //声明stu_t为stu类型，stu_p为stu类型的指针
</code></pre>
<p>实例变量：</p>
<pre><code>stu_t stu1,stu2;    //实例两个stu结构体变量
stu_p *stu1_p, *stu2_p; //实例两个指向stu结构体指针
stu1_p = &amp;stu1; //指向实例stu1
stu2_p = &amp;stu2; //指向实例stu2
</code></pre>
<h1 id="3-结构体初始化"><a href="#3-结构体初始化" class="headerlink" title="3.结构体初始化"></a>3.结构体初始化</h1><p>初始化&#x3D;赋初始值。<br>结构体的实例只分配了内存，其成员的值要手动赋值后才能确定。否则直接拿来用会得到不确定的值（取决于分配到的内存原本的值）。<br>以重定义的结构体类型stu_t为例，实例变量时顺便初始化所有成员为0：</p>
<pre><code>stu_t stu1,stu2 = &#123;0&#125;;
</code></pre>
<p>有的编译器可能要求这种写法：</p>
<pre><code>stu_t stu1,stu2 = &#123;&#123;0&#125;&#125;;
</code></pre>
<p>如果各成员有默认初始值，初始化如下：</p>
<pre><code>stu_t stu1, stu2 = &#123; &quot;Tom&quot;, 9527, 18, &#39;A&#39;, 136.5 &#125;;
</code></pre>
<h1 id="4-结构体的赋值"><a href="#4-结构体的赋值" class="headerlink" title="4.结构体的赋值"></a>4.结构体的赋值</h1><p>结构体赋值是对结构体变量内的成员赋值。<br>两种方式访问成员：</p>
<pre><code>结构体变量.成员名;
stu1.name = &#39;Tom&#39;;
结构体指针-&gt;成员名
stu1_p-&gt;name = &#39;Tom&#39;;
</code></pre>
<p>这两种方法的选择取决于使用情况。如果结构体作为参数在函数之间频繁传递和赋值，建议使用传指针，而不是传结构体变量，这样减少函数为结构体频繁分配局部内存，但要注意结构体已被释放，形成空指针的判断。<br>注意是对实例的成员赋值（已分配内存），而不能对结构体类型的成员赋值（只是个标签）。例如如下操作是错误的：</p>
<pre><code>stu_t.name = &quot;Tom&quot;  //错，stu_t是类型
stu1_p = &amp;stu_t     //错，stu_t没地址
</code></pre>
<p>可以对结构体类型进行sizeof操作，而不需要分配内存。</p>
<pre><code>sizeof(stu_t);      //获取结构体（将）占用的内存空间
</code></pre>
<h1 id="5-结构体的内存分配"><a href="#5-结构体的内存分配" class="headerlink" title="5.结构体的内存分配"></a>5.结构体的内存分配</h1><p><strong>理论上</strong>结构体的内存占用是成员占用的和。各成员在内存中连续存储的，和数组非常类似，例如结构体变量 stu1、stu2的内存分布如下，共占用 4+4+4+1+4&#x3D;17字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061515193.jpeg" alt="1"><br>但实际上，编译器会遵循<strong>内存对齐</strong>规则。实际内存占用大于各成员占用的和。如下图，stu1、stu2 其实占用了 17+3&#x3D;20 字节<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516336.jpeg" alt="2"></p>
<h2 id="5-1内存对齐概述"><a href="#5-1内存对齐概述" class="headerlink" title="5.1内存对齐概述"></a>5.1内存对齐概述</h2><p>1.CPU怎么访问内存中的数据最高效？<br>答：用最少的访问次数，获取该数据所在的内存空间的值。<br>2.怎么做到对某类型数据的最少访问？<br>答：编译器设置数据的存放地址的单位为数据占用空间的长度，CPU以数据长度为单位查询偏移地址，找到数据空间首地址后，根据数据类型取出其占用空间大小的数据。<br>如int数据，就存放在以4字节为单位的偏移地址，如0，4，8…,CPU取数据就按0，4，8…的地址查询，找到该数据地址后取4字节。这样做到一次性访问获取int数据。如果CPU按单字节访问int,就要查询4次，如int首字节地址为0x00001024, CPU要分4次查询0x00001024~0x00001027才能得到一个int。<br>3.对于结构体，包含多种数据类型，怎么对齐？<br>答：各成员按各自的类型对齐，即对于成员来说不存在结构体的概念，它认为它就是基本的数据类型int、char、指针等。</p>
<h2 id="5-2结构体与内存对齐"><a href="#5-2结构体与内存对齐" class="headerlink" title="5.2结构体与内存对齐"></a>5.2结构体与内存对齐</h2><p>结构体是不同类型数据的集合，因此内存对齐问题就特别突出。一个例子：</p>
<pre><code>#include &quot;stdio.h&quot;
typedef struct &#123;
    int a;
    double b;
    char c;
&#125;A; 

typedef struct &#123;
    int a;
    char b;
    double c;
&#125;B;

int main()
&#123;
	printf(&quot;sizeof A: %d, sizeof B: %d\n&quot;, sizeof(A), sizeof(B));
&#125;
</code></pre>
<p>A和B的内存占用：A&#x3D;24字节，B&#x3D;16字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516111.png" alt="3"><br>结构体内存对齐的计算规则：<br>1.默认首地址已对齐（或认为是0地址)<br>2.各成员按自己的类型对齐<br>3.整个结构体分配的空间是期中最大成员占用空间的整数倍<br>对于A：<br>int a占用4字节，地址byte[0<del>3]<br>double b占8字节，起始地址必须是8的倍数，占用byte[7</del>15]<br>char c占1字节，因此占byte[16]<br>目前共占用17字节。编译器会按照规则3，将byte[17~13]也分配给结构体，因此最终结构体占用3<em>8&#x3D;24字节。<br>对于B, int a和char b加起来都不够8字节，double c再占用8字节，共占用2</em>8&#x3D;16字节。<br>因此<strong>结构体的内存分配&#x3D;各成员按类型对齐+总空间是最大成员空间的倍数</strong><br>注意，结构体不仅成员间要对齐，最后一个成员后面的空余空间可能也分配给结构体。<br>查看下面的测试程序：</p>
<pre><code>typedef struct &#123;
    int a;
    double b;
    char c;
    char d;         //d作为成员
&#125;C;

typedef struct &#123;
    int a;
    double b;
    char c;
    struct &#123;        //d作为嵌套结构体的成员
    	char d; 
    &#125;;
&#125;D;

printf(&quot;sizeof C: %d, sizeof D: %d\n&quot;, sizeof(C), sizeof(D));
</code></pre>
<p>C和D的内存占用：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517211.png" alt="4"><br>新增的char d作为C的成员被分配在第三个8byte区域的第二个字节（byte[17])，嵌套的结构体并不从第四个8byte开始分配，它占用空间还是byte[17]。可见编译器对结构体内存分配不区分成员类型，只根据成员大小来处理。</p>
<h1 id="6-联合、位域、枚举"><a href="#6-联合、位域、枚举" class="headerlink" title="6.联合、位域、枚举"></a>6.联合、位域、枚举</h1><p>这几种数据结构体和结构体相关联，通常混合使用。</p>
<h2 id="6-1联合"><a href="#6-1联合" class="headerlink" title="6.1联合"></a>6.1联合</h2><p>联合(Union)也称共用体，和结构体的区别：<br>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。<br>声明格式：</p>
<pre><code>union 共用体名&#123;
    成员列表
&#125;;
</code></pre>
<p>共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>联合的一个示例：</p>
<pre><code>#include &lt;stdio.h&gt;
union data&#123;
    int n;
    char ch;
    short m;
&#125;;
int main()&#123;
    union data a;
    printf(&quot;%d, %d\n&quot;, sizeof(a), sizeof(union data) );
    a.n = 0x40;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.ch = &#39;9&#39;;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.m = 0x2059;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.n = 0x3E25AD54;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>4, 4
40, @, 40
39, 9, 39
2059, Y, 2059
3E25AD54, T, AD54
</code></pre>
<p>在内存中数据分布如下（以大端，低字节存高位为例）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517262.jpeg" alt="5"><br>可见数据会相互覆盖，联合可以理解为分时复用的结构体，其空间占用定长，为最大的成员长度，在不同时间，值的含义不同。</p>
<h2 id="6-2位域"><a href="#6-2位域" class="headerlink" title="6.2位域"></a>6.2位域</h2><p>有的结构体成员在存储时并不占用一个完整的字节，只需要按二进制位为单位分配空间即可。可以指定该成员所占用的二进制位数（Bit），这就是位域。</p>
<pre><code>#include &quot;stdio.h&quot;
struct &#123;
        unsigned char a;    //a占完整的8bit
        unsigned char b: 2; //b占2bit
        unsigned char c: 6; //C占6bit
&#125;bs;

int main()
&#123;
	printf(&quot;sizeof bs: %d\n&quot;, sizeof(bs));
&#125;
</code></pre>
<p>输出2字节，可见b和c刚好拼成一个unsigned char(8 bit)：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517807.png" alt="6"><br>位域将结构体成员占用的空间从基本数据类型为单位，变成了以二进制位为单位，是更精细的结构体内存分配。<br>位域不能超过对应基本类型的二进制位数。</p>
<h2 id="6-3枚举"><a href="#6-3枚举" class="headerlink" title="6.3枚举"></a>6.3枚举</h2><p>枚举可以理解为计数宏的结构体。</p>
<pre><code>#include &lt;stdio.h&gt;
int main()&#123;
    enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125; day;
    scanf(&quot;%d&quot;, &amp;day);
    switch(day)&#123;
        case Mon: puts(&quot;Monday&quot;); break;
        case Tues: puts(&quot;Tuesday&quot;); break;
        case Wed: puts(&quot;Wednesday&quot;); break;
        case Thurs: puts(&quot;Thursday&quot;); break;
        case Fri: puts(&quot;Friday&quot;); break;
        case Sat: puts(&quot;Saturday&quot;); break;
        case Sun: puts(&quot;Sunday&quot;); break;
        default: puts(&quot;Error!&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
<p>枚举值默认从0开始，往后逐个加 1（递增）；如果第一个成员赋值，从那个成员值往后递增。也就是说，week中的 Mon、Tues …… Sun 对应的值分别为 1、2… 7。<br>宏在编译的预处理阶段将名字替换成对应的值，而枚举在编译阶段将名字替换成对应的值。在编译过程中，Mon、Tues、Wed 名字都被替换成了对应的数字。这意味着Mon、Tues、Wed 等都不是变量，不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是被编译到指令里面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。<br>枚举类型实例的内存占用通常&#x3D;int类型占用&#x3D;4字节。</p>
<h1 id="7-结构体常见用法"><a href="#7-结构体常见用法" class="headerlink" title="7.结构体常见用法"></a>7.结构体常见用法</h1><h2 id="7-1结构体数组"><a href="#7-1结构体数组" class="headerlink" title="7.1结构体数组"></a>7.1结构体数组</h2><p>结构体数组是将多个同类型结构体按数组的方式存储，其成员访问方式为：先访问数组元素，再访问结构体成员。<br>结构体数组本质还是数组，但数组成员是结构体，结构体内可以包含各种类型的成员。<br>一个Linux NandFlash驱动的结构体数组如下：</p>
<pre><code>    static struct mtd_partition s3c_nand_parts[] = &#123;
	[0] = &#123;
        .name   = &quot;bootloader&quot;,
        .size   = 0x00040000,
		.offset	= 0,
	&#125;,
	[1] = &#123;
        .name   = &quot;params&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00020000,
	&#125;,
	[2] = &#123;
        .name   = &quot;kernel&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00200000,
	&#125;,
	[3] = &#123;
        .name   = &quot;root&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = MTDPART_SIZ_FULL,
	&#125;
&#125;;
</code></pre>
<p> 该数组名为s3c_nand_parts，成员为mtd_partition结构体，包含分区名，分区大小和分区偏移地址。每个结构体成员分别初始化赋值。注意结构体数组实例没写结构体名，只有数组下标[]，结构体成员没写结构体名,只有.符号。这是Linux kernel常见的精简写法。<br> 访问一个结构体数组的成员：</p>
<pre><code>s3c_nand_parts[0].name = &quot;bootloader_2&quot;
</code></pre>
<p>结构体数组的内存占用&#x3D;数组成员数*单个结构体内存占用。</p>
<h2 id="7-2结构体指针"><a href="#7-2结构体指针" class="headerlink" title="7.2结构体指针"></a>7.2结构体指针</h2><p>结构体指针本质是指针变量，其值是结构体的地址。<br>前面结构体重定义一节已经定义和初始化过结构体指针，需要注意的是，结构体指针的初始化值来源于结构体实例，结构体类型名只是标签，不代表结构体地址，注意和”数组名&#x3D;数组地址“区分。</p>
<pre><code>struct stu&#123;         
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;

struct stu *stu_p = stu;    //错，stu只是符号，不占内存
struct stu *stu_p = &amp;stu1;  //对，stu1是结构体实例，占内存  //对，stu1是stu实例变量，有内存占用
</code></pre>
<p>结构体指针的常见用途：malloc分配结构体空间</p>
<pre><code>stu_p =(stu_t *)malloc(sizeof(stu_t));  //分配结构体空间，返回地址给结构体指针
</code></pre>
<p>结构体指针最重要的用途：函数传参<br>结构体变量作为函数参数时传递的是整个结构体内存空间，也就是所有成员空间，而不是像数组一样被编译器转换成一个指针。如果结构体成员较多，传送的时间和空间开销会很大，影响程序的运行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。</p>
<h2 id="7-2结构体嵌套"><a href="#7-2结构体嵌套" class="headerlink" title="7.2结构体嵌套"></a>7.2结构体嵌套</h2><p>结构体嵌套是结构体的成员也是结构体。有两种情况：<br>1.成员是其他类型的结构体<br>2.成员是同类型的结构体</p>
<h3 id="7-2-1-嵌套其他类型"><a href="#7-2-1-嵌套其他类型" class="headerlink" title="7.2.1.嵌套其他类型"></a>7.2.1.嵌套其他类型</h3><p>在协议开发中，一个命令的数据可以用结构体来表达，在命令的内部又分为很多个数据域，每个数据域又用结构体来表达，因此需要结构体嵌套。对于同一块数据，根据命令的不同，解析为不同的结构体,因此存在多类命令公用一块数据域的情况，因此需要联合（Union）。以NVMe协议为例，结构体嵌套和联合一起使用的例子：</p>
<pre><code>typedef struct  //nvme命令结构体
&#123;
     union      //命令中dword10空间的联合
    &#123;
        u32 command_dw10;
        struct
        &#123;
            u32 cntid:16;   //16 bit位域
            u32 resv1:8;    //8 bit位域
            u32 cns:8;      //8 bit位域
        &#125;identify;          //当命令为identify时
        struct
        &#123;
            u32 save:1;
            u32 resv1:20;
            u32 select:3;
            u32 feature_identifier:8;
        &#125;get_features;      //当命令为get_featuresy时
        struct
        &#123;
            u32 queue_size:16;
            u32 queue_identifier:16;
        &#125;io_queue_create_delete_dw10;
        ...
    &#125;;
    
    union   //命令中dword11空间的联合
    &#123;
        u32 command_dw11;
        struct
        &#123;
            u32 completion:16;
            u32 submission:16;
        &#125;number_of_queues;
        struct
        &#123;
            u32 interrupt_vector:16;
            u32 resv1:14;
            u32 interrupt_enabled:1;
            u32 physically_contiguous:1;
        &#125;create_io_completion_queue_dw11;
        ...
    &#125;;
    
&#125;command_t, *command_p;
</code></pre>
<p>该例子结合了结构体、联合、位域。对每个nvme命令，多个联合并存在结构体command_t实例里，每个联合长度为一个dword(4字节)，分别表示dword0~15中的一个。对于dword内部，根据解析到命令的不同，作为不同含义处理，如解析为identify就按identify的结构体读写成员，如解析为get_features则按get_features的结构体读写成员。在结构体内部，用位域更精细控制这个dword内各bit的含义。</p>
<h3 id="7-2-2嵌套自身类型"><a href="#7-2-2嵌套自身类型" class="headerlink" title="7.2.2嵌套自身类型"></a>7.2.2嵌套自身类型</h3><p>结构体嵌套自身类型的典型应用：链表数据结构体</p>
<pre><code>typedef struct ListNode &#123;
	DataType data;          // 节点数据 
	struct ListNode *next;  // 指向下一个结点的指针 
&#125; ListNode_t;
</code></pre>
<p>这个结构体有两个成员：DataType类型的数据，和指向 struct ListNode类型(&#x3D;ListNode_t类型)的实例的指针。有多个ListNode_t类型的结构体被实例化且依次指向后续节点后，可以依次node1-&gt;next-&gt;next…-&gt;data访问链表中的节点数据。<br>注意：结构体体能嵌套自身类型的指针，而不能嵌套自身类型的实例。因为指针分配内存是定长（通常4字节），而循环嵌套结构体变量是无穷的。以下写法是错的</p>
<pre><code>typedef struct ListNode &#123;
	DataType data;           
	struct ListNode next;  // 错，嵌套的是实例 
&#125; ListNode_t;
</code></pre>
<h1 id="8-结构体高级用法：面向对象"><a href="#8-结构体高级用法：面向对象" class="headerlink" title="8.结构体高级用法：面向对象"></a>8.结构体高级用法：面向对象</h1><h2 id="8-1函数指针"><a href="#8-1函数指针" class="headerlink" title="8.1函数指针"></a>8.1函数指针</h2><p>程序中定义的函数，在编译时会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的入口地址。函数名表示的就是这个地址的值。可以定义一个指针变量来存放函数的入口地址，这个指针变量就叫作函数指针变量，简称函数指针。<br>这段话什么意思？<br>1.函数名&#x3D;函数入口地址<br>2.可以用指针变量的值取代函数名，函数的调用和该指针变量的调用等价<br>3.可以把这个指针变量当参数传递给别的函数，也可以把这个指针变量作为结构体的成员，总之，一切指针能做的，函数指针都能做。<br>函数指针的定义：</p>
<pre><code>返回值 函数入口地址(入参1的类型，入参2的类型，...)
int (*p)(int, int);     //p为函数指针，*p为入口地址
</code></pre>
<p>定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数。p 的类型为 int(*)(int，int)<br>函数指针的初始化：</p>
<pre><code>int Func(int x);   /*声明一个函数，包含入参名*/
int (*p) (int);  /*声明一个函数指针，只有入参类型*/
p = Func;         /*将Func函数的入口地址赋给指针变量p*/
</code></pre>
<p>函数指针作为结构体成员的调用如下</p>
<pre><code>struct&#123;
    int (* func)(int);
&#125;stu1, *stu1_p; //分配两个结构体实例：stu1结构体和指针stu1_p

stu1.func(10);  //通过结构体调用函数指针
stu1_p-&gt;func(10);   //通过结构体指针调用函数指针
</code></pre>
<h2 id="8-2回调函数"><a href="#8-2回调函数" class="headerlink" title="8.2回调函数"></a>8.2回调函数</h2><p>回调函数(Callback)就是一个通过函数指针调用的函数。把函数指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由函数的实现方直接调用，而是在特定的事件或条件发生时，由把它当参数的那个函数调用的，用于对该事件或条件进行响应。<br>回调的两个特点：<br>1.函数&#x3D;参数。函数A指针当参数传递B<br>2.异步。特定时间发生时，B才调用A指针指向的函数</p>
<h2 id="8-3结构体与面向对象"><a href="#8-3结构体与面向对象" class="headerlink" title="8.3结构体与面向对象"></a>8.3结构体与面向对象</h2><p>当函数指针作为结构体的成员，可以通过结构体实例调用成员函数，此时可以实现类似其他语言中“类”或“接口”的概念：<br>结构体声明&#x3D;类声明&#x3D;接口声明<br>结构体的函数指针成员&#x3D;类方法&#x3D;接口函数<br>结构体实例调用函数指针成员&#x3D;类实例调用方法&#x3D;接口的实现<br>这种设计思想在Linux内核和驱动框架中很常用。以字符设备驱动为例：<br>字符设备驱动顶层框架将所有字符操作函数作为接口在结构体file_operations中定义，在底层具体的设备驱动中实现file_operations的方法。底层驱动实例化file_operations结构体（分配内存），将各种操作的具体实现函数赋值给接口定义的函数，然后上报（注册）该file_operations实例给顶层驱动框架，顶层驱动框架接收到应用层的系统调用请求时，回调已注册的file_operations实例的函数。<br>上层驱动框架定义的字符文件操作接口如下，这些open、read、write作为文件操作的方法供应用层调用。</p>
<pre><code> struct file_operations &#123;   //字符文件操作的接口定义
　　struct module *owner;   //结构体指针
　　ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);      //函数指针read
　　ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);    //函数指针write
　　int (*open) (struct inode *, struct file *);    //函数指针open
　　int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);   //函数指针ioctl
　　...
&#125;;
</code></pre>
<p>而这些方法具体实现（内部做什么）是由底层驱动代码实现：</p>
<pre><code>static int my_drv_open(struct inode *inode, struct file *file)
&#123;
	//硬件寄存器操作A...
	return 0;
&#125;

static ssize_t my_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)
&#123;
	//硬件寄存器操作B...
	return 0;
&#125;
</code></pre>
<p>那么这些实现怎么关联接口：在底层驱动分配结构体实例，初始化函数指针为实现函数</p>
<pre><code>static struct file_operations my_drv_fops = &#123;
    .owner  =   THIS_MODULE,   
    .open   =   my_drv_open,   //open接口由my_drv_open函数实现  
	.write	=	my_drv_write,	 //write接口由my_drv_write函数实现  
&#125;;
</code></pre>
<p>关联完了，上层驱动怎么调用：结构体指针传参+回调<br>my_drv_fops是file_operations的实例，上报给上层驱动，上层驱动有它自己的字符设备结构体cdev，取出my_drv_fops实例的.结构体指针fops的值，赋给cdev实例内的ops指针。之后它就能用ops调用my_drv_open、my_drv_write函数。</p>
<pre><code>//注册结构体
cdev-&gt;owner = fops-&gt;owner;
cdev-&gt;ops = fops;
//回调.open方法
cdev-&gt;ops-&gt;open(inode,file);
</code></pre>
<p>由于my_drv_write是值，open才是结构体成员，因此调用的时候看上去调用的是open函数，本质上执行的还是my_drv_write的流程。函数指针的回调能将接口名暴露，方法名隐藏。因此底层实现的函数名和上层驱动的调用函数名不相关，上层永远都可以用.open .read .write这些接口调用底层驱动，而底层函数可以随便改名（不能改入参出参类型，否则函数指针类型变了），这种特性都是函数指针决定的。<br>对于应用程序，是调用上层驱动提供的系统调用接口，还是如.open .read .write等接口。Linux驱动将设备抽象成了文件，驱动程序实现了文件的各种方法，所以对应用程序，打开文件&#x3D;打开设备，调用文件对应的接口&#x3D;调用设备驱动提供的接口。</p>
<pre><code>fd = open(&quot;/dev/xyz&quot;, O_RDWR);  //打开文件（设备）
read(fd, &amp;val, 1);  //读fd文件（设备）的值到val变量
</code></pre>
<p>除了C语言，在golang中也有类似的结构体+函数指针实现的面向对象方法。<br>NOTE:关于结构体中的函数指针写法易错点：<br>不包含变量名，只能使用基本类型</p>
<pre><code>   #一个结构体
   typedef stru&#123;    //定义结构体名
        int a;
        char b;
   &#125;stru_t, *stru_p; //重定义结构体变量和指针
    
    #普通函数声明
    int func(int a, stru_p p); //参数写类型且写值，可以使用typedef后的结构体指针类型
    
    #函数指针声明
    int (*func)(int, struct stru *);    //参数只写类型不写参数，只能使用C基本类型，不能使用typedef后的类型，只能写struct stru *类型
</code></pre>
<p>函数指针声明使用typedef后的类型名，编译器不认识，产生syntax error。    </p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux网络编程: IO多路复用之select、poll、epoll</title>
    <url>/2020/12/07/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>I&#x2F;O多路复用：通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<p>但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>IO多路复用适用如下场合：</p>
<ul>
<li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li>
</ul>
<p>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p>
<h1 id="select实现"><a href="#select实现" class="headerlink" title="select实现"></a>select实现</h1><p>逻辑时序：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401453.png" alt="1"><br>具体实现：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401118.png" alt="2"></p>
<p>fd_set(监听的端口个数)：32位机默认是1024个，64位机默认是2048。</p>
<p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间<br>（2）注册回调函数__pollwait<br>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）<br>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。<br>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。<br>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。<br>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。<br>（8）把fd_set从内核空间拷贝到用户空间。</p>
<p>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024</p>
<h1 id="poll实现"><a href="#poll实现" class="headerlink" title="poll实现"></a>poll实现</h1><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，而使其没有连接数的限制。其他的都差不多。</p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401522.png" alt="3"></p>
<h2 id="epoll的几大改进"><a href="#epoll的几大改进" class="headerlink" title="epoll的几大改进"></a>epoll的几大改进</h2><p>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。<br>每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中。<br>而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。即epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关。</p>
<p>对于第三个缺点，epoll没有这个限制。<br>它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看,一般来说这个数目和系统内存关系很大。</p>
<h2 id="epoll小结："><a href="#epoll小结：" class="headerlink" title="epoll小结："></a>epoll小结：</h2><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。<br>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<h1 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h1><ol>
<li><p>支持一个进程所能打开的最大连接数<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051402990.png" alt="4"></p>
</li>
<li><p>FD剧增后带来的IO效率问题<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051402536.png" alt="5"></p>
</li>
<li><p>消息传递方式<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051403370.png"></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p>
<ul>
<li>连接数多，活跃链接占比不高的场景下，epoll的性能最好</li>
<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>
<li>select低效是因为每次它都需要轮询。但低效也是相对的，可通过良好的设计改善。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux的Signal信号</title>
    <url>/2020/11/08/%E6%B5%85%E8%B0%88Linux%E7%9A%84Signal%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<p>本文将从以下几个方面来阐述信号:</p>
<p>(1) 信号的基本知识<br>(2) 信号生命周期与处理过程分析<br>(3) 基本的信号处理函数<br>(4) 保护临界区不被中断<br>(5) 信号的继承与执行<br>(6) 实时信号中锁的研究</p>
<h1 id="第一部分-信号的基本知识"><a href="#第一部分-信号的基本知识" class="headerlink" title="第一部分: 信号的基本知识"></a>第一部分: 信号的基本知识</h1><h2 id="1-信号本质"><a href="#1-信号本质" class="headerlink" title="1.信号本质:"></a>1.信号本质:</h2><p>信号的本质是软件层次上对中断的一种模拟。它是一种异步通信的处理机制，事实上，进程并不知道信号何时到来。</p>
<h2 id="2-信号来源"><a href="#2-信号来源" class="headerlink" title="2.信号来源"></a>2.信号来源</h2><p>(1)程序错误，如非法访问内存<br>(2)外部信号，如按下了CTRL+C<br>(3)通过kill或sigqueue向另外一个进程发送信号</p>
<h2 id="3-信号种类"><a href="#3-信号种类" class="headerlink" title="3.信号种类"></a>3.信号种类</h2><p>信号分为可靠信号与不可靠信号,可靠信号又称为实时信号，非可靠信号又称为非实时信号。<br>信号代码从1到32是不可靠信号,不可靠信号主要有以下问题:<br>(1)每次信号处理完之后，就会恢复成默认处理，这可能是调用者不希望看到的<br>(2)存在信号丢失的问题<br>现在的Linux对信号机制进行了改进，因此，不可靠信号主要是指信号丢失<br>信号代码从SIGRTMIN到SIGRTMAX之间的信号是可靠信号。可靠信号不存在丢失，由sigqueue发送，可靠信号支持排队。</p>
<p>可靠信号注册机制:<br>内核每收到一个可靠信号都会去注册这个信号，在信号的未决信号链中分配sigqueue结构，因此，不会存在信号丢失的问题。</p>
<p>不可靠信号的注册机制:<br>而对于不可靠的信号，如果内核已经注册了这个信号，那么便不会再去注册，对于进程来说，便不会知道本次信号的发生。<br>可靠信号与不可靠信号与发送函数没有关系，取决于信号代码，前面的32种信号就是不可靠信号，而后面的32种信号就是可靠信号。</p>
<h2 id="4-信号响应的方式"><a href="#4-信号响应的方式" class="headerlink" title="4.信号响应的方式"></a>4.信号响应的方式</h2><p>(1)采用系统默认处理SIG_DFL,执行缺省操作<br>(2)捕捉信号处理，即用户自定义的信号处理函数来处理<br>(3)忽略信号SIG_IGN ,但有两种信号不能被忽略SIGKILL，SIGSTOP</p>
<h1 id="第二部分-信号的生命周期与处理过程分析"><a href="#第二部分-信号的生命周期与处理过程分析" class="headerlink" title="第二部分: 信号的生命周期与处理过程分析"></a>第二部分: 信号的生命周期与处理过程分析</h1><h2 id="1-信号的生命周期"><a href="#1-信号的生命周期" class="headerlink" title="1. 信号的生命周期"></a>1. 信号的生命周期</h2><p>信号产生-&gt;信号注册－&gt;信号在进程中注销-&gt;信号处理函数执行完毕</p>
<p>(1)信号的产生是指触发信号的事件的发生</p>
<p>(2)信号注册<br>指的是在目标进程中注册，该目标进程中有未决信号的信息:</p>
<pre><code>struct sigpending pending：
struct sigpending{
struct sigqueue *head, **tail;
sigset_t signal;
};

struct sigqueue{
struct sigqueue *next;
siginfo_t info;
}
</code></pre>
<p>其中 sigqueue结构组成的链称之为未决信号链，sigset_t称之为未决信号集。<br>*head,**tail分别指向未决信号链的头部与尾部。<br>siginfo_t info是信号所携带的信息。<br>信号注册的过程就是将信号值加入到未决信号集siginfo_t中，将信号所携带的信息加入到未决信号链的某一个sigqueue中去。<br> 因此，对于可靠的信号，可能存在多个未决信号的sigqueue结构，对于每次信号到来都会注册。而不可靠信号只注册一次，只有一个sigqueue结构。<br>只要信号在进程的未决信号集中，表明进程已经知道这些信号了，还没来得及处理，或者是这些信号被阻塞。</p>
<p>(3)信号在目标进程中注销<br> 在进程的执行过程中，每次从系统调用或中断返回用户空间的时候，都会检查是否有信号没有被处理。如果这些信号没有被阻塞，那么就调用相应的信号处理函数来处理这些信号。则调用信号处理函数之前，进程会把信号在未决信号链中的sigqueue结构卸掉。是否从未决信号集中把信号删除掉，对于实时信号与非实时信号是不相同的。<br>非实时信号:由于非实时信号在未决信号链中只有一个sigqueue结构，因此将它删除的同时将信号从未决信号集中删除。<br>实时信号:由于实时信号在未决信号链中可能有多个sigqueue结构，如果只有一个，也将信号从未决信号集中删除掉。如果有多个那么不从未决信号集中删除信号，注销完毕。</p>
<p>(4)信号处理函数执行完毕<br>执行处理函数，本次信号在进程中响应完毕。<br>在第4步，只简单的描述了信号处理函数执行完毕，就完成了本次信号的响应，但这个信号处理函数空间是怎么处理的呢? 内核栈与用户栈是怎么工作的呢? 这就涉及到了信号处理函数的过程。</p>
<h2 id="2-信号处理函数的过程"><a href="#2-信号处理函数的过程" class="headerlink" title="2. 信号处理函数的过程:"></a>2. 信号处理函数的过程:</h2><p>(1)注册信号处理函数<br>信号的处理是由内核来代理的，首先程序通过sigal或sigaction函数为每个信号注册处理函数，而内核中维护一张信号向量表，对应信号处理机制。这样，在信号在进程中注销完毕之后，会调用相应的处理函数进行处理。</p>
<p>(2)信号的检测与响应时机<br>在系统调用或中断返回用户态的前夕，内核会检查未决信号集，进行相应的信号处理。</p>
<p>(3)处理过程:<br>程序运行在用户态时-&gt;进程由于系统调用或中断进入内核-&gt;转向用户态执行信号处理函数-&gt;信号处理函数完毕后进入内核-&gt;返回用户态继续执行程序<br>首先程序执行在用户态，在进程陷入内核并从内核返回的前夕，会去检查有没有信号没有被处理，如果有且没有被阻塞就会调用相应的信号处理程序去处理。首先，内核在用户栈上创建一个层，该层中将返回地址设置成信号处理函数的地址，这样，从内核返回用户态时，就会执行这个信号处理函数。当信号处理函数执行完，会再次进入内核，主要是检测有没有信号没有处理，以及恢复原先程序中断执行点，恢复内核栈等工作，这样，当从内核返回后便返回到原先程序执行的地方了。<br>信号处理函数的过程大概是这样了。<br>具体的可参考<a href="http://www.spongeliu.com/linux/linux%E5%86%85%E6%A0%B8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/">http://www.spongeliu.com/linux/linux内核信号处理机制介绍/</a></p>
<h1 id="第三部分-基本的信号处理函数"><a href="#第三部分-基本的信号处理函数" class="headerlink" title="第三部分: 基本的信号处理函数"></a>第三部分: 基本的信号处理函数</h1><p>首先看一个两个概念: 信号未决与信号阻塞<br>信号未决: 指的是信号的产生到信号处理之前所处的一种状态。确切的说，是信号的产生到信号注销之间的状态。<br>信号阻塞: 指的是阻塞信号被处理，是一种信号处理方式。</p>
<h2 id="1-信号操作"><a href="#1-信号操作" class="headerlink" title="1. 信号操作"></a>1. 信号操作</h2><p> 信号操作最常用的方法是信号的屏蔽，信号屏蔽主要用到以下几个函数:</p>
<pre><code>int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set,int signo);
int sigdelset(sigset_t *set,int signo);
int sigismemeber(sigset_t* set,int signo);
int sigprocmask(int how,const sigset_t*set,sigset_t *oset);
</code></pre>
<p>信号集，信号掩码，未决集<br>信号集: 所有的信号阻塞函数都使用一个称之为信号集的结构表明其所受到的影响。<br>信号掩码:当前正在被阻塞的信号集。<br>未决集: 进程在收到信号时到信号在未被处理之前信号所处的集合称为未决集。<br>可以看出，这三个概念没有必然的联系，信号集指的是一个泛泛的概念，而未决集与信号掩码指的是具体的信号状态。</p>
<p>对于信号集的初始化有两种方法: 一种是用sigemptyset使信号集中不包含任何信号，然后用sigaddset把信号加入到信号集中去。<br>另一种是用sigfillset让信号集中包含所有信号，然后用sigdelset删除信号来初始化。<br>sigemptyset()函数初始化信号集set并将set设置为空。<br>sigfillset()函数初始化信号集，但将信号集set设置为所有信号的集合。<br>sigaddset()将信号signo加入到信号集中去。<br>sigdelset()从信号集中删除signo信号。<br>sigprocmask()将指定的信号集合加入到进程的信号阻塞集合中去。如果提供了oset,那么当前的信号阻塞集合将会保存到oset集全中去。<br>参数how决定了操作的方式:<br>SIG_BLOCK 增加一个信号集合到当前进程的阻塞集合中去<br>SIG_UNBLOCK 从当前的阻塞集合中删除一个信号集合<br>SIG_SETMASK 将当前的信号集合设置为信号阻塞集合</p>
<p>下面看一个例子:</p>
<pre><code>int main(){
    sigset_t initset;
    int i;
    sigemptyset(&amp;initset);//初始化信号集合为空集合
    sigaddset(&amp;initset,SIGINT);//将SIGINT信号加入到此集合中去
    while(1){
        sigprocmask(SIG_BLOCK,&amp;initset,NULL);//将信号集合加入到进程的阻塞集合中去
        fprintf(stdout,&quot;SIGINT singal blocked/n&quot;);
        for(i=0;i&lt;10;i++){
        
            sleep(1);//每1秒输出
            fprintf(stdout,&quot;block %d/n&quot;,i);
        }
        //在这时按一下Ctrl+C不会终止
        sigprocmask(SIG_UNBLOCK,&amp;initset,NULL);//从进程的阻塞集合中去删除信号集合
        fprintf(stdout,&quot;SIGINT SINGAL unblokced/n&quot;);
        for(i=0;i&lt;10;i++){
            sleep(1);
            fprintf(stdout,&quot;unblock %d/n&quot;,i);
        }
    }
    exit(0);
}
</code></pre>
<p>执行结果:</p>
<pre><code>SIGINT singal blocked
block 0
block 1
block 2
block 3
block 4
block 5
block 6
block 7
block 8
block 9
</code></pre>
<p>在执行到block 3时按下了CTRL+C并不会终止，直到执行到block9后将集合从阻塞集合中移除。</p>
<pre><code>[root@localhost C]# ./s1
SIGINT singal blocked
block 0
block 1
block 2
block 3
block 4
block 5
block 6
block 7
block 8
block 9
SIGINT SINGAL unblokced
unblock 0
unblock 1
</code></pre>
<p>由于此时已经解除了阻塞，在unblock1后按下CTRL+C则立即终止。</p>
<h2 id="2-信号处理函数"><a href="#2-信号处理函数" class="headerlink" title="2. 信号处理函数"></a>2. 信号处理函数</h2><p>sigaction</p>
<pre><code>int sigaction(
    int signo,
    const struct sigaction *act,
    struct sigaction *oldact
);
</code></pre>
<p>这个函数主要是用于改变或检测信号的行为。<br>第一个参数是变更signo指定的信号，它可以指向任何值，SIGKILL,SIGSTOP除外<br>第二个参数,第三个参数是对信号进行细粒度的控制。<br>如果*act不为空，*oldact不为空，那么oldact将会存储信号以前的行为。如果act为空，*oldact不为空，那么oldact将会存储信号现在的行为。</p>
<pre><code>struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int,siginfo_t*,void*);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
}
</code></pre>
<p>参数含义:<br>sa_handler是一个函数指针，主要是表示接收到信号时所要采取的行动。此字段的值可以是SIG_DFL,SIG_IGN.分别代表默认操作与内核将忽略进程的信号。这个函数只传递一个参数那就是信号代码。<br>当SA_SIGINFO被设定在sa_flags中，那么则会使用sa_sigaction来指示信号处理函数，而非sa_handler.<br>sa_mask设置了掩码集，在程序执行期间会阻挡掩码集中的信号。<br>sa_flags设置了一些标志， SA_RESETHAND当该函数处理完成之后，设定为为系统默认的处理模式。SA_NODEFER 在处理函数中，如果再次到达此信号时，将不会阻塞。默认情况下，同一信号两次到达时，如果此时处于信号处理程序中，那么此信号将会阻塞。<br>SA_SIGINFO表示用sa_sigaction指示的函数。<br>sa_restorer已经被废弃。</p>
<p>sa_sigaction所指向的函数原型:</p>
<pre><code>void my_handler(int signo,siginfo_t *si,void *ucontext);
</code></pre>
<p>第一个参数: 信号编号<br>第二个参数:指向一个siginfo_t结构。<br>第三个参数是一个ucontext_t结构。<br>其中siginfo_t结构体中包含了大量的信号携带信息，可以看出，这个函数比sa_handler要强大，因为前者只能传递一个信号代码，而后者可以传递siginfo_t信息。</p>
<pre><code>typedef struct siginfo_t{
    int si_signo;//信号编号
    int si_errno;//如果为非零值则错误代码与之关联
    int si_code;//说明进程如何接收信号以及从何处收到
    pid_t si_pid;//适用于SIGCHLD，代表被终止进程的PID
    pid_t si_uid;//适用于SIGCHLD,代表被终止进程所拥有进程的UID
    int si_status;//适用于SIGCHLD，代表被终止进程的状态
    clock_t si_utime;//适用于SIGCHLD，代表被终止进程所消耗的用户时间
    clock_t si_stime;//适用于SIGCHLD，代表被终止进程所消耗系统的时间
    sigval_t si_value;
    int si_int;
    void * si_ptr;
    void* si_addr;
    int si_band;
    int si_fd;
};
</code></pre>
<p>sigqueue</p>
<pre><code>sigqueue(pid_t pid,int signo,const union sigval value)
</code></pre>
<p>sigqueue函数类似于kill,也是一个进程向另外一个进程发送信号的。<br>但它比kill函数强大。<br>第一个参数指定目标进程的pid.<br>第二个参数是一个信号代码。<br>第三个参数是一个共用体，每次只能使用一个，用来进程发送信号传递的数据。<br>或者传递整形数据，或者是传递指针。<br>发送的数据被sa_sigaction所指示的函数的siginfo_t结构体中的si_ptr或者是si_int所接收。</p>
<p>sigpending</p>
<pre><code>sigpending(sigset_t set);
</code></pre>
<p>这个函数的作用是返回未决的信号到信号集set中。即未决信号集，未决信号集不仅包括被阻塞的信号，也可能包括已经到达但没有被处理的信号。</p>
<h2 id="示例1-sigaction函数的用法"><a href="#示例1-sigaction函数的用法" class="headerlink" title="示例1: sigaction函数的用法"></a>示例1: sigaction函数的用法</h2><pre><code>void signal_set(struct sigaction *act)
{
switch(act-&gt;sa_flags){
    case (int)SIG_DFL:
        printf(&quot;using default hander/n&quot;);
        break;
    case (int)SIG_IGN:
        printf(&quot;ignore the signal/n&quot;);
        break;
    default:
        printf(&quot;%0x/n&quot;,act-&gt;sa_handler);
    }
}
void signal_set1(int x){//信号处理函数
    printf(&quot;xxxxx/n&quot;);
    while(1){}
}

int main(int argc,char** argv)
{
    int i;
    struct sigaction act,oldact;
    act.sa_handler = signal_set1;
    act.sa_flags = SA_RESETHAND;
    //SA_RESETHANDD 在处理完信号之后，将信号恢复成默认处理
    //SA_NODEFER在信号处理程序执行期间仍然可以接收信号
    sigaction (SIGINT,&amp;act,&amp;oldact) ;//改变信号的处理模式
    for (i=1; i&lt;12; i++)
    {
        printf(&quot;signal %d handler is : &quot;,i);
        sigaction (i,NULL,&amp;oldact) ;
        signal_set(&amp;oldact);//如果act为NULL，oldact会存储信号当前的行为
        //act不为空，oldact不为空，则oldact会存储信号以前的处理模式
    }
    while(1){
        //等待信号的到来
    }
    return 0;
}
</code></pre>
<p>运行结果:</p>
<pre><code>[root@localhost C]# ./s2
signal 1 handler is : using default hander
signal 2 handler is : 8048437
signal 3 handler is : using default hander
signal 4 handler is : using default hander
signal 5 handler is : using default hander
signal 6 handler is : using default hander
signal 7 handler is : using default hander
signal 8 handler is : using default hander
signal 9 handler is : using default hander
signal 10 handler is : using default hander
signal 11 handler is : using default hander
xxxxx
</code></pre>
<p>解释:</p>
<pre><code>sigaction(i,NULL,&amp;oldact);
signal_set(&amp;oldact);
</code></pre>
<p>由于act为NULL,那么oldact保存的是当前信号的行为，当前的第二个信号的行为是执行自定义的处理程序。<br>当按下CTRL＋C时会执行信号处理程序，输出xxxxxx，再按一下CTRL＋C会停止,是由于SA_RESETHAND恢复成默认的处理模式，即终止程序。<br>如果没有设置SA_NODEFER,那么在处理函数执行过程中按一下CTRL＋C将会被阻塞，那么程序会停在那里。</p>
<h2 id="示例2-sigqueue向本进程发送数据的信号"><a href="#示例2-sigqueue向本进程发送数据的信号" class="headerlink" title="示例2: sigqueue向本进程发送数据的信号"></a>示例2: sigqueue向本进程发送数据的信号</h2><pre><code>int main(){
    union sigval val;//定义一个携带数据的共用体
    struct sigaction oldact,act;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO;//表示使用sa_sigaction指示的函数，处理完恢复默认，不阻塞处理过程中到达下在被处理的信号
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;act,&amp;oldact);
    char data[100];
    int num=0;
    while(num&lt;10){
        sleep(2);
        printf(&quot;等待SIGUSR1信号的到来/n&quot;);
        sprintf(data,&quot;%d&quot;,num++);
        val.sival_ptr=data;
        sigqueue(getpid(),SIGUSR1,val);//向本进程发送一个信号
    }
}

void myhandler(int signo,siginfo_t *si,void *ucontext){
    printf(&quot;已经收到SIGUSR1信号/n&quot;);
    printf(&quot;%s/n&quot;,(char*)(si-&gt;si_ptr));
}
</code></pre>
<p>程序执行的结果是:</p>
<pre><code>等待SIGUSR1信号的到来
已经收到SIGUSR1信号
0
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
1
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
2
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
3
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
4
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
5
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
6
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
7
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
8
等待SIGUSR1信号的到来
已经收到SIGUSR1信号
9
</code></pre>
<p>解释: 本程序用sigqueue不停的向自身发送信号,并且携带数据，数据被放到处理函数的第二个参数siginfo_t结构体中的si_ptr指针，当num&lt;10时不再发。</p>
<p>一般而言，sigqueue与sigaction配合使用，而kill与signal配合使用。</p>
<h2 id="示例3-一个进程向另外一个进程发送信号，并携带信息"><a href="#示例3-一个进程向另外一个进程发送信号，并携带信息" class="headerlink" title="示例3: 一个进程向另外一个进程发送信号，并携带信息"></a>示例3: 一个进程向另外一个进程发送信号，并携带信息</h2><p>发送端:</p>
<pre><code>int main(){
    union sigval value;
    value.sival_int=10;
    
    if(sigqueue(4403,SIGUSR1,value)==-1){//4403是目标进程pid
        perror(&quot;信号发送失败/n&quot;);
    }
    sleep(2);
}
</code></pre>
<p>接收端:</p>
<pre><code>int main(){
    struct sigaction oldact,act;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO|SA_NODEFER;
    //表示执行后恢复，用sa_sigaction指示的处理函数，在执行期间仍然可以接收信号
    sigaction(SIGUSR1,&amp;act,&amp;oldact);
    while(1){
        sleep(2);
        printf(&quot;等待信号的到来/n&quot;);
    }
}

void myhandler(int signo,siginfo_t *si,void *ucontext){
    printf(&quot;the value is %d/n&quot;,si-&gt;si_int);
}
</code></pre>
<h2 id="示例4-sigpending的用法"><a href="#示例4-sigpending的用法" class="headerlink" title="示例4: sigpending的用法"></a>示例4: sigpending的用法</h2><p>sigpending(sigset_t *set)将未决信号放到指定的set信号集中去，未决信号包括被阻塞的信号和信号到达时但还没来得及处理的信号</p>
<pre><code>int main(){
    struct sigaction oldact,act;
    sigset_t oldmask,newmask,pendingmask;
    act.sa_sigaction=myhandler;
    act.sa_flags=SA_SIGINFO;
    sigemptyset(&amp;act.sa_mask);//首先将阻塞集合设置为空，即不阻塞任何信号
    //注册信号处理函数
    sigaction(SIGRTMIN+10,&amp;act,&amp;oldact);
    //开始阻塞
    sigemptyset(&amp;newmask);
    sigaddset(&amp;newmask,SIGRTMIN+10);
    printf(&quot;SIGRTMIN+10 blocked/n&quot;);
    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask);
    sleep(20);//为了发出信号
    printf(&quot;now begin to get pending mask/n&quot;);
    if(sigpending(&amp;pendingmask)&lt;0){
        perror(&quot;pendingmask error&quot;);
    }
    if(sigismember(&amp;pendingmask,SIGRTMIN+10)){
        printf(&quot;SIGRTMIN+10 is in the pending mask/n&quot;);
    }
    
    sigprocmask(SIG_UNBLOCK,&amp;newmask,&amp;oldmask);
    printf(&quot;SIGRTMIN+10 unblocked/n&quot;);
}
//信号处理函数
void myhandler(int signo,siginfo_t *si,void *ucontext){
    printf(&quot;receive signal %d/n&quot;,si-&gt;si_signo);
}
</code></pre>
<p>程序执行,在另一个shell发送信号:</p>
<pre><code> kill -44 4579

SIGRTMIN+10 blocked
now begin to get pending mask
SIGRTMIN+10 is in the pending mask
receive signal 44
SIGRTMIN+10 unblocked
</code></pre>
<p>可以看到SIGRTMIN由于被阻塞所以处于未决信号集中。<br>关于基本的信号处理函数就介绍到这了。</p>
<h1 id="第四部分-保护临界区不被中断"><a href="#第四部分-保护临界区不被中断" class="headerlink" title="第四部分: 保护临界区不被中断"></a>第四部分: 保护临界区不被中断</h1><h2 id="1-函数的可重入性"><a href="#1-函数的可重入性" class="headerlink" title="1. 函数的可重入性"></a>1. 函数的可重入性</h2><p>函数的可重入性是指可以多于一个任务并发使用函数，而不必担心数据错误。相反，不可重入性是指不能多于一个任务共享函数，除非能保持函数互斥(或者使用信号量，或者在代码的关键部分禁用中断)。可重入函数可以在任意时刻被中断，稍后继续执行，而不会丢失数据。</p>
<p>可重入函数：</p>
<ul>
<li>不为连续的调用持有静态数据。</li>
<li>不返回指向静态数据的指针；所有数据都由函数的调用者提供。</li>
<li>使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。</li>
<li>绝不调用任何不可重入函数。</li>
</ul>
<p>不可重入函数可能导致混乱现象，如果当前进程的操作与信号处理程序同时对一个文件进行写操作或者是调用malloc()，那么就可能出现混乱，当从信号处理程序返回时，造成了状态不一致。从而引发错误。<br>因此，信号的处理必须是可重入函数。<br>简单的说，可重入函数是指在一个程序中调用了此函数，在信号处理程序中又调用了此函数，但仍然能够得到正确的结果。<br>printf，malloc函数都是不可重入函数。printf函数如果打印缓冲区一半时，又有一个printf函数，那么此时会造成混乱。而malloc函数使用了系统全局内存分配表。</p>
<h2 id="2-保护临界区不被中断"><a href="#2-保护临界区不被中断" class="headerlink" title="2. 保护临界区不被中断"></a>2. 保护临界区不被中断</h2><p>由于临界区的代码是关键代码，是非常重要的部分，因此，有必要对临界区进行保护，不希望信号来中断临界区操作。这里通过信号屏蔽字来阻塞信号的发生。</p>
<p> 下面介绍两个与保护临界区不被信号中断的相关函数。</p>
<pre><code>int pause(void);
int sigsuspend(const sigset_t *sigmask);
</code></pre>
<p>pause函数挂起一个进程，直到一个信号发生。</p>
<p>sigsuspend函数的执行过程如下:<br>(1)设置新的mask去阻塞当前进程<br>(2)收到信号，调用信号的处理函数<br>(3)将mask设置为原先的掩码<br>(4)sigsuspend函数返回</p>
<p>可以看出，sigsuspend函数是等待一个信号发生，当等待的信号发生时，执行完信号处理函数后就会返回。它是一个原子操作。</p>
<p>保护临界区的中断:<br>(1)首先用sigprocmask去阻塞信号<br>(2)执行后关键代码后,用sigsuspend去捕获信号<br>(3)然后sigprocmask去除阻塞<br>这样信号就不会丢失了，而且不会中断临界区。</p>
<p>上面的程序是用pause去保护临界区，首先用sigprocmask去阻塞SIGINT信号，执行临界区代码，然后解除阻塞。最后调用pause()函数等待信号的发生。但此时会产生一个问题，如果信号在解除阻塞与pause之间发生的话，信号就可能丢失。这将是一个不可靠的信号机制。<br>因此，采用sigsuspend可以避免上述情况发生。</p>
<p>sigsuspend函数的用法：<br>sigsuspend函数是等待的信号发生时才会返回。<br>sigsuspend函数遇到结束时不会返回，这一点很重要。</p>
<p>示例:</p>
<p>下面的例子能够处理信号SIGUSR1,SIGUSR2,SIGSEGV,其它的信号被屏蔽，该程序输出对应的信号，然后继续等待其它信号的出现。</p>
<pre><code>void myhandler(int signo);
int main(){
    struct sigaction action;
    sigset_t sigmask;
    sigemptyset(&amp;sigmask);
    sigaddset(&amp;sigmask,SIGUSR1);
    sigaddset(&amp;sigmask,SIGUSR2);
    sigaddset(&amp;sigmask,SIGSEGV);
    action.sa_handler=myhandler;
    action.sa_mask=sigmask;
    sigaction(SIGUSR1,&amp;action,NULL);
    sigaction(SIGUSR2,&amp;action,NULL);
    sigaction(SIGSEGV,&amp;action,NULL);
    sigfillset(&amp;sigmask);
    sigdelset(&amp;sigmask,SIGUSR1);
    sigdelset(&amp;sigmask,SIGUSR2);
    sigdelset(&amp;sigmask,SIGSEGV);
    while(1){
        sigsuspend(&amp;sigmask);//不断的等待信号到来
    }
    return 0;
}
    
void myhandler(int signo){
    switch(signo){
        case SIGUSR1:
            printf(&quot;received sigusr1 signal./n&quot;);
        break ;
        case SIGUSR2:
            printf(&quot;received sigusr2 signal./n&quot;);
        break;
        case SIGSEGV:
            printf(&quot;received sigsegv signal/n&quot;);
        break;
    }
}
</code></pre>
<p>程序运行结果:</p>
<pre><code>received sigusr1 signal
received sigusr2 signal
received sigsegv signal
received sigusr1 signal
已终止
</code></pre>
<p>另一个终端用于发送信号:<br>先得到当前进程的pid, ps aux|grep 程序名</p>
<pre><code>kill -SIGUSR1 4901
kill -SIGUSR2 4901
kill -SIGSEGV 4901
kill -SIGTERM 4901
kill -SIGUSR1  4901
</code></pre>
<p>解释:<br>第一行发送SIGUSR1，则调用信号处理函数，打印出结果。<br>第二，第三行分别打印对应的结果。<br>第四行发送一个默认处理为终止进程的信号。<br>但此时，但不会终止程序，由于sigsuspend遇到终止进程信号并不会返回，此时并不会打印出”已终止”，这个信号被阻塞了。当再次发送SIGURS1信号时，进程的信号阻塞恢复成默认的值，因此，此时将会解除阻塞SIGTERM信号，所以进程被终止。</p>
<h1 id="第五部分-信号的继承与执行"><a href="#第五部分-信号的继承与执行" class="headerlink" title="第五部分: 信号的继承与执行"></a>第五部分: 信号的继承与执行</h1><p>当使用fork()函数时，子进程会继承父进程完全相同的信号语义，这也是有道理的，因为父子进程共享一个地址空间，所以父进程的信号处理程序也存在于子进程中。</p>
<p>示例: 子进程继承父进程的信号处理函数</p>
<pre><code>void myhandler(int signo,siginfo_t *si,void *vcontext);
int main(){
    union sigval val;
    struct sigaction oldact,newact;
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO|SA_RESETHAND;//表示采用sa_sigaction指示的函数以及执行完处理函数后恢复默认操作
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    
    if(fork()==0){
        val.sival_int=10;
        printf(&quot;子进程/n&quot;);
        sigqueue(getpid(),SIGUSR1,val);
    }
    else {
        val.sival_int=20;
        printf(&quot;父进程/n&quot;);
        sigqueue(getpid(),SIGUSR1,val);
    }
}

void myhandler(int signo,siginfo_t *si,void *vcontext){
    printf(&quot;信号处理/n&quot;);
    printf(&quot;%d/n&quot;,(si-&gt;si_int));
}
</code></pre>
<p>输出的结果为:</p>
<pre><code>子进程
信号处理
10
父进程
信号处理
20
</code></pre>
<p>可以看出来，子进程继承了父进程的信号处理函数。</p>
<h1 id="第六部分-实时信号中锁的研究"><a href="#第六部分-实时信号中锁的研究" class="headerlink" title="第六部分: 实时信号中锁的研究"></a>第六部分: 实时信号中锁的研究</h1><h2 id="1-信号处理函数与主函数之间的死锁"><a href="#1-信号处理函数与主函数之间的死锁" class="headerlink" title="1. 信号处理函数与主函数之间的死锁"></a>1. 信号处理函数与主函数之间的死锁</h2><p>当主函数访问临界资源时，通常需要加锁，如果主函数在访问临界区时，给临界资源上锁，此时发生了一个信号，那么转入信号处理函数，如果此时信号处理函数也对临界资源进行访问，那么信号处理函数也会加锁，由于主程序持有锁，信号处理程序等待主程序释放锁。又因为信号处理函数已经抢占了主函数，因此，主函数在信号处理函数结束之前不能运行。因此，必然造成死锁。</p>
<p>示例1: 主函数与信号处理函数之间的死锁</p>
<pre><code>int value=0;
sem_t sem_lock;//定义信号量
void myhandler(int signo,siginfo_t *si,void *vcontext);//进程处理函数声明
int main(){
    union sigval val;
    val.sival_int=1;
    struct sigaction oldact,newact;
    int res;
    res=sem_init(&amp;sem_lock,0,1);
    if(res!=0){
        perror(&quot;信号量初始化失败&quot;);
    }
    
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    sem_wait(&amp;sem_lock);
    printf(&quot;xxxx/n&quot;);
    value=1;
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);//sigqueue发送带参数的信号
    sem_post(&amp;sem_lock);
    sleep(10);
    exit(0);
}

void myhandler(int signo,siginfo_t *si,void *vcontext){
    sem_wait(&amp;sem_lock);
    value=0;
    sem_post(&amp;sem_lock);
}
</code></pre>
<p>此程序将一直阻塞在信号处理函数的sem_wait函数处。</p>
<h2 id="2-利用测试锁解决死锁"><a href="#2-利用测试锁解决死锁" class="headerlink" title="2. 利用测试锁解决死锁"></a>2. 利用测试锁解决死锁</h2><p>sem_trywait(&amp;sem_lock);是非阻塞的sem_wait,如果加锁失败或者是超时，则返回－1。<br>示例2: 用sem_trywait来解决死锁</p>
<pre><code>int value=0;
sem_t sem_lock;//定义信号量
void myhandler(int signo,siginfo_t *si,void *vcontext);//进程处理函数声明
int main(){
    union sigval val;
    val.sival_int=1;
    struct sigaction oldact,newact;
    int res;
    res=sem_init(&amp;sem_lock,0,1);
    if(res!=0){
        perror(&quot;信号量初始化失败&quot;);
    }
    
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    sem_wait(&amp;sem_lock);
    printf(&quot;xxxx/n&quot;);
    value=1;
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);//sigqueue发送带参数的信号
    sem_post(&amp;sem_lock);
    sleep(10);
    sigqueue(getpid(),SIGUSR1,val);
    exit(0);
}

void myhandler(int signo,siginfo_t *si,void *vcontext){
    if(sem_trywait(&amp;sem_lock)==0){
        value=0;
        sem_post(&amp;sem_lock);
    }
}
</code></pre>
<p>第一次发送sigqueue时，由于主函数持有锁，因此，sem_trywait返回－1，当第二次发送sigqueue时，主函数已经释放锁，此时就可以在信号处理函数中对临界资源加锁了。<br>但这种方法明显丢失了一个信号，不是很好的解决方法。</p>
<h2 id="3-利用双线程来解决主函数与信号处理函数死锁"><a href="#3-利用双线程来解决主函数与信号处理函数死锁" class="headerlink" title="3. 利用双线程来解决主函数与信号处理函数死锁"></a>3. 利用双线程来解决主函数与信号处理函数死锁</h2><p>我们知道，当进程收到一个信号时，会选择其中的某个线程进行处理，前提是这个线程没有屏蔽此信号。因此，可以在主线程中屏蔽信号，另选一个线程去处理这个信号。由于主线程与另外一个线程是平行执行的，因此，等待主线程执行完临界区时，释放锁，这个线程去执行信号处理函数，直到执行完毕释放临界资源。</p>
<p>这里用到一个线程的信号处理函数: pthread_sigmask</p>
<pre><code>int pthread_sigmask(int how,const sigset_t *set,sigset_t *oldset);
</code></pre>
<p>这个函数与sigprocmask很相似。<br>how的取值:<br>SIG_BLOCK 将信号集加入到线程的阻塞集中去<br>SIG_UNBLOCK 将信号集从阻塞集中删除<br>SIG_SETMASK 将当前集合设置为线程的阻塞集</p>
<p>示例: 利用双线程来解决主函数与信号处理函数之间的死锁</p>
<pre><code>void*thread_function(void *arg);//线程处理函数
void myhandler(int signo,siginfo_t *si,void *vcontext);//信号处理函数
int value;
sem_t semlock;
int main(){
    int res;
    pthread_t mythread;
    void *thread_result;
    res=pthread_create(&amp;mythread,NULL,thread_function,NULL);//创建一个子线程
    if(res!=0){
        perror(&quot;线程创建失败&quot;);
    }

    //在主线程中将信号屏蔽
    sigset_t empty;
    sigemptyset(&amp;empty);
    sigaddset(&amp;empty,SIGUSR1);
    pthread_sigmask(SIG_BLOCK,&amp;empty,NULL);

    //主线程中对临界资源的访问
    if(sem_init(&amp;semlock,0,1)!=0){
        perror(&quot;信号量创建失败&quot;);
    }
    sem_wait(&amp;semlock);
    printf(&quot;主线程已经执行/n&quot;);
    value=1;
    sleep(10);
    sem_post(&amp;semlock);
    res=pthread_join(mythread,&amp;thread_result);//等待子线程退出
    exit(EXIT_SUCCESS);
}

void *thread_function(void *arg){
    struct sigaction oldact,newact;
    newact.sa_sigaction=myhandler;
    newact.sa_flags=SA_SIGINFO;
    //注册信号处理函数
    sigaction(SIGUSR1,&amp;newact,&amp;oldact);
    union sigval val;
    val.sival_int=1;
    printf(&quot;子线程睡眠3秒/n&quot;);
    sleep(3);
    sigqueue(getpid(),SIGUSR1,val);
    pthread_exit(0);//线程结束
}

void myhandler(int signo,siginfo_t *si,void *vcontext){
    sem_wait(&amp;semlock);
    value=0;
    printf(&quot;信号处理完毕/n&quot;);
    sem_post(&amp;semlock);
}
</code></pre>
<p>运行结果如下:</p>
<pre><code>主线程已经执行
子线程睡眠3秒
信号处理完毕
</code></pre>
<p>解释一下:<br>在主线线程中阻塞了SIGUSR1信号,首先让子线程睡眠3秒，目的让主线程先运行，然后当主线程访问临界资源时，让线程sleep(10),在这期间，子线程发送信号，此时子线程会去处理信号，而主线程依旧平行的运行，子线程被阻止信号处理函数的sem_wait处，等待主线程10后，信号处理函数得到锁，然后进行临界资源的访问。这就解决了主函数与信号处理函数之间的死锁问题。</p>
<p>扩展: 如果有多个信号到达时，还可以用多线程来处理多个信号，从而达到并行的目的，这个很好实现的，可以尝试一下。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux网络编程: Socket基础</title>
    <url>/2020/10/30/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Socket%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="套接字（socket）基础"><a href="#套接字（socket）基础" class="headerlink" title="套接字（socket）基础"></a>套接字（socket）基础</h1><p>套接字是网络编程中，应用层和传输层之间的数据结构，其作用如下:<br>应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字(Socket)的接口，以区分不同应用程序进程间的网络通信和连接。</p>
<h1 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h1><p>通用套接字地址的结构体sockaddr定义如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411648.png" alt="1"><br>在以太网中，不直接使用sockaddr结构体，而使用sockaddr_in,其定义如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411109.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411045.png" alt="3"></p>
<p>通用结构体sockaddr和以太网的sockaddr_in结构体，有点像C++中的父类和子类的关系，sockaddr_in是对sockaddr的细化，其存储结构大小相同，分布如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411360.png" alt="4"><br>由于大小相同，在设置socket地址时，一般先设置sockaddr_in结构体，然后强转为sockaddr类型</p>
<h1 id="套接字地址结构在用户层和内核层的交互"><a href="#套接字地址结构在用户层和内核层的交互" class="headerlink" title="套接字地址结构在用户层和内核层的交互"></a>套接字地址结构在用户层和内核层的交互</h1><p>sockaddr的使用，以socket流程中的bind()函数为例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411733.png" alt="5"><br>bind函数需要传入sockaddr结构体的指针，和sockaddr结构体的长度</p>
<h2 id="向内核传入数据"><a href="#向内核传入数据" class="headerlink" title="向内核传入数据"></a>向内核传入数据</h2><p>向内核传入数据的socket函数有：bind,send<br>传入过程如下：</p>
<ul>
<li>sockaddr结构体的长度，以传值方式传入内核</li>
<li>内核通过sockaddr结构体的指针以及结构体长度，以内存复制的方式，从用户层拷贝sockaddr结构体到内核层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411951.png" alt="6"></p>
<h2 id="从内核获取数据"><a href="#从内核获取数据" class="headerlink" title="从内核获取数据"></a>从内核获取数据</h2><p>从内核得到数据的socket函数有：accept,recv</p>
<ul>
<li>sockaddr结构体的长度，以传值方式传入内核</li>
<li>内核通过sockaddr结构体的指针以及结构体长度，以内存复制的方式，从内核层拷贝sockaddr结构体到用户层。</li>
<li>内核返回内核的结构体的长度<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412551.png" alt="7"></li>
</ul>
<h1 id="Socket编程流程"><a href="#Socket编程流程" class="headerlink" title="Socket编程流程"></a>Socket编程流程</h1><h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>TCP编程主要为C&#x2F;S模式，即服务器和客户端编程，我们讲socket编程，要区分是服务器端的流程还是客户端的流程。</p>
<ul>
<li>服务器端：创建服务-等待客户端连接-收到连接请求-处理</li>
<li>客户端：发起对服务器的连接请求-根据服务器的响应做处理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412551.png"></p>
<p>服务端各函数含义:</p>
<ul>
<li>socket：套接字初始化</li>
<li>bind：绑定套接字和端口</li>
<li>listen：配置服务器的请求队列，监测连接请求</li>
<li>accept：接受客户端连接</li>
<li>read&#x2F;write：数据的接收、发送</li>
<li>close：断开连接，释放套接字</li>
</ul>
<p>客户端函数：</p>
<ul>
<li>客户端套接字不需要绑定端口和监听，直接connect发起连接请求，其他函数和服务端一致。</li>
</ul>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>socket函数用于创建socket套接字的文件描述符，</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412223.png" alt="9"></p>
<p>有三个入参：</p>
<ul>
<li>domain：域，区分本地，IPV4 Internet，IPV6 Internet等。有的以PF开头，有的以AF开头，这两者值一样。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412180.png" alt="10"></p>
<ul>
<li>type：通信类型，如流式（TCP）,数据报式（UDP）等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412975.png" alt="11"></p>
<ul>
<li>protocal：协议类型，指定通信类型中的子类型，一般为0</li>
</ul>
<p>socket套接字初始化的一个例子：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412776.png" alt="12"></p>
<h2 id="socket函数在应用层和内核层的交互"><a href="#socket函数在应用层和内核层的交互" class="headerlink" title="socket函数在应用层和内核层的交互"></a>socket函数在应用层和内核层的交互</h2><p>用户调用的socket函数，会调用内核的sys_socket函数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051415958.png" alt="2"></p>
<p>sys_socket做两件事：</p>
<ul>
<li><p>sock_create生成内核的socket结构，和应用层的结构不同，如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413920.png" alt="13"></p>
</li>
<li><p>sock_map_fd将内核socket结构绑定文件描述符fd,用户层可通过fd访问内核socket结构</p>
</li>
</ul>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>服务端用socket函数建立套接字文件描述符后，需要绑定地址和端口到该文件描述符，才能接受客户端请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413732.png" alt="14"></p>
<ul>
<li>sockfd：socket函数创建的文件描述符</li>
<li>sockaddr结构的指针：指向的sockaddr结构，包含ip和port等信息</li>
<li>addrlen：即sizeof(struct sockaddr)</li>
</ul>
<p>bind函数绑定UNIX族的套接字：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413483.png" alt="15"></p>
<p>bind函数绑定AF_INET族的套接字:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413289.png" alt="16"></p>
<h2 id="bind函数在应用层和内核层的交互"><a href="#bind函数在应用层和内核层的交互" class="headerlink" title="bind函数在应用层和内核层的交互"></a>bind函数在应用层和内核层的交互</h2><p>以AF_INET族的套接字绑定为例，不同协议族实际上是调用内核不同的绑定函数<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051418474.png" alt="image-20221205141814380"></p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>listen函数用于初始化服务器的可连接队列，即服务器处理客户的请求，不是并行处理，而是异步的串行处理。服务器建立可连接队列，将当前不能同步处理的新请求放到队列中，等队列前面的请求处理完了，才异步处理这个请求。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051414568.png" alt="18"></p>
<ul>
<li>backlog是服务器可连接队列的最大长度</li>
<li>当前队列没满，即当前队列的请求没超过backlog值，才可以调用accept</li>
<li>listen函数只针对SOCK_STREAM和SOCK_SEQPACKET才能调用，因为TCP请求才需要建立连接。对于SOCK_DGRAM不支持listen，因为UDP是无连接的。</li>
</ul>
<p>TCP连接中，SOCK_STREAM类型的套接字，调用listen的示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419762.png" alt="image-20221205141912644"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419995.png" alt="image-20221205141921877"></p>
<h2 id="listen函数在应用层和内核层的交互"><a href="#listen函数在应用层和内核层的交互" class="headerlink" title="listen函数在应用层和内核层的交互"></a>listen函数在应用层和内核层的交互</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419209.png" alt="image-20221205141934130"></p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>服务端用listen建立连接队列后，客户端以connect发来一个请求，会加入到服务端连接队列的队尾，当这个请求到达队头，会调用accept真正处理该请求。<br>accept会创建一个新的套接字文件描述符，用来描述客户端的连接，这个时候会有两个套接字描述符并存：</p>
<ul>
<li>socket函数创建的老的sockfd，表示正在监听的ip和端口</li>
<li>accept函数创建的新的clientfd，表示当前的客户端连接，后续的客户端的收发和客户端关闭，即send，recv，close函数，都使用clientfd</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420456.png" alt="image-20221205142030402"></p>
<p>流式连接的accept示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420563.png" alt="image-20221205142038423"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420232.png" alt="image-20221205142048069"></p>
<h2 id="accept函数在应用层和内核层的交互"><a href="#accept函数在应用层和内核层的交互" class="headerlink" title="accept函数在应用层和内核层的交互"></a>accept函数在应用层和内核层的交互</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051421941.png" alt="image-20221205142100841"></p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>connect函数是客户端调用的函数，在客户端调用socket函数创建套接字文件sockfd后，可调用connect函数向服务端发起连接请求，请求的ip和端口信息包含在sockaddr结构体内。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051422137.png" alt="image-20221205142256082"></p>
<p>客户端的socket connect示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051422137.png"></p>
<h2 id="connect函数在应用层和内核层的交互"><a href="#connect函数在应用层和内核层的交互" class="headerlink" title="connect函数在应用层和内核层的交互"></a>connect函数在应用层和内核层的交互</h2><p>根据数据流式或数据报式的请求，具体调用inet_stream_connect或inet_dgram_connect<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423142.png" alt="image-20221205142315046"></p>
<h2 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h2><p>服务端和客户端真正建立连接后（socket通信逻辑连接，不是TCP&#x2F;UDP的面向连接&#x2F;无连接的传输层连接），即客户端发起connect，服务端accept完成，双方就可以相互read&#x2F;write，读写对方的数据，通过sockfd文件描述符，就像读写本地文件一样。</p>
<ul>
<li>read：从套接字文件读取数据，写入本地缓冲区，返回非空的有效数据大小<br> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423066.png" alt="image-20221205142328017"></li>
<li>write：向套接字文件写入数据，将本地缓冲区数据写入socket函数创建的socket文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423066.png"></li>
</ul>
<h2 id="close和shutdown函数"><a href="#close和shutdown函数" class="headerlink" title="close和shutdown函数"></a>close和shutdown函数</h2><ul>
<li>close：关闭socket连接，释放内核的套接字资源，不能通过套接字文件来读写操作</li>
<li>shutdown：支持读写的单向关闭，即关闭套接字文件的读、写、或者读写能力（等同于close）</li>
</ul>
<h1 id="Socket客户端和服务端交互的例程"><a href="#Socket客户端和服务端交互的例程" class="headerlink" title="Socket客户端和服务端交互的例程"></a>Socket客户端和服务端交互的例程</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>客户端从标准输入读取用户输入的字符串，发送给服务端，服务端读取数据，回写这些数据到客户端，客户端收到数据后输出到标准输出。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423842.png" alt="image-20221205142345794"></p>
<p>客户端和服务端可以在同一台机器部署，访问回环地址127.0.0.1即可，注意服务端的监听端口不能和其他进程的端口冲突。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>服务端代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
//#define PORT 8088						/*侦听端口地址*/
#define BACKLOG 2						/*侦听队列长度*/

int main(int argc, char *argv[])
{
	int ss,sc;		/*ss为服务器的socket描述符，sc为客户端的socket描述符*/
	struct sockaddr_in server_addr;	/*服务器地址结构*/
	struct sockaddr_in client_addr;	/*客户端地址结构*/
	int err;							/*返回值*/
	pid_t pid;							/*分叉的进行ID*/

	/*建立一个流式套接字*/
	ss = socket(AF_INET, SOCK_STREAM, 0);
	if(ss &lt; 0){							/*出错*/
		printf(&quot;socket error\n&quot;);
		return -1;	
	}
	
	/*设置服务器地址*/
	bzero(&amp;server_addr, sizeof(server_addr));			/*清零*/
	server_addr.sin_family = AF_INET;					/*协议族*/
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);	/*本地地址*/
	//server_addr.sin_port = htons(PORT);
	server_addr.sin_port = htons(atoi(argv[1]));		/*服务器端口*/
	
	/*绑定地址结构到套接字描述符*/
	err = bind(ss, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));
	if(err &lt; 0){/*出错*/
		printf(&quot;bind error\n&quot;);
		return -1;	
	}
	
	/*设置侦听*/
	err = listen(ss, BACKLOG);
	if(err &lt; 0){										/*出错*/
		printf(&quot;listen error\n&quot;);
		return -1;	
	}
	
		/*主循环过程*/
	for(;;)	{
		socklen_t addrlen = sizeof(struct sockaddr);
		/*接受客户端连接*/
		sc = accept(ss, (struct sockaddr*)&amp;client_addr, &amp;addrlen); 
		if(sc &lt; 0){							/*出错*/
			continue;						/*结束本次循环*/
		}	
		
		/*建立一个新的进程处理到来的连接*/
		pid = fork();						/*分叉进程*/
		if( pid == 0 ){						/*子进程中*/
			process_conn_server(sc);		/*处理连接*/
			close(ss);						/*在子进程中关闭服务器的侦听*/
		}else{
			close(sc);						/*在父进程中关闭客户端的连接*/
		}
	}
}
</code></pre>
<p>服务端注意几点:</p>
<ul>
<li>accept后处理连接的过程，是在子进程中处理的，使用fork创建子进程用于连接处理。根据fork返回的pid是0还是其他，判断当前调度到子进程还是父进程，从全局上来讲，这个<code>if-else</code>的两种流程分别在父进程和子进程中指向。</li>
<li>服务端有两个套接字：侦听套接字和连接套接字。处理连接传入的是连接套接字。</li>
<li>在父进程（侦听进程）中，要关闭连接套接字；在子进程（连接处理进程）中，要关闭侦听套接字。这是为了避免子父进程相互影响。</li>
<li>对于多进程，一个进程的套接字关闭不会释放该套接字内存，只有所有进程都关闭了这个套接字，内核才会 释放该套接字，所有可以放心在侦听进程和连接处理进程中，关闭对方的套接字。</li>
</ul>
<p>客户端代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
//#define PORT 8088								/*侦听端口地址*/

int main(int argc, char *argv[])
{
	int s;										/*s为socket描述符*/
	struct sockaddr_in server_addr;			/*服务器地址结构*/
	
	s = socket(AF_INET, SOCK_STREAM, 0); 		/*建立一个流式套接字 */
	if(s &lt; 0){									/*出错*/
		printf(&quot;socket error\n&quot;);
		return -1;
	}	
	
	/*设置服务器地址*/
	bzero(&amp;server_addr, sizeof(server_addr));	/*清零*/
	server_addr.sin_family = AF_INET;					/*协议族*/
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);	/*本地地址*/
	server_addr.sin_port = htons(atoi(argv[2]));		/*服务器端口*/
	
	/*将用户输入的字符串类型的IP地址转为整型*/
	inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);	
	/*连接服务器*/
	connect(s, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr));
	process_conn_client(s);						/*客户端处理过程*/
	close(s);									/*关闭连接*/
	return 0;
}
</code></pre>
<p>建立连接后的读写交互代码，包含服务端的调用和客户端的调用：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
/*客户端的处理过程*/
void process_conn_client(int s)					/* 传入的是客户端调用socket时创建的s */
{
	ssize_t size = 0;
	char buffer[1024];							/*数据的缓冲区*/
	
	for(;;){									/*循环处理过程*/
		/*从标准输入中读取数据放到缓冲区buffer中,标准输入：0，标准输出：1，标准错误：2*/
		size = read(0, buffer, 1024);
		if(size &gt; 0){							/*读到数据*/
			write(s, buffer, size);				/*发送给服务器*/
			/*客户端阻塞，等待服务器有数据可读*/
			size = read(s, buffer, 1024);		/*从服务器读取数据*/
			write(1, buffer, size);				/*写到标准输出*/
		}
	}	
}
/*服务器对客户端的处理*/
void process_conn_server(int s) 				/* 传入的是服务端调用accept时创建的sc */
{
	ssize_t size = 0;
	char buffer[1024];							/*数据的缓冲区*/
	
	for(;;){									/*循环处理过程*/		
		size = read(s, buffer, 1024);			/*从套接字中读取数据放到缓冲区buffer中*/
		if(size == 0){							/*没有数据*/
			return;	
		}
		
		/*构建响应数据*/
		//sprintf(buffer, &quot;server receive %d bytes from client\n&quot;, size);
		//write(s, buffer, strlen(buffer));
		write(s, buffer, size);					/*发回给客户端*/
	}	
}
</code></pre>
<p>Makefile编译脚本:</p>
<pre><code>all:client server					#all规则，它依赖于client和server规则

client:tcp_process.o tcp_client.o	#client规则，生成客户端可执行程序
	gcc -o client tcp_process.o tcp_client.o
server:tcp_process.o tcp_server.o	#server规则，生成服务器端可执行程序
	gcc -o server tcp_process.o tcp_server.o	
tcp_process.o:						#tcp_process.o规则，生成tcp_process.o
	gcc -c tcp_process.c -o tcp_process.o
clean:								#清理规则，删除client、server和中间文件
	rm -f client server *.o
</code></pre>
<h2 id="部署和运行"><a href="#部署和运行" class="headerlink" title="部署和运行"></a>部署和运行</h2><p>后台运行server,指定监听端口:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424795.png" alt="image-20221205142401747"><br>运行client，指定服务端的ip, port：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424795.png"><br>客户端每输入一个字符串，服务端返回完全相同的字符串，通信正常<br>如果运行服务端时，有bind error，可能是端口被占用，<code>netstat</code>找到占用端口的PID，kill之后再运行server<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424796.png" alt="image-20221205142416741"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux进程的内存分布和进程IPC</title>
    <url>/2020/11/15/%E6%B5%85%E8%B0%88Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9B%E7%A8%8BIPC/</url>
    <content><![CDATA[<h1 id="Linux虚拟内存空间分布"><a href="#Linux虚拟内存空间分布" class="headerlink" title="Linux虚拟内存空间分布"></a>Linux虚拟内存空间分布</h1><p>（1）虚拟内存空间与物理内存：<br>带MMU控制器的CPU支持将物理内存以分页的方式，细粒度的动态分配给进程，使每个进程只看得到这个虚拟的内存空间，每个进程认为自己可以访问整个内存空间。进程根本不知道其访问的某个内存页的实际物理地址，也许在SDRAM上，或者硬盘的交换分区上。</p>
<p>进程的虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每个进程都拥有一套属于它自己的页表。</p>
<p>（2）下面讨论用户进程能看到什么样的虚拟内存空间：</p>
<p>以32位系统为例，CPU可寻址4GB的内存空间。此时虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分：</p>
<ul>
<li>将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。</li>
<li>将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间</li>
</ul>
<p>因为每个进程可以通过<strong>系统调用</strong>进入内核，因此，Linux内核由系统内的所有进程共享。从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051156842.png" alt="image-20221205115648795"></p>
<p>注意：</p>
<ul>
<li>内核可见的内存空间只有全局的1GB; 用户进程可见的内存空间包括该进程独有的3GB空间，和全局内核的1GB;</li>
<li>用户进程虽然可见内核空间的1GB，但不可直接访问，要通过系统调用（或中断等方式），涉及上下文切换；</li>
<li>当进程访问内核空间时，称为“进入内核态”，返回时称为“进入用户态”；</li>
<li>内核空间分布在虚拟内存空间的高地址，用户空间在低地址</li>
</ul>
<p>（3）用户进程的内部空间详解</p>
<p>编译好的程序都分为几个段(section)，在程序运行过程中的临时变量还产生堆栈，程序手动分配的内存使用堆, 还有命令行参数和环境变量等配置信息，这些东西都属于进程空间的数据。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051159094.png" alt="image-20221205115908003"></p>
<p>详解如下：<br>代码段(Text):存放程序指令，一些只读数据(.rodata)也可归为此类<br>数据段(Data):存放初始化过的全局数据<br>BSS段:存放未初始化(默认为0)的全局数据<br>栈 (Stack): 用于控制函数调用和返回过程中的临时变量，存储函数内的临时变量; 存储函数的返回指针，<br>堆 (Heap):存储动态内存分配, 需要程序员手工分配, 手工释放。注意与数据结构中的堆(优先队列)是不同，分配方式类似于链表。</p>
<h1 id="Linux进程间通信-IPC"><a href="#Linux进程间通信-IPC" class="headerlink" title="Linux进程间通信(IPC)"></a>Linux进程间通信(IPC)</h1><p>进程本身是为了隔离程序的资源，但不同程序间可能有数据通信或调用关系，因此需要进程通信机制。</p>
<p>进程通信最主要的几种方式有：管道(pipe) , 共享内存(shared memory), 消息队列(message queue), socket等。为了进程间的时序同步和资源处理，信号量(semaphore)通常配合使用。</p>
<p>本节重点讲管道和共享内存，关于Linux IPC 的全面内容，参考：<br><a href="http://www.cs.fsu.edu/~zwang/files/cop4610/Fall2016/linux-ipc.pdf">An introduction to Linux IPC</a><br><a href="https://opensource.com/sites/default/files/gated-content/inter-process_communication_in_linux.pdf">inter-process_communication_in_linux</a></p>
<h2 id="进程通信的基本思路"><a href="#进程通信的基本思路" class="headerlink" title="进程通信的基本思路"></a>进程通信的基本思路</h2><p>根据上节的内存空间分布，所有进程共享同一个内核空间，最简单的进程通信就是通过 进程A-&gt;内核-&gt;进程B：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157104.png" alt="1637063328269_12"></p>
<p>以上虽然可以实现，但有两次拷贝以及上下文切换，其总体思路是管道和共享内存方式的基础。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道的实质就是一个内核缓冲区；<br>管道对于管道两端的进程而言就是一个文件，与普通文件的区别是管道只存在于内存中；<br>进程通过读写管道文件，传递数据；</p>
<p>管道依据是否有名字分为匿名管道和命名管道，其功能有以下区别：<br>匿名管道(通常管道就是指匿名管道)：</p>
<ul>
<li>半双工的，即管道设置好后，数据只能从进程A到进程B；如果还需要从B到A,需要创建另外的管道</li>
<li>只能用于父子进程或兄弟进程之间的通信</li>
</ul>
<p>命名管道(FIFO)：</p>
<ul>
<li>可用于无关联进程的通信，其基本原理和匿名管道一样，本节不详细描述</li>
</ul>
<p>管道内部提供了同步机制<br>临界资源： 大家都能访问到的共享资源<br>临界区： 对临界资源进行操作的代码<br>同步： 临界资源访问的可控时序性（一个操作完另一个才可以操作）<br>互斥： 对临界资源同一时间的唯一访问性（保护临界资源安全）</p>
<h3 id="匿名-管道使用三部曲"><a href="#匿名-管道使用三部曲" class="headerlink" title="(匿名)管道使用三部曲"></a>(匿名)管道使用三部曲</h3><p>1.创建本进程的管道<br>使用pipe函数创建管道文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157310.png" alt="image-20221205115729244"></p>
<p>2.fork子进程，共享管道<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157031.png" alt="image-20221205115734973"></p>
<p>3.设置管道为单向<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157508.png" alt="image-20221205115744442"></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>Linux中每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。</p>
<p>两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。</p>
<p>共享内存的通信原理：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051157936.png" alt="image-20221205115751869"></p>
<p>共享内存的关键是一份内存资源被两个进程占用，因此需要信号量等同步机制，实现进程同步与资源互斥。</p>
<p>这里简单说明我对信号量的理解：</p>
<ul>
<li>信号量的作用是“流程同步”，这个流程可以是两个进程访问共享内存，也可以是同一进程内的多个线程访问共享数据；</li>
<li>注意，信号量并不一定用于共享资源的情景，可能只是简单的主线程等待工作线程这种情况。这是其和互斥锁的关键区别；</li>
<li>信号量如果用于共享资源，其本质是“引用计数”，即共享资源是否可用的计数，计数为0表示无资源可用。各进程如果获得资源计数-1，释放资源计数+1。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/cl_linux/article/details/80328608">Linux进程地址空间和进程的内存分布</a><br><a href="http://www.cs.fsu.edu/~zwang/files/cop4610/Fall2016/linux-ipc.pdf">An introduction to Linux IPC</a><br><a href="https://opensource.com/sites/default/files/gated-content/inter-process_communication_in_linux.pdf">inter-process_communication_in_linux</a><br><a href="https://www.cnblogs.com/huansky/p/13170125.html#:~:text=Linux%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B8%BB%E8%A6%81%E6%9C%89%EF%BC%9A%E7%AE%A1%E9%81%93%20%28pipe%29,%28%E5%8C%85%E6%8B%AC%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%29%E3%80%81%E4%BF%A1%E5%8F%B7%20%28signal%29%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%28queue%29%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%82">Linux 进程间通信（IPC）总结</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈信号完整性和ReDriver</title>
    <url>/2023/04/10/%E6%B5%85%E8%B0%88%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8CReDriver/</url>
    <content><![CDATA[<h2 id="信号完整性"><a href="#信号完整性" class="headerlink" title="信号完整性"></a>信号完整性</h2><p>在讨论ReDriver之前，先说明信号完整性（Signal Integrity, SI）的相关背景。<br>电子信号在传输过程中(无线或有线)都会受到环境噪声干扰，信号功率也会随着传输距离衰减(signal attenuation)。<br>通信系统中用信噪比表达的信号的好坏:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信噪比(dB)=10*log（信号/噪音）</span><br></pre></td></tr></table></figure>

<ul>
<li>当信噪比大于设备接收灵敏度时，信号能被正常接收和解析（成逻辑0&#x2F;1）</li>
<li>当信噪比小于设备接收灵敏度时，信号被错误解析（错误的逻辑0&#x2F;1）或者是根本解析不出信号(噪声完全淹没信号，接收端恒为0或1，没有信号变化)。</li>
</ul>
<p>信号完整性（Signal Integrity, SI）一般指PCB电路中的电压信号的信噪比好坏。如果电路中信号能够以要求的时序、持续时间和电压幅度到达接收器，则该电路具有较好的信号完整性。反之当信号不能正常响应时，就出现了信号完整性问题。一般通过眼图观测信号完整性好坏。</p>
<p>信号完整性在高速电路更容易出问题，表现为信号有传输延迟和时序错误、电路串扰（电容性、电感性串扰）等。</p>
<p>高速信号的PCB电路设计和信号完整性密切相关，例如下图是PCB使用FR4材料和Megtron6材料，信号-频率函数显示衰减度不同。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101118830.png" alt="Attenuation versus Frequency as a function of PCB material"></p>
<h2 id="ReDriver"><a href="#ReDriver" class="headerlink" title="ReDriver"></a>ReDriver</h2><p>Redriver能减弱信号在远距离、高噪声环境的传输中的信号完整性问题对接收端的影响。</p>
<p>Redriver类似通信系统中的基站，其接收传输线路中的信号，重新生成原始信号，再转发给远端设备；其输出信号基本和原始信号完全一致以保证接收端能正常解析信号。</p>
<p>(1)PCIe redriver</p>
<p>以典型的高速信号PCIe接口为例，其使用Redriver和Retimer提高信号完整性，参考：<a href="https://www.allaboutcircuits.com/industry-articles/choosing-the-right-redriver-or-retimer-device-to-extend-pcie-protocol-signal-range/">Choosing the Right Redriver or Retimer Device to Extend PCIe Protocol Signal Range</a></p>
<p>其RX, EQ接收PCIe信号源的TX, EQ信号，redrive生成原始信号后再从TX, EQ发送给接收端。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101126665.png" alt="Single lane redriver block diagram"></p>
<p>(2)USB redriver</p>
<p>以多层子设备结构的USB接口为例，其使用Redriver提高子USB host的驱动能力，参考 <a href="https://www.diodes.com/zh/products/connectivity-and-timing/redrivers-repeaters/">信号完整性 - ReDriver&#x2F; 信号中继器 &#x2F; 调节器</a></p>
<p><img src="https://www.diodes.com/assets/Uploads/redrivers-application2__ResizedImageWzYwMCwzNTFd.png" alt="redrivers application2"></p>
<p>(3)SD redriver</p>
<p>即使是较低速的SD接口(MB&#x2F;s级别)也有PCB设计和传输距离引起的信号完整性问题，也需要redriver解决。</p>
<p>如下SD redriver接收SD host的几个信号并重新生成：SD clock, SD cmd, SD data, Vdd power。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101130119.png" alt="image-20230410113046013"></p>
]]></content>
      <categories>
        <category>硬件基础</category>
      </categories>
      <tags>
        <tag>redriver</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈加密和编码：MD5</title>
    <url>/2022/01/25/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9AMD5/</url>
    <content><![CDATA[<h1 id="1-MD5简介"><a href="#1-MD5简介" class="headerlink" title="1.MD5简介"></a>1.MD5简介</h1><p>MD5的全称是Message-Digest Algorithm 5（<strong>信息摘要算法</strong>），经MD2、MD3和MD4发展而来。<br>所谓信息摘要，就是包含数据关键特性，能（唯一）识别原数据的关键信息。</p>
<p>MD5也称为<strong>单向散列算法</strong>，这是从其实现方式命名，因为：</p>
<ul>
<li>MD5能对大量数据，进行哈希映射，输出固定长度(128bit)的数据，输出数据也称为原数据的信息摘要。</li>
<li>不能由摘要推测出原数据，即MD5算法是单向的，当加密来用的话，只能加密不能解密。</li>
</ul>
<p>MD5的特点：</p>
<ul>
<li>固定长度：输入任意长度的信息，经过MD5处理，输出总是128位的信息。</li>
<li>唯一性：不同的输入得到的不同的结果；同样的输入一定得到相同的结果。</li>
<li>不可逆：根据128位的输出结果不可能反推出输入的信息。</li>
</ul>
<h1 id="2-MD5的应用"><a href="#2-MD5的应用" class="headerlink" title="2.MD5的应用"></a>2.MD5的应用</h1><p>1、防止被篡改：<br>1）比如A和B发送一个电子文档，发送前，A先自己计算出数据的MD5输出结果a。<br>然后在B收到电子文档后，B计算得到一个MD5的输出结果b。<br>如果a与b一样就代表传输中途数据未被篡改。<br>2）比如A提供文件下载，为了防止不法分子在文件中添加木马，伪装成A的文件。A可以在网站上公布由安装文件得到的MD5输出结果。<br>要下载文件的人只需要下载后，验证MD5是否和A一致，如果不一致，就是被其他人修改过。</p>
<p>2、防止暴露明文：<br>基本上存储用户密码的场景，都用到MD5加密明文。<br>1）例如网站服务器在其数据库存储用户的密码，都是存储用户密码的MD5值。就算不法分子得用户密码的MD5值，也无法知道用户的密码。<br>2）在UNIX、Linux系统中，用户密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。</p>
<p>3、防止抵赖（数字签名）：<br>这需要一个存储MD5值的第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。</p>
<h1 id="3-MD5算法实现"><a href="#3-MD5算法实现" class="headerlink" title="3.MD5算法实现"></a>3.MD5算法实现</h1><p>对MD5算法简要的叙述可以为：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<p>第一步、填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N<em>512+448(bit)；<br>第二步、记录信息长度：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N</em>512+448+64&#x3D;(N+1)*512位。<br>第三步、装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A&#x3D;(01234567) 16 ，B&#x3D;(89ABCDEF) 16 ，C&#x3D;(FEDCBA98) 16 ，D&#x3D;(76543210) 16 ）。如果在程序中定义应该考虑大小端（A&#x3D;0X67452301L，B&#x3D;0XEFCDAB89L，C&#x3D;0X98BADCFEL，D&#x3D;0X10325476L）。<br>第四步、四轮循环运算：循环的次数是分组的个数（N+1）。 最终由4个32bit数据拼成128bit的结果。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121430277.png" alt="image-20221212143002209"></p>
<h1 id="4-MD5的安全性"><a href="#4-MD5的安全性" class="headerlink" title="4.MD5的安全性"></a>4.MD5的安全性</h1><p>普遍认为MD5是很安全，因为哈希散列是强抗碰撞的：已知原数据和其MD5值，想通过枚举找到一个相同MD5值的数据，基本不可能。如果暴力破解MD5，其运算时间是不可想象的。</p>
<p>但是实际应用上，如果把用户密码仅仅MD5处理后再存储到数据库，其实是很不安全的。因为用户的密码的固有特征，让枚举集合变小了许多，原因：</p>
<ul>
<li>用户密码是比较短的一般8位左右。</li>
<li>很多用户的密码有规律，例如使用生日，手机号码，或者使用常用数字组合，或某个英文单词。</li>
<li>许多用户的常用密码只有一个，也就是说，泄漏了微信的密码，也很有可能QQ,支付宝密码也泄漏了</li>
</ul>
<p>如果把常用的密码先MD5处理后存储结果，然后再跟用户的MD5结果匹配，这时就有较大概率“碰撞”，得到明文。这种预先存储的MD5表称为rainbow-table。<br>因此MD5作为“信息摘要”的用途多一些，作为加密，还需要配合其他的算法（例如AES等几种公钥算法），或者“加盐”。<br>安全性比较好的网站，都会用一种叫做 “加盐”(salt)的方式来存储密码:</p>
<ul>
<li>先将用户输入的密码进行一次MD5（或其它哈希算法）加密。</li>
<li>将得到的MD5值前后加上一些只有管理员自己知道的随机串，再进行一次MD5加密。</li>
<li>这个随机串中可以包括某些固定的串，也可以包括用户名（用来保证每个用户加密使用的密钥都不一样）。</li>
<li>在管理员和用户的两个salt没有泄露的情况下，黑客拿到加密串，就几乎不可能推算出原始的密码是什么了。</li>
</ul>
<h1 id="5-MD5库"><a href="#5-MD5库" class="headerlink" title="5.MD5库"></a>5.MD5库</h1><p>在涉及到文件传输的场景，通常用MD5校验文件的一致性，openSSL库提供MD5计算函数：</p>
<p><a href="https://www.openssl.org/docs/man3.0/man3/MD5_Update.html">MD5_Update</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int MD5_Init(MD5_CTX *c);</span><br><span class="line">int MD5_Update(MD5_CTX *c, const void *data, unsigned long len);</span><br><span class="line">int MD5_Final(unsigned char *md, MD5_CTX *c);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>加密技术</category>
      </categories>
      <tags>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈加密和编码：base64</title>
    <url>/2022/01/22/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9Abase64/</url>
    <content><![CDATA[<h1 id="1-什么是编码解码"><a href="#1-什么是编码解码" class="headerlink" title="1.什么是编码解码"></a>1.什么是编码解码</h1><p>编码：利用特定的算法，对原始内容进行处理，生成运算后的内容，形成另一种数据的表现形式，可以根据算法，再还原回来，这种操作称之为编码。<br>解码：利用编码使用的算法的逆运算，对经过编码的数据进行处理，还原出原始数据，这种操作称之为解码。</p>
<h1 id="2-什么是Base64编码算法"><a href="#2-什么是Base64编码算法" class="headerlink" title="2.什么是Base64编码算法"></a>2.什么是Base64编码算法</h1><p>将任意的字节数组数据，通过Base64算法，生成只有（大小写英文、数字、+、&#x2F;）（一共64个字符）内容表示的字符串数据。即将任意的内容转换为可见的字符串形式。</p>
<h1 id="3-为什么需要Base64编码"><a href="#3-为什么需要Base64编码" class="headerlink" title="3.为什么需要Base64编码"></a>3.为什么需要Base64编码</h1><p>Base64算法最开始是被用于解决电子邮件数据传输问题。以前发送邮件只支持可见字符的传送，但ASCII码中，有一部分不支持直接显示。由此，需要有一个方法将不可见的字符转换为可见的字符，便产生了Base64编码算法。</p>
<h1 id="4-Base64算法的实现"><a href="#4-Base64算法的实现" class="headerlink" title="4.Base64算法的实现"></a>4.Base64算法的实现</h1><p>特点：</p>
<ul>
<li>将数据按照 3个字节一组的形式进行处理，每三个字节在编码之后被转换为4个字节。即：如果一个数据有6个字节，可编码后将包含6&#x2F;3*4&#x3D;8个字节</li>
<li>当数据的长度无法满足3的倍数的情况下，最后的数据需要进行填充操作，即补“&#x3D;” ，这里“&#x3D;”是填充字符，不要理解为第65个字符。因此我们经常看见base64编码的字符串结尾有几个”&#x3D;”号</li>
</ul>
<p>示例：</p>
<p> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121437191.png" alt="image-20221212143753149"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121438580.png" alt="image-20221212143830525"></p>
<p>上面示例将原始数据的每三个字节分为一组，按位进行分割为每6位一个字节的形式，进行转换，形成新的4个字节。空缺的两个bit用0填补。<br>这四个字节才通过Base64编码表进行映射，形成最后实际的Base64编码结果。<br>如果原始数据最后无法凑成3个字节，则以“&#x3D;”填充。</p>
<p>注：上图中的1234567表示bit的位置，不是bit的值。</p>
<p>将字符串”ABC”进行Base64编码流程如下。</p>
<p>1.使用ASCII编码方式将字符串”ABC”转换成二进制数据 01000001 | 01000010 | 01000011<br>2.将步骤1的二进制数据进行分组，每个分组6bit 010000 | 010100 | 001001 | 000011<br>3.将步骤2的4组6bit二进制编码数据进行补位（高位补0），变成4组8bit二进制 00010000 | 00010100 | 00001001 | 00000011<br>4.将步骤3中的4组8bit转换成十进制。16 | 20 | 9 | 3<br>5.以步骤4的十进制数据为索引，去Base64编码映射表中寻找对应的字符。16在编码表中映射的字符是Q，20映射的字符是U，9映射的字符是J，3映射的字符是D。<br>所以，字符串”ABC”经过Base64编码后的数据是”QUJD”。</p>
<p><strong>Base64编码索引表</strong><br>26个字母 * 2(大小写) + 10个数字 + 2个运算符号 &#x3D; 64个字符<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121438704.png" alt="image-20221212143820653"></p>
<h1 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h1><p>http协议中，GET方式和POST方式是Http请求常用的两种方式，GET方法只能传递ASCII数据，但某些情况下会要求使用GET来传递二进制数据。<br>此时用Base64对Get传输的二进制数据，编码成ASCII数据，例如，客户端和服务器传递JSON数据时，经常会进行base64编解码。</p>
<p>注意：</p>
<ul>
<li>Base64是编码算法，不是加密算法，只是用来编码二进制的字节数组，形成可视的ASCII字符串。</li>
<li>Base64编码实际上是把原数据的3个字节映射成了4个字节，所以相比于原数据长度，编码后的长度会增加1&#x2F;3。会降低传输效率。</li>
</ul>
]]></content>
      <categories>
        <category>加密技术</category>
      </categories>
      <tags>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈数字电路之PLL</title>
    <url>/2023/03/01/%E6%B5%85%E8%B0%88%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B9%8BPLL/</url>
    <content><![CDATA[<p>本文PLL的基础内容参考了Digital Integrated Circuits一书，下载方式：在 <a href="https://vdoc.pub/">vdoc</a> 搜索关键字 Digital Integrated Circuits</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303011144938.jpeg" alt="img"></p>
<h2 id="PLL的应用概述"><a href="#PLL的应用概述" class="headerlink" title="PLL的应用概述"></a>PLL的应用概述</h2><p>两个作用：Clock Synthesis（时钟综合）和 Clock Synchronization（时钟同步）</p>
<ul>
<li>Clock Synthesis，Synthesis是综合&#x2F;生成的意思，Clock Synthesis即生成时钟，但此处含义不是作为时钟源，而是在低频晶振时钟的基础上倍频生成高频时钟：其中低频的晶振时钟的特性：10~200MHz， accurate, low-jitter ，高频时钟特性：200MHz ~ GHz级别，通常也称为系统时钟，例如SOC core的基准频率</li>
<li>Clock Synchronization，不同芯片之间传递时钟信号需要同步时钟相位，例如SOC的CPU和外设之间的通信接口一般是：分频后的时钟信号（reference clock）和数据信号（Date），CPU和外设间的信号传递是需要时间的，高速信号传递到外设侧有相位偏移（可以简单理解为延迟），因此需要PLL同步时钟相位以保证对数据采样的正确性（想象一下，如果reference clock相位偏移过大，可能每个采样时刻得到的data数据都是错位的）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031043844.png" alt="image-20230303104354744"></p>
<h2 id="相位的概念"><a href="#相位的概念" class="headerlink" title="相位的概念"></a>相位的概念</h2><p>Digital Integrated Circuits一书对相位的描述：</p>
<p>Periodic signals of known frequency can be discribed exactly by only one parameter, their<br>phase. More accurately a set of two or more periodic signals of the same frequency can be<br>well defined if we know one of them and its phase with respect to the other signals.  </p>
<p>翻译下就是：</p>
<ul>
<li><p>多个已知频率的周期信号只用一个参数就能精确区分：相位</p>
</li>
<li><p>如果这些信号的频率相同，则只需知道相位差就可以从一个信号精确推测另一个信号</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031634330.png" alt="image-20230303163446269"></p>
<p>基于以上概念，下面介绍PLL的两个核心功能：</p>
<ul>
<li>将输入PLL的时钟和PLL输出时钟的频率精确同步：输出时钟信号频率是输入时钟信号频率的精确的N倍</li>
<li>将输入PLL的时钟和PLL输出时钟的相位精确同步：输出时钟信号N分频后，其应该和输入信号完全一致，其上升&#x2F;下降沿应该精确对齐输入时钟信号的上升&#x2F;下降沿</li>
</ul>
<h2 id="PLL内部实现"><a href="#PLL内部实现" class="headerlink" title="PLL内部实现"></a>PLL内部实现</h2><p>PLL内部结构如下，真正核心的只有两个组件：</p>
<ul>
<li>VCO: The voltage-controlled oscillator (VCO) takes an analog control input and generates a clock signal of the desired frequency.  VCO接受电压（模拟信号），转换为频率（数字信号），也就是说，VCO使输出频率是电压的函数(非线性)。Charge pump是控制电压增加和减少的模块，Loop filter是低通滤波器，过滤掉电压信号中的高频正弦噪声，使VCO的输入更“纯粹”（减少毛刺信号，jittery clock）</li>
<li>Phase Detectors: 为什么带s ? 因为可以有两种实现：XOR Phase Detector  和 Phase-Frequency Detector ，Phase Detectors是相位和频率同步的核心，具体原理下面讲</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031635776.png" alt="image-20230303163504732"></p>
<h3 id="XOR-Phase-Detector"><a href="#XOR-Phase-Detector" class="headerlink" title="XOR Phase Detector"></a>XOR Phase Detector</h3><p>用一个异或门(XOR)就能实现相位检测，是最简单但有缺陷的实现：</p>
<p>当ref clock和local clock(反馈时钟)有相位差，异或之后输出的就是相位差信号(phase error)，这个信号经过线性函数转换成Vdd, 作为VCO的控制电压。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031433820.png" alt="image-20230303143346757"></p>
<p>XOR的缺陷：当local clock相位和ref clock相位一致，但local clock频率是ref clock的N倍时，XOR检不输出相位差，但此时PLL输出频率不是预期的频率，而是N倍的预期频率。</p>
<h3 id="Phase-Frequency-Detector-PFD"><a href="#Phase-Frequency-Detector-PFD" class="headerlink" title="Phase-Frequency Detector (PFD)"></a>Phase-Frequency Detector (PFD)</h3><p>为了解决XOR的缺陷，引入了Phase-Frequency Detector (PFD)，看名字就知道，它同时检测相位和频率，以保证PLL输出的正确性</p>
<p>如下图，UP&#x2F;DN是控制VCO的信号，用于给VCO加压&#x2F;降压；A和B是local clock和ref clock；</p>
<p>PFD使用触发器(flip-flops)，将UP&#x2F;DN变成A和B的状态机；关于flip-flops的特性，参考 <a href="https://courses.cs.washington.edu/courses/cse370/03sp/pdfs/lectures/lecture15.pdf">Overview The D latch - University of Washington</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031532421.png" alt="image-20230303153203366"></p>
<p>(1) PFD如何检测相位差</p>
<p>以左侧信号为例，过程如下：</p>
<ol>
<li>信号A相位超前于信号B, A上升沿时会触发UP信号输出(D触发器特性，这里A作为D触发器的CLK输入信号)；</li>
<li>当信号B上升沿变化时, B处的触发器也输出DN脉冲，两个触发器的输出都为1，经过与门后Rst复位信号为1，导致A和B的触发器都被reset, 之后UP和DN都变为低；</li>
<li>综合下来看，UP信号的宽度就等于相位差，线性转换后就可以作为控制VCO的电压</li>
</ol>
<p>右侧波形同理，信号A相位落后于信号B，DN即相位差</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031500042.png" alt="image-20230303150043973"></p>
<p>(2) PFD如何检测频率差</p>
<p>如下图，当B频率比A低，PFD输出更多的UP信号增加VCO电压，提高B的频率；当B频率比A高则相反，PFD输出更多DN信号降低B的频率</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031517323.png" alt="image-20230303151725271"></p>
<h2 id="PLL的指标"><a href="#PLL的指标" class="headerlink" title="PLL的指标"></a>PLL的指标</h2><p>PLL structure is a feedback structure and the addition of extra phase shifts, as is done by a high-order filter, may result in instability. </p>
<p>PLL是能造成相位偏移（矫正）的反馈电路，既然是反馈就得像数学求极限一样不断趋近，这决定PLL不是一上电就能马上稳定工作，因此引入PLL的关键指标如下：</p>
<p>Important properties of a PLL are：</p>
<ul>
<li><p>lock range—the range of input frequencies over which the loop can maintain functionality; PLL能接受的输入时钟不可能太高，一般是OSC晶振低频时钟。想象一下，太高的输入时钟要去同步相位和倍频，对VCO和相位检测器的精度要求也极高</p>
</li>
<li><p>the lock time—the time it takes for the PLL to lock onto a given input signal; PLL是反馈环路电路，需要不断递归趋近于目标时钟信号直到稳定，稳定需要的时间称为PLL锁定时间</p>
</li>
<li><p>jitter.  毛刺信号，在模拟端称为noise(VCO输入电压)，在数字端称为jitter毛刺(VCO输出时钟)，这是时钟信号相关模块必不可少的指标</p>
</li>
</ul>
<h2 id="PLL的稳定过程"><a href="#PLL的稳定过程" class="headerlink" title="PLL的稳定过程"></a>PLL的稳定过程</h2><p>如下图是Spice 仿真将100Mhz reference clock倍频8倍，VCO最终稳定输出800Mhz system clock的过程：</p>
<ul>
<li><p>左侧是VCO控制电压，经过几次反馈调整后最终稳定</p>
</li>
<li><p>右侧是时钟信号，ref是输入的100Mhz reference clock，vco是输出的system clock， div是vco输出8分频后的反馈时钟</p>
</li>
</ul>
<p>可见PLL稳定过程是将ref，vco和div时钟信号的相位、频率都收敛到一致</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031423652.png" alt="image-20230303142344571"></p>
<h2 id="PLL在IC设计IP的实例"><a href="#PLL在IC设计IP的实例" class="headerlink" title="PLL在IC设计IP的实例"></a>PLL在IC设计IP的实例</h2><p>以SMIC的PLL IP S65NLLPLLGS 为例介绍实际IC设计中的PLL模块：</p>
<p>(1) 简介</p>
<p>This PLL is developed as an IP block to reduce time to market, risk and cost in the<br>development of Analog Front –End design. This macro cell is mainly for the clock<br>generator. It can generate stable high-speed clock from a slower clock signal with<br>single power supply. The output frequency is adjustable and can be up to 1500MHz.<br>This PLL integrates a Phase Frequency Detector (PFD), a Low Pass Filter (LPF), a<br>Voltage Controlled Oscillator and other associated circuit. All fundamental building<br>blocks as well as fully programmable dividers are integrated in the core. It is useful<br>for clock multiplication of stable crystal oscillator sources and for de-skew clock<br>signals  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061656462.png" alt="image-20230306165657371"></p>
<p>可见主要模块还是PFD + VCO，输出时钟加了一些逻辑门控制，例如PDRST是PLL时钟复位控制。</p>
<p>(2) 主要参数</p>
<p>Technology: SMIC 65nm logic LL process  </p>
<p>PFD comparison frequency range from 1Mhz to 50Mhz.  </p>
<p>Output clock frequency range from 62.5MHz to 1500MHz  </p>
<p>基本体现了PLL的指标：输入输出时钟频率有限制</p>
<p>(3) PLL reset</p>
<p>PLL作为实际可用的模块，其输出频率一定是可调的，以下PLL IP的pin中的M, N即调整频率；对于固件、驱动软件开发者，M，N分频的访问接口是作为寄存器来动态配置。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061707268.png" alt="image-20230306170709189"></p>
<p>在M，N调整分配时，必须reset PLL并等待PLL再次稳定（PLL lock time），如下图：</p>
<p>LKDT: Lock Detection, 表示目前PLL正在lock，即反映PLL是否处于不稳定状态</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061711496.png" alt="image-20230306171156449"></p>
<h2 id="PLL在外设时钟配置的实例"><a href="#PLL在外设时钟配置的实例" class="headerlink" title="PLL在外设时钟配置的实例"></a>PLL在外设时钟配置的实例</h2><p>SD控制器(SD host)是SOC中常用的外围模块，通过SD specification规定的SD Command通信格式向SD卡通信。</p>
<p>下面以SD host&#x2F;card的时钟初始化为例，介绍PLL的lock time在外设时钟初始化的影响</p>
<p>(1) SD 4.0标准的host和card的物理框图如下图，这里重点关注host侧的时钟相关的模块：</p>
<ul>
<li>OSC: host 的时钟来源，同时也是PLL的输入</li>
<li>PLL: host的倍频器，为了给SD UHS-II card提供更高速的工作时钟(UHS-I低速SD card不需要此PLL)</li>
<li>RCLK: SD card的工作时钟(reference clock)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061954691.png" alt="image-20230306195458581"></p>
<p>(2) SD host和card的时钟初始化</p>
<p>SD host和card的时钟初始化包含三步：</p>
<p>1.使能internal clock: sd host chip自己的工作时钟(即base clock，来源是OSC)，并等待其稳定，如下图(3)~(4)</p>
<p>2.enable PLL，并等待其稳定，这个等待稳定超时时间为150ms ，如下图(5)~(6)。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303062016985.png" alt="image-20230306172758282"></p>
<p>3.待host PLL输出稳定后，即可enable SD clock开始对SD卡供应reference clock时钟, 注意SD clock是下图(1)~(2)就已经计算好的，如下表Base Clock为internal clock，M可理解为PLL倍频后的频率, 经过2^N分频后给SD card作为reference clock。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303062013044.png" alt="image-20230306201345998"></p>
<h2 id="PLL在电源管理的实例"><a href="#PLL在电源管理的实例" class="headerlink" title="PLL在电源管理的实例"></a>PLL在电源管理的实例</h2><p>所谓电源管理，通俗的讲就是按需管理电源：</p>
<ul>
<li>按需，指的是按应用场景的需求，例如在高性能肯定对应高功耗，各种模块全部开启，且时钟频率拉到最大；而睡眠休眠等模式，有时只需要保留能唤醒系统的时钟就行；</li>
<li>管理电源，涉及到供电和时钟：将低功耗情景下不需要用到的模块直接关电，将要用到但速度要求不高的模块进入低速时钟工作。</li>
</ul>
<p>下面以PCIe的电源管理为例，介绍低功耗状态如何影响PLL的状态</p>
<p>（1）PCIe电源管理基本概念</p>
<p>PCIe的电源管理基本概念参考 <a href="https://www.intel.cn/content/www/cn/zh/io/pci-express/pci-express-architecture-power-management-rev-1-1-paper.html">PCI EXPRESS ARCHITECTURE POWER MANAGEMENT</a>, 也可以参考PCIe标准协议PCIe Base Spec</p>
<p>从上到下包含三层：系统电源状态(S)，PCIe链路电源状态(L)，PCIe设备电源状态(D)</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071046331.png" alt="Untitled Diagram"></p>
<ul>
<li>Sleep state</li>
</ul>
<p>S0 (Working): This is the active system state in which the platform appears to be “on.”  </p>
<p>S1&#x2F;POS, S1 (Microsoft* OS Stand By): These are the lowest wake latency sleeping states.  </p>
<p>S3 (Microsoft OS Stand By) and S4 (Microsoft OS Hibernate): S3 is a low wake latency sleeping state in which all device contexts are lost except system memory</p>
<p>S5 (Microsoft OS Soft-off): In this state, the OS does not save any context and requires a complete OS boot when the system wakes  </p>
<ul>
<li>Link States</li>
</ul>
<p>L0: Active state  </p>
<p>L1: This link state is a low exit latency link state that is intended to reduce power when the device becomes aware of a lack of outstanding requests or pending transactions  </p>
<p>L2&#x2F;L3 Ready: This link state prepares the PCI Express link for the removal of power and clock.   </p>
<p>L3 (link off): Power and clock are removed in this link state  </p>
<ul>
<li>Device States</li>
</ul>
<p>D0 (Fully-on): The device is completely active and responsive during this D-state  </p>
<p>D1 and D2: There is no universal definition for these D-states. In general, D1 is expected to save<br>less power but preserve more device context than D2  </p>
<p>D3 (Off): Primary power may be fully removed from the device (D3cold), or not removed from the device (D3hot). </p>
<p>S, L, D 三层状态的对应关系如下表</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071050761.png" alt="image-20230307105034704"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071050372.png" alt="image-20230307105052312"></p>
<p>注意，Link state是Sleep state对Device state作用的结果，即状态变化的过程是：</p>
<p>系统发起S3 -&gt; Device sate进入D3-&gt;Link state进入L2&#x2F;L3</p>
<p>（2）使用PLL控制Device state</p>
<p>Device sate进入D3, 设备内部操作即包含PLL的disable，将PLL模块整个关掉，保留OSC低速时钟作为退出D3状态的唤醒时钟源（软件上可以理解为heart beat），当PLL关掉后，其他依赖PLL的高速模块通常也断电，整个设备接近（或彻底）断电，因此设备功耗极低。</p>
<p>Device sate退出D3并进入D0则是相反过程，设备的PLL模块打开，其他依赖PLL的高速模块也打开，整个设备进入Active状态，功耗自然升高。</p>
<p>（3）使用PLL控制Link state</p>
<p>参考chapter11 of <a href="https://vdoc.pub/download/introduction-to-pci-express-a-hardware-and-software-developers-guide-1r2bcv8l7e6o">Introduction to PCI Express: A Hardware and Software Developer’s Guide</a></p>
<p>当PCIe link改变时，本质是PCIe时钟改变；PCIe host侧（bridge&#x2F;Root Complex）的时钟也是低速clock source经PLL倍频后的2.5GHz，如下图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071202081.png" alt="image-20230307120222026"></p>
<p>L1 link state的本质：The L1 Link state is an idle state with the internal Phase Lock Loop Circuit turned off. The source clock is still feeding a 100-megahertz differential clock signal to the PCI Express component.</p>
<p>L2 link state的本质：The L2 Link state is an optional auxiliary idle state with the internal Phase Lock Loop Circuit, the external clock source, and the main device power turned off (auxiliary power remains on)</p>
<p>总结就是：PCIe Link State本质是通过关闭PCIe host侧的PLL甚至clock source来实现的。</p>
]]></content>
      <categories>
        <category>硬件基础</category>
      </categories>
      <tags>
        <tag>PLL</tag>
      </tags>
  </entry>
  <entry>
    <title>电量计 -- 77561电池建模和调参</title>
    <url>/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%2077561%E7%94%B5%E6%B1%A0%E5%BB%BA%E6%A8%A1%E5%92%8C%E8%B0%83%E5%8F%82/</url>
    <content><![CDATA[<h1 id="电量计-–-77561电池建模和调参"><a href="#电量计-–-77561电池建模和调参" class="headerlink" title="电量计 – 77561电池建模和调参"></a>电量计 – 77561电池建模和调参</h1><h2 id="合并电池建模数据到PRJ"><a href="#合并电池建模数据到PRJ" class="headerlink" title="合并电池建模数据到PRJ"></a>合并电池建模数据到PRJ</h2><p>77561的可配参数包括建模表都是cobra直接配置到flash，因此直接在现有prj上编辑参数：</p>
<p>（1）导入TableMaker输出的OCV_falcon.txt(X轴是电压的版本)和RC.txt表</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503311736904.png" alt="image-20250331173554812"></p>
<p>（2）导入电池规格参数</p>
<p>电量计采样是双节电芯才按双节电压处理；如果是电量计两个通道分别采样单节电芯要按单节电芯算，电池包的电压参数要除2。</p>
<p>多串电芯的示例（双节采样）：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503311931715.png" alt="image-20250331193151566"></p>
<p>多并电芯的示例：</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/10/23/721c9ec0991e071f.png" alt="image-20251023102148780"></p>
<p>注意保护电压也要调整，Cell OV threshold &gt;&#x3D; 充电限制电压，如果设置低了ADC就不采集，SBS通信就读不出电压为0</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/10/23/b134e7905f5f7e10.png" alt="image-20251023115325601"></p>
<h2 id="FW环境数据更新"><a href="#FW环境数据更新" class="headerlink" title="FW环境数据更新"></a>FW环境数据更新</h2><p>(1) 初始化DFCC表</p>
<p>放电精度调参主要是调DFCC，其定义取决于客户需求要关注哪几个电流和温度，如下图是初始值，默认权重都是100%即保持当前soc不缩小或放大。</p>
<p>注意：DFCC_Y和DFCC_Z的值也要跟随调整，DFCC_X一般不动。</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/10/23/b246339726250faf.png" alt="image-20251023103321369"></p>
<p>sysim系统阻抗是电量计芯片和电芯之间的线阻，影响放大误差，如果默认值1毫欧和实际硬件有很大不匹配可能导致很大的放电误差。</p>
<p>需要测量电池包内，电芯到电量计芯片的阻抗，注意不是电池包到外部充放电线的阻抗，再配置代码参数sysim(单位0.1毫欧)</p>
<p>例如 cfg.sysim &#x3D; 2*10; 表示系统阻抗2毫欧。</p>
<p>(2)更新RC建模表的XY个数</p>
<p>注意Firmware的RC table XY值也要调整为和建模表一致！仿真环境也必须一致，否则仿真曲线和实测曲线不重合！</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/11/03/b8d01a0779dd4593.png" alt="image-20251103110429290"></p>
<h2 id="仿真环境数据更新"><a href="#仿真环境数据更新" class="headerlink" title="仿真环境数据更新"></a>仿真环境数据更新</h2><p>(1)更新建模表和参数</p>
<p>batsim代码里新增一个DATA_TYPE宏区分不同项目配置，根据OCV_falcon.txt和RC.txt表合并OCV,RC table和parameter，需要修改SOCLib的table.c&#x2F;table.h&#x2F;parameter.c</p>
<p>使用python脚本完成以上OCV和RC表数据替换，详见python tool注释；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503312033925.png" alt="image-20250331203309863"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503312033583.png" alt="image-20250331203328434"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503312038052.png" alt="image-20250331203805982"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504031426429.png" alt="image-20250403142611409"></p>
<p>注意DFCC需要手动配置。从Firmware代码拷DFCC table和Y，Z个数到仿真代码。必须一致否则调参对不上而且问题隐蔽！</p>
<p>还有一些参数在仿真代码main.c直接定义的，如sysim，eod_ddv。</p>
<p>（2）FW 的lib_fg.c需要同步到仿真的SOCLib77561\lib，仿真使用的到底是那个lib_fg .c和.h可以在vs环境查看，将FW的lib&#x2F;lib_fg.c和lib_fg.h复制到仿真工程的SOCLib77561\lib，在vs工程中移除之前的libfg.c和.h，再添加existing file libfg.c和.h。</p>
<p>移植FW lib到仿真工程可能有的问题：dbg_print编译报错，注释掉所有dbg_print。最后winmerge比较确认和FW一致性。参数定义不一致问题，以当前FW定义为准。</p>
<p>以上全部配置好后，编译SOCLib和Simer GUI</p>
<h2 id="仿真软件调参DFCC"><a href="#仿真软件调参DFCC" class="headerlink" title="仿真软件调参DFCC"></a>仿真软件调参DFCC</h2><p>实测不同温度电流下的cobra放电数据（cycler-cobra .csv)</p>
<h3 id="Bat-simmer软件"><a href="#Bat-simmer软件" class="headerlink" title="Bat simmer软件"></a>Bat simmer软件</h3><p>先编译Lib和GUI，运行bat simmer，加载cobra采集数据csv。csv可能包含充电和放电过充，可手动设置Display只显示放电区域的x轴范围</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504021732398.png" alt="image-20250402173244348"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504011050736.png" alt="image-20250401105054688"></p>
<p>已更新Bat simmer版本功能，GUI X轴自动显示放电过程</p>
<h3 id="DFCC调参"><a href="#DFCC调参" class="headerlink" title="DFCC调参"></a>DFCC调参</h3><p>调参是根据cyc-sim蓝绿曲线的最大值，找对应的SOC，再结合电流和温度，查表对应的DFCC值。</p>
<p>（1）DFCC调参基本思路：</p>
<p>cycle曲线是以cobra csv的电荷积分信息算出的真实电量信息，作为目标值；</p>
<p>simer曲线是以SOCLib中算法输出的rsoc电量信息，作为待调试值；</p>
<p>调参目标：放电阶段，simer曲线逼近cycle曲线，对应的cyc-sim误差全局小于3%。</p>
<p>cycle-cobra的误差反映的是调参以前的实测误差，在调参过程中用不到这个误差。调参以后可以再cobra实测确认误差应该和cyc-sim一致。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504021727057.png" alt="image-20250402172723008"></p>
<p>（2）调参过程：</p>
<p>如果simmer &gt; cycle，调低对应的DFCC区间值；反之则调高DFCC区间值。</p>
<p>以调整RSOC 10位置的误差为例：</p>
<p>由于DFCC表的电流是离散的几个值，可能当前测试的电流(1A)不在DFCC电流表中(0.6A, 1.5A)，算法查DFCC表会依赖于临近电流插值，因此估计(0.6A, 1.5A)两个电流点的DFCC值会共同决定1A的DFCC值，可以同时把(0.6A, 1.5A)两个点调大，也可以只调1.5A, 0.6A不变，以调整结果为准。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504021715840.png" alt="image-20250402171530799"></p>
<p>在调参后需要编译SOCLib更新DLL，Bat Sim界面程序不需要更新，可以直接VS F5运行查看效果（sln项目配置需要设置F5运行默认从Bat sim启动）。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504021736896.png" alt="image-20250402173650853"></p>
<p>（3）DFCC表是有调整规律的：</p>
<p>低温的容量会调低，大电流的容量会调高，高温的容量会调高。</p>
<p>同一 Y, Z轴下的一行DFCC值不会反复跳变，一般是从40%递增到100%甚至超过100。</p>
<p>某个soc点位怎么调都缩写不了误差如何处理：</p>
<ol>
<li><p>考虑调它前面的点位（曲线左侧soc更高的点位），因为前面的soc会累积影响到当前soc，当前误差最大可能是前面soc影响。</p>
</li>
<li><p>曲线要看转折点而不仅仅是最大误差点，看左侧趋势在哪个点位发生斜率改变，这个转折点就是要调的soc，而不是后面误差累计达到最大的点</p>
</li>
</ol>
<p>（4）注意：Bat simer全局最大误差idx log是不准确的，调参应该以曲线鼠标显示的soc值为准</p>
<p>如下图说RSOC 30是误差最大点，实际误差很小；RSOC 8是误差最大点，要调的是这个点）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504021707148.png" alt="image-20250402170734028"></p>
<p>（5）调参也应该参考cobra曲线和sim曲线，某处soc对应误差大，不一定是修改DFCC这个soc的值，而是修改这个soc前面或者后面的值，要根据sim曲线趋势判断误差发生在前面还是后面的soc。</p>
<p>如下图左侧是cobra原始DFCC，右侧是调参后的DFCC。</p>
<p>正常的调参，DFCC值应该是连续变化，如果有误差在当前soc改不动，例如当前soc偏低，但怎么调高也纠正不了，考虑原因是前面放电更高soc点位的DFCC值偏低。</p>
<p>调参切忌盯着一个soc点位调，错误把DFCC值改成跳变。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081636016.png" alt="image-20250408163614933"></p>
<p>（5）权重互补</p>
<p>因为DFCC表只是几个采样，实际电流情况会有插值。DFCC调参需要考虑权重互补，考虑相邻DFCC行的权重。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504181030594.png" alt="image-20250418103046531"></p>
<p>(6) 使用cobra数据精确调参</p>
<p>遇到常温误差比较大的情况时，首先排查两个问题：1.看EOD电压附近+-50mV以内是否电量达到0，这是EOD参数基础功能要求。2.如果发现电池开始放电压降大，怀疑sysim问题，仿真代码可以修改sysim看看效果。</p>
<p>然后才是调DFCC：查看GGMEM0的fcc和facc比例，可以直接得出dfcc该如何调整。</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/10/28/fa4464af99381706.png" alt="image-20251028150421032"></p>
<h1 id="Bug-fix记录"><a href="#Bug-fix记录" class="headerlink" title="Bug fix记录"></a>Bug fix记录</h1><h2 id="CADC补偿问题影响低温精度"><a href="#CADC补偿问题影响低温精度" class="headerlink" title="CADC补偿问题影响低温精度"></a>CADC补偿问题影响低温精度</h2><p>77561有CADC TRIM功能，是利用ATE对不同批次芯片测试中发现某些批次电流误差较大时（良率问题），ATE将25度和60度下CADC电流误差纠正值写入flash，FW根据flash值按一定斜率推算低温-20度的电流补偿值。25度和60度的补偿是数字逻辑纠偏不需要FW参与。</p>
<p>如果CADC TRIM功能失效，会导致-20C精度测试的误差很大（达到20%），这时不管怎么调DFCC都很难纠正。因此低温下SOC精度问题尤其要注意CADC补偿是否正常。</p>
<p>CADC TRIM功能和DFCC调参的相关性：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504111418301.png" alt="image-20250411141816196"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504111419341.png" alt="image-20250411141914294"></p>
<h2 id="低温大电流放电，cycle曲线异常"><a href="#低温大电流放电，cycle曲线异常" class="headerlink" title="低温大电流放电，cycle曲线异常"></a>低温大电流放电，cycle曲线异常</h2><p>低温-20度用大电流0.5C 2.5A放电，工具读csv显示的cycle曲线异常，下降极快</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504161602548.png" alt="image-20250416160203454"></p>
<p>而同样环境，低温-20度小电流0.2C 1A放电，或者是低温-10度大电流0.5C 2.5A放电，cycle曲线都是正常。</p>
<p>问题原因：低温+大电流两个条件叠加，导致放电开始时初始电压就降到3.4V，而截止电压是3.3V。但工具解析cycle csv数据对放电终点有误判认为3.4V就是终点导致cycle曲线错误解析。</p>
<p>-20度 2.5A的放电数据cycle csv：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504161610370.png" alt="image-20250416161004330"></p>
<p>解决办法：用rsoc &#x3D; 0作为放电终点，只对小电流放电补充判断截止电压，避免大电流放电误判</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504161610510.png" alt="image-20250416161023471"></p>
<p>修复之后效果：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504161612037.png" alt="image-20250416161237987"></p>
<h2 id="电池一致性问题"><a href="#电池一致性问题" class="headerlink" title="电池一致性问题"></a>电池一致性问题</h2><p>一般电池建模和放电cobra测试使用同型号的电芯，但有时电芯一致性区别大，使用#1号电芯建模，使用#2电芯放电测试，怎么调参都达不到仿真效果，可能是一致性问题，即两个同型号电芯的实际容量和内阻等特性有大的差异，导致建模不匹配。</p>
<p>对这种问题，首先确认三个数据是否一致，排除软件引起：建模RCtable，Cobra测试FW的算法和RCtable，仿真环境FW的算法和RCtable，应该完全一致。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505141930422.png" alt="image-20250514193017205"></p>
<p>问题特性是：</p>
<ol>
<li><p>仿真可以调得很好，但cobra测试误差很大（相同的FW和建模数据，cobra测试曲线和仿真曲线不能保持一致），如下图</p>
</li>
<li><p>查看cobra csv log无异常，温度(内部外部温度区别不大)，电流值（originCurrent和CADC校准后的Bat current），电量（放电的 电流*时间 积分 &#x3D; ccmAh电量）等关键数据都没问题。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505141931240.png" alt="image-20250514193136189"></p>
<p>使用当前电芯做一次建模，和已有的RCtable的建模结果比较，如果soc误差大即确认建模不匹配，如下图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505141945794.png" alt="微信图片_20250514194341"></p>
<p>然后用已有RCtable的那块建模电芯再复测，如果仿真曲线和cobra曲线能匹配，就确认了是一致性问题。</p>
]]></content>
      <categories>
        <category>电量计</category>
      </categories>
      <tags>
        <tag>电量计</tag>
      </tags>
  </entry>
  <entry>
    <title>电量计 -- HDQ调试过程</title>
    <url>/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20HDQ%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="电量计-–-HDQ调试过程"><a href="#电量计-–-HDQ调试过程" class="headerlink" title="电量计 – HDQ调试过程"></a>电量计 – HDQ调试过程</h1><p>用GPIO INT pin（支持WKUP）实现HDQ接口，实现slave，配合host驱动通信，获取电量信息。并且和I2C接口兼容不冲突。</p>
<h2 id="Keil-sct和项目配置"><a href="#Keil-sct和项目配置" class="headerlink" title="Keil sct和项目配置"></a>Keil sct和项目配置</h2><p>(1) Keil工程配置</p>
<p>Keil的IROM，IRAM配置的主要作用是在编译期发现空间不够的问题，编译器提前报错。</p>
<p>IRAM只是代码段，不包含堆栈，所以IRAM大小要预留STACK和HEAP空间，不然编译期不报错，运行期STACK爆了很难查</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507161146082.png" alt="image-20250716114617057"></p>
<p>(2) sct链接配置 </p>
<p>真正配置IROM和IRAM空间分布的是.sct文件，如下是newton FW sct</p>
<p>sct的含义参考Keil文档，这里不详细描述。需要会区分IROM，IRAM，知道(+RO)表示代码段，(+RW +ZI)表示数据段，.ANY和*.o是通配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">;;Flash mapping, total 64KB EEPROM </span><br><span class="line">;0x0~0x2000 8KB bootloader code</span><br><span class="line">;0x2000~0xD3FF 45KB Firmware code</span><br><span class="line">;0xD400~0xF3FF 8KB Table and Parameter data</span><br><span class="line">;0xF400~0xFFFF 3KB log page and trim data</span><br><span class="line"></span><br><span class="line">;;RAM mapping, total 4KB RAM</span><br><span class="line">;0x20000000 ~ 0x20000400 1KB bootloader data</span><br><span class="line">;0x20000400 ~ 0x20000F80 3KB-128 firmware data</span><br><span class="line">;0x20000F80 ~ 0x20001000 128 bytes remain for stack and heap</span><br><span class="line"></span><br><span class="line">LR_IROM1 0x00000000 0x00002000  &#123;</span><br><span class="line">  ER_IROM1 0x00000000 0x00002000  &#123;  ; bootloader 8KB, load address = execution address</span><br><span class="line">   ;.ANY (+RO)</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   ;*(InRoot$$Sections)</span><br><span class="line">   ;startup_armcm0.o</span><br><span class="line">   ;system_ARMCM0.o</span><br><span class="line">   ;newton_o2bootloader_main.o</span><br><span class="line">   ;systime_o2bl.o</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00000400  &#123;  ; RW data, 1KB</span><br><span class="line">   ;.ANY (+RW +ZI)</span><br><span class="line">   newton_o2bootloader_main.o (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_STACK +0 UNINIT ALIGN 16       ; RW data - Stack &lt;&lt;&lt; THIS SECTION IS WHAT I ADDED</span><br><span class="line">  &#123;</span><br><span class="line">    *.o (Stack)</span><br><span class="line">	*.o (Heap)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LR_IROM2 0x00002000 0x0000B400  &#123;    ; FW ROM 45KB(0xB400), +Bootloader 8KB(0x2000) = 53KB, 后面还有8KB</span><br><span class="line">  ER_IROM2 0x00002000 0x0000B400  &#123; </span><br><span class="line">   ;.ANY (+RO)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   main.o</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ;RW_IRAM2 0x20000460 0x00000BA0 &#123; ; original setting, 0x460+0xBA0=0x1000 4KB</span><br><span class="line">  RW_IRAM2 0x20000400 0x00000B80  &#123;  ; RW data, 3KB - 128 bytes(remain for stack)</span><br><span class="line">   ;.ANY (+RW +ZI)</span><br><span class="line">   main.o (+RW +ZI)</span><br><span class="line">  ...</span><br><span class="line">   .ANY (+RW +ZI)  ; Catch-all for any remaining BSS sections</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) RAM紧缺的优化方法</p>
<p>修改大数组，添加const使编译器从原本是RW数据区的数组放置到ROM区，减少RAM占用。</p>
<p>注意只读数组可以这么改，修改后数组在EEPROM&#x2F;Flash，无法在RAM中被更新。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507161136815.png" alt="image-20250716113642727"></p>
<h2 id="Sleep-time过程"><a href="#Sleep-time过程" class="headerlink" title="Sleep time过程"></a>Sleep time过程</h2><p>Chip Sleep主要依赖于Timer1的timeout中断来计时(单位1HZ)，Timer1还能同时配置wakeup中断使timeout时chip从sleep低功耗模式下恢复成全功率模式</p>
<p>Timer2基本没使用，Chip Idle状态下的sleep和定时active都是由timer1完成。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507181141454.png" alt="image-20250718114147290"></p>
<h2 id="HDQ调试–UART方式"><a href="#HDQ调试–UART方式" class="headerlink" title="HDQ调试–UART方式"></a>HDQ调试–UART方式</h2><p>UART打印只需要使用slave的TX，即GPIO TX；UART打印一次约一百毫秒以上，会影响毫秒级别HDQ timing，secure CRT看到的uart时间戳并不是真实的HDQ timing时间戳。因此UART打印只能用来调试秒级的HDQ的基本逻辑功能。</p>
<h2 id="HDQ调试–GPIO方式"><a href="#HDQ调试–GPIO方式" class="headerlink" title="HDQ调试–GPIO方式"></a>HDQ调试–GPIO方式</h2><p>基本GPIO配置：（INT和TX都可用于调试信号，配置模式不一样）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;chip_uart.h&quot;</span><br><span class="line">void Set_INTGPIO(uint8_t val)</span><br><span class="line">&#123;</span><br><span class="line">    Chip_IO_SetINTCFG(EXINTCFG_MODE_OUTPUT_PUSH_PULL | EXINTCFG_PU_ENABLE);</span><br><span class="line">    UART-&gt;CTL &amp;= ~(UART_CTRL_RX_ENABLE);</span><br><span class="line">    if(val)</span><br><span class="line">        Chip_IO_SetINT_DOUT(EXINTDAT_OUTPUT_HIGH);</span><br><span class="line">    else</span><br><span class="line">        Chip_IO_SetINT_DOUT(EXINTDAT_OUTPUT_LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Set_TXGPIO(uint8_t val)</span><br><span class="line">&#123;</span><br><span class="line">    Chip_IO_SetGPIOCFG(GPIOCFG_MODE_DIGI_OUTPUT); //注意模式是DIGI_OUTPUT，不是OUTPUT_PUSH_PULL</span><br><span class="line">    UART-&gt;CTL &amp;= ~(UART_CTRL_TX_ENABLE);</span><br><span class="line">    if(val)</span><br><span class="line">        Chip_IO_SetGPIO_DOUT(GPIODATA_OUTPUT_HIGH);</span><br><span class="line">    else</span><br><span class="line">        Chip_IO_SetGPIO_DOUT(GPIODATA_OUTPUT_LOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试信号函数：输出n+1次脉冲(1 &amp; 0)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void hdq_txgpio_dbg_signal(int n)&#123;</span><br><span class="line">    do&#123;</span><br><span class="line">        Set_TXGPIO(1);</span><br><span class="line">        Set_TXGPIO(0);</span><br><span class="line">    &#125;while(n--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用可在中断内，例如HDQ WKUP handler，TIM1 hander：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//HDQ WKUP isr内调用，用dslogic查看break信号是否超时:   </span><br><span class="line"></span><br><span class="line">   hdq_txgpio_dbg_signal(1);</span><br><span class="line"></span><br><span class="line">    // 等待break结束（检测上升沿）</span><br><span class="line">    while (!hdq_gpio_read()) &#123;</span><br><span class="line">        if (hdq_wait_timeout(hdq_ctrl.break_start_ms, 3*HDQ_BREAK_MAX_MS)) &#123;</span><br><span class="line">            // break超时，退出</span><br><span class="line">            dbg_print(&quot;HDQ: Break timeout, elapsed=%dms\r\n&quot;, hdq_timer_elapsed_ms(hdq_ctrl.break_start_ms, hdq_timer_get_ms_count()));</span><br><span class="line">            hdq_ctrl.state = HDQ_STATE_IDLE;</span><br><span class="line">            hdq_enable_sleep();</span><br><span class="line">            </span><br><span class="line">            hdq_txgpio_dbg_signal(2);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hdq_txgpio_dbg_signal(1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void TIM1_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">	//每次timeout中断翻转一次TX，用于检测中断时间是否准确</span><br><span class="line">    int gpio = Chip_IO_GetGPIO_DOUT();</span><br><span class="line">    Set_TXGPIO(gpio? 0: 1);</span><br><span class="line">    </span><br><span class="line">    TIMER16_1-&gt;TIMINTR |= 1; // TIMER_INT_FLAG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HDQ帧间sleep后不能再wkup"><a href="#HDQ帧间sleep后不能再wkup" class="headerlink" title="HDQ帧间sleep后不能再wkup"></a>HDQ帧间sleep后不能再wkup</h2><p>drive sleep前需要初始化配置HDQ的GPIO模式，避免被其他配置干扰</p>
<h2 id="HDQ-fast-sleep"><a href="#HDQ-fast-sleep" class="headerlink" title="HDQ fast sleep"></a>HDQ fast sleep</h2><p>一个SBS通信期间需要多个HDQ帧，如果每个帧都等待systick idle 1s sleep，一次SBS通信太慢，所以需要SBS通信active时，HDQ快速进入sleep</p>
<p>具体方法：新增HDQ register定义：SBS_STATUS_REG_ADDR用于Host通知slave，什么时候SBS开始，什么时候结束，SBS期间slave主动drive sleep不用等idle。</p>
<p>Host侧读SBS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 发SBS_STATUS_REG_ADDR = 1表示启动了SBS通信会有多个HDQ帧，</span><br><span class="line">sd77561_hdq_write_byte(chip, SBS_STATUS_REG_ADDR, 1);</span><br><span class="line"></span><br><span class="line">// 写CMD</span><br><span class="line">  sd77561_hdq_write_byte(chip, CMD_REG_ADDR, sbs_cmd_code);</span><br><span class="line">  sd77561_hdq_wait_slave_sleep(HDQ_SBS_RUNNING_WAIT_MS);</span><br><span class="line"></span><br><span class="line">  // 读数据</span><br><span class="line">  for (indx = 0; indx &lt; size; indx++)</span><br><span class="line">  &#123;</span><br><span class="line">   if (sd77561_hdq_read_byte(chip, DATA0_REG_ADDR + indx, &amp;sbs_data[indx]) &lt; 0)</span><br><span class="line">   return -1;</span><br><span class="line">   sd77561_hdq_wait_slave_sleep(HDQ_SBS_RUNNING_WAIT_MS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 读CRC(CMD+Data的)</span><br><span class="line">  sd77561_hdq_read_byte(chip, CRC_REG_ADDR, &amp;crc_slave) ;</span><br><span class="line">  </span><br><span class="line">// 发SBS_STATUS_REG_ADDR = 0表示完成了SBS通信，固件会恢复1s idle sleep时间</span><br><span class="line">  sd77561_hdq_wait_slave_sleep(HDQ_SBS_RUNNING_WAIT_MS);</span><br><span class="line">  sd77561_hdq_write_byte(chip, SBS_STATUS_REG_ADDR, 0);</span><br></pre></td></tr></table></figure>

<p>Slave侧在SBS的一个HDQ完成后，但SBS没结束的状态下，以ms级别轮询，主动drive sleep</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (systime_passed_ms())</span><br><span class="line">    &#123;</span><br><span class="line">#if HDQ_SW_ENABLE</span><br><span class="line">        // dbg_print(&quot;systime_get_ms(): %d\r\n&quot;, systime_get_ms());</span><br><span class="line">        // dbg_print(&quot;hdq_timer_get_count(): %d\r\n&quot;, hdq_timer_get_count());</span><br><span class="line"></span><br><span class="line">        //如果只用HDQ帧idle就进sleep，会导致秒级算法轮询无法更新因为ms级别polling一定比秒级先执行，</span><br><span class="line">        //所以额外使用SBS状态判断，必须是SBS通信过程中的HDQ帧间idle才快速进入sleep，SBS通信标志由host写HDQ reg status设置和清除</span><br><span class="line">        if(hdq_ctrl.state == HDQ_STATE_IDLE) &#123;</span><br><span class="line">            // 检查SBS状态，如果SBS通信进行中则快速进入sleep以便下一帧HDQ</span><br><span class="line">            if (hdq_ctrl.registers.sbs_status_reg &amp; HDQ_SBS_STATUS_RUNNING) &#123;</span><br><span class="line">                stm_drive_sleep(10, STM_SLPMD_SLEEP);  // SBS通信中，快速sleep，下个HDQ break会马上WKUP</span><br><span class="line">            &#125; else&#123; //SBS通信结束，恢复timer和isr使能, 让VADC/CADC能更新</span><br><span class="line">                hdq_timer_restore(); //关闭hdq 1ms timer，避免频繁中断影响cadc等其他中断的更新，因为timer优先级很高</span><br><span class="line">                hdq_isr_restore(); //恢复cadc唤醒等中断，之前hdq启动时关闭了防止充电时频繁唤醒导致hdq通信不能进sleep</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>1.如果不用HDQ_SBS_STATUS_RUNNING限制毫秒级别sleep，会影响秒级的libfg更新算法，所有电量数据将不变。</p>
<p>2.WKUP中断内drive sleep不生效，所以只能在ms级别轮询里做。</p>
<h2 id="HDQ充电时无法进sleep"><a href="#HDQ充电时无法进sleep" class="headerlink" title="HDQ充电时无法进sleep"></a>HDQ充电时无法进sleep</h2><p>是因为CADC中断有触发条件：当电流大于CADC触发阈值，就会自动wakeup更新CADC。所以hdq drive sleep被cadc中断提前唤醒了。</p>
<p>解决：在HDQ帧开始禁用CADC wakeup， HDQ帧（或SBS帧）完成后restore CADC wakeup。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507291029945.png" alt="image-20250729102943925"></p>
]]></content>
      <categories>
        <category>电量计</category>
      </categories>
      <tags>
        <tag>电量计</tag>
      </tags>
  </entry>
  <entry>
    <title>电量计 -- 电池基础知识和电量计算法简介</title>
    <url>/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20%E7%94%B5%E6%B1%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E7%94%B5%E9%87%8F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="电量计-–-电池基础知识和电量计算法简介"><a href="#电量计-–-电池基础知识和电量计算法简介" class="headerlink" title="电量计 – 电池基础知识和电量计算法简介"></a>电量计 – 电池基础知识和电量计算法简介</h1><h2 id="算法背景简介"><a href="#算法背景简介" class="headerlink" title="算法背景简介"></a>算法背景简介</h2><h3 id="电池建模"><a href="#电池建模" class="headerlink" title="电池建模"></a>电池建模</h3><p>电量计芯片算法首先是建立在电池 &#x2F; 电芯建模的基础上。 由于电芯的SOC受到电池的电压，电池充放电电流以及温度的影响。</p>
<p>根据客户应用场景的需求， 将电芯按照不同的温度和电流进行充电和放电，得到不同场景的充放电数据。 通过大瞬科技自己研发的数据处理软件， 作为该种电池的基础模型数据保存下来， 储存在芯片 flash 或主机端中作为算法的内部数据使用。 当电池进行充放电时， 芯片固件会参考该数据， 对芯片的充放电 SOC 状态进行误差评估， 然后结合当前的电压， 电流和温度， 进行动态的修正。 抑制各种动态环境带来的偏差。</p>
<p>电量计建模会生成两种数据内容：</p>
<p>电池的OCV（Open Circuit Voltage）表，由于库伦积分法无法得到电池的初始SOC，所以在电池上电的初始阶段会应用此表查到的SOC来作为电池初始化的SOC.</p>
<p>电池在不同电压，不同电流以及不同温度下的SOC表格，此表用来作为安时积分法的SOC计算参考表格。<br>温度一般选取-10度，0度，25度和45度4个点。<br>电流根据客户的充放电应用选取3-4个点。<br>同时记录电池在不同温度和不同电流下不同SOC对应的电压点。<br>在实际应用中，对于温度或电流不在建模表范围内的点，采用专用算法进行插值处理。</p>
<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>电芯按照充放电状态，可以分为充充电状态，空闲状态和放电状态，三种状态会分别执行不同的逻辑。</p>
<p>对于充电状态：<br>在充电初始状态，使用当前电压，电流，温度和 SOH 值来对整体满充电芯容量进行预估。<br>在充电进行中，使用库仑计进行库伦积分，当温度和电流变化时，芯片会计算不同电流和温度下的库伦效率值，整合滤波算法来更新 SOC。<br>根据当前的电压和电流值，以及设定的截至电压和截至电流来判定 CC 和 CV 充电状态。<br>根据设定的截至电压和截至电流以及库伦积分值来判定是否达到满充。其中截至电压和截至电流作为主要判定条件。</p>
<p>对于放电状态：</p>
<p>在放电初始状态，使用当前电压，电流，温度和 SOH 值来对整体电芯的可用容量进行预估。<br>在放电进行中，使用库仑计进行库伦积分，结合 放电模型更新当前可用的有效容量和 SOC，当温度，电流和电压变化时，放电模型会自动更新电芯的有效容量，同时结合自适应 算法 来更新 SOC，保证 SOC 的精度。<br>在放电末端，SOC 小于 10%之后，根据放电的截止电压，对 SOC 值进行额外的滤波处理使其在尾端尽可能逼近截止电压，同时不会因为特定的应用情况而出现跳变。</p>
<p>对于空闲状态：</p>
<p>对于电流死区（10mA，可配置）以上的电流，库伦会记录电流积分数据并更新到SOC 上。<br>对于长时间处于空闲状态的电池，每隔一定时间（12h，可配置），使用电压查询OCV，得到 SOC，对当前的 SOC 进行滤波修正。<br>在无负载状态时，当温度发生变化，电芯电压可能会发生变化。为了避免终端用户在无负载情况下，直接观察到 SOC 下降或者上升，认为设备异常。在这种情况下，电量计 SOC 输出会维持不变。当电芯转入充电或者放电状态时，再根据实际电流，电压和温度情况调整电芯容量预估值，使 SOC 平滑过渡，准确达到充电截止或者放电截止。</p>
<h3 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h3><p>由于不同客户电池的放电容量不同，EOD（End of Discharge）电压不同，电池内阻不同，温度等其他参数对电量的影响也不同，所以在基于大瞬电量计的基础算法上，需根据电量计精度的测试结果来进行调参。<br>对于电池包端电量计，大瞬科技开发有专用的调参仿真软件进行调参。<br>对于主板端电量计，目前仍需实测方式进行调参。</p>
<p>充电精度测量：<br>在实际测试中，充电阶段以芯片报 0%开始，芯片达到 100%结束。通过统计该阶段的库仑计值，就可以计算出该充电阶段的标准 SOC 值。使用该值减去芯片输出的 RSOC 值就可以得到充电阶段 SOC 的误差值。同时充电也需要评估芯片充电截止时的截止电流与客户配置的截止电流之间的实际差异。<br>放电精度测量：<br>对于放电阶段同理，以满充状态为 100%，以芯片报 0%为放电完成。统计该阶段的库仑计值，计算出该放电阶段的标准 SOC 值。使用该值减去芯片输出的 RSOC 值就可以得到放电阶段 SOC 的误差值。放电阶段需要额外评估放电阶段的实际截止电压与客户配置的截止电压之间的差异。</p>
<h2 id="锂电池基础知识"><a href="#锂电池基础知识" class="headerlink" title="锂电池基础知识"></a>锂电池基础知识</h2><h3 id="常用电池参数"><a href="#常用电池参数" class="headerlink" title="常用电池参数"></a>常用电池参数</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211602675.png" alt="image-20250321160203631"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211602332.png" alt="image-20250321160221281"></p>
<h3 id="电池充电曲线"><a href="#电池充电曲线" class="headerlink" title="电池充电曲线"></a>电池充电曲线</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211602487.png" alt="image-20250321160244457"></p>
<h3 id="电池放电特性"><a href="#电池放电特性" class="headerlink" title="电池放电特性"></a>电池放电特性</h3><p>放电电流影响内阻压降</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211603864.png" alt="image-20250321160323833"></p>
<p>负载移除有瞬态效应</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211603115.png" alt="image-20250321160343073"></p>
<p>环境温度影响放电曲线</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211604683.png" alt="image-20250321160416649"></p>
<h3 id="循环次数"><a href="#循环次数" class="headerlink" title="循环次数"></a>循环次数</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211607520.png" alt="image-20250321160709488"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211607989.png" alt="image-20250321160721945"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211607159.png" alt="image-20250321160743128"></p>
<h2 id="电量计简介"><a href="#电量计简介" class="headerlink" title="电量计简介"></a>电量计简介</h2><h3 id="电量计功能"><a href="#电量计功能" class="headerlink" title="电量计功能"></a>电量计功能</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211608835.png" alt="image-20250321160835792"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211608143.png" alt="image-20250321160848105"></p>
<h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211610665.png" alt="image-20250321161013632"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211610250.png" alt="image-20250321161026216"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211611917.png" alt="image-20250321161050760"></p>
<h3 id="电量检测算法简介"><a href="#电量检测算法简介" class="headerlink" title="电量检测算法简介"></a>电量检测算法简介</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211611646.png" alt="image-20250321161131608"></p>
<h4 id="OCV查询"><a href="#OCV查询" class="headerlink" title="OCV查询"></a>OCV查询</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211611128.png" alt="image-20250321161159088"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211612406.png" alt="image-20250321161210368"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211612126.png" alt="image-20250321161223080"></p>
<h4 id="库伦监测"><a href="#库伦监测" class="headerlink" title="库伦监测"></a>库伦监测</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211612654.png" alt="image-20250321161249617"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211613724.png" alt="image-20250321161306688"></p>
<h3 id="通用算法流程"><a href="#通用算法流程" class="headerlink" title="通用算法流程"></a>通用算法流程</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211620706.png" alt="image-20250321162020664"></p>
]]></content>
      <categories>
        <category>电量计</category>
      </categories>
      <tags>
        <tag>电量计</tag>
      </tags>
  </entry>
  <entry>
    <title>电量计 -- 阻抗追踪算法移植和调试</title>
    <url>/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20%E9%98%BB%E6%8A%97%E8%BF%BD%E8%B8%AA%E7%AE%97%E6%B3%95%E7%A7%BB%E6%A4%8D%E5%92%8C%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="电量计-–-阻抗追踪算法移植和调试"><a href="#电量计-–-阻抗追踪算法移植和调试" class="headerlink" title="电量计 – 阻抗追踪算法移植和调试"></a>电量计 – 阻抗追踪算法移植和调试</h1><h2 id="V-term跳变导致R跳变"><a href="#V-term跳变导致R跳变" class="headerlink" title="V_term跳变导致R跳变"></a>V_term跳变导致R跳变</h2><p>放电电流的大小本身不会影响电池内阻，电池内阻是电池固有状态。</p>
<p>但是调整电流时，因为压降变化，V_term会有大幅度跳变，会影响内阻计算，导致内阻跳变。</p>
<p>这属于算法问题，并不是真实内阻有跳变。</p>
<p>方案：平滑V_term，使用avgcellmv</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202508041642079.png" alt="image-20250804164236977"></p>
]]></content>
      <categories>
        <category>电量计</category>
      </categories>
      <tags>
        <tag>电量计</tag>
      </tags>
  </entry>
  <entry>
    <title>电量计--77428的MCU sample代码交付</title>
    <url>/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--77428%E5%90%88%E5%B9%B6%E5%8F%82%E6%95%B0%E5%88%B0MCU%20baseline%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="电量计–77428的MCU-sample代码交付"><a href="#电量计–77428的MCU-sample代码交付" class="headerlink" title="电量计–77428的MCU sample代码交付"></a>电量计–77428的MCU sample代码交付</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>77428电量计的固件代码是固化在芯片内部ROM而不是Flash，无法下载更新。</p>
<p>一般客户需求是提供电量计配套的Host侧MCU sample代码，其中实现可配置参数的下载流程，不同的电池使用不同的参数建模数据，在客户MCU代码运行时下载到电量计。</p>
<p>可配置参数的来源：</p>
<p>（1）电池厂商提供的电池规格书文档和参数信息表excel，FAE和客户沟通获得。</p>
<p>（1）电芯特征数据：电芯拿到实验室 -&gt; 用循环仪器测试工具对电池循环充放电 -&gt; 得到循环仪原始采集文件csv，包括电压电流电荷 -&gt; 使用软件TableMaker从循环仪采集文件中提取出参数文件txt（RC table.txt和OCV table.txt），这部分需要FAE，软件开发，循环仪操作人协作。</p>
<p>可配置参数的写入：MCU host通过I2C给77428 chip中的F&#x2F;W（固化ROM）通信，写配置参数，以适配不同的电池模块。</p>
<h2 id="电池建模"><a href="#电池建模" class="headerlink" title="电池建模"></a>电池建模</h2><p>拿到客户电池，根据电池规格书的放电电流参数范围，决定要采集的电流范围；根据客户需求的温度范围，决定采集的温度范围。</p>
<p>77428 A2版本的固件要求电池建模必须至少采集4个电流 * 4个温度，共16种情况；每个采集得到电荷变化算出剩余容量RC</p>
<p>循环仪采集的建模数据集合示例：</p>
<p><a href="https://o2micro-my.sharepoint.com/:u:/p/thomas_hu/Ebuc3fWIJndPnko8315TasIBkeIUS6LSJDYvnNlXK7-8TQ?e=OqHlto">JG-20250321.7z</a></p>
<p>经过77428 版本的TableMaker工具转换成77428 MCU sample代码能用的txt，77428项目使用的电池特征参数文件是OCV.txt和RC.txt，建模工具输出的.c&#x2F;.h是给其他项目使用。</p>
<p><a href="https://o2micro-my.sharepoint.com/:u:/p/thomas_hu/ETi91u6I8-pFsxZtX3DQWlMB1pY2zaLarvceKMmWCYZR8g?e=FHpIXc">JG TABLE-20250321.7z</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211449916.png" alt="image-20250321144922884"></p>
<p>OCV table默认用OCV&#x2F;FalconLY里面的x数据（36个），用OCV目录的也可以，取y数据（36个）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211449354.png" alt="image-20250321144916301"></p>
<h2 id="MCU-sample代码合并电池参数的方法"><a href="#MCU-sample代码合并电池参数的方法" class="headerlink" title="MCU sample代码合并电池参数的方法"></a>MCU sample代码合并电池参数的方法</h2><p>（1）配OCV voltage，来源是OCV.txt的x或y。一般采样36个电压，电压范围来自规格书</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141702910.png" alt="image-20250214170240774"></p>
<p>（2）配RC.txt中的电压，电流，温度区间，以及RC容量值。</p>
<p>注意RC table的成员要和77428温度数组的项数目对应。</p>
<p>77428 A2版本FW规定死了Host代码配置的电流是4组，温度是4组，电压是36个采样，如果Host代码定义不符合，会写入参数报错。意味着循环仪对电池的采样测试至少要做4*4 &#x3D; 16组数据，可以多测但不能少。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201735883.png" alt="image-20250320173549846"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141716710.png" alt="image-20250214171651607"></p>
<p>（3）配MCU .h中的充放电参数，数据来自FAE提供的excel（源数据来自电池规格书）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141721613.png" alt="image-20250214172136527"></p>
<p>注：电池建模采集电压的范围要根据具体电池的规格书确定。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211405169.png" alt="image-20250321140503084"></p>
<p>注：DFCC table是调整算法的策略，其温度、电流、电压区间与电池建模的区间无关。没有调算法的需求就先不动。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211406800.png" alt="image-20250321140625765"></p>
<h2 id="MCU-sample代码分析"><a href="#MCU-sample代码分析" class="headerlink" title="MCU sample代码分析"></a>MCU sample代码分析</h2><p>MCU sample代码中有下发I2C配置77428的示例，客户需要根据自己的平台按类似的I2C包格式实现代码</p>
<p>（1）下载电池参数到77428。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141728106.png" alt="image-20250214172824010"></p>
<p>（2）通过77428自定义I2C SBS命令，查询电池状态</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141731968.png" alt="image-20250214173133900"></p>
<p>（3） SBS各命令的含义和格式要求见Firmware Specification</p>
<p>Host给电量计发的命令格式要按电量计specification规定，读写指定长度的数据，且带校验字节（PEC：Packet Error Check）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211413628.png" alt="image-20250321141318580"></p>
<h2 id="MCU-sample客户交付示例"><a href="#MCU-sample客户交付示例" class="headerlink" title="MCU sample客户交付示例"></a>MCU sample客户交付示例</h2><p><a href="https://o2micro-my.sharepoint.com/:u:/p/thomas_hu/EePUWfAMJ2BMqXaudjTf96MBcnzJImOLlWLKQ6FRuVb5Og?e=uZMr2S">SW6000_SD77428_MCU_20250214.zip</a></p>
<h2 id="MCU-sample内部测试环境：代码移植到STM32F407运行"><a href="#MCU-sample内部测试环境：代码移植到STM32F407运行" class="headerlink" title="MCU sample内部测试环境：代码移植到STM32F407运行"></a>MCU sample内部测试环境：代码移植到STM32F407运行</h2><p><a href="https://o2micro-my.sharepoint.com/:f:/p/thomas_hu/EmPIBLrw8ylMmO33dsfI9DQBnrkCqU9n5anKoXvQ-5et2w?e=dUpdfx">2.STM32F407测试环境</a></p>
<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>TODO</p>
]]></content>
      <categories>
        <category>电量计</category>
      </categories>
      <tags>
        <tag>电量计</tag>
      </tags>
  </entry>
  <entry>
    <title>开源学习 -- xv6完全注释</title>
    <url>/2023/05/17/%E5%BC%80%E6%BA%90%E5%AD%A6%E4%B9%A0%20--%20xv6-annotated-xv6%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<p>xv6是mit6.828操作系统课程的基于unix v6重新实现的教学操作系统。</p>
<p>本文英文部分是x86版本的xv6(mit6.828 2018及以前的版本)完全注释，github：<a href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p>本文中文部分是我学习xv6过程中添加了部分中文注解</p>
<h1 id="DAS-BOOT"><a href="#DAS-BOOT" class="headerlink" title="DAS BOOT"></a>DAS BOOT</h1><p>First things first: in order for a computer to run xv6, we need to load it from<br>disk into memory and tell the processor to start running it. So how does this<br>all happen?</p>
<h2 id="The-Boot-Process"><a href="#The-Boot-Process" class="headerlink" title="The Boot Process"></a>The Boot Process</h2><p>When you press the power button, the hardware gets initialized by a piece of<br>firmware called the BIOS (Basic Input&#x2F;Output System) that comes pre-installed on<br>the motherboard on a ROM chip. Nowadays, your computer probably uses UEFI loaded<br>from flash memory, but xv6 pretends like it’s 1995 and sticks with BIOS. Since<br>xv6 runs on x86 hardware, we’re gonna have to satisfy all the janky requirements<br>that come with that architecture, in addition to the BIOS’s requirements.</p>
<p>Now the BIOS has to load some <em>other</em> code called the boot loader from disk;<br>then it’s the boot loader’s job to load the OS and get it running. The boot<br>loader has to act as a middle-man because the BIOS has no idea where on the disk<br>you decided to put the OS.</p>
<p>The BIOS will look for the boot loader in the very first sector (512 bytes) of<br>whatever mass storage device you told it to boot from, which we’ll call the boot<br>disk. The processor will execute the instructions it finds there. This means<br>you have to make a choice: either your boot loader has to be less than 512 bytes<br>or you can split it up into smaller parts and have each part load the next one.<br>xv6 takes the first approach.</p>
<p>The BIOS loads the boot loader into memory at address 0x7C00, then sets the<br>processor’s <code>%ip</code> register to that address and jumps to it. Remember that <code>%eip</code><br>is the instruction pointer on x86? Okay cool. But why did I write <code>%ip</code> instead<br>of <code>%eip</code>? Well, the BIOS assumes we’re gonna be using 16 bits because of the<br>hellscape known as backwards-compatibility, so we’ve gotta pretend like it’s<br>1975 before we can pretend it’s 1995. The irony here is that this initial 16-bit<br>mode is called “real mode”. So on top of loading the OS, the boot loader will<br>also have to shepherd the processor from real mode to 32-bit “protected mode”.</p>
<p>One last detail: we’ll look at the Makefile and linker script later on, but for<br>now just keep in mind that the boot loader will be compiled separately from the<br>kernel, which will be compiled separately from all the user-space programs. This<br>makes it easier to make sure that the entire boot loader will fit in the first<br>512 bytes on disk. Eventually, the boot loader and the kernel will be stored on<br>the same boot disk together, and the user-space programs will be on a separate<br>disk that holds the file system.</p>
<h2 id="bootasm-S"><a href="#bootasm-S" class="headerlink" title="bootasm.S"></a>bootasm.S</h2><p>Boot loader space is tight, and we want to make sure our instructions are exact,<br>so we’re gonna start off in assembly. The “.S” file extension means it’s gonna<br>be assembled by the GNU assembler <code>as</code>, and we’re allowed to use C preprocessor<br>directives like <code>#include</code> or <code>#define</code> or whatever in the assembly code. Also,<br>xv6 uses AT&amp;T syntax, so if you read CS:APP or took the online course then it’ll<br>be familiar; if you don’t know what that means, then don’t worry about it.</p>
<h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>First we include some header files to use some constants; I’ll point them out<br>later. Next up, we gotta tell the assembler to generate 16-bit code, and set a<br>global label to tell the BIOS where to start executing code.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.code16         # Tell compiler to generate 16-bit code</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br></pre></td></tr></table></figure>

<p>Next up: you know how sometimes you can press a special key to tell the BIOS to<br>stop what it’s doing and let you pick a disk to boot from? Or you move your<br>mouse around in the BIOS menu and you see the pointer moving? Yeah, that needs<br>hardware interrupts in order to work, but right now, we don’t have the faintest<br>clue how to handle those if they happen, so let’s go ahead and turn those off.<br>There’s an x86 instruction to disable them by clearing the interrupt flag in<br>the CPU’s flags register.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cli</span><br></pre></td></tr></table></figure>

<p>Now we’ve gotta handle some of x86’s quirks. First off, we’re gonna need 20-bit<br>memory addresses, but we only have 16 bits to work with. x86 uses six segment<br>registers <code>%cs</code> (code segment), <code>%ds</code> (data segment), <code>%ss</code> (stack segment),<br><code>%es</code> (extra segment), <code>%fs</code> and <code>%gs</code> (general-purpose segments) to create 20-<br>bit addresses from 16-bit ones; we’re gonna need the first four. The BIOS<br>guarantees that <code>%cs</code> will be set to zero, but it doesn’t make any promises<br>about the others, so we have to clear them ourselves. We’re not using <code>%eax</code> for<br>anything yet, so we’ll use that to clear the others. The <code>w</code> at the end of <code>xorw</code><br>and <code>movw</code> means we’re operating on 16-bit words.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xorw    %ax,%ax</span><br><span class="line">movw    %ax,%ds     # Data segment</span><br><span class="line">movw    %ax,%es     # Extra segment</span><br><span class="line">movw    %ax,%ss     # Stack segment</span><br></pre></td></tr></table></figure>

<p>This next part is a total hack for backwards-compatibility: sometimes a virtual<br>address might get converted to a 21-bit physical address, and oh no, what are we<br>gonna do? Well, some hardware can’t deal with 21 bits, so it just ignores it,<br>but it’s 1995, so we’ve got fancy hardware that can use that extra bit. Wow, you<br>really know we’re in the future when you’ve got a whole 2 MB of RAM to work<br>with! So we have to tell the processor not to throw away that 21st bit. The way<br>we do that is by setting the second bit of the keyboard controller’s output port<br>to line high. I don’t know. Don’t ask me why. The output ports are 0x64 and<br>0x60, so we’re gonna wait until they’re not busy, then set the magic values that<br>will make this all work.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb     $0x64,%al   # Wait for not busy</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.1</span><br><span class="line"></span><br><span class="line">    movb    $0xd1,%al   # 0xD1 -&gt; port 0x64</span><br><span class="line">    outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb     $0x64,%al   # Wait for not busy</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.2</span><br><span class="line"></span><br><span class="line">    movb    $0xdf,%al   # 0xDF -&gt; port 0x60</span><br><span class="line">    outb    %al,$0x60</span><br></pre></td></tr></table></figure>

<h3 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h3><p>Now it’s time to switch to 32-bit “protected mode”. Up until now, the processor<br>has been converting virtual addresses to physical ones using those segment<br>registers which we cleared, so the mapping has been an identity map. But let’s<br>talk about how x86 converts 32-bit virtual addresses to physical ones; this is<br>important for the rest of the boot loader code as well as the OS, so you’re<br>gonna have to bear with me for this maelstrom of x86-specific details.</p>
<p>The x86 architecture does the conversion in two steps: first segmentation, then<br>paging. A virtual address starts off life as a <em>logical address</em>. Segmentation<br>converts that to a <em>linear address</em>, and paging converts that to a physical one.</p>
<p>A logical address consists of a 20-bit <em>segment selector</em> and a 12-bit offset,<br>with the segment bits before the offset bits, like <code>segment:offset</code>. The CPU’s<br>segmentation hardware uses those segment bits to pick one of those four segment<br>registers we cleared earlier, which acts as an index into a <em>Global Descriptor<br>Table</em> or GDT. Each entry of this GDT tells you where that segment is found in<br>memory using a base physical address and a virtual address for the maximum or<br>limit.</p>
<p>The GDT entry also has some permission bits for that segment; the segmentation<br>hardware will check whether each address can be written to and whether the<br>process generating the virtual address has the right permissions to access it.<br>These checks compare the GDT entry’s <em>Descriptor Privilege Levels</em>, also known<br>as <em>ring levels</em>, against the <em>Current Privilege Level</em>. x86 has four privilege<br>levels (0-3), so if you’ve ever heard of the kernel operating in ring 0 or user<br>code in ring 3, this is where it comes from.</p>
<p>Okay, so the GDT entry will give us the first 20 bits of the new linear address;<br>the offset bits stay the same. After that, the linear address is ready to be<br>converted to a physical address by the paging hardware. We’ll go over this<br>second half of the story in the virtual memory section. For now, the point is<br>this: xv6 is mostly gonna say no thank you to segmentation and stick to paging<br>alone for memory virtualization.</p>
<p>So we’re gonna set up our GDT to map all segments the exact same way: with a<br>base of zero and the maximum possible limit (with 32 bits, that works out to a<br>grand total of 4 GB, wow so much RAM, I can’t imagine ever needing more). We<br>have to stick this GDT somewhere in our code so we can point the CPU to it, so<br>we’ll put it at the end and throw a <code>gdtdesc</code> label on it. Now we can tell the<br>CPU to load it up with a special x86 instruction for that.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lgdt    gdtdesc</span><br></pre></td></tr></table></figure>

<h3 id="Protected-Mode"><a href="#Protected-Mode" class="headerlink" title="Protected Mode"></a>Protected Mode</h3><p>Good news, everyone! We’re finally ready to turn on protected mode, which we do<br>by setting the zero bit of the <code>%cr0</code> control register. Note that the <code>l</code> at the<br>end of the instructions here means we’re now using long words, i.e. 32 bits;<br><code>CR0_PE</code> is defined in the <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a><br>header file as 0x1.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    %cr0, %eax      # Copy %cr0 into %eax</span><br><span class="line">orl     $CR0_PE, %eax   # Set bit 0</span><br><span class="line">movl    %ax, %cr0       # Copy it back</span><br></pre></td></tr></table></figure>

<p>Oh wait, I lied. Enabling protection mode like we just did doesn’t change how<br>the processor translates addresses. We have to load a new value into a segment<br>register to make the CPU read the GDT and change its internal segmentation<br>settings. We can do that by using a long jump instruction, which lets us specify<br>a code segment selector. We’re just gonna jump to the very next line anyway, but<br>in doing so we’ll force the CPU to start using the GDT, which describes a 32-bit<br>code segment, so <em>now</em> we’re finally in 32-bit mode! Here, <code>SEG_KCODE</code> is a<br>constant defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as segment 1, for <code>%cs</code>; we bitshift it left by 3.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ljmp    $(SEG_KCODE&lt;&lt;3), $start32</span><br></pre></td></tr></table></figure>

<p>First we signal the compiler to start generating 32-bit code. Then we initialize<br>the data, extra, and stack segment registers to point to the <code>SEG_KDATA</code> entry<br>of the GDT; that constant is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as the segment for the kernel<br>data and stack. We’re not required to set up <code>%fs</code> and <code>%gs</code>, so we’ll just zero<br>them.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.code 32    # Tell assembler to generate 32-bit code now</span><br><span class="line">start32:</span><br><span class="line">    movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector</span><br><span class="line">    movw    %ax, %ds    # Data segment</span><br><span class="line">    movw    %ax, %es    # Extra segment</span><br><span class="line">    movw    %ax, %ss    # Stack segment</span><br><span class="line">    movw    $0, %ax     # Zero the segments not ready for use</span><br><span class="line">    movw    %ax, %fs</span><br><span class="line">    movw    %ax, %gs</span><br></pre></td></tr></table></figure>

<h3 id="The-Kernel-Stack"><a href="#The-Kernel-Stack" class="headerlink" title="The Kernel Stack"></a>The Kernel Stack</h3><p>Okay, last step in the assembly code now: we have to set up a stack in an unused<br>part of memory. In x86, the stack grows downwards, so the “top” of the stack–<br>that is, the most-recently-added byte–is actually at the bottom of the stack in<br>physical memory. It’s annoying, but we’re gonna have to keep track of that. The<br><code>%ebp</code> register points to the base of the stack (i.e., the first byte we pushed<br>onto the stack), and the <code>%esp</code> register holds the address of the top of the<br>stack (most-recently-pushed byte).</p>
<p>But where should we put the stack? The memory from 0xA_0000 to 0x10_0000 is<br>littered with a memory regions that I&#x2F;O devices are gonna be checking, so that’s<br>out. The boot loader starts at 0x7C00 and takes up 512 bytes, so that means it<br>ends at 0x7E00. So xv6 is gonna start the stack at 0x7C00 and have it grow down<br>from there, toward 0x0000 and away from the boot loader. Remember how back in<br>the beginning, we started off the assembly code with a <code>start</code> label? That means<br>that <code>start</code> is conveniently located at 0x7C00.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $start, %esp</span><br></pre></td></tr></table></figure>

<p>And we’re done with assembly! Time to move on to C code for the rest of the boot<br>loader. We’ll take over with a C function called <code>bootmain()</code>, which should<br>never return. The linker will take care of connecting the call here to its<br>definition in <a href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">bootmain.c</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    bootmain</span><br></pre></td></tr></table></figure>

<h3 id="Handling-Errors"><a href="#Handling-Errors" class="headerlink" title="Handling Errors"></a>Handling Errors</h3><p>Wait, what? There’s more assembly code after this? Why?</p>
<p>Well, if something goes wrong in <code>bootmain()</code>, then the function will return, so<br>we have to handle that here. Since we usually run OSes we’re developing in an<br>emulator like Bochs or QEMU, we’ll trigger a breakpoint and loop. Bochs listens<br>on port 0x8A00, so we can transfer control back to it there; this wouldn’t do<br>anything on real hardware.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    movw    $0x8a00, %ax    # 0x8a00 -&gt; port 0x8a00</span><br><span class="line">    movw    %ax, %dx</span><br><span class="line">    outw    %ax, %dx</span><br><span class="line">    movw    $0x8ae0, %ax    # 0x8ae0 -&gt; port 0x8a00</span><br><span class="line">    outw    %ax, %dx</span><br><span class="line">spin:</span><br><span class="line">    jmp     spin            # loop forever</span><br></pre></td></tr></table></figure>

<h3 id="The-Global-Descriptor-Table"><a href="#The-Global-Descriptor-Table" class="headerlink" title="The Global Descriptor Table"></a>The Global Descriptor Table</h3><p>Oh, and remember when we promised the hardware that we were gonna give it a GDT?<br>We even told it to load it from address <code>gdtdesc</code>, remember? Well, we have to<br>deliver on that promise now by defining the GDT here.</p>
<p>x86 expects that the GDT will be aligned on a 32-bit boundary, so we tell the<br>assembler to do that. Then we use the macros <code>SEG_NULLASM</code> and <code>SEG_ASM</code> defined<br>in <a href="https://github.com/mit-pdos/xv6-public/blob/master/asm.h">asm.h</a> to create three segments: a null segment, a segment for executable<br>code, and another for writeable data. The null segment has all zeroes; the first<br>argument to <code>SEG_ASM</code> has the permission bits, the second is the physical base<br>address, and the third is the maximum virtual address. As we said before, xv6<br>relies mostly on paging, so we set the segments to go from 0 to 4 GB so they<br>identity-map all the memory.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.p2align 2      # force 4-byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                             # null segment</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code segment</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)         # data segment</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word   (gdtdesc - gdt - 1)     # sizeof(gdt) - 1</span><br><span class="line">    .long   gdt                     # address of gdt</span><br></pre></td></tr></table></figure>

<h2 id="bootmain-c"><a href="#bootmain-c" class="headerlink" title="bootmain.c"></a>bootmain.c</h2><p>Okay, the rest of the boot loader is in C now! Most of the code here is just to<br>interact with the disk in order to read the kernel from disk and load it into<br>memory. Let’s start off by looking at <code>waitdisk()</code>.</p>
<h3 id="waitdisk"><a href="#waitdisk" class="headerlink" title="waitdisk"></a>waitdisk</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HEAD. DESK. Why all the magic numbers? At least we’re lucky that the name makes<br>it obvious what this function does; this won’t always be true in xv6. Okay, so<br>this function does only one thing: it loops until the disk is ready. Disk specs<br>are boring as all hell, so feel free to skip to the next section if you don’t<br>care about the particulars (I don’t blame you).</p>
<p>The usual way to talk to the disk is with Direct Memory Access (DMA), in which<br>devices are hooked up directly to RAM for easy communication. But we haven’t<br>initialized the disk at all or set up any drivers for it; that’s the OS’s<br>responsibility, not the boot loader’s. Even if we could ask the disk to give us<br>some data through memory-mapped I&#x2F;O, we disabled all interrupts, so we wouldn’t<br>know when it’s ready. So instead, we have to go back to assembly code (ugh, I<br>know) to access the disk directly.</p>
<p>Storage disks have all kinds of standardized specifications, among them IDE<br>(Integrated Drive Electronics) and ATA (Advanced Technology Attachment). The<br>ATA specs include a Programmed I&#x2F;O mode where data can be transferred between<br>the disk and CPU through I&#x2F;O ports. This is usually a huge waste of resources<br>because every byte has to be transferred through a port and the CPU is busy the<br>entire time, but right now beggars can’t be choosers.</p>
<p>Each disk controller chip has two buses (primary and secondary) for use with ATA<br>PIO mode; the primary bus sends data on port 0x1F0 and has control registers on<br>ports 0x1F1 through 0x1F7. In particular, port 0x1F7 is the status port, which<br>will have some flags to let us know what it’s up to. The sixth bit (or 0x40 in<br>hex) is the RDY bit, which is set when it’s ready to receive more commands. The<br>seventh bit (i.e., 0x80) is the BSY bit, which if set says the disk is busy.</p>
<p>Since interrupts are disabled, we’ll have to manually poll the status port in an<br>infinite loop until the BSY bit is not set but the RDY bit is: <code>inb()</code> is a C<br>wrapper (defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">x86.h</a>) for the x86 assembly instruction <code>inb</code>, which reads<br>from a port. We don’t care about any of the other status flags, so we’ll get rid<br>of them by bitwise-ANDing the result with 0xC0 &#x3D; 0x40 + 0x80. If the result of<br>that is 0x40, then only the RDY bit is set and we’re good to go.</p>
<p>Phew. That was a lot for just one line of code.</p>
<h3 id="readsect"><a href="#readsect" class="headerlink" title="readsect"></a>readsect</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Issue command</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);</span><br><span class="line">    outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read data</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you skipped the last section: this function reads a sector (which in the<br>current-year-according-to-xv6 of 1995 is 512 bytes) from disk. Good to see you<br>again, on to the next section for you!</p>
<p>If you powered through the pain and read about ATA PIO mode above, some of the<br>magic numbers here might be familiar. First we call <code>waitdisk()</code> to wait for the<br>RDY bit, then we send some stuff over ports 0x1F2 through 0x1F7, which we know<br>are the command registers for the primary ATA bus.</p>
<p>Note that <code>uint</code> is just a type alias for C’s <code>unsigned int</code>, defined in the<br>header file <a href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">types.h</a>. The <code>offset</code> argument is in bytes, and determines which<br>sector we’re gonna read; sector 0 has to hold the boot loader so the BIOS can<br>find it, and in xv6 the kernel will start on disk at sector 1.</p>
<p><code>outb()</code> is another C wrapper for an x86 instruction from <a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>; this one’s<br>the opposite of <code>inb()</code> because it sends data out to a port. The disk controller<br>register at port 0x1F2 determines how many sectors we’re gonna read. Ports 0x1F3<br>through 0x1F6 are where the sector’s address goes. If you <em>really</em> must know<br>(why?) they’re the sector number register, the cylinder low and high registers,<br>and the drive&#x2F;head register, in order. Port 0x1F7 was the status port above, but<br>it also doubles as the command register; we send it command 0x20, aka READ<br>SECTORS.</p>
<p>Then we wait for the RDY bit again before reading from the bus’s data register<br>at port 0x1F0, into the address pointed to by <code>dst</code>. Once again, <code>insl()</code> is a<br>C wrapper for the x86 instruction <code>insl</code>, which reads from a port into a string.<br>The <code>l</code> at the end means it reads one long-word (32 bits) at a time.</p>
<h3 id="readseg"><a href="#readseg" class="headerlink" title="readseg"></a>readseg</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(uchar *pa, uint count, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar *epa = pa + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round down to sector boundary</span></span><br><span class="line">    pa -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time. We&#x27;d write</span></span><br><span class="line">    <span class="comment">// more to memory than asked, but it doesn&#x27;t matter -- we load in increasing</span></span><br><span class="line">    <span class="comment">// order.</span></span><br><span class="line">    <span class="keyword">for</span> (; pa &lt; epa; pa += SECTSIZE, offset++) &#123;</span><br><span class="line">        readsect(pa, offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Okay, finally, we’re done with assembly and disk specs. We’re gonna read <code>count</code><br>bytes starting from <code>offset</code> into physical address <code>pa</code>. Note that <code>uchar</code> is<br>another type alias for <code>unsigned char</code> from <a href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>; this means that <code>pa</code> is a<br>pointer (which is 32 bits in x86) to some data where each piece is 1 byte.</p>
<p><code>epa</code> will point to the end of the part we want to read. Now, <code>count</code> might not<br>be sector-aligned, so we fix that. Declaring <code>pa</code> as a <code>uchar *</code> lets us do this<br>pointer arithmetic easily because we know that adding 1 to <code>pa</code> makes it point<br>at the next byte; if it were a <code>void *</code> like in <code>readsect()</code>, pointer arithmetic<br>would be undefined. (Actually, GCC lets you do it anyway, but GCC lets you get<br>away with a lot of crazy stuff, so let’s not go there.)</p>
<p>Now that we’ve got everything set up, we just call <code>readsect()</code> in a for loop to<br>read one sector at a time, and that’s it!</p>
<p>Some people have asked about the structure of some of the for loops in xv6,<br>because they don’t always use obvious index variables like <code>int i</code>. There are<br>plenty of reasons to hate C, but I think the way it structures for loops is by<br>far one of its most powerful features:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test condition; update statements) &#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When evaluating the for loop, C first executes anything in the initialization.<br>Then it checks whether the test condition is true; if so, it executes the code<br>inside the loop. Then it carries out the update statements before checking the<br>test condition again and runnning the code if it’s still true.</p>
<p>In the for loop above, the initialization is just an empty statement; all the<br>variables we want to use have already been set up, so we don’t need it and C<br>will just move on to the next step. The test condition is simple enough. But the<br>update statement actually increments both <code>pa</code> and <code>offset</code> at once before going<br>through the loop again.</p>
<p>Okay great, so now we can read from the disk into memory, so we’re all set up to<br>load the kernel and start running it!</p>
<h3 id="ELF-Files"><a href="#ELF-Files" class="headerlink" title="ELF Files"></a>ELF Files</h3><p>Before we move on to the star of the show, <code>bootmain()</code>, we need to talk about<br>how a computer can actually recognize a file as executable. When you compile<br>some code, the result gets spit out in a format that your machine can recognize,<br>load into memory, and run; it’s usually the linker’s job to do this. Most Unix<br>and Unix-like systems use the standardized Executable and Linkable Format, or<br>ELF, for this purpose.</p>
<p>ELF divides the executable file into sections: <code>text</code> (the code’s instructions),<br><code>data</code> (initialized global variables), <code>bss</code> (statically-allocated variables<br>that have been declared but not initialized), <code>stab</code> and <code>stabstr</code> (debugging<br>symbols and similar info), <code>rodata</code> (read-only data, usually stuff like string<br>literals).</p>
<p>An ELF file starts with a header which has a magic number: 0x7F followed by the<br>letters “ELF” represented as ASCII bytes; an OS can use this to recognize an ELF<br>file. The header also tells you the file’s type: it could be an executable, or a<br>library to be linked with executables, or something else. There’s a whole bunch<br>of other info in the header, like the architecture it’s made to run on, version,<br>etc., but we’re gonna ignore most of that.</p>
<p>The most important parts of the header are the part where it tells us where in<br>the file the processor should start executing instructions and the part that<br>describes the number of entries, on-disk offset, and size of the program header<br>table.</p>
<p>The program header table is an array that has one entry for each of the file<br>sections above that’s found in this program. It describes the offset in the file<br>where each section can be found along with the physical and virtual address at<br>which that section should be loaded into memory and the size of the section,<br>both in the file and in memory; these might differ if, e.g. the program contains<br>some uninitialized variables which don’t need to be stored in the file but do<br>need to have space in memory.</p>
<p>The kernel (along with all the user-space programs) will be compiled and linked<br>as ELF files, so <code>bootmain()</code> will have to parse the ELF header to find the<br>program header table, then parse that to load each section into memory at the<br>right address. xv6 uses a <code>struct elfhdr</code> and a <code>struct proghdr</code>, both defined<br>in <a href="https://github.com/mit-pdos/xv6-public/blob/master/elf.h">elf.h</a>, for this purpose.</p>
<p>Okay, back to the boot loader to finish up now!</p>
<h3 id="bootmain"><a href="#bootmain" class="headerlink" title="bootmain"></a>bootmain</h3><p>This is the C function that gets called by the first part of the boot loader<br>written in assembly. Its job will be to load the kernel into memory and start<br>running it at its entry point, a program called <code>entry()</code>.</p>
<p>Next up, we’re gonna use <code>readseg()</code> to load the kernel’s ELF header into memory<br>at physical address 0x1_0000; the number isn’t too important because the header<br>won’t be used for long; we just need some scratch space in some unused memory<br>away from the boot loader’s code, the stack, and the device memory-mapped I&#x2F;O<br>region. We’ll read 4096 bytes first at offset 0; <code>readseg()</code> turns that offset<br>into sector 1. Remember that we have to convert <code>elf</code> into a <code>uchar *</code> so that<br>the pointer arithmetic in <code>readseg()</code> works out the way we want it to.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> elfhdr *) <span class="number">0x10000</span>;</span><br><span class="line">    readseg((uchar *) elf, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>While we’re at it, let’s go ahead and make sure that what we’re loading really<br>is an ELF file and not some random other garbage because any of a million things<br>went wrong during the compilation process, or we got some rootkit that totally<br>corrupted the kernel or something. It’s not really the most robust of checks,<br>but <em>eh</em>. If something went wrong we’ll just return, since we know that the code<br>in <code>bootasm.S</code> is ready to handle that with some Bochs breakpoints.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have to look at the program header table to know where to find each of<br>the kernel’s segments. The <code>elf-&gt;phoff</code> field tells us the program header<br>table’s offset from the start of the ELF header, so we’ll set <code>ph</code> to point to<br>that and <code>eph</code> to point to the end of the table.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (<span class="keyword">struct</span> proghdr *) ((uchar *) elf + elf-&gt;phoff);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">eph</span> =</span> ph + elf-&gt;phnum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each entry in the program header table tells us where to find a segment, so<br>we’ll iterate over the entries, reading each one from disk and loading it up. In<br>this for loop, note that <code>ph</code> is a <code>struct proghdr *</code>, so incrementing it with<br><code>ph++</code> increments it by the size of a <code>struct proghdr</code> and not by one byte; this<br>makes it automatically point at the next entry in the table.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">        uchar *pa = (uchar *) ph-&gt;paddr;    <span class="comment">// address to load section into</span></span><br><span class="line">        readseg(pa, ph-&gt;filesz, ph-&gt;off);   <span class="comment">// read section from disk</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the segment&#x27;s size in memory is larger than the file image</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;memsz &gt; ph-&gt;filesz) &#123;</span><br><span class="line">            stosb(pa + ph-&gt;filesz, <span class="number">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That if statement at the end checks if the section’s size in memory should be<br>larger than its size in the file, in which case it calls <code>stosb()</code>, which is yet<br>another C wrapper from <a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a> for the x86 instruction <code>rep stosb</code>, which block<br>loads bytes into a string. It’s used here to zero the rest of the memory space<br>for that section. Okay, but why would we want to do that? Well, if the reason<br>it’s larger is because it has some uninitialized static variables, then we want<br>to make sure those start off holding zero (as the C standard requires) and not<br>whatever garbage value may have been there before.</p>
<p>Last part of the bootloader: let’s call the kernel’s entry point, <code>entry()</code>, and<br>get it running! But remember how the boot loader is compiled and linked<br>separately from the kernel? Yeah, that means we can’t just call <code>entry()</code> as a<br>function, because then the linker would go “Huh? What entry function? I don’t<br>have any <code>entry</code> function here in your symbol table. REJECTED.” And then it<br>would throw a huge error.</p>
<p>Luckily, the ELF header tells us where to find the entry point in memory, so we<br>could get a pointer to that address. That means… function pointers! If you’ve<br>never used function pointers in C before, then this won’t be the last time<br>you’ll see them in xv6, so check it out.</p>
<p>A C function is just a bunch of code to be executed in order, right? That means<br>it shows up in the ELF file’s <code>text</code> section, which will end up in memory. When<br>you call a regular old C function, the compiler just adds some extra assembly<br>instructions to throw a return address on the stack and update the registers<br><code>%ebp</code> and <code>%esp</code> to point to the new function’s stack on top of the old one. If<br>the function getting called has any arguments or local variables, they’ll get<br>pushed onto the stack too. Then the instruction register <code>%eip</code> gets updated to<br>point to the new function section, and that’s it. After the compiler is done,<br>the linker will replace the function’s name with its memory address in the<br><code>text</code> section, and voila, a function call.</p>
<p>The point of all this is that in C we can use pointers to functions; they just<br>point to the beginning of that function’s instructions in memory, where the<br><code>%eip</code> register would end up pointing if the function gets called. So in this<br>case, even though we’re not linking with the kernel, we can still call into the<br>entry point by getting its address from the ELF header, creating a function<br>pointer to that address, then calling the function pointer. The compiler will<br>still add all the usual stack magic, but instead of the linker determining where<br><code>%eip</code> should point, we’ll do that ourselves.</p>
<p>The first line below declares <code>entry</code> as a pointer to a function with argument<br>type <code>void</code> and return type <code>void</code>. Then we set <code>entry</code> to the address from the<br>ELF header, then we call it.</p>
<p>Again, this shouldn’t return, but if it does then it’s the last part of this<br>function, so this function will return back into the assembly boot loader code.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">void</span> (*entry)(<span class="type">void</span>);</span><br><span class="line">    entry = (<span class="type">void</span>(*) (<span class="type">void</span>)) (elf-&gt;entry);</span><br><span class="line">    entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s it! Starting from <code>entry()</code>, we’re officially out of the boot loader and<br>into the kernel.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, the assembly part of the boot loader (1) disabled interrupts, (2)<br>set up the GDT and segment registers so the segmentation hardware is happy and<br>we can ignore it later, (3) set up a stack, and (4) got us from 16-bit real mode<br>to 32-bit protected mode.</p>
<p>Then the C part of the boot loader just loaded the kernel from disk and called<br>into its entry point.</p>
<p>ELF headers will continue to haunt us in the kernel’s linker script and when we<br>load user programs from disk in <code>exec()</code>, and function pointers will make<br>another appearance when we get around to handling interrupts. The good news: the<br>boot loader is one of the most opaque parts of the xv6 code, full of boring<br>hardware specs and backwards-compatibility requirements, so if you made it this<br>far, it does get better!</p>
<p>(But it also gets worse… looking at you, <a href="https://github.com/mit-pdos/xv6-public/blob/master/mp.c">mp.c</a> and <a href="https://github.com/mit-pdos/xv6-public/blob/master/kb.c">kbd.c</a>…)</p>
<h1 id="The-Beginning-Entry-and-Paging"><a href="#The-Beginning-Entry-and-Paging" class="headerlink" title="The Beginning: Entry and Paging"></a>The Beginning: Entry and Paging</h1><h2 id="xv6’s-Memory-Layout"><a href="#xv6’s-Memory-Layout" class="headerlink" title="xv6’s Memory Layout"></a>xv6’s Memory Layout</h2><p>The whole point of virtualizing memory is to give users the illusion that they<br>can roam freely across a limitless field of memory without worrying their pretty<br>little heads about such boring details as how much physical memory their machine<br>actually has, or where kernel code is stored, or the fact that their seemingly-<br>continuous heap space is actually shattered into tons of tiny pages spread out<br>in possibly random parts of physical memory. As long as user code is well-<br>behaved, that illusion should hold up; if they do a no-no we’ll just smack them<br>with a segmentation fault.</p>
<p>One downside is that the kernel also has to use virtual memory, so we’re faced<br>with the potentially-complicated challenge of setting things up in physical<br>memory without knowing where anything is actually located in physical memory! So<br>xv6 does something that a lot of OSes do: it sets itself up as a higher-half<br>kernel. That means that in the virtual address space (from 0 to 4 GB), the<br>kernel will reside in the upper half starting at 2 GB, i.e. address 0x8000_0000<br>and up; user code will start at 0 and end at 2 GB. Because of this, <code>KERNBASE</code><br>is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a> as 0x8000_0000.</p>
<p>Then it sets up paging so that all of physical memory is identity-mapped to<br>virtual memory starting at 0x8000_0000. This makes it really convenient for the<br>kernel to figure out the physical address of a virtual address it’s using; just<br>subtract <code>KERNBASE</code> and you’re done. The <code>V2P</code> and <code>V2P_WO</code> macros defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a> do just that, and the <code>P2V</code> and <code>P2V_WO</code> add <code>KERNBASE</code> to a<br>physical address to get the kernel virtual address.</p>
<p>Note that I said “kernel virtual address”, not just any old virtual address.<br>Users don’t get these kinds of fancy privileges, because they shouldn’t be<br>worrying about where anything is in physical memory. They’re running through a<br>limitless field of virtual memory, remember? So user virtual addresses between 0<br>and 2 GB will get mapped to totally arbitrary locations in physical memory.</p>
<p>One consequence of this is that xv6 is limited to no more than 2 GB of physical<br>memory (instead of the 4 GB that 32-bit addresses allow for) in order to map it<br>all into the top 2 GB of virtual memory. In reality, it’s even less, for two<br>reasons: (1) we also need to map device I&#x2F;O regions into virtual memory, so<br>it’ll be a little less than 2 GB, and (2) it’s hard and annoying to figure out<br>how much physical memory is actually present on any given machine, so xv6 just<br>says to hell with all that and picks the totally arbitrary value of a puny 224<br>MB as the amount of available physical memory (that’s <code>PHYSTOP</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a>).</p>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>Remember when we talked about segmentation, and how we said we’d come back to<br>paging later? Guess what? It’s later.</p>
<p>So all virtual addresses are really “logical addresses”, and segmentation turns<br>those into “linear addresses”. In xv6, the boot loader set up the segmentation<br>hardware to use an identity map, so virtual addresses are the same as logical<br>addresses are the same as linear addresses. Now paging has to turn those linear<br>addresses into physical addresses. Just like segmentation uses a GDT and the<br>segment registers for its mapping, paging uses a page directory, page tables,<br>and the <code>%cr3</code> register.</p>
<p>First, imagine a world where every single time some user code throws up an<br>address (maybe it looks up a variable, or it calls a function, or it simply<br>needs to execute the next instruction), the CPU has to stop what it’s doing,<br>save all the user’s register contents, load up some kernel code, restore its<br>register contents, find out where its stack is, get it running, and then ask the<br>OS where that virtual address is actually located in physical memory. That would<br>be <em>so</em> slow. We don’t want that. We want the hardware to do all the address<br>conversions by itself, and involve the OS only minimally to set up a new page<br>directory when it starts a new process.</p>
<p>Instead, the x86 hardware uses one of its control registers, <code>%cr3</code>, to store a<br>pointer to a page directory in memory. Then every time it needs to map a linear<br>address to a physical one, it goes to that page directory and grabs the relevant<br>entry. That entry is a pointer to a page <em>table</em> somewhere else in memory, so<br>the processor grabs the right entry from there, which points to a 4096-byte page<br>in some other location.</p>
<p>A linear address has a three-part structure: the 10 most significant bits are an<br>index that picks an entry from the page directory, the next 10 bits are an index<br>to pick an entry from whatever page table we’ve been directed to, and the last<br>12 bits are an offset that determines where to look in the page that the page<br>table entry pointed to.</p>
<p>For example, let’s say we have a virtual address like 0x9C4A_02BF. If we convert<br>to binary, split it up, and convert back to hex, we can see that the 10 most<br>significant bits are 0x271, the next 10 are 0x0A0, and the last 12 are 0x2BF. So<br>the paging hardware would look at wherever <code>%cr3</code> is pointing to find the page<br>directory; let’s just call it <code>pgdir</code>. Then it would take entry <code>pgdir[0x271]</code><br>and go look wherever that’s pointing to find the right page table; let’s call<br>that <code>pgtab271</code>. Then it would take entry <code>pgtab271[0x0A0]</code> and look wherever<br>that’s pointing to find the right page, <code>pg</code>. <em>Then</em> it would finally<br>know that the corresponding physical address is <code>pg + 0x2BF</code>. Whew.</p>
<p>This still sounds super slow, so the paging hardware uses a cache called the<br>Translation Lookaside Buffer (TLB) to store recently-used mappings and make them<br>faster in the future. Since pages are 4096 bytes, it only needs to map a new<br>page if the addresses some code is asking for crosses a page boundary.</p>
<p>xv6 provides two macros, <code>PDX</code> and <code>PTX</code> defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>, to recover just the<br>page directory index bits or the page table index bits, respectively, from a<br>virtual address.</p>
<p>Finally: an important aspect of virtual memory is that each process should be<br>isolated from the others, and the kernel should be isolated from user processes.<br>So each process will get its own page directory, and each entry of that page<br>directory will say whether it’s present (i.e., mapped) or not. If it’s present,<br>then it points to a page table for that process; if it’s not present and we try<br>to access it, we’ll get a page fault or a general protection fault. Each entry<br>in a page table will also say whether that page is present and what kinds of<br>permissions it has. The bit flags for the permissions are (in order from least<br>to most significant bit):</p>
<ul>
<li>Bit 0: present.</li>
<li>Bit 1: read&#x2F;write.</li>
<li>Bit 2: user (otherwise only the kernel can access it).</li>
<li>Bit 3: write-through.</li>
<li>Bit 4: cache disabled.</li>
<li>Bit 5: accessed (for the TLB).</li>
<li>Bit 6: page size (we’ll talk about this later).</li>
<li>Bit 7: (unused).</li>
</ul>
<p>This way, since each process has its own page directory, page tables, and pages,<br>and each level has specific permissions set, they should never be able to<br>interfere with each other.</p>
<p>Again, most of the time, the kernel will just happily ignore all this and use<br>the mapping in the higher half of virtual memory for simplicity. Each user<br>process’s page directory will have the same mapping in the higher half so that<br>the kernel can keep doing what it’s doing no matter which user process is<br>currently running.</p>
<p>Anyway, back to the code! We left off after the boot loader had finished loading<br>the kernel into memory; it ended by calling an <code>entry()</code> function in the kernel.<br>We haven’t set up paging yet, so that’s next on our to-do list. But first, the<br>kernel is compiled and linked using a <em>linker script</em>, so we’ll have to look at<br>that to understand how that sets up memory the way we want it.</p>
<h2 id="kernel-ld"><a href="#kernel-ld" class="headerlink" title="kernel.ld"></a>kernel.ld</h2><p>The gory details of linker scripts as a whole are outside the scope of these<br>posts, so I’m gonna gloss over a lot of the parts of this file and focus on<br>the important pieces.</p>
<p>It’s important to understand what a linker does in a rough sense, so I’ll just<br>generalize and wave my hands around and say that a compiler takes code in a<br>high-level language and converts it to assembly, an assembler takes that<br>assembly code and turns it into machine code, and a linker takes a whole bunch<br>of machine code files (including any code for library functions) and links them<br>all together into a single executable file.</p>
<p>注释: compiler -&gt; assembler -&gt; linker, high-level language -&gt; asm code -&gt; machine code</p>
<p>Linking involves three steps that are important for us here: first, the linker<br>has to assign each piece of code a location in memory, so that different<br>variables, functions, etc. don’t end up colliding; then it replaces references<br>to that object with its address. Second, it has to resolve any outstanding<br>symbols (variables, functions, etc.) in each file by looking them up in all the<br>other files and replacing them with those addresses; the linker can define its<br>own symbols too. Third, it has to create an output file in a format that the OS<br>can use, like ELF.</p>
<p>注释: 链接的本质是将符号(symbol)替换为地址值(address)，symbol主要指函数；链接输出二进制程序例如elf</p>
<p>xv6 has decided that command-line flags are too basic for it, so instead it’ll<br>use a linker script <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a> for the GNU linker.</p>
<p>We start off by specifying the output format (32-bit ELF), the architecture<br>(x86, also known as i386), and the entry point to start executing code. The<br>convention is to call the entry point <code>_start</code>; the ELF header will include its<br>address, which is how we were able to call it from the boot loader.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure>

<p>Next up come the sections. Remember the ELF sections <code>text</code>, <code>rodata</code>, <code>data</code>,<br><code>bss</code>, and <code>stab</code>? Well we’ve gotta tell the linker where to set them up in<br>memory, using commands like <code>. = address</code>. These are virtual addresses, so since<br>we want to set up our kernel in the higher half of virtual memory, we’ll tell it<br>to link the code start at 0x8010_0000. Again, we use that address instead of<br>0x8000_0000 (which maps to physical address 0) because we have to avoid the<br>address spaces of the boot loader and the memory-mapped I&#x2F;O devices.</p>
<p>We can also tell the linker where in physical memory the code should be placed<br>(in linker script lingo, its “load address”) using the <code>AT(address)</code> command.<br>We’ll use the physical address 0x0010_0000, since that maps to virtual address<br>0x8010_0000.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x80100000;</span><br><span class="line"></span><br><span class="line">    .text : AT(0x100000) &#123;</span><br><span class="line">        /* this part tells the linker which files to include in this section */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* more sections here... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s one other detail we should check out: the linker can create its own<br>symbols using the <code>PROVIDE(symbol = .)</code> command. If the code happens to declare<br>its own variable <code>symbol</code>, then the linker will just throw away its own version<br>of it, but if the code uses <code>symbol</code> without defining it, then the linker will<br>replace those references with the contents of that memory location.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* virtual address and text sections are defined as above */</span><br><span class="line"></span><br><span class="line">    PROVIDE(etext = .);     /* etext will be at the address right after the end</span><br><span class="line">                            of the text section */</span><br><span class="line"></span><br><span class="line">    /* rodata, stab, and stabstr sections defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(data = .);      /* data will be at the address at the very beginning</span><br><span class="line">                            of the data section */</span><br><span class="line"></span><br><span class="line">    /* data section defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(edata = .);     /* edata will be at the address right after the end</span><br><span class="line">                            of the data section */</span><br><span class="line"></span><br><span class="line">    /* bss section defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(end = .);       /* end will be at the very last address at the end</span><br><span class="line">                            of the entire kernel code */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Those variables will be used later in the kernel code; not so much for their<br>contents but for their addresses, as pointers to the virtual addresses of<br>specific parts of the kernel’s code in memory. On to the kernel!</p>
<h2 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h2><p>I have bad news. That <code>entry()</code> function that the boot loader called? It’s in<br>assembly again. :(</p>
<h3 id="Multiboot-Header"><a href="#Multiboot-Header" class="headerlink" title="Multiboot Header"></a>Multiboot Header</h3><p>Okay, so first off, we’ve got some more hideous specs to deal with for a bit in<br>the form of a multiboot header. Multiboot is a specification that lets boot<br>loaders load up kernel code in a standardized way; the GNU boot loader GRUB uses<br>it. So this part is mostly here in case you want to run xv6 on real hardware<br>using GRUB; feel free to skip to <code>entry()</code> below.</p>
<p>The original Multiboot specification has since been replaced with Multiboot 2,<br>but again, it’s 1995, so we don’t know about that yet.</p>
<p>Multiboot helps compliant kernels and boot loaders identify each other using a<br>special header. The header must be completely contained in the first 8192 bytes<br>of the kernel’s image, and it must be 32-bit aligned. The header contains three<br>things: (1) a magic number used for mutual identification and recognition<br>(0x1BADB002 for kernels, 0x2BADB002 for boot loaders), (2) some flags for the<br>kernel to inform the boot loader what the kernel requires in order to run<br>successfully, and (3) a 32-bit unsigned checksum which when added to the other<br>two fields must have a 32-bit unsigned sum of zero. Depending on the flags that<br>are set, there may be other components to the Multiboot header.</p>
<p>So we’ll start by creating a <code>multiboot_header</code> label at the beginning of the<br>file (and thus, the beginning of the kernel image) and making sure it’s aligned<br>to 32 bits.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.p2align 2      # Force 4-byte alignment</span><br><span class="line">.text</span><br><span class="line">.globl multiboot_header</span><br><span class="line">multiboot_header:</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Now we’ll just add the magic number, set the flags to 0 to indicate no special<br>requirements, and add the checksum.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define magic 0x1badboo2</span><br><span class="line">#define flags 0</span><br><span class="line">.long magic</span><br><span class="line">.long flags</span><br><span class="line">.long (-magic-flags)</span><br></pre></td></tr></table></figure>

<p>And that’s it!</p>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>Back in <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, we said that the linker would set up the kernel’s ELF<br>header to specify the kernel’s entry point using <code>_start</code>, but <code>_start</code> itself<br>wasn’t actually defined there, so we have to do that first. We don’t know where<br>this code will end up in memory, so we’ll define an <code>entry</code> label and set<br><code>_start</code> to the address of <code>entry</code>. Note that the linker script used virtual<br>addresses in the higher half, but we haven’t set up paging yet, so we’ll have to<br>convert it to a physical address using one of the macros we mentioned earlier.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start = V2P_WO(entry)</span><br><span class="line">.globl entry</span><br></pre></td></tr></table></figure>

<p>Next up we want to finish setting up virtual memory by enabling paging, but<br>that’s all kinds of complicated, so we’re gonna start off with a super simple<br>version of paging. Part of that difficulty is that there’s a bootstrap problem:<br>we need to allocate pages to hold the page tables themselves, but we can’t use<br>pages without page tables… uhh…</p>
<p>We’ll solve that by starting off with a basic, super-simple page directory where<br>only two entries are mapped: the first entry maps virtual addresses 0 to 4 MB to<br>physical addresses 0 to 4 MB, and the second entry maps virtual addresses<br><code>KERNBASE</code> to <code>KERNBASE</code> + 4MB to physical addresses 0 to 4 MB. One consequence<br>is that the entire kernel code and data has to fit in 4 MB.</p>
<p>Why the two entries pointing to the same place? It’s to solve another bootstrap<br>problem. The kernel is currently running in physical addresses close to 0. Once<br>we enable paging and start using virtual addresses in the higher half, the stack<br>pointer <code>%esp</code>, instruction pointer <code>%eip</code>, even the pointer in <code>%cr3</code> to the<br>page directory itself will all still point to low addresses until we update<br>them. But updating them requires executing instructions, which would require<br>accessing low addresses a few more times. If we left out the low addresses, we’d<br>get a page fault, and since we don’t have exception handlers set up yet, that<br>would cause a double fault, which would turn into the dreaded <strong>TRIPLE FAULT</strong>,<br>in which the processor enters an infinite reboot loop. So yeah, point is, we<br>need both the low and high mappings for now; we’ll get rid of the low mappings<br>once we’re done setting up.</p>
<p>But wait! Aren’t page directory entries supposed to point to page tables? How<br>can they point directly to pages here? It turns out that x86 can skip that<br>second layer altogether if we use so-called “huge” pages of 4 MB in size instead<br>of the usual 4 KB. In the long run, this could lead to internal fragmentation,<br>but it does cut down on the overhead and allows a faster set-up. Plus we’re only<br>gonna use them for a minute while we get ready for the full paging ordeal.</p>
<p>To use 4 MB pages, we have to enable x86’s Page Size Extension (PSE) by setting<br>the fourth bit in the <code>%cr4</code> register. <code>CR4_PSE</code> is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as 0x10,<br>or 00010000 in binary.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry:</span><br><span class="line">    movl    %cr4, %eax</span><br><span class="line">    orl     $(CR4_PSE), %eax</span><br><span class="line">    movl    %eax, %cr4</span><br></pre></td></tr></table></figure>

<p>We need a page directory before we can set up paging; again, basic version now,<br>full glorious page directory later. We’re gonna do the same thing we did in the<br>boot loader where we tell the processor to load the page directory now but then<br>procrastinate actually writing it; this time, we’ll write it in C and call it<br><code>entrypgdir</code>. Then we’ll load its physical address into register <code>%cr3</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class="line">movl    %eax, %cr3</span><br></pre></td></tr></table></figure>

<p>Now we can enable (a basic version of) paging! We tell the CPU to start using<br>the page directory in <code>%cr3</code> by setting bit 31 (paging) of register <code>%cr0</code>; we<br>can also set bit 16 (write protect) of the same register to prevent writing to<br>any pages that the page directory and page tables have marked as read-only.<br><code>CR0_PG</code> and <code>CR0_WP</code> are defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> to set these bits.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $(CR0_PG|CR0_WP), %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>

<p>Now remember how the processor is still running at low addresses? Yeah, let’s<br>fix that. First we’ll make a new kernel stack in the higher half that will still<br>be valid even after we get rid of the lower address mappings. We’ll have the<br>linker save some space for us under the symbol <code>stack</code> and set it up there;<br><code>KSTACKSIZE</code> is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 4096 bytes. So we just set the stack<br>pointer register <code>%esp</code> to the top of that section in order to let the stack<br>grow down toward the address of <code>stack</code>. Again, we’ll procrastinate actually<br>defining <code>stack</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $(stack + KSTACKSIZE), %esp</span><br></pre></td></tr></table></figure>

<p>Now we want to call into the <code>main()</code> function, but we don’t just want to do<br>that the usual assembly way of <code>call main</code>. That would generate a jump relative<br>to the current value of <code>%eip</code>, which is still in low addresses. We’ll use an<br>indirect jump instead.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     $main, %eax</span><br><span class="line">jmp     *%eax</span><br></pre></td></tr></table></figure>

<p>Finally, we need to get around to reserving space for the stack. We can do that<br>with the assembler instruction <code>.comm symbol, size</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.comm stack, KSTACKSIZE</span><br></pre></td></tr></table></figure>

<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>Awesome, back to C code now! Remember how we procrastinated actually defining<br><code>entrypgdir</code>? Let’s do that now; it’s at the bottom of <a href="https://github.com/mit-pdos/xv6-public/blob/master/main.c">main.c</a>.</p>
<h3 id="entrypgdir"><a href="#entrypgdir" class="headerlink" title="entrypgdir"></a>entrypgdir</h3><p>What in the world is this?!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entrypgdir[NPDENTRIES] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = (<span class="number">0</span>) | PTE_P | PTE_W | PTE_PS,</span><br><span class="line">    [KERNBASE&gt;&gt;PDXSHIFT] = (<span class="number">0</span>) | PTE_P | PTE_W | PTE_PS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Okay, bear with me; I promise it’s not too bad.</p>
<p>First, the <code>__attribute__</code> tells the compiler and linker that the page directory<br>should be placed in memory at an address that’s a multiple of <code>PGSIZE</code> (4096<br>bytes); that’s just a requirement of the paging hardware.</p>
<p>Next, we define <code>entrypgdir</code> as an array of <code>NPDENTRIES</code> (1024, according to<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>), each of type <code>pde_t</code> (a type alias for <code>unsigned int</code>, according to<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>).</p>
<p>Then we initialize the entries: in C, you’re allowed to initialize an array by<br>specifying the values of specific enties; all other enties become zero. You<br>specify an entry by putting its index in square brackets before its value, so<br><code>[2] 5</code> will set the entry with index 2 to be 5. Here we initialize the entries<br>with indices 0 and <code>KERNBASE &gt;&gt; PDXSHIFT</code>, which is the same thing as<br><code>PDX(KERNBASE)</code>, AKA the page directory index corresponding to the virtual<br>address <code>KERNBASE</code>, AKA 0x8000_0000. So basically, we’ve initialized the page<br>directory entries corresponding to the low virtual address 0 and the high<br>virtual address <code>KERNBASE</code>.</p>
<p>We set their value to 0, because we want them to map to physical addresses from<br>0 up to 4 MB. Oh, and remember how page directories and page tables can also<br>hold permission flags? We want to set flags to say that these pages are present<br>(so that accessing them doesn’t cause a page fault), writeable, and 4 MB in<br>size; those are defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as <code>PTE_P</code>, <code>PTE_W</code>, and <code>PTE_PS</code>. We can<br>combine them all together by bitwise-ORing them.</p>
<p>And we’re done!</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>The code in <a href="https://github.com/mit-pdos/xv6-public/blob/master/entry.S">entry.S</a> finished up by calling into the C function <code>main()</code>, which<br>is where the core set-up happens before we can start running processes. It calls<br>into basically every single part of the xv6 kernel, so we can’t go through all<br>the functions line-by-line yet; instead I’ll just give you an overview of what<br>they do.</p>
<ul>
<li><code>kinit1()</code> solves another bootstrap problem around paging: we need to allocate<br>  pages in order to use the rest of memory, but we can’t allocate those pages<br>  without first freeing the rest of memory, which requires allocating them…<br>  You see what I mean. This function will free the rest of memory between the<br>  <code>end</code> of the kernel code (defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, remember?) and 4 MB.</li>
<li><code>kvmalloc()</code> allocates a page of memory to hold the fancy full-fledged page<br>  directory, sets it up with mappings for the kernel’s instructions and data,<br>  all of physical memory, and I&#x2F;O space, then switches to that page directory<br>  (leaving poor old <code>entrypgdir</code> in the trash).</li>
<li><code>mpinit()</code> detects hardware components like additional CPUs, buses, interrupt<br>  controllers, etc. Then it determines whether this machine supports this<br>  crazy new idea where you can have multiple CPU cores. Wow, 1995 is crazy.</li>
<li><code>lapicinit()</code> programs this CPU’s local interrupt controller so that it’ll<br>  deliver timer interrupts, exceptions, etc. when we’re ready for them later.</li>
<li><code>seginit()</code> sets up this CPU’s kernel segment descriptors in its GDT; we still<br>  won’t really use segmentation, but we’ll at least use the permission bits.</li>
<li><code>picinit()</code> disables the <em>ancient</em> PIC interrupt controller that literally no<br>  one has ever used since the APIC was introduced in 1989. I don’t even know<br>  what to say. I guess I was mistaken when I assumed it was 1995; I don’t<br>  know.</li>
<li><code>ioapicinit()</code> programs the I&#x2F;O interrupt controller to forward interrupts<br>  from the disk, keyboard, serial port, etc., when we’re ready for them later.<br>  Each device will have to be set up to send its interrupts to the I&#x2F;O APIC.</li>
<li><code>consoleinit()</code> initializes the console (display screen) by adding it to a<br>  table that maps device numbers to device functions, with entries for reading<br>  and writing to the console. It also sets up the keyboard to send interrupts<br>  to the I&#x2F;O APIC.</li>
<li><code>uartinit()</code> initializes the serial port to send an interrupt if we ever<br>  receive any data over it. xv6 uses the serial port to communicate with<br>  emulators like QEMU and Bochs.</li>
<li><code>pinit()</code> initializes an empty process table so that we can start allocating<br>  slots in it to processes as we spin them up.</li>
<li><code>tvinit()</code> sets up and interrupt descriptor table (IDT) so that the CPU can<br>  find interrupt handler functions to deal with exceptions and interrupts when<br>  they come.</li>
<li><code>binit()</code> initializes the buffer cache, a linked list of buffers holding<br>  cached copies of disk data for more efficient reading and writing.</li>
<li><code>fileinit()</code> sets up the file table, a global array of all the open files in<br>  the system. There are other parts of the file system that need to be<br>  initialized like the logging layer and inode layer, but those might require<br>  sleeping, which we can only do from user mode, so we’ll do that in the first<br>  user process we set up.</li>
<li><code>ideinit()</code> initializes the disk controller, checks whether the file system<br>  disk is present (because both the kernel and boot loader are on the boot<br>  disk, which is separate from the disk with user programs), and sets up disk<br>  interrupts.</li>
<li><code>startothers()</code> loads the entry code for all other CPUs (in <a href="https://github.com/mit-pdos/xv6-public/blob/master/entryothers.S">entryothers.S</a>)<br>  into memory, then runs the whole setup process again for each new CPU.</li>
<li><code>kinit2()</code> finishes initializing the page allocator by freeing memory between<br>  4 MB and <code>PHYSTOP</code>.</li>
<li><code>userinit()</code> creates the first user process, which will run the initialization<br>  steps that have to be done in user space before spinning up a shell.</li>
<li><code>mpmain()</code> loads the interrupt descriptor table into the CPU so that we’re<br>  finally completely ready to receive interrupts, then calls the <code>scheduler()</code><br>  function in <a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a>, which enables interrupts on this CPU and starts<br>  scheduling processes to run. <code>scheduler()</code> never returns, so at that point<br>  we’re completely done with setup and we’re running the OS proper.</li>
</ul>
<h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>The entry code in the xv6 kernel had one job: to set up paging. It kind of<br>failed at that job, but not for lack of trying! There are just all kinds of<br>Catch-22s when it comes to paging, so at least it got us partway there by making<br>a temporary page directory to tide us over until we can throw it away and never<br>look back.</p>
<p>We also took a sneak peek at all the setup code in <code>main()</code>; we’re gonna end up<br>going through it all, but at least now you should have enough of an idea of<br>what’s going on that you can more or less skip around and look at what you need.</p>
<h1 id="Detour-Spin-Locks"><a href="#Detour-Spin-Locks" class="headerlink" title="Detour: Spin-Locks"></a>Detour: Spin-Locks</h1><p>So I know I said I wasn’t expecting you to have finished the OSTEP section on<br>concurrency, but xv6 uses locks all over the place, so we’re gonna have to get<br>comfortable with them right away. Luckily, xv6 primarily uses spin-locks, which<br>are super simple and work on bare metal; a lot of the more complex&#x2F;more awesome<br>locks that OSTEP talks about require an OS beneath them.</p>
<p>I’ll give a brief intro to concurrency first in case you haven’t made it to that<br>part in OSTEP; then we’ll turn to the spin-lock implementation in xv6.</p>
<h2 id="A-Very-Brief-Poor-Man’s-Intro-to-Concurrency"><a href="#A-Very-Brief-Poor-Man’s-Intro-to-Concurrency" class="headerlink" title="A Very Brief, Poor-Man’s Intro to Concurrency"></a>A Very Brief, Poor-Man’s Intro to Concurrency</h2><p>TL;DR: Concurrency is your worst nightmare. It’ll cause bugs in the places where<br>you least expect it, and they won’t even be consistent: your code might work 95%<br>of the time, but every once in a while it’ll randomly fail and you’ll have no<br>idea why. The good news: xv6 handles it in a super-simple way, so we’ll get to<br>appreciate it as we go along. If you’re like me, you might also see the code use<br>locks when you wouldn’t have thought they were needed, and then you’ll come to<br>appreciate just how clever the xv6 authors are.</p>
<p>First off, stop reading this and go watch the discussion of data races and locks<br>in <a href="https://www.youtube.com/watch?v=LzElj46saa8&t=8762s">the last few minutes of the CS 50 2021 lecture on SQL</a>.<br>I’m serious, go watch it right now; this post will still be here.</p>
<p>Okay, I’m gonna assume you’ve seen it now; you should have a decent sense of the<br>main issues with data races and how locks solve them. But the CS 50 lecture<br>skipped some details about locks: (1) what Brian (the TA) does when he finds a<br>locked fridge, (2) how locks are implemented in code, and (3) deadlocks.</p>
<h3 id="What-Does-Brian-Do"><a href="#What-Does-Brian-Do" class="headerlink" title="What Does Brian Do?"></a>What Does Brian Do?</h3><p>Let’s say process <code>david</code> is running on one thread, and it needs to use some<br>resource (a global variable maybe, or an I&#x2F;O device like the disk or console)<br>that other threads might want to use too, so <code>david</code> acquires the lock for that<br>resource. Then process <code>brian</code> comes along and wants to use the same resource at<br>the same time. This could cause a data race, but luckily we’ve thought ahead and<br>used a lock, so <code>brian</code> can’t access it until <code>david</code> is done with it and<br>releases the lock.</p>
<p>First of all, we better hope <code>david</code> remembers to release the lock; otherwise<br><code>brian</code> (and all other processes, even the kernel) will <em>never</em> be able to use<br>that resource. But assuming we’re smart and remembered to release it, what does<br>the <code>brian</code> process do in the meantime?</p>
<p>Well, maybe <code>brian</code> has some other work to do that he can get started on in the<br>meantime. But what would that mean for an OS? How would we know, in general,<br>whether the lines of code that follow the use of a shared resource can be safely<br>executed if we haven’t used that resource yet? That sounds impossible to figure<br>out without knowing ahead of time what the resource is and how it’s used, so<br>let’s just go ahead and skip that idea.</p>
<p>Another option that’s actually used often in the real world is for <code>brian</code> to<br>stop trying and go to sleep. Maybe he can put a note on himself asking <code>david</code><br>to wake him up when he gets back with the milk. So in code, that might look like<br><code>brian</code> signaling the OS and letting it run a different process until the lock<br>is released. That sounds nice and all, but at this early stage in our kernel, we<br>don’t even have processes or a scheduler yet, let alone a notion of sleeping.</p>
<p>Okay, another option: what if <code>brian</code> just spins around in circles, or twiddles<br>his thumbs, or does jumping jacks or whatever until <code>david</code> releases the lock?<br>In code, that means looping over and over forever until the lock is released.<br>That would be horribly inefficient; think of all the CPU time wasted when one<br>process just loops over and over again while another process does something slow<br>while holding a lock! But it’s also the approach that xv6 is gonna take, because<br>at the end of the day, our kernel is still in baby stages and beggars can’t be<br>choosers. So xv6 uses <em>spin-locks</em> with loops that only stop when we acquire a<br>lock.</p>
<p>This means we should be careful when using locks to acquire them only at the<br>last possible moment when they’re absolutely needed, and release them as soon as<br>they’re no longer required, in order to limit the amount of wasted CPU cycles.</p>
<h3 id="Implementing-Locks"><a href="#Implementing-Locks" class="headerlink" title="Implementing Locks"></a>Implementing Locks</h3><p>We can implement locks as a simple boolean variable: if it’s true, then someone<br>else is using the resource behind the lock. If it’s false, then it’s unused and<br>you can go ahead and take it. So an <code>acquire()</code> function sets the lock to <code>true</code><br>and a <code>release()</code> function sets it back to <code>false</code>. Done!</p>
<p>But it’s not so simple: there’s actually a race condition hidden in the very<br>idea of a lock. Think about it for a second: a lock protects some shared<br>resource, right? And a shared resource is something that more than one process<br>wants to use? But a lock is itself a thing that more than one process wants to<br>use… so we haven’t actually gotten rid of the race condition. (FLIPS TABLE.)</p>
<p>We have another Catch-22 on our hands, but this time we can’t get rid of it with<br>a clever software trick like we did with the <code>entrypgdir</code>. The issue is that no<br>matter how well we write our code, it will always require more than one step:<br>first we have to check whether the lock is <code>true</code>, then we have to set it to<br><code>true</code>. But if someone else is doing the same thing at the same time, our<br>instructions might get executed in parallel and then we’d both acquire the lock<br>at the same time -&gt; RACE CONDITION.</p>
<p>The solution will require hardware support, using <em>atomic</em> instructions – these<br>are hardware instructions that are indivisible; no other code can execute in<br>between ours. One example is the x86 instruction <code>xchg</code>, which atomically reads<br>a value from memory, updates it to a new value, and returns the old value.</p>
<p>Now we’re good! A lock can still be a boolean variable but now <code>acquire</code> has to<br>use <code>xchg</code>: it should get the old value while simultaneously updating it to<br><code>true</code>.</p>
<p>Atomic instructions have more overhead than regular ones, so we should only use<br>them when they’re required, like in locks, but otherwise we can stick to the<br>regular instructions we’ve always used.</p>
<p>There’s one other detail we should be careful about: a lot of the locks in xv6<br>protect resources that are needed by both interrupt handlers and kernel or user<br>code. For example, we might use a process table lock to protect the list of all<br>currently running processes; suppose some kernel code has acquired the lock in<br>order to run a new process. What happens if a timer interrupt goes off at that<br>moment? The timer interrupt handler function might need to acquire the lock in<br>order to switch processes, but it’s already being held by the kernel thread. But<br>the timer interrupt might take priority over the kernel thread and refuse to<br>return to the kernel until it finishes executing. The result: that CPU comes to<br>a total halt as the timer interrupt handler function spins forever, never to get<br>the lock it so desperately needs to move on. So sad. :(</p>
<p>xv6 avoids this issue in a really simple way: every time we acquire a lock,<br>we’ll just disable interrupts altogether. Problem solved: now a thread can’t get<br>interrupted until it’s done using the lock and releases it. This does mean that<br>a process which grabs locks often might stick around longer than it should,<br>since we won’t have timer interrupts to tell the scheduler to swap it out with<br>another process, but we’re just gonna cross our fingers and hope that doesn’t<br>happen too often.</p>
<h3 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h3><p>The last concurrency issue we need to be aware of is the problem of deadlocks.<br>Suppose two threads each need locks A and B; this happens often, e.g. when<br>loading a user program the kernel will need to hold a lock for the disk and<br>another for the process table, or a process might be reading from disk and<br>printing to the console at the same time.</p>
<p>Suppose they’re running at the same time, and one process acquires lock A while<br>the other one acquires lock B. If they each need the other lock to keep going,<br>they’d spin forever waiting for it. This is a deadlock.</p>
<p>The way to avoid these is to make sure that, if we use more than one lock, we<br><em>always</em> acquire them in the same order. That way, one process would acquire<br>lock A, the second one would be unable to acquire it and would spin, then the<br>first process acquires lock B with no issues. When it’s done, it releases both<br>locks and the second process can continue.</p>
<p>This can get complicated though: if we ever acquire a lock in a function, we’d<br>have to check any functions that that function calls to see whether they use any<br>locks, and so on. If they do, and if the order conflicts with another chain of<br>function calls, we’d have to refactor the code until the orders match. xv6 has<br>been carefully written so that the lock acquisition order is always consistent.</p>
<h2 id="spinlock-c"><a href="#spinlock-c" class="headerlink" title="spinlock.c"></a>spinlock.c</h2><p>xv6’s spin-locks are set up as a <code>struct spinlock</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/spinlock.h">spinlock.h</a>. The<br><code>locked</code> field acts as the boolean variable to determine whether the lock is<br>held; the other fields are for debugging, since we can expect concurrency issues<br>to be the one of the most common causes of bugs in the kernel code because,<br>again, concurrency is your worst nightmare.</p>
<p>Note that <code>locked</code> is an <code>unsigned int</code> instead of a <code>bool</code>; C requires the<br>standard library header <em>stdbool.h</em> in order to use the <code>bool</code> type, but on<br>bare metal we can’t assume we have a standard library to use.</p>
<h3 id="initlock"><a href="#initlock" class="headerlink" title="initlock"></a>initlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function is pretty straightforward; it just stores the string <code>name</code> in<br>the lock and starts it off as unlocked; the <code>cpu</code> field is 0 because no CPU is<br>holding it yet. Next.</p>
<h3 id="pushcli-and-popcli"><a href="#pushcli-and-popcli" class="headerlink" title="pushcli and popcli"></a>pushcli and popcli</h3><p>For reasons mentioned above, we need to disable interrupts whenever we’re using<br>a lock and re-enable them when we release a lock. But if we’re not careful, we<br>could end up enabling interrupts too early when we release one lock while still<br>holding another; or if interrupts were already disabled when we acquired a lock,<br>we could unintentionally re-enable them upon releasing it.</p>
<p>xv6 uses paired functions <code>pushcli()</code> and <code>popcli()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushcli</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> eflags = readeflags();</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli == <span class="number">0</span>) &#123;</span><br><span class="line">        mycpu()-&gt;intena = eflags &amp; FL_IF;</span><br><span class="line">    &#125;</span><br><span class="line">    mycpu()-&gt;ncli += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readeflags()</code> is a C wrapper for some x86 assembly code that reads from the<br><code>eflags</code> register; the 9th bit is the interrupt flag, which is set whenever<br>interrupts are enabled. <code>cli</code> is another x86 instruction that clears that flag,<br>thus disabling interrupts.</p>
<p><code>mycpu()</code> returns a pointer to a <code>struct cpu</code> with information about the CPU<br>running this code; we’ll go over these when we talk about processes; here we<br>increment the <code>ncli</code> field in every call to <code>pushcli()</code>. If this is the first<br>call, we save the value of the interrupt flag in the <code>intena</code> field.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">popcli</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;popcli - interruptible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--mycpu()-&gt;ncli &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;popcli&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli == <span class="number">0</span> &amp;&amp; mycpu()-&gt;intena) &#123;</span><br><span class="line">        sti();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>popcli()</code> first checks to make sure interrupts aren’t already enabled and we’re<br>not popping without having pushed. Then it decrements the <code>ncli</code> field of the<br><code>struct cpu</code> for this CPU. If this is the last call to <code>popcli()</code>, it checks the<br><code>intena</code> field; if it was set (i.e., interrupts were enabled before the first<br><code>popcli()</code>), then it enables interrupts again.</p>
<p>Check out how these two functions are carefully written so that they’re matched:<br>it takes two calls to <code>popcli()</code> to undo two calls to <code>pushcli()</code>. Also, if<br>interrupts were already off before the first call to <code>pushcli()</code>, they’ll stay<br>off after the last <code>popcli()</code>. Pretty neat, right?</p>
<h3 id="holding"><a href="#holding" class="headerlink" title="holding"></a>holding</h3><p>This function checks whether this CPU is holding the lock.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line">    <span class="type">int</span> r = lock-&gt;locked &amp;&amp; lock-&gt;cpu == mycpu();</span><br><span class="line">    popcli();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not much to talk about here; it just checks (inside calls to <code>pushcli()</code> and<br><code>popcli()</code>) whether the lock is being held and this is the CPU holding it. If<br>both conditions are true it’ll return 1; otherwise 0.</p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>The first step in this function is to disable interrupts to avoid deadlocks. We<br>also make sure we’re not already holding the lock; otherwise we’d deadlock<br>ourselves.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holding(lk)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next up, we’ve gotta acquire the lock using the atomic <code>xchg</code> instruction,<br>defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>.<br>Like we said before, the trick is to atomically set <code>locked</code><br>to 1 while returning the old value. If the returned old value is 1, that<br>means it was already 1 before we got to it, so it’s currently being held and we<br>can’t acquire it yet – gotta spin. But if the returned old value is 0, that<br>means the lock was free before we got to it, and our <code>xchg</code> just updated it to<br>1, so we’ve successfully acquired it. No other instruction can occur between<br>checking the old value and updating it to the new one, so we can be confident<br>that no one else will be holding the lock at the same time.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We do have to be careful about one other thing: compiler optimizations can get<br>pretty wild nowadays, so the order of code on the page isn’t necessarily the<br>order it’ll get compiled to or executed in. This is a critical section of code,<br>so we need to make sure acquiring the lock forms a barrier between the code that<br>comes before it and the code after it so any reordering doesn’t cross the lock<br>acquisition point. We can do that with a special compiler instruction:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll record some info about the CPU and process holding the lock for<br>debugging purposes. Don’t worry about <code>mycpu()</code> for now, but we’ll talk about<br><code>getcallerpcs()</code> below.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lk-&gt;cpu = mycpu();</span><br><span class="line">    getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>Releasing a lock is a little easier than acquiring it: to acquire it, we need to<br>check whether it’s already held and update its value, with both steps together<br>as an atomic instruction. To release it, we only have to set the value to false.<br>That’s only one instruction, so it’s automatically atomic!</p>
<p>Well, almost, but not quite. The compiler works some serious magic behind the<br>scenes, so there’s no guarantee that a single C operation like <code>lk-&gt;locked = 0</code><br>will actually get compiled down to a single assembly instruction. So we’re gonna<br>have to make sure it does by writing it directly in assembly.</p>
<p>We start off by making sure we are already holding the lock before releasing a<br>lock held by someone else. Then we clear the debug info stored in the lock, and<br>tell the compiler and processor not to reorder code past the lock release.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holding(lk)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to release the lock, i.e. an assembly instruction equivalent to<br><code>lk-&gt;locked = 0</code> in C. C allows in-line assembly code using the <code>asm</code> keyword.<br>We mark it as <code>volatile</code>, which prevents the compiler from optimizing the write<br>away and ensures it’ll get written to memory. Finally, we call <code>popcli()</code> to<br>enable interrupts again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl $0, %0&quot;</span> : <span class="string">&quot;+m&quot;</span> (lk-&gt;locked) : )</span>;</span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getcallerpcs"><a href="#getcallerpcs" class="headerlink" title="getcallerpcs"></a>getcallerpcs</h3><p>This function exists to store information about the current process in the lock<br>for use in debugging. In particular, we want to record the program counters of<br>the last 10 functions on the call stack so we can try to figure out which<br>functions were called in which order when concurrency issues inevitably bring<br>our world crashing down with data races, or to a grinding halt with deadlocks.</p>
<p>In order to get the program counters, we’re gonna have to know a bit about how<br>x86 handles function calls. The <code>%eip</code> register (or instruction pointer) holds<br>the program counter, which tracks the next instruction to be executed. The<br><code>%ebp</code> register (or base pointer) holds the address of the base of the stack<br>(i.e., its highest address, since it grows down).</p>
<p>When a function gets called all its arguments are pushed on the stack in reverse<br>order, so that the first argument is at the top (lowest address) of the stack.<br>Then the previous function’s <code>%eip</code> is pushed on the stack, followed by its<br><code>%ebp</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;- low addresses                                               high addresses -&gt;</span><br><span class="line">...  [new function&#x27;s data]  [old %ebp]  [old %eip]  [new arg1]  [new arg2]  ...</span><br><span class="line">&lt;- top of stack                                               bottom of stack -&gt;</span><br></pre></td></tr></table></figure>

<p>Anyway, the point is that if we have the address of the first argument to the<br>current function, then we can recover the contents of the previous function’s<br><code>%ebp</code> and <code>%eip</code> registers: <code>%eip</code> is one spot below it on the stack and <code>%ebp</code><br>is two spots below it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    uint *ebp = (uint *) v - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note the type casts here – <code>v</code> is a pointer to the first argument, which can be<br>of any type and size, so we use a <code>void *</code>. But both of the <code>%eip</code> and <code>%ebp</code><br>registers hold 32-bit pointers, so <code>ebp</code> is declared as a pointer to a <code>uint</code><br>(a type alias for <code>unsigned int</code>, remember?), which makes the pointer arithmetic<br>work out nicely so that subtracting 2 returns a pointer to the right spot on the<br>stack.</p>
<p>Now, what we really want is the program counter <code>%eip</code>, not the pointer to the<br>stack base <code>%ebp</code>. But we can use the address of <code>%ebp</code> to make sure we haven’t<br>gone too far back in the function call history. Remember, we wanna get the<br>program counters for the last 10 functions in the call stack, then save them in<br>the <code>pcs</code> array.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// Stop if the %ebp pointer is null or out of range</span></span><br><span class="line">        <span class="keyword">if</span> (ebp == <span class="number">0</span> || ebp &lt; (uint *) KERNBASE || ebp == (uint *) <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pcs[i] = ebp[<span class="number">1</span>];</span><br><span class="line">        ebp = (uint *) ebp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s talk about those last two lines: the <code>ebp</code> pointer in the code holds the<br>location of the saved <code>%ebp</code> register, so <code>ebp[0]</code> is the value at that address<br>(i.e., the actual value of the saved <code>%ebp</code> register) and <code>ebp[1]</code> is the value<br>stored one spot above that, i.e. the value of the saved <code>%eip</code> register. So<br>each iteration of the loop will get one <code>%eip</code> and store it in a <code>pcs</code> entry.</p>
<p>Then we update <code>ebp</code> to the actual value at the address it points to, which<br>means <code>ebp</code> will now point to the address of the saved <code>%ebp</code> register for the<br>function one step further back in the call chain. Okay sorry, I know that’s<br>confusing, but basically each iteration of the for loop moves us back to the<br>function that called this function, then the function that called that one, and<br>so on.</p>
<p>Okay, whew. So what happens if we break out of the for loop early because we<br>went all the way back in the call stack? The other entries of <code>pcs</code> might hold<br>some garbage values, so let’s just make them null pointers so we know to ignore<br>them when debugging.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        pcs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One last little trick: the previous for loop declared the loop variable <code>i</code><br>before the loop – this means <code>i</code> will be in scope for the rest of the function<br>body. If it had been declare inside the for loop like <code>for (int i = 0; ...)</code>, it<br>would fall out of scope at the end of the loop. So we can keep using the same<br><code>i</code> in this second for loop (without an initialization statement) and know it’ll<br>hold the value it had after finishing the first for loop. If we finished all the<br>iterations, that value will be 10; otherwise it’ll be less. So we use that to<br>clear any remaining entries of <code>pcs</code>.</p>
<h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>You’ll learn to hate concurrency issues in C; newer languages like Rust make<br>data races a thing of the past, though deadlocks can still rear their ugly<br>heads. But for now, the xv6 authors have done all the dirty work for us, so we<br>can just sit back and watch. Note, though, that even the xv6 authors say it’s<br>totally possible that something has slipped past them and the thousands of other<br>students and instructors that have looked at xv6, so it’s probable that xv6<br>still has some lingering race conditions. See, even the masters struggle with<br>it. -_-</p>
<p>Anyway, we saw that locks have to be implemented with hardware support using<br>atomic instructions. C and most languages provide high-level atomics that real-<br>world operating systems use, but the point of xv6 is elegance in simplicity, not<br>being a total show-off, so the xv6 spin-locks just use the basic <code>xchg</code>.</p>
<p>We took this detour into spin-locks to make sure we all understand some basic<br>details because we’re gonna be seeing a lot of them in the rest of the kernel<br>code. They’re inefficient (because the processor just spins around waiting for<br>the lock to be released, WHEEEEE), but we gotta make do with the machinery we’ve<br>built up so far. xv6 will also use some fancier locks called sleep-locks, but<br>we’ll cross that bridge when we get to it.</p>
<h1 id="Page-Allocation"><a href="#Page-Allocation" class="headerlink" title="Page Allocation"></a>Page Allocation</h1><p>When we left off before the lock detour, the boot loader had set up a GDT to<br>ignore segmentation, and the entry code set up some barebones paging with an<br><code>entrypgdir</code>. But that initial page directory is too limiting to keep for long;<br>it only mapped the first 4 MB of physical memory. So we want a new one, but we<br>have to set it up and allocate pages in it before we can actually use it. And<br>until we switch to it, everything has to happen in those first 4 MB.</p>
<h2 id="kalloc-c"><a href="#kalloc-c" class="headerlink" title="kalloc.c"></a>kalloc.c</h2><p>We start off in this file by declaring the function <code>freerange()</code>, which will be<br>defined below. We have to do this in C in order to call a function in the code<br>before the compiler has actually seen the function’s definition, which comes<br>below, or maybe in another file. A <em>declaration</em> tells the C compiler “I know I<br>haven’t shown you this symbol before, but don’t worry; it’s just a function that<br>takes this number of arguments with these types and has a return value of this<br>type.” That lets the compiler keep calm and carry on with its usual type-checks<br>(weak as they may be in C). A <em>definition</em> tells the compiler that this is the<br>function (or variable) we were talking about, so it’ll reserve some space in<br>memory for it; it also tells the compiler how to evaluate that function whenever<br>it’s called (for variables, an <em>initialization</em> will have to tell the compiler<br>what the value the variable should hold). The linker will take care of matching<br>function calls (and variable uses) to their definitions, possibly across files.</p>
<p>Usually you’d stick declarations in a C header file and tell the preprocessor to<br>copy-paste the header into your code with an <code>#include</code> directive; then other<br>files could <code>#include</code> that header too. So header files should really be more of<br>an API kind of thing, for functions that you want other code to be able to call.<br>This one is just a local helper function, so we’ll declare it here instead of in<br>a header so other code can’t use it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span>;</span><br></pre></td></tr></table></figure>

<p>Okay okay, I know function declarations are like 101-level C, but I wanted to<br>mention them because we’re about to see something similar but a little off next<br>when we declare <code>end</code> as a global array of characters.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[];</span><br></pre></td></tr></table></figure>
<p>The C keyword <code>extern</code> lets you define a global variable or function in one file<br>and use it in another, so in that sense it’s similar to the function declaration<br>above. In fact, the compiler implicitly assumes there’s an <code>extern</code> before each<br>function declaration. The difference is that an explicit <code>extern</code> lets us do the<br>same thing for global variables: we tell the compiler and linker “hey, I’m gonna<br>use a variable of this type with symbol <code>end</code>, but don’t worry about reserving a<br>spot in memory for it; that already happened elsewhere.”</p>
<p>The really cool thing about <code>extern</code> is that the function or variable might not<br>even be defined in C – it could come from any other language! We just pass the<br>compiled object files from the other language together with the C object files<br>to the linker and it’ll match up the definitions and calls.</p>
<p>In this case if you try looking for the place where <code>end</code> is defined in the C or<br>assembly code, you’re gonna be disappointed. Turns out it’s actually defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, remember? Back then, we said it was gonna be located at the very<br>first memory address right after the end of the kernel code and data in memory.<br>We’re about to see why it’s needed.</p>
<p>Next up, we define a new <code>struct</code> type:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Hmm, the only member of this <code>struct run</code> is a pointer to another <code>struct run</code>.<br>Hopefully, you’ve seen some singly-linked lists before so you can recognize it<br>as one of those. Usually it would have another member to hold the data in the<br>list, but we won’t need any extra data here; we’ll find out why soon enough.</p>
<p>Last thing before we get to the functions: we define another <code>struct</code> type and<br>declare the global variable <code>kmem</code> to be of that type.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> use_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<p>The syntax here is the usual C thing where we say the type of a variable, then<br>an identifier, like <code>int i</code>; it just looks more confusing because we’re also<br>defining the type at the same time. This <code>struct</code> type doesn’t get a name like<br><code>struct run</code> did because we’re only gonna need it this one time. The fields are<br>a spin-lock (hence the detour before coming here), a <code>use_lock</code> variable that<br>we’ll treat as a boolean, and a pointer to a <code>struct run</code> called <code>freelist</code>.</p>
<p>I’m just gonna go ahead and spoil the next two functions for you: we want to use<br>a better page directory than <code>entrypgdir</code>, right? Well then we need to assign<br>a page of memory for it, plus a page for each of its page tables, plus a page<br>for each entry in those page tables that’s mapped. That means we’ll need some<br>bookkeeping to track which pages have already been assigned. We’re gonna use a<br>linked list of free pages (that’s what <code>struct run</code> is for); we’ll allocate a<br>page by popping one off the free list, and we’ll free a page by pushing it onto<br>the top of the list.</p>
<p>Note that <code>kfree()</code> here is <em>not</em> supposed to be a kernel version of the usual C<br>standard library function <code>free()</code>, nor is <code>kalloc()</code> supposed to be a kernel<br>version of <code>malloc()</code>. We have no concept of a heap yet, so heap allocation<br>wouldn’t make sense. These functions allocate and free <em>whole physical pages</em> to<br>be added to the current page directory and its page tables.</p>
<h3 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h3><p>This function will free a single page (4096 bytes, or <code>PGSIZE</code>) of memory by<br>adding it to the front of the free list. It takes an argument <code>char *v</code> which is<br>a virtual address; we’re using <code>char *</code> here instead of <code>uint *</code> or <code>void *</code> or<br>whatever so that the pointer arithmetic increments by a single byte instead of<br>4 bytes for <code>uint</code> or whatever.</p>
<p>First, some sanity checks: <code>v</code> should be page-aligned (because we’re freeing a<br>whole page), it should be above <code>end</code> (because we don’t want to accidentally<br>overwrite the kernel code), and its corresponding physical address should be<br>below <code>PHYSTOP</code> (because the only addresses we’ll use above the top of physical<br>memory are for memory-mapped I&#x2F;O devices and we shouldn’t be freeing those pages<br>anyway).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((uint) v % PGSIZE || v &lt; end || V2P(v) &gt;= PHYSTOP) &#123;</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if you’ve programmed in C, you might have come across the dreaded (but oh-<br>so-common) bug known as a <em>use-after-free</em>. This means you called <code>free()</code> on<br>some variable (hopefully one you had <code>malloc()</code>-ed before), and then used it<br>again. Hmm, very naughty! The problem is that that memory might have been re-<br>allocated to some other variable or even another process, so you might read the<br>wrong values or overwrite something important. This is a <em>very</em> common cause of<br>security vulnerabilities in C and C++ to this day; it’s also not always easy to<br>spot because huge projects might have you call <code>malloc()</code> in one file, then use<br>the variable somewhere else thousands of lines of code later in some other file,<br>then call <code>free()</code> in yet another file – plus it’s unlikely that all of these<br>pieces were written by the same person. So let’s make this a little easier on<br>ourselves by filling the freed page with junk (a bunch of 1s everywhere) in the<br>hope that a use-after-free leads to a crash (and thus debugging and detection)<br>sooner than it would otherwise.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">1</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might be familiar with <code>memset()</code> from the C standard library in <em>string.h</em>,<br>but we can’t risk using standard library functions here because they assume the<br>code will be provided by the OS, and the implementation might require any of a<br>million features we haven’t implemented yet. So we have to make our own version<br>for the kernel in <a href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>. We’ll get around to looking at that code later on<br>in an optional detour, but for now just know that it sets the memory starting at<br><code>v</code> and continuing for <code>PGSIZE</code> bytes to hold a bunch of repeated 1s.</p>
<p>Now let’s talk concurrency. At any time, multiple threads might want to allocate<br>or free pages simultaneously; if we’re not careful we might accidentally use the<br>same page twice, which would cause bugs in addition to security vulnerabilities,<br>because all the per-process isolation that paging gets us would be lost. So much<br>work down the drain! This is why <code>kmem</code> has a lock, which we should use any time<br>we push to or pop from the free list.</p>
<p>But in the early stages of the kernel we only use a single CPU and interrupts<br>are disabled, so there’s nothing to fear. Plus, locks add overhead, and the<br><code>acquire()</code> function needs to call <code>mycpu()</code>, which we haven’t even defined yet,<br>so let’s just go ahead and skip them in the beginning. So <code>kmem.use_lock</code> is a<br>boolean that will tell us whether we need a lock right now or not.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        acquire(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, we’re finally at the point where we can free the page. We’ll make a<br><code>struct run *r</code> that points to virtual address <code>v</code>, then make its <code>next</code> point<br>to the first entry of the free list. Then we’ll update the head of the list to<br>point at the newly-freed page. This is the standard C idiom to add to the front<br>of a singly-linked list.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> (<span class="keyword">struct</span> run *) v;</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s something interesting here: where are we storing this entry for the free<br>list? Why, in the free page itself! So each unused page will hold the address of<br>the next one in its first few bytes.</p>
<p>Finally, we’re out of the critical section where we updated the free list, so we<br>can release the lock.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h3><p>Allocating a page means popping off the head of the free list. We acquire the<br>lock first, if we need one.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        acquire(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we get a pointer to the first free page in the list and update the head to<br>point to the next one in the list. But what if the list is empty? In that case,<br>the head would be a null pointer, and dereferencing a null pointer (like we do<br>here in <code>r-&gt;next</code>) is undefined behavior in C, which means BAD THINGS HAPPEN.<br>I’m serious – there are absolutely no restrictions on what might happen, so the<br>compiler could literally set your computer on fire if it wanted to. In the real<br>world, that usually means either a segmentation fault or security vulnerability,<br>or both if you’re unlucky. So we should check whether <code>r</code> is null (i.e. zero).<br>if it’s nonzero then we can update <code>r-&gt;next</code>; otherwise we should just return<br><code>r</code> and hope whoever called us checks whether it’s null. Moral of the story:<br>any call to <code>kalloc()</code>, just like any call to <code>malloc()</code> in regular C code,<br>should always be followed by checking whether the returned pointer is null.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        kmem.freelist = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now we just release the lock, and we’re done!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freerange"><a href="#freerange" class="headerlink" title="freerange"></a>freerange</h3><p><code>kalloc()</code> and <code>kfree()</code> both handle only one page at a time, which can get<br>annoying if we’re trying to free tons of pages at once; also, they can only use<br>page-aligned virtual addresses, which have to be typecast to <code>char *</code>. Let’s<br>simplify our lives with a simple wrapper function to free multiple pages between<br>two virtual memory addresses <code>vstart</code> and <code>vend</code> that may not be page-aligned.</p>
<p>Let’s assume that <code>vstart</code> is the first address after some other data in an<br>already-allocated page; we don’t want to free that page, but the next one, so we<br>align it to a page boundary by rounding up, then cast that to a <code>char *</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *) PGROUNDUP((uint) vstart);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can iterate over the pages, starting at <code>p</code> and incrementing by <code>PGSIZE</code><br>until we reach or pass <code>vend</code>, freeing pages as we go.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; p + PGSIZE &lt;= (<span class="type">char</span> *) vend; p += PGSIZE) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Done, next.</p>
<h3 id="kinit1-and-kinit2"><a href="#kinit1-and-kinit2" class="headerlink" title="kinit1 and kinit2"></a>kinit1 and kinit2</h3><p>Both of these functions get called by the kernel’s <code>main()</code>. Quick reminder:<br>we’ve got an <code>entrypgdir</code> that maps two virtual address ranges (0 to 4 MB and<br><code>KERNBASE</code> to <code>KERNBASE</code> + 4 MB) to the physical addresses range from 0 to 4 MB.<br>We want to leave this baby page directory behind for a grown-up page directory<br>that maps all of physical memory, but first we needed to figure out how to<br>allocate pages.</p>
<p>Okay cool, we already did that. But allocation needs a free list, which for now<br>is just sitting around chilling as an empty list. But we can’t free pages if<br>they’re not already allocated, right? Ahh, bootstrap problems! This one’s not an<br>issue; we’ll just cheat this one time and free all the memory between <code>end</code> (the<br>end of the kernel code and data in memory) and <code>PHYSTOP</code>, even though we didn’t<br>get it from a call to <code>kalloc()</code>. Sounds good, right?</p>
<p>I hate to burst your bubble, but kernel development <em>loves</em> bursting bubbles.<br>Turns out there’s yet another bootstrap problem: each page has to store the<br>pointer to the next free page, which means we have to write to that page, which<br>means that page must already be mapped… but we can’t map all of memory until<br>we initialize the free list by freeing all of memory…</p>
<p>HEAD. DESK. We’re screwed.</p>
<p>Okay, obviously the xv6 authors figured this out already. The trick is that we<br>do have <em>some</em> physical memory we can write to: everything between <code>end</code> and 4<br>MB. So we can free that part for now, allocate some of those pages for a fresh<br>page directory and some pages, then use those pages to map the rest of physical<br>memory, then come back later and free those pages.</p>
<p>So we’ll have to split up the work of setting up the new page directory into two<br>very similar functions, <code>kinit1()</code> and <code>kinit2()</code>. The first one will initialize<br>the lock for the free list but make <code>kmem.use_lock</code> false so we don’t use a lock<br>in the early stages of kernel setup. The second one will set it to true so we<br>start using a lock to allocate and free pages once we have multiple CPUs, a<br>scheduler, interrupts, etc.</p>
<p>Both of them will use <code>freerange()</code> to free the pages in a section of physical<br>memory. <code>main()</code> calls <code>kinit1()</code> with arguments to free the range from <code>end</code> to<br>4 MB, and calls <code>kinit2()</code> with arguments for the range from 4 MB to <code>PHYSTOP</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit1</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    kmem.use_lock = <span class="number">0</span>;</span><br><span class="line">    freerange(vstart, vend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kinit2</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    freerange(vstart, vend);</span><br><span class="line">    kmem.use_lock = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>This whole file was just to set up page allocation for the new page directory<br>we’re gonna replace <code>entrypgdir</code> with. It uses a free list in <code>kmem</code>; freeing a<br>page adds it to the front of the list and allocation pops a page off the front.<br>We have to populate the free list will pages for all of physical memory, but we<br>do that in two steps to avoid some bootstrap issues.</p>
<p>Again, this is a <em>page</em> allocator, not a <em>heap</em> allocator like <code>malloc()</code>, but<br>many heap allocator implementations use linked lists of free heap regions in the<br>same way. We talked about use-after-free bugs above, but now we can also see why<br><em>double-frees</em> (in which you free the same memory region more than once) can<br>cause bugs and security vulnerabilities: they add the same region to it twice,<br>which then might get allocated to two different variables or processes, which<br>might ruin the per-process isolation that virtualization is supposed to provide.<br>In addition, our page allocator handles fixed-size regions, but a heap allocator<br>needs to use variable regions, so when a memory region gets allocated twice<br>after a double-free, it might get split up into differently-sized pieces, of<br>which some parts get allocated to other processes, etc… It’s just a nightmare.</p>
<p>Next up, we’ll see the full story of virtual memory.</p>
<h1 id="More-Paging-The-Kernel-Side"><a href="#More-Paging-The-Kernel-Side" class="headerlink" title="More Paging: The Kernel Side"></a>More Paging: The Kernel Side</h1><p>We’ve already talked <em>plenty</em> about virtual memory, and I bet you’re probably so<br>over <code>entrypgdir</code> by now; let’s wrap up its story and get rid of it!</p>
<p>The <a href="https://github.com/mit-pdos/xv6-public/blob/master/vm.c">vm.c</a> file is HUGE; only <a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a> and <a href="https://github.com/mit-pdos/xv6-public/blob/master/sysfile.c">sysfile.c</a> match its length. Some<br>parts deal with the general paging implementation; we’ll look at those here. The<br>rest handles the details of paging for processes and user code, we’ll need to<br>know a bit more about processes in xv6 for that.</p>
<h2 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h2><p>After the include directives for the preprocessor, we have a declaraction for<br>an external symbol defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>. This one is the beginning of the<br>data section for the kernel.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> data[];</span><br></pre></td></tr></table></figure>

<p>Next we have a definition for a pointer to a global page directory: this is the<br>fancy new one that’s gonna replace <code>entrypgdir</code>. Note that <code>pde_t</code> is a type for<br>page directory entries defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>; it’s just a type alias for <code>int</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *kpgdir;</span><br></pre></td></tr></table></figure>

<h3 id="seginit"><a href="#seginit" class="headerlink" title="seginit"></a>seginit</h3><p>This first function gets called directly by the kernel’s <code>main()</code>; it sets up<br>the segment descriptors in the GDT as identity maps to all of memory so that we<br>can ignore them from now on. Wait, didn’t we already do that in the boot loader?</p>
<p>Yes, kind of, but that was before the kernel took over, so back then we had no<br>notion of kernel space versus user space. Now that we do, we want to set the<br>permission flags for each segment so that we can use the privilege ring levels,<br>with the kernel in ring 0 and user code in ring 3. That way any misbehaving user<br>code will get slapped with a segmentation fault the way we’ve all come to know<br>and love in C.</p>
<p>We also have some permission flags for protection in the page directory and page<br>table entries, so maybe we could get away without it? I mean, both kernel code<br>and user code are read-only anyway, so maybe they could both have a Descriptor<br>Privilege Level of 3. But no, x86 is gonna shut that right down by forbidding<br>interrupts that take you from ring level 0 to ring level 3, so all the interrupt<br>handler functions have to be in kernel space with a kernel code segment selector<br>at ring level 0.</p>
<p>So we’re just gonna have to do it all over again. Great. Well, maybe it’s not<br>too bad, let’s take a look… oh god, it’s awful. Okay, deep breath.</p>
<p>Each processor has its own GDT, so we’re gonna need to call this function once<br>per CPU. First we figure out which CPU we’re on with with the <code>cpuid()</code> function<br>that we’ll see later on; for now it… (drumroll)… gets the CPU’s ID. Then we<br>look that up in a global table of CPUs (there’s an <code>extern</code> declaration for this<br>in the included <a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.h">proc.h</a>) and store it in a <code>struct cpu</code>; we saw that before in<br>the spin-lock code, but we’ll get around to talking about it more later.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[cpuid()];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That <code>struct cpu</code> has a field to hold the GDT, so we’re gonna add entries for<br>the kernel code, kernel data, user code, and user data segment descriptors;<br>those entries are <code>SEG_KCODE</code>, <code>SEG_KDATA</code>, <code>SEG_UCODE</code>, and <code>SEG_UDATA</code>,<br>respectively. Recall that the permission bits are <code>STA_X</code> (executable), <code>STA_R</code><br>(readable), and <code>STA_W</code> (writeable); now we’re gonna pile on the descriptor<br>privilege levels for the kernel (0) and user (3, or <code>DPL_USER</code>) on top. Besides<br>those ring levels, we want to ignore segmentation, so each segment should be an<br>identity map for all virtual memory from 0 to 4 GB (0xffff_ffff).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c-&gt;gdt[SEG_KCODE] = SEG(STA_X|STA_R, <span class="number">0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;gdt[SEG_KDATA] = SEG(STA_W, <span class="number">0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;gdt[SEG_UCODE] = SEG(STA_X|STA_R, <span class="number">0</span>, <span class="number">0xffffffff</span>, DPL_USER);</span><br><span class="line">    c-&gt;gdt[SEG_UDATA] = SEG(STA_W, <span class="number">0</span>, <span class="number">0xffffffff</span>, DPL_USER);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The only difference between the <code>SEG</code> macro used here and the <code>SEG_ASM</code> one from<br>the boot loader is that this one is for C code and the other is for assembly.</p>
<p>Finally, we load up the new GDT into the processor with a C wrapper for the<br>x86 instruction <code>lgdt</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lgdt(c-&gt;gdt, <span class="keyword">sizeof</span>(c-&gt;gdt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done with segmentation, now on to more paging.</p>
<h3 id="walkpgdir"><a href="#walkpgdir" class="headerlink" title="walkpgdir"></a>walkpgdir</h3><p>A page directory lets the paging hardware convert virtual addresses to physical<br>ones, but we’re gonna need those mappings in the kernel too while we set up the<br>page directory, so this function does the conversion manually. Wait, but aren’t<br>we setting up paging so that all of physical memory is mapped in the higher half<br>of the virtual address space? Can’t we just add or subtract <code>KERNBASE</code> to do the<br>conversion? Well, that would work for kernel virtual addresses, but user virtual<br>addresses actually will use page directories and page tables in a non-obvious<br>way, so if we want to figure out where those go, we’ll need a function for it.</p>
<p>In C, using the <code>static</code> keyword before a function limits its scope and makes it<br>visible only within its own file. The function returns a <code>pte_t *</code>, a pointer to<br>a page table entry (the type is defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as a type alias for <code>uint</code>).</p>
<p>Its arguments are a pointer to a page directory, a virtual address, and <code>alloc</code><br>(a boolean variable, but as an <code>int</code> instead of <code>bool</code>). This <code>alloc</code> lets the<br>function play a dual role: if it’s set, the function will allocate a page table<br>if needed; otherwise it reports failure if the page table doesn’t exist. The<br><code>const</code> keyword lets the compiler know a variable shouldn’t be mutated so it’ll<br>throw an error if we do. Here, <code>const void *va</code> is a pointer to a constant value<br>of any type; the address the pointer holds might change, but we can never write<br>to that address. The opposite is a <code>void *const va</code>: the address being pointed<br>to will never change, but we can overwrite the contents of that address all we<br>want. You can combine the two with <code>const void *const va</code>. What’s that I hear? C<br>syntax is the worst? No, never…</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember way back when, when we talked about how “linear” addresses are set up<br>and converted to physical ones? The first 10 bits are an index for the page<br>directory to pick a page directory entry, which points to a page table; the next<br>10 bits pick a page table entry that points to a page, and the last 12 bits are<br>an offset within that page; the <code>PDX()</code> and <code>PTX()</code> macros get first 10 bits and<br>the next 10 bits from a linear address, respectively. So we start by getting the<br>page directory index and using that to get the page directory entry.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *pde = &amp;pgdir[PDX(va)];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now <code>pde</code> points to a page directory entry which has two parts: a<br>pointer to the physical address of a page table, and some flags. But who knows<br>if this page table even exists; most page directory (and page table) entries<br>aren’t mapped in order to save space. So we have to check whether <code>*pde</code> has the<br><code>PTE_P</code> (present) flag set.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the page table exists, we should get rid of the flags and recover the pointer<br>to the page table using the <code>PTE_ADDR()</code> macro. But the hardware uses physical<br>addresses for these pointers, so we need to convert it to a virtual address<br>first, which is what this function does… recursion? Bootstrap problem? No,<br>it’s actually easy because we can access the page table from within the kernel’s<br>virtual address space in the higher half by adding <code>KERNBASE</code> to the physical<br>address with the <code>P2V()</code> macro.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        pgtab = (<span class="type">pte_t</span> *) P2V(PTE_ADDR(*pde));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now for the else clause, which happens if the page directory entry doesn’t have<br>the <code>PTE_P</code> bit set. Well, if the boolean <code>alloc</code> is false (zero), then we’re<br>done and we should just report failure by returning a null pointer. On the other<br>hand, if it’s true, we just allocate a page for the page table. But wait,<br>remember how page allocation might fail and return a null pointer if we’re out<br>of free pages in the free list? And remember how I said we should always check<br>for that? Okay well let’s check for that; if allocation fails, we also return a<br>null pointer. Oh, and because this is C, we’re gonna do a jillion things at once<br>in a single line: check if <code>alloc</code> is false, try to allocate a page table, and<br>check if that allocation failed. C lets us assign to a variable and then test<br>that variable’s value in a single statement.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!alloc || (pgtab = (<span class="type">pte_t</span> *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now suppose: (1) the page table wasn’t present, (2) alloc was set, and<br>(3) we successfully allocated a page. Now what? Remember how we filled all free<br>pages with garbage in <code>kfree()</code> using <code>memset()</code>? Let’s undo that now by zeroing<br>it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">memset</span>(pgtab, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll update the page directory entry to point to this new page table and<br>add the <code>PTE_P</code> flag so it knows it’s present. Wait, while we’re at it, what<br>other permissions will it need? Is it writeable? Can users access it? Hmm, we’d<br>have to know whether we’re looking up a user virtual address or a kernel one,<br>and whether it’s gonna be used for code or data. Ah, screw it, we’ll just throw<br>all the flags on there at once. Either way, the page table entries will have<br>their own flags too, so we can restrict the page’s permissions there instead of<br>here at the page directory entry.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This probably isn’t the safest thing ever, because we’re saying that only the<br>page table will restrict permissions, so we’re throwing all that responsibility<br>over there, but hey, xv6 is supposed to be simple, not ultra-secure. Just don’t<br>do this at home, kids.</p>
<p>Finally, we return the address of the corresponding page table entry using the<br>index from the middle bits of <code>va</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pgtab[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mappages"><a href="#mappages" class="headerlink" title="mappages"></a>mappages</h3><p>Okay, so <code>walkpgdir()</code> returns a pointer to a page table entry and can even<br>crate a page table if if it doesn’t exist. That’s not quite enough to add new<br>mappings for pages though; the page itself might not be mapped, and if we just<br>created a new page table, then certainly none of the pages are mapped yet.<br><code>mappages()</code> will finish the job by installing mappings in page tables (possibly<br>newly-allocated ones) for a range of virtual addresses.</p>
<p>The arguments are a page directory, a virtual address for the beginning of the<br>range, the size of the range, a physical address to map it to, and the flags for<br>permissions we want to set. We start off by rounding the virtual address down to<br>the nearest page boundary and getting a pointer to the end of the range, also<br>page-aligned.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span> *) PGROUNDDOWN((uint) va);</span><br><span class="line">    <span class="type">char</span> *last = (<span class="type">char</span> *) PGROUNDDOWN(((uint) va) + size - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’re gonna iterate over the pages in that range; <code>for (;;)</code> is a common C<br>idiom for an infinite loop. In this case, we need to increment <code>a</code> and <code>pa</code> by<br><code>PGSIZE</code> each time, and we’ll break out of the loop when <code>a</code> reaches <code>last</code>. To<br>be completely honest, I’m not really sure why the authors chose to write this as<br>an infinite loop with the condition&#x2F;break statement and update statements inside<br>the loop rather than as a regular old for loop; I think the latter would be more<br>clear, but oh well, I didn’t write this.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (a == last) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inside the for loop, we’ll start each iteration by looking up the right page<br>table entry with <code>walkpgdir()</code>, with <code>alloc</code> set to true. Remember how that<br>function called <code>kalloc()</code>, which might fail, in which case it returns a null<br>pointer? Well that means we’ve gotta check for a null pointer here too. This<br>time however, we’ll return -1 for failure and 0 for success, because why not?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, a, <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re supposed to be allocating brand-new pages for this range of addresses, so<br>if a page has already been allocated, we’ll just flip out in rage and panic.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_P) &#123;</span><br><span class="line">            panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last thing before checking the loop condition and updating <code>a</code> and <code>pa</code> is<br>to install the mapping to the right physical address with the right permissions<br>in the page table. Then we’re done!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *pte = pa | perm | PTE_P;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cool, now we have a way to map new pages into a page directory. We’re well on<br>our way to leaving poor old <code>entrypgdir</code> behind for the shiny new <code>kpgdir</code>.</p>
<h3 id="kmap"><a href="#kmap" class="headerlink" title="kmap"></a>kmap</h3><p>Each process is gonna have its own page directory, so its mappings in the lower<br>half of the virtual address space might be totally different from those of<br>another process. But the mappings in the higher half (where the kernel lives)<br>will always be the same – that way, the kernel can always use the existing page<br>directory for whatever process it happens to be running. We’ll only use <code>kpgdir</code><br>when the kernel isn’t currently running a process, e.g. while it’s running the<br>scheduler.</p>
<p>So when we create a new process, we’ll need to copy in all the mappings that the<br>kernel expects to find into a fresh page directory for that process. Those are:<br>memory-mapped I&#x2F;O device space from physical address 0 to 0x10_0000 (the boot<br>loader is also here, but we don’t need it any more), kernel code and read-only<br>data from 0x10_0000 to the physical address of <code>data</code> (one of the symbols<br>defined in <a href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>), kernel data the rest of physical memory from there to<br><code>PHYSTOP</code>, and more I&#x2F;O devices from 0xFE00_0000 and up. Each of these ranges<br>needs its own permissions too.</p>
<p>We’ll represent each of these mappings with a <code>struct kmap</code>, which has fields<br>for the starting virtual address, the starting and ending physical addresses,<br>and the permissions; then the mappings will get stored in a static global<br>variable <code>kmap</code>… oh come on, what fresh hell is THIS?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *virt;</span><br><span class="line">    uint phys_start;</span><br><span class="line">    uint phys_end;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line">&#125; kmap[] = &#123;</span><br><span class="line">    &#123; (<span class="type">void</span> *)KERNBASE, <span class="number">0</span>, EXTMEM, PTE_W &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)KERNLINK, V2P(KERNLINK), V2P(data), <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)data, V2P(data), PHYSTOP, PTE_W &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)DEVSPACE, DEVSPACE, <span class="number">0</span>, PTE_W &#125;.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Okay, there are a few things going on here. First, the <code>static</code> keyword for a<br>variable means that variable has a single fixed location in memory that it’s<br>never gonna move out of.</p>
<p>Then it does that thing again where we simultaneously define a <code>struct</code> type and<br>define a variable of that type. So the type is</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *virt;</span><br><span class="line">    uint phys_start;</span><br><span class="line">    uint phys_end;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>So then the static global variable <code>kmap</code> is an array of <code>struct kmap</code>s. I guess<br>we ran out of names or something. The array has four entries, and since each one<br>is a <code>struct</code>, it needs curly braces around it.</p>
<p>The first entry (for the lower of the two memory-mapped I&#x2F;O device regions) has<br>a <code>virt</code> field of <code>KERNBASE</code>, a <code>phys_start</code> field of 0, a <code>phys_end</code> field of<br><code>EXTMEM</code> (defined as 0x10_0000), and permission flag <code>PTE_W</code>. So it maps a<br>virtual address range starting at <code>KERNBASE</code> to the physical address range from<br>0x0 to 0x10_0000 and makes it writeable so we can communicate with the devices<br>there. The next two entries are similar, except that the kernel code isn’t<br>writeable.</p>
<p>The last entry has <code>phys_start</code> of 0xFE00_0000 and a <code>phys_end</code> of 0. That’s a<br>little strange, but it’s because we want to map all the way up to the end of the<br>virtual address space at 0xFFFF_FFFF. The end should be one byte past that, but<br>it’s impossible to represent 0x1_0000_0000 with 32 bits. Setting the end to 0<br>makes the size calculation (<code>phys_end - phys_start</code>) work out nicely: it’ll just<br>overflow to the right number. This is okay since we’re using unsigned integers,<br>but note that <em>signed</em> integer overflow is undefined behavior and thus VERY BAD<br>and the cause of many security vulnerabilities.</p>
<p>Okay, back to getting rid of <code>entrypgdir</code>!</p>
<h3 id="setupkvm"><a href="#setupkvm" class="headerlink" title="setupkvm"></a>setupkvm</h3><p>This function sets up a fresh new page directory with all the mappings in <code>kmap</code><br>in order to please the kernel when it encounters the page directory. So needy,<br>right?</p>
<p>It takes no arguments and returns a pointer to the new page directory. First,<br>let’s allocate a page of memory to hold the new directory. We’ll be good and<br>remember to check for null (in which case we return null too) and clear the page<br>of the garbage values we wrote when we freed it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *pgdir;</span><br><span class="line">    <span class="keyword">if</span> ((pgdir = (<span class="type">pde_t</span> *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The upper end of virtual memory after <code>DEVSPACE</code> has I&#x2F;O devices, so <code>PHYSTOP</code><br>should be below that; this is as good a place as any to make sure.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (P2V(PHYSTOP) &gt; (<span class="type">void</span> *) DEVSPACE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;PHYSTOP too high&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll add all the mappings in <code>kmap</code> above into this page directory so<br>the kernel is happy. We’ll use <code>mappages()</code>, which returns -1 if it fails, so<br>we should check for that. The <code>freevm()</code> function is defined below, and we’ll<br>get to it soon, but for now just know that it gets rid of all the mappings we<br>just made, in case any of them fails.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> *<span class="title">k</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (k = kmap; k &lt; &amp;kmap[NELEM(kmap)]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappages(pgdir,</span><br><span class="line">                k-&gt;virt,</span><br><span class="line">                k-&gt;phys_end - k-&gt;phys_start,</span><br><span class="line">                (uint) k-&gt;phys_start,</span><br><span class="line">                k-&gt;perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            freevm(pgdir);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pgdir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s check out that for loop: <code>k</code> is a pointer to a <code>struct kmap</code>, and <code>kmap</code><br>is an array of <code>struct kmap</code>s; in C, arrays decay to pointers, so they have the<br>same type. <code>k</code> starts off pointing to the first (zero) entry of <code>kmap</code>. Then<br>incrementing it with <code>k++</code> shifts its value by the size of a <code>struct kmap</code>, so<br>it’ll point to the next entry. The loop stops when <code>k</code> points beyond the last<br>entry of <code>kmap</code>, as determined by the <code>NELEM()</code> macro which counts the number of<br>entries in an array. Note that array element-counting only works in C if the<br>array is defined in the same function or as a global variable in the same file,<br>which is why it’s so easy to do an out-of-bounds read or write in C (yet another<br>common security vulnerability).</p>
<p>Finally, if everything worked out okay, we return a pointer to the new page<br>directory.</p>
<h3 id="switchkvm"><a href="#switchkvm" class="headerlink" title="switchkvm"></a>switchkvm</h3><p>We said above that the kernel would usually just use the page directory of the<br>currently-running process, but it’ll use <code>kpgdir</code> when no process is running,<br>i.e. during the kernel setup and while it’s scheduling a new process. So we need<br>a way to tell the paging hardware to load <code>kpgdir</code> into register <code>%cr3</code>, which<br>holds a pointer to the page directory. That’s this function.</p>
<p>It’s a one-liner: get the physical address of <code>kpgdir</code> and stick it in <code>%cr3</code><br>with the assembly instruction <code>lcr3</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcr3(V2P(kpgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvmalloc"><a href="#kvmalloc" class="headerlink" title="kvmalloc"></a>kvmalloc</h3><p>FINALLY, we’re here! We’re gonna get rid of <code>entrypgdir</code>! The kernel’s <code>main()</code><br>calls this function right after <code>kinit1()</code>.</p>
<p>We already did all the hard work, so this one’s a breeze: we call <code>setupkvm()</code><br>to allocate a new page directory and fill it with the kernel’s mappings, then<br>call <code>switchkvm()</code> to load it into the paging hardware.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kvmalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    kpgdir = setupkvm();</span><br><span class="line">    switchkvm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And we’re DONE! Take that, <code>entrypgdir</code>, we don’t need you anymore. We’re big<br>kids now.</p>
<h2 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h2><p>So far, it’s been a serious odyssey just to move from no paging in the boot<br>loader, to super basic paging with <code>entrypgdir</code> in <a href="https://github.com/mit-pdos/xv6-public/blob/master/entry.S">entry.S</a>, to <code>kpgdir</code> now.<br>Along the way, we’ve looked at code to allocate and free pages and install new<br>mappings in page directories and page tables. That’ll come in handy when we look<br>at processes next; the virtual memory story still isn’t over.</p>
<p>Also, note that <code>kpgdir</code> still isn’t at the height of its powers: at the point<br>when <code>main()</code> calls <code>kvmalloc()</code>, the free list only contains pages for physical<br>memory between 0 and 4 MB. The rest will have to wait until <code>kinit2()</code> unleashes<br>its full potential. (Maybe some self-actualization seminars would help…)</p>
<h1 id="More-Paging-The-User-Side"><a href="#More-Paging-The-User-Side" class="headerlink" title="More Paging: The User Side"></a>More Paging: The User Side</h1><p>It’s almost time to turn to interrupts and processes so we can figure out how to<br>work that sweet multiprocessing magic, but unfortunately we have some last<br>pieces of paging to wrap up before we can get there.</p>
<p>I know, we’ve been talking about virtual memory for what feels like a century<br>now, but so far everything we’ve done has been on the kernel side, allocating<br>pages and creating new page directories with the same kernel mapping. But what<br>about the lower half of the virtual address space, where user processes live?</p>
<p>This post will go through the rest of<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/vm.c">vm.c</a><br>and set up the paging-related machinery we’ll need to run processes later on.</p>
<h2 id="Detour-Starting-a-New-Process"><a href="#Detour-Starting-a-New-Process" class="headerlink" title="Detour: Starting a New Process"></a>Detour: Starting a New Process</h2><p>When xv6 runs a new process, it will create a brand new virtual memory space for<br>it with a fresh page directory. We haven’t talked about processes in xv6 yet, so<br>you might wonder how a process gets started up in the first place.</p>
<p>Let’s forget all about xv6 for a second and think about another Unix-like OS:<br>Linux. How do we start a process there? Okay, we also have to forget about GUI<br>applications there. Let’s just say you want to run some C code (xv6 maybe?) that<br>you’ve just compiled; what happens when you run it from the terminal?</p>
<p>Hopefully, you’ve done the OSTEP project called <a href="https://github.com/remzi-arpacidusseau/ostep-projects/tree/master/processes-shell">processes-shell</a><br>by now, so you know the answer; if you haven’t, I recommend doing that one right<br>now before I give it away. (It’s not strictly required, but are you really the<br>kind of person who loves getting movies spoiled for them?)</p>
<p>Okay, are you done?</p>
<p>The answer: it’s just an <code>exec()</code> system call! The shell finds the executable<br>file in the file system, calls <code>fork()</code> to create a new child process, which<br>then calls <code>exec()</code> to transform itself into the program you want to run.</p>
<p>We’ll get to these system calls later, so for now let’s just go over the broad<br>strokes as they relate to virtual memory. <code>fork()</code> works by taking the parent<br>process’s virtual memory space and making a copy of it for the child process.</p>
<p><code>exec()</code> allocates a new page directory, figures out how much memory the new<br>program will need when it runs, then grows the virtual memory space allocated in<br>that new page directory to the required size. Then it loads the program into<br>memory in the new page directory.</p>
<p>Next, <code>exec()</code> skips a page, leaving it mapped but user-inaccessible; then the<br>next page becomes the process’s stack. Why that empty page? It’s an important<br>one for protection: that way, user programs that blow their stack will trigger a<br>page fault or a general protection fault instead of possibly overwriting random<br>code.</p>
<p>Then <code>exec()</code> copies some arguments into the stack before it switches to using<br>the new page directory and gets rid of the old one it had before.</p>
<p>Whew, okay, that’s a lot of code to go over later, and that’s only the virtual<br>memory part of the story. So let’s just make it easier by doing all the work we<br>can right now. According to the above, we have to understand how xv6 does all of<br>the following:</p>
<ul>
<li>Makes a copy of a whole page directory,</li>
<li>Creates a new page directory,</li>
<li>Grows (or shrinks) the virtual memory space of a page directory,</li>
<li>Loads program code into a page directory,</li>
<li>Makes a page inaccessible to users,</li>
<li>Copies stuff into a page in a page directory,</li>
<li>Switches to a new process page directory, and</li>
<li>Gets rid of an unused page directory.</li>
</ul>
<p>Finally, there’s one edge case to think about: running the very first process.<br>We obviously need to start running a shell at some point, so we need a special<br>way to get that started too, so it can in turn run other processes.</p>
<h2 id="vm-c-Again"><a href="#vm-c-Again" class="headerlink" title="vm.c, Again"></a>vm.c, Again</h2><p>We’re gonna need some new functions! Actually, we already finished one of the<br>requirements – <code>setupkvm()</code> can allocate a new page directory and set up the<br>kernel portion too. <code>switchkvm()</code> lets us switch to using <code>kpgdir</code> as a page<br>directory, but now we need to switch <em>away</em> from that to a page directory for a<br>process, so that’ll be <code>switchuvm()</code>.</p>
<p><code>copyuvm()</code> creates a copy of an entire page directory for a child process.<br><code>allocuvm()</code> and <code>deallocuvm()</code> grow and shrink the virtual memory space that’s<br>allocated in a page directory, and <code>freevm()</code> clears a page directory we no<br>longer need.</p>
<p><code>loaduvm()</code> will load program code into a page directory; <code>clearpteu</code> makes a<br>page inaccessible to users, and <code>copyout()</code> copies data into a page in a page<br>directory. <code>inituvm()</code> handles the special case of setting up the page directory<br>for the very first process that xv6 will run.</p>
<p>The rest of this post will go over those functions one by one so we can be done<br>with virtual memory, but I know it’s a little strange to go through a million<br>helper functions when we haven’t seen the code that’s gonna use them yet, so if<br>you’d prefer, you can come back to this after reading about processes and system<br>calls.</p>
<h3 id="deallocuvm"><a href="#deallocuvm" class="headerlink" title="deallocuvm"></a>deallocuvm</h3><p>The arguments for this function are a page directory, the process’s old size,<br>and the new size we want to shrink it down to; it’ll return the process’s new<br>size. By “shrinking” a virtual memory space, we really mean making sure that the<br>page directory only allocates up to <code>newsz</code> worth of pages. So if we think of<br>the sizes as virtual addresses, then the page directory currently maps the<br>virtual space from 0 to <code>oldsz</code>, so we should free everything between <code>newsz</code><br>and <code>oldsz</code>, leaving behind the space from 0 to <code>newsz</code>.</p>
<p>First, we should make sure the new size is actually smaller than the old one;<br>otherwise trying to “shrink” down to the new size might cause integer overflow.<br>There; the sizes are both unsigned integers here, so at least it wouldn’t be<br>that scary boogeyman of undefined behavior, but it could still be bad: 0 would<br>wrap around to 2^32 - 1, so “shrinking” to the new size would actually grow the<br>process way beyond what physical memory could handle.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newsz &gt;= oldsz) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re gonna shrink the physical memory allocated to this page directory by<br>freeing pages until we reach the new size. Let’s start with the first page above<br><code>newsz</code>; we can get its virtual address by rounding up <code>newsz</code> to a page<br>boundary.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint a = PGROUNDUP(newsz);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll just iterate over the pages between <code>a</code> and <code>oldsz</code> one at a time and<br>free them. This is a little tricky: <code>kfree()</code> takes a virtual address (cast to a<br><code>char *</code>), but it should be a <em>kernel</em> virtual address in the higher half, not a<br>user virtual address. Luckily, we already have <code>walkpgdir()</code>, which can take an<br>arbitrary virtual address and return its page table entry, so that’s a good<br>start.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walkpgdir(pgdir, (<span class="type">char</span> *) a, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The page table entry contains the page’s physical address, plus some flags to<br>determine whether it’s mapped and what permissions are set for it.</p>
<p>Now, a virtual address space isn’t laid out contiguously. Think about it: if you<br>sit back and imagine a user process hanging out in memory, what does that<br>address space look like? You’re probably imagining the stack at one end of<br>memory and the heap at the other, with each growing toward the center, right?<br>so there will be some pages in the center that aren’t mapped; some of the page<br>tables might not exist either, in which case <code>walkpgdir()</code> would return a null<br>pointer.</p>
<p>Remember we agreed to never dereference null pointers? Yeah, so we’ll have to<br>skip all those unmapped pages. If we got a null pointer, then that means the<br>entire page table doesn’t exist, so we need to skip forward to the next page<br>directory entry (and thus the next page table). We’ll have to move <code>a</code> to the<br>virtual address that corresponds to that next page directory entry.</p>
<p>We can get the page directory index from <code>a</code> with the <code>PDX()</code> macro we’ve seen<br>seen before, and then just add 1 to get the next entry in the page directory.<br>Now we need to turn that back into a virtual address. We’ll use a new macro,<br><code>PGADDR()</code> (also from <a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>),<br>to do that. So then we’ll continue to the next loop iteration, which will get<br>the page table entry for this new virtual address.</p>
<p>Wait wait wait, one last thing! After all that, <code>a</code> should now be the first<br>virtual address in the page table for the new page directory entry… except<br>it’s get <code>PGSIZE</code> added to it because of the for loop’s update statement.</p>
<p>Ugh, okay, fine, this is annoying. Let’s just fix it with a hack: subtract<br><code>PGSIZE</code> from it now, so that it gets incremented to the right value in the next<br>iteration. Okay, that’s it, I swear!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walkpgdir(pgdir, (<span class="type">char</span> *) a, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            a = PGADDR(PDX(a) + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) - PGSIZE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now the else branch: if we don’t get a null pointer then at least the page<br>table exists, but that doesn’t mean the page itself is mapped. If it’s not, then<br>we don’t need to do anything else, but if it is mapped, then we need to free it.<br>We can get the page’s physical address out of the page table entry with the<br><code>PTE_ADDR</code> macro then make sure it’s not null.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            uint pa = PTE_ADDR(*pte);</span><br><span class="line">            <span class="keyword">if</span> (pa == <span class="number">0</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The whole point of this was to be able to call <code>kfree()</code>, remember? So let’s<br>convert <code>pa</code> to a kernel virtual address as a <code>char *</code> and free it. Then after<br>the loop is done, we’ll return the new size.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="type">char</span> *v = P2V(pa);</span><br><span class="line">            kfree(v);</span><br><span class="line">            *pte = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocuvm"><a href="#allocuvm" class="headerlink" title="allocuvm"></a>allocuvm</h3><p>This is the reverse of <code>deallocuvm()</code>: instead of freeing pages with <code>kfree()</code>,<br>we’ll allocate them with <code>kalloc()</code>. Here too, we start by checking for integer<br>overflow by making sure <code>newsz</code> really is larger than <code>oldsz</code>. But now we also<br>have to check that we’re not gonna grow the process’s size into the region where<br>it could access kernel memory; otherwise it might read or modify arbitrary<br>physical memory.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newsz &gt;= KERNBASE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newsz &lt; oldsz) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re gonna start adding new pages right after <code>oldsz</code>, so we have to align that<br>to a page boundary:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint a = PGROUNDUP(oldsz);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The for loop is easier this time around because we already know that the pages<br>aren’t mapped. First we allocate a new page. Any call to <code>kalloc()</code> needs two<br>things after, remember? We have to check for null, in which case we print an<br>error message to the console (that’s <code>cprintf()</code>; we’ll get to that in the<br>devices section), then undo any allocations we made and return 0. Then we have<br>to zero the page because we filled it with 1s when it was freed.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">char</span> *mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;allocuvm out of memory\n&quot;</span>);</span><br><span class="line">            deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We have a page now, but it’s not yet mapped in the page directory. We can do<br>that with <code>mappages()</code>; that might fail too (because it needs to allocate more<br>pages for the page tables), in which case we do the same as before. Then after<br>the for loop is done, we return the new size.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span>, uint oldsz, uint newsz) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappages(pgdir, (<span class="type">char</span> *) a, PGSIZE, V2P(mem), PTE_W | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;allocuvm out of memory (2)\n&quot;</span>);</span><br><span class="line">            deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freevm"><a href="#freevm" class="headerlink" title="freevm"></a>freevm</h3><p>This function will get rid of a user page directory that we no longer need. Now<br>that we have <code>deallocuvm()</code>, it’s easy: we just “shrink” the process to a size<br>of zero. Oh and we’ll remember the lessons our ancestors have taught us and make<br>sure the pointer to the page directory isn’t null before dereferencing it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pgdir == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;freevm: no pgdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    deallocuvm(pgdir, KERNBASE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Great, so all pages are freed, and we’re done!</p>
<p>Now hang on a sec… The page directory itself resides in memory; so do the page<br>tables. We have to free those too. We’ll start with the page tables; freeing the<br>page directory first would be a use-after-free vulnerability because we’d need<br>to use it to get to the page tables.</p>
<p>We’ll iterate over the page directory’s entries, checking whether each one has<br>the “present” flag set (<code>NPDENTRIES</code> is defined as 1024 in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">mmu.h</a>).<br>If it does, we’ll get the page table’s physical address from it with the<br><code>PTE_ADDR()</code> macro, then convert that to a virtual address as a <code>char *</code> to make<br><code>kfree()</code> happy. We don’t have to worry about clearing the “present” flag in the<br>page directory because it’s about to be freed anyway.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; NPDENTRIES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pgdir[i] &amp; PTE_P) &#123;</span><br><span class="line">            <span class="type">char</span> *v = P2V(PTE_ADDR(pgdir[i]));</span><br><span class="line">            kfree(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We wrap up by freeing the page directory itself.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    kfree((<span class="type">char</span> *) pgdir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copyuvm"><a href="#copyuvm" class="headerlink" title="copyuvm"></a>copyuvm</h3><p>The <code>fork()</code> system call will need to “clone” a process, which includes its<br>virtual address space. This function takes a pointer to the parent process’s<br>page directory and the size of the parent process’s address space and returns a<br>pointer to a fresh new page directory with everything set up exactly the same.</p>
<p>We start by creating a new page directory and taking care of the kernel’s half<br>of the address space with <code>setupkvm()</code>. That might fail if it can’t allocate a<br>new page, so we have to check for null. Sigh. C code is approximately 40%<br>checking for null return values.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *d;</span><br><span class="line">    <span class="keyword">if</span> ((d = setupkvm()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll iterate over the user portion of the parent process’s address space<br>from 0 to <code>sz</code>, copying everything over as we go. Say we want to copy a page<br>from the parent’s virtual address <code>i</code> to the child’s address <code>i</code> (note that<br>they’ll map to different physical addresses). We’ll have to figure out the<br>corresponding kernel virtual address for the parent’s <code>i</code> in order to do that,<br>so we use <code>walkpgdir()</code> to get the page table entry, then get the page’s<br>physical address.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, (<span class="type">void</span> *) i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;copyuvm: pte should exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; PTE_P)) &#123;</span><br><span class="line">            panic(<span class="string">&quot;copyuvm: page not present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint pa = PTE_ADDR(*pte);</span><br><span class="line">        uint flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case we know the parent process is already set up, so we don’t really<br>have to worry about <code>walkpgdir()</code> failing and returning null, but it’s bad C<br>juju to ignore a possibly-null return value, so we just panic if it does fail or<br>if the page isn’t present.</p>
<p>Next we allocate a page for the child process (checking for null again…) and<br>copy everything from the parent’s page to the new child page.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">char</span> *mem;</span><br><span class="line">        <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">        memmove(mem, (<span class="type">char</span> *) P2V(pa), PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might recognize <code>memmove()</code> as a C standard library function that copies the<br>contents of one memory address into another, but we can’t use those, remember?<br>So xv6 provides its own implementation of it in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>.</p>
<p>If you haven’t seen a <code>goto</code> statement before, it’s basically a holdover from ye<br>olde days before Edsger Dijkstra preached the gospel of structured programming<br>to the world and invented the if statement. It does exactly what it sounds like:<br>you make a label somewhere in code and it takes you there.</p>
<p>Next we stick that new page into the child’s page directory, checking for null<br>again. If <code>mappages()</code> fails, then the new page won’t be in the page directory,<br>so we have to free it here or else we’ll never be able to find it again: a<br>memory leak.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (mappages(d, (<span class="type">void</span> *) i, PGSIZE, V2P(mem), flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If none of the allocations failed, we just return a pointer to the new page<br>directory. But if something went wrong, then one of those <code>goto</code> statements will<br>send us to the time out corner of <code>bad</code>, where we undo all our work by freeing<br>the page directory and returning a null pointer.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    freevm(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Great, another function we’ll have to check for null.</p>
<h3 id="switchuvm"><a href="#switchuvm" class="headerlink" title="switchuvm"></a>switchuvm</h3><p>Okay, we’ve got a way to create a new process page directory. We also have a way<br>to switch to using the kernel page directory <code>kpgdir</code> with <code>switchkvm()</code>. But we<br>need a way to switch to using the process page directory too. Enter <code>switchuvm()</code>.</p>
<p>I’ll warn you – <code>switchkvm()</code> was nice and short, but <code>switchuvm()</code> is an ugly<br>one for sure.</p>
<p>The argument to this function is a pointer to a <code>struct proc</code>, which represents<br>a process. We’ll talk about that more when we get to processes; two fields are<br>important now: <code>p-&gt;kstack</code> which holds a pointer to the kernel stack for that<br>process, and <code>p-&gt;pgdir</code>, which points to that process’s page directory.</p>
<p>Okay, well let’s start with some sanity checks to make sure that the process <code>p</code><br>actually exists (the pointer is non-null) and its kernel stack and page directory<br>pointers are non-null too.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no process&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kstack == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kstack == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The main function of loading the process’s page directory will be the same as in<br><code>switchkvm()</code>: just an <code>lcr3</code> instruction. But the difference now is that the<br>x86 architecture requires some additional bookkeeping for processes.</p>
<p>See, when the kernel runs a new process, the CPU will start executing different<br>instructions. But it needs a way to keep track of where it left off in the<br>kernel code so that it can pick the thread back up after the process is done<br>executing. Similarly, interrupts and system calls might change the running<br>process, so the CPU needs to record some metadata about the process’s state too<br>before switching to another one. x86 does that by means of a structure called a<br><em>Task State Segment</em>, or TSS.</p>
<p>The TSS holds information like the current state of certain registers (e.g.,<br><code>%esp</code>, <code>%eip</code>, <code>%cr3</code>, etc.), segment descriptors (<code>%cs</code>, <code>%ss</code>, <code>%ds</code>, etc.),<br>the current privilege leve, and I&#x2F;O privilege levels – in other words, the<br>process’s <em>context</em>. It can be located anywhere in memory, but the processor<br>needs to find it, so it uses an entry in the GDT called the TSS segment<br>descriptor that points to the TSS. Remember the GDT from way back when we were<br>talking about segmentation? Good times. The CPU holds a pointer to the GDT’s TSS<br>entry in a special register called the task register.</p>
<p>Back in the segmentation days of our youth, we stored the GDT in a <code>struct cpu</code><br>that held information about the current processor. We got that <code>struct cpu</code> by<br>calling a <code>mycpu()</code> function. We’re gonna do the same thing here in order to<br>update the GDT with a segment for the TSS. Getting interrupted in the middle of<br>this might be disastrous: the TSS would be half-updated, so who knows what would<br>happen when the CPU tried to resume execution where it last left off. So we’ll<br>use the <code>pushcli()</code> and <code>popcli()</code> functions we saw with spin-locks to temporarily<br>disable interrupts.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    mycpu()-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;mycpu()-&gt;ts, <span class="keyword">sizeof</span>(mycpu()-&gt;ts)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    mycpu()-&gt;gdt[SEG_TSS].s = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whoa okay what is this?</p>
<p>We’ve seen the <code>SEG()</code> and <code>SEG_ASM()</code> macros before; they created GDT segments.<br><code>SEG16()</code> does the same with 16 bits (it’s defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>). <code>STS_T32A</code><br>is a flag that sets the segment’s type as an available 32-bit TSS. Then we pass<br>in a pointer to the task state with <code>&amp;mycpu()-&gt;ts</code>, its size, and a descriptor<br>privilege level of 0 (which means ring 0, the kernel level). The GDT’s <code>.s</code><br>field is a one-bit flag to determine whether this is a system or application<br>segment, so we set it to system.</p>
<p>Okay, so now the GDT points to the task state. Next we need to update the task<br>state, then load it into the CPU. We’ll start by storing a segment selector and<br>the stack pointer in the task state; these should look familiar from the boot<br>loader and <code>seginit()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mycpu()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    mycpu()-&gt;ts.esp0 = (uint) p-&gt;kstack + KSTACKSIZE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The TSS can also specify permissions for accessing I&#x2F;O ports: for example,<br>setting the I&#x2F;O privilege level to 0 in the <code>eflags</code> register <em>and</em> setting a<br>part of the TSS called the I&#x2F;O map base address to an address beyond the TSS<br>segment forbids I&#x2F;O instructions like <code>inb</code> and <code>outb</code> from user space. So we’ll<br>set the I&#x2F;O map base address next.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mycpu()-&gt;ts.iomb = (ushort) <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So now we have a GDT entry pointing to the TSS, which is now updated. Now we<br>just load it into the task register with the x86 instruction <code>ltr</code>; here we use<br>a C wrapper for that assembly instruction, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ltr(SEG_TSS &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, the last thing we do before re-enabling interrupts is to load the<br>process’s page directory into the <code>%cr3</code> register so we can start using it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lcr3(V2P(p-&gt;pgdir));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loaduvm"><a href="#loaduvm" class="headerlink" title="loaduvm"></a>loaduvm</h3><p>Okay, this is another function that’s gonna require extra info we haven’t seen<br>yet, but I’m gonna make it a bit easier by waving my hands around and glossing<br>over the details. It’s gonna read a program from a file into memory at virtual<br>address <code>addr</code> using page directory <code>pgdir</code>. The part we want to read has size<br><code>sz</code> and is located at position <code>offset</code> within the file.</p>
<p>Now, what about the file? We’ll talk more when we get to the file system code,<br>but for now let’s just say that files are represented in xv6 as <code>struct inode</code>s,<br>and we can read from them with the function <code>readi()</code>.</p>
<p>We’re gonna run the program from this code, so the address it’s stored in needs<br>to be page-aligned.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((uint) addr % PGSIZE != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;loaduvm: addr must be page aligned&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’re gonna iterate over pages starting from <code>addr</code>, reading from the file<br>in <code>ip</code> into that page. As usual, we’ll need to get the kernel virtual address<br>from the user address <code>addr</code>, so we start by getting the page table entry via<br><code>walkpgdir()</code>, checking for a null pointer if the corresponding page table<br>doesn’t exist. Then we can turn that into a physical address.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// Get the page table entry</span></span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, addr + i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;loaduvm: address should exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get the page&#x27;s physical address</span></span><br><span class="line">        uint pa = PTE_ADDR(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we want to read from the file one page at a time using <code>readi()</code>, which<br>takes a pointer to an inode (here, <code>ip</code>), a kernel virtual address (<code>P2V(pa)</code>),<br>the location within the file of the segment we want to read (<code>offset + i</code>), and<br>the segment’s size.</p>
<p>Now we want to read from the file one page at a time using <code>readi()</code>. We have to<br>specify a size in bytes to read; if the remaining unread part of the segment is<br>larger than a page, then the size we pass to <code>readi()</code> should be <code>PGSIZE</code>, but<br>otherwise it’ll be less. So we’ll compare <code>sz</code> to <code>i</code> and define define <code>n</code><br>accordingly.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        uint n;</span><br><span class="line">        <span class="keyword">if</span> (sz - i &lt; PGSIZE) &#123;</span><br><span class="line">            n = sz - i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n = PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The other arguments to <code>readi()</code> are a pointer to an inode (<code>ip</code>), a kernel<br>virtual address (<code>P2V(pa)</code>), and the location within the file of the segment we<br>want to read (<code>offset + i</code>). It returns the number of bytes read, so if it’s not<br><code>n</code> we’ll report an error by returning -1. Otherwise we return 0 after the for<br>loop is done.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (readi(ip, P2V(pa), offset + i, n) != n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inituvm"><a href="#inituvm" class="headerlink" title="inituvm"></a>inituvm</h3><p>Okay, the next three are nice and easy! This next one is pretty similar to<br><code>loaduvm()</code>, except instead of loading program code from disk, it copies it in<br>from memory. We’ll take <code>sz</code> bytes from a source address of <code>init</code> and stick it<br>in address 0 of the process’s page directory <code>pgdir</code>.</p>
<p>This function is also easier because we’re only gonna call it for programs that<br>are less than one page in size, so we don’t have to worry about looping over<br>pages or anything like that. I like it when xv6 keeps things simple.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sz &gt;= PGSIZE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we allocate a fresh page of memory, zero it to clear the garbage values,<br>and stick it into <code>pgdir</code> at address 0.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> *mem = kalloc();</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    mappages(pgdir, <span class="number">0</span>, PGSIZE, V2P(mem), PTE_W | PTE_U);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And we wrap up by actually loading the code from <code>init</code> into the new page.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    memmove(mem, init, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clearpteu"><a href="#clearpteu" class="headerlink" title="clearpteu"></a>clearpteu</h3><p>This function takes a page directory and a user virtual address and clears the<br>“user-accessible” flag so that the process can’t touch it. It’s used to create<br>an inaccessible page below a new process’s stack to guard against stack<br>overflows; this way, a stack overflow will cause a page fault instead of<br>silently overwriting memory.</p>
<p>The <code>PTE_U</code> flag is in the page table entry, so we’ll have to get that, then set<br>the flag.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearpteu</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *uva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the page table entry</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = walkpgdir(pgdir, uva, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;clearpteu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Clear the user permission flag</span></span><br><span class="line">    *pte &amp;= ~PTE_U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here <code>&amp;</code> is a bitwise-AND and <code>~</code> is a bitwise-NOT; for reference, <code>|</code> is<br>bitwise-OR and <code>^</code> is bitwise-XOR. Contrast these with their logical versions,<br><code>&amp;&amp;</code>, <code>!</code>, and <code>||</code> (XOR has no logical version). C also has corresponding<br>assignment operators (similar to <code>+=</code>, <code>-=</code>, <code>*=</code>, etc.) for each of them. So<br>the last line of code is equivalent to <code>*pte = *pte &amp; (~PTE_U)</code>.</p>
<h3 id="uva2ka"><a href="#uva2ka" class="headerlink" title="uva2ka"></a>uva2ka</h3><p>We often need to convert user virtual addresses to kernel ones; <code>uva2ka()</code> is a<br>short helper function that does that while checking that the page is actually<br>present and has the user permission flag set.</p>
<p>We’ll call walkpgdir to get the page table entry, then check both permission<br>bits before recovering the page address with <code>PTE_ADDR()</code> and converting it to a<br>kernel virtual address. We’ll return the kernel virtual address as a <code>char *</code>,<br>or null if either flag is not set.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">uva2ka</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *uva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walkpgdir(pgdir, uva, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_P) == <span class="number">0</span>) &#123;  <span class="comment">// check that it&#x27;s present</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span>) &#123;  <span class="comment">// check that it&#x27;s user-accessible</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> *) P2V(PTE_ADDR(*pte));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let me ask you a weird question: how are you feeling right now?</p>
<p>Okay, that was a test of your C coding practices, because if you took those null<br>checks to heart, you should be <em>really</em> uncomfortable right about now.</p>
<p>Check it out: <code>walkpgdir()</code> returns a pointer to the page table entry. <em>Any</em><br>time a function returns a pointer, you should immediately ask yourself whether<br>that function can return a null pointer. Tons of C functions report an error by<br>returning null. In this case, we <em>know</em> <code>walkpgdir()</code> can fail and report null<br>if the page table doesn’t exist, so we <em>know</em> we might get a null pointer out of<br>it – it’ll happen whenever a page table doesn’t exist. So what do we do with<br>that knowledge?</p>
<p>Why, we go right ahead and dereference that pointer. WKBW;NQ39Q2A4T8YHMFGRW!!!</p>
<p>Dereferencing a null pointer is undefined behavior. There’s literally no telling<br>what might happen. It can cause all kinds of bugs from segmentation faults to<br>security vulnerabilities.</p>
<p>All those null checks in the other functions serve a purpose: if something goes<br>wrong and a function returns a null pointer, they catch it before it gets<br>dereferenced, then either handle it gracefully or simply propagate the error by<br>returning null (or some other error code) and let the caller figure out what to<br>do with it.</p>
<p>Omitting a check for a null pointer like <code>uva2ka()</code> does is bad practice in C<br>because it means the programmer has to <em>guarantee</em> – by manually checking –<br>that no call to this function could <em>ever possibly</em> cause a null return value.<br>Except humans are dumb, dumb creatures who make mistakes all the time, especially<br>in big projects: there’s no way you’d be able to remember that tiny little<br>detail two years later when you decide to refactor your code or add a new<br>feature or something.</p>
<p>But maybe you can note that in the comments? Okay yeah, but think about it: how<br>often do you go and look up the source code for every single function you call?<br>Yeah, I thought so.</p>
<p>This is why C is so dangerous: there are hundreds of such problems that you need<br>to be aware of and remember to add stuff like null pointer checks to your code.<br>If you don’t because you’re a normal human who forgets things sometimes, then<br>you’ll need to remember that you forgot to do it before and manually check every<br>single call to your code and think about every possible edge case that a<br>malicious adversary might exploit.</p>
<p>Good thing no one ever makes these mistakes in C, or we’d see enormous security<br>vulnerabilities being reported every single day in all kinds of critical<br>software. Oh wait…</p>
<p>So if you ever find yourself looking at C during code review and you come across<br>a function that returns a pointer, you should stop what you’re doing and look up<br>the documentation for that function. If that function has any chance of<br>returning a null pointer, then you should yell and kick and scream until somebody<br>adds a null check and figures out how they want to handle it if it’s null. Is<br>this annoying? Yes. Hard to remember? Yes. But that’s C. <em>(cough cough use Rust<br>instead cough cough…)</em></p>
<p>Now, the xv6 authors are so awesome that I’m gonna give them the benefit of the<br>doubt and assume they left it off because they hand-checked every call to make<br>sure it would never be an issue. But you and me? Nah.</p>
<p>The point of my rant is this: if you’re reading this, then you’re probably gonna<br>find yourself hacking away at xv6 for a project sooner or later. When you do<br>that, you should treat this function as VERBOTEN. You’re not allowed to touch<br>it or call it, at least until you add a null check to it yourself.</p>
<p>The same goes for any functions that call this one, because maybe all the<br>existing calls to <code>uva2ka()</code> are fine right now, but then you make some tiny<br>change and now it’s no longer guaranteed to never be null. For reference, this<br>function currently only gets called by <code>copyout()</code>, and that one only gets<br>called by <code>exec()</code>. <code>exec()</code> gets called by <code>sys_exec()</code>, the shell, and the<br>initial user-space program <code>init</code>. So be careful if you touch any of those.</p>
<p>Whew, okay, &#x2F;rant.</p>
<h3 id="copyout"><a href="#copyout" class="headerlink" title="copyout"></a>copyout</h3><p>This function copies <code>len</code> bytes of data from a kernel virtual address <code>p</code> to a<br>user virtual address <code>va</code> using page directory <code>pgdir</code>. <code>exec()</code> will use this<br>to copy command-line arguments to the stack for a program it’s about to run.</p>
<p>You might be wondering why it’s needed – doesn’t <code>memmove()</code> do the same thing?<br>Almost, but the difficulty is that <code>pgdir</code> may not be the current page<br>directory, so we’ll have to manually translate the virtual address <code>va</code>. That’s<br>where <code>uva2ka()</code> comes in, plus it ensures that the page for <code>va</code> has the right<br>flags set. <em>Then</em> we can use <code>memmove()</code>.</p>
<p>First, <code>p</code> will be the source address, but <code>memmove()</code> requires a <code>char *</code> in<br>order to copy data byte-by-byte, so let’s convert it now:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to get the kernel virtual address corresponding to <code>va</code>, but<br>there’s a challenge: what if the data crosses a page table boundary? It might be<br>spread across separate locations in physical memory (and thus in kernel virtual<br>memory too). So we’ll need a loop in which each iteration gets the next kernel<br>virtual address and copies whatever part of the data is in this page.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        len -= n;</span><br><span class="line">        buf += n;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So we’ll start each iteration by making <code>va0</code> the base address of the page <code>va</code><br>is on and <code>pa0</code> the kernel address of <code>va0</code>, converted with <code>uva2ka()</code>. I…<br>honestly don’t know why they used <code>pa0</code> as an identifier here. It makes it look<br>like it should be a physical address, but it’s not; it’s a kernel virtual<br>address. Sigh. Anyway, the call to <code>uva2ka()</code> might fail if the page isn’t<br>present or it doesn’t have a user permission bit, so we have to check for a null<br>pointer and return -1 if we find one.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        uint va0 = (uint) PGROUNDDOWN(va);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *pa0 = uva2ka(pgdir, (<span class="type">char</span> *) va0);</span><br><span class="line">        <span class="keyword">if</span> (pa0 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        va = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now <code>va</code> is in between <code>va0</code> and the next page, so the length of the data within<br>this page is <code>PGSIZE - (va - va0)</code>, unless it’s the last page, in which case we<br>should pick the lesser of this value and <code>len</code> (since <code>len</code> gets decremented on<br>each iteration through the loop).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        uint n = PGSIZE - (va - va0);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we copy the data from <code>buf</code> into the target kernel virtual address for<br><code>va</code>. Hmm, we don’t have that yet. Oh wait, <code>pa0</code> is the kernel virtual address<br>for <code>va0</code>, and <code>va</code> is just <code>va-va0</code> bytes after that, so we’ll use it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        memmove(pa0 + (va - va0), buf, n);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We return 0 if everything went okay.</p>
<h2 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h2><p>Okay, that was a lot of helper functions, but we’re ALL DONE with virtual<br>memory! From now on, we have all the tools we’ll need to manage memory and set<br>up virtual address spaces for new processes.</p>
<h1 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h1><p>It’s time to turn our attention to processes in xv6!<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a> is another<br>huge file, so I’m gonna split it up into a few posts. This one will focus on the<br>basic functions we’ll need in order to create new processes; later posts will<br>go over scheduling and system calls.</p>
<h2 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a>proc.h</h2><p>I haven’t spent much time on the header files in xv6, but<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/proc.h">proc.h</a> defines some<br>important structures we’re gonna be using often, so let’s just get those out of<br>the way first.</p>
<p>Let’s start off with the definition for <code>struct context</code>. The processor will<br>have to switch between different processes during interrupts, system calls,<br>exceptions, etc.; these <em>context switches</em> will require saving the contents of<br>some of the CPU registers so that it can reload them when it switches back and<br>resume execution where it left off. It’ll save the process’s context by pushing<br>those register contents on the stack; that way the stack pointer is effectively<br>a pointer to the context. So the fields of a <code>struct context</code> will just list all<br>the registers that were saved on the stack.</p>
<p>Now, which registers do we need to save? Let’s look at the full list on the<br><a href="https://wiki.osdev.org/CPU_Registers_x86">OSDev Wiki</a>. We’ve got some general-<br>purpose registers, the instruction pointer register <code>%eip</code>, segment registers,<br>a flags register, control registers, and the GDT and IDT registers (x86 doesn’t<br>use the debug, test, or LDT registers).</p>
<p>The flags register, control registers, and GDT&#x2F;IDT registers shouldn’t change<br>between processes, so we don’t need to save those. What about the segment<br>registers like <code>%cs</code>? Back when we set up segmentation, we made the segments be<br>identity maps that would always stay the same for all processes. There are<br>separate segments for user mode and kernel mode, but context switches will<br>always occur in kernel mode, so the segment registers shouldn’t change, and we<br>don’t need to save them either.</p>
<p>We should definitely save the program counter (AKA instruction pointer <code>%eip</code>),<br>since that will point to the place in the code where we should resume execution.</p>
<p>The only ones left now are the general-purpose registers: the stack base pointer<br><code>%ebp</code> and stack pointer <code>%esp</code>, along with <code>%eax</code>, <code>%ebx</code>, <code>%ecx</code>, <code>%edx</code>,<br><code>%esi</code>, and <code>%edi</code>. We said above that the stack pointer <code>%esp</code> would tell us<br>where to find the context, so that must mean we’ll already have it through some<br>other means in order to find the rest of the context, so we don’t need to save<br>it again (we’ll see how we end up getting it later on). But we do need to save<br><code>%ebp</code>.</p>
<p>There’s an x86 convention that the caller of a function has to save <code>%eax</code>,<br><code>%ecx</code>, and <code>%edx</code>, so those are already taken care of. So we’ll just save the<br>others: <code>%edi</code>, <code>%esi</code>, and <code>%ebx</code>.</p>
<p>We end up with this list of saved registers as the fields for <code>struct context</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    uint edi;</span><br><span class="line">    uint esi;</span><br><span class="line">    uint ebx;</span><br><span class="line">    uint ebp;</span><br><span class="line">    uip eip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Next up: we might end up with a bunch of processes, some of which are currently<br>running while others aren’t. Let’s set up some labels to note that. We’ll<br>definitely need a <code>RUNNING</code> label; we’ll also use one called <code>RUNNABLE</code> for<br>processes that are ready to be run the next time there’s a free CPU. We also<br>need a label for processes that are blocked waiting for something else to happen<br>(e.g., I&#x2F;O); xv6 calls this <code>SLEEPING</code>. Processes that don’t exist yet will be<br>called <code>UNUSED</code>.</p>
<p>There are two special moments in a process’s lifecycle that we should be careful<br>with: birth and death. When we create a new process, we’ll have to do a bunch of<br>setup before it’s <code>RUNNABLE</code>; killing a process requires clean-up before it goes<br>back to <code>UNUSED</code>. We’ll call those <code>EMBRYO</code> and <code>ZOMBIE</code>, respectively.</p>
<p>We could use bit flags for these states or just regular integers, except then<br>we’d have to do annoying bit arithmetic or keep track of which number represents<br>which state. And yes, we could use a bunch of <code>#define</code> directives for the<br>preprocessor for that, but there’s a better way to do it. C lets us create data<br>types for labels using <code>enum</code>s. These don’t have fields like <code>struct</code>s do;<br>they’re basically just a mapping between integers and what the labels those<br>integers represent. So it’s pretty similar to using a bunch of <code>#define</code><br>directives, except that they’re all defined neatly in a single place, so it<br>helps us remember they’re all representing the same idea. So we’ll use an <code>enum</code><br>like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Now it’s time to look at how we’ll represent processes themselves together with<br>their metadata. Let’s see… what kind of unique data does each process have?<br>We just talked about <code>struct context</code>s and <code>enum procstate</code>s; each process will<br>have both of those.</p>
<p>We also talked about virtual memory for processes in a previous post, so it<br>should also have its own page directory and stack for the kernel to use, plus a<br>way to track the size of its virtual address space. We said then that processes<br>are created using <code>fork()</code>, so let’s add a field to point to the parent process.</p>
<p>We’ll need a way for the kernel to refer to a process, so let’s give it a unique<br>process ID. That’s not super helpful when it comes to debugging, so let’s also<br>add a name for it as a string.</p>
<p>The rest of the fields are for aspects we haven’t seen yet but will talk about<br>soon: a <em>trap frame</em> for interrupts and system calls, a boolean to track whether<br>a process should be killed soon, a <em>channel</em> to be able to wake up a sleeping<br>process, an array of open files, and a current working directory.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    uint sz;                    <span class="comment">// size (in bytes) of virtual address space</span></span><br><span class="line">    <span class="type">pde_t</span> *pgdir;               <span class="comment">// page directory</span></span><br><span class="line">    <span class="type">char</span> *kstack;               <span class="comment">// kernel stack for this process</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>       <span class="comment">// process state</span></span><br><span class="line">    <span class="type">int</span> pid;                    <span class="comment">// process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>        <span class="comment">// parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// trap frame for current system call</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span>    <span class="comment">// saved register contents for context switches</span></span><br><span class="line">    <span class="type">void</span> *chan;                 <span class="comment">// channel that process is sleeping on, if any</span></span><br><span class="line">    <span class="type">int</span> killed;                 <span class="comment">// boolean: should process be killed soon?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// array of open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>          <span class="comment">// current working directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];              <span class="comment">// process name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Okay, next we’ll add another structure for metadata representing each CPU.</p>
<p>If you read the previous post, then you know each CPU has its own local<br>interrupt controller with a unique ID, so we’ll write that down. The post about<br>process paging talked about the TSS, so we’ll need one of those per CPU, plus a<br>GDT too.</p>
<p>At any point in time, a processor will be running one of: its own initialization<br>routine (only once while the kernel is setting up), a user process (or any<br>interrupts or system calls that come up), or a scheduler routine to run the next<br>process. So let’s add a pointer to a <code>struct proc</code>, which will be null if it’s<br>not running a process; a boolean <code>started</code> will be false until the CPU finishes<br>its own set-up. The scheduler isn’t itself a process; it uses the <code>kpgdir</code> page<br>directory and has its own context, so we’ll store that context in a field here.</p>
<p>Finally: remember how the spin-lock post talked about nested calls to <code>pushcli()</code><br>and <code>popcli()</code> tracking whether interrupts were enabled before the first call to<br><code>pushcli()</code>, and only enabling interrupts after the last call to <code>popcli()</code> if<br>they were enabled before? Those were tracked with per-CPU fields <code>ncli</code> and<br><code>intena</code>, so we need those too.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">    uchar apicid;               <span class="comment">// ID of this CPU&#x27;s local interrupt controller</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">scheduler</span>;</span>  <span class="comment">// scheduler&#x27;s context</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span>;</span>        <span class="comment">// task state segment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[<span class="title">NSEGS</span>];</span>  <span class="comment">// global descriptor table</span></span><br><span class="line">    <span class="keyword">volatile</span> uint started;      <span class="comment">// boolean: has this CPU been initialized yet?</span></span><br><span class="line">    <span class="type">int</span> ncli;                   <span class="comment">// depth of pushcli() nesting</span></span><br><span class="line">    <span class="type">int</span> intena;                 <span class="comment">// were interrupts enabled before pushcli()?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// currently running process</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Last but not least, we’ll add declarations for the global array of CPUs and the<br>number of CPUs actually present on this machine; these were defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mp.c">mp.c</a></p>
<p>Okay, on to the functions now!</p>
<h2 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a>proc.c</h2><p>xv6 uses a global process table with an array of processes to store all the<br><code>struct proc</code>s in; this means we’ll never be able to create more processes than<br>the number of entries in the array, <code>NPROC</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 64.<br>We’ll need a lock too to prevent data races while accessing the process table.<br>The process table’s definition does that thing again where you simultaneously<br>define a <code>struct type</code> and define a variable using that type in a single<br>statement.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line">&#125; ptable;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Then we define a global static variable to point to the first process that gets<br>run on xv6, so that other files can set it up.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">initproc</span>;</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Finally, we’re gonna need to assign unique process IDs, so we’ll use a global<br>counter to know which one we should use next.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="pinit"><a href="#pinit" class="headerlink" title="pinit"></a>pinit</h3><p>This function only does one thing: initializes the lock in the process table.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;ptable.lock, <span class="string">&quot;ptable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mycpu"><a href="#mycpu" class="headerlink" title="mycpu"></a>mycpu</h3><p>This function will return a pointer to the <code>struct cpu</code> for the current CPU.<br>There’s a potential concurrency bug with this function: if it gets interrupted<br>before it returns, then it might get rescheduled on a different CPU, and end up<br>returning an incorrect <code>struct cpu</code>. So we need to make sure that interrupts are<br>disabled when we call it. Normally we’d do that with <code>pushcli()</code> and <code>popcli()</code>,<br>but those functions actually call this one, so we’d get an infinite recursion.<br>So instead we’re just gonna have to remember to disable interrupts <em>before</em><br>calling this function.</p>
<p>If you’re reading this because you’re gonna do some xv6 kernel hacking for an<br>OSTEP project or something, you should read that as “DANGER DANGER DANGER!”. If<br>your code calls this function, or calls any other functions that in turn call<br>this one, you <em>have</em> to make sure you’ve disabled interrupts first.</p>
<p>Concurrency bugs are a nightmare because they’re not deterministic: for example,<br>if you forget to disable interrupts before calling this function, it might work<br>just fine most of the time until the one unlucky moment when it gets interrupted<br>and rescheduled on a different CPU. So let’s make this easier to debug by<br>starting off with a check that interrupts are disabled and panic if they’re not.<br>We can check whether the interrupt flag <code>FL_IF</code> is set in the <code>eflags</code> register.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *<span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;mycpu called with interrupts enabled\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay so how do we figure out which CPU we’re on? Well, the previous post talked<br>about interrupt controllers; each CPU has a local interrupt controller with a<br>unique ID which we can get with <code>lapicid()</code>. Once we have that, we can iterate<br>over the CPU array <code>cpus</code> until we find an entry with a matching <code>apicid</code>; we’ll<br>just panic if none of them match.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *<span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> apicid = lapicid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ncpu; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpus[i].apidid == apicid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;cpus[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;unknown apicid\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cpuid"><a href="#cpuid" class="headerlink" title="cpuid"></a>cpuid</h3><p>Those local interrupt controller IDs aren’t guaranteed to start from 0, so we’ll<br>need another way to identify CPUs. We can just use its entry number in the<br>global <code>cpus</code> array for that; <code>cpus</code> is an array of <code>struct cpu</code>s, which in C<br>means it’s really a pointer to the entry with index 0. <code>mycpu()</code> returns a<br>pointer to the entry for the current CPU, so we can just subtract those pointers<br>to get the index.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpuid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mycpu() - cpus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="myproc"><a href="#myproc" class="headerlink" title="myproc"></a>myproc</h3><p>This function returns a pointer to the <code>struct proc</code> running on this CPU. We’re<br>gonna call <code>mycpu()</code> here, so we’ll be good and remember to dsable interrupts<br>first with <code>pushcli()</code> and reenable them at the end with <code>popcli()</code>. Then we’ll<br>get the current process from the <code>struct cpu</code>‘s field.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc *<span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocproc"><a href="#allocproc" class="headerlink" title="allocproc"></a>allocproc</h3><p>Okay, we’re finally at the code to create a new process! Whew, it’s been a long<br>journey.</p>
<p>This is a <code>static</code> function, which means it can only be called by functions<br>defined in this same file. Creating a new process will require modifying the<br>process table, so we need to grab the lock so that other threads can’t mess with<br>it while we’re using it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to look through the table and find a slot that’s <code>UNUSED</code>; if we<br>find on, then great, we’ll assign that slot to the new process after the <code>found</code><br>label below. But if none of them are free, we’ll have to return a null pointer<br>to indicate that. You know what that means, right? Yup, we’re gonna have to add<br>null checks every time we call this function! Wooooo!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look through process table looking for an UNUSED slot</span></span><br><span class="line">    <span class="keyword">for</span> (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If none is found, return null pointer</span></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Check out that for loop too: <code>p</code> is a pointer to a <code>struct proc</code> that starts off<br>pointing to <code>ptable.proc</code>; that means it points to the entry and index 0. Then<br>it gets incremented by 1 each iteration; since it’s a <code>struct proc</code>, the pointer<br>arithmetic will work out so that it points to the next entry in the process<br>table.</p>
<p>Okay now let’s check out the <code>found</code> label and see what happens if we did find<br>an unused slot. First we set its state to <code>EMBRYO</code> (instead of <code>RUNNABLE</code>, since<br>we’re not done setting it up) and give it a PID. That state means it’s neither<br><code>UNUSED</code> nor <code>RUNNABLE</code>, so we can be confident that any other threads wouldn’t<br>try messing with it right now; they can’t allocate the slot to another process,<br>and they can’t try to run it yet. So we can stop hogging the process table now<br>and let other threads take a turn.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    p-&gt;state = EMBRYO;</span><br><span class="line">    p-&gt;pid = nextpid++;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to allocate a page for this process’s kernel thread to use as a<br>stack. Remember, <code>kalloc()</code> can return null, so we need a null check here.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;kstack = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;state = UNUSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we’re not gonna set up its page directory yet; that’ll happen in <code>fork()</code>,<br>which we’ll see later on. But we do need to set up the process so that it’ll<br>start executing code somewhere. It needs to start off in kernel mode, then it’ll<br>context-switch back into user mode and start running its code.</p>
<p>We haven’t looked at the mechanics of context switches yet, so I’ll spoil it a<br>little now (I know, I’m sorry). When a process is already running, it can send a<br>system call to ask for the kernel’s attention to do whatever it needs, like a<br>baby crying until it gets fed or changed or burped or whatever. Then it’ll<br>switch into kernel mode to run the system call, then switch back to where it<br>left off and pick up from there.</p>
<p>Well, xv6 is all about simplicity, right? And what’s more simple and elegant<br>than treating a special case (creating a new process and starting it off running<br>some code) the same as the general case (returning from a system call)? So xv6<br>will set up every new process to start off by “returning” from a (non-existent)<br>system call. That way the context switch code can be reused for new processes<br>too.</p>
<p>New processes are created via <code>fork()</code>, so we’ll return into a function called<br><code>forkret()</code>. Then that has to return into the function <code>trapret()</code>, which<br>closes out a <em>trap</em> (interrupt, system call, or exception) by restoring saved<br>registers and switching into user mode. We’ll get to <code>forkret()</code> and <code>trapret()</code><br>soon.</p>
<p>But first, the challenge: how do we “return” into a function that never called<br>us in the first place? We talked about function calls in x86 in the post on<br>spin-locks with the <code>getcallerpcs()</code> function, so make sure to read that now if<br>you need a refresher.</p>
<p>To summarize: when a function <code>f()</code> calls another function <code>g()</code>, it pushes the<br>arguments of <code>g()</code> on the top of its stack. Then it pushes a return address to<br>know where it should continue running the code of <code>f()</code> after <code>g()</code> returns;<br>that’s just the <code>%eip</code> register. Then it pushes the base address of the stack<br>for <code>f()</code>, i.e. the current <code>%ebp</code> register. That’s where <code>g()</code>‘s stack will<br>start off.</p>
<p>When the scheduler first runs the new process, it’ll check its context via<br><code>p-&gt;context</code> to get its register contents, including the instruction pointer<br><code>%eip</code>. So if we want it to start executing the code in <code>forkret()</code>, the <code>eip</code><br>field of its context should point to the beginning of <code>forkret()</code>. Then we can<br>trick it into thinking that the previous caller was <code>trapret()</code> by setting up<br>arguments and a return address in its stack.</p>
<p>Let’s start off by getting a pointer to the bottom of the stack. We had just<br>allocated a new stack page at <code>p-&gt;kstack</code>, but the stack grows from high to low<br>addresses, so the base of the stack is really at <code>p-&gt;kstack + KSTACKSIZE</code>. We’ll<br>make it a <code>char *</code> so we can move around one byte at a time using pointer<br>arithmetic.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> *sp = p-&gt;<span class="built_in">stack</span> + KSTACKSIZE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we should push any arguments for <code>trapret()</code> on the stack; it takes a<br><code>struct trapframe</code> (which we’ll go over later), so we’ll leave some room for it<br>and make the process point to it with <code>p-&gt;tf</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="keyword">sizeof</span>(*p-&gt;tf);</span><br><span class="line">    p-&gt;tf = (<span class="keyword">struct</span> trapframe *) sp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we add a “return address” to the beginning of <code>trapret()</code> after that.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="number">4</span>;</span><br><span class="line">    *((uint *) sp) = (uint) trapret;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last thing we need is to save some space for the process’s context on the<br>stack and point <code>p-&gt;context</code> to it. Then we’ll zero it all out, except for the<br><code>eip</code> field, which will point to the beginning of <code>forkret()</code>. And that’s it!<br>We just return the pointer to the process now.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="keyword">sizeof</span>(*p-&gt;context);</span><br><span class="line">    p-&gt;context = (<span class="keyword">struct</span> context *) sp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(*p-&gt;context));</span><br><span class="line">    p-&gt;context-&gt;eip = (uint) forkret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can create new processes now!</p>
<h3 id="growproc"><a href="#growproc" class="headerlink" title="growproc"></a>growproc</h3><p>What about growing or shrinking the size of a process’s address space? We<br>already did most of the hard work with <code>allocuvm()</code> and <code>deallocuvm()</code> from the<br>post on process paging, so let’s take a beat to thank past us for that.</p>
<p>Okay, so first we have to get the current process’s size.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    uint sz = curproc-&gt;sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Depending on the size of <code>n</code>, we’ll either grow the process or shrink it by <code>n</code><br>bytes. Both <code>allocuvm()</code> and <code>deallocuvm()</code> can fail and return zero, so let’s<br>add some checks for those and return -1 if they fail.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sz = allocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sz = deallocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curproc-&gt;sz = sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we need to tell the hardware that there’s a new page directory in town<br>with a different size than the old one, so we’ll use <code>switchuvm()</code> to update<br>the page directory and TSS stored by the hardware to reflect the changes. Then<br>we return 0 to indicate everything went okay.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    switchuvm(curproc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="procdump"><a href="#procdump" class="headerlink" title="procdump"></a>procdump</h3><p>This function is for debugging purposes: it’ll print a complete listing of any<br>processes in the process table. Quick spoiler: the keyboard interrupt handler<br>function will set things up so that pressing <code>^P</code> runs this function. Go ahead,<br>load up xv6 and try it out!</p>
<p>We want to print out the state for each process, but the states in <code>enum procstate</code> are just integers, which isn’t very debug-friendly. So let’s map them<br>all to strings first with a static array of strings.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *states[] = &#123;</span><br><span class="line">        [UNUSED]    <span class="string">&quot;unused&quot;</span>,</span><br><span class="line">        [EMBRYO]    <span class="string">&quot;embryo&quot;</span>,</span><br><span class="line">        [SLEEPING]  <span class="string">&quot;sleep &quot;</span>,</span><br><span class="line">        [RUNNABLE]  <span class="string">&quot;runble&quot;</span>,</span><br><span class="line">        [RUNNING]   <span class="string">&quot;run   &quot;</span>,</span><br><span class="line">        [ZOMBIE]    <span class="string">&quot;sombie&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This array notation might be a little unusual if you haven’t seen it before: C<br>lets you initialize arrays by specifying the value of each entry. If you leave<br>any entries out, then they’ll get initialized to zero. You can even write the<br>entries out of order by adding their index before them in square brackets. So<br><code>{ [1] 5, [0] 2 }</code> is the same thing as <code>{2, 5}</code>. The <code>enum</code> turns the states<br>into integers, so they work as indices here.</p>
<p>Now we’ll just iterate over the process table to get all the processes, skipping<br>over any <code>UNUSED</code> ones.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll get the process’s state (or just use <code>&quot;???&quot;</code> if something went wrong<br>and the state isn’t recognized).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">char</span> *state;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state &gt;= <span class="number">0</span> &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state]) &#123;</span><br><span class="line">            state = states[p-&gt;state];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we can print out its PID, state, and name to the console.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        cprintf(<span class="string">&quot;%d %s %s&quot;</span>, p-&gt;pid, state, p-&gt;name);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll see later on that the <code>sleep()</code> and <code>wakeup()</code> system calls<br>involve some lock trickery, so sleeping processes could be a common cause of<br>concurrency issues like deadlocks. So if a process is sleeping, we’ll print out<br>its call stack using the <code>getcallerpcs()</code> function.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">            uint pc[<span class="number">10</span>];</span><br><span class="line">            getcallerpcs((uint *) p-&gt;context-&gt;ebp + <span class="number">2</span>, pc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; pc[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">                cprintf(<span class="string">&quot; %p&quot;</span>, pc[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h2><p>Whew, we’re making good progress. The most important part of this code was how<br>xv6 creates new processes and sets them up to start running: basically, it uses<br>some stack and function call trickery to make the scheduler start running a new<br>process with the code in <code>forkret()</code>, then <code>trapret()</code>, before switching context<br>into user mode.</p>
<p>We haven’t talked about those two functions yet; we’ll hold off on that until we<br>do traps and system calls. Next up is scheduling processes!</p>
<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><p>We’ve done a lot of talking about context switching and scheduling, but we’ve<br>procrastinated looking at the code for those. It’s time to fix that.</p>
<p>There are all kinds of advanced schedulers out there, but as we’ve said before,<br>the name of the game in xv6 is simplicity, so xv6 just uses a round-robin<br>scheduling algorithm in which in loops through the exisitng processes in order.<br>Each timer interrupt will force the current process to yield the processor and<br>perform a context switch back into the scheduler so it can run the next<br>available process.</p>
<h2 id="swtch-S"><a href="#swtch-S" class="headerlink" title="swtch.S"></a>swtch.S</h2><p>The <code>struct context</code> we talked about in the last post is gonna be key here, so<br>let’s just look at its fields again:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    uint edi;</span><br><span class="line">    uint esi;</span><br><span class="line">    uint ebx;</span><br><span class="line">    uint ebp;</span><br><span class="line">    uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The context switch function is <code>swtch()</code>; it’s gonna need to save and restore<br>processor registers, so that means it’s gonna have to be written in assembly.<br>But let’s pretend it’s just a C function for a second and talk about what it’s<br>going to do.</p>
<p>This function will save the contents of the registers on the stack as a <code>struct context</code>, then save that location as the old context. Then it’ll load a new<br>context, switch to the new stack, and restore the registers of the new context.<br>Its declaration would look like this in C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context **old, <span class="keyword">struct</span> context *new)</span>;</span><br></pre></td></tr></table></figure>
<p>The first argument is a pointer <em>to a pointer</em> to a <code>struct context</code>. That<br>double indirection might be confusing, but there’s a method to this madness: C<br>passes arguments by value, so if we used <code>struct context *old</code> and changed <code>old</code><br>to point to the saved context, it would be lost as soon as we returned from this<br>function. So instead we have to use this kind of double pointer so we can set<br><code>*old</code> to point to the saved context. This way <code>old</code> will be lost anyway, but<br><code>*old</code> was changed and will persist beyond this function’s return.</p>
<p>Note that, as we’ve said before, those arguments will be pushed on the stack<br>before <code>swtch()</code> is called. So at the beginning of <code>swtch()</code>, the stack pointer<br><code>%esp</code> points to a return address; the argument <code>old</code> is one space (4 bytes)<br>above that in the stack, and <code>new</code> is one space higher than that.</p>
<p>Okay, let’s check out the assembly code now. We’re gonna start by saving those<br>arguments into registers. We can’t just use any old registers here, or we might<br>overwrite some of the data we’re trying to save. But in the last post, I said<br>x86 has a convention that the caller has to save the contents of the <code>%eax</code>,<br><code>%ecx</code>, and <code>%edx</code> registers, so that means we’re free to overwrite them all we<br>want since they’ve already been saved.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">    movl    4(%esp), %eax</span><br><span class="line">    movl    8(%esp), %edx</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>
<p>We haven’t seen this number-parenthesis notation in assembly yet, so in case<br>you’re not familiar with x86 assembly, it’s just a way to add a number to the<br>contents of a register, then treating it as a pointer and dereferencing it. So<br><code>4(%esp)</code> in assembly is the same as <code>*(esp + 4)</code> in C. So at this point, <code>%eax</code><br>holds the <code>struct context **old</code> pointer, and <code>%edx</code> holds the<br><code>struct context *new</code> pointer.</p>
<p>Now it’s time to save all the fields in a <code>struct context</code> on the stack. The<br>stack grows from high addresses to low ones, but C <code>structs</code> expect their fields<br>to be from low to high, so we’ll save them in reverse order. Oh, and hang on –<br>remember what’s at the bottom of the stack right now, after the arguments?<br>That’s right, a return address. That’s just a saved <code>%eip</code>, so that one’s<br>already done for us! We just need to save the others.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    pushl   %ebp</span><br><span class="line">    pushl   %ebx</span><br><span class="line">    pushl   %esi</span><br><span class="line">    pushl   %edi</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Next we have to save a pointer to this old <code>struct context</code> into <code>*old</code>. Well,<br>we pushed them on the stack in reverse order, right? So <code>%esp</code> already <em>is</em><br>pointing to it, so that’s our pointer; we’ll just copy it into <code>*old</code> (remember<br>it’s stored in <code>%eax</code>, and we dereference it in assembly with parentheses).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    movl    %esp, (%eax)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Now it’s time to switch stacks to the <code>new</code> context, which we saved in <code>%edx</code>.<br>That context must have been saved by a previous call to <code>swtch()</code>, so it also<br>happens to be a stack pointer as well.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    movl    %edx, %esp</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>At this point, we’re using the stack from <code>new</code>, which will already have its<br>saved context at the top. So we can load the new context by popping it off the<br>stack in reverse order into the corresponding registers. And again, just like<br>the <code>call</code> instruction had already saved <code>%eip</code> on the stack as the return<br>address, the <code>ret</code> (return) instruction will pop it off and restore it into<br><code>%eip</code> for us.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    popl    %edi</span><br><span class="line">    popl    %esi</span><br><span class="line">    popl    %ebx</span><br><span class="line">    popl    %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>And that’s it! That’s a context switch in xv6.</p>
<h2 id="proc-c-1"><a href="#proc-c-1" class="headerlink" title="proc.c"></a>proc.c</h2><p>And now, finally, we can look at the scheduling code. Once the kernel is done<br>setting itself up, initializing all the devices and drivers, etc., the very last<br>function that <code>main()</code> calls is <code>scheduler()</code>. Interrupts were disabled in the<br>boot loader and haven’t been enabled yet, so it’s also the scheduler’s job to<br>enable them for the first time in xv6.</p>
<p><code>scheduler()</code> never returns; it’s an infinite loop that just keeps searching<br>through the process table for a <code>RUNNABLE</code> process, then runs it. So from that<br>point on, with the exception of interrupts and system calls, the kernel will<br>only ever do one thing: schedule processes to run.</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>A CPU that’s running the scheduler isn’t running its own process. So we’ll start<br>off by setting this CPU’s process pointer to null. Note that <code>mycpu()</code> requires<br>interrupts to be disabled before it’s called, but that’s okay here because<br>interrupts were disabled in the boot loader and haven’t been re-enabled before<br>the scheduler is called.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">    c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The order of the next few steps is tricky, and the authors of xv6 had to be<br>extremely careful to do them in the right order to avoid concurrency problems.<br>We need to (1) re-enable interrupts, (2) acquire the process table’s lock, and<br>(3) create an infinite loop to iterate over the process table forever, scheduling<br>processes along the way. To see why this is nontrivial, let’s check out some<br>different orders (with a <code>fake_scheduler()</code> function) and see what problems we<br>get.</p>
<p>ATTEMPT #1: interrupts -&gt; lock -&gt; loop. Let’s try it out.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fake_scheduler1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sti();                  <span class="comment">// enable interrupts</span></span><br><span class="line">    acquire(&amp;ptable.lock);  <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              <span class="comment">// infinite scheduling loop</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interrupts have been disabled since the boot loader used <code>cli</code>, so when we call<br><code>sti()</code> here they’ll be turned on for the first time in the kernel. At that<br>point we’ll find out if there were any interrupts waiting to be acknowledged,<br>and possibly jump into some handler function to take care of it. Then when<br>that’s done, we’ll come back here and acquire the process table’s lock. Acquiring<br>a lock disables interrupts, remember? So they’re disabled again in the infinite<br>scheduling loop (but not forever; we’ll release the lock before switching to a<br>user process). That sounds okay, right?</p>
<p>Not so fast! There’s a hidden problem: suppose we had a situation in which none<br>of the current processes are <code>RUNNABLE</code> – maybe they’re all blocked (or<br><code>SLEEPING</code>) waiting for I&#x2F;O or something, which is not unlikely. In that case,<br>the scheduler would just keep idly looping through the process table until one<br>of them becomes <code>RUNNABLE</code> again. But if interrupts are always disabled in the<br>loop, then this processor will never find out about, e.g., a disk interrupt<br>saying it’s done reading data which would allow a blocked process to become<br><code>RUNNABLE</code>. That means the process will never find out the condition it’s<br>waiting for has already happened, which means the scheduler will never find any<br><code>RUNNABLE</code> processes. It’ll just get stuck in an infinite loop, repeatedly and<br>desperately searching every entry of the process table. So basically, the<br>system would freeze while the CPU pointlessly spins at top speed.</p>
<p>Okay okay, so that doesn’t work. We’ll have to periodically re-enable interrupts<br>before disabling them again. So let’s try moving the call to <code>sti()</code> inside the<br>infinite loop so interrupts get re-enabled every once in a while.</p>
<p>ATTEMPT #2: lock -&gt; loop -&gt; interrupts.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fake_scheduler2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;ptable.lock);  <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              <span class="comment">// infinite scheduling loop</span></span><br><span class="line">        sti();              <span class="comment">// temporarily enable interrupts</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Problem solved, right? Actually… this one turns out to be just as bad. The<br>call to <code>acquire()</code> disables interrupts, only for <code>sti()</code> to enable them again.<br>There’s a reason that locks disable interrupts, remember? If an interrupt occurs<br>that switches away from <code>scheduler()</code>, then it might call a handler function<br>that needs to access the process table lock, which is already held by<br><code>scheduler()</code>, so that function would spin forever in a deadlock.</p>
<p>So now we arrive at the correct order: we’ll call <em>both</em> <code>sti()</code> and <code>acquire()</code><br>inside the loop, in that order. That means we’ll also need a call to <code>release()</code><br>at the end of the loop before we try to <code>acquire()</code> again in the next iteration.<br>We had already said we’d have to release the lock before running a process; now<br>we’ll have to acquire it again before context-switching back into the loop.</p>
<p>ATTEMPT #3 (the right one): loop -&gt; interrupts -&gt; lock. This will give us a<br>chance to detect any outstanding interrupts in each iteration of the for loop,<br>but before we’ve acquired the lock again and thus, before doing so could cause a<br>deadlock.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        sti();</span><br><span class="line">        acquire(&amp;ptable.lock);</span><br><span class="line">        <span class="comment">// ... pick a process and run it ...</span></span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Whew, okay. Basically, we’ve learned that concurrency bugs can be hard to predict<br>and can turn seemingly-fine code into impossible-to-diagnose system crashes or<br>freezes.</p>
<p>Okay, so now let’s fill in the part of the loop where the scheduling algorithm<br>goes. We’ll add an inner for loop to iterate over the process table entries<br>and stop when we find a <code>RUNNABLE</code> process.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state != RUNNABLE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... run that process ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, if we found a process, then we need to switch to that process’s virtual<br>address space; that is, we need to start using its page directory.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            c-&gt;proc = p;</span><br><span class="line">            switchuvm(p);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if we just switched to an arbitrary page directory in the middle of running<br>other code, we might cause a bunch of problems: all the virtual addresses we’re<br>currently using for variables, functions, instructions, etc. might suddenly<br>become invalid and point to random other places in memory. But this is where can<br>see some of the earlier design decisions in xv6 start to pay off: remember how<br><code>setupkvm()</code> made sure every single process would have the exact same mappings<br>for the upper half of the address space, starting at <code>KERNBASE</code>? That means that<br>if we’re running in kernel mode, we can arbitrarily switch to any process’s page<br>directory and know that all of our mappings will be exactly the same. The user<br>mappings in the lower half might be different, but the kernel side will never<br>change. Nice!</p>
<p>Now we can run the process using <code>swtch()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            p-&gt;state = RUNNING;</span><br><span class="line">            swtch(&amp;(c-&gt;scheduler), p-&gt;context);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swtch()</code> will <em>not</em> return here immediately; instead, it’ll pick up execution<br>wherever the process last left off, which will be in kernel mode – if it<br>stopped running before, it must have been due to a system call, interrupt, or<br>exception, which would have been handled in kernel mode before calling the<br>scheduler.</p>
<p>Note that this process will still be holding the process table lock when it<br>starts running again. For example, that’s the main reason for the existence of<br>the <code>forkret()</code> function we mentioned before. This is another dangerous detail<br>we’ll have to remember, so I’m just gonna go ahead and hope you remember THIS<br>BIG GIANT GLARING WARNING FLAG RIGHT HERE: if you do any xv6 kernel hacking, and<br>you want to add a new system call that will let go of the CPU, then your code<br><em>must</em> release the process table lock at the point at which it starts executing<br>after switching to it from the scheduler.</p>
<p>This is pretty dangerous; if xv6 were a big project, it would be really easy to<br>forget that when adding more features later on. But in this case, there’s no<br>easy way to get around it; for example, we can’t just release the process table<br>lock before calling <code>swtch()</code> and reacquire it after. The problem becomes<br>apparent if you think of locks as protecting some invariant; that invariant<br>might be temporarily violated while you hold the lock, but it should be restored<br>before the lock is released.</p>
<p>The process table protects invariants related to the process’s <code>p-&gt;state</code> and<br><code>p-&gt;context</code> fields, e.g. that the CPU registers must hold the process’s<br>register values, that a <code>RUNNABLE</code> process must be able to be run by any idle<br>CPU’s scheduler, etc. These don’t hold true while executing in <code>swtch()</code>, so we<br>need to hold the lock then; otherwise another CPU might decide to run the<br>process before <code>swtch()</code> is done executing.</p>
<p>Now, at some point that process will be done running and will give up the CPU<br>again. Before it switches back into the scheduler, it has to acquire the process<br>table lock again. So here’s ONE MORE GIANT WARNING for good measure: you should<br>make sure to do that too if you add your own scheduling-related system call.</p>
<p>Eventually, it’ll switch back here with a call with the arguments in reverse,<br>like <code>swtch(&amp;(p-&gt;context), c-&gt;scheduler)</code>. At the point, execution of the<br>scheduler will resume right here, so we need to switch back to using the kernel<br>page directory <code>kpgdir</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            switchkvm();</span><br><span class="line">            c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After that, the outer for loop just releases the lock before looping to the top<br>again to temporarily re-enable interrupts, then acquire the lock again and check<br>for another process to run.</p>
<h3 id="forkret"><a href="#forkret" class="headerlink" title="forkret"></a>forkret</h3><p>Let’s take a quick look at one example of where a process might start to execute<br>after being scheduled. All processes (whether the very first process, or any<br>others created later through calls to <code>fork()</code>) will start running code in<br><code>forkret()</code>, then return from here into <code>trapret()</code>.</p>
<p>Most of the time, this function does just one thing: it releases the process<br>table lock. However, there are two kernel initialization functions that have to<br>be run from user mode, so we can’t just call them from <code>main()</code> and be done with<br>it. We need a place for a process to call them, and <code>forkret()</code> is as good a<br>place as any. So the very first call to <code>forkret()</code> will run these two start-up<br>functions, and the rest will ignore them.</p>
<p>The two functions are <code>iinit()</code> and <code>initlog()</code>, which are part of xv6’s file<br>system code; we’ll get to them later on. For now, we’ll just use a <code>static int</code><br>as a boolean and set it to false after we’ve run those functions once on our<br>first pass through <code>forkret()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only gets run once, on the first call</span></span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        iinit(ROOTDEV);</span><br><span class="line">        initlog(ROOTDEV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Returns into `trapret()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Any other kernel code that switches into the scheduler (e.g., <code>sleep()</code> and<br><code>yield()</code>) will have a similar lock release right after returning from<br>the scheduler.</p>
<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>We saw one example of code that runs after switching <em>away</em> from the scheduler,<br>but what about code that runs before switching <em>to</em> the scheduler? Any functions<br>that need to call into the scheduler can’t just call <code>scheduler()</code>, since the<br>scheduler probably left off last time halfway through the loop and should resume<br>in the same place. So <code>sched()</code> handles the task of picking up the scheduler<br>wherever it last left off.</p>
<p><code>sched()</code> should be called <em>after</em> acquiring the process table lock and without<br>holding any other locks (lest we cause a deadlock somewhere). Also, the process<br>should not be in the <code>RUNNING</code> state anymore since we’re about to stop running<br>it. So we’ll start off by checking that those are all true and that interrupts<br>are disabled.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!holding(&amp;ptable.lock)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched ptable.lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli != <span class="number">1</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state == RUNNING) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, remember when the <code>pushcli()</code> and <code>popcli()</code> functions checked whether<br>interrupts were enabled before turning them off while holding a lock? That’s<br>really a property of this kernel thread, not of this CPU, so we need to save<br>that now. Then we can call <code>swtch()</code> to pick up where the scheduler left off<br>(the line right after its own call to <code>swtch()</code>). This process will resume<br>executing after that line eventually, at which point we’ll restore the data<br>about whether interrupts were enabled and let it run again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save whether interrupts were enabled before acquiring the lock</span></span><br><span class="line">    <span class="type">int</span> intena = mycpu()-&gt;intena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform context switch into the scheduler</span></span><br><span class="line">    swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler);</span><br><span class="line">    <span class="comment">// Execution will eventually resume here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore whether interrupts were enabled before</span></span><br><span class="line">    mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>Okay, let’s see an example of how this all comes together now! The <code>yield()</code><br>function forces a process to give up the CPU for one scheduling round. For<br>example, this will be used to handle timer interrupts later on. Now that we know<br>how scheduling works in xv6, <code>yield()</code> is easy. We just acquire the process<br>table lock, set the current process’s state to <code>RUNNABLE</code> so it can get picked<br>up again in the next scheduling round, and call <code>sched()</code> to switch into the<br>scheduler. When we eventually return here, we’ll just release the lock again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    myproc()-&gt;state = RUNNABLE;</span><br><span class="line">    sched();</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h2><p>We’ve now seen how xv6 handles process scheduling with a super-simple round-<br>robin algorithm. The <code>scheduler()</code> function had plenty of concurrency pitfalls,<br>but luckily the xv6 authors took care of all the careful coding for us, so we<br>just get to sit back and admire their work.</p>
<p>We also saw how context switches occur in xv6, so now we can understand how, in<br>the previous post, <code>allocproc()</code> set up a new process with a context that would<br>result in it starting execution in <code>forkret()</code>.</p>
<p>Next up, we’ll look at the way xv6 handles interrupts, system calls, and software<br>exceptions.</p>
<h1 id="It’s-a-Trap"><a href="#It’s-a-Trap" class="headerlink" title="It’s a Trap!"></a>It’s a Trap!</h1><p>The last post introduced the mechanisms that xv6 uses for scheduling and context<br>switches. User processes can transfer control to kernel code with system calls,<br>potentially switching into the scheduler with <code>sleep()</code> or <code>exit()</code> to find<br>another process to run. But there are many other system calls besides those two<br>Kernel code can also be invoked during hardware interrupts or software<br>exceptions; these three together are collectively referred to as traps.</p>
<p>We’ll go over traps now to understand them more generally. First, about the<br>terminology: depending on the source, interrupts might mean hardware interrupts<br>specifically or any trap generally; similarly, exceptions might mean errors<br>arising from the code, or traps in general. It’s super frustrating because it<br>makes it really hard to know what’s meant by a word like “interrupt” or<br>“exception” in whatever specification or source you happen to be reading. So I’m<br>gonna try my best to save you that kind of pain in this post by sticking to<br>“interrupt” for the hardware interrupts only, “exception” for software errors,<br>and “trap” for those two combined with system calls.</p>
<h2 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h2><p>Imagine if, after every single time some user code carried out a division, the<br>processor stopped, context switched into the kernel, and asked the kernel to<br>check if there was a division by zero and handle it if necessary. Or every time<br>a hardware interrupt happened, the kernel had to start polling all the devices<br>to figure out which one just yelled. No. Just no. Running kernel code for all<br>this would be way too slow.</p>
<p>So it’s the processor that will have to detect traps and decide how to handle<br>them. But what exactly it should do for a specific trap depends on all kinds of<br>of particulars about that OS, e.g. a disk saying it’s done reading from a file<br>might require updating some file system data or storing the disk data in a<br>specific buffer or something. That’s too much responsibility for the processor.</p>
<p>Okay, so the kernel will set up a bunch of handler functions for every possible<br>type of trap. Then it tells the hardware, “Okay, so if you get a disk interrupt,<br>here are my instructions to handle that. For timer interrupts, use these<br>instructions. If a process tries to access an invalid page, do this…”<br>From then on, the processor can handle the traps without further input from the<br>kernel by looking up the interrupt number in a big table to get the trap handler<br>function that the kernel set up, then just running it.</p>
<p>In the x86 architecture, that table is called the <em>interrupt descriptor table</em><br>or IDT. I know, I’m sorry, I promised I’d say “trap” for the general case, but<br>the x86 specs give it the official name of IDT even though it handles all the<br>traps. Sigh. It has 256 entries (so that’s the maximum number of distinct traps<br>we can define); each one specifies a segment descriptor (ugh segmentation again,<br>you know what that means: opaque code) and an instruction pointer (<code>%eip</code>) that<br>tell the processor where it can find the corresponding trap handler<br>function.</p>
<p>xv6 won’t use all 256 entries; it’ll mostly use trap numbers 0-31 (software<br>exceptions), 32-63 (hardware interrupts), and 64 (system calls), all defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/traps.h">traps.h</a>.<br>But we do have to stick all 256 in the IDT anway, so we’re the unlucky fools who<br>get to write 256 functions’ worth of assembly code by hand. Nah, just kidding:<br>xv6 uses a script in a high-level language to do that for us and spit out the<br>entries into an assembly file.</p>
<p>Unfortunately for us, that high-level language is Perl. Sigh. Perl is infamous<br>as a “write-only” language, so I guess instead we’re just the unlucky fools who<br>get to try reading Perl.</p>
<h2 id="vectors-pl"><a href="#vectors-pl" class="headerlink" title="vectors.pl"></a>vectors.pl</h2><p>Okay, I’m not gonna assume you know Perl, and either way I really don’t wanna go<br>over every single line of this file. The syntax is similar enough to C’s (except<br>that somehow they managed to make it even <em>worse</em> than C), so you can read it on<br>your own if you want.</p>
<p>Now, no script will be able to generate 256 completely unique assembly functions<br>with enough detail to handle each trap correctly, so each function in the script<br>has to be pretty generic. They’re all gonna call the same assembly helper<br>function, which will call a C function where we can more comfortably code up<br>how to handle each interrupt.</p>
<p>The gist of this Perl script is that it prints a bunch of stuff using a for loop<br>with 256 iterations. The xv6<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a><br>will run it from the command line with <code>./vectors.pl &gt; vectors.S</code> so that the<br>output gets saved in an assembly file, which will then get assembled together<br>with all the other kernel code in <code>OBJS</code>.</p>
<p>The resulting assembly file will look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line"></span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $0</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line">.globl vector1</span><br><span class="line">vector1:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $1</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line">.globl vector2</span><br><span class="line">vector2:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $2</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Except that a handful of entries (8, 10 through 14, and 17) will skip one line<br>(I’ll explain why below):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.globl vector8</span><br><span class="line">vector8:</span><br><span class="line">    pushl   $8</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Then at the end, it defines an array <code>vectors</code> with each of those entries above:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.globl vectors</span><br><span class="line"></span><br><span class="line">vectors:</span><br><span class="line">    .long vector0</span><br><span class="line">    .long vector1</span><br><span class="line">    .long vector2</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Okay, so those are all the handler functions; the <code>vectors</code> array holds a<br>pointer to each one. They’re all more or less the same: most of them push zero<br>onto the stack, then all they push a <em>trap number</em> to indicate which trap<br>just happened, and then they jump to a point in the code called <code>alltraps</code>;<br>that’s the assembly helper function I mentioned earlier.</p>
<p>A handful of the entries don’t push zero on the stack: these are trap numbers<br>8 (a double fault, which happens when the processor encounters an error while<br>handling another trap), 10 (an invalid task state segment), 11 (segment<br>not present), 12 (a stack exception), 13 (a general protection fault), 14 (a<br>page fault), and 17 (an alignment check). These are special because the<br>processor will actually push an error code on the stack before calling into the<br>corresponding handler function in <code>vectors</code>. It doesn’t push any error codes on<br>the stack for the others, so we just push 0 ourselves to make them all match up.</p>
<h2 id="trapasm-S"><a href="#trapasm-S" class="headerlink" title="trapasm.S"></a>trapasm.S</h2><h3 id="alltraps"><a href="#alltraps" class="headerlink" title="alltraps"></a>alltraps</h3><p>The processor needs to run the trap handler in kernel mode, which means we have<br>to save some state for the process that’s currently running so we can return to<br>it later (similar to the <code>struct context</code> we saw before), then set things up to<br>run in kernel mode. The <code>alltraps</code> routine does just that.</p>
<p>Remember how we said the IDT holds segment selectors for <code>%cs</code> and <code>%ss</code>, plus<br>and instruction pointer <code>%eip</code>? (I know we haven’t seen the code to create the<br>IDT and store the entries of <code>vectors</code> in it yet; we’ll get to that below.) The<br>processor will start using those segments (and save the old ones) before running<br>the trap handler function. Each trap handler function in <code>vectors</code> above pushed<br>an error code (or 0) followed by a trap number. Now we have to push all the<br>other segment selectors on the stack one at a time, then push all the general-<br>purpose registers at once with the x86 instruction <code>pushal</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line">alltraps:</span><br><span class="line">    pushl   %ds</span><br><span class="line">    pushl   %es</span><br><span class="line">    pushl   %fs</span><br><span class="line">    pushl   %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Cool, all the registers are saved now. So now we’ll set up the <code>%ds</code> and <code>%es</code><br>registers for kernel mode (<code>%cs</code> and <code>%ss</code> were already done by the processor).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">movw    $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class="line">movw    %ax, %ds</span><br><span class="line">movw    %ax, %es</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Now we’re ready to call the C function <code>trap()</code> that’s gonna do most of the<br>work. That function expects a single argument: a pointer to the process’s saved<br>register contents. Well, we just pushed them all on the stack, so we can just<br>use <code>%esp</code> as that pointer.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">pushl   %esp</span><br><span class="line">call    trap</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>That function will return back here when it’s done, so let’s ignore the return<br>value by moving the stack pointer just above it (essentially popping it off the<br>stack).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">addl    $4, %esp</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<h3 id="trapret"><a href="#trapret" class="headerlink" title="trapret"></a>trapret</h3><p>We’ve talked about this function before; when we create a new process, it starts<br>executing in <code>forkret()</code>, which then returns into <code>trapret()</code>. More generally,<br>any call to <code>trap()</code> will return here as well.</p>
<p>This function just restores everything back to where it was before, popping<br>stored registers off the stack in reverse order. We can skip the trap number and<br>error code; we won’t need them anymore. Then we use the <code>iret</code> or “interrupt<br>return” (though you should read that as “trap return”) instruction to close out,<br>return to user mode, and start executing the process’s instructions again.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl trapret</span><br><span class="line">trapret:</span><br><span class="line">    popal</span><br><span class="line">    popl    %gs</span><br><span class="line">    popl    %fs</span><br><span class="line">    popl    %es</span><br><span class="line">    popl    %ds</span><br><span class="line">    addl    $0x8, %esp  # skip the trap number and error code</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>

<h2 id="trap-c"><a href="#trap-c" class="headerlink" title="trap.c"></a>trap.c</h2><p>Okay, on to the main part of the code! We have to do two things here: stick the<br>trap handler functions in <code>vectors</code> into an IDT, and figure out what to do with<br>each interrupt type.</p>
<p>At the top, we’ve got four global variables. The IDT is represented as an array<br>of <code>struct gatedesc</code>s, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>. It’s worth<br>taking a look at because it uses an obscure C feature (bit fields); we’ll do that<br>in the next section.</p>
<p>Then we declare the <code>vectors</code> array of trap handler (with an <code>extern</code> keyword,<br>since it’s defined in an assembly file), a global counter <code>ticks</code> that tracks<br>the number of timer interrupts so far (basically a rough timer), and a lock to<br>use with <code>ticks</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256];</span></span><br><span class="line"><span class="keyword">extern</span> uint vectors[];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">tickslock</span>;</span></span><br><span class="line">uint ticks;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="Bit-Fields"><a href="#Bit-Fields" class="headerlink" title="Bit Fields"></a>Bit Fields</h3><p>This section will get <em>deep</em> into the weeds, so feel free to skip it if you’re<br>having a nice day and don’t want to spoil it by reading about a bunch of C<br>standards.</p>
<p>So far, we’ve used bit flags with regular integers by manually doing some bit<br>arithmetic to set one bit at a time. For example, the flags for page table and<br>page directory entries are defined as powers of 2 (e.g., <code>PTE_P</code> is 0x1, <code>PTE_W</code><br>is 0x2, <code>PTE_U</code> is 0x4, etc.) so that we can set a specific bit using a bitwise-<br>OR like <code>pte |= PTE_U</code> or test whether it’s set with a bitwise-AND like<br><code>pte &amp; PTE_P</code>.</p>
<p>But sometimes that can get annoying and hard to keep track of; wouldn’t it be<br>nice if we could just have variables that represent a single bit? Or two bits,<br>or any number of bits we want?</p>
<p>The trouble is that most computer architectures don’t work with a single bit at<br>a time; they operate on bytes, words (2 bytes), long&#x2F;double words (4 bytes), or<br>quad words (8 bytes), so it would be nontrivial to compile a line of C like<br><code>a = 1</code> if <code>a</code> is a nonstandard size.</p>
<p>In fact, accessing variables that aren’t aligned to a standard size (4 bytes on<br>x86 or 8 bytes on x86_64) is much slower than when they are aligned. Compilers<br>often optimize code to correct for this by padding <code>struct</code>s so that they’ll<br>line up along those standard sizes. For example, one like</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nopadding</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>is probably left the same on x86, but one like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>is probably converted by the compiler into this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> pad0[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">char</span> pad1[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>WARNING: We’re entering the dark arts of C’s unspecified and implementation-<br>defined behavior here. Note that these are different from <em>undefined</em> behavior:<br>undefined behavior means you did something BAD BAD BAD like dereferencing a null<br>pointer, freeing a memory region twice, using a variable after freeing it,<br>accessing an out-of-bounds index in a buffer, or overflowing a signed data type.<br>Implementation-defined and unspecified behavior aren’t as dangerous as undefined<br>behavior is, but they can cause portability issues.</p>
<p>The C standard is a huge document with a bunch of legalese rules about what<br>makes C, well, C. People who write C compilers need to know exactly how C code<br>should behave under all kinds of different circumstances, so the C standard<br>spells most of it out. But there are some parts it intentionally leaves out.</p>
<p><em>Implementation-defined</em> behavior means the C standard doesn’t set any fixed<br>requirements about how a compiler should handle some behavior or feature; the<br>developers of a C compiler get to decide how to write that part of the code with<br>total freedom. One example is the number of bits in a byte; we’ve been assuming<br>it’s 8, but there are some (dumb) architectures where it’s different.</p>
<p><em>Unspecified behavior</em>, on the other hand, means that the C Standard provides<br>some specific options, and compiler developers have to choose from those options<br>for <em>each instance</em> of the behavior in the code they’re compiling (that means,<br>don’t assume it’s always gonna be the same, even with the same compiler).</p>
<p>Structure padding is implementation-defined, and there are often implementation-<br>defined ways to modify it or disable it altogether (i.e., to <em>pack</em> the <code>struct</code><br>instead of <em>padding</em> it), usually with stuff like <code>__attribute__</code>s or <code>#pragma</code><br>directives for the preprocessor.</p>
<p>Wait weren’t we gonna talk about bit manipulation? Why are we talking about<br><code>struct</code>s? Well, C does have a workaround to make bit manipulation a little<br>easier by avoiding that slightly-annoying bit arithmetic you have to do to set<br>or clear flags in an <code>int</code> or <code>unsigned int</code>: it’s called a <em>bit field</em>, and it<br>takes advantage of <code>struct</code> padding.</p>
<p>You can specify the number of bits that a field of a <code>struct</code> should occupy by<br>adding a colon and a size after the field name:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfield_example</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This way, you can set the single-bit flag <code>a</code> with simple variable assignments<br>like <code>var.a = 1</code>, and the compiler will figure out any necessary magic similar<br>to structure padding to make that happen. Awesome, right? So why haven’t we been<br>using it all the time instead of all that opaque bit arithmetic with arcane<br>operators like <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>|</code>, and <code>&amp;</code>?</p>
<p>Well, there are some big downsides to bit fields. First, the C standard sets<br>some strict rules on their use to make sure that compilers can figure out how to<br>handle them. Bit fields are only allowed inside of structures. You’re not<br>allowed to create arrays of bit fields or pointers to bit fields. Functions<br>aren’t allowed to return a bit field. You’re not allowed to get the address of a<br>bit field with the <code>&amp;</code> operator. You can only operate on a single bit field at a<br>time in any statement; that means you can’t set one bit field to equal another,<br>and you can’t compare the values of two bit fields.</p>
<p>Second, they’re <em>extremely</em> implementation-defined. Each implementation (read:<br>compiler + architecture combo) determines what data types and sizes are allowed<br>to be used in bit fields. The data types you <em>can</em> use might have different<br>signedness rules from the usual ones for signed and unsigned types. How they’re<br>laid out, ordered, and padded in memory can differ. In short: the low-level<br>details are a total black box that you can probably only figure out by reading<br><em>deep</em> into the compiler’s specifications.</p>
<p>Now imagine trying to do something that requires specific protocols like sending<br>data over a network, and you come across a bit field. Lolwut. Who knows what<br>you’d have to do. Bit fields make it impossible to port your code.</p>
<p>BUT! Bit arithmetic is annoying, so let’s use bit fields anyway!</p>
<p>Okay, so back to <code>struct gatedesc</code>. IDT entries have to contain a 16-bit code<br>segment selector (<code>%cs</code>), 16 low bits and 16 high bits for an offset in that<br>segment, the number of arguments for the handler function, a type, a system&#x2F;<br>application flag, a descriptor privilege level (0 for kernel, 3 for user), and a<br>“present” flag. And x86 is very particular about how it’s all laid out, so we<br>have to set up <code>struct gatedesc</code> in the exact right order.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    uint off_15_0 : <span class="number">16</span>;</span><br><span class="line">    uint cs : <span class="number">16</span>;</span><br><span class="line">    uint args : <span class="number">5</span>;</span><br><span class="line">    uint rsv1 : <span class="number">3</span>;</span><br><span class="line">    uint type : <span class="number">4</span>;</span><br><span class="line">    uint s : <span class="number">1</span>;</span><br><span class="line">    uint dpl : <span class="number">2</span>;</span><br><span class="line">    uint p : <span class="number">1</span>;</span><br><span class="line">    uint off_31_16 : <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Well, okay, that’s it for now.</p>
<h3 id="tvinit"><a href="#tvinit" class="headerlink" title="tvinit"></a>tvinit</h3><p>This function loads all the assembly trap handler functions in <code>vectors</code> into<br>the IDT. The <code>SETGATE()</code> macro in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> will organize<br>each entry correctly. We said before that the IDT needs a code segment selector,<br>an instruction pointer (from <code>vectors</code>), and a privilege level (0 for kernel<br>mode), so we’ll stick those in.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, SEG_KCODE &lt;&lt; <span class="number">3</span>, vectors[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re basically done now, but there’s one last hiccup: user code needs to be<br>able to generate system calls, but we just set all the privilege levels so only<br>the kernel and processor can generate traps. So we’ll fix the entry for system<br>calls as a special case.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, SEG_KCODE &lt;&lt; <span class="number">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oh and while we’re at it, let’s just go ahead and initialize the lock for the<br>tick counter.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="idtinit"><a href="#idtinit" class="headerlink" title="idtinit"></a>idtinit</h3><p>The last function stored all the trap vectors in the IDT, so now we need to tell<br>the processor where to find the IDT. There’s a special assembly instruction for<br>that in x86 called <code>lidt</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idtinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lidt(idt, <span class="keyword">sizeof</span>(idt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h3><p>This last function is the one that gets called by the assembly code in <code>alltraps</code>;<br>it’s responsible for figuring out what to do based on the trap number we pushed<br>on the stack before. Heads up: it’s gonna do that by calling a bunch of other<br>functions, many of which we haven’t seen yet. I’ll just give a quick summary<br>when we come across them, and we’ll get to them later on.</p>
<p>The only argument is a pointer to a <code>struct trapframe</code>. Wait, hang on. Up above<br>in the assembly code, the argument we pushed on the stack was <code>%esp</code>, the stack<br>pointer, not a pointer to any <code>struct trapframe</code>. What’s up with that? Did we<br>pass the wrong kind of argument in?</p>
<p>Let’s check out the definition for <code>struct trapframe</code>, found in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>. It’s got a<br>bunch of fields, starting off with the general purpose registers (those are the<br>fields from <code>%edi</code> to <code>%eax</code>). Then it has four segment registers (fields <code>%gs</code><br>through <code>%ds</code>), plus some unused padding bits in between them to round the 16-<br>bit segment registers up to 32 bits. The next two fields are a trap number and<br>an error code.</p>
<p>All that should sound familiar. Take another look at<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/trapasm.S">trapasm.S</a>: so<br>far, those are the exact same things we pushed on the stack! The other fields<br>are what the processor pushed on the stack before calling the handler function<br>in the IDT. So basically, we’re never gonna construct a <code>struct trapframe</code> in C<br>code; we already constructed it manually in assembly. It just describes<br>everything that’s already on the stack by the time this <code>trap()</code> function gets<br>called. In that sense, the <code>%esp</code> we pushed as an argument really <em>is</em> a pointer<br>to a <code>struct trapframe</code>. It’s a clever way to read values off the stack.</p>
<p>So we said we’re gonna check the trap number and decide which kernel function to<br>call based on that, right? Let’s start by checking if the trap number indicates<br>this is a system call (trap number 64, or <code>T_SYSCALL</code>).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;trapno == T_SYSCALL) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Well how should we handle system calls? xv6 will have several, and we don’t even<br>know what they all are yet. So let’s procrastinate again and just call some<br>other function <code>syscall()</code> to handle the work of figuring out which system call<br>to execute. Now we’ll store the pointer to the <code>struct trapframe</code> in that<br>process’s <code>struct proc</code>, obtained with a call to <code>myproc()</code>. Also, processes<br>need to be killed once they’re done, or if they cause an exception; that happens<br>by setting a <code>killed</code> flag in the <code>struct proc</code>. So we’ll check for that before<br>and after carrying out the system call and close the process out with <code>exit()</code><br>if it’s due to be killed.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;trapno == T_SYSCALL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        myproc()-&gt;tf = tf;</span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now we have all the other trap numbers to think about. We could do them<br>with a ton of <code>if</code> statements, but that would be a pain; we’ll use a <code>switch</code><br>statement instead. If you haven’t seen <code>switch</code> statements, they replace big<br><code>if-else</code> blocks with cases instead. The cases can only be indexed by integers,<br>and you have to stick a <code>break</code> statement at the end or else you’ll fall through<br>to the next case and execute the code found there as well. (To be honest, I<br>don’t see a reason why the system call case wasn’t just included in this same<br>switch statement; if you see a reason for that, let me know.)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// cases go here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First up is the trap number for timer interrupts; the main function of timer<br>interrupts is to schedule a new process, but that will come further down in this<br>function. For now, we’ll just increment the <code>ticks</code> counter then call <code>wakeup()</code>,<br>which checks if any processes went to sleep until the next tick; it’ll switch to<br>running any process it finds. There’s one detail to deal with here: the system<br>may have multiple processors, each with their own timer and interrupts. We want<br>to use the <code>ticks</code> counter as a rough timer, but we don’t know whether all the<br>CPU timers will be synchronized, so we’ll only update <code>ticks</code> using the first<br>CPU to avoid those issues.</p>
<p>If you read the post on interrupt controllers then you’ll be familiar with<br><code>lapiceoi()</code>; if you didn’t (or you forgot), it just tells the local interrupt<br>controller that we’ve read and acknowledged the current interrupt so it can<br>clear it and get ready for more interrupts.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">            <span class="keyword">if</span> (cpuid() == <span class="number">0</span>) &#123;</span><br><span class="line">                acquire(&amp;tickslock);</span><br><span class="line">                ticks++;</span><br><span class="line">                wakeup(&amp;ticks);</span><br><span class="line">                release(&amp;tickslock);</span><br><span class="line">            &#125;</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Later on, we’ll see some interrupt handler functions for various devices:<br><code>ideintr()</code> handles disk interrupts, <code>kbdintr()</code> for key presses and releases,<br>and <code>uartintr()</code> for serial port data. We’ll direct the corresponding interrupts<br>to those functions, then acknowledge and clear them with <code>lapiceoi()</code>. Also,<br>devices occasionally generate spurious interrupts due to hardware malfunctions;<br>we’ll either ignore them (if they’re coming from the Bochs emulator) or print a<br>message about it to the console.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_IDE:      <span class="comment">// disk interrupt</span></span><br><span class="line">            ideintr();</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_IDE + <span class="number">1</span>:  <span class="comment">// spurious Bochs disk interrupt</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_KBD:      <span class="comment">// keyboard interrupt</span></span><br><span class="line">            kbdintr();</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ + <span class="number">7</span>:             <span class="comment">// spurious interrupt-no break, FALL THROUGH</span></span><br><span class="line">        <span class="keyword">case</span> T_IRQ + IRQ_SPURIOUS:  <span class="comment">// spurious interrupt</span></span><br><span class="line">            cprintf(<span class="string">&quot;cpu%d: spurious interrupt at %x:%x\n&quot;</span>,</span><br><span class="line">                    cpuid(), tf-&gt;cs, tf-&gt;eip);</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now we’ve dealt with system calls and hardware interrupts, so any other<br>trap must be a software exception. <code>switch</code> statements allow a catch-all case<br>with <code>default</code>, so we’ll use that to catch the rest of the trap numbers. Now,<br>this may have come from a kernel error or a misbehaving user process. We can<br>check with <code>myproc()</code>, which returns a null pointer if we were running kernel<br>code or a pointer to a <code>struct proc</code> if we were in user space, or by checking<br>the current privilege level in the code segment selector. Depending on the<br>source, we’ll print out an appropriate error message and either panic (if in the<br>kernel) or mark the process so it gets killed soon.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (myproc() == <span class="number">0</span> || (tf-&gt;cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Kernel code exception</span></span><br><span class="line">                cprintf(<span class="string">&quot;unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n&quot;</span>,</span><br><span class="line">                        tf-&gt;trapno, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">                panic(<span class="string">&quot;trap&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// User process exception</span></span><br><span class="line">            cprintf(<span class="string">&quot;pid %d %s: trap %d err %d on cpu %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;eip 0x%x addr 0x%x--kill proc\n&quot;</span>,</span><br><span class="line">                    myproc()-&gt;pid, myproc()-&gt;name, tf-&gt;trapno,</span><br><span class="line">                    tf-&gt;err, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">            myproc()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The reason we don’t kill it immediately is because the process might be executing<br>some kernel code right now; for example, system calls allow other interrupts and<br>exceptions to occur while they’re being handled. Killing it now might corrupt<br>whatever it’s doing. So instead we just give it the kiss of death for now and<br>come back to finish the job later.</p>
<p>So next up, we’ll check if this trap was generated by a user process that’s due<br>to be killed, and that process is running in ring 3. If so, we finally do<br>the deed with <code>exit()</code>; otherwise if it’s running in ring 0, it’ll live for now<br>and get killed the next time it generates a trap instead.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;killed &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == DPL_USER) &#123;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Up above, the only thing a timer interrupt did was increment <code>ticks</code>. But we<br>know a really important function of timer interrupts is to force a process to<br>let go of the CPU and let someone else run. It’s time to do that. We’ll check if<br>the process’s state is <code>RUNNING</code> and the trap was a timer interrupt; if so, we<br>call <code>yield()</code> to let another process get scheduled on this CPU.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;state == RUNNING &amp;&amp;</span><br><span class="line">            tf-&gt;trapno == T_IRQ0 + IRQ_TIMER) &#123;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have one last check: a process that yielded, then got picked up again<br>later might have been marked as killed in the meantime, so if it was, we need to<br>finish it off now. So we do the exact same check as above again, and then we’re<br>done.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;killed &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == DPL_USER) &#123;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that this function will return into <code>trapret</code> in the assembly code, which<br>will then send it back to user mode.</p>
<h2 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h2><p>Let’s take a moment to assess how much of xv6 we’ve already covered. Remember,<br>the xv6 kernel has four main functions: (1) finishing the boot process that the<br>boot loader started, (2) virtualizing resources in order to isolate processes<br>from each other, (3) scheduling processes to run, and (4) interfacing<br>between user processes and hardware devices. Let’s take that as a checklist and<br>go through those items now.</p>
<p>We’ve already seen some of the initialization routines that get run on boot in<br><code>main()</code>; most of the code there sets up virtual memory and all the hardware<br>devices. We still have a few more devices to talk about: the keyboard, serial<br>port, console, and disk; each of those has its own boot function that we’ll need<br>to go over in order to wrap up point (1).</p>
<p>On the other hand, we’re already done with (2) and (3): we spent a lot of time<br>going over virtual memory and paging, and the last post on scheduling showed us<br>how xv6 virtualizes the CPU as well as it runs processes.</p>
<p>The code we saw in this post was our introduction to point (4). Traps are the<br>primary mechanism for user processes to communicate with the hardware; the<br>kernel coordinates that communication by setting up trap handler functions. The<br>code we’ve seen here basically acts like an usher, directing traps to the<br>right trap handler function depending on its type.</p>
<p>When a trap occurs (x86 instruction <code>int</code>), the processor will stop executing<br>code, find the IDT, and looks up the entry for that trap number. The script that<br>xv6 uses to generate the IDT entries just makes them all point to the same<br>function <code>alltraps()</code>, which saves all the process’s registers, switches into<br>kernel mode, and calls <code>trap()</code>. Then that function uses the trap number to<br>figure out how the kernel wants it to respond to this particular trap. So any<br>hardware interrupt, software exception, or user system call will get funneled<br>into the functions here before getting dispatched to some other appropriate<br>kernel code that will know what to do with it.</p>
<p>We haven’t finished point (4) yet, though: we have to actually see what each of<br>those trap handler functions does. But we did see some of them: for example, we<br>saw that a software exception either kills the process that caused it or panics<br>if it occurred in kernel code. That already takes care of one of the three types<br>of traps, so we’re left with hardware interrupts and system calls. All the<br>system calls got redirected to a <code>syscall()</code> function which we haven’t seen yet.</p>
<p>We have seen how some of the hardware interrupts are dealt with: a timer<br>interrupt increments a <code>ticks</code> counter (if it’s on CPU 0), then calls <code>yield()</code><br>to force a process to give up the CPU until the next scheduling round. Spurious<br>interrupts either get ignored or print a message to the console. But we’ve<br>procrastinated some of the others: disk interrupts call an <code>ideintr()</code> function<br>to handle them, keyboard interrupts call <code>kdbintr()</code>, and serial port interrupts<br>call <code>uartintr()</code>, none of which we’ve gone over.</p>
<p>So in order to wrap up the xv6 kernel, we still have to understand how system<br>calls are routed in general, as well as how devices are initialized at boot and<br>how the kernel responds to specific system calls that require use of those<br>devices. The general system call routing mechanism is up next.</p>
<h1 id="System-Calls-Routing"><a href="#System-Calls-Routing" class="headerlink" title="System Calls: Routing"></a>System Calls: Routing</h1><p>We said in the last post that system calls are the primary means for user<br>processes to request some action by the kernel; system calls mediate processes’<br>access to hardware resources.</p>
<p>If a user process wants to generate a system call, it starts a trap with the<br>trap number for system calls. Then it identifies which of the various xv6 system<br>calls it wants to do and passes any required arguments. The processor will then<br>handle the trap instruction using the code we saw in the last post. Eventually,<br>it’ll get to the <code>trap()</code> function, which will recognize the trap number as a<br>system call and pass it on to the <code>syscall()</code> function.</p>
<p><code>syscall()</code> is itself a routing function like <code>trap()</code>; it’ll figure out which<br>system call the process created and redirect it again to the appropriate kernel<br>code.</p>
<h2 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h2><p>All system calls use the same trap number: 64, or <code>T_SYSCALL</code>, but xv6 has<br>multiple system calls, so we need another number for a process to identify which<br>system call it wants to run. The convention on x86 is to use a system call<br>number which the calling process should put in the <code>%eax</code> register, which<br>usually holds return values. Then the kernel’s handler function (here,<br><code>syscall()</code>) can just check <code>%eax</code> to figure out which system call to run. The<br>system call numbers are defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/syscall.h">syscall.h</a>. There<br>you can see that, e.g. <code>SYS_fork</code> is defined as 1, <code>SYS_exit</code> is 2, and so on.</p>
<p>All the system call functions are defined in other files, so we’ll have to<br>import their declarations with the <code>extern</code> keyword:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Now we’ve got the numbers and the functions. Note that the numbers start with<br>uppercase <code>SYS_</code> and the functions start with lowercase <code>sys_</code>, so make sure<br>your kernel hacking adventures don’t do anything like <code>SYS_fork()</code>; use<br><code>sys_fork()</code> instead.</p>
<p>We’ll also need a way to map the numbers to those system call functions so that<br><code>syscall()</code> can call the right one depending on the number. We could use another<br><code>switch</code> statement like we did in <code>trap()</code>, but there are 21 system calls here,<br>so that would get pretty long; also, each number will just call the specific<br>function, unlike the different trap numbers which required different responses<br>(e.g., the timer interrupt trap number didn’t call any function at all). xv6<br>does something else this time that’s much simpler and more elegant, but it uses<br>some slightly-obscure C features, so we’ll go over it carefully.</p>
<p>Remember function pointers from way back in the boot loader? Functions are just<br>a set of instructions in order, loaded somewhere in the kernel’s code segment,<br>so C lets us use the function’s name as a pointer to the beginning of its code<br>in memory. So if we have a C function like <code>int func(char c)</code>, then <code>func</code> is<br>its function pointer. We could even assign it to a variable; that variable’s<br>type would be a pointer to a function of argument type <code>char</code> and return type<br><code>int</code>; then we could call the function using the new pointer too. Here’s an<br>example that would print “Match!” to the screen:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = func(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*func_ptr)(<span class="type">char</span>) = &amp;func;</span><br><span class="line"><span class="type">int</span> n = (*func_ptr)(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So instead of a big old <code>switch</code> statement, the <code>syscall()</code> function will use a<br>static, global array of pointers to all the system call functions we just<br>imported above. (Remember that the <code>static</code> keyword in front of a variable means<br>it always occupies the same fixed place in memory.) It’ll work because all the<br>functions have the same argument type (<code>void</code>) and return type (<code>int</code>), so their<br>pointers all have the same type and can fit inside a single array. Then we can<br>get the right function by just using the system call number to index into the<br>array of function pointers.</p>
<p>Now, we’d have to be super careful to add the function pointers into the array<br>in the right order so that the indices match up. Even worse, there is no system<br>call with number zero, so we’d have to skip that entry of the array. This could<br>get complicated. Luckily, even though humans are bad at this kind of thing,<br>computers are <em>really</em> good at it. So instead of trying to line them up by hand,<br>we can use the array notation from <code>procdump()</code> in the post on processes where<br>we specified the value of each entry of an array like this with the index in<br>square brackets, like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; [<span class="number">2</span>] <span class="number">5</span>, [<span class="number">0</span>] <span class="number">1</span>, [<span class="number">4</span>] <span class="number">-2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>The C compiler will use the indices we wrote there to figure out that the array<br>needs 5 entries (indices 0 to 4), and entry 0 is 1, entry 2 is 5, and entry 4 is<br>-2. Entries 1 and 3 will just be initialized to zero.</p>
<p>So at the end of the day, our array of pointers to system call functions looks<br>like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork]      sys_fork,</span><br><span class="line">    [SYS_exit]      sys_exit,</span><br><span class="line">    [SYS_wait]      sys_wait,</span><br><span class="line">    [SYS_pipe]      sys_pipe,</span><br><span class="line">    [SYS_read]      sys_read,</span><br><span class="line">    [SYS_kill]      sys_kill,</span><br><span class="line">    [SYS_exec]      sys_exec,</span><br><span class="line">    [SYS_fstat]     sys_fstat,</span><br><span class="line">    [SYS_chdir]     sys_chdir,</span><br><span class="line">    [SYS_dup]       sys_dup,</span><br><span class="line">    [SYS_getpid]    sys_getpid,</span><br><span class="line">    [SYS_sbrk]      sys_sbrk,</span><br><span class="line">    [SYS_sleep]     sys_sleep,</span><br><span class="line">    [SYS_uptime]    sys_uptime,</span><br><span class="line">    [SYS_open]      sys_open,</span><br><span class="line">    [SYS_write]     sys_write,</span><br><span class="line">    [SYS_mknod]     sys_mknod,</span><br><span class="line">    [SYS_unlink]    sys_unlink,</span><br><span class="line">    [SYS_link]      sys_link,</span><br><span class="line">    [SYS_mkdir]     sys_mkdir,</span><br><span class="line">    [SYS_close]     sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Okay great, now we’re ready to route system calls to the right function.</p>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>The first thing we need to do is get the system call number so we can figure out<br>which function to call. We said above that the x86 convention is to store it in<br>the <code>%eax</code> register, but we might have a problem: by the time we get to<br><code>syscall()</code>, the processor has already executed the code in the trap handler<br>function for trap number <code>T_SYSCALL</code>, which sent it to <code>alltraps()</code>, which<br>replaced all the register contents with those of <code>trap()</code>, so the system call<br>number is probably long gone from <code>%eax</code>.</p>
<p>But wait, all is not lost! <code>alltraps()</code> saved all the registers in a<br><code>struct trapframe</code> for the current process. So we can just read the value of<br><code>%eax</code> from there. Whew, that was some good forward-thinking.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> num = curproc-&gt;tf-&gt;eax;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we just need to do one more thing: call the function that corresponds to<br>that number. We’re gonna use the array of function pointers above, but we have<br>to be careful: this number was given to us by a user process. A malicious user<br>process might pass in an invalid number in the hopes of getting the kernel to<br>carry out some undefined behavior which might lead to an easy exploit. So in<br>order to keep up good security practices, the kernel should <em>always</em> distrust<br>anything originating from user code and handle it carefully, preferably with<br>three-inch-thick lead-lined gloves. So let’s think about it: what might go<br>wrong?</p>
<p>First of all, any entries that weren’t explicitly initialized above (including<br>the 0 entry) will have been automatically initialized to zero, i.e. a null<br>pointer. Also, a number that’s bigger than the highest system call number will<br>make us do an out-of-bounds read from the array, thus possibly executing some<br>arbitrary kernel code that’s stored after the array in memory. So we should<br>check that (1) the number is greater than 0, (2) it’s smaller than the number of<br>elements in the array, and (3) the entry it points to is not a null pointer.</p>
<p>Finally, the <code>%eax</code> register is usually used in x86 to store return values, so<br>we’ll put the return value of the system call function there. If any of the<br>above checks failed, we’ll just print a message to the console and return -1 to<br>indicate failure.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invalid system call number</span></span><br><span class="line">        cprintf(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>, curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">        curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The system call handler function will store its return value in <code>%eax</code>; after<br>that, <code>syscall()</code> will return to the line below where it was called in <code>trap()</code>.<br>After executing the rest of the code there, <code>trap()</code> will return into <code>trapret()</code>,<br>which ends with an <code>iret</code> (interrupt return) instruction to tell the processor<br>to switch to user mode and resume executing the process’s code.</p>
<h3 id="fetchint"><a href="#fetchint" class="headerlink" title="fetchint"></a>fetchint</h3><p>Take a look at the <code>sys_</code> functions we imported above: they all have argument<br>type <code>void</code>. But if you think about it, many system calls need an argument: for<br>example, <code>open()</code> needs to know which file to open, <code>chdir()</code> needs to know<br>which directory to open, <code>kill()</code> needs a PID to know which process to kill,<br>etc. So why did we make them all have argument type <code>void</code>?</p>
<p>The trouble is that until we get the system call number in <code>syscall()</code> above, we<br>have no way of knowing which function we’ll need. And each function takes<br>arguments with different types, e.g. <code>open()</code> might need a string for the file<br>to open but <code>kill()</code> might need an integer for the PID. So there’s no way for<br>the kernel to know which arguments to expect in <code>syscall()</code>, even though the<br>arguments were already pushed on the stack. The task of recovering the arguments<br>from the stack will have to fall to each of the <code>sys_</code> functions. But let’s go<br>ahead and make their lives a little easier by setting up some nice helper<br>functions now.</p>
<p>The system call functions might take integers, strings, or pointers, so we’ll<br>need functions to fetch each of those types. <code>fetchint()</code> is one example; it<br>takes a user virtual address (an integer argument’s location in memory) and a<br>pointer to an integer where we can store the integer we find. Then it returns 0<br>if it was able to find it, or -1 if it failed.</p>
<p>Just like <code>syscall()</code> above, we need to treat anything passed from user space<br>with extreme caution. A user process that tries to read or write memory outside<br>its address space will cause a segmentation fault or page fault and be killed,<br>but the kernel has free reign over memory, so a malicious process might try to<br>trick the kernel into doing that <em>for</em> it by putting its “argument” outside of<br>the user’s address space. So we have to start by checking that the entire 4<br>bytes of the integer is inside the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchint</span><span class="params">(uint addr, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt;= curproc-&gt;sz || addr + <span class="number">4</span> &gt; curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can just cast the address to a pointer, dereference it, and store the<br>value in <code>*ip</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchint</span><span class="params">(uint addr, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *ip = *(<span class="type">int</span> *)(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we can use an address like <code>addr</code> which will be in the lower half of<br>memory because traps don’t perform a full context switch, so we’re still using<br>the process’s page directory even though we’re in kernel mode (ring 0). If we<br>had switched to a kernel page directory, we’d have to call <code>walkpgdir()</code> or<br><code>uva2ka()</code> to figure out the corresponding kernel virtual address for <code>addr</code>.</p>
<p>Now hopefully, if you’ve taken anything away from my past rants about undefined<br>behavior in C, you noticed something wrong with this function. If you didn’t,<br>take another look; I’ll wait.</p>
<p>Did you see it? We’re dereferencing <code>addr</code> without checking that it’s not null,<br>so if the user passed in a null address, we’d dereference a null pointer! We<br>also dereference <code>ip</code> without a similar check, but at the very least <code>ip</code> is<br>passed in by the kernel.</p>
<p>This could be very dangerous – in general, it’s undefined behavior in C, but<br>now that we’ve seen the code for handling traps, we’re actually at a point where<br>we can figure out what would happen in xv6 if a null pointer gets dereferenced,<br>so let’s take the opportunity to think about it for a bit.</p>
<p>First, what would happen if the kernel dereferenced a null pointer? Well, if the<br>kernel is currently using <code>kpgdir</code> as a page directory, the address 0 isn’t<br>mapped to anything, so when the paging hardware goes to figure out which physical<br>address corresponds to the kernel virtual address 0, it would fail and generate<br>a “General Protection Fault” (trap number 13, or <code>T_GPFLT</code>). That would start<br>running the trap handler code, which would eventually get to the <code>switch</code><br>statement in <code>trap()</code> (see the last post). Trap number 13 would fall under the<br><code>default</code> case, and the if statement there would recognize that it originated in<br>the kernel. So it would print an error message to the console, then panic.</p>
<p>Okay, what if we’re using a process’s page directory, e.g. during a system call?<br>Address 0 is in the lower half of memory, so it’s a user virtual address. The<br>result will depend on whether that page and its page table are mapped in the<br>process’s page directory. If they are, then dereferencing a null pointer might<br>be fine after all. But if they’re not mapped, dereferencing a null pointer will<br>cause a General Protection Fault. This time, <code>trap()</code> would print an error<br>message to the console, then mark the process to be killed.</p>
<p>Now, killing a process or causing a kernel panic might not sound like a huge<br>deal. In fact, xv6 does a great job here by killing a process that might have<br>dereferenced a null pointer or caused the kernel to do so. A kernel panic would<br>be much worse – think about how annoying it would be if that PDF you downloaded<br>from that one sketchy website installed some malware that made your kernel panic<br>all the time – the OS would become unusable. In fact, this is an example of a<br>“denial of service” vulnerability – a malicious process might not be able to<br>read or write arbitrary memory or execute arbitrary code, but it can still keep<br>you from using your machine the way you expect to.</p>
<p>Just like <code>uva2ka()</code>, this function will only get called by one other function<br>(we’ll see it soon), so it just so happens that under the current xv6 code,<br>it’ll all be okay because it should never get passed a null pointer. But<br>everything from my rant about <code>uva2ka()</code> applies here: if you add any kernel<br>code that calls this function, be <em>VERY</em> careful and add your own null checks.</p>
<p>Okay, deep breath now. &#x2F;rant.</p>
<h3 id="fetchstr"><a href="#fetchstr" class="headerlink" title="fetchstr"></a>fetchstr</h3><p>Fetching a string argument is tricky too; strings in C are just pointers to an<br>array of characters that ends in nul, i.e. <code>&#39;\0&#39;</code>, so this time we have to make<br>sure that both the pointer <em>and</em> the entire string are in the user’s address<br>space; otherwise, we could unwittingly read from some arbitrary memory location<br>and pass the data back to the user process.</p>
<p>So we’ll start by making sure the pointer itself is in a valid address:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt;= curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll store the string pointer in <code>*pp</code>. We’ll also get a pointer to the end<br>of the process’s virtual address space so we can make sure the entire string is<br>inside its bounds.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pp = (<span class="type">char</span> *) addr;</span><br><span class="line">    <span class="type">char</span> *ep = (<span class="type">char</span> *) curproc-&gt;sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>How can we check if the entire string is inside user memory? Well, a string ends<br>with a nul byte, <code>&#39;\0&#39;</code>, so we just have to start scanning the memory starting<br>from <code>*pp</code> up to <code>ep</code> until we find a zero byte. If we find one in that range,<br>then the entire string is in user memory and we can return its length to<br>indicate success; otherwise the string overflows past the end of the process’s<br>virtual address space, so we should return -1 to indicate failure.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for a nul byte inside process&#x27;s address space</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> *s = *pp; s &lt; ep; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If nul byte found, return the length</span></span><br><span class="line">            <span class="keyword">return</span> s - *pp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// String is not nul-terminated inside process&#x27;s memory, so report failure</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that again, we’re dereferencing <code>pp</code> and <code>addr</code> without any null checks<br>(where <code>addr</code> is definitely the bigger concern, since it’s user-generated), and<br>again, it’s gonna work out okay (a misbehaving process will just get killed),<br>but once more: be careful if you use this function for your own kernel hacks.</p>
<h3 id="argint"><a href="#argint" class="headerlink" title="argint"></a>argint</h3><p>This is the main function that the <code>sys_</code> system call functions will use to<br>recover an integer argument; it’s basically just a wrapper for <code>fetchint()</code>. The<br>arguments are an integer <code>n</code> to say we want the nth integer argument, and a<br>pointer <code>ip</code> to store the recovered argument in. We have to call <code>fetchint()</code><br>with an address argument, so the main task now is to figure out where in memory<br>the nth integer argument should be.</p>
<p>We’re gonna have to use the x86 function call conventions again. Remember how<br>whenever we call a function in x86, its arguments get pushed onto the stack in<br>reverse order (i.e., from right to left), so that the first argument is at the<br>top of the stack (i.e., lowest memory address)? Then we push a return address<br>(<code>%eip</code>) and the old stack base pointer <code>%ebp</code>. Normally, the stack pointer<br>would just keep going on to the next slot on the callee’s stack, but in this<br>case the code in <code>alltraps()</code> saved all the registers (including the stack<br>pointer <code>%esp</code>) in a <code>struct trapframe</code> before calling <code>trap()</code> or <code>syscall()</code>.</p>
<p>That means we can recover the old value of <code>%esp</code> from the trap frame and look<br>one spots below that on the stack (i.e., 4 bytes higher in memory, since <code>int</code>s<br>are 4 bytes) to get the first (<code>n = 0</code>) argument. The second argument (<code>n = 1</code>)<br>would be 8 bytes higher than <code>%esp</code>, and so on. Pretty neat.</p>
<p>Okay, now that we’ve got that down, the code for this function is pretty<br>straightforward.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fetchint((myproc()-&gt;tf-&gt;esp) + <span class="number">4</span> + <span class="number">4</span>*n, ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="argptr"><a href="#argptr" class="headerlink" title="argptr"></a>argptr</h3><p>Some of the system call functions will have pointer arguments, so this function<br>recovers them. Pointers are 4 bytes in x86, so we can use <code>argint()</code> to get the<br>pointer itself before performing some additional checks to make sure the pointer<br>and the address it points to are valid.</p>
<p>The arguments are <code>n</code> (to retrieve the nth function argument), a pointer <code>pp</code> to<br>an address where we can store the retrieved pointer, and the size of the block<br>of memory that the retrieved pointer points to.</p>
<p>Let’s start off by just retrieving the value of the pointer as an integer using<br><code>argint()</code>; that’ll make sure that the number <code>n</code> is valid.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (argint(n, &amp;i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have to make sure that the pointer we just retrieved is itself valid,<br>i.e. that the size is nonnegative and the beginning and end of the memory block<br>it points to are both within the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (uint) i &gt;= curproc-&gt;sz || (uint) i + size &gt; curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we can store the pointer in <code>*pp</code> and return 0.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pp = (<span class="type">char</span> *) i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="argstr"><a href="#argstr" class="headerlink" title="argstr"></a>argstr</h3><p>A string is just a pointer in C, so we can recover the pointer’s value using<br><code>argint()</code> again, then pass it to <code>fetchstr()</code>. The former will make sure <code>n</code> is<br>valid, and the latter will make sure the string is nul-terminated and resides<br>entirely in the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (argint(n, &amp;addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchstr(addr, pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sysproc-c"><a href="#sysproc-c" class="headerlink" title="sysproc.c"></a>sysproc.c</h2><p>So now we know how <code>syscall()</code> will route a system call trap to the right <code>sys_</code><br>function, and we’ve seen how those functions can recover arguments from the<br>process’s stack. Let’s see some examples in action; most of these will be simple<br>wrapper functions.</p>
<h3 id="sys-fork"><a href="#sys-fork" class="headerlink" title="sys_fork"></a>sys_fork</h3><p>All the hard work here is gonna be done by <code>fork()</code>, which will create a new<br>child process by cloning the parent process’s virtual address space. We don’t<br>need any arguments for this, so we’ll just call <code>fork()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-exit"><a href="#sys-exit" class="headerlink" title="sys_exit"></a>sys_exit</h3><p><code>exit()</code> closes out a process, but it puts it in the <code>ZOMBIE</code> state so that the<br>parent process can call <code>wait()</code> to find out it’s done running. <code>exit()</code> should<br>never return, so we’ll add a return value here to make the compiler happy, but<br>it should never get executed.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-wait"><a href="#sys-wait" class="headerlink" title="sys_wait"></a>sys_wait</h3><p>This system call is the parent process’s counterpart to <code>exit()</code>; it’ll do as<br>its name says and wait until the child process exits.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-kill"><a href="#sys-kill" class="headerlink" title="sys_kill"></a>sys_kill</h3><p>The <code>kill()</code> system call sounds like a more aggressive version of <code>exit()</code>:<br>after all, we’re killing another process against its will, right? But in reality<br>it would be way too complicated to do that: the process might be running on<br>another CPU, midway through updating some kernel data structure, or about to<br>wake up another process that’s asleep. Killing it by force might screw up a lot<br>of other things.</p>
<p>So instead <code>kill()</code> just tags it with the <code>killed</code> field in its <code>struct proc</code>;<br>eventually either the process will call <code>exit()</code> on its own, or it’ll generate<br>another trap, at which point the code in <code>trap()</code> will call <code>exit()</code> on it.</p>
<p><code>kill()</code> needs an integer argument: the process ID for the process we wish to<br>kill. So now we can see the payoff of writing those functions above.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;pid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kill(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-getpid"><a href="#sys-getpid" class="headerlink" title="sys_getpid"></a>sys_getpid</h3><p>The <code>getpid()</code> system call is so simple that it doesn’t even have another<br>function for this <code>sys_getpid()</code> to call. We’ll just return the PID for the<br>current process.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> myproc()-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-sbrk"><a href="#sys-sbrk" class="headerlink" title="sys_sbrk"></a>sys_sbrk</h3><p>If you’re not familiar with system calls like <code>brk()</code> and <code>sbrk()</code> on Unix<br>systems, here’s what they do: they grow or shrink the virtual address space of a<br>process. <code>brk()</code> sets its new size to a specific maximum address; <code>sbrk()</code> grows<br>or shrinks the process by a certain size in bytes and returns its old size.<br>They’re mostly used to implement higher-level memory management functions like<br><code>malloc()</code>. Heh, “high-level” probably isn’t high on your mind when you think of<br>adjectives for <code>malloc()</code>, right? Anyway, xv6 only has <code>sbrk()</code>, so let’s check<br>out its <code>sys_</code> wrapper function.</p>
<p>We’ll need an integer argument (the number of bytes to grow or shrink by), so<br>let’s grab that.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can use <code>growproc()</code> from our posts on paging to grow the process by <code>n</code><br>bytes. But we want to return the old size, so we’ll have to grab that before we<br>change it with the call to <code>growproc()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> addr = myproc()-&gt;sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (growproc(n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-sleep"><a href="#sys-sleep" class="headerlink" title="sys_sleep"></a>sys_sleep</h3><p>The <code>sleep()</code> function is pretty interesting; we’ll get to the implementation<br>details later, but let’s talk about the broad strokes now. You might be familiar<br>with the <code>sleep()</code> system call in Unix systems; you pass it an integer (usually<br>in milliseconds) and it puts your process to sleep (i.e., leaves it inactive or<br>not running) for that amount of time.</p>
<p>However, <code>sleep()</code> plays a dual role in xv6: the kernel will call <code>sleep()</code> for<br>processes that need to wait while something else happens, e.g. waiting for a<br>disk to read or write data. That way the processes don’t end up idly spinning in<br>a loop or something and wasting valuable CPU time.</p>
<p>Implementing that is tricky; there’s no way to know how long it would take for<br>whatever condition the process is waiting on to be satisfied, so it’s not like<br>we can just stick in a random amount of time in the call to <code>sleep()</code> and hope<br>the condition is satisfied by then. So instead the <code>sleep()</code> function will just<br>“put a process to sleep” (read: make its state <code>SLEEPING</code> so it can’t be run by<br>the scheduler) on a <em>channel</em>, which is just an arbitrary integer. Then later on<br>the kernel can wake up any processes sleeping on that channel. So for example,<br>the kernel can put a process waiting on the disk to sleep using a specific<br>channel that’s assigned to the disk; then when the next disk interrupt occurs it<br>can wake up any processes that might be sleeping on the disk channel.</p>
<p>Okay so that’s all well and good for the kernel’s use of <code>sleep()</code>. But what<br>about the regular old <code>sleep()</code> system call? The argument is an integer that<br>represents the number of ticks to sleep for; how are we gonna turn that into a<br>channel to sleep on?</p>
<p>The answer is pretty neat (at least I think so): we’ll set the channel to the<br>address of the <code>ticks</code> counter. Remember, <code>ticks</code> is a global variable that gets<br>incremented with every timer interrupt. Go check out the code in <code>trap()</code> again:<br>each timer interrupt sends a wakeup call to any processes that might be sleeping<br>on the <code>&amp;ticks</code> channel. That should wake the process at every timer interrupt.<br>Then we’ll just stick that inside a for loop so it keeps sleeping forever until<br>the right amount of ticks have passed.</p>
<p>Let’s start by retrieving the integer argument, which is the number of ticks to<br>sleep for.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That argument <code>n</code> is a relative count, since a user process won’t necessarily<br>know how many ticks have already gone by. So let’s get the current tick count<br>before we put the process to sleep.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    uint ticks0 = ticks;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we just have to write that while loop I mentioned above to put the process<br>to sleep until <code>n</code> ticks have passed. Since we started counting at <code>ticks0</code>, the<br>condition should be satisfied when <code>ticks - ticks0 == n</code>.</p>
<p>Two more details: first, we’ll add a check inside the while loop to see if the<br>current process has been tagged to be killed; if so, we’ll just return -1 so we<br>can hasten the process’s actual death by letting it run more code so the kernel<br>will call <code>exit()</code> on it at the next trap. Second, the function <code>sleep()</code> takes<br>another argument in addition to the channel: a lock. It’ll release the lock for<br>us and reacquire it before waking up so that a sleeping process doesn’t hog a<br>lock when it doesn’t need it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (ticks - ticks0 &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            release(&amp;tickslock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-uptime"><a href="#sys-uptime" class="headerlink" title="sys_uptime"></a>sys_uptime</h3><p>The <code>uptime()</code> system call just returns the amount of ticks that have passed<br>since the system started. This is another one that’s so simple it doesn’t need<br>another function, so we’ll take care of it all here.</p>
<p>We just acquire the lock for <code>ticks</code>, get its current value, release the lock,<br>and return the value we got.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    uint xticks = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> xticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Running-System-Calls-from-User-Code"><a href="#Running-System-Calls-from-User-Code" class="headerlink" title="Running System Calls from User Code"></a>Running System Calls from User Code</h2><p>We have system calls now! Well, not quite – we still have to check out the<br>actual functions like <code>exit()</code>, <code>sleep()</code>, <code>kill()</code>, etc. Plus, we only saw the<br><code>sys_</code> wrapper functions for <em>some</em> of the system calls here; the rest are in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/sysfile.c">sysfile.c</a>, which<br>we’ll get to after we understand the xv6 file system.</p>
<p>But let’s pause for a second and think about how a user process will send a<br>system call. Like let’s say you’re writing some C code for a user program that<br>will run on xv6 and you want to create a child process with <code>fork()</code>. What<br>should you do?</p>
<p>Well, if you were coding for a Unix system like Linux or macOS, you’d just write<br>a call to <code>fork()</code> in your code. But that can’t be right in xv6, can it? After<br>all, <code>fork()</code> is a kernel function, to be run in kernel mode with a current<br>privilege level of 0. Plus, isn’t it supposed to be called by <code>sys_fork()</code>? So<br>should we call that?</p>
<p>None of these options will work. Well, yes, you do end up just calling <code>fork()</code>,<br>but it’s <em>not</em> the kernel function <code>fork()</code>, so if you’re expecting that one,<br>you’ll be surprised when it doesn’t behave the way you want it to. You won’t be<br>able to use any kernel code at all in your user program for xv6. This is a<br>mistake I’ve seen a <em>lot</em> of people make in their xv6 OSTEP projects, so bear<br>with me for a second while I explain why you can’t do it; feel free to skip the<br>next section on the Makefile if you already know why.</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>To see why, let’s check out the xv6<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a> to see<br>how xv6 is actually compiled, built, and run. There’s a ton of stuff in there,<br>but take a second to think about this: how do you usually run xv6? I bet it’s<br>a command like <code>make qemu</code> or <code>make qemu-nox</code>, right?</p>
<p>If you’re not familiar with Makefiles, here’s a quick primer: each command like<br><code>make qemu</code>, <code>make clean</code>, etc. is specified in the Makefile with a rule that<br>looks like this:</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="section">mycmd: dependency1 dependency2 ...</span></span><br><span class="line">    build_cmd1</span><br><span class="line">    build_cmd2</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>So if I run <code>make mycmd</code>, the <code>make</code> program will check that <code>dependency1</code>,<br><code>dependency2</code>, etc. are up to date; if they’re not, it’ll update them by looking<br>up <em>their</em> rules and executing those to update them. Then it’ll execute<br><code>build_cmd1</code> on the shell, followed by <code>build_cmd2</code>, etc.</p>
<p>Okay, I know that might be confusing, so let me simply the <code>make qemu</code> command a<br>bit to make it more readable (note that I cut a lot of stuff out here, so don’t<br>try to run xv6 with what I wrote below).</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">qemu: fs.img xv6.img</span></span><br><span class="line">    qemu -drive file=fs.img,index=1 -drive file=xv6.img,index=0</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>This just says that in order to run <code>make qemu</code> when you type it on the<br>terminal, the <code>make</code> program first has to make sure that both <code>fs.img</code> and<br><code>xv6.img</code> are fully up to date. Then once they are, it can just run the shell<br>command <code>qemu</code> with the options <code>-drive file=fs.img,index=1</code> and<br><code>-drive file=xv6.img,index=0</code>. Those options are just regular flags like the<br>ones you’re probably used to with stuff like <code>ls -a</code> or <code>rm -rf</code>. In this case,<br>they tell <code>qemu</code> to use the files <code>fs.img</code> and <code>xv6.img</code> as virtual hard drives,<br>with <code>xv6.img</code> as disk number 0 and <code>fs.img</code> as disk number 1.</p>
<p>Okay, let’s check out the <code>make</code> command for <code>xv6.img</code> next.</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">xv6.img: bootblock kernel</span></span><br><span class="line">    <span class="comment"># some dd commands here</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Hey, that’s interesting, we already saw <code>bootblock</code> in a prior post. That’s the<br>one we get when we compile the boot loader. <code>kernel</code> is, well, all the kernel<br>code. The <code>dd</code> command is often used in Unix systems to format and set up disks;<br>the details aren’t important here, so I left them out for now. The point is that<br>the boot loader got compiled separately from the kernel code, remember? But<br>their machine code files get smushed into the same (virtual) disk together as<br><code>xv6.img</code>, which will be disk 0 when we run in <code>qemu</code>.</p>
<p>Not let’s check out the (slightly simplified) <code>make</code> command for <code>fs.img</code>.</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">UPROGS = cat echo forktest grep init kill ln ls <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="section">fs.img: mkfs README <span class="variable">$(UPROGS)</span></span></span><br><span class="line">    ./mkfs fs.img README <span class="variable">$(UPROGS)</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Okay, so <code>UPROGS</code> is just a list of all the user programs. Each of those gets<br>compiled separately; e.g. if you look in their source code, you’ll see each one<br>has its own <code>main()</code> function. Then the shell command says to run <code>mkfs</code> to<br>create a file system called <code>fs.img</code> with <code>README</code> and all the user programs as<br>files.</p>
<p>The point of this detour is this: the boot loader gets compiled as a single<br>unit, as does the entire kernel code. But the user programs are compiled one at<br>a time. So if you write a user program for xv6, you should add it to the list in<br><code>UPROGS</code> (as well as in <code>EXTRA</code>) and expect it to get compiled individually and<br>stuck onto the <code>fs.img</code> disk.</p>
<p>That means there’s no way for a user program to call into any kernel code; the<br>linker wouldn’t even be able to match up the call to the right function. So no<br>user program will ever be able to call functions like (the kernel’s) <code>fork()</code>.<br>Think about it: if you write a program in C and compile it to run on Linux, do<br>you expect to have to recompile the entire Linux kernel just to run your one<br>little program? No, right?</p>
<p>But certainly we can’t just expect every single program ever to be totally self-<br>contained. You also don’t have to rewrite and recompile all of <code>malloc()</code> every<br>time you write a C program. So operating systems provide libraries for users to<br>include and call in their programs. Aha! So all we need to do in order for<br>user processes to execute system calls is to provide a library. That library is<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/usys.S">usys.S</a>.</p>
<h3 id="usys-S"><a href="#usys-S" class="headerlink" title="usys.S"></a>usys.S</h3><p>Let’s trace back to the beginning of a trap. In order to execute a system call,<br>we’re supposed to send the processor an <code>int</code> instruction with a specific trap<br>number; that would be <code>int 64</code> for system calls on xv6. We’re also supposed to<br>stick the system call number in the <code>%eax</code> register. Let’s say we want to call<br><code>fork()</code>. According to<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/syscall.h">syscall.h</a>, the<br>system call number for fork is <code>SYS_fork</code>, or 1. In order to send a specific x86<br>instruction and manipulate individual registers, we’ll have to write our system<br>call library in assembly. Here’s what it would look like for the <code>fork()</code> system<br>call:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl fork</span><br><span class="line">fork:</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>Okay, that’s easy enough, but we have 21 of these to write, and it would be<br>pretty easy to make a mistake or write the wrong system call number. Let’s<br>automate it instead with a C preprocessor macro. We’ve seen plenty of examples<br>of defining simple constants with <code>#define</code> directives for the preprocessor, but<br>we haven’t looked at them too closely until now.</p>
<p>The C preprocessor is a piece of software that edits C (or assembly) code before<br>it’s compiled. Preprocessor directives like <code>#define A 5</code> create macros that are<br>expanded to replace every instance of <code>A</code> in the code with the number 5;<br>directives like <code>#include &quot;header.h&quot;</code> expand such that they essentially copy-<br>paste all the code in the file <code>header.h</code>. We can also create function-like<br>macros like the <code>P2V()</code> and <code>V2P()</code> macros we’ve used often by adding a<br>parameter inside parentheses; unlike functions, these will be expanded <em>before</em><br>compilation to paste the code into every instance of its use, thus avoiding the<br>usual overhead associated with a function call. Function-like macros are also<br>generic, in a sense, since they don’t require specifying parameter types or<br>return types (as long as it works within the places where the macro will be<br>used). Note that there are some drawbacks: macros aren’t type-checked, they can<br>evaluate their arguments more than once, we can’t use pointers to them like we<br>can with functions, and they can result in larger code.</p>
<p>We’re gonna use a function-like macro here to create the assembly code for each<br>system call function so that it gets expanded before the code is assembled.<br>We’ll use <code>T_SYSCALL</code> instead of 64 in the code above, and <code>SYS_fork</code> (or its<br>equivalent for each system call) for the system call number. We’ll have to<br>replace the part after the underscore in <code>SYS_</code> with the name of the system call<br>function; we can do that with the token-pasting operator <code>##</code>, which glues two<br>tokens together to form a single token. Also, macros must be defined on a single<br>line, so we’ll escape the newline characters with <code>\</code> and end each assembly line<br>with a semicolon.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line">#include &quot;traps.h&quot;</span><br><span class="line"></span><br><span class="line">#define SYSCALL(name) \</span><br><span class="line">    .globl name; \</span><br><span class="line">    name: \</span><br><span class="line">        movl    $SYS_##name, %eax; \</span><br><span class="line">        int $T_SYSCALL; \</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>Now we can just invoke the macro on the name of each function we want to create:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">SYSCALL(fork)</span><br><span class="line">SYSCALL(exit)</span><br><span class="line">SYSCALL(wait)</span><br><span class="line"># and so on ...</span><br></pre></td></tr></table></figure>

<p>After the preprocessor runs on the file, the result will look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl fork</span><br><span class="line">fork:</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl exit</span><br><span class="line">exit:</span><br><span class="line">    movl    $2, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl wait</span><br><span class="line">wait:</span><br><span class="line">    movl    $3, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"># and so on...</span><br></pre></td></tr></table></figure>

<p>Great! Now we have 21 functions for the system calls, all written in assembly.<br>All user programs for xv6 will be compiled together with the code for these<br>functions: see <code>ULIB</code> in the Makefile. So now, a user program can execute a<br>system call by calling these functions, e.g. <code>fork()</code>.</p>
<h2 id="Summary-9"><a href="#Summary-9" class="headerlink" title="Summary"></a>Summary</h2><p>After all the preparations are handled by the trap handler functions in the IDT,<br><code>alltraps()</code>, and <code>trap()</code>, system calls get routed to the <code>syscall()</code> function,<br>which uses a system call number to pick the right function out of an array. That<br>function will have to recover any arguments to the system call before passing it<br>on to the real system call function later on.</p>
<p>Next up, we’ll take a look at some of those system calls; we’ll leave the rest<br>until after we go over xv6’s file system.</p>
<h1 id="System-Calls-Processes"><a href="#System-Calls-Processes" class="headerlink" title="System Calls: Processes"></a>System Calls: Processes</h1><p>In a previous post, I pointed out some of the most important functions a kernel<br>has to fulfill. System calls take care of two of these: virtualizing resources<br>via virtual memory and processes, and mediating communication between user-mode<br>processes and the hardware. We’ll wrap up the former now by looking at the<br>system call functions relating to processes and scheduling.</p>
<h2 id="proc-c-2"><a href="#proc-c-2" class="headerlink" title="proc.c"></a>proc.c</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>Unlike some of the other functions we’ll talk about in this post, <code>fork()</code> is<br>used almost exclusively by user code as a system call; the kernel never calls<br>it. That said, it has an extremely important role: after the first process has<br>started, it’s the only way to create more processes. It does that by copying the<br>parent process’s virtual address space into a new page directory. We haven’t<br>talked about the file system yet, but hopefully you’re familiar with file I&#x2F;O in<br>Linux, so you know each process has its own list of open files and a current<br>working directory; <code>fork()</code> will clone those as well for the child process.</p>
<p>Let’s start off by getting a pointer to the parent process and creating a slot<br>in the process table for the child process with <code>allocproc()</code>. Remember, that<br>function returns a pointer to the new process’s <code>struct proc</code>, but it can fail<br>and return null (e.g., if there is no available slot in the process table, or if<br>its call to <code>kalloc()</code> fails), so we’ll need to check for that.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate process table slot for child process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((np = allocproc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allocproc()</code> also sets up the new process’s stack so that it’ll return into<br><code>forkret()</code>, then <code>trapret()</code>, before context switching into user mode, and sets<br>the process’s state to <code>EMBRYO</code>.</p>
<p>Next we need a page directory for the new child process; it should be a copy of<br>the parent process’s page directory. Luckily, we already did the hard work for<br>this back in the virtual memory posts, so we can just use <code>copyuvm()</code> now. That<br>function can also fail, in which case we’ll free the stack that <code>allocproc()</code><br>created and set the child process’s state back to <code>UNUSED</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((np-&gt;pgdir = copyuvm(curproc-&gt;pgdir, curproc-&gt;sz)) == <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(np-&gt;kstack);</span><br><span class="line">        np-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        np-&gt;state = UNUSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll copy the parent process’s size and trap frame; the latter will make<br>sure the child starts executing after <code>trapret()</code> with the same register<br>contents as the parent. We’ll set the child process’s parent to, well, its<br>parent (the current process).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    np-&gt;sz = curproc-&gt;sz;</span><br><span class="line">    np-&gt;parent = curproc;</span><br><span class="line">    *np-&gt;tf = *curproc-&gt;tf;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The two processes will be nearly identical, so we need a way to distiguish them<br>from user space so that a user program can give different instructions to each.<br>xv6 follows the Unix convention that <code>fork()</code> should return the child process’s<br>PID to the parent and return 0 for the child. The parent’s return value is easy;<br>we’ll just literally return the child’s PID at the end. But the child didn’t<br>actually call <code>fork()</code>, so how can we set a return value that it will see?</p>
<p>Well, the x86 convention is for return values to be passed in the <code>%eax</code><br>register, right? And that register will be restored from the trap frame before<br>switching into user mode. So we’ll just store the value 0 there.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    np-&gt;tf-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll copy all the parent process’s open files and its current working<br>current working directory. The files are stored in a per-process file array<br><code>curproc-&gt;ofile</code> of size <code>NOFILE</code>, so we can copy them over with the function<br><code>filedup()</code> (which we’ll see later). The current working directory is in<br><code>curproc-&gt;cwd</code> and can be copied with <code>idup()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NOFILE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> curproc-&gt;ofile[i]) &#123;</span><br><span class="line">            np-&gt;ofile[i] = filedup(curproc-&gt;ofile[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    np-&gt;cwd = idup(curproc-&gt;cwd);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we’ll copy the parent process’s name with <code>safestrcpy()</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>. You<br>might be familiar with the C standard library funtion <code>strncpy()</code>; this function<br>is almost identical, except that unlike <code>strncpy()</code> it’s guaranteed to nul-<br>terminate the string it copies. If you haven’t seen this kind of thing before,<br>it’s a fairly common practice to write your own safe wrappers for some of the C<br>standard library functions, especially the ones in <code>string.h</code> which are so often<br>error-prone and dangerous.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    safestrcpy(np-&gt;name, curproc-&gt;name, <span class="keyword">sizeof</span>(curproc-&gt;name));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll set the child process’s state to <code>RUNNABLE</code> and return its PID<br>for the parent.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    np-&gt;state = RUNNABLE;</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>This is one of the functions that can get called both by the kernel and as a<br>system call. The kernel will use it to terminate malicious or buggy processes,<br>and user code can use it as a system call to kill another process too.</p>
<p>We said before that killing a process immediately would present all kinds of<br>risks (e.g. corrupting any kernel data structures it might be updating, etc.),<br>so all we’re gonna do is give it the ominous mark of death with the <code>p-&gt;killed</code><br>field. Then the code in <code>trap()</code> will handle the actual murder the next time the<br>process passes through there.</p>
<p>The argument is a process ID number, so let’s just iterate over the process<br>table until we find a process with a matching PID; we’ll return -1 if we don’t<br>find any.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we do find a matching process, then we’ll set <code>p-&gt;killed</code>. Also, some of the<br>calls to <code>sleep()</code> will occur inside a while loop that checks if <code>p-&gt;killed</code> has<br>been set since the process started sleeping, so let’s hasten the process’s death<br>a little by setting its state to <code>RUNNABLE</code> so it’ll wake up and encounter those<br>checks faster. There’s no risk of screwing up by waking up a process too early,<br>since each call to <code>sleep()</code> should be in a loop that will just put it back to<br>sleep if it’s not ready to wake up yet.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">                p-&gt;state = RUNNABLE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            release(&amp;ptable.lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>The last post went over the basics of <code>sleep()</code> and <code>wakeup()</code>; they act as<br>mechanisms for <em>sequence coordination</em> or <em>conditional synchronization</em>, which<br>allows processes to communicate with each other by sleeping while waiting for<br>conditions to be fulfilled and waking up other processes when those conditions<br>are satisfied.</p>
<p>Processes can go to sleep on a channel or wake up other processes sleeping on a<br>channel. In many operating systems, this is achieved via channel queues or even<br>more complex data structures, but xv6 makes it as simple as possible by simply<br>using pointers (or equivalently, integers) as channels; the kernel can just use<br>any convenient address as a pointer for one process to sleep on while other<br>processes send a wakeup call using the same pointer.</p>
<p>This does mean that multiple processes might be sleeping on the same channel,<br>either because they are waiting for the same condition before resuming execution<br>or because two different <code>sleep()</code>&#x2F;<code>wakeup()</code> pairs accidentally used the same<br>channel. The result would be that a process might be woken up before the<br>condition it’s waiting for has been fulfilled. We can solve that problem by<br>requiring every call to <code>sleep()</code> to occur inside a loop that checks the<br>condition; that way, if a process receives a spurious wakeup call before it<br>really should have been woken up, the loop will put it right back to sleep<br>anyway. We saw one example of this in the <code>sys_sleep()</code> function, in which the<br>while loop checked if the right number of ticks had passed.</p>
<p>A common concurrency danger with conditional synchronization in any operating<br>system is the problem of missed wakeup calls: if the process that’s supposed to<br>send the wakeup call runs <em>before</em> the process that’s supposed to sleep, it’s<br>possible that the sleeping process will never be woken up again. The problem is<br>more general than just processes; it applies to devices too.</p>
<p>Imagine this scenario: a process tries to read from the disk; it’ll check<br>whether the data is ready yet and go to sleep (inside a while loop) until it is.<br>If the disk gets to run first, then the process will just find the data ready<br>and waiting for it, so it can continue on to use the data. If the process runs<br>before the disk does, then it’ll see the data isn’t ready yet and sleep in a<br>loop until it is; the disk will wake the process up once the data is ready.</p>
<p>But suppose they run at the same time, or in between each other. The process<br>does its check and finds the data isn’t ready, but before it can go to sleep, a<br>timer interrupt or some other trap goes off and the kernel switches processes.<br><em>Then</em> the disk finishes reading and starts a disk interrupt that sends a wakeup<br>call to any sleeping processes, but the process isn’t sleeping yet. When the<br>process starts running again later on, it’ll go to sleep – having already<br>missed its wakeup call.</p>
<p>The problem is that the process can get interrupted between checking the<br>condition and going to sleep, right? So why don’t we just disable interrupts<br>there with <code>pushcli()</code> and <code>popcli()</code>? add a lock there? Ah, but there’s another<br>problem: what if the disk driver is running simultaneously on another CPU?<br>Disabling interrupts on the process’s CPU wouldn’t stop the other CPU from<br>sending the disk’s wakeup call too early.</p>
<p>Okay fine, so let’s use a lock instead. The process will hold the lock while it<br>checks the condition and sleeps, and the disk driver will have to acquire the<br>lock before it can send its wakeup call… Can you see the problem here? If the<br>process holds the lock while it’s sleeping, the disk driver will never be able<br>to acquire the lock in order to wake it up. That’s a deadlock.</p>
<p>HEAD. DESK.</p>
<p>Ugh, okay, fine, you got me. So let’s use a lock, but let’s have <code>sleep()</code><br>release it right away, then reacquire it before waking up; that way the lock<br>will be free while the process is sleeping so the disk driver can acquire it.<br>Done, right? Everybody’s happy?</p>
<p>Nope. Now we’re back to the original problem: if the lock gets released inside<br><code>sleep()</code> before the process is actually sleeping, then the wakeup call might<br>happen in between those and get missed.</p>
<p>@*#&amp;@#$**&amp;@#%$!!!</p>
<p>So we need a lock. And we can’t hold the lock while sleeping, or we’d get a<br>deadlock. But we also can’t release it before sleeping, or we might miss a<br>wakeup call. So… ???</p>
<p>See, I told you: concurrency is your worst nightmare. Ever since we decided we’d<br>like our operating systems to do more than run a single basic process at a time,<br>we introduced all <em>kinds</em> of problems we have to reason through. Let’s check out<br>how xv6 actually writes the <code>sleep()</code> function and think through it ourselves<br>and try to understand if it manages to solve this problem.</p>
<p>We’ll start by making sure of two things: (1) this CPU is currently running a<br>process and not the scheduler (which can’t ever go to sleep), and (2) the caller<br>passed in a lock (which can be any arbitrary lock).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lk == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sleep without lk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to release the lock and put the process to sleep. That will require<br>modifying its state, so we should now acquire the lock for the process table.<br>But if the lock that the process is already holding <em>is</em> the process table lock,<br>then trying to acquire it again would cause a panic, so let’s add a check for<br>that; if we’re already holding it then we’ll keep using it and we don’t need to<br>release it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (lk != &amp;ptable.lock) &#123;</span><br><span class="line">        acquire(&amp;ptable.lock);</span><br><span class="line">        release(lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s nap time for this process. We just update its channel to <code>chan</code><br>and its state to <code>SLEEPING</code>, then call <code>sched()</code> to perform a context switch<br>into the scheduler so it can run a new process. We <em>have</em> to be holding the<br>process table lock before calling <code>sched()</code>, remember?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;chan = chan;</span><br><span class="line">    p-&gt;state = SLEEPING;</span><br><span class="line">    sched();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the process wakes up later on (if indeed it turns out that the code here<br>works and doesn’t miss any wakeup calls), it’ll eventually be run by the<br>scheduler, at which point it will context switch back here. So at that point<br>we’ll reset its channel and reacquire the original lock before returning.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lk != &amp;ptable.lock) &#123;</span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">        acquire(lk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, well I don’t know about you, but I’m still not convinced that this<br>implementation won’t miss any wakeup calls. After all, we release the original<br>lock before putting the process to sleep, right? We’re holding the process table<br>lock at that point, which at least means that interrupts are disabled, but the<br>process that will wake this one up might already be running on another CPU and<br>might send the wakeup signal in between releasing the original lock and<br>updating this process’s channel and state. Hmm… Well, as always, xv6 is<br>brilliant, so we’ll see how this gets solved in the code for <code>wakeup()</code>.</p>
<p>But wait! Before we move on, I have a warning for you about using this function<br>in your own code when you start hacking away at xv6. Remember that when we first<br>talked about deadlocks, we saw we can cause a deadlock if two processes acquire<br>two locks in opposite orders? If process 1 tries to acquire lock A, then lock B,<br>and process 2 simultaneously tries to acquire lock B, then lock A, then the end<br>result is that process 1 will acquire lock A and process 2 will acquire lock B,<br>but neither will be able to acquire the other lock since it’s already being held.</p>
<p>If you look at the code above, the process that called <code>sleep()</code> must have<br>already been holding a lock <code>lk</code>, then <code>sleep()</code> acquires <code>ptable.lock</code> before<br>releasing <code>lk</code>. You know what that means: there’s potential for a deadlock. So<br>in order to avoid that, you should make sure that <em>any</em> lock you pass in to<br><code>sleep()</code> must <em>always</em> get acquired before <code>ptable.lock</code>. If any other function<br>(or chain of function calls) could potentially acquire <code>ptable.lock</code> before <code>lk</code>,<br>then you might end up with a deadlock. As always, the xv6 authors have been<br>extremely careful to make sure that that never happens in the existing code, so<br>you’ll have to do the same thing for any code you add.</p>
<h3 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup"></a>wakeup</h3><p>This function is short and sweet because it procrastinates all the work it has<br>to do by pushing it off to a helper function, <code>wakeup1()</code>. It just acquires the<br>process table lock, calls <code>wakeup1()</code>, then releases the process table lock. It<br>has to grab that lock since it’s gonna modify the process’s state in the process<br>table.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    wakeup1(chan);</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xv6 has to use this kind of a wrapper function for the real wakeup function<br><code>wakeup1()</code> in order to let processes that are already holding the process table<br>lock send wakeup calls too.</p>
<p>Okay, now before we go look at <code>wakeup1()</code>, let’s get back to figuring out<br>whether xv6’s implementation of <code>sleep()</code> and <code>wakeup()</code> can lead to missed<br>wakeup calls. Take a look at the code in <code>sleep()</code> again where the original lock<br>gets released – we have to acquire the process table lock <em>before</em> we can<br>release the other lock. So now there are always two locks in play whenever we<br>use <code>sleep()</code> and <code>wakeup()</code>.</p>
<p>Let’s go back to the example of a process waiting on a disk read. The process<br>acquires some disk-related lock first, then checks to see if the disk is done<br>reading; if not, it’ll call <code>sleep()</code> inside a while loop. If the disk driver<br>runs now before the process gets to call <code>sleep()</code>, that’s okay: the disk driver<br>also has to acquire the same lock before calling <code>wakeup()</code>, so the disk would<br>just end up spinning idly. Eventually, the process runs again and gets to<br>call <code>sleep()</code>; there, it will first acquire the process table lock before<br>releasing the original disk-related lock.</p>
<p>So what happens if the disk driver’s code runs now? Now the disk would be able<br>to acquire the original lock, so there’s nothing stopping it from calling<br><code>wakeup()</code>. But the very first thing it has to do there is acquire the process<br>table lock, which the process is already holding, so it just spins idly again!<br>There’s no way the disk driver could ever beat the process to acquiring this<br>second lock, because the process already held the first (disk-related) lock<br>before acquiring the second one (the process table lock). Now the process can<br>finish going to sleep and switch into the scheduler, which will eventually<br>release the process table lock. So then the disk driver can acquire it, release<br>the first lock, and finally send its wakeup call.</p>
<p>Moral of the story? There’s no way for xv6 to ever have any missed wakeup calls!<br>The trick was to use two locks, and acquire the second before releasing the<br>first. But coming up with that solution isn’t as easy as saying “oh, just use<br>two locks!” The solution only works because of the way the process table lock is<br>already being handled by so many other parts of the kernel code. For example, if<br>the context switch into the scheduler wasn’t guaranteed to release the process<br>table lock, then the disk driver in the example would never be able to acquire<br>it after the process goes to sleep, resulting in a deadlock. The solution works<br>because of all the design decisions in xv6 up to this point.</p>
<h3 id="wakeup1"><a href="#wakeup1" class="headerlink" title="wakeup1"></a>wakeup1</h3><p>Okay, I’ll stop fawning over the intricacies of xv6 concurrency management now<br>so we can look at how wakeup calls actually happen. Remember, this is a separate<br>function from <code>wakeup()</code> because sometimes the scheduler needs to send a wakeup<br>call while it’s already holding the process table lock. So we’re gonna assume<br>that every function that ever calls this is already holding it.</p>
<p>The implementation here is actually pretty simple now: we’ll just iterate over<br>the process table and set every single process that’s sleeping on channel<br><code>chan</code> to <code>RUNNABLE</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wakeup1</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">            p-&gt;state = RUNNABLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, there might be multiple processes sleeping on this channel, so this will<br>wake them all up. For some of those processes, this might be a spurious wakeup,<br>so again, we should always make sure to call <code>sleep()</code> in a loop that checks for<br>some condition to be satisfied. Even if multiple processes do have their<br>sleep conditions satisfied, they’ll have to reacquire their original lock before<br>returning out of <code>sleep()</code>, so only one of them will do so and the others will<br>spin until the first one is done.</p>
<p>Why not just wake up the first process we find that’s sleeping on <code>chan</code>? Then<br>we could avoid the extra overhead of a bunch of processes waking up, checking a<br>condition, and going back to sleep, or even spinning idly waiting to reacquire<br>the lock before returning. The issue is that the channels may not be unique, so<br>there’s no way to know which of all the sleeping processes is the one whose<br>sleep condition has just been fulfilled. If we wake up the wrong process, it’ll<br>just go back to sleep, but the right process didn’t wake up, so that means we’ve<br>lost a wakeup call.</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>Okay, so we saw above that <code>kill()</code> doesn’t really kill a process immediately;<br>it shirks that responsibility and lets <code>exit()</code> handle it instead… except<br>even <code>exit()</code> won’t really fully kill a process. Whew, a process’s death just<br>keeps getting dragged out forever, doesn’t it? It’s starting to feel like a<br>cheesy death scene in a tragedy; I bet the process is tired of suffering the<br>slings and arrows of outrageous fortune by now.</p>
<p>But it does make sense. Think about what we have to do in order to wrap up a<br>process and recycle its slot in the process table: we have to close out any open<br>files and reset its current working directory, free its kernel stack and its<br>entire page directory, then notify the parent that it’s done running.</p>
<p>The trouble comes with freeing the kernel stack and process page directory. This<br>function runs in kernel mode, so while the user stack in the lower half of<br>memory will be unused now, the kernel stack is still needed in order to keep<br>executing the instructions for <code>exit()</code>. Also, with the exception of the times<br>when it’s running the scheduling algorithm, the kernel uses the page directory<br>of the current process. The moment we free that page directory, the very next<br>memory access will be to an invalid page; the CPU would trigger an exception<br>then. That exception would eventually get routed to <code>exit()</code> again, except, oh<br>wait, we can’t even run any instructions without generating another exception,<br>because the entire page directory and stack have been freed; that’s a double<br>fault. So then the CPU would try to handle <em>that</em> exception, which would cause<br>the dreaded boogeyman of OS devs around the world: a triple fault. After a fault<br>triggers a second exception, which itself triggers a third exception, the CPU<br>just decides that the kernel in its current state doesn’t have its shit together<br>enough to keep running, so it takes over and reboots the whole system. Oops.</p>
<p>Okay, so let’s not do that. That means we can’t free the kernel stack nor the<br>page directory until we’re running on a different stack&#x2F;page directory combo.<br>That could happen in <code>scheduler()</code> while we’re using the page directory <code>kpgdir</code>,<br>or it could happen while we’re running another process. xv6 does it while it’s<br>running the parent process, in the <code>wait()</code> system call. If you haven’t used<br>that in Linux before, <code>wait()</code> lets a parent process sleep until a child process<br>is done running. xv6 will use <code>wait()</code> to finish cleaning up after an exited<br>child process too.</p>
<p>Now, the very first process that starts running in xv6 (<code>initproc</code>, which loads<br>and runs the shell) obviously has no parent process, but that’s okay because<br>that one should never exit as long as the system is up. So let’s start this<br>function off by making sure that the process that’s exiting isn’t the initial<br>process.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (curproc == initproc) &#123;</span><br><span class="line">        panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll close all open files and clear the current working directory; again,<br>we haven’t seen the file system functions used here, but we’ll get to them soon.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all open files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curproc-&gt;ofile[fd]) &#123;</span><br><span class="line">            fileclose(curproc-&gt;ofile[fd]);</span><br><span class="line">            curproc-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the current working directory</span></span><br><span class="line">    begin_op();</span><br><span class="line">    iput(curproc-&gt;cwd);</span><br><span class="line">    end_op();</span><br><span class="line">    curproc-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we only have one thing left to do: notify the parent process that this<br>process has exited. If the parent process is currently sleeping in <code>wait()</code>,<br>then we’ll need to wake it up. But maybe the parent process is currently in the<br>middle of executing other code before it gets to <code>wait()</code>; we don’t want it to<br>miss the wakeup call… oh wait, but that’s okay, remember? The implementations<br>of <code>sleep()</code> and <code>wakeup()</code>&#x2F;<code>wakeup1()</code> guarantee that we can’t miss a wakeup<br>call as long as we’re holding the right lock; <code>wait()</code> will use the process<br>table lock for that. So let’s acquire it now and send a wakeup call.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    wakeup1(curproc-&gt;parent);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, remember that a sleeping process needs to check some condition in a loop;<br>how can the parent process know that the child has exited? Hmm, okay, let’s set<br>the child’s state to <code>ZOMBIE</code>. That’ll also prevent the scheduler from trying to<br>run it again.</p>
<p>Ah, but hang on a sec… what if the parent process has itself been killed, i.e.<br>the current process has been orphaned? (Again with the melodrama…) A process<br>can’t run any more user code after <code>exit()</code>, so an undead parent process would<br>never get to call <code>wait()</code> to clean up after its children. In that case, we’d<br>have to find another process that could adopt a child.</p>
<p>So let’s just solve that problem now: this process is about to shuffle off its<br>mortal coil, so let’s figure out if it has any children and pass them off to<br>another process that can keep raising them as its own. But which process is<br>guaranteed to live long enough to clean up after those children once they die?<br>Ah, <code>initproc</code>, of course! That first process is immortal, so it should be able<br>to look after any children that this process might leave behind after it makes<br>its quietus with a bare bodkin.</p>
<p>So we’ll iterate over the process table, looking for any processes with parent<br>process equal to <code>curproc</code>; if we find any, we’ll have <code>initproc</code> adopt them.<br>If any of our now-abandoned children has already exited before we did, we’ll<br>send a wakeup signal to <code>initproc</code> too in case it’s sleeping in <code>wait()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parent == curproc) &#123;</span><br><span class="line">            p-&gt;parent = initproc;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == ZOMBIE) &#123;</span><br><span class="line">                wakeup1(initproc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s finally time for this process to find out what dreams may come in<br>that sleep of death. We’ll set its state to <code>ZOMBIE</code> and context-switch into the<br>scheduler, never to return; if something goes wrong and the scheduler <em>does</em><br>return, we’ll panic in order to keep this function from returning into user code<br>again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    curproc-&gt;state = ZOMBIE;</span><br><span class="line">    sched();</span><br><span class="line"></span><br><span class="line">    panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>Like we said above, this system call lets a parent process wait for a child<br>process to exit; it also cleans up after the child process has exited.</p>
<p>First, we don’t even know if this process has any children, so we’ll have to<br>check by iterating through the process table and checking each process’s parent<br>to see if it matches the current process. If it does, then we’ll check if it’s a<br>zombie, in which case we can clean it up and return its process ID.</p>
<p>We should also deal with two edge cases: first, if the process has no children<br>at all, and second, if the process does have children but none of them are dead<br>yet. In the first case, we’ll just return -1 to report failure; in the second<br>case we’ll put the current process to sleep until one of its children exits. The<br><code>sleep()</code> call means we’ll have to do these checks inside an infinite loop.</p>
<p>Alright, let’s get started by getting the current process and acquiring the<br>process table lock, then starting an infinite loop.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inside the loop, we’ll use a variable <code>havekids</code> as a boolean to track whether<br>we’ve found any child processes. Then we can iterate over the process table,<br>skipping any processes for which the current process is not the parent. If we<br>find any children, we’ll set <code>havekids</code> to 1.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> havekids = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent != curproc) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            havekids = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we did find a child process, we should check if it’s a zombie, in which case<br>it’s time to finish its clean-up. That means freeing its kernel stack and its<br>page directory and recycling its <code>struct proc</code> so that it can be reallocated to<br>another process later on.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == ZOMBIE) &#123;</span><br><span class="line">                <span class="type">int</span> pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Free child&#x27;s kernel stack</span></span><br><span class="line">                kfree(p-&gt;kstack);</span><br><span class="line">                p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Free child&#x27;s page directory</span></span><br><span class="line">                freevm(p-&gt;pgdir);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Recycle child&#x27;s struct proc</span></span><br><span class="line">                p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">                p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">                p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">                p-&gt;state = UNUSED;</span><br><span class="line"></span><br><span class="line">                release(&amp;ptable.lock);</span><br><span class="line">                <span class="keyword">return</span> pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if <code>havekids</code> is still zero by the time we finish the for loop, that means<br>the process doesn’t have any children, so we should report failure. We’ll also<br>check if the process has been marked as killed in the meantime.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!havekids || curproc-&gt;killed) &#123;</span><br><span class="line">            release(&amp;ptable.lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, if it <em>does</em> have children, but none of them have exited yet, we’ll put<br>the process to sleep. It’ll get woken up when a child exits, at which point<br>it’ll restart the outer for loop at the top and start looking through the<br>process table again.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        sleep(curproc, &amp;ptable.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-10"><a href="#Summary-10" class="headerlink" title="Summary"></a>Summary</h2><p>By now, we’ve looked at a good chunk of the system calls available in xv6. These<br>system calls wrap up the mechanisms that xv6 uses to create and exit processes<br>with <code>fork()</code>, <code>kill()</code>, <code>exit()</code>, and <code>wait()</code>, and introduced <code>sleep()</code> and<br><code>wakeup()</code> as a means for (limited) inter-process communication.</p>
<p>So what’s left now? The rest of the kernel code we’re gonna look at will just<br>focus on communicating with various hardware devices like the serial port,<br>console, and keyboard. Those drivers are relatively short, but there’s one<br>device that will require a lot more work: the disk. Storing files on disk and<br>making sure they persist across reboots require careful planning, and making<br>files conveniently accessible to users requires an entire system of abstractions<br>layered on top of each other, along with a whole host of file-related system<br>calls.</p>
<h1 id="Sleep-Locks"><a href="#Sleep-Locks" class="headerlink" title="Sleep Locks"></a>Sleep Locks</h1><p>We’ve used plenty of spin-locks, and a previous post looked at their<br>implementation in xv6. Spin-locks have pretty harsh performance costs: a process<br>that’s waiting to acquire a lock will just spin idly in a while loop, wasting<br>valuable CPU time that could be used to run other processes. So far, we’ve only<br>seen locks for kernel resources like the process table, page allocator, and<br>console, for which all operations should be relatively fast, on the order of a<br>few dozen CPU cycles at most.</p>
<p>Now it’s time to look at the disk driver and file system implementation, and<br>we’ll need some locks there too. But disk operations are <em>slow</em> – reading from<br>and writing to disk might take milliseconds, which is a literal eternity for a<br>CPU. Imagine a process hogging a spin-lock for the disk while other processes<br>spin around and around waiting <em>forever</em> for the disk to finish writing. It<br>would be an enormous waste!</p>
<p>Spin-locks were the best we could do at the time, since we didn’t have any<br>infrastructure to support more complex locks, but now we really do need a better<br>alternative. We also have some more kernel building blocks in place relating to<br>processes, including a bunch of system calls.</p>
<p>For example, we’ve seen the <code>sleep()</code> and <code>wakeup()</code> system calls, which let a<br>process give up the CPU until some condition is met. Well, hang on a second –<br>what if that condition is that a lock is free to acquire? Then a process could<br>sleep while another process holds the lock, and wake up when it’s ready to be<br>acquired; that would let other processes run instead of forcing a process to<br>spin and spin. xv6 calls these <em>sleep-locks</em>, and it’s time to find out how they<br>work.</p>
<h2 id="sleeplock-h"><a href="#sleeplock-h" class="headerlink" title="sleeplock.h"></a>sleeplock.h</h2><p>If we want a process holding a sleep-lock to give up the processor in the middle<br>of a critical section, then sleep-locks have to work well when held across<br>context switches. They also have to leave interrupts enabled. This couldn’t<br>happen with spin-locks: it was important that they disable interrupts to prevent<br>deadlocks and ensure a kernel thread can’t get rescheduled in the middle of<br>updating some important data structure.</p>
<p>Leaving interrupts on adds some extra challenges. First, we have to make sure<br>the lock can still be acquired atomically; second, we have to make sure that any<br>operations in the critical section can safely resume after being interrupted.</p>
<p>Let’s solve the first problem: how can we make sure a sleep-lock will always be<br>acquired atomically? Well, if we want to do something atomically, we already<br>have a solution: spin-locks! So rather than reinventing the wheel, we’ll just<br>make each sleep-lock a two-tiered deal with a spin-lock to protect its<br>acquisition.</p>
<p>We’ll use a <code>locked</code> field just like the one all spin-locks have, but then we’ll<br>add a spin-lock to protect it. We’ll also make debugging a little easier by<br>adding a name for the lock and a field for a PID to identify which process is<br>holding it.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">    uint locked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="sleeplock-c"><a href="#sleeplock-c" class="headerlink" title="sleeplock.c"></a>sleeplock.c</h2><h3 id="initsleeplock"><a href="#initsleeplock" class="headerlink" title="initsleeplock"></a>initsleeplock</h3><p>We can initialize a sleep-lock by initializing its guard spin-lock, then adding<br>a name for it, setting <code>locked</code> to false, and the <code>pid</code> field to zero.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initsleeplock</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;lk-&gt;lk, <span class="string">&quot;sleep lock&quot;</span>);</span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acquiresleep"><a href="#acquiresleep" class="headerlink" title="acquiresleep"></a>acquiresleep</h3><p>In order to make sure sleep-lock acquisition is atomic, we’ll bookend this<br>function by acquiring and releasing a spin-lock. This will also make sure that<br>interrupts are disabled during this function but re-enabled when it’s done. It<br>does add some overheard in the form of spinning until this lock is free, but the<br>code here should be relatively short and fast to execute. What we really want is<br>to avoid spinning once the sleep-lock is acquired, i.e. spinning <em>after</em> this<br>function is done. So we’ll tolerate a little waste here.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now we have to do the actual acquisition. We said above that we’d use the<br><code>sleep()</code> function to avoid wasting processor time. Hopefully you remember one<br>important detail about <code>sleep()</code>: it must always be called inside a while loop<br>in order to make sure that we don’t miss any wakeup calls. So let’s check if the<br>sleep-lock is already being held and go to sleep if it is. We’ll need a channel<br>and a lock for <code>sleep()</code> to release, so let’s use the pointer to this lock <code>lk</code><br>as the channel, and the outer spin-lock <code>lk-&gt;lk</code> as the lock to be released.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">        sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s important to keep the two locks separate in your head right now: <code>lk</code> is<br>the sleep-lock, and <code>lk-&gt;lk</code> is the spin-lock it uses to protect the sleep-lock’s<br>acquisition. Note that we’re checking <code>lk-&gt;locked</code> here, <em>not</em> the spin-lock<br><code>lk-&gt;lk</code> – this process is already holding <code>lk-&gt;lk</code>, but we need to acquire<br><code>lk</code> itself by updating <code>lk-&gt;locked</code>. Phew, try saying that ten times fast.</p>
<p>Now the process will go to sleep and yield the CPU until the sleep-lock is free.<br>If multiple processes are sleeping waiting on the same sleep-lock, they will all<br>wake up at the same time, but all of them have to reacquire <code>lk-&gt;lk</code> before<br>returning from sleep, so only one will get to return here and complete the<br>sleep-lock acquisition. The others will spin a bit longer, then return here only<br>to find that <code>lk-&gt;locked</code> is already being held by another process, so the while<br>loop will put them to sleep again.</p>
<p>Once the sleep-lock is free, the process can exit the while loop and claim the<br>sleep-lock for itself.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">    lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We don’t need fancy atomic operations like <code>xchg</code> anymore, since the guarding<br>spin-lock has already made sure that interrupts are disabled and all operations<br>are effectively atomic. So that’s all we need! Now we just release the spin-lock<br>and return.</p>
<h3 id="releasesleep"><a href="#releasesleep" class="headerlink" title="releasesleep"></a>releasesleep</h3><p>Now that we’ve seen how a process acquires a sleep-lock, releasing it is easy,<br>we just do the opposite. We’ll set <code>lk-&gt;locked</code> to zero and clear the <code>lk-&gt;pid</code><br>field. And what’s the opposite of <code>sleep()</code>? Well, <code>wakeup()</code>, of course! That<br>will check whether there are any processes sleeping on this channel and let them<br>know they can attempt to acquire the sleep-lock now.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line"></span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    wakeup(lk);</span><br><span class="line"></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="holdingsleep"><a href="#holdingsleep" class="headerlink" title="holdingsleep"></a>holdingsleep</h3><p>This function is even more simple: it just checks whether a sleep-lock is being<br>held, and if so, whether it’s being held by the current process. The first is<br>done by just checking <code>lk-&gt;locked</code>; the second is done by checking that <code>lk-&gt;pid</code><br>matches the current process’s PID. The result is a boolean stored in a temporary<br>variable so we can release the guarding spin-lock before returning the result.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holdingsleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);</span><br><span class="line"></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-11"><a href="#Summary-11" class="headerlink" title="Summary"></a>Summary</h2><p>Okay, that wasn’t too bad! It makes sense why we couldn’t use sleep-locks in a<br>kernel without system calls like <code>sleep()</code> and <code>wakeup()</code>. But xv6 already has<br>those, so why not use them everywhere? If sleep-locks really do cut down on the<br>wasted CPU time, can we just go back and replace all the spin-locks with<br>sleep-locks? Then the only use for spin-locks would be as a guard for the more-<br>sophisticated sleep-locks.</p>
<p>Hold your horses! It’s not that easy. Sleep-locks leave interrupts enabled, so<br>they can’t be used in interrupt handler functions, or inside a critical section<br>where a spin-lock is being used, since interrupts will be disabled (though spin-<br>locks can be used inside sleep-lock critical sections). They also can’t be used<br>by kernel threads like the scheduler, since those aren’t processes and thus<br>can’t be put to sleep.</p>
<p>Finally, there are some situations in which a sleep-lock might actually add<br><em>more</em> overhead than a spin-lock: it takes some time to put a process to sleep,<br>schedule another process, send a wakeup call, schedule the first process again,<br>and so on, and the process will hold the sleep-lock the entire time. If another<br>process is waiting on the sleep-lock, it might actually end up waiting longer<br>than with a spin-lock, although it’ll wait in a sleeping state instead of a<br>running state where it just spins in a loop.</p>
<p>Additionally, sleep-locks can only be used when it’s safe to interrupt a process<br>in the middle of a critical section and wake it up later. Sure, no other process<br>can acquire the sleep-lock in the meantime, but it’s still not great for time-<br>sensitive operations like getting the current number of <code>ticks</code>.</p>
<p>So sleep-locks are great, but their applications are more limited than spin-<br>locks. The perfect use for them is when a process needs to complete an operation<br>atomically, but that operation itself might take a very long time. A great<br>example of that is disk I&#x2F;O, and we’ll see next how xv6 puts them to use in its<br>file system implementation.</p>
<h1 id="Devices-Disk-Driver"><a href="#Devices-Disk-Driver" class="headerlink" title="Devices: Disk Driver"></a>Devices: Disk Driver</h1><p>At this point, we’ve seen how xv6 virtualizes memory and the processor to give<br>each user process the illusion of a contiguous, near-infinite memory space and a<br>dedicated CPU to run it; we’ve also seen how xv6 mediates interactions between<br>most of a computer’s hardware components and user processes via system calls.<br>But there’s one more piece of hardware that’s critically important for an OS<br>that we haven’t looked at yet: the disk. All that’s left in the kernel code for<br>us to look at is how xv6 manages data storage on the disk and how it presents<br>that data to users in a simplified way.</p>
<p>The function of a disk is to provide <em>persistence</em> for an operating system. RAM<br>is volatile memory: it gets erased when the machine is turned off, so any data<br>stored there is fleeting. A disk allows an OS to store and retrieve data across<br>shut-offs. The disk driver we’ll go over in this post allows the xv6 kernel<br>direct access to that device so it can read and write data to it.</p>
<p>But unlike other devices, a simple driver isn’t enough here. We don’t just need<br>to be able to read and write data; we’d like to present users with a simplified,<br>accessible framework to navigate that data. Imagine using a computer where you<br>had to specify which byte of the disk to read or write, then remember that<br>yourself in order to access it again later. It’s madness! Enter file systems;<br>“files” don’t really exist in any real sense on a disk, but the OS can provide<br>the illusion of discrete, individual files in order to simplify access to data.</p>
<p>We also need to make sure concurrent accesses of the same file don’t risk<br>corrupting the file (or even the entire file system). We need to separate out<br>kernel data (like the kernel code itself) from user data on the disk, so that a<br>malicious user process can’t just overwrite arbitrary kernel code. Finally,<br>there’s that oh-so-famous line about Unix systems, “everything is a file”. We’ll<br>need a way to present “everything” in the elegant abstraction of a file.</p>
<p>All of these abstractions and security checks will require far more code than a<br>simple driver to implement them, so before we go on to the driver, let’s check<br>out how xv6 will organize its file system to get a preview of what’s ahead.</p>
<h2 id="File-System-Organization"><a href="#File-System-Organization" class="headerlink" title="File System Organization"></a>File System Organization</h2><p>Laying the abstraction of a complete file system on top of a physical disk will<br>require several steps. xv6 does this using seven layers. From bottom (direct<br>hardware interaction) to top (user-facing code), they are:</p>
<ul>
<li>Disk driver: reads and writes blocks on an IDE hard drive.</li>
<li>Buffer cache: caches disk blocks in memory and synchronizes access to them.</li>
<li>Logging: provides atomic disk writes to mitigate the risk of a crash.</li>
<li>Inodes: turns disk blocks into individual files that the OS can manipulate.</li>
<li>Directories: creates a tree of named directories that contain other files.</li>
<li>Path names: provides hierarchical, human-readable path names in the directory tree structure.</li>
<li>File descriptors: abstracts OS resources like pipes and devices as files to provide a unified API for user programs.</li>
</ul>
<p>That’s a lot of work to do now, but it’ll pay off! The kernel will do all this<br>labor so that users are free to be lazy later on and can live in blissful<br>ignorance of the fact that their precious little files actually exist as nothing<br>but ones and zeroes in totally arbitrary locations on the disk.</p>
<p>Note that hard drives are usually divided into <em>sectors</em>, which are physical<br>divisions (originally referring to literal geometric sectors), traditionally of<br>512 bytes. Operating systems can then collect these into larger <em>blocks</em> which<br>are multiples of the sector size. xv6 uses 512-byte blocks for simplicity so<br>that the sector and block sizes match up; I’ll use the two terms interchangeably.</p>
<p>On the disk, block 0 usually contains the boot sector, so it’s not used by xv6<br>(but remember the Makefile – xv6 actually stores the boot loader and kernel<br>code on an entirely separate physical disk). Block 1 is called the <em>superblock</em><br>because it contains metadata about the file system like its total size, the size<br>of the log, the number of files, and their location on the disk. Then the log<br>starts at block 2 and on.</p>
<h2 id="buf-h"><a href="#buf-h" class="headerlink" title="buf.h"></a>buf.h</h2><p>If you’ve read any of the previous optional posts on device drivers, you know<br>that interacting directly with the hardware means all kinds of opaque code with<br>seemingly-arbitrary port I&#x2F;O and cryptic magic numbers. Drivers are also specific<br>to the actual (or virtual) hardware in the machine that xv6 will run on, so it<br>tends to be less useful for showing general OS concepts – hence why all the<br>other device driver posts were optional. That being said, the disk driver nicely<br>rounds out the rest of the file system code, so I recommend checking it out, but<br>if you’re short on time or bored with all the talk about hardware specs, feel<br>free to skip to the summary section below.</p>
<p>Reading and writing disk data is super slow, so the second layer in the file<br>system is the buffer cache, which will store copies of disk blocks in memory for<br>faster access. But we still have to read from the disk to create that buffer,<br>and we still have to write any modified data to the disk once we’re done, so<br>we still need a layer below the buffer cache to do that. That layer is the disk<br>driver; its purpose is to copy data from the disk to the in-memory cache and<br>vice versa. A single block is represented in the cache as a <code>struct buf</code>, defined<br>in <a href="https://github.com/mit-pdos/xv6-public/blob/master/buf.h">buf.h</a>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    uint dev;               <span class="comment">// device number</span></span><br><span class="line">    uint blockno;           <span class="comment">// block number (same as sector number)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span>  <span class="comment">// sleep-lock to protect buffer reads and writes</span></span><br><span class="line">    uint refcnt;            <span class="comment">// how many processes are using this buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span>       <span class="comment">// for use with buffer cache doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span>       <span class="comment">// for use with buffer cache doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span>      <span class="comment">// for use with disk driver queue</span></span><br><span class="line">    uchar data[BSIZE];      <span class="comment">// data stored in the buffer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_VALID 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_DIRTY 0x4</span></span><br></pre></td></tr></table></figure>

<p>The two constants defined at the bottom are used in the <code>flags</code> field; <code>B_VALID</code><br>indicates that a buffer has been read from disk and should accurately reflect<br>the sector’s contents on the disk, and <code>B_DIRTY</code> says we’ve modified the buffer<br>but haven’t yet updated the on-disk version of a file, so we need to write the<br>buffer to disk soon.</p>
<p>We’ll see later on that the buffer cache uses a doubly-linked list of buffers;<br>the <code>prev</code> and <code>next</code> fields are used there. However, the disk driver also<br>maintains its own queue of buffers that are waiting to be read from or written<br>to the disk; that’s implemented as a singly-linked list using the <code>qnext</code> field.</p>
<h2 id="ide-c"><a href="#ide-c" class="headerlink" title="ide.c"></a>ide.c</h2><p>We’ve already seen some code to read and write disk data in the <a href="boot.md">boot loader</a>;<br>I know it’s been a while, so you can check that out again if you want. We can’t<br>reuse the code there for a few reasons, though: (1) the boot loader has to be<br>compiled separately from the kernel, so we can’t access any of the functions<br>there, and (2) we need to store data in the buffer cache, so we can’t even copy-<br>paste the code we used before since the boot loader barely even knows what<br>memory is, let alone a buffer cache.</p>
<h3 id="ATA-Programmed-I-O-Mode"><a href="#ATA-Programmed-I-O-Mode" class="headerlink" title="ATA Programmed I&#x2F;O Mode"></a>ATA Programmed I&#x2F;O Mode</h3><p>Modern disk drivers usually talk to the disk via direct memory access (DMA), but<br>to keep things simple xv6 is just gonna talk to it with port I&#x2F;O. That’s much,<br>much slower, and it requires active participation by the CPU (which means it<br>can’t do anything else at the same time), but hey, xv6 thinks it’s 1995,<br>remember? So PIO mode is still (relatively) cutting edge. Either way, extreme<br>performance isn’t the goal here, so we’ll just have to suck it up.</p>
<p>Okay, let’s do a super-quick summary. <code>inb</code> is a C wrapper for an x86 assembly<br>instruction that reads a single byte of data from a port; <code>outb</code> writes a byte<br>to a port. The disk controller chip has primary and secondary buses; the primary<br>bus sends data on port 0x1F0 and has control registers on ports 0x1F1 through<br>0x1F7. Port 0x1F7 doubles as a command register and a status port with some<br>useful flags we can check in order to know what the disk is up to; we saw some<br>of those before, but I’ll give you the full list now.</p>
<ul>
<li>Bit 0 (0x01) - ERR (indicates an error occurred)</li>
<li>Bit 1 (0x02) - IDX (index; always set to zero)</li>
<li>Bit 2 (0x04) - CORR (corrected data; always set to zero)</li>
<li>Bit 3 (0x08) - DRQ (drive has data to transfer or is ready to receive data)</li>
<li>Bit 4 (0x10) - SRV (service request)</li>
<li>Bit 5 (0x20) - DF (drive fault error)</li>
<li>Bit 6 (0x40) - RDY (ready; clear when drive isn’t running or after an error and set otherwise)</li>
<li>Bit 7 (0x80) - BSY (busy; drive is in the middle of sending&#x2F;receiving data)</li>
</ul>
<p>The disk driver defines some of these with preprocessor macros at the top of the<br>file.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECTOR_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_BSY     0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_DRDY    0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_DF      0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_ERR     0x01</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>We also saw one command example in the boot loader: sending 0x20 to port 0x1F7<br>tells the disk to read a sector and send it to us through data port 0x1F0. Now<br>we’ll also use commands to write a sector, as well as to read or write multiple<br>sectors at once.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_READ    0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_WRITE   0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_RDMUL   0xc4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_WRMUL   0xc5</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>If, for some reason beyond mortal comprehension, you decide you want to know<br>more about the eldritch secrets of ancient hard drives, you can read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/ATA-d1410r3a.pdf">this<br>resource on ATA disks</a>.</p>
<p>After those constants, we find three static global variables: a spin-lock for<br>accessing the disk, the queue of buffers waiting to be synchronized with their<br>on-disk counterparts, and a boolean to track whether xv6 is running with only<br>disk 0 (boot loader and kernel) or with disk 1 (user file system) as well.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">idelock</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">idequeue</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> havedisk1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="idewait"><a href="#idewait" class="headerlink" title="idewait"></a>idewait</h3><p>This function takes an integer <code>checkerr</code> argument that should be a boolean and<br>waits for the disk to be ready to receive more commands. If <code>checkerr</code> is true,<br>it’ll also check whether the status port includes any error flags.</p>
<p>It starts by reading from the disk’s status port and looping until the busy<br>flag is not set but the ready flag is. The bitwise-OR <code>IDE_BSY | IDE_DRDY</code><br>combines both flags, and the bitwise-AND tests whether either one is set in <code>r</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">idewait</span><span class="params">(<span class="type">int</span> checkerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (((r = inb(<span class="number">0x1f7</span>)) &amp; (IDE_BSY | IDE_DRDY)) != IDE_DRDY)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now if <code>checkerr</code> is nonzero we have to check that neither the error nor the<br>drive failure flag is set in the status port. If either one is set, we’ll return<br>-1; we’ll return 0 otherwise.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">idewait</span><span class="params">(<span class="type">int</span> checkerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (checkerr &amp;&amp; (r &amp; (IDE_DF | IDE_ERR)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ideinit"><a href="#ideinit" class="headerlink" title="ideinit"></a>ideinit</h3><p>This function is called by the kernel’s <code>main()</code> during set-up to initialize the<br>disk. We start by initializing the disk lock, then tell the I&#x2F;O interrupt<br>controller to forward all disk interrupts to the last CPU. We talked about the<br><code>ioapicenable()</code> function in detail in the post on interrupt controllers.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;idelock, <span class="string">&quot;ide&quot;</span>);</span><br><span class="line">    ioapicenable(IRQ_IDE, ncpu - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we wait for the disk to be ready to accept commands (ignoring any error<br>flags that may be present).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    idewait(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We said above that disk 0 should contain the boot loader and kernel, so we can<br>assume any machine running xv6 should have that present. However, we need to<br>make sure disk 1 is present; the<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a> includes<br>some configurations like <code>make qemu-memfs</code> under which xv6 can run without a<br>dedicated disk for the file system, storing files in memory instead.</p>
<p>Port 0x1F6 is used to select a drive. Bits 5 and 7 should always be set, and bit<br>6 picks the right mode we need to indicate a disk. Bit 4 determines whether we<br>want to select disk 0 or disk 1. So we can select drive 1 by setting bits 5-7<br>(0xE0 when combined), then bit 4 (<code>1 &lt;&lt; 4</code>).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to wait for disk 1 to be ready; we need to handle this as a special<br>case since <code>waitdisk()</code> can’t check a specific disk for us, and because an<br>absent disk 1 would make the while loop there continue forever. So we’ll check<br>the status register 1000 times; if it ever reports that it’s ready, we’ll set<br><code>havedisk1</code> to true and break, but otherwise we’ll assume disk 1 isn’t present<br>and leave <code>havedisk1</code> as zero (i.e., false).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inb(<span class="number">0x1f7</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            havedisk1 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll switch back to using disk 0 by changing the fourth bit of the<br>register at port 0x1F6.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">0</span> &lt;&lt; <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="idestart"><a href="#idestart" class="headerlink" title="idestart"></a>idestart</h3><p>This is the core function that will read or write a buffer to or from the disk.<br>It’s a <code>static</code> function, so it can only be called by other functions in this<br>file; <code>ideintr()</code> and <code>iderw()</code> will both use it as a helper function. It takes<br>a pointer to a buffer, so the first thing to do is make sure that pointer isn’t<br>null. We’ll also make sure the buffer’s block number is within the maximum limit<br>set by <code>FSSIZE</code>, defined in<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 1000.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;blockno &gt;= FSSIZE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;incorrect blockno&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to figure out which disk sector to read from or write to. Since xv6<br>uses blocks that are the same size as a sector, this should just be <code>b-&gt;blockno</code>,<br>but we’ll add a conversion here in case that gets changed later on (especially<br>if we want higher disk throughput).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> sector_per_block = BSIZE / SECTOR_SIZE;</span><br><span class="line">    <span class="type">int</span> sector = b-&gt;blockno * sector_per_block;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If each block fits exactly one sector, then we’ll need to use the single-sector<br>read and write commands; otherwise we should use the multi-sector versions of<br>those commands. We’ll set <code>read_cmd</code> and <code>write_cmd</code> to the right versions.<br>We’ll also make sure that there are no more than 7 sectors per block.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> read_cmd = (sector_per_block == <span class="number">1</span>) ? IDE_CMD_READ : IDE_CMD_RDMUL;</span><br><span class="line">    <span class="type">int</span> write_cmd = (sector_per_block == <span class="number">1</span>) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;</span><br><span class="line">    <span class="keyword">if</span> (sector_per_block &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s wait for the disk to be ready, ignoring any error flags.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    idewait(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s time to brace yourself, because this next part is a hot mess of<br>port I&#x2F;O operations with lots of magic numbers. First we’ll tell the disk<br>controller to generate an interrupt once it’s done reading or writing by setting<br>the device control register at 0x3F6 to zero. Then we’ll tell it how many total<br>sectors we want to read or write by writing that number (AKA <code>sector_per_block</code>)<br>to port 0x1F2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x3f6</span>, <span class="number">0</span>);                 <span class="comment">// generate interrupt when done</span></span><br><span class="line">    outb(<span class="number">0x1f2</span>, sector_per_block);  <span class="comment">// number of sectors to read/write</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Before sending the read or write command, we have to tell the disk which sector<br>to read from, using our <code>sector</code> variable from above. Let’s take a second to<br>talk about hard drive geometry. A hard drive consists of a bunch of stacked<br>circular surfaces, where each surface has a corresponding <em>head</em> that changes<br>its position to read or write from the right place on the disk. Each surface has<br>a number of <em>tracks</em>: concentric circles that contain data. If you pick a track<br>number (i.e. pick a distance from the center of the surfaces) and collect all<br>those tracks from all the surfaces, you get a <em>cylinder</em>.</p>
<p>A sector number acts as a kind of address with each part specifying a different<br>geometric component, similar to how linear addresses contain a page directory<br>index, page table index, and offset. The eight most significant bits (24 through<br>31) identify the drive and&#x2F;or head that the sector is located on (plus some<br>flags); bits 8 through 23 identify the cylinder, and bits 0 through 7 pick a<br>sector within that cylinder. Altogether, these define a 3D coordinate system<br>that uniquely identifies all sectors on a machine’s disks.</p>
<p>Port 0x1F3 is the sector number register, ports 0x1F4 and 0x1F5 are the cylinder<br>low and high registers, and port 0x1F6 is the drive&#x2F;head register. We can write<br>the sector number as <code>sector &amp; 0xFF</code>; the cylinder low and high numbers can be<br>recovered by bitshifting <code>sector</code> down by 8 and 16, respectively.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f3</span>, sector &amp; <span class="number">0xff</span>);             <span class="comment">// sector number</span></span><br><span class="line">    outb(<span class="number">0x1f4</span>, (sector &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);      <span class="comment">// cylinder low</span></span><br><span class="line">    outb(<span class="number">0x1f5</span>, (sector &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);     <span class="comment">// cylinder high</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now for the drive&#x2F;head register, we’ll use <code>b-&gt;dev</code> to get the block’s device<br>and <code>(sector &gt;&gt; 24)</code> to get the head it’s on. Finally, we’ll set bits 5-7 as<br>required (and as mentioned above in <code>ideinit()</code>) with 0xE0. Then we can<br>bitwise-OR all of these together and write them to port 0x1F6.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | ((b-&gt;dev &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>) | ((sector &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0f</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, that was the worst of it! Deep breath now. The last part is just sending<br>the actual read or write command. But how do we know which one we’re supposed to<br>do? The only argument is a pointer to a buffer <code>b</code>, not any sort of boolean that<br>might tell us which to carry out. Well, remember the buffer flag <code>B_DIRTY</code>? That<br>one indicates that a buffer has been modified and needs to be written to disk.<br>If that flag is set, reading from the disk would overwrite any changes, which<br>probably isn’t what we want. So let’s just assume that the <code>B_DIRTY</code> flag means<br>we should write to disk, and the absence of that flag means we should read from<br>disk.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;flags &amp; B_DIRTY) &#123;</span><br><span class="line">        outb(<span class="number">0x1f7</span>, write_cmd);</span><br><span class="line">        outsl(<span class="number">0x1f0</span>, b-&gt;data, BSIZE / <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outb(<span class="number">0x1f7</span>, read_cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here <code>outsl()</code> is another C wrapper for an x86 instruction; this one writes data<br>from a string, four bytes at a time.</p>
<p>That’s it! This is by far the most cryptic function in the disk driver; the last<br>two are relatively easy now.</p>
<h3 id="ideintr"><a href="#ideintr" class="headerlink" title="ideintr"></a>ideintr</h3><p>We saw in <code>idestart()</code> that we set up the disk to send an interrupt whenever<br>it’s done reading or writing data. Back when we looked at<br><a href="https://github.com/mit-pdos/xv6-public/blob/master/trap.c">trap.c</a>, we saw that<br>the <code>trap()</code> function directs all disk interrupts to the handler function<br><code>ideintr()</code>. It’s time to check that one out now.</p>
<p>We’ll start by acquiring the disk’s spin-lock; note that we don’t use a sleep-<br>lock because this is an interrupt handler function, so interrupts should be<br>disabled while it runs.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;idelock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we got an interrupt, then it usually means the disk is done with the most<br>recent request. Those requests are stored in the global <code>idequeue</code> linked list,<br>with the current request at the front of the queue. So we’ll get the head of the<br>queue as <code>b</code>, then set <code>idequeue</code> to point to the next buffer in the queue. If<br>the head is null, then we’ll just return early.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((b = idequeue) == <span class="number">0</span>) &#123;</span><br><span class="line">        release(&amp;idelock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idequeue = b-&gt;next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The read command in <code>idestart()</code> didn’t specify where to read the data to, so we<br>do that now. We’ll check if the <code>B_DIRTY</code> flag was set; if it wasn’t (i.e. the<br>operation was a disk read), then we’ll wait for the disk to be ready (without<br>any errors, using <code>idewait(1)</code> instead of <code>idewait(0)</code> as we have before) and<br>read the data into <code>b-&gt;data</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(b-&gt;flags &amp; B_DIRTY) &amp;&amp; idewait(<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        insl(<span class="number">0x1f0</span>, b-&gt;data, BSIZE / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we set the <code>B_VALID</code> flag with a bitwise-OR and clear any <code>B_DIRTY</code> flag<br>with a bitwise-AND and a bitwise-NOT. Then we’ll wake up any user process that<br>went to sleep on a channel for this buffer after requesting a disk I&#x2F;O operation.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b-&gt;flags |= B_VALID;</span><br><span class="line">    b-&gt;flags &amp;= ~B_DIRTY;</span><br><span class="line">    wakeup(b);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll get the disk started on the next operation, for the next buffer<br>in the queue.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (idequeue != <span class="number">0</span>) &#123;</span><br><span class="line">        idestart(idequeue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iderw"><a href="#iderw" class="headerlink" title="iderw"></a>iderw</h3><p>The <code>idestart()</code> function is <code>static</code>, so it can’t be called by anything outside<br>of this file; we need to provide a mechanism for both kernel and user threads to<br>read and write disk data. That’s what <code>iderw()</code> does. Note that processes should<br>never call this function directly; it only gets called by the code for the<br>buffer cache layer of the file system. In other words, processes will use system<br>calls like <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>, etc., which in turn will<br>use functions from higher layers of abstraction, which in turn call functions<br>from lower layers, and so on, until they reach the buffer cache, which calls<br><code>iderw()</code> to finally read&#x2F;write directly from&#x2F;to the disk.</p>
<p>By the time a process gets to <code>iderw()</code>, it should already be holding a sleep-<br>lock <code>b-&gt;lock</code> for the buffer <code>b</code> it wants to read or write, and either the<br><code>B_DIRTY</code> flag should be set (to write to disk) or the <code>B_VALID</code> flag should be<br>absent (to read from disk). We’ll start off with some sanity checks for those,<br>and make sure that we’re not trying to read from disk 1 if it’s not present on<br>this machine. Then we’ll acquire the disk’s spin-lock.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;iderw: buf not locked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((b-&gt;flags &amp; (B_VALID | B_DIRTY)) == B_VALID) &#123;</span><br><span class="line">        <span class="comment">// B_VALID is set, so we don&#x27;t need to read it; B_DIRTY is not set, so</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to write it</span></span><br><span class="line">        panic(<span class="string">&quot;iderw: nothing to do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev != <span class="number">0</span> &amp;&amp; !havedisk1) &#123;</span><br><span class="line">        panic(<span class="string">&quot;iderw: ide disk 1 not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;idelock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There may be other buffers waiting in line in the disk queue, so we have to<br>append this buffer <code>b</code> to the end of <code>idequeue</code>. We can do that by setting<br><code>b-&gt;qnext</code> to null, then creating a variable <code>pp</code> to traverse the entire queue.<br>When <code>pp</code> points to the last element, we’ll set its <code>qnext</code> field to point to<br><code>b</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b-&gt;qnext = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse the queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> **<span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (pp = &amp;idequeue; *pp; pp = &amp;(*pp)-&gt;qnext)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append b to end of queue</span></span><br><span class="line">    *pp = b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That traversal might look confusing as all hell, so let’s take a closer look.<br>It defines <code>pp</code> as a double pointer: a pointer to a pointer to a <code>struct buf</code>.<br>(If you’ve seen the interview of Linus Torvalds where he talks about good style<br>with linked lists, it’s similar to the code there; there’s a nice summary<br><a href="https://github.com/mkirchner/linked-list-good-taste">here</a>.) <code>pp</code> starts off<br>equal pointing to <code>idequeue</code>, i.e. the head of the linked list. Each iteration<br>checks that <code>pp</code> points to a valid (non-null) pointer, i.e. the loop will end<br>when we reach the end of the list. The body of the loop is empty, so none of the<br>iterations actually do anything; the purpose of the for loop is just to update<br><code>pp</code> several times. At the end of each iteration, <code>pp</code> is updated to point to a<br>pointer to the next buffer in the queue.</p>
<p>Suppose the last buffer in the queue is <code>end</code>. At the end of the for loop, <code>pp</code><br>will hold the address of <code>end-&gt;qnext</code>, so <code>*pp = b</code> sets <code>end-&gt;qnext = b</code>. The<br>double indirection makes it easy to update the last buffer in the queue; without<br>it, we would have to stop the loop one step earlier when <code>pp</code> points to <code>end</code><br>instead of <code>end-&gt;qnext</code> then be careful to update the actual buffer at the end<br>of the queue instead of just updating the local variable <code>pp</code>. All in all, it’s<br>just an elegant way to write a linked list traversal in a single line.</p>
<p>Okay, so now our buffer <code>b</code> is at the end of the queue. If there are others in<br>front of it, then <code>ideintr()</code> will make sure that each disk interrupt starts the<br>disk on the next operation. But what if <code>b</code> is actually the only buffer in the<br>queue? In that case, the disk isn’t running yet, so we need to get it started<br>ourselves.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (idequeue == b) &#123;</span><br><span class="line">        idestart(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At this point, we can be confident that the disk will either start our request<br>now or get to it eventually (if there are other requests in the queue). This<br>process just has to wait for the disk to finish, so we’ll put it to sleep until<br>the buffer has been synchronized with the disk. We’ll check that by making sure<br>the <code>B_VALID</code> flag is present but <code>B_DIRTY</code> is not set. The call to <code>sleep()</code><br>will release <code>idelock</code> and reacquire it before returning.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> ((b-&gt;flags &amp; (B_VALID | B_DIRTY)) != B_VALID) &#123;</span><br><span class="line">        sleep(b, &amp;idelock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-12"><a href="#Summary-12" class="headerlink" title="Summary"></a>Summary</h2><p>The disk driver handles direct communication with the hard drive, issuing orders<br>to read or write sectors. It exposes two API functions, <code>ideintr()</code> and<br><code>iderw()</code>. The former is called by <code>trap()</code> to handle disk interrupts, while the<br>latter is called by the code for the buffer cache layer of the file system to<br>update blocks in the buffer cache with their corresponding sectors on disk. Next<br>up we’ll look at the buffer cache itself, as well as the logging layer, which<br>provides crash recovery.</p>
]]></content>
      <categories>
        <category>开源学习</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>电量计--77561(77226)的Firmware Architecture</title>
    <url>/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--77561(77226)%E7%9A%84Firmware%20Architecture/</url>
    <content><![CDATA[<h1 id="电量计–77561-77226-的Firmware-Architecture"><a href="#电量计–77561-77226-的Firmware-Architecture" class="headerlink" title="电量计–77561(77226)的Firmware Architecture"></a>电量计–77561(77226)的Firmware Architecture</h1><h1 id="Part1-总体结构概述"><a href="#Part1-总体结构概述" class="headerlink" title="Part1 总体结构概述"></a>Part1 总体结构概述</h1><h2 id="Keil-MDK项目结构"><a href="#Keil-MDK项目结构" class="headerlink" title="Keil MDK项目结构"></a>Keil MDK项目结构</h2><p>项目基于ARM Cortex-M0 MCU，使用Keil MDK开发环境构建。核心代码分为底层驱动、算法库和应用三层结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- newton.uvprojx           # Keil项目主文件</span><br><span class="line">- newton.sct               # 链接脚本</span><br><span class="line">- Device/                  # ARM M0 MCU设备相关文件</span><br><span class="line">- RTE/                     # 运行时环境配置</span><br><span class="line">- lib/                     # 核心算法库文件</span><br><span class="line">  - lib_fg.c/h             # 电量计核心算法库(Fuel Gauge)</span><br><span class="line">  - lib_pg.c/h             # 电池包电量计算法库(Pack Gauge)</span><br><span class="line">- user/                    # 用户应用代码</span><br><span class="line">  - main.c                 # 主程序入口</span><br><span class="line">  - parameter.c/h          # 参数配置</span><br><span class="line">  - sbsd.c/h               # SBS通信协议实现</span><br><span class="line">  - filter.c/h             # 数据滤波处理</span><br><span class="line">  - db_print.c/h           # 调试打印功能</span><br><span class="line">- flash/                   # Flash操作相关</span><br><span class="line">- chip/                    # 芯片驱动层</span><br><span class="line">- table/                   # 查找表数据</span><br><span class="line">- o2bootloader/            # 引导加载程序</span><br></pre></td></tr></table></figure>

<h2 id="启动和运行主流程"><a href="#启动和运行主流程" class="headerlink" title="启动和运行主流程"></a>启动和运行主流程</h2><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><ol>
<li><p>上电后从o2bootloader引导区启动</p>
</li>
<li><p>初始化MCU系统时钟和基本外设</p>
</li>
<li><p>初始化电量计参数和查找表</p>
</li>
<li><p>调用fg_init函数初始化电量计算法库</p>
</li>
<li><p>进入主循环</p>
</li>
</ol>
<h3 id="主循环流程"><a href="#主循环流程" class="headerlink" title="主循环流程"></a>主循环流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[上电] → [初始化] → [主循环&#123;</span><br><span class="line">  读取电池数据(电压/电流/温度)</span><br><span class="line">  处理电量计算法</span><br><span class="line">  更新SOC和其他电池状态</span><br><span class="line">  处理SBS通信请求</span><br><span class="line">  进入低功耗状态</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>主程序采用状态机设计，根据不同的电池状态(充电&#x2F;放电&#x2F;空闲)调用不同的处理函数。</p>
<h3 id="模块关系和流程图"><a href="#模块关系和流程图" class="headerlink" title="模块关系和流程图"></a>模块关系和流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[硬件层]</span><br><span class="line">  │</span><br><span class="line">  ├── MCU外设(ADC/I2C/Flash) </span><br><span class="line">  │       │</span><br><span class="line">  │       ▼</span><br><span class="line">  ├── 驱动层(chip/) </span><br><span class="line">  │       │</span><br><span class="line">  │       ▼</span><br><span class="line">[软件层]</span><br><span class="line">  │       </span><br><span class="line">  ├── 电量计算法核心(lib_fg) ◄────┐</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── 电池包管理(lib_pg)          │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── 应用层(user/main)           │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── SBS通信层(sbsd)             │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">[数据层]                          │</span><br><span class="line">  │                               │</span><br><span class="line">  └── 查找表(table/) ─────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取原始数据(电压/电流/温度) </span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">数据过滤(filter.c) </span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">状态判断(充电/放电/空闲)</span><br><span class="line">       │</span><br><span class="line">       ┌───────────┬────────────┐</span><br><span class="line">       ▼           ▼            ▼</span><br><span class="line">   充电状态     放电状态      空闲状态</span><br><span class="line">   处理函数     处理函数      处理函数</span><br><span class="line">       │           │            │</span><br><span class="line">       └───────────┼────────────┘</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">         SOC计算(库伦积分+OCV校正)</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">            电量计状态更新</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">              SBS数据更新</span><br></pre></td></tr></table></figure>

<h2 id="I2C-SBS通信命令"><a href="#I2C-SBS通信命令" class="headerlink" title="I2C SBS通信命令"></a>I2C SBS通信命令</h2><p>SBS（Smart Battery System）通信是电量计与主机通信的标准协议。该项目中在sbsd.c&#x2F;h文件实现了SBS标准通信命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 命令码 | 命令名称 | 描述 |</span><br><span class="line">|-------|---------|------|</span><br><span class="line">| 0x00 | ManufacturerAccess | 制造商访问 |</span><br><span class="line">| 0x01 | RemainingCapacityAlarm | 剩余容量警报 |</span><br><span class="line">| 0x02 | RemainingTimeAlarm | 剩余时间警报 |</span><br><span class="line">| 0x03 | BatteryMode | 电池模式 |</span><br><span class="line">| 0x04 | Temperature | 温度 |</span><br><span class="line">| 0x05 | Voltage | 电压 |</span><br><span class="line">| 0x06 | Current | 电流 |</span><br><span class="line">| 0x07 | AverageCurrent | 平均电流 |</span><br><span class="line">| 0x08 | MaxError | 最大误差 |</span><br><span class="line">| 0x09 | RelativeStateOfCharge | 相对电量百分比 |</span><br><span class="line">| 0x0A | AbsoluteStateOfCharge | 绝对电量百分比 |</span><br><span class="line">| 0x0B | RemainingCapacity | 剩余容量 |</span><br><span class="line">| 0x0C | FullChargeCapacity | 满充容量 |</span><br><span class="line">| 0x0D | RunTimeToEmpty | 运行剩余时间 |</span><br><span class="line">| 0x0E | AverageTimeToEmpty | 平均剩余时间 |</span><br><span class="line">| 0x0F | AverageTimeToFull | 平均充满时间 |</span><br><span class="line">| 0x10 | ChargingCurrent | 充电电流 |</span><br><span class="line">| 0x11 | ChargingVoltage | 充电电压 |</span><br><span class="line">| 0x12 | BatteryStatus | 电池状态 |</span><br><span class="line">| 0x13 | CycleCount | 循环次数 |</span><br><span class="line">| 0x14 | DesignCapacity | 设计容量 |</span><br><span class="line">| 0x15 | DesignVoltage | 设计电压 |</span><br><span class="line">| 0x16 | SpecificationInfo | 规格信息 |</span><br><span class="line">| 0x17 | ManufactureDate | 生产日期 |</span><br><span class="line">| 0x18 | SerialNumber | 序列号 |</span><br><span class="line">| 0x19 | ManufacturerName | 制造商名称 |</span><br><span class="line">| 0x1A | DeviceName | 设备名称 |</span><br><span class="line">| 0x1B | DeviceChemistry | 电池化学成分 |</span><br><span class="line">| 0x1C | ManufacturerData | 制造商数据 |</span><br><span class="line">| 0x3C-0x3F | GGMEM0-GGMEM8 | 调试内存区域 |</span><br></pre></td></tr></table></figure>

<p>此外，项目还实现了一些扩展命令，用于调试和配置电量计算法参数。</p>
<h2 id="电量计算法fg-lib分析"><a href="#电量计算法fg-lib分析" class="headerlink" title="电量计算法fg_lib分析"></a>电量计算法fg_lib分析</h2><h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">typedef *struct* &#123;</span><br><span class="line">  // 电量计状态</span><br><span class="line">  *int* status;         // 电量计状态标志位</span><br><span class="line">  // 容量相关</span><br><span class="line">  *int* fcc;          // 满充容量(Full Charge Capacity)</span><br><span class="line">  *int* facc;          // 满充绝对容量(Full Absolute Charge Capacity)</span><br><span class="line">  *int* rca;          // 剩余容量(Remaining Capacity)</span><br><span class="line">  *int* chgcap;         // 充电容量</span><br><span class="line"></span><br><span class="line">  // SOC相关</span><br><span class="line">  *int* soc;          // 当前SOC百分比(0-10000，对应0-100%)</span><br><span class="line">  *int* soc_raw;        // 原始SOC</span><br><span class="line">  *int* soc_now;        // 实时SOC</span><br><span class="line">  *int* rsoc_now;        // 相对SOC</span><br><span class="line"></span><br><span class="line">  // 电池参数</span><br><span class="line">  *int* cell_temp;       // 电池温度</span><br><span class="line">  *int* cell_volt;       // 电池电压</span><br><span class="line">  *int* cell_curr;       // 电池电流</span><br><span class="line"></span><br><span class="line">  // 算法参数</span><br><span class="line">  *int* parm_eocmv;       // 充电截止电压</span><br><span class="line">  *int* parm_eocma;       // 充电截止电流</span><br><span class="line">  *int* parm_eodmv;       // 放电截止电压</span><br><span class="line"></span><br><span class="line">  // 时间记录</span><br><span class="line">  *unsigned* *int* chgtime;    // 充电时间</span><br><span class="line">  *unsigned* *int* dsgtime;    // 放电时间</span><br><span class="line">  *unsigned* *int* idletime;   // 空闲时间</span><br><span class="line"></span><br><span class="line">  // 表格数据</span><br><span class="line">  FG_LUT_T fg_tbls;      // 查找表结构</span><br><span class="line"></span><br><span class="line">  // 滤波相关</span><br><span class="line">  *int* cavgmov;        // 移动平均电流</span><br><span class="line">  *int* cavgcntr[4];      // 电流滤波器</span><br><span class="line">&#125; LIB_FG_TYPE_T;</span><br></pre></td></tr></table></figure>



<h3 id="算法核心模块"><a href="#算法核心模块" class="headerlink" title="算法核心模块"></a>算法核心模块</h3><h4 id="电量计状态机"><a href="#电量计状态机" class="headerlink" title="电量计状态机"></a>电量计状态机</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">电量计使用状态机管理不同的工作状态：</span><br><span class="line">\#define FG_STAT_INIT    0x00000001 // 初始化状态</span><br><span class="line">\#define FG_STAT_CHG     0x00000002 // 充电状态</span><br><span class="line">\#define FG_STAT_DSG     0x00000004 // 放电状态</span><br><span class="line">\#define FG_STAT_IDLE    0x00000008 // 空闲状态</span><br><span class="line">\#define FG_STAT_CHG_CC   0x00000010 // 恒流充电</span><br><span class="line">\#define FG_STAT_CHG_CV   0x00000020 // 恒压充电</span><br><span class="line">\#define FG_STAT_CHG_EOC   0x00000040 // 充电截止</span><br><span class="line">\#define FG_STAT_DSG_EOD   0x00000080 // 放电截止</span><br><span class="line">\#define FG_STAT_DSG_FST1  0x00000100 // 快速放电1</span><br><span class="line">\#define FG_STAT_DSG_FST2  0x00000200 // 快速放电2</span><br><span class="line">\#define FG_STAT_DSG_LT   0x00000400 // 低温放电</span><br></pre></td></tr></table></figure>



<h4 id="SOC计算核心"><a href="#SOC计算核心" class="headerlink" title="SOC计算核心"></a>SOC计算核心</h4><p>SOC (State of Charge) 计算采用混合算法：</p>
<ol>
<li><p>库伦积分法</p>
<p>：根据电流积分计算电量变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 电流积分计算</span><br><span class="line">  delta_capacity = (current * delta_time) / 3600; // 单位：mAh</span><br><span class="line">  rca = rca - delta_capacity; // 更新剩余容量</span><br><span class="line">  soc = (rca * 10000) / fcc;  // 计算SOC(0-10000)</span><br></pre></td></tr></table></figure>


</li>
<li><p>OCV校准</p>
<p>：通过电压查表获取SOC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 通过OCV查表获取SOC</span><br><span class="line">  FG_ERROR_T fg_get_soc_by_ocv(FG_HANDLE_T **handle*, *short* *ocv_mv*, *short* **soc*)</span><br><span class="line">  &#123;</span><br><span class="line">​    // 通过一维表查找获取SOC</span><br><span class="line">​    return lut_one_axis_r(handle, &amp;(((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.ocv_tbl), ocv_mv, soc);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>混合算法</p>
<p>：结合库伦积分和OCV校准</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 空闲状态下的OCV校准</span><br><span class="line">  if (idle_time &gt; OCV_RELAX_TIME) &#123;</span><br><span class="line">​    // 获取OCV对应的SOC</span><br><span class="line">​    fg_get_soc_by_ocv(handle, ocv, &amp;ocv_soc);</span><br><span class="line"></span><br><span class="line">​    // 计算偏差</span><br><span class="line">​    delta = ocv_soc - current_soc;</span><br><span class="line"></span><br><span class="line">​    // 如果偏差超过阈值，进行校准</span><br><span class="line">​    if (abs(delta) &gt; OCV_DELTA_THRESHOLD) &#123;</span><br><span class="line">​      // 使用滤波平滑过渡</span><br><span class="line">​      current_soc = current_soc + (delta * OCV_FILTER_FACTOR) / 100;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="温度补偿"><a href="#温度补偿" class="headerlink" title="温度补偿"></a>温度补偿</h4><p>温度对电池容量和电压有显著影响，算法中实现了温度补偿：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 温度补偿</span><br><span class="line">FG_ERROR_T fg_get_temp_factor(FG_HANDLE_T **handle*, *short* *temp*, *short* **factor*)</span><br><span class="line">&#123;</span><br><span class="line">  // 查表获取温度补偿系数</span><br><span class="line">  return lut_one_axis_f(handle, &amp;(((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.temp_factor_tbl), temp, factor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 应用温度补偿</span><br><span class="line">fcc_temp = (fcc * temp_factor) / 1000; // 温度修正后的满充容量</span><br></pre></td></tr></table></figure>



<h4 id="老化补偿"><a href="#老化补偿" class="headerlink" title="老化补偿"></a>老化补偿</h4><p>电池循环次数增加会导致容量衰减，算法实现了老化补偿：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 老化因子计算</span><br><span class="line">*int* fg_check_agefactor(FG_HANDLE_T **handle*)</span><br><span class="line">&#123;</span><br><span class="line">  *int* temp = fg_idiv_rounddown(handle, ((LIB_FG_TYPE_T *)handle)-&gt;chgcap, ((LIB_FG_TYPE_T *)handle)-&gt;facc);</span><br><span class="line">  temp *= FG_AGING_RATIO_MIN; // 最小损耗 * 循环次数</span><br><span class="line">  temp = (10000 - temp) / 100;</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 应用老化补偿</span><br><span class="line">fcc_aged = (fcc * (10000 - aging_factor)) / 10000; // 老化修正后的满充容量</span><br></pre></td></tr></table></figure>



<h4 id="快速放电处理"><a href="#快速放电处理" class="headerlink" title="快速放电处理"></a>快速放电处理</h4><p>在大电流放电或低电压情况下，电池容量会急剧下降，算法实现了快速放电处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static *int* fg_fast_dsg(FG_HANDLE_T **handle*, FG_PARAM_T **param*)</span><br><span class="line">&#123;</span><br><span class="line">  // 根据不同电压档位加速SOC下降速率</span><br><span class="line">  if (param-&gt;volt_lo_mv &lt; (((LIB_FG_TYPE_T *)handle)-&gt;parm_eodmv - ((LIB_FG_TYPE_T *)handle)-&gt;parm_ddv - 200)) &#123;</span><br><span class="line">​    // 每秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 100);</span><br><span class="line">  &#125; else if (param-&gt;volt_lo_mv &lt; (((LIB_FG_TYPE_T *)handle)-&gt;parm_eodmv - ((LIB_FG_TYPE_T *)handle)-&gt;parm_ddv - 100)) &#123;</span><br><span class="line">​    // 每5秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 500);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">​    // 每10秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新状态</span><br><span class="line">  ((LIB_FG_TYPE_T *)handle)-&gt;status |= FG_STAT_DSG_FST1;</span><br><span class="line">  return ERR_FG_NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="查表算法"><a href="#查表算法" class="headerlink" title="查表算法"></a>查表算法</h4><p>算法使用多种查表算法进行插值计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一维表正向查找</span><br><span class="line">static *int* lut_one_axis_f(FG_HANDLE_T **handle*, *tbl_one_t* **table*, *short* *input*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 通过输入值在表中查找并插值计算输出值</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一维表反向查找</span><br><span class="line">static *int* lut_one_axis_r(FG_HANDLE_T **handle*, *tbl_one_t* **table*, *short* *value*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 通过目标值反向查找输入值</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 三维表查找</span><br><span class="line">static *int* lut_three_axis(FG_HANDLE_T **handle*, *tbl_three_t* **table*, *short* *x_value*, *short* *y_value*, *short* *z_value*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 三维插值计算</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法流程概述"><a href="#算法流程概述" class="headerlink" title="算法流程概述"></a>算法流程概述</h3><h4 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h4><p>fg_init() → 初始化电量计参数和状态 → 加载查找表 → OCV初始化SOC</p>
<h4 id="充电处理流程"><a href="#充电处理流程" class="headerlink" title="充电处理流程"></a>充电处理流程</h4><p>检测充电状态 → 更新充电时间 → 库伦积分计算SOC → 判断CC&#x2F;CV模式 → 检查充电截止条件 → 更新SOC</p>
<h4 id="放电处理流程"><a href="#放电处理流程" class="headerlink" title="放电处理流程"></a>放电处理流程</h4><p>检测放电状态 → 更新放电时间 → 库伦积分计算SOC → 温度补偿 → 低电压检测 → 快速放电处理 → 更新SOC</p>
<h4 id="空闲处理流程"><a href="#空闲处理流程" class="headerlink" title="空闲处理流程"></a>空闲处理流程</h4><p>检测空闲状态 → 更新空闲时间 → 检查OCV稳定时间 → OCV校准SOC → 更新SOC</p>
<h2 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h2><p>该电量计实现了以下低功耗策略：</p>
<ol>
<li><p>工作周期设计：系统大部分时间处于深度睡眠状态，定时唤醒采集数据和处理</p>
</li>
<li><p>外设优化：只在需要时启用ADC、I2C等外设</p>
</li>
<li><p>代码执行效率：优化算法减少指令执行次数</p>
</li>
<li><p>数据存储优化：使用查找表减少计算量</p>
</li>
</ol>
<h2 id="调试和校准工具"><a href="#调试和校准工具" class="headerlink" title="调试和校准工具"></a>调试和校准工具</h2><p>根据Cobra工具文档，系统支持以下调试和校准功能：</p>
<ol>
<li>电流校准：通过Cobra工具校准0电流、正向电流和负向电流</li>
<li>数据采集：通过SBS协议读取电量计内部状态</li>
<li>内存调试：通过GGMEM0-GGMEM8访问电量计内部RAM</li>
<li>参数配置：通过Cobra工具配置电量计算法参数</li>
</ol>
<h1 id="Part2-Firmware主要功能模块分析"><a href="#Part2-Firmware主要功能模块分析" class="headerlink" title="Part2 Firmware主要功能模块分析"></a>Part2 Firmware主要功能模块分析</h1><h2 id="通信接口（SBS命令流程）"><a href="#通信接口（SBS命令流程）" class="headerlink" title="通信接口（SBS命令流程）"></a>通信接口（SBS命令流程）</h2><p>以SBS命令0x0D(RSOC - 相对电量)为例，详细介绍整个处理流程，包含main.c、sbs.c和i2c.c三个文件在这个流程中的角色和作用</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>（1）main.c中的初始化：</p>
<p>在main.c中：</p>
<ol>
<li>调用i2cif_init初始化I2C接口，设置从机地址和回调函数sbs_callback_i2c_slave</li>
<li>调用sbsif_init初始化SBS接口</li>
<li>调用gg_lib_init初始化电量计算库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* main(*void*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // ...系统初始化</span><br><span class="line"></span><br><span class="line">  // 初始化I2C接口，设置从机地址和回调函数</span><br><span class="line">  i2cif_init(param_board_cfg[PARM_BCFG_I2CADDR], tx_buff, sbs_callback_i2c_slave);</span><br><span class="line"></span><br><span class="line">  // 初始化SBS接口</span><br><span class="line">  sbsif_init(param_board_cfg[PARM_BCFG_I2CADDR]);</span><br><span class="line"></span><br><span class="line">  // 初始化电量计模块</span><br><span class="line">  gg_lib_init();</span><br><span class="line"></span><br><span class="line">  // ...其他初始化</span><br><span class="line"></span><br><span class="line">  // 进入主循环</span><br><span class="line">  main_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）sbs.c中的初始化</p>
<ol>
<li>初始化SBS接口数据结构</li>
<li>初始化SBS数据缓冲区，包括SBS0D_RSOC（相对电量）的初始值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* sbsif_init(*uint32_t* *slv_addr*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  psbsifHandle = (SBS_HANDLE_T *)sbs_mem;</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_slv_addr = slv_addr;</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff = sbs_data_buff;</span><br><span class="line"></span><br><span class="line">  // ...初始化各种SBS数据</span><br><span class="line"></span><br><span class="line">  // 初始相对电量为0</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）i2c.c中的初始化</p>
<ol>
<li><p>初始化I2C接口数据结构</p>
</li>
<li><p>配置I2C硬件参数</p>
</li>
<li><p>设置回调函数，该函数将在I2C通信事件发生时被调用</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* i2cif_init(*uint32_t* *slv_addr*, *uint8_t* **t_buff*, i2c_callback *p_callback*)</span><br><span class="line">&#123;</span><br><span class="line">  i2cif_p = (I2CIF_T *)(i2c_mem);</span><br><span class="line">  i2cif_p-&gt;pI2C_Base = I2C;      // I2C模块基地址</span><br><span class="line">  i2cif_p-&gt;slv_addr = slv_addr;    // 从机地址</span><br><span class="line">  i2cif_p-&gt;tx_buffer = t_buff;     // 发送缓冲区</span><br><span class="line">  i2cif_p-&gt;i2c_callback_f = p_callback; // 回调函数</span><br><span class="line"></span><br><span class="line">  // ...配置I2C硬件</span><br><span class="line"></span><br><span class="line">  // 启用中断</span><br><span class="line">  Chip_I2C_EnableInts(i2cif_p-&gt;pI2C_Base, (...));</span><br><span class="line">  Chip_I2C_Enable(i2cif_p-&gt;pI2C_Base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="电量数据更新阶段"><a href="#电量数据更新阶段" class="headerlink" title="电量数据更新阶段"></a>电量数据更新阶段</h3><p>（1）main.c中的电量数据更新：</p>
<p>主循环调用gg_step计算最新的电量数据<br>调用gg_sync_result将电量计算结果同步到SBS数据<br>调用sbsif_update和sbsif_update_time更新SBS数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* main_loop()</span><br><span class="line">&#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">​    // ...其他循环处理</span><br><span class="line">​    // 更新电量计算</span><br><span class="line">​    gg_step(passSec);</span><br><span class="line">​    // 同步电量计结果到SBS</span><br><span class="line">​    gg_sync_result();</span><br><span class="line">​    // 更新SBS数据</span><br><span class="line">​    sbsif_update(1);</span><br><span class="line">​    sbsif_update_time();</span><br><span class="line">​    // ...其他处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static *void* gg_sync_result(*void*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // 将电量计计算结果同步到SBS数据</span><br><span class="line">  sbsif_set_data(SBS0D_RSOC, gg_result.rsoc);</span><br><span class="line">  // ...更新其他SBS数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）sbs.c中的电量数据更新</p>
<p>sbsif_set_data函数允许外部模块（如电量计）直接设置SBS数据<br>sbsif_update函数基于库仑计数据和满充容量计算相对电量<br>将计算结果存储在SBS0D_RSOC（相对电量）中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sbsif_update(uint8_t updata_cc)</span><br><span class="line">&#123;</span><br><span class="line">    // ...更新其他数据</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 更新相对电量</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS5F_CCACCMAH];</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= 100;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val /= ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS10_FCC];</span><br><span class="line">    temp1 = ((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line">    if (temp1 &gt; 100)</span><br><span class="line">        temp1 = 100;</span><br><span class="line">    </span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC] = temp1;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sbsif_set_data(SBS_DATA_T index, int32_t ivalue)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; SBSD_CMD_MAX) &#123;</span><br><span class="line">        sbs_data_buff[index] = ivalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I2C通信阶段-处理SBS-0x0D命令"><a href="#I2C通信阶段-处理SBS-0x0D命令" class="headerlink" title="I2C通信阶段 - 处理SBS 0x0D命令"></a>I2C通信阶段 - 处理SBS 0x0D命令</h3><p>当上位机发送SBS命令0x0D（读取相对电量）时：</p>
<p>（1）i2c.c中的命令接收</p>
<p>首先接收SBS命令字节(0x0D)并识别它<br>当上位机发送读请求时，调用回调函数准备要发送的数据<br>当I2C发送缓冲区需要数据时，发送预先准备好的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">I2C_STATUS_T i2cif_slave_handle(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 地址匹配检测</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_ADDR) &#123;</span><br><span class="line">        // 检查I2C方向（读/写）</span><br><span class="line">        if (i2cif_p-&gt;intstat &amp; I2C_ISR1_SLV_ADDR_DIR) &#123;</span><br><span class="line">            // 读操作 - 准备发送数据</span><br><span class="line">            i2cif_p-&gt;i2c_state = I2C_XFER_SLVSND;</span><br><span class="line">            // ...</span><br><span class="line">            i2cif_p-&gt;i2c_status = I2C_STATUS_TXDATA;</span><br><span class="line">            if (i2cif_p-&gt;i2c_callback_f) &#123;</span><br><span class="line">                i2cif_p-&gt;i2c_callback_f(i2cif_p-&gt;i2c_status, i2cif_p-&gt;sbd_idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 写操作 - 准备接收命令</span><br><span class="line">            i2cif_p-&gt;i2c_state = I2C_XFER_SLVRCV;</span><br><span class="line">            i2cif_p-&gt;rx_idx = 0;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 接收数据</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_RXNE) &#123;</span><br><span class="line">        i2cif_p-&gt;data = Chip_I2C_ReadRXData(i2cif_p-&gt;pI2C_Base);</span><br><span class="line">        </span><br><span class="line">        // 第一个字节是SBS命令</span><br><span class="line">        if (i2cif_p-&gt;rx_idx == 0) &#123;</span><br><span class="line">            i2cif_p-&gt;i2c_cmd = (uint8_t)i2cif_p-&gt;data; // 0x0D</span><br><span class="line">            </span><br><span class="line">            // 查找命令定义</span><br><span class="line">            do &#123;</span><br><span class="line">                if (((sbsd_cmd_def[i2cif_p-&gt;sbd_idx] &amp; SBSD_CMD_Msk) &gt;&gt; SBSD_CMD_Pos) == i2cif_p-&gt;i2c_cmd) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; while ((i2cif_p-&gt;sbd_idx++) &lt; SBSD_CMD_MAX);</span><br><span class="line">            </span><br><span class="line">            // ...处理命令</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 发送数据</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_TXIS &amp;&amp; i2cif_p-&gt;i2c_state == I2C_XFER_SLVSND) &#123;</span><br><span class="line">        if (i2cif_p-&gt;tx_idx &lt; i2cif_p-&gt;tx_size) &#123;</span><br><span class="line">            if (i2cif_p-&gt;tx_buffer) &#123;</span><br><span class="line">                i2cif_p-&gt;data = *i2cif_p-&gt;tx_buffer;</span><br><span class="line">                i2cif_p-&gt;tx_buffer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // ...</span><br><span class="line">        </span><br><span class="line">        i2cif_p-&gt;tx_idx++;</span><br><span class="line">        Chip_I2C_WriteTXData(i2cif_p-&gt;pI2C_Base, i2cif_p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）main.c中的I2C回调处理</p>
<p>回调函数sbs_callback_i2c_slave处理I2C事件<br>当接收到状态I2C_STATUS_TXDATA时，准备发送数据<br>对于命令SBS0D_RSOC，调用sbsif_get_data获取当前相对电量<br>将数据填充到发送缓冲区<br>调用i2cif_set_tx通知I2C模块准备发送这些数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void sbs_callback_i2c_slave(uint32_t status, uint32_t n)</span><br><span class="line">&#123;</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case I2C_STATUS_TXDATA:</span><br><span class="line">            // 准备发送数据</span><br><span class="line">            switch (n) &#123;</span><br><span class="line">                case SBS0D_RSOC:</span><br><span class="line">                    // 准备发送相对电量数据</span><br><span class="line">                    value = sbsif_get_data(SBS0D_RSOC);</span><br><span class="line">                    </span><br><span class="line">                    // 设置发送缓冲区</span><br><span class="line">                    *tx_ptr++ = (uint8_t)value;</span><br><span class="line">                    *tx_ptr++ = (uint8_t)(value &gt;&gt; 8);</span><br><span class="line">                    </span><br><span class="line">                    // 设置要发送的数据大小</span><br><span class="line">                    i2cif_set_tx(tx_cnt, tx_buff);</span><br><span class="line">                    break;</span><br><span class="line">                </span><br><span class="line">                // ...处理其他SBS命令</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">        // ...处理其他I2C状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）sbs.c中的数据获取</p>
<p>sbsif_get_data函数返回指定SBS命令的当前值<br>对于SBS0D_RSOC，返回当前存储的相对电量值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int32_t sbsif_get_data(SBS_DATA_T index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;= SBSD_CMD_MAX)</span><br><span class="line">        return sbs_data_buff[SBS03_BATTMODE];</span><br><span class="line">    else</span><br><span class="line">        return sbs_data_buff[index]; // 返回SBS0D_RSOC的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整流程图解"><a href="#完整流程图解" class="headerlink" title="完整流程图解"></a>完整流程图解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【初始化阶段】</span><br><span class="line">main.c:main() </span><br><span class="line">    ↓</span><br><span class="line">    ├── i2c.c:i2cif_init() → 初始化I2C接口</span><br><span class="line">    ├── sbs.c:sbsif_init() → 初始化SBS数据接口</span><br><span class="line">    └── main.c:gg_lib_init() → 初始化电量计算库</span><br><span class="line"></span><br><span class="line">【电量数据更新阶段 - 周期性执行】</span><br><span class="line">main.c:main_loop()</span><br><span class="line">    ↓</span><br><span class="line">    ├── main.c:gg_step() → 电量计算</span><br><span class="line">    ├── main.c:gg_sync_result() → 同步电量计结果</span><br><span class="line">    │   └── sbs.c:sbsif_set_data(SBS0D_RSOC, ...) → 更新SBS数据</span><br><span class="line">    ├── sbs.c:sbsif_update() → 更新SBS接口数据</span><br><span class="line">    └── sbs.c:sbsif_update_time() → 更新时间预测数据</span><br><span class="line"></span><br><span class="line">【I2C通信阶段 - 上位机请求时】</span><br><span class="line">上位机发送SBS命令0x0D</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:I2C_IRQHandler() → I2C中断处理</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_slave_handle() → 识别命令0x0D</span><br><span class="line">    ↓</span><br><span class="line">main.c:sbs_callback_i2c_slave() → 处理I2C回调</span><br><span class="line">    ↓</span><br><span class="line">sbs.c:sbsif_get_data(SBS0D_RSOC) → 获取当前相对电量值</span><br><span class="line">    ↓</span><br><span class="line">main.c:sbs_callback_i2c_slave() → 准备发送数据</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_set_tx() → 设置发送缓冲区</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_slave_handle() → 通过I2C发送数据</span><br><span class="line">    ↓</span><br><span class="line">上位机接收相对电量数据</span><br></pre></td></tr></table></figure>

<h3 id="SBS命令的隐式支持"><a href="#SBS命令的隐式支持" class="headerlink" title="SBS命令的隐式支持"></a>SBS命令的隐式支持</h3><p>注意sbs_callback_i2c_slave中的default流程，可能隐藏支持一些SBS命令，例如SBS30_CV</p>
<p>每秒轮询更新eocmv之后，存储到sbs buffer的SBS30_CV：</p>
<pre><code>smart_charge_func:
	((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS30_CV] = eocmv;
	((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS34_EOC] = eocma;
</code></pre>
<p>((SBSIF_T *)psbsifHandle)-&gt;sbs_buff和sbs_data_buff指向同一个内存区域：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sbsif_init(uint32_t slv_addr)</span><br><span class="line">&#123;</span><br><span class="line">    psbsifHandle = (SBS_HANDLE_T *)sbs_mem;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_slv_addr = slv_addr;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff = sbs_data_buff;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host发SBS30命令查询时，进到sbs_callback_i2c_slave的I2C_STATUS_TXDATA default，拿到sbs_data_buff数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sbs_callback_i2c_slave:</span><br><span class="line"></span><br><span class="line">//命令返回数据大小</span><br><span class="line">size = ((sbsd_cmd_def[n] &amp; SBSD_LEN_Msk) &gt;&gt; SBSD_LEN_Pos);</span><br><span class="line"></span><br><span class="line">switch (n)&#123;</span><br><span class="line">... //显式定义的命令处理</span><br><span class="line">//隐式处理命令：只要定义过的命令数据写到了sbs_data_buff就能获取到</span><br><span class="line">default: </span><br><span class="line">	pBuff = (uint8_t*)(&amp;sbs_data_buff[n]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2cif_set_tx(size, pBuff);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>default隐式支持的命令必须在sbsd_cmd_def数组中注册，否则I2C接口无法识别。</p>
</li>
<li><p>注册的数据大小要和传入值一致（0x30的SBSD_LEN_Pos处定义数据是4byte）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const unsigned int sbsd_cmd_def[SBSD_CMD_MAX] = &#123;</span><br><span class="line">	(0x03UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RW &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),		//0x03000434UL, /* BattMode */</span><br><span class="line">	(0x09UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x09000415UL, /* Voltage */</span><br><span class="line">	(0x0AUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0A000415UL, /* Current */</span><br><span class="line">	(0x0BUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0B000415UL, /* AvgCurrent */</span><br><span class="line">	(0x0DUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0D000415UL, /* RSOC */</span><br><span class="line">	(0x0EUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0E000415UL, /* ASOC */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">(0x30UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),			/* CHGVOLT */</span><br><span class="line">(0x32UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),			/* CHGCURRENT */</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>FW参数有两个来源：</p>
<p>代码的默认配置；</p>
<p>Cobra写入到PRJ文件的Flash参数区域（GDM）</p>
<h3 id="代码默认配置参数"><a href="#代码默认配置参数" class="headerlink" title="代码默认配置参数"></a>代码默认配置参数</h3><h3 id="Cobra写入Flash参数"><a href="#Cobra写入Flash参数" class="headerlink" title="Cobra写入Flash参数"></a>Cobra写入Flash参数</h3><p>以param_board_cfg[PARM_BCFG_DESIGNCAPACITY]为例：</p>
<p>（1）定义：</p>
<p>param_board_cfg[PARM_BCFG_DESIGNCAPACITY] 是从 Flash 中读取的设计容量参数</p>
<p>在 parameter.h 中定义了参数的枚举类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">  // ...</span><br><span class="line">  PARM_BCFG_DESIGNCAPACITY, //=14</span><br><span class="line">  // ...</span><br><span class="line">  PARM_BCFG_MAX</span><br><span class="line">&#125; PARM_TYPE_BCFG_T;</span><br></pre></td></tr></table></figure>

<p>parameter.c 中定义了参数数组及其默认值（实际不是值，是Flash offset）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile signed int param_board_cfg[(PARM_BCFG_MAX)] = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  0x1388,                //0x0D48, PARM_BCFG_DESIGNCAPACITY, 5000mAh</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）参数加载过程：</p>
<p>在 gdm_init() 函数中，位于 flash&#x2F;gdm.c 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void gdm_init()</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    if (M32(GDM_FLASH_TABLECHECKSUM) != NEWTON_FLASH_EMPTY_DWORD)</span><br><span class="line">    &#123;</span><br><span class="line">        // copy Board configure from flash</span><br><span class="line">        ptrmemu32 = (uint32_t *)param_board_cfg;</span><br><span class="line">        for (i = 0; i &lt; PARM_BCFG_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flashoffset = GDM_FLASH_BOARD_CONF + i * 4;</span><br><span class="line">            *(ptrmemu32 + i) = M32(flashoffset);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...</span><br><span class="line">        gdm_load_sw_cali();</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码：<br>首先检查 Flash 中的校验和是否有效<br>如果有效，则从 Flash 地址 GDM_FLASH_BOARD_CONF 开始，按顺序读取所有配置参数<br>每个参数占用 4 字节，按照枚举顺序依次读取<br>将读取的值存储到 param_board_cfg 数组中</p>
<p>（3）参数使用</p>
<p>设计容量参数在多处被使用，例如在 user&#x2F;main.c 中初始化电量计算配置时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FG_CONFIG_T cfg;</span><br><span class="line">cfg.dsncap = (int32_t)(param_board_cfg[PARM_BCFG_DESIGNCAPACITY]);</span><br></pre></td></tr></table></figure>

<p>在 sbs.c 中初始化 SBS 接口时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS18_DSNCAP] = param_board_cfg[PARM_BCFG_DESIGNCAPACITY];</span><br></pre></td></tr></table></figure>



<h2 id="数据持久化（Flash-log日志）"><a href="#数据持久化（Flash-log日志）" class="headerlink" title="数据持久化（Flash log日志）"></a>数据持久化（Flash log日志）</h2><h3 id="log数据结构"><a href="#log数据结构" class="headerlink" title="log数据结构"></a>log数据结构</h3><p>log.c实现了电池管理系统的日志记录和数据持久化功能，主要包括：<br>历史数据记录：记录电池使用过程中的极值数据，如最高&#x2F;最低电压、最大充放电电流、最高&#x2F;最低温度等<br>参数持久化：存储电量计算所需的自学习参数，确保系统断电后能恢复重要数据<br>Flash管理：管理Flash存储空间，实现数据的读写和擦除功能<br>CRC校验：通过CRC校验确保持久化数据的完整性</p>
<p>日志模块使用LOG_T结构体存储数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint16_t checksum;        // CRC校验值</span><br><span class="line">    uint16_t logindex;        // 日志索引</span><br><span class="line">    uint32_t historiage;      // 历史容量老化累计</span><br><span class="line">    uint16_t rc;              // 当前剩余容量</span><br><span class="line">    uint8_t packinfo[64];     // 电池包信息</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 极值记录</span><br><span class="line">    uint16_t vmaxcell1;       // 最高单体电压</span><br><span class="line">    uint16_t vmincell1;       // 最低单体电压</span><br><span class="line">    uint16_t cmaxchg;         // 最大充电电流</span><br><span class="line">    int16_t cmaxdsg;          // 最大放电电流</span><br><span class="line">    uint16_t maxtempcell;     // 最高温度</span><br><span class="line">    uint8_t maxtempcnt;       // 高温事件计数</span><br><span class="line">    uint16_t mintempcell;     // 最低温度</span><br><span class="line">    </span><br><span class="line">    // 时间统计</span><br><span class="line">    uint16_t timefw;          // 固件运行时间</span><br><span class="line">    uint16_t timeUT;          // 极低温时间</span><br><span class="line">    uint16_t timeELT;         // 超低温时间</span><br><span class="line">    uint16_t timeLTL;         // 低温下限时间</span><br><span class="line">    uint16_t timeLT;          // 低温时间</span><br><span class="line">    uint16_t timeLTH;         // 低温上限时间</span><br><span class="line">    uint16_t timeSTL;         // 标准温度下限时间</span><br><span class="line">    uint16_t timeRT;          // 参考温度时间</span><br><span class="line">    uint16_t timeSTH;         // 标准温度上限时间</span><br><span class="line">    uint16_t timeHT;          // 高温时间</span><br><span class="line">    uint16_t timeOT;          // 过温时间</span><br><span class="line"></span><br><span class="line">&#125; LOG_T;</span><br></pre></td></tr></table></figure>

<h3 id="日志数据初始化和更新"><a href="#日志数据初始化和更新" class="headerlink" title="日志数据初始化和更新"></a>日志数据初始化和更新</h3><p>（1）初始化流程：初始化过程中，系统会从Flash中读取最新的日志记录，校验其完整性，并将数据同步到内存中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void log_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化Flash接口</span><br><span class="line">    eflash_init();</span><br><span class="line">    </span><br><span class="line">    // 查找最新的日志</span><br><span class="line">    ret = find_latest_log();</span><br><span class="line">    if (-1 == ret) &#123;</span><br><span class="line">        // 没有找到日志，初始化缓冲区</span><br><span class="line">        log_init_buff();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 读取日志数据</span><br><span class="line">        for (i = 0; i &lt; sizeof(LOG_T); i++)</span><br><span class="line">            log_mem[i] = Chip_Flash_Read_Main_Byte(...);</span><br><span class="line">        </span><br><span class="line">        // 校验CRC</span><br><span class="line">        for (i = LOG_DATA_START; i &lt; sizeof(LOG_T); i += 2)</span><br><span class="line">            wval = math_calc_crc16(*(uint16_t *)(log_mem + i), wval);</span><br><span class="line">            </span><br><span class="line">        if (wval == log_p-&gt;checksum) &#123;</span><br><span class="line">            // CRC校验通过，同步数据到内存</span><br><span class="line">            ((SBSIF_T *)psbsifHandle)-&gt;sbs_historiage = log_p-&gt;historiage;</span><br><span class="line">            vmaxcell1_now = log_p-&gt;vmaxcell1;</span><br><span class="line">            vmincell1_now = log_p-&gt;vmincell1;</span><br><span class="line">            // ...其他数据同步</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 日志索引自增</span><br><span class="line">        log_p-&gt;logindex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void recover_dfcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 从Flash读取DFCC数据</span><br><span class="line">    log_crc = Chip_Flash_Read_Main_DWord(PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET);</span><br><span class="line"></span><br><span class="line">    // 计算数据的CRC校验值</span><br><span class="line">    for (i = 0; i &lt; DFCC_TABLE_LEN; i += 2) &#123;</span><br><span class="line">        value = Chip_Flash_Read_Main_Word((PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET) + 4 + i);</span><br><span class="line">        wval = math_calc_crc16(value, wval);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 校验CRC</span><br><span class="line">    if ((log_crc == wval) &amp;&amp; (wval != 0)) &#123;</span><br><span class="line">        // 复制数据到内存</span><br><span class="line">        fn_memcpy(DFCC_table, (uint8_t *)(PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET) + 4, DFCC_TABLE_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类似地恢复充电FCC表和放电偏移量表...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）数据更新流程</p>
<p>数据更新流程中，系统会持续监控电池参数的极值，并在特定条件下（如极值变化、定时更新、强制更新）将数据写入Flash。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void update_log_data(uint8_t right_now)</span><br><span class="line">&#123;</span><br><span class="line">    // 更新电压极值</span><br><span class="line">    if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &gt; vmaxcell1_now)</span><br><span class="line">        vmaxcell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &lt; vmincell1_now)</span><br><span class="line">        vmincell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line">    </span><br><span class="line">    // 判断是否需要更新日志</span><br><span class="line">    if ((log_check_ultimate_value() &amp;&amp; lifetime_en) || right_now || (time_flag[10] &amp;&amp; lifetime_en)) &#123;</span><br><span class="line">        // 更新日志数据</span><br><span class="line">        log_p-&gt;historiage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_agemah;</span><br><span class="line">        log_p-&gt;rc = sbsif_get_data(SBS0F_RC);</span><br><span class="line">        </span><br><span class="line">        if (lifetime_en) &#123;</span><br><span class="line">            log_p-&gt;vmaxcell1 = vmaxcell1_now;</span><br><span class="line">            log_p-&gt;vmincell1 = vmincell1_now;</span><br><span class="line">            log_p-&gt;cmaxchg = cmaxchg_now;</span><br><span class="line">            log_p-&gt;cmaxdsg = cmaxdsg_now;</span><br><span class="line">            log_p-&gt;maxtempcell = (maxtempcell_now - DK_BASE) / 10;</span><br><span class="line">            log_p-&gt;mintempcell = (mintempcell_now - DK_BASE) / 10;</span><br><span class="line">            log_p-&gt;maxtempcnt = maxtempcnt;</span><br><span class="line">            log_update_time();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 计算CRC校验值</span><br><span class="line">        for (i = LOG_DATA_START; i &lt; sizeof(LOG_T); i += 2) &#123;</span><br><span class="line">            wval = math_calc_crc16(*(uint16_t *)(log_mem + i), wval);</span><br><span class="line">        &#125;</span><br><span class="line">        log_p-&gt;checksum = wval;</span><br><span class="line">        </span><br><span class="line">        // 写入Flash</span><br><span class="line">        write_log_into_flash();</span><br><span class="line">        log_p-&gt;logindex++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 充电完成后更新自学习参数</span><br><span class="line">    if ((!charge_full_flag &amp;&amp; (sbsif_get_data(SBS16_BATTSTATUS) &amp; SBS16_FULLY_CHARGED)) || update_dfcc_flag) &#123;</span><br><span class="line">        if (log_check_update_condition()) &#123;</span><br><span class="line">            log_update_dfcc_data();</span><br><span class="line">            log_update_charge_fcc_data();</span><br><span class="line">            log_update_discharge_offset();</span><br><span class="line">        &#125;</span><br><span class="line">        update_dfcc_flag = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化数据类型"><a href="#持久化数据类型" class="headerlink" title="持久化数据类型"></a>持久化数据类型</h3><p>（1）基本电池信息日志</p>
<p>由LOG_T结构体存储，包含：<br>电池容量老化历史<br>电压电流温度极值记录<br>各温度区间使用时间统计<br>这些数据用于追踪电池使用历史和健康状态。</p>
<p>（2）放电容量动态学习表(DFCC)</p>
<p>DFCC表存储了不同温度和电流条件下的放电容量校正因子，用于提高电量计算精度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void log_update_dfcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态放电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_dsg_enable)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 擦除Flash页</span><br><span class="line">    eflash_erase_page(PAGE_DEFCC_START);</span><br><span class="line">    </span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)DFCC_table, sizeof(DFCC_table));</span><br><span class="line">    </span><br><span class="line">    // 写入CRC校验值</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, 0, 4, (uint8_t *)&amp;wval);</span><br><span class="line">    </span><br><span class="line">    // 写入DFCC表</span><br><span class="line">    eflash_mem_to_flashEX(PAGE_DEFCC_START, 4, sizeof(DFCC_table), (uint8_t *)DFCC_table);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）充电容量动态学习表(CFCC)</p>
<p>充电FCC表记录了不同温度和电流条件下的充电容量校正数据，用于优化充电过程中的电量计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void log_update_charge_fcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态充电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_chg_enable)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)charge_fcc_data, sizeof(charge_fcc_data));</span><br><span class="line">    </span><br><span class="line">    // 写入CRC校验值</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_CHARGE_FCC_OFFSET, 4, (uint8_t *)&amp;wval);</span><br><span class="line">    </span><br><span class="line">    // 写入充电FCC表</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_CHARGE_FCC_OFFSET + 4, sizeof(charge_fcc_data), (uint8_t *)charge_fcc_data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）放电偏移量表</p>
<p>放电偏移量表存储了不同条件下的放电偏移校正值，用于补偿放电过程中的误差。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void log_update_discharge_offset(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态放电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_dsg_enable)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)discharge_offset, sizeof(discharge_offset));</span><br><span class="line">    </span><br><span class="line">    // 组装数据</span><br><span class="line">    fn_memcpy(log_buf, &amp;wval, 4);</span><br><span class="line">    fn_memcpy(log_buf + 4, discharge_offset, sizeof(discharge_offset));</span><br><span class="line">    </span><br><span class="line">    // 写入放电偏移量表</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_DISCHARGE_OFFSET_OFFSET, 12, (uint8_t *)log_buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化的应用"><a href="#持久化的应用" class="headerlink" title="持久化的应用"></a>持久化的应用</h3><p>（1）电池电量计算精度提升</p>
<p>问题：电池在不同温度、电流条件下的容量会有显著差异，使用固定参数难以保证准确性。<br>解决方案：通过日志模块记录DFCC表和充电FCC表，实现动态学习和参数调整。</p>
<p>数据收集：<br>充放电过程中记录温度、电流等参数<br>完整放电&#x2F;充电周期后计算实际容量<br>参数更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (log_check_update_condition()) &#123;</span><br><span class="line">    log_update_dfcc_data();</span><br><span class="line">    log_update_charge_fcc_data();</span><br><span class="line">    log_update_discharge_offset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用算法：<br>电量计根据当前温度和电流查表获取校正因子<br>应用校正因子调整容量计算</p>
<p>（2）电池健康状态监测</p>
<p>问题：需要监控电池寿命周期内的健康状态变化，为用户提供电池健康程度的指导。<br>解决方案：利用日志模块的极值记录功能。</p>
<p>极值记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &gt; vmaxcell1_now)</span><br><span class="line">    vmaxcell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line"></span><br><span class="line">// 定期持久化</span><br><span class="line">log_p-&gt;vmaxcell1 = vmaxcell1_now;</span><br></pre></td></tr></table></figure>

<p>健康评估：<br>分析电压极值分布判断是否过充&#x2F;过放<br>通过温度极值记录判断是否经历过高&#x2F;低温<br>基于充放电电流极值评估是否有过大电流冲击</p>
<p>容量衰减追踪：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_p-&gt;historiage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_agemah;</span><br></pre></td></tr></table></figure>

<p>（3）断电数据保护</p>
<p>问题：电池管理系统断电后会丢失当前的电量计算参数和状态。<br>解决方案：关键参数的持久化存储与恢复。</p>
<p>状态保存：<br>定期或在特定事件（如充满电）时保存电量计算状态<br>包括当前电量(RC)、最大容量(FCC)、学习参数等</p>
<p>上电恢复：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 启动时恢复数据</span><br><span class="line">if (wval == log_p-&gt;checksum) &#123;</span><br><span class="line">    // CRC校验通过，同步数据</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_historiage = log_p-&gt;historiage;</span><br><span class="line">    vmaxcell1_now = log_p-&gt;vmaxcell1;</span><br><span class="line">    // ...其他数据恢复</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 恢复学习参数</span><br><span class="line">recover_dfcc_data();</span><br></pre></td></tr></table></figure>

<p>（4）Flash寿命管理</p>
<p>考虑到Flash的有限擦写次数，系统采取了以下策略：<br>只在必要时（极值变化、定时更新）写入数据<br>使用日志循环写入机制，平均分布擦写压力</p>
<h2 id="状态机（State-Machine）"><a href="#状态机（State-Machine）" class="headerlink" title="状态机（State Machine）"></a>状态机（State Machine）</h2><p>TODO</p>
<h1 id="Part3：电量算法模块"><a href="#Part3：电量算法模块" class="headerlink" title="Part3：电量算法模块"></a>Part3：电量算法模块</h1><h2 id="OCV-table"><a href="#OCV-table" class="headerlink" title="OCV table"></a>OCV table</h2><p>OCV表在lib_fg.c中的确实应用主要集中在：<br>系统初始化时的SOC确定<br>静置状态下的SOC校正<br>电压与SOC之间的转换计算<br>反向查询电压</p>
<p>（1）fg_init_soc函数：用于初始化SOC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static FG_ERROR_T fg_init_soc(FG_HANDLE_T *handle, short volt, short curr, short cellthm)</span><br><span class="line">&#123;</span><br><span class="line">    short soc = 0;</span><br><span class="line">    // 使用OCV表估算初始SOC</span><br><span class="line">    if (lut_soc_by_ocv(handle, volt, &amp;soc) != ERR_FG_NO_ERROR)</span><br><span class="line">        return ERR_FG_LUT_ERROR;</span><br><span class="line">    // ...设置初始SOC及库仑计数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）fg_idle_process函数：静置状态下的SOC校正</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static FG_ERROR_T fg_idle_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // ...在静置条件下</span><br><span class="line">    // 使用OCV表估算SOC并进行校正</span><br><span class="line">    if (lut_soc_by_ocv(handle, tmp_volt, &amp;ocv_soc) == ERR_FG_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        // ...根据OCV表估算结果校正SOC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）lut_soc_by_ocv函数本身：OCV查表获取SOC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static FG_ERROR_T lut_soc_by_ocv(FG_HANDLE_T *handle, int volt, short *soc)</span><br><span class="line">&#123;</span><br><span class="line">    // 实现查表逻辑，根据电压和温度获取SOC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）使用OCV表反向查询电压</p>
<p>lib_fg.c中的lut_ocv_by_soc函数提供了OCV表的反向查询能力，用于预测特定SOC点的电压：</p>
<p>在以下场景有应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int fg_time_estimation(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    short eod_ocv = 0;</span><br><span class="line">    int time_to_empty = 0;</span><br><span class="line"></span><br><span class="line">    // 预测放电终止点的OCV</span><br><span class="line">    if (lut_ocv_by_soc(handle, 0, &amp;eod_ocv) == ERR_FG_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        // 根据当前电压与终止电压的差距，以及当前放电速率，估算剩余时间</span><br><span class="line">        int voltage_drop = param-&gt;volt_lo_mv - eod_ocv;</span><br><span class="line">        int discharge_rate = voltage_drop * 3600 / ((LIB_FG_TYPE_T*)handle)-&gt;bat_avg_rate;</span><br><span class="line">        </span><br><span class="line">        time_to_empty = ((LIB_FG_TYPE_T*)handle)-&gt;cc_prv * 3600 / </span><br><span class="line">                        (param-&gt;current_ma * discharge_rate / 100);</span><br><span class="line">        </span><br><span class="line">        ((LIB_FG_TYPE_T*)handle)-&gt;time_to_empty = time_to_empty;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RC-table"><a href="#RC-table" class="headerlink" title="RC table"></a>RC table</h2><p>RC表是一个三维查找表，存储了电池在不同电压、电流和温度条件下电池内阻相关的容量校正因子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// RC表的查询实现</span><br><span class="line">// 输入电压、电流、温度，输出RC值</span><br><span class="line">static FG_ERROR_T lut_rc_f(FG_HANDLE_T *handle, short volt, short curr, short temp, short *output)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查输入参数有效性</span><br><span class="line">    // 可能会对电流取绝对值</span><br><span class="line"></span><br><span class="line">    // 使用三维表查询函数获取RC值</span><br><span class="line">    // 可能调用三线性插值函数</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR; // 成功返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RC表的应用"><a href="#RC表的应用" class="headerlink" title="RC表的应用"></a>RC表的应用</h3><p>RC表在fg_update中的应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FG_ERROR_T fg_update(FG_HANDLE_T *handle, FG_PARAM_T *param, FG_RESULT_T *result)</span><br><span class="line">&#123;</span><br><span class="line">    // 更新电池状态</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 在这里调用lut_rc_f获取RC值</span><br><span class="line">    </span><br><span class="line">    // 将RC值填充到结果结构体中</span><br><span class="line">    result-&gt;rc = ((LIB_FG_TYPE_T *)handle)-&gt;rc;</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在放电过程中的应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在fg_mobile_discharge_process函数中，RC表用于调整放电容量估计</span><br><span class="line"></span><br><span class="line">static FG_ERROR_T fg_mobile_discharge_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 放电处理逻辑</span><br><span class="line">    </span><br><span class="line">    // 在这里调用lut_rc_f获取放电条件下的RC值</span><br><span class="line">    // 使用RC值调整容量估计</span><br><span class="line">    </span><br><span class="line">    // 更新内部状态</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在充电过程中的应用</p>
<p>在fg_mobile_charge_process函数中，RC表用于调整充电容量估计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static FG_ERROR_T fg_mobile_charge_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 充电处理逻辑</span><br><span class="line"></span><br><span class="line">    // 在这里调用lut_rc_f获取充电条件下的RC值</span><br><span class="line">    // 使用RC值调整容量估计</span><br><span class="line">    </span><br><span class="line">    // 更新内部状态</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在时间预估中的应用：</p>
<p>用于fg_time_estimation函数中，影响剩余时间计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int fg_time_estimation(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 在这里间接调用lut_rc_f获取的RC值</span><br><span class="line">    // 使用RC值调整剩余时间计算</span><br><span class="line">    </span><br><span class="line">    // 计算并更新time_to_empty或time_to_full</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在SOH计算中的应用：</p>
<p>在soh_update函数中用于电池健康状态评估：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void soh_update(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 在这里调用lut_rc_f获取标准条件下的RC值</span><br><span class="line">    // 使用RC值参与SOH计算</span><br><span class="line">   </span><br><span class="line">    // 更新SOH值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RC表小结"><a href="#RC表小结" class="headerlink" title="RC表小结"></a>RC表小结</h3><p>RC与电池内阻：</p>
<p>RC表代表以下含义：<br>在放电过程中：RC表值较大表示内阻小、可用容量高；RC表值较小表示内阻大、可用容量低<br>在低温条件下：RC表值会降低，反映低温对容量的不利影响<br>在大电流条件下：RC表值会降低，反映大电流放电对有效容量的减少<br>在电池老化后：RC表配合SOH机制，反映容量衰减</p>
<p>因为温度和负载情况(电流大小)都会最终反映到锂电池内阻上，RC表的容量值变化实际是与电池内阻相关：<br>IR压降补偿：<br>估算负载下的电压损失<br>计算实际OCV(开路电压)<br>提高电量估算精度</p>
<p>容量校正：<br>调整电池在不同条件下的实际可用容量<br>考虑温度和电流对容量的影响</p>
<p>放电终点预测：<br>根据内阻预测不同负载下的放电终止点<br>提高剩余时间估算精度</p>
<p>RC表在实际应用中的一般流程：</p>
<p>获取实时数据：读取电池电压、电流和温度<br>查询RC表：调用lut_rc_f函数，获取当前条件下的RC值<br>容量调整：根据RC值调整FCC(满充容量)和CC(当前容量)<br>SOC计算：基于调整后的容量计算SOC<br>结果输出：将RC值和其他计算结果返回给系统</p>
<h2 id="DFCC-table"><a href="#DFCC-table" class="headerlink" title="DFCC table"></a>DFCC table</h2><h3 id="DFCC表的配置与初始化"><a href="#DFCC表的配置与初始化" class="headerlink" title="DFCC表的配置与初始化"></a>DFCC表的配置与初始化</h3><p>默认数据结构和初始值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 表的维度定义</span><br><span class="line">#define DFCC_X 11  // SOC轴</span><br><span class="line">#define DFCC_Y 3   // 电流轴  </span><br><span class="line">#define DFCC_Z 4   // 温度轴</span><br><span class="line"></span><br><span class="line">// 各轴的数据范围</span><br><span class="line">const short DFCC_XDATA[DFCC_X] = &#123;500, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000&#125;; // SOC: 5%-100%</span><br><span class="line">const short DFCC_YDATA[DFCC_Y] = &#123;600, 1500, 3000&#125;;  // 电流: 600mA-3000mA</span><br><span class="line">const short DFCC_ZDATA[DFCC_Z] = &#123;-100, 0, 250, 550&#125;; // 温度: -10°C到55°C</span><br><span class="line"></span><br><span class="line">// DFCC表数据结构</span><br><span class="line">short DFCC_table[DFCC_Y * DFCC_Z][DFCC_X];  // 3D查找表</span><br></pre></td></tr></table></figure>

<p>使用前的初始化：</p>
<p>从main.c中的代码片段可以看到DFCC表是作为查找表(lut)的一部分进行初始化的：</p>
<p>这段代码配置了一个三维查找表结构(tbl_three_t)，包含：<br>轴点数量：x_num, y_num, z_num<br>轴数据指针：p_x_start, p_y_start, p_z_start<br>表数据指针：p_data_start</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lut.dfcc_tbl.x_num = DFCC_X;</span><br><span class="line">lut.dfcc_tbl.y_num = DFCC_Y;</span><br><span class="line">lut.dfcc_tbl.z_num = DFCC_Z;</span><br><span class="line">lut.dfcc_tbl.p_x_start = (short *)DFCC_XDATA;</span><br><span class="line">lut.dfcc_tbl.p_y_start = (short *)DFCC_YDATA;</span><br><span class="line">lut.dfcc_tbl.p_z_start = (short *)DFCC_ZDATA;</span><br><span class="line">lut.dfcc_tbl.p_data_start = (short *)DFCC_table;</span><br></pre></td></tr></table></figure>

<p>查找表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int     x_num;              // X轴点数</span><br><span class="line">    int     y_num;              // Y轴点数</span><br><span class="line">    int     z_num;              // Z轴点数</span><br><span class="line">    short*  p_x_start;          // X轴数据起始指针</span><br><span class="line">    short*  p_y_start;          // Y轴数据起始指针</span><br><span class="line">    short*  p_z_start;          // Z轴数据起始指针</span><br><span class="line">    short*  p_data_start;       // 表数据起始指针</span><br><span class="line">&#125; tbl_three_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    tbl_read_t  readfunc;       // 表读取函数</span><br><span class="line">    tbl_one_t   thm_tbl;        // 温度表信息</span><br><span class="line">    tbl_one_t   ocv_tbl;        // OCV表信息</span><br><span class="line">    tbl_three_t rc_tbl;         // RC表信息</span><br><span class="line">    tbl_three_t dfcc_tbl;       // DFCC表信息</span><br><span class="line">&#125; FG_LUT_T;</span><br></pre></td></tr></table></figure>

<h3 id="lut-dfcc-f查表函数"><a href="#lut-dfcc-f查表函数" class="headerlink" title="lut_dfcc_f查表函数"></a>lut_dfcc_f查表函数</h3><p>定义DFCC table为宏DDTABLE </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define DDTABLE ((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.dfcc_tbl.p_data_start</span><br></pre></td></tr></table></figure>

<p>在放电处理流程内调用lut_dfcc_f查表，过程：</p>
<p>a) 输入参数限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SOC限制</span><br><span class="line">if (soc &lt; XDTABLE[0]) &#123;</span><br><span class="line">    soc = XDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (soc &gt; XDTABLE[XDNUM - 1]) &#123;</span><br><span class="line">    soc = XDTABLE[XDNUM - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电流限制</span><br><span class="line">if (curr &lt; YDTABLE[0]) &#123;</span><br><span class="line">    curr = YDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (curr &gt; YDTABLE[YDNUM - 1]) &#123;</span><br><span class="line">    curr = YDTABLE[YDNUM - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 温度限制</span><br><span class="line">if (temp &lt; ZDTABLE[0]) &#123;</span><br><span class="line">    temp = ZDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (temp &gt; ZDTABLE[ZDNUM - 1]) &#123;</span><br><span class="line">    temp = ZDTABLE[ZDNUM - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b) 索引查找：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查找SOC对应的索引</span><br><span class="line">for (IDX = 1; IDX &lt; XDNUM; IDX++) &#123;</span><br><span class="line">    if ((XDTABLE[IDX-1] &lt;= soc) &amp;&amp; (XDTABLE[IDX] &gt; soc)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找电流对应的索引</span><br><span class="line">for (IDY = 1; IDY &lt; YDNUM; IDY++) &#123;</span><br><span class="line">    if ((YDTABLE[IDY-1] &lt;= curr) &amp;&amp; (YDTABLE[IDY] &gt; curr)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找温度对应的索引</span><br><span class="line">for (IDZ = 1; IDZ &lt; ZDNUM; IDZ++) &#123;</span><br><span class="line">    if ((ZDTABLE[IDZ-1] &lt;= temp) &amp;&amp; (ZDTABLE[IDZ] &gt; temp)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c) 三线性插值计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// X轴(SOC)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    XFRACS = 1 * 100;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    XFRACS = fg_idiv(handle, (soc - STMP) * 100, (SVAL - STMP));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Y轴(电流)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    YFRAC = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    YFRAC = (SVAL - STMP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Z轴(温度)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    ZFRAC = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ZFRAC = (SVAL - STMP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFCC与动态容量"><a href="#DFCC与动态容量" class="headerlink" title="DFCC与动态容量"></a>DFCC与动态容量</h3><p>放电流程中查找RC table后继续查找DFCC table，动态修改FCC容量值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error = lut_dfcc_f(*handle*, ((LIB_FG_TYPE_T *)*handle*)-&gt;rsoc_now, -curr_now, *param*-&gt;cellthm, (*short* *)&amp;dfcc_comp);</span><br><span class="line"></span><br><span class="line">rca_prv = (fg_idiv(*handle*, tmp_soh_mah, ((LIB_FG_TYPE_T *)*handle*)-&gt;rsoc_now) * dfcc_comp) / 10000;</span><br><span class="line"></span><br><span class="line">((LIB_FG_TYPE_T *)*handle*)-&gt;fcc = rca_prv;</span><br></pre></td></tr></table></figure>

<h2 id="查表函数的插值原理"><a href="#查表函数的插值原理" class="headerlink" title="查表函数的插值原理"></a>查表函数的插值原理</h2><p>RC table和DFCC table都是三维查表函数，是离散点。而电量计检测到的温度电流电压soc等数据是连续点。因此需要三维插值去处理连续点无法在离散表中查询到的情况。</p>
<p>三线性插值是一种在三维空间中进行插值的技术，它基于周围8个已知点的值来估计任意位置的值。整个过程分三步：</p>
<ol>
<li><p>X方向插值：对Z和Y固定，在X方向上插值得到4个点</p>
</li>
<li><p>Y方向插值：对这4个点在Y方向上插值得到2个点</p>
</li>
<li><p>Z方向插值：对这2个点在Z方向上插值得到最终结果</p>
</li>
</ol>
<p>插值公式：</p>
<p>!V &#x3D; V_{000}(1-x)(1-y)(1-z) + V_{100}x(1-y)(1-z) + V_{010}(1-x)y(1-z) + V_{110}xy(1-z) + V_{001}(1-x)(1-y)z + V_{101}x(1-y)z + V_{011}(1-x)yz + V_{111}xyz</p>
<p>其中x, y, z是归一化的坐标（范围0到1）。</p>
<p>以下是示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int lut_three_latitude(tbl_three_t *p_tbl, short x, short y, short z, short *result)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int x_idx, y_idx, z_idx;</span><br><span class="line">    float fx[2], fy[2], fz[2];  // 插值权重</span><br><span class="line">    float tmp_xyz[8];           // 八个顶点的值</span><br><span class="line">    float tmp_xy[4];            // 四条边的插值结果</span><br><span class="line">    float tmp_x[2];             // 两个面的插值结果</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 查找X轴索引并计算插值权重</span><br><span class="line">    x_idx = find_table_index(p_tbl-&gt;p_x_start, p_tbl-&gt;x_num, x);</span><br><span class="line">    if (x_idx &lt; 0) return -1;</span><br><span class="line">    if (x_idx == p_tbl-&gt;x_num - 1) &#123;</span><br><span class="line">        fx[0] = 1.0f; fx[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fx[1] = (float)(x - p_tbl-&gt;p_x_start[x_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_x_start[x_idx+1] - p_tbl-&gt;p_x_start[x_idx]);</span><br><span class="line">        fx[0] = 1.0f - fx[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 查找Y轴索引并计算插值权重</span><br><span class="line">    y_idx = find_table_index(p_tbl-&gt;p_y_start, p_tbl-&gt;y_num, y);</span><br><span class="line">    if (y_idx &lt; 0) return -1;</span><br><span class="line">    if (y_idx == p_tbl-&gt;y_num - 1) &#123;</span><br><span class="line">        fy[0] = 1.0f; fy[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fy[1] = (float)(y - p_tbl-&gt;p_y_start[y_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_y_start[y_idx+1] - p_tbl-&gt;p_y_start[y_idx]);</span><br><span class="line">        fy[0] = 1.0f - fy[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 查找Z轴索引并计算插值权重</span><br><span class="line">    z_idx = find_table_index(p_tbl-&gt;p_z_start, p_tbl-&gt;z_num, z);</span><br><span class="line">    if (z_idx &lt; 0) return -1;</span><br><span class="line">    if (z_idx == p_tbl-&gt;z_num - 1) &#123;</span><br><span class="line">        fz[0] = 1.0f; fz[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fz[1] = (float)(z - p_tbl-&gt;p_z_start[z_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_z_start[z_idx+1] - p_tbl-&gt;p_z_start[z_idx]);</span><br><span class="line">        fz[0] = 1.0f - fz[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取周围8个点的值</span><br><span class="line">    for (k = 0; k &lt; 2 &amp;&amp; (z_idx + k) &lt; p_tbl-&gt;z_num; k++) &#123;</span><br><span class="line">        for (j = 0; j &lt; 2 &amp;&amp; (y_idx + j) &lt; p_tbl-&gt;y_num; j++) &#123;</span><br><span class="line">            for (i = 0; i &lt; 2 &amp;&amp; (x_idx + i) &lt; p_tbl-&gt;x_num; i++) &#123;</span><br><span class="line">                int data_idx = (z_idx + k) * (p_tbl-&gt;y_num * p_tbl-&gt;x_num) + </span><br><span class="line">                               (y_idx + j) * p_tbl-&gt;x_num + (x_idx + i);</span><br><span class="line">                tmp_xyz[k*4 + j*2 + i] = (float)p_tbl-&gt;p_data_start[data_idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿X轴插值，得到4个边的值</span><br><span class="line">    for (k = 0; k &lt; 2; k++) &#123;</span><br><span class="line">        for (j = 0; j &lt; 2; j++) &#123;</span><br><span class="line">            tmp_xy[k*2 + j] = tmp_xyz[k*4 + j*2] * fx[0] + tmp_xyz[k*4 + j*2 + 1] * fx[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿Y轴插值，得到2个面的值</span><br><span class="line">    for (k = 0; k &lt; 2; k++) &#123;</span><br><span class="line">        tmp_x[k] = tmp_xy[k*2] * fy[0] + tmp_xy[k*2 + 1] * fy[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿Z轴插值，得到最终结果</span><br><span class="line">    *result = (short)(tmp_x[0] * fz[0] + tmp_x[1] * fz[1]);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过三线性插值，系统能够在RC表&#x2F;DFCC表的离散数据点之间生成平滑的过渡值，这带来以下优势：</p>
<ol>
<li><p>平滑过渡：避免在临界点附近出现电量跳变</p>
</li>
<li><p>精细粒度：无需为每个可能的条件定义离散值，大幅减少表的大小</p>
</li>
<li><p>处理边界条件：即使输入参数超出表定义范围，也能提供合理的边界值</p>
</li>
<li><p>适用性广：同一表格可用于各种电池和工作条件</p>
</li>
</ol>
<p>一个插值示例：</p>
<p>场景：电池在-5°C环境下以1500mA电流放电，SOC为25%。</p>
<p>插值过程：</p>
<ol>
<li>温度在-10°C(DFCC_ZDATA[0]&#x3D;-100)和0°C(DFCC_ZDATA[1]&#x3D;0)之间</li>
</ol>
<ul>
<li>温度插值权重：fz[0]&#x3D;0.5, fz[1]&#x3D;0.5</li>
</ul>
<ol>
<li>电流在1000mA(DFCC_YDATA[1])和2000mA(DFCC_YDATA[2])之间</li>
</ol>
<ul>
<li>电流插值权重：fy[0]&#x3D;0.5, fy[1]&#x3D;0.5</li>
</ul>
<ol>
<li>SOC在10%(DFCC_XDATA[1]&#x3D;1000)和30%(DFCC_XDATA[2]&#x3D;3000)之间</li>
</ol>
<ul>
<li>SOC插值权重：fx[0]&#x3D;0.75, fx[1]&#x3D;0.25</li>
</ul>
<p>计算过程：</p>
<ul>
<li><p>获取8个顶点值：</p>
</li>
<li><p>V000 &#x3D; DFCC_table[0<em>3+1][1] &#x3D; 88（-10°C, 1000mA, 10%SOC）</em></p>
</li>
<li><p>V001 &#x3D; DFCC_table[1<em>3+1][1] &#x3D; 85（0°C, 1000mA, 10%SOC）</em></p>
</li>
<li><p>V010 &#x3D; DFCC_table[0<em>3+2][1] &#x3D; 60（-10°C, 2000mA, 10%SOC）</em></p>
</li>
<li><p>V011 &#x3D; DFCC_table[1<em>3+2][1] &#x3D; 75（0°C, 2000mA, 10%SOC）</em></p>
</li>
<li><p>V100 &#x3D; DFCC_table[0<em>3+1][2] &#x3D; 90（-10°C, 1000mA, 30%SOC）</em></p>
</li>
<li><p>V101 &#x3D; DFCC_table[1<em>3+1][2] &#x3D; 85（0°C, 1000mA, 30%SOC）</em></p>
</li>
<li><p>V110 &#x3D; DFCC_table[0<em>3+2][2] &#x3D; 75（-10°C, 2000mA, 30%SOC）</em></p>
</li>
<li><p>V111 &#x3D; DFCC_table[1<em>3+2][2] &#x3D; 75（0°C, 2000mA, 30%SOC）</em></p>
</li>
<li><p>应用三线性插值公式计算最终值（简化计算）：</p>
</li>
<li><p>X方向插值（SOC）：</p>
</li>
<li><p>tmp_xy[0] &#x3D; 88<em>0.75 + 90</em>0.25 &#x3D; 88.5</p>
</li>
<li><p>tmp_xy[1] &#x3D; 60<em>0.75 + 75</em>0.25 &#x3D; 63.75</p>
</li>
<li><p>tmp_xy[2] &#x3D; 85<em>0.75 + 85</em>0.25 &#x3D; 85</p>
</li>
<li><p>tmp_xy[3] &#x3D; 75<em>0.75 + 75</em>0.25 &#x3D; 75</p>
</li>
<li><p>Y方向插值（电流）：</p>
</li>
<li><p>tmp_x[0] &#x3D; 88.5<em>0.5 + 63.75</em>0.5 &#x3D; 76.125</p>
</li>
<li><p>tmp_x[1] &#x3D; 85<em>0.5 + 75</em>0.5 &#x3D; 80</p>
</li>
<li><p>Z方向插值（温度）：</p>
</li>
<li><p>result &#x3D; 76.125<em>0.5 + 80</em>0.5 &#x3D; 78.06</p>
</li>
</ul>
<p>最终校正因子约为78.06%，表示在-5°C、1500mA放电电流和25% SOC条件下，电池实际可用容量约为标称容量的78.06%。</p>
]]></content>
      <categories>
        <category>电量计</category>
      </categories>
      <tags>
        <tag>电量计</tag>
      </tags>
  </entry>
  <entry>
    <title>电量计--Cobra/循环仪/电池包的测试环境说明</title>
    <url>/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--Cobra%E5%BE%AA%E7%8E%AF%E4%BB%AA%E7%94%B5%E6%B1%A0%E5%8C%85%E7%9A%84%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="电量计–Cobra-循环仪-电池包的测试环境说明"><a href="#电量计–Cobra-循环仪-电池包的测试环境说明" class="headerlink" title="电量计–Cobra&#x2F;循环仪&#x2F;电池包的测试环境说明"></a>电量计–Cobra&#x2F;循环仪&#x2F;电池包的测试环境说明</h1><p>以Newton FW项目(77561, 77226)为例，介绍cobra工具配合客户环境电池包的使用。</p>
<p>客户环境指：电量计内置在电池包，通信接口只有I2C，不支持串口调试和Jtag下载FW；而开发环境的电量计是独立开发板，支持串口打印和Jtag下载。</p>
<p>在实验室环境：使用Chroma循环仪模拟真实的客户Charger，对电量计和电池系统充放电测试，用cobra配置电量计FW和参数并采集数据，调试客户遇到的问题。</p>
<h2 id="Cobra编辑和下载project文件"><a href="#Cobra编辑和下载project文件" class="headerlink" title="Cobra编辑和下载project文件"></a>Cobra编辑和下载project文件</h2><ol>
<li><p>启动项目匹配的Cobra shell版本，加载项目oce文件</p>
<p>cobra shell是程序启动器，版本号在 About查看，目前使用1.01.19版本</p>
<p>oce是cobra功能文件，决定具体项目支持的功能，不同项目的oce不同；oce分为X版本和Y版本，X为发布给用户使用版本，Y仅用于内部Debug。</p>
<p>下图在Extension Manager中select SD77226SBS_X_20250315.oce，oce路径在COBRA\Extensions</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191558616.png" alt="img"></p>
<ol start="2">
<li>（对于Newton项目）加载prj</li>
</ol>
<p>prj文件(project)是cobra对Newton FW bin和Flash参数文件xml（parameter_newton，OCV table， RCtable，user_setting）的打包。</p>
<p>加载prj后默认显示newton FW bin：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191608196.png" alt="img"></p>
<p>加载prj后可查看(show)参数：根据电池规格书配置Design Capacity容量，Limited Charge Voltage电压等参数；根据常温和高低温需求配置CC转CV的电压值(Constant Current切换的Constant Voltage转折点)的电压值和温度阈值。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191613694.png" alt="image-20250319161351611"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191614471.png" alt="image-20250319161401395"></p>
<p>OCV(Open Circuit Voltage) table和RC(Remaining Capacity) table都是根据具体电池实测的电池数据，一般不会更改（除非测试数据有问题或者更换电池）。</p>
<p>以RC table为例，数组对应关系如下同颜色的标号</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191635013.png" alt="image-20250319163556911"></p>
<p><strong>关于RC table：</strong></p>
<p>RC table反映的是在不同环境下的充放电过程中的电压和剩余容量的对应关系。</p>
<p>RC table的采集方法是对电池放电（从满电以恒流放到截止电压），在不同温度下，用不同电流放电，分别采集到电池输出电压和电池剩余容量的关系。</p>
<p>为什么RC table是采集放电过程而不是充电过程：（可能）是因为放电过程可以保持恒流，如果采集充电过程，充电CC-CV阶段开始后电流会降低，破坏了恒定电流值的要求。</p>
<p>为什么RC table要考虑问题温度和电流：锂电池特性决定，温度影响锂电池的放电容量，温度降低，电池内阻加大，电池放电容量下降；温度过高有风险，有时应用上需要调低满电容量。电流实际能反映负载的分压，由于电池开路电压一定，电池内置在某时刻一定，那么电池带负载时输出电流越大说明外部负载电阻小，大电流放电，电池内阻导致的压降更多，放电到截止电压就会提前到来，满电对应的输出电压也不一样，最终反映到RC table。</p>
<p><strong>关于OCV table：</strong></p>
<p>OCV table反映的是电池开路(非充放电)状态下的电压和剩余容量的对应关系。</p>
<p>严格的OCV table应该是用极小的电流放电采集容量变化。小电流说明负载电阻极大，可以近似开路环境。但这种采集时间太长，一般没搞。</p>
<p>项目实际用的OCV table是RC table采集过程中提取出来的数据，会有误差。</p>
<p>对于电量计FW，OCV table一般用于电池在持续Idle&#x2F;sleep状态下查询剩余容量，因为此时没有电流，只能靠电压查询。</p>
<p>充放电过程中查询容量主要使用RC table，初始充电时也会参考OCV table。</p>
<p><strong>关于电量计计算SOC（State-of-charge）是否符合标准的判定方法：</strong></p>
<p>SOC（State-of-charge）可以简单理解成剩余电荷容量（RC）占满充总容量(FCC，Full Charge Capacity)的百分比[0 ~ 100]</p>
<p>理论上，电量计应该在每个时刻都反映精确的剩余容量百分比，但很难做到（原因？？？？）</p>
<p>项目的SOC算法的目标：</p>
<p>(1) 应用层目标：在充电达到截止电流时，SOC要报100；在放电达到截止电压时，SOC要报0。SOC误差 &lt; 3%</p>
<p>(2) 基于(1)的两个测试标准，如果FW只靠RC table和OCV table计算SOC，可能不能达到要求。因此SOC算法添加了追赶机制：</p>
<p>当充电进入CV阶段恒流升压转恒压降流，SOC算法可能会开启SOC追赶，确保电流达到截止时SOC能到100。CV过程的SOC并不能反映真实电量变化。</p>
<p>当放电接近截止电压，SOC算法可能会开启SOC追赶，确保达到截止电压时SOC能到0。这个过程的SOC也不能反映真实电量变化。</p>
<p>中间的过程SOC值主要来自RC table数据，SOC算法可能只做一些消抖平滑处理。</p>
<p>3.（对于Newton项目）下载prj到电量计芯片(ARM M0)的Flash</p>
<p>Full download下载当前prj内的所有bin和参数数据到电量计（通信方式是I2C）</p>
<p>4.（对于Newton项目）更新prj</p>
<p>如果FW bin需要修改，可以在当前prj界面open用KEIL MDK编译出的新newton_encript.bin，再save as新的prj</p>
<p>如果有参数需要修改，直接改参数，再save as新的prj</p>
<h2 id="Cobra使用SBS采集数据"><a href="#Cobra使用SBS采集数据" class="headerlink" title="Cobra使用SBS采集数据"></a>Cobra使用SBS采集数据</h2><h3 id="连接电量计"><a href="#连接电量计" class="headerlink" title="连接电量计"></a>连接电量计</h3><p>Bus setting选择port连接。使用o2link gen1 USB转I2C转接板(8051芯片)，需要先安装windows转接板驱动。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191930845.png" alt="img"></p>
<h3 id="初始界面"><a href="#初始界面" class="headerlink" title="初始界面"></a>初始界面</h3><p>默认可勾选查询哪些电量计信息，下方可切换页面到log信息页面</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191935049.png" alt="image-20250319193558973"></p>
<h3 id="开启调试内存GGMEM-（可选）"><a href="#开启调试内存GGMEM-（可选）" class="headerlink" title="开启调试内存GGMEM#（可选）"></a>开启调试内存GGMEM#（可选）</h3><p>GGMEM0~GGMEM8是Cobra查询电量计内存中指定RAM区域数据的接口，是Cobra环境监测电量计参数变化的主要手段。</p>
<p>选中FWVersion，Ctrl+ALT+Y输入密码888888，使能GGMEM0~GGMEM8</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191941173.png" alt="image-20250319194120118"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191943097.png" alt="image-20250319194304045"></p>
<h3 id="查看Cobra-log"><a href="#查看Cobra-log" class="headerlink" title="查看Cobra log"></a>查看Cobra log</h3><p>Cobra log是每秒发送一次之前勾选的SBS命令给电量计，查询电量计已获取的电池信息（电量计可能每秒轮询一次电池信息）。</p>
<p>主要关注电压(Battery Voltage)，外部温度(ETHM), 电流(Battery Current)和电量计算法输出的SOC容量（RSOC）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191945945.png" alt="image-20250319194542869"></p>
<h3 id="查看GGMEM"><a href="#查看GGMEM" class="headerlink" title="查看GGMEM"></a>查看GGMEM</h3><p>查看GGMEM0值</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192008717.png" alt="image-20250319200834671"></p>
<p>查看GGMEM7的值和Cobra参数设定一致（高温环境，EOC电压是4100mV，EOC电流是500）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192020659.png" alt="image-20250319202040571"></p>
<h3 id="详细了解ggmem的映射过程"><a href="#详细了解ggmem的映射过程" class="headerlink" title="详细了解ggmem的映射过程"></a>详细了解ggmem的映射过程</h3><p>GGMEM字段在电量计FW中的定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192014937.png" alt="image-20250319201430891"></p>
<p>GGMEM是如何从电量计RAM对应到Cobra SBS命令的：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192016127.png" alt="image-20250319201605094"></p>
<p>如果要打开更多GGMEM9显示到Cobra log，需要更新cobra oce支持新SBSD9_GGMEM9，修改FW新增绑定SBS SBSD9_GGMEM9 &#x3D; gg_mem[X]，X可以是任何偏移，不一定是72。</p>
<h2 id="Cobra电流校准"><a href="#Cobra电流校准" class="headerlink" title="Cobra电流校准"></a>Cobra电流校准</h2><p>更新新的prj到电量计后，有时候Cobra采集的电流和charger&#x2F;循环仪的真实电量不一致，需要calibration校准电流，分为3步：</p>
<p>0电流校准；3V充电校准；-3V放电校准。</p>
<p>先用循环仪设置对应的电流，再点击cobra calibrate按钮即可；分别校准3种电流情况之后，SBS log的电流误差应该会消除。</p>
<p>如果没有更新prj，校准过的数据无需再校准</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192035028.png" alt="image-20250319203521951"></p>
<h2 id="Cobra应用示例"><a href="#Cobra应用示例" class="headerlink" title="Cobra应用示例"></a>Cobra应用示例</h2><p>如下图是充电进入CV阶段的部分log，电压恒压，电流减少。但RSOC只有62%，后面算法应该会加速追赶，确保在达到满充（电流降到500）时SOC到100%</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192040622.png" alt="image-20250319204006543"></p>
<p>这是export log导出csv文件，用曲线图分析</p>
<h2 id="循环仪Chroma-17020的使用"><a href="#循环仪Chroma-17020的使用" class="headerlink" title="循环仪Chroma 17020的使用"></a>循环仪Chroma 17020的使用</h2><h3 id="选择充电和放电配方"><a href="#选择充电和放电配方" class="headerlink" title="选择充电和放电配方"></a>选择充电和放电配方</h3><p>选择1A恒流充电（CC_1A），勾选连接到电量计的通道1-3，可开始充电和停止充电。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201021090.png" alt="image-20250320102129025"></p>
<p>1A恒流放电（DS_1A）同理：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201023474.PNG" alt="img"></p>
<p>在Cobra电流校准时，使用CC_3A和DS_3A，启动充电和放电后，再点击Cobra校准。</p>
<h3 id="编辑充放电配方"><a href="#编辑充放电配方" class="headerlink" title="编辑充放电配方"></a>编辑充放电配方</h3><p>配方编辑器可查看现有的配方，也可以编辑和新增配方</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201024587.PNG" alt="img"></p>
<p>查看已有的CC_3A配方的具体设置：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201025579.PNG" alt="img"></p>
<p>CC转CV电压模式充电：</p>
<p>CC阶段恒流3A充电电压逐渐升高到4.53，之后开始CV阶段恒压4.53，电流从3A逐渐减少到截止电流0.12A停止；关闭所有过流保护。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201025475.PNG" alt="img"></p>
<p>查看DS_1A放电的配方设置：</p>
<p>恒流放电：</p>
<p>1A恒流放电，电压从4.xV左右逐渐降低到截止电压3V就停止；关闭所有过流保护。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201027970.PNG" alt="img">对于不同的电池测试需求，可以修改参数之后存储档案。</p>
<h3 id="新建充放电配方"><a href="#新建充放电配方" class="headerlink" title="新建充放电配方"></a>新建充放电配方</h3><p>可以配置“放电+静置+充电”的自动运行配方，方便自动测试</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201034525.PNG" alt="img"></p>
<h2 id="Cobra采集数据分析"><a href="#Cobra采集数据分析" class="headerlink" title="Cobra采集数据分析"></a>Cobra采集数据分析</h2><p>示例数据：<a href="https://o2micro-my.sharepoint.com/:x:/p/thomas_hu/EftK5pMRry5HtS552GzuDRcBmb_yms6TSJNWoHF33muY4A?e=noJtCx">Scan_03_19_2025_11_44_14.csv</a></p>
<p>从放电快结束开始记录，静置，然后CC-CV充电到截止电流。</p>
<p>电压-电流曲线：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211526999.png" alt="image-20250321152603963"></p>
<p>比较真实电荷变化(mAh)和电量计评估的容量（RSOC）：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211528188.png" alt="image-20250321152851154"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211525757.png" alt="image-20250321152538723"></p>
<p><img src="C:\Users\cursorhu\AppData\Roaming\Typora\typora-user-images\image-20250321152447765.png" alt="image-20250321152447765"></p>
<h2 id="Cobra调试FW"><a href="#Cobra调试FW" class="headerlink" title="Cobra调试FW"></a>Cobra调试FW</h2><p>Y版本发指定SBS命令，格式参考FW代码和FW spec文档。</p>
<h3 id="SBS-F9打开串口、关闭串口"><a href="#SBS-F9打开串口、关闭串口" class="headerlink" title="SBS F9打开串口、关闭串口"></a>SBS F9打开串口、关闭串口</h3><p>串口测试环境必须要demo板子，电池包只有i2c不能看串口信息。测试环境如下</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081924569.png" alt="image-20250408192436055"></p>
<p>Cobra Y版本，发送 SBS F9 + 01 28，打开串口。 发送 SBS F9 + 01 29，关闭串口。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081918994.png" alt="image-20250408191814914"></p>
<h3 id="SBS51读高温次数和时间的数据"><a href="#SBS51读高温次数和时间的数据" class="headerlink" title="SBS51读高温次数和时间的数据"></a>SBS51读高温次数和时间的数据</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081931949.png" alt="image-20250408193124921"></p>
]]></content>
      <categories>
        <category>电量计</category>
      </categories>
      <tags>
        <tag>电量计</tag>
      </tags>
  </entry>
  <entry>
    <title>电量计--问题和功能记录</title>
    <url>/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--%E9%97%AE%E9%A2%98%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="电量计–问题和功能记录"><a href="#电量计–问题和功能记录" class="headerlink" title="电量计–问题和功能记录"></a>电量计–问题和功能记录</h1><h2 id="切换CV相关问题"><a href="#切换CV相关问题" class="headerlink" title="切换CV相关问题"></a>切换CV相关问题</h2><h3 id="充电过充中切cv"><a href="#充电过充中切cv" class="headerlink" title="充电过充中切cv"></a>充电过充中切cv</h3><p>需求描述：（NPC660项目）在充电过充中Host发送SBS73命令切换截止电压，从默认的4.35v切到4.1v，同时Charger充电器也设置截止电压4.15v以保证能充满到4.1v。期望充电到4.1v时rsoc能报100. </p>
<p>问题分析：在充电过充中切换截止电压，之前电量计累计的数据没有清0，导致充满到4.1v时电量还是按4.35v计算，只有70%</p>
<p>解决方案：收到SBS73就复位电量计数据（清0），注意清0会导致rsoc跳变。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081354520.png" alt="image-20250408135441409"></p>
<h3 id="放电过充中切cv"><a href="#放电过充中切cv" class="headerlink" title="放电过充中切cv"></a>放电过充中切cv</h3><p>需求描述：（NPC660项目）按4.35v充满后，如果长时间没拔下充电器，充电器会判断为长时间过充，Host发送SBS73命令切换截止电压，从默认的4.35v切到4.1v，之后放电到4.1v。期望放电到4.1v过充中rsoc能保持100，4.1v以下按正常电量消耗显示，电量无跳变。</p>
<p>问题分析：</p>
<p>（1）切换后Host有时读到soc是0值，可能是正好读到了复位数据。</p>
<p>（2）初始方案是判断电压在4.35~4.1时直接sbsif强制上报100，但4.1v时soc会有跳变。</p>
<p>（3）Host在4.35v时发送cv切换时GGMEM0看到soc是100，但4.35放电到4.1v过充中，soc一直下降，放电到4.1v按真实soc显示会跳变到89。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081405362.png" alt="image-20250408140512307"></p>
<p>解决方案：</p>
<p>（1）测试发现放电中每次发SBS73切cv到4.1v时，GGMEM0 soc都复位到100，因此解决方案是4.1v附近再复位一次电量计数据。</p>
<p>（2）不能在刚刚4.1v时复位，算法来不及刷新数据，会导致soc跳变。在4.1V + 20mV时提前复位。</p>
<p>（3）为了防止跳变，预设了平滑下降数据，平滑追赶跳变soc值。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081504160.png" alt="image-20250408150400108"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t cv_adjusted_flag = 0;</span><br><span class="line">static int16_t adjusted_cv_value = 0;</span><br><span class="line">#define FAKE_SOC_TABLE_SIZE 40</span><br><span class="line">static uint8_t fake_soc[FAKE_SOC_TABLE_SIZE] = &#123;</span><br><span class="line">                99, 99, 98, 98, 97, 97, 96, 96, 95, 95, 94, 94, 93, 93, 92, 92, 91, 91, 90, 90,</span><br><span class="line">                89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70,</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">//main loop每秒调用一次</span><br><span class="line">void check_and_force_soc_if_needed(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 获取当前电池电压</span><br><span class="line">    int16_t current_voltage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS09_BATTVOLT];</span><br><span class="line"></span><br><span class="line">    // 判断是否需要处理CV调整后的特殊情况</span><br><span class="line">    if (cv_adjusted_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果电压仍高于调整后的CV值，保持SOC为100%</span><br><span class="line">        if (current_voltage &gt; adjusted_cv_value)</span><br><span class="line">        &#123;</span><br><span class="line">            // 检查是否是放电状态</span><br><span class="line">            if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0A_BATTCURR] &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //4.1V以上时直接上报100，避免误读到SBS73的reset soc值0.</span><br><span class="line">                ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = 100;</span><br><span class="line">                ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC] = 100;</span><br><span class="line">    </span><br><span class="line">                //接近4.1V时提前reset数据，这样降到4.1v时真实soc能接近100</span><br><span class="line">                //如果不reset，从4.35放电到4.1的电量会被计算到soc，造成4.1v的soc只有90%</span><br><span class="line">                if(current_voltage - adjusted_cv_value &lt; 20)</span><br><span class="line">                    reset_gauge_parameters();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // 电压已降至CV值以下，按真实soc报</span><br><span class="line">            if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0A_BATTCURR] &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // 不要在这里复位，不然客户会看到soc跳变</span><br><span class="line">                // reset_gauge_parameters();</span><br><span class="line">    </span><br><span class="line">                // 备选: 如果用真实rsoc有跳变(5~15%左右)，做平滑处理，每秒降低soc直到匹配真实soc</span><br><span class="line">                static int idrop = 0;</span><br><span class="line">                if((((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] &lt; fake_soc[idrop]) &amp;&amp;</span><br><span class="line">                   (idrop &lt; FAKE_SOC_TABLE_SIZE))</span><br><span class="line">                &#123;</span><br><span class="line">                    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = fake_soc[idrop]; </span><br><span class="line">                    idrop++;</span><br><span class="line">                    return; //这里退出，下次继续，直到匹配或者超出fake table</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 清除全局标志</span><br><span class="line">            cv_adjusted_flag = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void smart_charge_func(void)</span><br><span class="line">&#123;</span><br><span class="line">    // SBS73: 超长时间充电切CV值功能</span><br><span class="line">    int16_t host_update = (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS73_UPDATE_CV] &gt;&gt; 16) &amp; 0xFFFF;</span><br><span class="line">    int16_t update_cv = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS73_UPDATE_CV] &amp; 0xFFFF</span><br><span class="line">    // 如果收到Host发送的CV调整命令</span><br><span class="line">    if (host_update &amp;&amp; update_cv)</span><br><span class="line">    &#123;</span><br><span class="line">        // 记录新的CV值</span><br><span class="line">        adjusted_cv_value = update_cv;</span><br><span class="line"></span><br><span class="line">        // 获取当前电池电压</span><br><span class="line">        int16_t current_voltage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS09_BATTVOLT];</span><br><span class="line"></span><br><span class="line">        // 如果当前电压高于新设定的CV值，设置标志且只设置一次</span><br><span class="line">        if ((cv_adjusted_flag == 0) &amp;&amp;</span><br><span class="line">            (current_voltage &gt; adjusted_cv_value))</span><br><span class="line">        &#123;</span><br><span class="line">            cv_adjusted_flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure>

<h2 id="充电到99停充，自动报百"><a href="#充电到99停充，自动报百" class="headerlink" title="充电到99停充，自动报百"></a>充电到99停充，自动报百</h2><p>FW有优化处理，当Charger提前截止充电了，电池处于idle状态且当前电量在99，Host发送81命令0x3数据通知电量计，电量计idle_process检测此标志位，持续30s后电量计自动报100，避免充电器插着但长时间停充场景的电量到不了100。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504241113416.png" alt="image-20250424111349241"></p>
<h2 id="GGMEM数据使用SBS命令导出"><a href="#GGMEM数据使用SBS命令导出" class="headerlink" title="GGMEM数据使用SBS命令导出"></a>GGMEM数据使用SBS命令导出</h2><p>客户环境下可能没有多的I2C接口能接Cobra上位机去读GGMEM，而问题调试必须依赖于GGMEM数据。</p>
<p>客户的Host代码可以使用SBS D0 ~ D8命令获取GGMEM0 ~8</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504241136014.png" alt="image-20250424113644949"></p>
<h2 id="Host乱切cv导致跳0和满充75问题"><a href="#Host乱切cv导致跳0和满充75问题" class="headerlink" title="Host乱切cv导致跳0和满充75问题"></a>Host乱切cv导致跳0和满充75问题</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251501835.png" alt="image-20250425150103773"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251509651.png" alt="image-20250425150921622"></p>
<p>Host侧代码可通过SBS D0~D8读GGMEM去分析这种跳0问题：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251510572.png" alt="image-20250425151016548"></p>
<p>注意Cobra轮询时间比较长最短1s，有时不一定能观测到soc跳0的值，但GGMEM0第一个DWORD复位为DESIGN FCC &#x3D; 13ec是可以作为判断的。</p>
<p>最终原因就是Host Charger逻辑问题，一直在发SBS73，而FW没加防呆，频繁复位libfg数据，导致最终4.1V时接近OCV查表值的电量75，而不是CV追赶值100.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251548428.png" alt="image-20250425154850336"></p>
<h2 id="Cycle-count放电循环次数"><a href="#Cycle-count放电循环次数" class="headerlink" title="Cycle-count放电循环次数"></a>Cycle-count放电循环次数</h2><p>SBS17 cycle-count &#x3D; 总放电量&#x2F;电池容量，每秒更新</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505071010300.png" alt="image-20250507101040214"></p>
<p>不接i2c多次循环再读cycle count可以读到更新，因为sleep机制下会有timer每60s唤醒一次持续1s，更新libfg信息，包括累计discharge ccmah，计算cycle count</p>
<h2 id="USB模式和AC-Charger模式的eocma调整接口"><a href="#USB模式和AC-Charger模式的eocma调整接口" class="headerlink" title="USB模式和AC Charger模式的eocma调整接口"></a>USB模式和AC Charger模式的eocma调整接口</h2><p>USB口只有500mA电流，应该保证USB充电的eocma小于500mA，典型值是200mA。参数的满充截止电流如果和USB电流相等都是500mA，host必须发SBS74切eocma到200mA，否则充电尾端加速过快，容易读到电量跳变。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505151622340.png" alt="image-20250515162238231"></p>
<h2 id="NTC表的两种形式"><a href="#NTC表的两种形式" class="headerlink" title="NTC表的两种形式"></a>NTC表的两种形式</h2><p>SD77561原版使用电压-电阻查表；SD77428A3使用电阻-温度查表，支持6uA&#x2F;48uA两种电流源切换，大电流源保证高温时R*I &#x3D; V有更大的值，这样电压ADC有更高精度。现在需要将SD77561的电压-电阻查表改成电阻-温度查表，支持6uA&#x2F;72uA两种电流源切换：</p>
<p>(1)首先将SD77428代码里已经有的R-T表，手动创建一个77561 PRJ的NTC.txt格式表：</p>
<p>x轴是16个采样点，total length是cobra解析此表的参数总和，即16*2 (x和y) + 6(header) &#x3D; 38</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202506301553903.png" alt="image-20250630155253817"></p>
<p>(2)修改ADC查表方式，并添加高温切换大电流源</p>
<p>代码分支：HaoPeng-I0917A</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Copy raw thm voltage to buffer</span><br><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_val = sbs_cal_lsb_factor((int32_t)(dacq_p-&gt;raw_buff[((SBSIF_T *)psbsifHandle)-&gt;sbs_val]), ADC_EXTMPLSB, ADC_EXTMPLSB_FACTOR);</span><br><span class="line">//暂存，后面切换电流源用到此raw电压作为条件</span><br><span class="line">temp2 = ((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line">/* find Re, with 20uA source */</span><br><span class="line">// we modify thermal table as Voltage V.S. Temperature, so don&#x27;t need to multiple THM_OHM</span><br><span class="line">//((SBSIF_T *)psbsifHandle)-&gt;sbs_val 		*= (THM_OHM);						//Re = 1000uV / 20uA ==&gt; Ohm</span><br><span class="line"></span><br><span class="line">//转换电压成电阻：电压*1000精度/电流源 = NTC R，支持72ua和6ua电流源，72uA为了高温下高精度测量</span><br><span class="line">if(EXTNTCSRC_72UA == Chip_ADC_GetNTCSrc()) </span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= (1000/72);</span><br><span class="line">else</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= (1000/6);</span><br><span class="line"></span><br><span class="line">//查表，改成电阻-温度表</span><br><span class="line">lut_one_latitude(TEMPERATURE_DATA_NUM,</span><br><span class="line">                 (one_latitude_data_t *)GDM_FLASH_THML_TABLE,</span><br><span class="line">                 ((SBSIF_T *)psbsifHandle)-&gt;sbs_val,</span><br><span class="line">                 &amp;temp1);</span><br><span class="line">temp1 += DK_BASE;</span><br><span class="line">//记录温度</span><br><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS61_ETDK1] = temp1 - (int32_t)(param_board_cfg[PARM_BCFG_EXTTHMOFFSET]); //((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据ntc电压（温度状况）决定电流源切换提高精度：</span><br><span class="line">//高温ntc电压小于60mV切换72uA，常温低温ntc电压大于900mV切换6uA</span><br><span class="line">if((temp2 &lt; 60) &amp;&amp; (EXTNTCSRC_6UA == Chip_ADC_GetNTCSrc()))&#123;</span><br><span class="line">    Chip_ADC_SetNTCSrc(EXTNTCSRC_72UA);</span><br><span class="line">&#125;else if ((temp2 &gt; 900) &amp;&amp; (EXTNTCSRC_72UA == Chip_ADC_GetNTCSrc()))&#123;</span><br><span class="line">    Chip_ADC_SetNTCSrc(EXTNTCSRC_6UA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在线升级bin和参数对照"><a href="#在线升级bin和参数对照" class="headerlink" title="在线升级bin和参数对照"></a>在线升级bin和参数对照</h2><p>终端在线升级出问题一般只会回传bin，需要对照bin的参数是怎么配置的，注意bin没有8K的bootloader offset即可找到参数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507232039915.png" alt="image-20250723203915801"></p>
<p>缺失的参数定义在C:\git-834\COBRA\COBRA Documents\SD77226SBS_X_20250315\Project\Parameter查看</p>
<h2 id="SOH更新原理"><a href="#SOH更新原理" class="headerlink" title="SOH更新原理"></a>SOH更新原理</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507251146800.png" alt="image-20250725114616713"></p>
<h2 id="77428-Host驱动使用硬件I2C判断通信问题"><a href="#77428-Host驱动使用硬件I2C判断通信问题" class="headerlink" title="77428 Host驱动使用硬件I2C判断通信问题"></a>77428 Host驱动使用硬件I2C判断通信问题</h2><p>i2c sbs接口持续错误可用此方式判断是硬件问题还是软件问题</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507251147766.png" alt="image-20250725114726725"></p>
<h2 id="注释函数大幅减少Code段占用"><a href="#注释函数大幅减少Code段占用" class="headerlink" title="注释函数大幅减少Code段占用"></a>注释函数大幅减少Code段占用</h2><p>一般注释掉函数的调用处，但不注释函数体本身，只会减少运行时堆栈，并不会减少Code代码段，；但是561 KEIL项目注释main的libfg_update后，Code段从36K减到20K</p>
<p>原因是编译器优化：未被调用的函数被从Image中移除；只有被调用的函数体才存放在Image。</p>
<p>如下图分别是不调用和调用libfg_update时的.map信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507291025458.png" alt="image-20250729102546398"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507291026312.png" alt="image-20250729102611276"></p>
<h2 id="SD77428-power-supply框架获取电量信息"><a href="#SD77428-power-supply框架获取电量信息" class="headerlink" title="SD77428 power supply框架获取电量信息"></a>SD77428 power supply框架获取电量信息</h2><p>框架参考：<a href="https://www.kernel.org/doc/html/latest/power/power_supply_class.html">https://www.kernel.org/doc/html/latest/power/power_supply_class.html</a></p>
<p>代码见&lt;include&#x2F;linux&#x2F;power_supply.h&gt;</p>
<p>基本原理是dev设备，注册power supply属性，其中的desc描述结构包含get_property回调函数接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int32_t sd77428_power_supply_init(struct sd77428_data *chip)</span><br><span class="line">&#123;</span><br><span class="line">    chip-&gt;bat_cfg.drv_data = chip;</span><br><span class="line">    chip-&gt;bat_cfg.of_node = chip-&gt;client-&gt;dev.of_node;</span><br><span class="line"></span><br><span class="line">    chip-&gt;bat_desc.name = &quot;sd77428&quot;;</span><br><span class="line">    chip-&gt;bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;</span><br><span class="line">    chip-&gt;bat_desc.properties = sd77428_battery_props;</span><br><span class="line">    chip-&gt;bat_desc.num_properties = ARRAY_SIZE(sd77428_battery_props);</span><br><span class="line">    chip-&gt;bat_desc.get_property = sd77428_battery_get_property; //这里是get_property回调</span><br><span class="line">    chip-&gt;bat_desc.no_thermal = 1;</span><br><span class="line">    chip-&gt;bat_desc.external_power_changed = sd77428_external_power_changed;</span><br><span class="line"></span><br><span class="line">    chip-&gt;bat = devm_power_supply_register(chip-&gt;dev, &amp;chip-&gt;bat_desc, &amp;chip-&gt;bat_cfg);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>驱动实现get_property回调，关联电量信息和上报的状态，有的信息需要映射，例如SOH不能直接上报值只能报状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case POWER_SUPPLY_PROP_VOLTAGE_NOW:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_voltage; //mV</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CURRENT_NOW:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_current; //mA</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CAPACITY: //capacity in percents(soc), from 0 to 100</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_rsoc;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_TEMP:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_temp; //单位：摄氏度</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN: //design charge capacity</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_capacity;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_FULL: //full-charge-capacity(FCC)</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_fcc; </span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_NOW: //charge capacity now</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_rc;</span><br><span class="line">    break;</span><br><span class="line">    </span><br><span class="line">case POWER_SUPPLY_PROP_HEALTH:</span><br><span class="line">    //val-&gt;intval = chip-&gt;batt_info.batt_soh; //不能直接返回SOH值</span><br><span class="line">    val-&gt;intval = POWER_SUPPLY_HEALTH_GOOD; //根据状态返回POWER_SUPPLY_HEALTH定义的状态</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<p>然后linux应用层通过sysfs访问power_supply路径下的节点，设备名称是前面注册的.name名称(sd77428)，路径下是各属性都像文件一样访问。</p>
<p>用uevent查看节点的所有实时信息，power_supply节点的任何信息的更新都会反映到默认属性uevent(power_supply属于uevent子类，基于uevent通知机制实现)；如果只查看某个信息如capacity，charge_now，都可以分开cat查看</p>
<p>如下是终端输出，sysfs查看uevent和驱动打印的电池信息是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@phytiumpi:~# ls /sys/class/power_supply</span><br><span class="line">sd77428</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# ls /sys/class/power_supply/sd77428 </span><br><span class="line">capacity            charge_now   device  power    status     temp  uevent</span><br><span class="line">charge_full_design  current_now  health  present  subsystem  type  voltage_now</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# cat /sys/class/power_supply/sd77428/uevent</span><br><span class="line">POWER_SUPPLY_NAME=sd77428</span><br><span class="line">POWER_SUPPLY_STATUS=Discharging</span><br><span class="line">POWER_SUPPLY_PRESENT=1</span><br><span class="line">POWER_SUPPLY_VOLTAGE_NOW=4089</span><br><span class="line">POWER_SUPPLY_CURRENT_NOW=0</span><br><span class="line">POWER_SUPPLY_CAPACITY=98</span><br><span class="line">POWER_SUPPLY_TEMP=25</span><br><span class="line">POWER_SUPPLY_CHARGE_FULL_DESIGN=3400</span><br><span class="line">POWER_SUPPLY_CHARGE_FULL=3400</span><br><span class="line">POWER_SUPPLY_CHARGE_NOW=3318</span><br><span class="line">POWER_SUPPLY_HEALTH=Good</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# [   23.297385] [bmt]sd77428_get_batt_info: vbat:4089, ibat:00000, tbat:25, rsoc:098, fcc:3400, dcap:3400, soh:100, cycle:0, rc:3318, dfcc:3798, cc:8242, ext_chg -1</span><br></pre></td></tr></table></figure>

<h2 id="561-cobra导出EEPROM-64K数据"><a href="#561-cobra导出EEPROM-64K数据" class="headerlink" title="561 cobra导出EEPROM 64K数据"></a>561 cobra导出EEPROM 64K数据</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510091639531.png" alt="image-20251009163917427"></p>
<p>从左到右依次read all，每次export一个bin，得到3个bin，然后用hex editor合并成一个64KB的bin，按EEPROM+Sytem+Information合并</p>
<h2 id="561-SBS改成428格式，交叉测试"><a href="#561-SBS改成428格式，交叉测试" class="headerlink" title="561 SBS改成428格式，交叉测试"></a>561 SBS改成428格式，交叉测试</h2><p>LK阶段问题怀疑是428使用轮询I2C造成slave持续拉低clock&#x2F;data，561使用中断处理I2C，为了快速验证，不改host 428驱动情况下，使用561修改部分命令成428格式测试。</p>
<p>改两处即可：I2C slave地址，SBS命令的值和长度。注意Slave地址设置原代码有问题，应该直接赋值SADDR1，不能或等，否则COM通信失败</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111445198.png" alt="image-20251011144509147"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111444197.png" alt="image-20251011144420090"></p>
<h2 id="561-使用轮询方式处理I2C"><a href="#561-使用轮询方式处理I2C" class="headerlink" title="561 使用轮询方式处理I2C"></a>561 使用轮询方式处理I2C</h2><p>需求同上，为了对比测试428问题，561使用轮询i2c方式</p>
<p>修改两处：</p>
<p>1.i2c slave handle加到while1 ms轮询</p>
<p>2.关闭NVIC I2C中断开关 （561基于ARM，428的riscv是另外一套PLIC关闭）</p>
<p>注意自定义的数字逻辑也有中断使能和中断状态，这个和NVIC中断是无关的，属于内部状态，所以即使关了外部NVIC中断开关，也只是切断了ISR回调处理，轮询方式调用i2c slave handle仍可以读内部i2c register中断状态判断是读是写是传输完成，只要保证清除状态，不要重复处理即可。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111452813.png" alt="image-20251011145237741"></p>
<h2 id="77428A3不更新FCC问题"><a href="#77428A3不更新FCC问题" class="headerlink" title="77428A3不更新FCC问题"></a>77428A3不更新FCC问题</h2><p>A3驱动下载参数后需要发SBS8F带非0参数，reset_lib去更新FCC&#x3D;Design Capacity</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/10/28/f21ba8363f115b8d.png" alt="image-20251028142924671"></p>
]]></content>
      <categories>
        <category>电量计</category>
      </categories>
      <tags>
        <tag>电量计</tag>
      </tags>
  </entry>
  <entry>
    <title>飞腾派Linux SD驱动分析和调试</title>
    <url>/2024/05/18/%E9%A3%9E%E8%85%BE%E6%B4%BELinux%20SD%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="飞腾派Linux-SD驱动分析和调试"><a href="#飞腾派Linux-SD驱动分析和调试" class="headerlink" title="飞腾派Linux SD驱动分析和调试"></a>飞腾派Linux SD驱动分析和调试</h1><h2 id="SD初始化流程分析"><a href="#SD初始化流程分析" class="headerlink" title="SD初始化流程分析"></a>SD初始化流程分析</h2><h3 id="SD初始化的起始点"><a href="#SD初始化的起始点" class="headerlink" title="SD初始化的起始点"></a>SD初始化的起始点</h3><p>带SD卡启动系统时，初始化SD host和card的调用链：</p>
<p>probe -&gt; mmc_alloc_host -&gt; mmc_start_host -&gt; _mmc_detect_change -&gt; mmc_schedule_delayed_work(&amp;host-&gt;detect) -&gt; mmc_rescan（注释1）-&gt; mmc_rescan_try_freq（注释2）</p>
<p>注释1：mmc_alloc_host时用INIT_DELAYED_WORK绑定delayed_work detect和mmc_rescan回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);</span><br></pre></td></tr></table></figure>

<p>注释2：这里可能执行多次，从SD接口最低频率开始初始化，一般是400KHz，代码如下。 注意host-&gt;f_min是host driver设置。	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const unsigned freqs[] = &#123; 400000, 300000, 200000, 100000 &#125;;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; ARRAY_SIZE(freqs); i++) &#123;</span><br><span class="line">    if (!mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min)))</span><br><span class="line">        break;</span><br><span class="line">    if (freqs[i] &lt;= host-&gt;f_min)</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SD初始化的过程"><a href="#SD初始化的过程" class="headerlink" title="SD初始化的过程"></a>SD初始化的过程</h3><p>以下具体分析mmc_rescan_try_freq流程，并用飞腾SD卡的初始化log对照理解。</p>
<h4 id="第一阶段：mmc通用初始化："><a href="#第一阶段：mmc通用初始化：" class="headerlink" title="第一阶段：mmc通用初始化："></a>第一阶段：mmc通用初始化：</h4><p>此时的host还没有指定卡是SD还是eMMC还是SDIO，这个阶段主要做卡power up和host reset，然后对卡reset（go_idle + send_if_cond）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191529248.png" alt="image-20240419152855006"></p>
<p>对应log如下，以下CMD8 fail属于正常，因为此时还没指定是SD type</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191555610.png" alt="image-20240419155547556"></p>
<h4 id="第二阶段：SD卡的初始化入口："><a href="#第二阶段：SD卡的初始化入口：" class="headerlink" title="第二阶段：SD卡的初始化入口："></a>第二阶段：SD卡的初始化入口：</h4><p>SD模式的初始化入口：</p>
<p>根据host的能力(caps)，依次尝试初始化SDIO, then SD, then MMC，如果host能力指定了不支持SDIO或SD或MMC，将进入host支持的初始化入口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Order&#x27;s important: probe SDIO, then SD, then MMC */</span><br><span class="line">if (!(host-&gt;caps2 &amp; MMC_CAP2_NO_SDIO))</span><br><span class="line">    if (!mmc_attach_sdio(host))</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">if (!(host-&gt;caps2 &amp; MMC_CAP2_NO_SD))</span><br><span class="line">    if (!mmc_attach_sd(host))</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">if (!(host-&gt;caps2 &amp; MMC_CAP2_NO_MMC))</span><br><span class="line">    if (!mmc_attach_mmc(host))</span><br><span class="line">        return 0;</span><br></pre></td></tr></table></figure>

<p>怎么配置host能力：</p>
<p>host能力是指该SD&#x2F;MMC&#x2F;SDIO接口具体用作哪种类型，这个和平台外设的设计相关。例如飞腾Pi平台的SOC有两个SD&#x2F;MMC&#x2F;SDIO控制器接口：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191611726.png" alt="Image 14"></p>
<p>对于SD0控制器, 只作为SD&#x2F;eMMC接口使用，因此host driver对SD0可以设置host-cap能力如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host-&gt;caps2 |= MMC_CAP2_NO_SDIO | MMC_CAP2_NO_MMC;</span><br></pre></td></tr></table></figure>

<p>这样在mmc_rescan_try_freq就可以跳过mmc_attach_sdio和mmc_attach_mmc， 只执行mmc_attach_sd去启动SD初始化流程。</p>
<h4 id="SD卡初始化的基本概念"><a href="#SD卡初始化的基本概念" class="headerlink" title="SD卡初始化的基本概念"></a>SD卡初始化的基本概念</h4><h5 id="SD卡初始化的流程总览"><a href="#SD卡初始化的流程总览" class="headerlink" title="SD卡初始化的流程总览"></a>SD卡初始化的流程总览</h5><p>SD spec的UHS-I流程总览：几个关键节点1～9。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191701745.png" alt="image-20240419170130663"></p>
<p>以上UHS-I流程兼容SD3.0的SDR50, SDR25, SDR12等UHS模式，以及SD2.0的HS模式, DS模式：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191627573.png" alt="image-20240419162710488"></p>
<h5 id="SD卡初始化的接口概念"><a href="#SD卡初始化的接口概念" class="headerlink" title="SD卡初始化的接口概念"></a>SD卡初始化的接口概念</h5><p>如下图SD host和card接口，卡初始化过程最核心的工作就是协商host侧和card侧的能力，最终以双方都能支持的最高速度通信，即完成卡初始化。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404192014746.png" alt="image-20240419201436682"></p>
<p>所谓高速通信，无外乎以下几点：</p>
<p>更高的比特率：可以提高时钟频率和增加带宽。其中时钟CLK是host和card能力决定上限，host通过配置分频去控制接口频率（ios clock）；带宽是指SD接口有DATA[3:0] 4根数据线，但默认1bit模式只用了1根，切换到4bit模式后用4根线可同时传输4个bit。 </p>
<p>更低的信号电平：由于逻辑电平是梯形有建立时间，更低的电平信号能减少建立时间，达到更快的波特率；所以UHS模式一定要1.8V通信电平。</p>
<h4 id="第四阶段：SD卡初始化"><a href="#第四阶段：SD卡初始化" class="headerlink" title="第四阶段：SD卡初始化"></a>第四阶段：SD卡初始化</h4><p>在正式卡初始化之前， 有一个状态清理和协商工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmc_attach_sd： </span><br><span class="line"></span><br><span class="line">mmc_send_app_op_cond （这里是为了确认卡left busy state，有时候刚reset需要等状态恢复到IDLE）</span><br><span class="line"></span><br><span class="line">host-&gt;ocr_avail = host-&gt;ocr_avail_sd; （这里拿到host支持的sd ocr电压值，例如3.3V）</span><br><span class="line"></span><br><span class="line">mmc_select_voltage （这里查询卡支持的ocr电压值，以协商一致电压，一般而言这里是3.3V）</span><br></pre></td></tr></table></figure>

<h5 id="SD卡初始化（上半部分）：-卡能力查询"><a href="#SD卡初始化（上半部分）：-卡能力查询" class="headerlink" title="**SD卡初始化（上半部分）：**卡能力查询"></a>**SD卡初始化（上半部分）：**卡能力查询</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmc_sd_init_card：</span><br><span class="line"></span><br><span class="line">	mmc_sd_get_cid：</span><br><span class="line"></span><br><span class="line">		mmc_go_idle (节点1，CMD0使卡进入IDLE state)</span><br><span class="line"></span><br><span class="line">		mmc_send_if_cond（节点2，CMD8使卡配置OCR电压）</span><br><span class="line"></span><br><span class="line">		mmc_send_app_op_cond（节点3，CMD41查询卡容量，是否支持1.8V信号电）</span><br><span class="line"></span><br><span class="line">		mmc_set_uhs_voltage（节点4，CMD11切换卡到1.8V信号电）</span><br><span class="line"></span><br><span class="line">			mmc_host_set_uhs_voltage （调用host-&gt;ops-&gt;start_signal_voltage_switch切host侧到1.8V信号电，使两端通信电平一致）	</span><br><span class="line">		</span><br><span class="line">		mmc_send_cid（节点5，CMD2获取卡CID）</span><br></pre></td></tr></table></figure>

<h6 id="关键节点描述："><a href="#关键节点描述：" class="headerlink" title="关键节点描述："></a>关键节点描述：</h6><p>节点2：CMD8应该设置arg[19:8] &#x3D; 1aa,  1 来自前面host ocr &#x3D; 2.7-3.6V support.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191656210.png" alt="image-20240419165618097"></p>
<p>有时候CMD41没设置arg bit24&#x3D;1, 可能是host cap没有正确配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phytium_mci_common_probe：</span><br><span class="line">mmc-&gt;ocr_avail_sd = MMC_VDD_32_33 | MMC_VDD_33_34;</span><br></pre></td></tr></table></figure>

<p>节点3：CMD41应该设置arg bit24  &#x3D; 1去查询卡是否支持S18R，去切换信号电到1.8V， 这个切换能力决定是否启动后面的UHS模式的初始化。这个CMD41有一定retry次数。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191706848.png" alt="image-20240419170626765"></p>
<p>有时候CMD41没设置arg bit24&#x3D;1, 可能是host cap没有使能UHS模式和4bit bus width</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmc_sd_get_cid：</span><br><span class="line">/*</span><br><span class="line"> * If the host supports one of UHS-I modes, request the card</span><br><span class="line"> * to switch to 1.8V signaling level. If the card has failed</span><br><span class="line"> * repeatedly to switch however, skip this.</span><br><span class="line"> */</span><br><span class="line">if (retries &amp;&amp; mmc_host_uhs(host))&#123;</span><br><span class="line">    ocr |= SD_OCR_S18R;</span><br><span class="line">    pr_info(&quot;%s: %s: set SD_OCR_S18R \n&quot;, mmc_hostname(host), __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mmc_host_uhs：</span><br><span class="line">static inline int mmc_host_uhs(struct mmc_host *host)</span><br><span class="line">&#123;</span><br><span class="line">	pr_info(&quot;%s: %s: host-&gt;caps = 0x%X \n&quot;, mmc_hostname(host), __func__, host-&gt;caps);</span><br><span class="line">	return host-&gt;caps &amp;</span><br><span class="line">		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |</span><br><span class="line">		 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |</span><br><span class="line">		 MMC_CAP_UHS_DDR50) &amp;&amp;</span><br><span class="line">	       host-&gt;caps &amp; MMC_CAP_4_BIT_DATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="host设置caps的两种方式：probe赋值，使用DTS"><a href="#host设置caps的两种方式：probe赋值，使用DTS" class="headerlink" title="host设置caps的两种方式：probe赋值，使用DTS"></a><strong>host设置caps的两种方式：probe赋值，使用DTS</strong></h6><p>一种方式是在host probe中对某个已知地址空间的mmc device直接设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phytium_mci_probe：</span><br><span class="line"></span><br><span class="line">host-&gt;sd0 = (0 == strcmp(dev_name(dev), &quot;28000000.mmc&quot;));</span><br><span class="line">if(host-&gt;sd0)&#123;</span><br><span class="line">	host-&gt;caps |= MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50 | MMC_CAP_4_BIT_DATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外的方式是设备树中添加property描述，通过mmc_of_parse解析能力，参考：<a href="https://gitee.com/phytium_embedded/phytium-linux-kernel/issues/I9H1ZS?from=project-issue">https://gitee.com/phytium_embedded/phytium-linux-kernel/issues/I9H1ZS?from=project-issue</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404221108662.png" alt="image-20240422110810589"></p>
<p>DTS位于arch&#x2F;arm&#x2F;boot&#x2F;dts, 用于描述某个开发板的设备信息；DTS是.dts或.dtsi后缀，dtsi是共性的dts配置，相当于头文件可被dts include。</p>
<p>搜索sd-uhs-sdrxx相关的dts，一个示例如下（rk3288-veyron-sdmmc.dtsi）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;sdmmc &#123;					//该SD/MMC/SDIO控制器是用于SD/MMC模式，不是SDIO模式</span><br><span class="line">	status = &quot;okay&quot;;		//用于enable或者disable此dts项，一般probe调用of_device_is_available检测此status.</span><br><span class="line">	bus-width = &lt;4&gt;;		//SD支持4bit线宽</span><br><span class="line">	cap-mmc-highspeed;		//支持eMMC HS</span><br><span class="line">	cap-sd-highspeed;		//支持SD HS（SD2.0）</span><br><span class="line">	card-detect-delay = &lt;200&gt;;</span><br><span class="line">	cd-gpios = &lt;&amp;gpio7 RK_PA5 GPIO_ACTIVE_LOW&gt;;		//卡检测（CD#）用的是GPIO7，低有效</span><br><span class="line">	rockchip,default-sample-phase = &lt;90&gt;;</span><br><span class="line">	sd-uhs-sdr12;			//支持UHS SDR12速率（SD3.0），时钟频率不超过24M</span><br><span class="line">	sd-uhs-sdr25;			//支持UHS SDR25速率（SD3.0），时钟频率不超过50M</span><br><span class="line">	sd-uhs-sdr50;			//支持UHS SDR50速率（SD3.0），时钟频率不超过100M</span><br><span class="line">	sd-uhs-sdr104;			//支持UHS SDR104速率（SD3.0），时钟频率不超过208M</span><br><span class="line">	vmmc-supply = &lt;&amp;vcc33_sd&gt;;	//卡供电VCC = 3.3V</span><br><span class="line">	vqmmc-supply = &lt;&amp;vccio_sd&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="SD卡初始化（下半部分-part1）：UHS高速模式（SD3-0）配置"><a href="#SD卡初始化（下半部分-part1）：UHS高速模式（SD3-0）配置" class="headerlink" title="SD卡初始化（下半部分-part1）：UHS高速模式（SD3.0）配置"></a><strong>SD卡初始化（下半部分-part1）：UHS高速模式（SD3.0）配置</strong></h5><p>在UHS下半部分初始化之前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host-&gt;ops-&gt;init_card：如果host有什么自定义寄存器配置，在此完成</span><br></pre></td></tr></table></figure>

<p>开始UHS下半部分：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191701745.png" alt="image-20240419170130663"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmc_sd_init_card：</span><br><span class="line"></span><br><span class="line">	mmc_set_relative_addr (节点6，CMD3获取卡地址：bus-device相对地址)</span><br><span class="line">	mmc_select_card (节点7，CMD7选中bus上的某card)</span><br><span class="line">                    （节点8，CMD42 unlock card，只有在CMD7的response显示card处于lock状态才发，此处一般不会lock，不发CMD42）</span><br><span class="line">                    </span><br><span class="line">	mmc_sd_setup_card：针对该card进行UHS初始化</span><br><span class="line">		step1：一些信息准备工作</span><br><span class="line">    	mmc_app_send_scr &amp; mmc_decode_scr（ACMD51,读卡的SCR register，见注释1）</span><br><span class="line">    	mmc_read_ssr（ACMD13,读卡的status register SSR，见注释2）</span><br><span class="line">		mmc_read_switch（ACMD6读卡能支持的driver strength和bus_width，下一步切换要用）</span><br><span class="line">	mmc_sd_init_uhs_card：切换到UHS模式的初始化（见注释3：需要host和card前面的协商结果是支持1.8V电平 &amp;&amp; UHS模式支持 &amp;&amp; bus width 4bit支持）</span><br><span class="line">		step2：执行切换：</span><br><span class="line">		一个ACMD6：</span><br><span class="line">            mmc_app_set_bus_width（节点9，ACMD6执行bus width切换4bit）</span><br><span class="line">            mmc_set_bus_width（host-ops也执行bus width切换到4bit）</span><br><span class="line">		几个CMD6如下（见注释4）</span><br><span class="line">            sd_select_driver_type（CMD6,设置卡侧driver strength并调用host ops也设置host侧register）</span><br><span class="line">            sd_set_current_limit（CMD6, 根据vdd设置最大电流）</span><br><span class="line">            sd_set_bus_speed_mode（CMD6，卡切换bus-speed到UHS中的SDRXX模式，并mmc_set_ios也设置host侧bus-speed）</span><br><span class="line">		step3：切完后调频：tuning</span><br><span class="line">			mmc_execute_tuning（节点10,CMD19，注释5）</span><br><span class="line"></span><br><span class="line">mmc_sd_init_card end.</span><br></pre></td></tr></table></figure>

<p>注释1：SCR register包含卡支持SD3.0以上版本与否，支持3.0以上则卡bus_width支持4BIT</p>
<p>注释2：SSR register包含卡的bus width，secured mode，card type等卡功能的配置</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404191807768.png" alt="image-20240419180712652"></p>
<p>注释3：切换到UHS模式的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Initialization sequence for UHS-I cards */</span><br><span class="line">if (rocr &amp; SD_ROCR_S18A &amp;&amp; mmc_host_uhs(host)) &#123;</span><br><span class="line">		err = mmc_sd_init_uhs_card(card);</span><br></pre></td></tr></table></figure>

<p>注释4：CMD6配合Function Function Group配置不同功能，注意和ACMD6区分.</p>
<p><img src="/home/cursorhu/.config/Typora/typora-user-images/image-20240419194003739.png" alt="image-20240419194003739"></p>
<p>注释5：tuning是高速模式下利用特定模式的数据（tuning block pattern）去模拟测试数据读写的CRC错误率，来反馈微调SD host和card接口的时钟频率，数据采样相位等，以适配不同PCB环境对高速信号干扰；如下图。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404192040132.png" alt="image-20240419204049080"></p>
<p>注意：UHS较低速的SDR12～SDR25 &lt; SDR50 &lt; 100MHz的，不需要tuning, SDR50可以tuning也可以不tuning。</p>
<p>注意：tuning需要SD host硬件支持，有的host时钟分频能支持UHS SDR104但不支持tuning，如下图的SDR fixed-delay， 此时SD UHS卡最高只能工作在SDR50 &lt;100MHz的速度，即这种host最高只能支持UHS SDR50模式。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404192034201.png" alt="image-20240419203428136"></p>
<h5 id="SD卡初始化（下半部分-part2）：HS模式（SD2-0）配置"><a href="#SD卡初始化（下半部分-part2）：HS模式（SD2-0）配置" class="headerlink" title="SD卡初始化（下半部分-part2）：HS模式（SD2.0）配置"></a><strong>SD卡初始化（下半部分-part2）：HS模式（SD2.0）配置</strong></h5><p>如果卡不支持UHS模式，即不调用mmc_sd_init_uhs_card流程，或者该流程失败，会进入mmc_sd_switch_hs初始化流程，该模式指非UHS的低速模式，不需要切换信号电平，通信线宽，tuning等操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmc_sd_switch_hs：</span><br><span class="line">	mmc_sd_switch（CMD6 switch to high speed）</span><br><span class="line">	mmc_set_clock（设置host ios clock）</span><br><span class="line">	mmc_app_set_bus_width（如果支持4bit bus-width，就CMD6切换）</span><br></pre></td></tr></table></figure>

<h2 id="附录：SD性能测试"><a href="#附录：SD性能测试" class="headerlink" title="附录：SD性能测试"></a>附录：SD性能测试</h2><p>在飞腾Pi上SD是作为系统盘启动，读写性能测试一般用fio或者dd。</p>
<p>如果没联外网下载fio，用系统自带的dd即可：</p>
<p>dd参数注释：</p>
<ol>
<li>if&#x3D;文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt;</li>
<li>of&#x3D;文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt;</li>
<li>bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</li>
<li>count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li>
</ol>
<p>dd测试写和读的用例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#测试写</span><br><span class="line">root@phytiumpi:~# dd if=/dev/zero of=/dd-test.bin bs=1M count=256 conv=fdatasync</span><br><span class="line">256+0 records in</span><br><span class="line">256+0 records out</span><br><span class="line">268435456 bytes (268 MB, 256 MiB) copied, 19.6135 s, 13.7 MB/s</span><br><span class="line"></span><br><span class="line">#测试读</span><br><span class="line">root@phytiumpi:~# dd if=/dd-test.bin of=/dev/zero bs=1M count=256 iflag=direct</span><br><span class="line">256+0 records in</span><br><span class="line">256+0 records out</span><br><span class="line">268435456 bytes (268 MB, 256 MiB) copied, 11.3607 s, 23.6 MB/s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意两个参数很重要，是为了绕开写缓存直接写硬盘：</p>
<p>‘fdatasync’：Synchronize output data just before finishing. This forces a physical write of output data. 写数据测试包括写入物理盘，而不是写到buffer就算完。dd命令执行到最后会真正执行一次“同步(sync)”操作。</p>
<p>iflag&#x3D;direct：读数据测试，直接读不经过读缓存。</p>
<p>这样测试也可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@phytiumpi:~# dd if=/dev/zero of=/dd-test.bin bs=256M count=1 conv=fdatasync1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">268435456 bytes (268 MB, 256 MiB) copied, 19.4769 s, 13.8 MB/s</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# dd if=/dd-test.bin of=/dev/zero bs=256M count=1 iflag=direct</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">268435456 bytes (268 MB, 256 MiB) copied, 11.327 s, 23.7 MB/s</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>飞腾派</category>
      </categories>
      <tags>
        <tag>phytium</tag>
      </tags>
  </entry>
  <entry>
    <title>飞腾派Linux调试环境-串口调试交叉编译uboot配置</title>
    <url>/2024/05/18/%E9%A3%9E%E8%85%BE%E6%B4%BELinux%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%9A%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91uboot%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="飞腾派Linux调试环境：串口调试，交叉编译，uboot配置"><a href="#飞腾派Linux调试环境：串口调试，交叉编译，uboot配置" class="headerlink" title="飞腾派Linux调试环境：串口调试，交叉编译，uboot配置"></a>飞腾派Linux调试环境：串口调试，交叉编译，uboot配置</h1><h1 id="串口调试环境"><a href="#串口调试环境" class="headerlink" title="串口调试环境"></a>串口调试环境</h1><h2 id="串口硬件连接"><a href="#串口硬件连接" class="headerlink" title="串口硬件连接"></a>串口硬件连接</h2><p>串口线的颜色和功能是对应的，4根线如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能    	   线的颜色</span><br><span class="line">TX           绿色</span><br><span class="line">RX           白色</span><br><span class="line">GND          黑色</span><br><span class="line">VCC          红色</span><br></pre></td></tr></table></figure>

<p>串口的接口类型取决于开发板接口，飞腾Pi是使用USB转TTL接口，有的开发板是板载串口转USB芯片，外部是USB直连PC，还有的是RS232接口。不管接口类型如何，串口转接芯片一般是CH340&#x2F;FT232。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404241426062.png" alt="image-20240424142615021"></p>
<p>飞腾派接线只用了3根线，没用VCC。注意RX是接到TX， TX是接到RX。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404241428560.png" alt="image-20240424142831480"></p>
<p>验证串口连接正常：查找到ttyUSB设备即USB转串口设备连接正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /dev/ttyUSB0</span><br></pre></td></tr></table></figure>

<p>注：Ubuntu有时串口线找不到ttyUSB0设备，可能跟线的质量或者芯片驱动相关。在Ubuntu下FT232不需要安装驱动能稳定连接。Windows下串口转接芯片一定需要装对应的CH340或FT232驱动才能在设备管理器COM口看到USB设备。</p>
<h2 id="Putty-配置串口调试环境"><a href="#Putty-配置串口调试环境" class="headerlink" title="Putty 配置串口调试环境"></a>Putty 配置串口调试环境</h2><p>Putty连接串口需要以root用户启动。非root用户启动putty无法设置端口号，波特率等参数。</p>
<p>以root启动putty有两种方式：</p>
<ul>
<li>以root启动putty GUI，在GUI中配置端口号，波特率等参数。</li>
<li>以命令行sudo启动putty，在启动参数中配置端口号，波特率等参数。</li>
</ul>
<p>以root启动putty GUI：对于Ubuntu 22.04 Wayland桌面，使用<code>sudo -E putty</code>启动putty GUI。</p>
<p>参考：<a href="https://wiki.archlinux.org/title/Running_GUI_applications_as_root">https://wiki.archlinux.org/title/Running_GUI_applications_as_root</a></p>
<p>以命令行sudo启动putty：</p>
<p>参考：<a href="https://readypinaple.com/using-putty-serial-terminal">https://readypinaple.com/using-putty-serial-terminal</a></p>
<p>对于我的调试环境（飞腾派），参数如下：</p>
<p><code>sudo putty -serial /dev/ttyUSB0 -sercfg 115200,8,n,1,N</code></p>
<h2 id="Putty串口环境的复制和粘贴"><a href="#Putty串口环境的复制和粘贴" class="headerlink" title="Putty串口环境的复制和粘贴"></a>Putty串口环境的复制和粘贴</h2><p>Ubuntu22.04环境上有两种方法：</p>
<p>1.使用鼠标中键在terminal和putty之间复制和粘贴；此方法不能在选中之后再选中，否则内容被覆盖；</p>
<p>2.启动putty GUI后在selection设置ctrl+shift +C&#x2F;V 复制粘贴。记得保存设置到session的default配置。terminal默认支持ctrl+shift+C&#x2F;V操作。这种方式更稳定。</p>
<p>以上的ctrl+shift+C&#x2F;V和中键操作属于两套剪贴板buffer，不会相互覆盖。即ctrl+shift+C复制的数据必须用ctrl+shift+V粘贴，中键选中的数据必须用中键粘贴。</p>
<h2 id="Putty记录和查看log"><a href="#Putty记录和查看log" class="headerlink" title="Putty记录和查看log"></a>Putty记录和查看log</h2><h3 id="记录log"><a href="#记录log" class="headerlink" title="记录log"></a>记录log</h3><p>在启动GUI后在session-&gt;logging设置记录all output，记得保存设置到session的default配置。</p>
<h3 id="查看log"><a href="#查看log" class="headerlink" title="查看log"></a>查看log</h3><p>查看log可以使用less显示 + grep过滤；</p>
<p><strong>关于less：</strong> 类似vim快捷键.</p>
<p>匹配查找：在less中查找可以使用 &#x2F;或者？查找，参考以下less的help：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/pattern          *  Search forward for (N-th) matching line.</span><br><span class="line">?pattern          *  Search backward for (N-th) matching line.</span><br><span class="line">n                 *  Repeat previous search (for N-th occurrence).</span><br><span class="line">N                 *  Repeat previous search in reverse direction.</span><br><span class="line"></span><br><span class="line">#对于有空格的匹配查找，用反斜杠转义空格，例如：</span><br><span class="line">/this\ is\ pattern</span><br></pre></td></tr></table></figure>

<p>跳转到头尾：大G（跳到末尾）和 gg（重来到开头）.</p>
<p><strong>关于grep</strong>，有几点很常用：</p>
<p>a.有时log中有乱码导致被grep设别为binary导致grep无法显示，需要<code>grep --text</code>参数指定以文本打开：</p>
<p>例如要查看putty.log中mmc0模块的打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~/phytium/phytium-linux-kernel-v1.0.1$ less ~/putty.log | grep mmc0 --text</span><br><span class="line"></span><br><span class="line">[    2.208568] mmc0: mmc_sd_setup_card:</span><br><span class="line">[    2.208571] mmc0: phytium_mci_ops_request: cmd:55 arg:0x400000</span><br><span class="line">[    2.209331] mmc0: phytium_mci_irq: events:100,mask:0x1547,dmac_events:0,dmac_mask:0x0,cmd:55</span><br><span class="line">[    2.209335] mmc0: phytium_mci_err_irq:</span><br><span class="line">[    2.209348] mmc0: error -110 whilst initialising SD card</span><br></pre></td></tr></table></figure>

<p>b.有时需要grep多个关键字，使用<code>grep -E “A|B”</code>，注意一定要用引号扩起来</p>
<p>例如要同时查看mmc0和BHT的打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less ~/putty.log | grep -E &quot;mmc0|BHT&quot; --text</span><br><span class="line"></span><br><span class="line">[    6.816021] BHT MSG:sdr50_notuning_sela_rx_inject:463</span><br><span class="line">[    6.821067] BHT MSG:exit:_ggc_output_tuning  0</span><br><span class="line">[    6.825505] BHT MSG: finit is 400000Hz</span><br><span class="line">[    6.829248] mmc0: tuning execution failed: 1</span><br><span class="line">[    6.833513] mmc0: phytium_mci_ops_set_ios:</span><br><span class="line">[    6.841521] mmc0: phytium_mci_set_buswidth: width = 0, set value:0x0</span><br></pre></td></tr></table></figure>

<p>c.有时需要排除某关键字，例如飞腾的SD host有mmc0, mmc1两个，我只关注mmc0, 使用 grep -v KEYWORD去排除， v：invert match</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less ~/putty.log | grep --text -v mmc1</span><br></pre></td></tr></table></figure>

<p><strong>less+grep+less：</strong></p>
<p>用less+grep过滤出log另存为新log， 再用less查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less ~/putty.log | grep --text -E &quot;mmc0|BHT&quot; &gt; putty-bh201-tuning-error.log </span><br><span class="line">less putty-bh201-tuning-error2.log</span><br></pre></td></tr></table></figure>

<h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h1><h2 id="交叉编译方法"><a href="#交叉编译方法" class="headerlink" title="交叉编译方法"></a>交叉编译方法</h2><p>设置工具链环境变量+交叉编译命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_env.sh: 注意要用source执行才是export配置到当前环境变量，用sh或者./sh都是配置到子shell进程环境</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:&quot;/opt/toolchains/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin&quot;</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line">export ARCH=arm64</span><br><span class="line"></span><br><span class="line">build_kernel.sh:</span><br><span class="line"></span><br><span class="line">make ARCH=arm64 e2000_defconfig all -j4 INSTALL_MOD_PATH=modules modules_install</span><br></pre></td></tr></table></figure>

<p>安装编译的系统镜像和设备树：把编译机的输出image和dtb拷贝到SD卡系统盘的rootfs&#x2F;boot&#x2F;里，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp_image.sh：</span><br><span class="line"></span><br><span class="line">sudo cp arch/arm64/boot/Image /media/cursorhu/rootfs/boot/</span><br><span class="line">sudo cp arch/arm64/boot/dts/phytium/phytium-pi-board.dtb /media/cursorhu/rootfs/boot/</span><br></pre></td></tr></table></figure>

<p>SD卡放回开发板启动，putty串口回车进入uboot，指定从SD卡系统盘的rootfs&#x2F;boot&#x2F;启动内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uboot.sh：（并不能直接在uboot运行）</span><br><span class="line"></span><br><span class="line">setenv bootargs console=ttyAMA1,115200 earlycon=pl011,0x2800d000 root=/dev/mmcblk0p1 rootwait rw;</span><br><span class="line">ext4load mmc 0:1 0x90100000 boot/Image;</span><br><span class="line">ext4load mmc 0:1 0x90000000 boot/phytium-pi-board.dtb;</span><br><span class="line">booti 0x90100000 – 0x90000000;</span><br></pre></td></tr></table></figure>

<h1 id="uboot配置"><a href="#uboot配置" class="headerlink" title="uboot配置"></a>uboot配置</h1><h2 id="uboot自动选择指定kernel启动"><a href="#uboot自动选择指定kernel启动" class="headerlink" title="uboot自动选择指定kernel启动"></a>uboot自动选择指定kernel启动</h2><p>背景：如下图，飞腾派启动指定内核需要设置uboot参数，由于飞腾派的uboot源码没有开放，不能用脚本（boot.scr）。调试新编译的内核，每次飞腾派启动都需要在putty粘贴uboot命令。开发效率低。</p>
<p>![Screenshot from 2024-04-08 15-40-55](&#x2F;home&#x2F;cursorhu&#x2F;Pictures&#x2F;Screenshot from 2024-04-08 15-40-55.png)</p>
<p>解决方案：将uboot命令配置到uboot环境变量，并保存到系统盘中使断电重启后uboot环境变量也生效。</p>
<p>参考mastering embeded linux programming， 使用bootcmd参数可以配置uboot script去执行一连串命令，实现类似shell script功能并保存，每次启动uboot不用复制粘贴一条条命令去启动。 </p>
<p>以飞腾派为例，每次编译kernel后要从新编译的kernel启动，需要每次手动设置以下uboot命令&#x2F;环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动参数环境变量</span><br><span class="line">setenv bootargs console=ttyAMA1,115200 earlycon=pl011,0x2800d000 root=/dev/mmcblk0p1 rootwait rw;</span><br><span class="line">#命令语句（非环境变量）</span><br><span class="line">ext4load mmc 0:1 0x90100000 boot/Image;</span><br><span class="line">ext4load mmc 0:1 0x90000000 boot/phytium-pi-board.dtb;</span><br><span class="line">booti 0x90100000 – 0x90000000;</span><br></pre></td></tr></table></figure>

<p>目标：使uboot自动从以上命令语句指定的kernel启动：</p>
<p>对于环境变量bootargs不需要改动，我们只需要将命令语句设置到bootcmd环境变量。最后再一起saveenv使两个环境变量都保存到硬盘，重启后能自动生效即可。</p>
<ol>
<li>如何设置bootcmd到uboot环境变量：</li>
</ol>
<p>将以上uboot命令语句合成为一条语句设置到bootcmd：uboot命令的结束标志是分号，设置bootcmd时在内容语句的每个分号前需要加转移字符 , 这样setenv才会判断这个分号是要输入到bootcmd的字符，而不散表明setenv命令本身的结束。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenv bootcmd ext4load mmc 0:1 0x90100000 boot/Image\;ext4load mmc 0:1 0x90000000 boot/phytium-pi-board.dtb\;booti 0x90100000 – 0x90000000\;</span><br></pre></td></tr></table></figure>

<p>注意：上面指令拷贝到putty串口时时符号 <code>-</code>会消失，需要手动添加</p>
<ol start="2">
<li>如何使bootargs和bootcmd环境变量重启后也自动生效：保存（所有）环境变量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">saveenv</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启后可以printenv查看配置生效，根据kernel打印可确认确实从指定kernel启动。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Phytium-Pi#printenv</span><br><span class="line">arch=arm</span><br><span class="line">baudrate=115200</span><br><span class="line">board=e2000</span><br><span class="line">board_name=e2000</span><br><span class="line">boot_os=bootm $kernel_addr -:- $ft_fdt_addr</span><br><span class="line">bootargs=console=ttyAMA1,115200 earlycon=pl011,0x2800d000 root=/dev/mmcblk0p1 rootwait rw;</span><br><span class="line">bootcmd=ext4load mmc 0:1 0x90100000 boot/Image;ext4load mmc 0:1 0x90000000 boot/phytium-pi-board.dtb;booti 0x90100000 - 0x90000000;</span><br><span class="line">bootdelay=2</span><br><span class="line">cpu=armv8</span><br></pre></td></tr></table></figure>

<p>5.如何删除env：变量设置为空即为删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenv bootargs</span><br><span class="line">setenv bootcmd</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>

<h1 id="附录：问题记录"><a href="#附录：问题记录" class="headerlink" title="附录：问题记录"></a>附录：问题记录</h1><h2 id="ARM工具链报错问题"><a href="#ARM工具链报错问题" class="headerlink" title="ARM工具链报错问题"></a>ARM工具链报错问题</h2><p>编译飞腾kernel有时会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~/phytium/phytium-linux-kernel-v1.0.1$ ./build_kernel.sh </span><br><span class="line">#</span><br><span class="line"># configuration written to .config</span><br><span class="line">#</span><br><span class="line">arch/arm64/Makefile:27: ld does not support --fix-cortex-a53-843419; kernel may be susceptible to erratum</span><br><span class="line">arch/arm64/Makefile:40: LSE atomics not supported by binutils</span><br><span class="line">arch/arm64/Makefile:48: Detected assembler with broken .inst; disassembly will be unreliable</span><br><span class="line">scripts/kconfig/conf  --syncconfig Kconfig</span><br><span class="line">arch/arm64/Makefile:27: ld does not support --fix-cortex-a53-843419; kernel may be susceptible to erratum</span><br><span class="line">arch/arm64/Makefile:40: LSE atomics not supported by binutils</span><br><span class="line">arch/arm64/Makefile:48: Detected assembler with broken .inst; disassembly will be unreliable</span><br><span class="line">  CC      scripts/mod/empty.o</span><br><span class="line">gcc: error: unrecognized command-line option ‘-mlittle-endian’</span><br><span class="line">make[3]: *** [scripts/Makefile.build:304: scripts/mod/empty.o] Error 1</span><br><span class="line">make[2]: *** [scripts/Makefile.build:544: scripts/mod] Error 2</span><br><span class="line">make[1]: *** [Makefile:1085: scripts] Error 2</span><br><span class="line">make[1]: *** Waiting for unfinished jobs....</span><br><span class="line">make: *** [Makefile:286: __build_one_by_one] Error 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>报错内容指向以下patch：</p>
<p><a href="https://patchwork.kernel.org/project/linux-arm-kernel/patch/1471873737-7614-1-git-send-email-will.deacon@arm.com/">https://patchwork.kernel.org/project/linux-arm-kernel/patch/1471873737-7614-1-git-send-email-will.deacon@arm.com/</a></p>
<p>可能原因：没有运行set_env.sh就直接build，生成的.confg有问题, ARCH&#x3D;arm CROSS_COMPILE&#x3D;XXX XXX_defconfig都没被写入到.confg文件</p>
<p>解决方法：删除kernel源码目录的.config文件：rm .config和.config.old，需要重启机器，再source set_env.sh重新设置环境变量, source build_kernel.sh, 编译就OK了</p>
]]></content>
      <categories>
        <category>飞腾派</category>
      </categories>
      <tags>
        <tag>phytium</tag>
      </tags>
  </entry>
  <entry>
    <title>高通平台 -- BH202 ARM windows的Pofx-&gt;D3 &amp; Fast removal/insert issue</title>
    <url>/2024/07/30/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0%20--%20BH202%20ARM%20windows%E7%9A%84Pofx-D3%20&amp;%20Fast%20removalinsert%20issue/</url>
    <content><![CDATA[<h1 id="BH202-ARM-windows的Pofx-D3-Fast-removal-insert-issue"><a href="#BH202-ARM-windows的Pofx-D3-Fast-removal-insert-issue" class="headerlink" title="BH202 ARM windows的Pofx-&gt;D3 &amp; Fast removal&#x2F;insert issue."></a>BH202 ARM windows的Pofx-&gt;D3 &amp; Fast removal&#x2F;insert issue.</h1><h2 id="issue现象和driver分析"><a href="#issue现象和driver分析" class="headerlink" title="issue现象和driver分析"></a>issue现象和driver分析</h2><p>客户问题：</p>
<p>客户高通平台5&#x2F;100的平台有首次插卡不弹卡问题，复现测试发现快速插拔卡可以等效复现，有概率性插卡不识别问题，且不识别后再插拔卡也不识别。</p>
<p>WH lab分析：</p>
<p>1.BH202状态机可能有问题，卡侧和Host侧的通信方向不一致导致CMD8持续报错。</p>
<p>2.Workaround：通过Driver的error recovery flow的power cycle操作（power off + power on）去复位硬件状态。</p>
<p>Driver问题分析和优化点：</p>
<p>1.快速插拔卡后设备不能进D3（power off），原因是BH202 driver的pofx-&gt; D3\pofx-&gt; D0流程有问题，按driver issue fix architecture修改后问题解决。</p>
<p>3.BH202 driver的card change -&gt; pofx request流程需要优化，确保pofx-&gt;D state时序正确</p>
<p>4.BH202 driver的card change event触发条件需要优化，避免快速插拔卡事件过多的问题</p>
<h2 id="Driver-Issue-Fix-Architecture"><a href="#Driver-Issue-Fix-Architecture" class="headerlink" title="Driver Issue Fix Architecture"></a>Driver Issue Fix Architecture</h2><h3 id="Power-cycle-diagram"><a href="#Power-cycle-diagram" class="headerlink" title="Power cycle diagram"></a>Power cycle diagram</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501141351408.png" alt="image-20250114135103318"></p>
<p>上图描述Issue fix的Driver Architecture，其中card handle和pofx handle属于BH202 miniport driver的模块，Storport AdapterControl属于miniport driver和Storport driver（and windows OS）的接口模块。</p>
<p>Note1：vdd1_power_cycle函数实现，内部调用pofx_request_d3和pofx_request_d0去实现power cycle（BH202 power off 再power on）。vdd1_power_cycle在以下情况被调用：</p>
<p>a.首次插卡，首次是指BH202没做过tuning</p>
<p>b.异常恢复流程，异常是卡初始化过程失败后的retry初始化</p>
<p>Note2：wait D3 response设置了超时时间5s，最大不能超过~8s，否则会触发SCSI BUS reset</p>
<p>Note3 and Note4：Storport返回的AdapterPowerControl D3只有一次，BH202 driver用作两个用途：</p>
<p>a.pofx handle认为系统响应了D3，即pofx-&gt;D3流程成功</p>
<p>b.card handle执行enter D3之前的准备流程，包括card stop transfer，card thread pending，card power off等函数，涉及到card一些标志的清理。</p>
<p>Note5: Storport driver收到D3请求的ACK（即请求返回）后，认为Adapter Idle；根据miniport注册的Adapter Pofx idle time 10ms，通知PMIC对BH202执行power off。</p>
<p>Note6：准备从D3返回D0，因为D3状态下没有任务或者中断插入执行，此处等待D0设置为2s</p>
<p>Note7：理论上应该是PMIC先上电后，Storport再通知miniport执行enter D0流程</p>
<p>Note8：进D0会发两次请求，首先是AdapterPowerControl - D0，BH202 driver由于实现了RestartAdapter，不需要在此请求做什么操作；之后是RestartAdapter，BH202 driver执行：</p>
<p>a.pofx handle认为pofx-&gt;D0流程成功</p>
<p>b.card handle执行enter D0的流程，包括host register reset，check card present，set card change event。</p>
<h3 id="pofx-D0-D3-diagram"><a href="#pofx-D0-D3-diagram" class="headerlink" title="pofx-&gt;D0&#x2F;D3 diagram"></a>pofx-&gt;D0&#x2F;D3 diagram</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501141423340.png" alt="image-20250114142323274"> </p>
<h3 id="Card-Event-change优化"><a href="#Card-Event-change优化" class="headerlink" title="Card Event change优化"></a>Card Event change优化</h3><p>快速插拔卡时，有两个问题：</p>
<ol>
<li>Driver对各种事件的处理是FIFO形式，当某次插拔卡事件（card change event）的处理流程遇到错误耗时较长，插拔卡事件会越积越多，但插拔卡实际是无记忆行为，driver只要能正确处理最终状态就可以，最终状态包括卡在位和卡不在位两种情况。</li>
<li>有多种应用场景会设置card change event，driver需要减少不必要的event设置</li>
</ol>
<p>Card event过滤如下：设置最多两个event的event FIFO：</p>
<ol>
<li><p>如果当前没有card change事件待处理，或者只有一个card change事件正在处理，此时shared task count &#x3D; 0，可以排队新增一个card change event待处理，并设置shared task count &#x3D; 1；</p>
</li>
<li><p>如果shared task count &#x3D; 1，不允许继续发起card change事件</p>
</li>
<li><p>每个card change event事件处理完毕后会shared task count - 1，直到为0.</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501141442768.png" alt="bh202-event"></p>
<h2 id="Bugfix状况"><a href="#Bugfix状况" class="headerlink" title="Bugfix状况"></a>Bugfix状况</h2><p>1.BH202 D0、D3问题：</p>
<p>原issue：快速插拔卡后拔卡，不能进D3，持续保持在D0。</p>
<p>现状：快速插拔卡后拔卡，能进D3（BH202能被power off），下次插卡能弹卡。</p>
<p>2.卡不识别问题：</p>
<p>原issue：快速插拔卡后，有时不识别卡，且不识别卡之后再插拔卡也不识别，除非Disable&#x2F;Enable驱动或者重启，会对用户造成困扰。</p>
<p>现状：快速插拔卡后，有时不识别卡，但再插拔一次可以识别；原因是快速插拔卡影响了驱动的卡识别正常流程，只需要再插拔一次就可以识别，不会对用户造成困扰。</p>
<p>结论：</p>
<p>当前版本可以release</p>
]]></content>
      <categories>
        <category>高通平台</category>
      </categories>
      <tags>
        <tag>SD/MMC</tag>
      </tags>
  </entry>
  <entry>
    <title>高通平台 -- BH20X问题记录</title>
    <url>/2024/07/30/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0%20--%20BH202%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="BH20x问题记录"><a href="#BH20x问题记录" class="headerlink" title="BH20x问题记录"></a>BH20x问题记录</h1><h2 id="Balur项目-Qcom-Android-14-bazel编译系统"><a href="#Balur项目-Qcom-Android-14-bazel编译系统" class="headerlink" title="Balur项目 - Qcom Android 14 bazel编译系统"></a>Balur项目 - Qcom Android 14 bazel编译系统</h2><p>关于GKI和KMI的概念(需要clash梯子)：GKI划分common kernel和platform module，是platform能使用bazel的根本原因</p>
<p><a href="https://source.android.com/docs/core/architecture/kernel/generic-kernel-image">https://source.android.com/docs/core/architecture/kernel/generic-kernel-image</a></p>
<p>bazel用于安卓14以上的platform kernel module编译：</p>
<p><a href="https://android.googlesource.com/kernel/build/+/refs/heads/main-kernel/kleaf/docs/impl.md#Step-2_Define-targets-to-build-external-kernel-modules">https://android.googlesource.com/kernel/build/+/refs/heads/main-kernel/kleaf/docs/impl.md#Step-2_Define-targets-to-build-external-kernel-modules</a></p>
<p>bazel语法（CN）</p>
<p><a href="https://bazel.google.cn/versions/7.4.0/reference/be/c-cpp?hl=zh-cn">https://bazel.google.cn/versions/7.4.0/reference/be/c-cpp?hl=zh-cn</a></p>
<h3 id="编译问题和方案"><a href="#编译问题和方案" class="headerlink" title="编译问题和方案"></a>编译问题和方案</h3><p>Bazel编译sdhci-msm.c中的#include语句时，找不到bayhub.c和bayhub.c</p>
<p>尝试按bazel语法，直接在host下的module.bzl里面的sdhci-msm模块的srcs的deps添加bayhub.c&#x2F;.h，但并没有成功</p>
<p>临时办法：</p>
<p>platform kernel下的根编译文件BUILD.bazel里面定义了linux&#x2F;mmc&#x2F;*.h, 将bayhub.h放到这个路径再引用</p>
<p>不#include bayhub.c，直接将内容展开到sdhci-msm.c</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202509051417452.png" alt="image-20250905141723250"></p>
<h3 id="ADB的环境搭建和使用"><a href="#ADB的环境搭建和使用" class="headerlink" title="ADB的环境搭建和使用"></a>ADB的环境搭建和使用</h3><p>ADB用于抓取soc板子的kernel log打印。使用ADB可以登录开发板root文件目录操作rootfs</p>
<h4 id="Windows装ADB环境"><a href="#Windows装ADB环境" class="headerlink" title="Windows装ADB环境"></a>Windows装ADB环境</h4><ol>
<li><p>安装ADB exe包</p>
<p><a href="https://www.thecustomdroid.com/google-android-usb-drivers/">https://www.thecustomdroid.com/google-android-usb-drivers/</a></p>
<p>下载platform-tools-latest，并且环境变量PATH添加adb.exe所在的目录，重启生效</p>
</li>
<li><p>安装USB-ADB驱动</p>
<p>没装USB驱动，连接soc板子（板子启动成功情况下），板子会被显示为yellow-bang设备，需要安装USB ADB驱动</p>
<p>驱动安装过程：</p>
<p>（1）右键yellow-bang的soc板子设备，选择更新驱动 -&gt; “通用串行总线”驱动类 -&gt; 找到WinUSB的ADB设备类驱动，不用管警告，安装。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202509051452516.png" alt="image-20250905145254487"></p>
<p>（2） 安装正常，soc设备会归为USB类，没有yellow bang</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202509051453172.png" alt="image-20250905145328150"></p>
</li>
</ol>
<h4 id="ADB抓kernel-log"><a href="#ADB抓kernel-log" class="headerlink" title="ADB抓kernel log"></a>ADB抓kernel log</h4><p>Win+R cmd进入命令行，用管理员启动</p>
<p>第一种方式：dmesg。输入如下命令开启mmc&#x2F;core的dev_dbg打印，dmesg输出到soc板子根目录&#x2F;sdcard的mmc.log，最后adb pull到windows PC查看log</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202509051455706.png" alt="图片2"></p>
<p>另一种方式：adb logcat，可以持续抓kprint的log，配合第一种打开dev_dbg打印后，可以同时抓pr_info和mmc的命令</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202509051456890.png" alt="图片3"></p>
<h3 id="调试SI参数"><a href="#调试SI参数" class="headerlink" title="调试SI参数"></a>调试SI参数</h3><p>两种方式：</p>
<p>1.直接改bayhub.h里面的GGC_CFG最后DWORD，包含drive strength值。需要编译整个系统，比较慢</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202509051503051.png" alt="image-20250905150355023"></p>
<p>2.使用debug sysfs接口，方便用户I&#x2F;O直接配置参数到驱动的对象，不需要编译系统。原理如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 读取当前值</span><br><span class="line">cat /sys/devices/platform/soc/8804000.sdhci/bh201_drive_strength</span><br><span class="line"># 写入新值(drive strength)</span><br><span class="line">echo 0x4A417777 &gt; /sys/devices/platform/soc/8804000.sdhci/bh201_drive_strength</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202509051503321.png" alt="image-20250905150308232"></p>
<h3 id="SD流程问题划分"><a href="#SD流程问题划分" class="headerlink" title="SD流程问题划分"></a>SD流程问题划分</h3><p>流程如下图，代码见core&#x2F;sd.c流程，以调用到.init_card()为划分：init_card前面属于平台Host测问题（调试需要看 host侧 VDD上电和CMD&#x2F;DATA&#x2F;CLK line信号）；.init_card()之后BH201驱动介入，根据ADB kprint和mmc log分析tuning等问题。</p>
<p>CMD0 -&gt; CMD8(check 2.0 card) -&gt; ACMD41 -&gt; CMD11(3.0 only) -&gt; CMD2 and 3 -&gt; .card_init (bht_load开始)</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202509051507611.png" alt="image-20250905150708572"></p>
]]></content>
      <categories>
        <category>高通平台</category>
      </categories>
      <tags>
        <tag>SD/MMC</tag>
      </tags>
  </entry>
  <entry>
    <title>高通平台 -- HDK845编译Android系统镜像记录</title>
    <url>/2019/09/26/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0%20--%20HDK845%E7%BC%96%E8%AF%91Android%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文记录在高通开发平台HDK845上编译Android系统镜像的过程</p>
<h2 id="一、-搭建Shadowsocks-Privoxy代理"><a href="#一、-搭建Shadowsocks-Privoxy代理" class="headerlink" title="一、 搭建Shadowsocks+Privoxy代理"></a>一、 搭建Shadowsocks+Privoxy代理</h2><h3 id="1-1为什么需要搭代理"><a href="#1-1为什么需要搭代理" class="headerlink" title="1.1为什么需要搭代理"></a>1.1为什么需要搭代理</h3><p>下载Android源码需要访问国外代码源，直接访问会被GFW阻挡，代理服务器（VPS）是未被GFW阻挡的国外服务器，通过代理服务器跳转至目标服务器访问国外代码源。</p>
<h3 id="1-2-shadowsocks-privoxy代理架构"><a href="#1-2-shadowsocks-privoxy代理架构" class="headerlink" title="1.2 shadowsocks+privoxy代理架构"></a>1.2 shadowsocks+privoxy代理架构</h3><p>使用shadowssocks+privoxy搭建客户端代理，如下图客户端进程发送请求（http&#x2F;https&#x2F;git）到privoxy，privoxy将请求转化为socks5请求，发送给shadowsocks客户端，shadowsocks处理socks5请求,将其发送到远端VPS上运行的socks5服务端（shadowsocks server），VPS再将请求转发给目标服务器。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281739480.png" alt="image001"></p>
<h3 id="1-3-shadowsocks-privoxy代理搭建"><a href="#1-3-shadowsocks-privoxy代理搭建" class="headerlink" title="1.3 shadowsocks+privoxy代理搭建"></a>1.3 shadowsocks+privoxy代理搭建</h3><h4 id="1-3-1-shadowsocks"><a href="#1-3-1-shadowsocks" class="headerlink" title="1.3.1 shadowsocks"></a>1.3.1 shadowsocks</h4><p>HOST系统：ubuntu 14.04 LTS<br>安装shadowsock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install python-pip </span><br><span class="line">pip install shadowsocks </span><br></pre></td></tr></table></figure>
<p>配置shadowsocks client</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /etc/ss.json </span><br><span class="line">输入以下内容: </span><br><span class="line">&#123; </span><br><span class="line">&quot;server&quot;:&quot;176.122.xxx.xx&quot;, </span><br><span class="line">&quot;server_port&quot;:8080, </span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;, </span><br><span class="line">&quot;local_port&quot;:1080, </span><br><span class="line">&quot;password&quot;:&quot;xxxxx&quot;, </span><br><span class="line">&quot;timeout&quot;:100, </span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行shadowsocks客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/ss.json &gt; ss.log 2&gt;&amp;1 &amp;  </span><br><span class="line">查看服务是否起来:  </span><br><span class="line">ps -ef | grep sslocal  </span><br></pre></td></tr></table></figure>
<p>若开机启动可写入<code>/etc/rc.local</code></p>
<h4 id="1-3-2-privoxy"><a href="#1-3-2-privoxy" class="headerlink" title="1.3.2 privoxy"></a>1.3.2 privoxy</h4><p>下载privoxy稳定版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz </span><br><span class="line">tar -zxvf privoxy-3.0.26-stable-src.tar.gz </span><br><span class="line">cd privoxy-3.0.26-stable </span><br></pre></td></tr></table></figure>
<p>privoxy服务需要新建privoxy用户,并添加到privoxy用户组来运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd privoxy </span><br><span class="line">groupadd -g 888 privoxy  </span><br><span class="line">gpasswd -a privoxy privoxy  </span><br></pre></td></tr></table></figure>
<p>查看privoxy用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id privoxy </span><br></pre></td></tr></table></figure>
<p>安装provoxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install autoconf </span><br><span class="line">autoheader &amp;&amp; autoconf</span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>
<p>设置privoxy监听http&#x2F;https&#x2F;git的端口，和privoxy面向socks5的端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /usr/local/etc/privoxy/config </span><br><span class="line">下面两行取消注释 </span><br><span class="line">listen-address 127.0.0.1:8118 </span><br><span class="line">forward-socks5t / 127.0.0.1:1080 </span><br></pre></td></tr></table></figure>
<p>启动privoxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privoxy --user privoxy /usr/local/etc/privoxy/config </span><br><span class="line">ps -ef | grep sslocal </span><br></pre></td></tr></table></figure>
<p>若开机启动可写入<code>/etc/rc.local</code></p>
<h4 id="1-3-3-设置代理环境变量"><a href="#1-3-3-设置代理环境变量" class="headerlink" title="1.3.3 设置代理环境变量"></a>1.3.3 设置代理环境变量</h4><p>http&#x2F;https&#x2F;ftp请求的代理端口设置为privoxy的监听端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit /etc/profile </span><br><span class="line">export http_proxy=&quot;http://127.0.0.1:8118&quot; </span><br><span class="line">export https_proxy=&quot;http://127.0.0.1:8118&quot; </span><br><span class="line">export ftp_proxy=&quot;http://127.0.0.1:8118&quot; </span><br></pre></td></tr></table></figure>
<p>生效并测试, curl返回大堆json字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile </span><br><span class="line">curl http://www.google.com </span><br></pre></td></tr></table></figure>
<p>系统的http(s)等请求的代理配置完成</p>
<h4 id="1-3-4-设置git代理"><a href="#1-3-4-设置git代理" class="headerlink" title="1.3.4 设置git代理"></a>1.3.4 设置git代理</h4><p>安装并配置git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install git </span><br><span class="line">git config --global user.email &quot;yourname@xxx.com&quot;  </span><br><span class="line">git config --global user.name &quot;yourname&quot; </span><br><span class="line">git config --global http.proxy http://127.0.0.1:8118 </span><br><span class="line">git config --global https.proxy http://127.0.0.1:8118 </span><br></pre></td></tr></table></figure>
<p>设置git使用代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install connect-proxy </span><br><span class="line">mkdir ~/bin </span><br><span class="line">echo &quot;connect-proxy -S 127.0.0.1:1080 \&quot;\$@\&quot;&quot; &gt; ~/bin/socks5proxywrapper </span><br><span class="line">chmod 755 ~/bin/socks5proxywrapper </span><br><span class="line">git config --global core.gitproxy `echo $HOME`/bin/socks5proxywrapper </span><br></pre></td></tr></table></figure>

<h2 id="二、下载编译Android源码"><a href="#二、下载编译Android源码" class="headerlink" title="二、下载编译Android源码"></a>二、下载编译Android源码</h2><h3 id="2-1-交叉编译的概念"><a href="#2-1-交叉编译的概念" class="headerlink" title="2.1 交叉编译的概念"></a>2.1 交叉编译的概念</h3><p>- 1 本地编译：在当前编译平台下，编译出来的程序只能运行在当前平台。常见的应用软件开发的编译都属于本地编译。<br>- 2 交叉编译：在当前编译平台下，编译出来的程序能运行在另一种体系结构不同的目标平台上，但是编译平台本身却不能运行该程序。<br>- 3 交叉编译工具链：编译过程包括了预处理、编译、汇编、链接等过程。每个子过程都是单独的工具来实现。交叉编译链是为了编译跨平台体系结构的程序代码而形成的由多个子工具构成的一套完整的工具集。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281739906.png" alt="image003"><br>如上图，交叉编译工具链中最主要的部分包含编译器（如gcc）,汇编器（如as）,连接器（如ld）。通常as和ld及objcopy等其他工具由GNU打包成了binutils（binary utilitys)工具，再加上编译器组成整个工具链。<br>其中编译器命名规则为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arch-core-kernel-system-compiler </span><br><span class="line"></span><br><span class="line">arch：目标平台架构，如arm, x86_64 </span><br><span class="line">core： 目标平台的CPU Core，如Cortex A8 </span><br><span class="line">kernel： 目标平台所运行的OS，如Linux，Android </span><br><span class="line">systen：交叉编译链所选择的库函数和目标系统的规范，如gnu，gnueabi等 </span><br><span class="line">compiler: 编译器名，如gcc, g++,clang,clang++ </span><br></pre></td></tr></table></figure>

<p>- 4 交叉编译架构：<br>HOST OS 通常为Linux，包含自身的kernel、glibc基础库和Target程序的依赖库。Toolchain包含C&#x2F;C++及其他语言编译器和汇编、链接器等组件。Toolchain依赖于HOST的glibc基础库。Target binary是编译出的目标镜像&#x2F;程序，编译过程依赖于Toolchain及HOST的build essential libs。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740465.png" alt="image005"></p>
<h3 id="2-2-高通Android平台编译概念"><a href="#2-2-高通Android平台编译概念" class="headerlink" title="2.2 高通Android平台编译概念"></a>2.2 高通Android平台编译概念</h3><p>高通平台HDK845推荐的编译环境如下：</p>
<table>
<thead>
<tr>
<th>HOST</th>
<th>Toolchain</th>
<th>Source code repository</th>
<th>build out Android version</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu14.04 LTS</td>
<td>Clang&#x2F;LLVM</td>
<td>CAF</td>
<td>support Android 9 Pie</td>
</tr>
</tbody></table>
<p>高通平台HDK845推荐的编译流程如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740419.png" alt="image006"></p>
<p>Clang&#x2F;LLVM编译器介绍<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281748816.png" alt="clangLLVM"><br>CAF和AOSP的介绍  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAF is Code Aurora repository. It&#x27;s the place where Qualcomm releases source code for their phone processors.  </span><br><span class="line">It&#x27;s directly supported by Qualcomm and it&#x27;s generally a more optimized branch for Snapdragon phones.  </span><br><span class="line">Actually, there are two main baselines for support of Qualcomm devices:  </span><br><span class="line">- 1. CodeAurora (CAF) - These are Qualcomm&#x27;s reference sources for their platform.  </span><br><span class="line">This is what they provide to OEMs, and what nearly all OEMs base their software off of.  </span><br><span class="line">As a result - nearly all non-Nexus devices are running kernels/display HALs/etc. that are derived from a CAF baseline.  </span><br><span class="line">- 2. Google&#x27;s software baseline(AOSP) - Usually when Google starts working on a new Android version, they&#x27;ll fork from CAF at the beginning.  </span><br><span class="line">Very often Google will be adding &quot;new&quot; features specific to the new Android version, while Qualcomm will continue with performance enhancements and bugfixes against the &quot;old&quot; baseline.  </span><br><span class="line">- 3. So when a new Android revision comes out, you have two baselines: CAF which is usually &quot;ahead&quot; in performance but &quot;behind&quot; in features,  while AOSP is “behind” in performance (relatively) but “ahead” in features.  </span><br><span class="line">Nowadays, developers are directly compiling the builds from CAF source code which is really difficult as this is what Google does initially before upgrading to a new version,  </span><br><span class="line">and then they add features and the source by the time gets ‘compilable’, it is easier to compile the one on Google Sources than the one which is there on CAF.  </span><br><span class="line">CAF can be considered as Vanilla version of a Vanilla version of Android.  </span><br></pre></td></tr></table></figure>
<h3 id="2-3-高通Android平台编译流程"><a href="#2-3-高通Android平台编译流程" class="headerlink" title="2.3 高通Android平台编译流程"></a>2.3 高通Android平台编译流程</h3><p>- 1 安装jdk，用于编译Android源码中的java代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add-apt-repository ppa:openjdk-r/ppa </span><br><span class="line">apt-get update </span><br><span class="line">apt-get -y install openjdk-8-jdk </span><br><span class="line">update-alternatives --config java </span><br><span class="line">java -version </span><br></pre></td></tr></table></figure>
<p>- 2 安装HOST(ubuntu14.04)的build essentials，编译过程依赖这些工具和库 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip libssl-dev libc6:i386 libstdc++6:i386</span><br></pre></td></tr></table></figure>
<p>- 3 安装repo，用于下载android源码 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo </span><br><span class="line">chmod +x ~/bin/repo </span><br><span class="line">export PATH=~/bin:$PATH </span><br><span class="line">repo --help </span><br></pre></td></tr></table></figure>
<p>- 4 解压开发板厂商的BSP，其中包含源码下载的脚本、补丁包等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip Open-Q_845_Android-P_v2.1.zip </span><br><span class="line">cd Open-Q_845_Android-P_v2.1/Source_Package </span><br><span class="line">chmod +x getSource_and_build.sh </span><br></pre></td></tr></table></figure>
<p>- 5 用脚本从CAF源下载代码，打补丁后编译 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./getSource_and_build.sh </span><br></pre></td></tr></table></figure>

<p><code>./getSource_and_build.sh</code>内容如下 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNDER=&#x27;\e[4m&#x27; </span><br><span class="line">RED=&#x27;\e[31;1m&#x27; </span><br><span class="line">GREEN=&#x27;\e[32;1m&#x27; </span><br><span class="line">YELLOW=&#x27;\e[33;1m&#x27; </span><br><span class="line">BLUE=&#x27;\e[34;1m&#x27; </span><br><span class="line">MAGENTA=&#x27;\e[35;1m&#x27; </span><br><span class="line">CYAN=&#x27;\e[36;1m&#x27; </span><br><span class="line">WHITE=&#x27;\e[37;1m&#x27; </span><br><span class="line">ENDCOLOR=&#x27;\e[0m&#x27; </span><br><span class="line">ITCVER=&quot;P_v2.1&quot; </span><br><span class="line">WORKDIR=`pwd` </span><br><span class="line">CAFTAG=&quot;LA.UM.7.3.r1-06700-sdm845.0&quot; </span><br><span class="line">BUILDROOT=&quot;$&#123;WORKDIR&#125;/SDA845_Open-Q_845_Android-$&#123;ITCVER&#125;&quot; </span><br><span class="line">PATCH_DIR=&quot;$&#123;WORKDIR&#125;/patches&quot; </span><br><span class="line">DB_PRODUCT_STRING=&quot;Open-Q 845 HDK Development Kit&quot; </span><br><span class="line"></span><br><span class="line">function download_CAF_CODE() &#123; </span><br><span class="line"># Do repo sanity test </span><br><span class="line">if [ $? -eq 0 ] </span><br><span class="line">then </span><br><span class="line">  echo &quot;Downloading code please wait..&quot; </span><br><span class="line">  repo init -q -u git://codeaurora.org/platform/manifest.git -b release -m $&#123;CAFTAG&#125;.xml </span><br><span class="line">  repo sync -q -c -j 4 --no-tags --no-clone-bundle </span><br><span class="line">  if [ $? -eq 0 ] </span><br><span class="line">  then </span><br><span class="line">    echo -e &quot;$GREEN Downloading done..$ENDCOLOR&quot; </span><br><span class="line">  else </span><br><span class="line">    echo -e &quot;$RED!!!Error Downloading code!!!$ENDCOLOR&quot; </span><br><span class="line">  fi </span><br><span class="line">else </span><br><span class="line">  echo &quot;repo tool problem, make sure you have setup your build environment&quot; </span><br><span class="line">  echo &quot;1) http://source.android.com/source/initializing.html&quot; </span><br><span class="line">  echo &quot;2) http://source.android.com/source/downloading.html (Installing Repo Section Only)&quot; </span><br><span class="line">  exit -1 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to check result for failures </span><br><span class="line">check_result() &#123; </span><br><span class="line">if [ $? -ne 0 ] </span><br><span class="line">then </span><br><span class="line">  echo </span><br><span class="line">  echo -e &quot;$RED FAIL: Current working dir:$(pwd) $ENDCOLOR&quot; </span><br><span class="line">  echo </span><br><span class="line">  exit 1 </span><br><span class="line">else </span><br><span class="line">  echo -e &quot;$GREEN DONE! $ENDCOLOR&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to autoapply patches to CAF code </span><br><span class="line">apply_android_patches() </span><br><span class="line">&#123; </span><br><span class="line">  echo &quot;Applying patches ...&quot; </span><br><span class="line">  if [ ! -e $PATCH_DIR ] </span><br><span class="line">  then </span><br><span class="line">    echo -e &quot;$RED $PATCH_DIR : Not Found $ENDCOLOR&quot; </span><br><span class="line">    return </span><br><span class="line">  fi </span><br><span class="line">  cd $PATCH_DIR </span><br><span class="line">  patch_root_dir=&quot;$PATCH_DIR&quot; </span><br><span class="line">  android_patch_list=$(find . -type f -name &quot;*.patch&quot; | sort) &amp;&amp; </span><br><span class="line">  for android_patch in $android_patch_list; do</span><br><span class="line">    android_project=$(dirname $android_patch) </span><br><span class="line">    echo -e &quot;$YELLOW  applying patches on  $android_project ... $ENDCOLOR&quot; </span><br><span class="line">    cd $BUILDROOT/$android_project </span><br><span class="line">    if [ $? -ne 0 ]; then </span><br><span class="line">      echo -e &quot;$RED $android_project does not exist in BUILDROOT:$BUILDROOT $ENDCOLOR&quot; </span><br><span class="line">      exit 1 </span><br><span class="line">    fi </span><br><span class="line">    git am --3way $patch_root_dir/$android_patch </span><br><span class="line">    check_result </span><br><span class="line">  done </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"># Function to check whether host utilities exists </span><br><span class="line">check_program() &#123; </span><br><span class="line">for cmd in &quot;$@&quot; </span><br><span class="line">do </span><br><span class="line">  which $&#123;cmd&#125; &gt; /dev/null 2&gt;&amp;1 </span><br><span class="line">  if [ $? -ne 0 ] </span><br><span class="line">  then </span><br><span class="line">    echo </span><br><span class="line">    echo -e &quot;$RED Cannot find command \&quot;$&#123;cmd&#125;\&quot;  $ENDCOLOR&quot; </span><br><span class="line">    echo </span><br><span class="line">    exit 1 </span><br><span class="line">  fi </span><br><span class="line">done </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">#Main Script starts here </span><br><span class="line">#Note: Check necessary program for installation </span><br><span class="line">echo </span><br><span class="line">echo -e &quot;$CYAN Product          : $DB_PRODUCT_STRING $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Intrinsyc Release Version : $ITCVER $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA WorkDir          : $WORKDIR $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Build Root        : $BUILDROOT $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA Patch Dir         : $PATCH_DIR $ENDCOLOR&quot; </span><br><span class="line">echo -e &quot;$MAGENTA CodeAurora TAG      : $CAFTAG $ENDCOLOR&quot; </span><br><span class="line">echo -n &quot;Checking necessary program for installation......&quot; </span><br><span class="line">echo </span><br><span class="line">check_program tar repo git patch </span><br><span class="line">if [ -e $BUILDROOT ] </span><br><span class="line">then </span><br><span class="line">  cd $BUILDROOT </span><br><span class="line">else </span><br><span class="line">  mkdir $BUILDROOT </span><br><span class="line">  cd $BUILDROOT </span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">#1 Download code </span><br><span class="line">download_CAF_CODE </span><br><span class="line">cd $BUILDROOT </span><br><span class="line"></span><br><span class="line">#2 Apply Open-Q 845 HDK Development Kit Patches</span><br><span class="line">apply_android_patches </span><br><span class="line"></span><br><span class="line">#3 Extract the proprietary objs </span><br><span class="line">cd $BUILDROOT </span><br><span class="line">echo -e &quot;$YELLOW  Extracting proprietary binary package to $BUILDROOT ... $ENDCOLOR&quot; </span><br><span class="line">tar -xzvf ../proprietary.tar.gz -C vendor/qcom/ </span><br><span class="line"></span><br><span class="line">#4 Build </span><br><span class="line">echo -e &quot;$YELLOW  Building Source code from $BUILDROOT ... $ENDCOLOR&quot; </span><br><span class="line">if [[ -z &quot;$&#123;BUILD_NUMBER&#125;&quot; ]]; then export BUILD_NUMBER=$(date +%m%d%H%M); fi </span><br><span class="line">. build/envsetup.sh </span><br><span class="line">lunch sdm845-$&#123;BV:=&quot;userdebug&quot;&#125; </span><br><span class="line">ITC_ID=Open-Q_845_$&#123;ITCVER&#125; make -j $(nproc) $@ </span><br></pre></td></tr></table></figure>

<p>编译后生成bootloader和系统等镜像：<br>SDA845_Open-Q_845_Android-P_v2.1&#x2F;out&#x2F;target&#x2F;product&#x2F;sdm845&#x2F;xxx.img<br>后续重新编译只需要注释掉<code>./getSource_and_build.sh</code>的<code>步骤#1 #2 #3</code>，保留<code>#4 Build</code></p>
<h2 id="二、-烧写Android镜像"><a href="#二、-烧写Android镜像" class="headerlink" title="二、 烧写Android镜像"></a>二、 烧写Android镜像</h2><h3 id="3-1-烧写、调试、打印的工具"><a href="#3-1-烧写、调试、打印的工具" class="headerlink" title="3.1 烧写、调试、打印的工具"></a>3.1 烧写、调试、打印的工具</h3><p>开发板通过micro USB和type-C USB连接到主机<br>type-C: 用于开发板接收adb&#x2F;fastboot<br>micro USB： 用于HOST接收开发板的输出打印<br>连接如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740889.png" alt="image007"></p>
<p>HOST端用到的工具：<br>fastboot: 用于烧写Android镜像到开发板<br>adb(Android Debug Bridge): 用于调试Android系统<br>secureCRT: 用于查看开发板串口打印<br>- 1 首先配置fastboot和adb到系统环境变量，windows环境下<code>win + R</code>输入<code>cmd</code>配置<code>PATH</code>变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set PATH=%PATH%;d:\platform-tools\adb.exe</span><br><span class="line">set PATH=%PATH%;d:\platform-tools\fastboot.exe</span><br></pre></td></tr></table></figure>
<p>确认adb和fastboot加到了<code>PATH</code>环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo %PATH%</span><br></pre></td></tr></table></figure>
<p>- 2 查看开发板对应的com口，secureCRT新建会话，设置serial，设置com口和波特率115200</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740486.png" alt="image009"></p>
<h3 id="3-2-烧写镜像"><a href="#3-2-烧写镜像" class="headerlink" title="3.2 烧写镜像"></a>3.2 烧写镜像</h3><p>- 1 首先使开发版进入fastboot模式，连接micro USB，电源选项拨到DC电源, 上电后长按vol-, 然后连接type-C，串口打印出现<code>Fastboot: Processing commands</code>则进入fastboot。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281740947.png" alt="image011"><br>- 2 <code>win + R</code>打开<code>cmd</code>，用fastboot烧写编译出来的镜像 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash system system.img </span><br><span class="line">fastboot flash persist persist.img </span><br><span class="line">fastboot flash boot boot.img  </span><br><span class="line">fastboot flash dtbo dtbo.img </span><br><span class="line">fastboot flash vbmeta vbmeta.img </span><br><span class="line">fastboot flash vendor vendor.img </span><br><span class="line">fastboot reboot </span><br></pre></td></tr></table></figure>
<p>可写入flash.bat脚本,放到系统镜像同一目录下运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off </span><br><span class="line"></span><br><span class="line">@echo Reboot bootloader... </span><br><span class="line">adb reboot bootloader </span><br><span class="line"></span><br><span class="line">@echo Flashing device... </span><br><span class="line">fastboot flash system system.img </span><br><span class="line">fastboot flash persist persist.img </span><br><span class="line">fastboot flash boot boot.img </span><br><span class="line">fastboot flash dtbo dtbo.img </span><br><span class="line">fastboot flash vbmeta vbmeta.img </span><br><span class="line">fastboot flash vendor vendor.img </span><br><span class="line"></span><br><span class="line">@echo Flashing finish, rebooting system... </span><br><span class="line">fastboot reboot </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281741449.png" alt="image012"><br>完成后系统重启进入Android桌面。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281741637.png" alt="image014"></p>
]]></content>
      <categories>
        <category>高通平台</category>
      </categories>
      <tags>
        <tag>qcom</tag>
      </tags>
  </entry>
  <entry>
    <title>高通平台 -- QCOM BH202 SDR50 tuning问题记录</title>
    <url>/2025/10/30/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0%20--%20QCOM%20BH202%20SDR50%20tuning%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="QCOM-BH202-SDR50-tuning问题"><a href="#QCOM-BH202-SDR50-tuning问题" class="headerlink" title="QCOM BH202 SDR50 tuning问题"></a>QCOM BH202 SDR50 tuning问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>现象：QCOM+BH202平台，SDR50模式下，Host侧发送tuning CMD19命令处理响应失败(TIMEOUT)，导致无法工作在SDR50模式，BH202驱动log打印wait DLL unlock和CMD19 timeout。其他模式如SDR104模式可以正常工作。</p>
<p>分析：经SD CMD&#x2F;DATA line信号测量，SD card发送了CMD19的响应，问题出在SD Host侧未处理响应。</p>
<p>问题指向SD Host侧在SDR50模式的tuning配置有问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><img src="https://s3.bmp.ovh/imgs/2025/11/04/16c0750eff90aa6f.png" alt="BH202 tuning sdr50.drawio"></p>
<p>如图是SD Host - BH20X bridge - SD card系统。</p>
<p>通常SD Host直连SD card时，SDR50模式host clock &lt;&#x3D;100MHz, 不需要执行SDR50 tuning流程，SDR50 tuning只是可选项。</p>
<p>但是BH20X bridge的数字逻辑要求SDR50模式下也走SDR50 tuning流程，否则SDR50模式无法正常工作。</p>
<p>因此需要修改Host驱动，支持SDR50 tuning，包括两个部分：</p>
<ul>
<li>配置DLL，以支持tuning block所需要的时钟</li>
<li>发送多个(16个) tuning block CMD19命令，解析SD卡响应数据，统计tuning pass相位窗口</li>
</ul>
<p>BH20X驱动也需要适配，调用Host tuning函数时使用高通的tuning流程，而不再直接发tuning block CMD19而不配置DLL。</p>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><p>如下是SDR50 tuning patch，修改点见三处注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/mmc/host/sdhci-bayhub.c b/mmc/host/sdhci-bayhub.c</span><br><span class="line">index 5533d38..762d46c 100644</span><br><span class="line">--- a/mmc/host/sdhci-bayhub.c</span><br><span class="line">+++ b/mmc/host/sdhci-bayhub.c</span><br><span class="line">@@ -2087,7 +2087,7 @@ int sdhci_bht_sdr104_execute_tuning(struct sdhci_host *host, u32 opcode)</span><br><span class="line"> </span><br><span class="line"> int sdhci_bht_sdr50_execute_tuning(struct sdhci_host *host, u32 opcode)</span><br><span class="line"> &#123;</span><br><span class="line">-#ifdef MSM_HOST_USED</span><br><span class="line">+#if 0         /* SDR50 host side tuning使用SDR104一样的入口，即调用qcom的sdhci_msm_execute_tuning */</span><br><span class="line">     u8 phase, *data_buf;</span><br><span class="line">     int size = 64;</span><br><span class="line">     int rc = 0;</span><br><span class="line">@@ -3671,7 +3671,7 @@ void ggc_tuning_result_reset(struct sdhci_host *host)</span><br><span class="line">     vendor_host-&gt;ggc.dll_unlock_reinit_flg = 0;</span><br><span class="line">     vendor_host-&gt;ggc.tuning_cmd7_timeout_reinit_flg = 0;</span><br><span class="line">     vendor_host-&gt;ggc.tuning_cmd7_timeout_reinit_cnt = 0;</span><br><span class="line">-    vendor_host-&gt;ggc.sdr50_notuning_sela_inject_flag = 1;</span><br><span class="line">+    vendor_host-&gt;ggc.sdr50_notuning_sela_inject_flag = 0; /* SDR50不需要指定notuning相位，按高通tuning流程执行即可 */</span><br><span class="line">     vendor_host-&gt;ggc.sdr50_notuning_crc_error_flag = 0;</span><br><span class="line">     vendor_host-&gt;ggc.degrade = 0;</span><br><span class="line"> </span><br><span class="line">diff --git a/mmc/host/sdhci-msm.c b/mmc/host/sdhci-msm.c</span><br><span class="line">index 8da7c4f..5a49b7e 100644</span><br><span class="line">--- a/mmc/host/sdhci-msm.c</span><br><span class="line">+++ b/mmc/host/sdhci-msm.c</span><br><span class="line">@@ -1131,6 +1131,10 @@ static bool sdhci_msm_is_tuning_needed(struct sdhci_host *host)</span><br><span class="line"> &#123;</span><br><span class="line"> 	struct mmc_ios *ios = &amp;host-&gt;mmc-&gt;ios;</span><br><span class="line"> 	</span><br><span class="line"> /* 如果当前模式是SDR50且host flag配置了NEEDS_TUNING，则执行tuning流程（DLL配置和CMD19） </span><br><span class="line"> *	注：BH20X驱动默认配置了host-&gt;flags SDHCI_SDR50_NEEDS_TUNING</span><br><span class="line"> */</span><br><span class="line"> +#ifdef CONFIG_MMC_SDHCI_BH201</span><br><span class="line"> +    if (ios-&gt;timing == MMC_TIMING_UHS_SDR50 &amp;&amp;</span><br><span class="line"> +        host-&gt;flags &amp; SDHCI_SDR50_NEEDS_TUNING)</span><br><span class="line"> +    return true;</span><br><span class="line"> +#endif</span><br><span class="line"> 	/*</span><br><span class="line"> 	 * Tuning is required for SDR104, HS200 and HS400 cards and</span><br><span class="line"> 	 * if clock frequency is greater than 100MHz in these modes.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>高通平台</category>
      </categories>
      <tags>
        <tag>SD/MMC</tag>
      </tags>
  </entry>
  <entry>
    <title>高通平台 -- HDK845开发环境</title>
    <url>/2025/10/30/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0%20--%20Qualcomm%20HDK845%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="Qualcomm-HDK845开发环境"><a href="#Qualcomm-HDK845开发环境" class="headerlink" title="Qualcomm HDK845开发环境"></a>Qualcomm HDK845开发环境</h1><h2 id="初始环境搭建（离线BSP包）"><a href="#初始环境搭建（离线BSP包）" class="headerlink" title="初始环境搭建（离线BSP包）"></a>初始环境搭建（离线BSP包）</h2><p>按SDM845(Open-Q 845 HDK) BSP v2.1 离线编译包中的README操作：</p>
<p>离线包约80GB，不需要翻墙下载android AOSP repo，只需要把Linux PC交叉编译环境搭好就能编译完整系统。</p>
<p>注意Linux系统必须使用Ubuntu18.04，其他版本有apt-get找不到包的问题。</p>
<hr>
<p>本压缩包（<code>Open-Q_845_Android-P_v2.1.offline.tar</code>）在原厂BSP编译包（Open-Q_845_Android-P_v2.1.zip）的基础上包含了CAF源码库，可直接编译，无需再从外网下载代码库。</p>
<p>建议先阅读原厂文档中对应的Programmer’s Guide（PG）, e.g., <code>Intrinsyc Open-Q_845 Development Kit BSP Programmer Guide_v1.0.pdf</code>.</p>
<p>本离线编译包涉及如下非原厂文件：</p>
<ol>
<li><code>./bm_README.txt</code><br>本说明文档。</li>
<li><code>Source_Package/bm_getSource.sh</code><br>该脚本为我们解压完原厂BSP编译包后运行的第一个脚本。它仅仅从CAF下载完代码库。</li>
<li><code>Source_Package/bm_first_build.sh</code><br>该脚本将不再下载代码库，顺序执行：应用Patches， 解压专属代码&#x2F;库，执行编译。 前两步需要且只能执行一次。</li>
<li><code>Source_Package/bm_rebuild.sh</code><br>该脚本仅执行编译。</li>
</ol>
<p>后三个文件，均为在原厂<code>Source_Package/getSource_and_build.sh</code>上简单修改而成。</p>
<p>如下步骤演示了如何使用本压缩包。</p>
<h3 id="创建虚拟机（可选）"><a href="#创建虚拟机（可选）" class="headerlink" title="创建虚拟机（可选）"></a>创建虚拟机（可选）</h3><p>使用如下配置，在 Windows 10 上，使用 VMWare Workstation 创建一个Ubuntu 虚拟机。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">内存：  不低于8GB</span><br><span class="line">处理器：建议内核总数不低于4；建议开启各虚拟引擎选项</span><br><span class="line">硬盘：  不低于300GB</span><br><span class="line">网络适配器： NAT或桥接模式均可</span><br><span class="line">CD/DVD(SATA)：使用 `ubuntu-18.04.3-desktop-amd64.iso`，可从Ubuntu官网下载</span><br></pre></td></tr></table></figure>

<p>虚拟机启动后，安装Ubuntu系统时，使用如下选项：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">语言： English</span><br><span class="line">Apps： Minimal Installation</span><br><span class="line">Other options:</span><br><span class="line">   - [uncheck] Download updates while installing ubuntu</span><br><span class="line">   - [check] Install third-part software ...</span><br><span class="line">Where are you: Shanghai / Hongkong</span><br><span class="line">Your computer&#x27;s name: 比如 `qc`</span><br><span class="line">Pick a username: 请务必先使用`bmx`</span><br></pre></td></tr></table></figure>

<p>安装完，系统启动后，推荐参照如下步骤设置：</p>
<ul>
<li>推荐设置更新源为本地更新源，比如<code>China</code>下的<code>mirrors.tuna.tsinghua.edu.cn</code></li>
<li>推荐通过<code>What&#39;s new in Ubuntu</code>引导界面，设置好Livepatch</li>
<li>执行<code>sudo apt update; sudo apt upgrade -y</code> 后重启系统</li>
<li>完整安装VMWare Tools，包含共享目录功能，之后重启系统</li>
</ul>
<h3 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h3><p>在重启后的Ubuntu中，创建一个内容为如下的脚本，e.g., prep.sh ，并执行它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; Updating system ...&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository -y ppa:git-core/ppa</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; Install libs ...&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install openjdk-8-jdk -y</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y curl ccache automake lzop python-networkx bzip2 libbz2-dev libbz2-1.0 \</span><br><span class="line">  libghc-bzlib-dev squashfs-tools pngcrush schedtool dpkg-dev liblz4-tool optipng maven \</span><br><span class="line">  libc6-dev linux-libc-dev g++-5-multilib libssl-dev zip aria2 bc git net-tools openssh-server</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; Configure GIT ...&quot;</span></span><br><span class="line">git config --global user.name <span class="variable">$USER</span></span><br><span class="line">git config --global user.email <span class="variable">$USER</span>@<span class="variable">$HOSTNAME</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&gt;&gt; Install repo ...&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/bin</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line"><span class="comment">#curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x ~/bin/repo</span><br><span class="line">bash -c <span class="string">&quot;echo &#x27;#added by <span class="variable">$USER</span>, to add repo&#x27; &gt;&gt; ~/.bashrc&quot;</span></span><br><span class="line">bash -c <span class="string">&quot;echo &#x27;export PATH=<span class="variable">$HOME</span>/bin:\$PATH&#x27; &gt;&gt; ~/.bashrc&quot;</span></span><br><span class="line"><span class="comment">#bash -c &quot;echo &#x27;export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;&#x27; &gt;&gt; ~/.bashrc&quot;</span></span><br></pre></td></tr></table></figure>

<p>之后，在终端中执行 <code>source ~/.bashrc</code> 来使 <code>repo</code> 命令生效。</p>
<p>下面，在VMWare Workstation 的虚拟机设置的 <code>选项</code> -&gt; <code>共享文件夹</code> 中，将本离线包（<code>Open-Q_845_Android-P_v2.1.offline.tar</code>）所在的Windows目录 <code>添加</code> 到 <code>文件夹（F）</code>中。<br>这里假设该目录的 <code>名称（N）</code>为 <code>WinDownloads</code>。</p>
<p>之后，在终端中依次执行如下指令将离线包解压到Ubuntu系统中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/openq</span><br><span class="line"><span class="built_in">cd</span> ~/openq</span><br><span class="line">tar xvf /mnt/hgfs/WinDownloads/Open-Q_845_Android-P_v2.1.offline.tar</span><br></pre></td></tr></table></figure>

<h3 id="首次编译系统镜像"><a href="#首次编译系统镜像" class="headerlink" title="首次编译系统镜像"></a>首次编译系统镜像</h3><p>解压完后，请执行如下命令来进行首次编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/openq/Open-Q_845_Android-P_v2.1/Source_Package/</span><br><span class="line">./bm_first_build.sh</span><br></pre></td></tr></table></figure>

<p>首次编译会需 5~6 个小时，视Ubuntu硬件配置不同。编译成功后，终端会有如下<code>build completed successfully</code>字样的绿色输出，提示编译顺利结束：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[100% 777/777] Target vbmeta image: out/target/product/sdm845/vbmeta.img</span><br><span class="line"></span><br><span class="line">#### build completed successfully (08:25 (mm:ss)) ####</span><br></pre></td></tr></table></figure>

<p>新编译好的镜像位于 <code>Source_Package/SDA845_Open-Q_845_Android-P_v2.1/out/target/product/sdm845</code> 目录下。</p>
<p>后续可参考 PG 或 <code>README.txt</code> 中的说明来烧录新编译的镜像。</p>
<h3 id="重新编译镜像"><a href="#重新编译镜像" class="headerlink" title="重新编译镜像"></a>重新编译镜像</h3><p>客户在自己定制系统镜像时，做完定制功能的代码修订后，请进入到<code>Source_Package</code>目录后执行<code>./bm_rebuild.sh</code>即可重新编译镜像。<br>选择性&#x2F;部分&#x2F;增量编译和烧录，请参见PG中的说明或原脚本。</p>
<p><strong>请勿再执行<code>./bm_first_build.sh</code>脚本来重新编译镜像。</strong></p>
<h2 id="HDK845的镜像烧录"><a href="#HDK845的镜像烧录" class="headerlink" title="HDK845的镜像烧录"></a>HDK845的镜像烧录</h2><h3 id="平台环境准备"><a href="#平台环境准备" class="headerlink" title="平台环境准备"></a>平台环境准备</h3><p>开发板通过micro USB和type-C USB连接到主机<br>type-C: 用于开发板接收Adb&#x2F;fastboot指令<br>micro USB：用于HOST PC接收开发板的输出打印<br>按键和连接如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091608737.png" alt="图片1"></p>
<h3 id="使用ADB烧录镜像（Linux）"><a href="#使用ADB烧录镜像（Linux）" class="headerlink" title="使用ADB烧录镜像（Linux）"></a>使用ADB烧录镜像（Linux）</h3><p>编译完需要用ADB USB-C烧录img镜像文件。</p>
<p>（1）设置Linux PC的ADB USB驱动，参考官方README 5.1 Setting up ADB in Linux。</p>
<p>（2）正确调用flashall.sh执行烧录</p>
<p>为了一键编译和烧录，创建了flash_img.sh脚本。必须用source或 . 执行脚本否则pwd路径错误。</p>
<p>脚本记录了进fastboot模式的注意事项，必须先boot到fastboot模式，再插USB-C ADB线。</p>
<p>flash_img.sh:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># How to use this script:</span><br><span class="line"># 1.power on HDK845 with vol- key pressed, enter fastboot mode(HDK845 screen show RECOVERY MODE/Other modes...). notice: do not connect type-C usb fastboot cable for now, otherwise cannot enter fastboot.</span><br><span class="line"># 2.Then connect type-C usb fastboot cable to this PC. use &#x27;lsusb&#x27; to find HDK845 fastboot device(ID 18d1:d00d Google Inc.)</span><br><span class="line"># 3.run this script with source or . command, the flash command resule shall print on terminal.</span><br><span class="line"># 4.HDK845 shall reboot in normal mode, capture micro-USB&#x27;s serial print log with putty or xshell, the type-C fastboot cable does not affect normal boot.</span><br><span class="line"></span><br><span class="line">cd ./SDA845_Open-Q_845_Android-P_v2.1/out/target/product/sdm845</span><br><span class="line">$(pwd)/flashall.sh</span><br><span class="line">cd -</span><br></pre></td></tr></table></figure>

<p>烧录过充如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091551743.png" alt="image-20250409155137702"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091554925.png" alt="image-20250409155422892"></p>
<p>out目录flashall.sh的内容是执行当前目录下img的烧录，并重启</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091555100.png" alt="image-20250409155512053"></p>
<h3 id="使用ADB烧录镜像（Windows）"><a href="#使用ADB烧录镜像（Windows）" class="headerlink" title="使用ADB烧录镜像（Windows）"></a>使用ADB烧录镜像（Windows）</h3><p>使用Windows ADB USB驱动需要bcdedit打开测试模式才能装Windows ADB USB驱动，装完后设备管理器可看到ADB设备</p>
<p>- 1 首先使开发版进入fastboot模式，连接micro USB，电源选项拨到DC电源, 上电后长按vol-, 然后连接type-C，串口打印出现<code>Fastboot: Processing commands</code>则进入fastboot。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091613766.jpg" alt="img"><br>- 2 <code>win + R</code>打开<code>cmd</code>，用fastboot烧写编译出来的镜像<br>`&#96;&#96;<br>fastboot flash system system.img<br>fastboot flash persist persist.img<br>fastboot flash boot boot.img<br>fastboot flash dtbo dtbo.img<br>fastboot flash vbmeta vbmeta.img<br>fastboot flash vendor vendor.img<br>fastboot reboot<br>`&#96;&#96;<br>可写入flash.bat脚本,放到系统镜像同一目录下运行<br>`&#96;&#96;<br>@echo off </p>
<p>@echo Reboot bootloader…<br>adb reboot bootloader </p>
<p>@echo Flashing device…<br>fastboot flash system system.img<br>fastboot flash persist persist.img<br>fastboot flash boot boot.img<br>fastboot flash dtbo dtbo.img<br>fastboot flash vbmeta vbmeta.img<br>fastboot flash vendor vendor.img </p>
<p>@echo Flashing finish, rebooting system…<br>fastboot reboot<br>`&#96;&#96;<br>完成后系统重启进入Android桌面。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091613776.jpg" alt="img"> </p>
<h3 id="HDK845官方README"><a href="#HDK845官方README" class="headerlink" title="HDK845官方README"></a>HDK845官方README</h3><hr>
<ol>
<li>Introduction<br>This release is intended to use for Intrinsyc Open-Q 845 HDK Development Kit.<br>This release uses the standard Codeaurora.org source code as open source development environment.</li>
</ol>
<p>Please make sure to use the Release notes.</p>
<ol start="2">
<li><p>Scope<br>This document assumes prior knowledge of Android source build process.<br>The board comes with preprogrammed boot-loader and Android 9.0.0.<br>User can program from bootloader to all images on target.</p>
</li>
<li><p>Directory structure</p>
</li>
</ol>
<p>Open-Q_845_Android-P_v2.1<br>|– Binaries  —————————————-Prebuilt Binaries<br>|   |– boot.img  ———————————–Linux kernel and ramdisk<br>|   |– dtbo.img  ———————————–Linux kernel device tree overlay<br>|   |– flashall.bat  ———————————Windows batch file to autoload&#x2F;program images using fastboot<br>|   |– flashall.sh  ———————————-Linux shell script to autoload&#x2F;program images using fastboot<br>|   |– persist.img  ——————————Android persist partition<br>|   |– system.img  ——————————–Android core OS partition<br>|   |– vbmeta.img  ——————————–Android VBMeta partition<br>|   <code>-- vendor.img  --------------------------------Android vendor partition | |-- README.txt  --------------------------------------This document | |-- usb_driver/  -------------------------------------Windows USB driver |    |-- amd64/ |    |   |-- NOTICE.txt |    |   |-- WdfCoInstaller01009.dll |    |   |-- winusbcoinstaller2.dll |    |   </code>– WUDFUpdate_01009.dll<br>|    |– androidwinusb86.cat<br>|    |– androidwinusba64.cat<br>|    |– android_winusb.inf<br>|    |– i386&#x2F;<br>|    |   |– NOTICE.txt<br>|    |   |– WdfCoInstaller01009.dll<br>|    |   |– winusbcoinstaller2.dll<br>|    |   <code>-- WUDFUpdate_01009.dll |    </code>– source.properties<br>|<br>|<br>|<br><code>-- Source_Package  ----------------------------------Source code patches     |-- getSource_and_build.sh  ----------------------Main download and build script     |-- proprietary.tar.gz  --------------------------Qualcomm Proprietary Binaries     </code>– patches  ————————————-Patches for Open-Q 845 support</p>
<ol start="4">
<li>How to use this release</li>
</ol>
<p>4.1 Setup the Android build environment for Android Source code build.</p>
<p>4.2 Copy Source Package to build &#x2F; work directory.<br>Note: Before proceeding make sure your internet connection is fine to download code from Code Aurora, and you have necessary hard-disk space.<br>For complete compilation minimum 100GB free space is recommended.</p>
<p>4.3 Copy the Source_Package to build machine.</p>
<p>4.5 Use following commands to compile the source code</p>
<p>user@builmachine$ cd Source_Package<br>user@builmachine$ chmod +x getSource_and_build.sh<br>user@builmachine$i .&#x2F;getSource_and_build.sh<br>The script downloads the source code from codeaurora.org and starts the build process.</p>
<p>4.6 If download and compilation fails script will report error, otherwise you will get the compiled binaries under<br>…&#x2F;out&#x2F;target&#x2F;product&#x2F;sdm845<br>		– boot.img  ————————————Linux kernel and ramdisk<br>		– dtbo.img  ————————————Linux device tree overlay<br>		– system.img  ———————————-Android core OS partition<br>		– userdata.img  ——————————–Android User data partition<br>		– vbmeta.img  ——————————–Android VBMeta partition<br>		– vendor.img  ——————————–Android vendor partition</p>
<p><strong>To program these images,  connect micro USB cable to target and copy flashall.sh to …&#x2F;out&#x2F;target&#x2F;product&#x2F;sdm845&#x2F;</strong><br><strong>And run the script as below:</strong></p>
<p> <strong>.&#x2F;flashall.sh this will program the image and reboot the device.</strong></p>
<ol start="5">
<li>Setting up adb for devices</li>
</ol>
<p><strong>5.1 Setting up ADB in Linux</strong></p>
<p><strong>5.1.1.1 Setup the Android SDK for adb binaries or use the build terminal</strong><br>      <strong>Create file etc&#x2F;udev&#x2F;rules.d&#x2F;51-android.rules with following lines</strong><br>      <strong>#for Fastboot bootloader interface</strong><br>      <strong>SUBSYSTEM&#x3D;&#x3D;”usb”, ATTR{idVendor}&#x3D;&#x3D;”18d1”, MODE&#x3D;”0777”, GROUP&#x3D;”adm”</strong><br>      <strong>#for Device adb interface</strong><br>      <strong>SUBSYSTEM&#x3D;&#x3D;”usb”, ATTR{idVendor}&#x3D;&#x3D;”05c6”, MODE&#x3D;”0777”, GROUP&#x3D;”adm”</strong></p>
<p>5.1.2 Reboot Linux machine and connect devices with micro USB cable<br>Make sure adb binary is in the path or you are in the build terminal</p>
<p>5.2 Setting up ADB in Windows<br>Download Android SDK Platform-Tools for Windows.<br><a href="https://developer.android.com/studio/releases/platform-tools.html">https://developer.android.com/studio/releases/platform-tools.html</a></p>
<p>You only need to download Android SDK Platform-Tools and Google USB Driver, if you just want to play with the phone. If you plan to develop apps, install also the API of your choice and Eclipse Classic (this is the recommended version by Google devs).</p>
<p>To make available everywhere your platform tools (adb, fastboot, etc.), add your platform-tools directory to Path:<br>Connect USB cable to target.</p>
<p>Device will appear as Android and install the drivers from usb_driver folder.</p>
<p>Please note:<br>Default there are 4 functional interfaces created only one is ADB other are used as diagnostic purpose (QPST, MDM, DIAG, MASS STORAGE).<br>Only one endpoint with following is applicable for ADB.<br>Your android_winusb.inf file should have below lines ADB.<br>android_winusb.inf<br>[Google.NTx86]<br>;Qualcomm SURF&#x2F;FFA<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9025<br>%CompositeAdbInterface%     &#x3D; USB_Install, USB\VID_05C6&amp;PID_9025&amp;MI_01<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9025<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9025&amp;MI_01</p>
<p>;Qualcomm SURF&#x2F;FFA (PTP+ADB)<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_904E<br>%CompositeAdbInterface%     &#x3D; USB_Install, USB\VID_05C6&amp;PID_904E&amp;MI_01<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_904E<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_904E&amp;MI_01</p>
<p>;Qualcomm SURF&#x2F;FFA (MTP+ADB)<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9039<br>%CompositeAdbInterface%     &#x3D; USB_Install, USB\VID_05C6&amp;PID_9039&amp;MI_01<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9039<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9039&amp;MI_01</p>
<p>;Qualcomm SURF&#x2F;FFA (UMS+ADB)<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9015<br>%CompositeAdbInterface%     &#x3D; USB_Install, USB\VID_05C6&amp;PID_9015&amp;MI_00<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9015<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9015&amp;MI_00<br>[Google.NTamd64]<br>;Qualcomm SURF&#x2F;FFA<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9025<br>%CompositeAdbInterface%     &#x3D; USB_Install, USB\VID_05C6&amp;PID_9025&amp;MI_01<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9025</p>
<p>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9025&amp;MI_01</p>
<p>;Qualcomm SURF&#x2F;FFA (PTP+ADB)<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_904E<br>%CompositeAdbInterface%     &#x3D; USB_Install, USB\VID_05C6&amp;PID_904E&amp;MI_01<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_904E<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_904E&amp;MI_01</p>
<p>;Qualcomm SURF&#x2F;FFA (MTP+ADB)<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9039<br>%CompositeAdbInterface%     &#x3D; USB_Install, USB\VID_05C6&amp;PID_9039&amp;MI_01<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9039<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9039&amp;MI_01</p>
<p>;Qualcomm SURF&#x2F;FFA (UMS+ADB)<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9015<br>%CompositeAdbInterface%     &#x3D; USB_Install, USB\VID_05C6&amp;PID_9015&amp;MI_00<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9015<br>%SingleAdbInterface%        &#x3D; USB_Install, USB\VID_05C6&amp;PID_9015&amp;MI_00</p>
<p>[Strings]<br>SingleAdbInterface &#x3D; “Android ADB Interface”<br>CompositeAdbInterface &#x3D; “Android Composite ADB Interface”<br>SingleBootLoaderInterface &#x3D; “Android Bootloader Interface”</p>
<p>When you see a Windows pop-up requesting drivers, provide the usb_driver folder path. Other device notifications from Windows should be ignored.</p>
<p>Each time you change your USB connection type from the Android Settings APP, you will see one time installation pop-up requesting for ADB driver to be installed,  provide the usb_driver folder.</p>
<h2 id="代码更新、编译、下载、日志"><a href="#代码更新、编译、下载、日志" class="headerlink" title="代码更新、编译、下载、日志"></a>代码更新、编译、下载、日志</h2><h3 id="代码更新"><a href="#代码更新" class="headerlink" title="代码更新"></a>代码更新</h3><p>Windows PC的VSCode Remote远程改Linux PC上的代码包，配置ssh ip为Linux Host的IP</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091529645.png" alt="image-20250409152929578"></p>
<h3 id="重新编译和下载img"><a href="#重新编译和下载img" class="headerlink" title="重新编译和下载img"></a>重新编译和下载img</h3><p>见1.4和2.2节。</p>
<p><code>Source_Package</code>目录执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bm_rebuild.sh</span><br></pre></td></tr></table></figure>

<p>拔ADB线，按vol- 启动平台进入测试模式，再插ADB线，才可以下载img</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source flash_img.sh</span><br></pre></td></tr></table></figure>

<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>下载完毕重启，即可通过microUSB的输出查看日志</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091525317.png" alt="image-20250409152530246"></p>
<h2 id="附录-安卓编译生态"><a href="#附录-安卓编译生态" class="headerlink" title="附录-安卓编译生态"></a>附录-安卓编译生态</h2><p>高通平台HDK845推荐的编译环境如下：</p>
<table>
<thead>
<tr>
<th>HOST</th>
<th>Toolchain</th>
<th>Source code repository</th>
<th>build out Android version</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu14.04&#x2F;16.04&#x2F;18.04 LTS</td>
<td>Clang&#x2F;LLVM</td>
<td>CAF</td>
<td>support Android 9 Pie</td>
</tr>
</tbody></table>
<p>理论上支持android编译的环境：</p>
<table>
<thead>
<tr>
<th>HOST</th>
<th>Linux 稳定发行版（ubuntu&#x2F;centOS&#x2F;…）</th>
</tr>
</thead>
<tbody><tr>
<td>Hard Disk</td>
<td>size &gt; 200GB</td>
</tr>
<tr>
<td>Memory</td>
<td>Memory size &gt; 8GB</td>
</tr>
<tr>
<td>CPU</td>
<td>无严格要求，最好Core &gt; 4 Frequency &gt; 3.0GHz</td>
</tr>
</tbody></table>
<p><em><strong>*Clang和LLVM的关系*</strong></em>：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091619044.png" alt="img"></p>
<p><em><strong>*CAF和ASOP的关系*</strong></em></p>
<p>CAF is <em><strong>*Code Aurora repository.*</strong></em> It’s the place where Qualcomm releases source code for their phone processors. It’s directly supported by Qualcomm and it’s generally a more optimized branch for Snapdragon phones.</p>
<p>Actually, there are two main baselines for support of Qualcomm devices:</p>
<p><em><strong>*CodeAurora (CAF)*</strong></em> - These are Qualcomm’s reference sources for their platform. This is what they provide to OEMs, and what nearly all OEMs base their software off of. As a result - nearly all non-Nexus devices are running kernels&#x2F;display HALs&#x2F;etc. that are derived from a CAF baseline.</p>
<p><em><strong>*Google’s software baseline*</strong></em>, or <em><strong>*AOSP*</strong></em> - Usually when Google starts working on a new Android version, they’ll fork from CAF at the beginning. Very often Google will be adding “new” features specific to the new Android version, while Qualcomm will continue with performance enhancements and bugfixes against the “old” baseline.</p>
<p>So when a new Android revision comes out, you have two baselines: CAF which is usually “ahead” in performance but “behind” in features, while AOSP is “behind” in performance (relatively) but “ahead” in features.</p>
<p>Nowadays, developers are directly compiling the builds from CAF source code which is really difficult as this is what Google does initially before upgrading to a new version, and then they add features and the source by the time gets ‘compilable’, it is easier to compile the one on Google Sources than the one which is there on CAF.</p>
<p>CAF can be considered as Vanilla version of a Vanilla version of Android.</p>
<p><em><strong>*在线下载和编译的流程：*</strong></em></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091617471.png" alt="img"></p>
<h2 id="附录-交叉编译概念"><a href="#附录-交叉编译概念" class="headerlink" title="附录-交叉编译概念"></a>附录-交叉编译概念</h2><h3 id="本地编译和交叉编译"><a href="#本地编译和交叉编译" class="headerlink" title="本地编译和交叉编译"></a>本地编译和交叉编译</h3><p>本地编译</p>
<p>本地编译可以理解为，在当前编译平台下，编译出来的程序只能放到当前平台下运行。平时我们常见的软件开发，都是属于本地编译：</p>
<p>比如，在 x86 平台上编写程序并编译成可执行程序。这种方式下，我们使用 x86 平台上的工具，开发针对 x86 平台本身的可执行程序，这个编译过程称为本地编译。</p>
<p>交叉编译</p>
<p>交叉编译可以理解为，在当前编译平台下，编译出来的程序能运行在体系结构不同的另一种目标平台上，但是编译平台本身却不能运行该程序：</p>
<p>比如，在 x86 平台上，编写程序并编译成能运行在 ARM 平台的程序，编译得到的程序在 x86 平台上是不能运行的，必须放到 ARM 平台上才能运行。</p>
<h3 id="交叉编译工具链"><a href="#交叉编译工具链" class="headerlink" title="交叉编译工具链"></a>交叉编译工具链</h3><p>常见的编译过程如下图。编译过程包括了预处理、编译、汇编、链接等功能。每个子功能都是一个单独的工具来实现，它们合在一起形成了一个完整的工具集。</p>
<p>****交叉编译链****就是为了编译跨平台体系结构的程序代码而形成的由多个子工具构成的一套完整的工具集。同时，它隐藏了预处理、编译、汇编、链接等细节，当我们指定了源文件时，它会自动按照编译流程调用不同的子工具，自动生成最终的二进制程序映像。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091622780.png" alt="image-20250409162245746"> </p>
<p>如上图，交叉编译工具链中最主要的部分包含编译器（如gcc）,汇编器（如as）,连接器（如ld）。通常as和ld及objcopy等其他工具由GNU打包成了binutils（binary utilitys）工具，再加上编译器组成整个工具链。</p>
<p>交叉编译工具链中编译器的命名规则，以如下为例</p>
<p>arm-linux-androideabi-gcc</p>
<p>arm-linux-gnueabihf-clang</p>
<p>命名规则为：</p>
<p><em><strong>*arch-core-kernel-system-compiler*</strong></em></p>
<p>arch：目标平台架构，如arm, x86_64。</p>
<p>core： 目标平台的CPU Core，如Cortex A8</p>
<p>kernel： 目标平台所运行的OS，如Linux，Android，bare（无OS）。</p>
<p>systen：交叉编译链所选择的库函数和目标系统的规范，如gnu，gnueabi等。</p>
<p>compiler: 编译器名，如gcc, g++,clang,clang++</p>
<p>ABI：二进制应用程序接口(Application Binary Interface (ABI) for the ARM Architecture)。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。</p>
<p>EABI：嵌入式ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。</p>
<p>两者主要区别是，ABI是计算机上的，EABI是嵌入式平台上（如ARM，MIPS等）。</p>
<h3 id="交叉编译架构"><a href="#交叉编译架构" class="headerlink" title="交叉编译架构"></a>交叉编译架构</h3><p>HOST OS 通常为Linux，包含自身的kernel、glibc基础库和Target程序的依赖库。Toolchain包含C&#x2F;C++及其他语言编译器和汇编、链接器等组件。Toolchain依赖于HOST的glibc基础库。Target binary是编译出的目标镜像&#x2F;程序，编译过程依赖于Toolchain及HOST的build essential libs。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504091623366.png" alt="img"></p>
]]></content>
      <categories>
        <category>高通平台</category>
      </categories>
      <tags>
        <tag>qcom</tag>
      </tags>
  </entry>
  <entry>
    <title>高通平台 -- sdhci dts分析</title>
    <url>/2025/10/30/%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0%20--%20Qualcomm%20sdhci%20dts%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Qualcomm-sdhci-dts分析"><a href="#Qualcomm-sdhci-dts分析" class="headerlink" title="Qualcomm sdhci dts分析"></a>Qualcomm sdhci dts分析</h1><h2 id="clocks部分"><a href="#clocks部分" class="headerlink" title="clocks部分"></a>clocks部分</h2><p>sc7280.dtsi中，sdhc的clocks属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 定义clocks数组，包含三个时钟的值 */</span><br><span class="line">clocks = &lt;&amp;gcc GCC_SDCC1_AHB_CLK&gt;, /* 第一个值，见gcc对象数组的索引GCC_SDCC1_AHB_CLK的成员的值 */</span><br><span class="line">		&lt;&amp;gcc GCC_SDCC1_APPS_CLK&gt;, /* 第二个值，见...对象的...成员的值 */</span><br><span class="line">		&lt;&amp;rpmhcc RPMH_CXO_CLK&gt;; /* 第三个值，见rpmhcc对象数组的索引RPMH_CXO_CLK的成员的值 */</span><br><span class="line">clock-names = &quot;iface&quot;, &quot;core&quot;, &quot;xo&quot;;  /* 以上三个clocks的数组成员，分别命名, 例如&quot;xo&quot;就对应第三个值 */</span><br></pre></td></tr></table></figure>

<p>以”xo”这个clock为例，看下这个clock值到底是多少。</p>
<p>首先找&amp;rpmhcc这个对象，这里有隐藏知识：rpmhcc是个”Clock providers”对象，一定是用”clock别名: clock-controller”的格式定义，在当前SOC dts搜索“rpmhcc: clock-controller”就直接找到其定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpmhcc: clock-controller &#123;</span><br><span class="line">    compatible = &quot;qcom,sc7280-rpmh-clk&quot;; /* 这里很重要！ */</span><br><span class="line">    clocks = &lt;&amp;xo_board&gt;; /* rpmhcc的clocks源是xo_board */</span><br><span class="line">    clock-names = &quot;xo&quot;; /* 当前clock别名xo */</span><br><span class="line">    #clock-cells = &lt;1&gt;; /* 有两个clock输入(cells是0-based)，即xo_board应该有两组值 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里很奇怪：</p>
<ol>
<li>rpmhcc没有定义regs，即没有直接定义他提供的时钟的值数值</li>
<li>compatible是干吗用的？</li>
</ol>
<p>原因见下图，clock provider提供的时钟值，是compatible指定的代码里面定义的！</p>
<p><img src="https://img-blog.csdnimg.cn/20190215150254844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0MjMwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>rpmhcc本身的clocks源是xo_board对象，这里#clock-cells &#x3D; &lt;1&gt;是表示rpmhcc clocks被几个消费者使用（输出几路时钟），0-based，#clock-cells &#x3D; &lt;0&gt; 表示只有一个成员。</p>
<p>搜索driver&#x2F;clk&#x2F;qcom找rpmh时钟的源文件：</p>
<p>linux-6.7\drivers\clk\qcom\clk-rpmh.c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const struct of_device_id clk_rpmh_match_table[] = &#123;</span><br><span class="line">	&#123; .compatible = &quot;qcom,qdu1000-rpmh-clk&quot;, .data = &amp;clk_rpmh_qdu1000&#125;,</span><br><span class="line">	&#123; .compatible = &quot;qcom,sa8775p-rpmh-clk&quot;, .data = &amp;clk_rpmh_sa8775p&#125;,</span><br><span class="line">	&#123; .compatible = &quot;qcom,sc7180-rpmh-clk&quot;, .data = &amp;clk_rpmh_sc7180&#125;,</span><br><span class="line">	....</span><br><span class="line">	&#123; .compatible = &quot;qcom,sc7280-rpmh-clk&quot;, .data = &amp;clk_rpmh_sc7280&#125;,</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct clk_rpmh_desc clk_rpmh_sc7280 = &#123;</span><br><span class="line">	.clks = sc7280_rpmh_clocks,</span><br><span class="line">	.num_clks = ARRAY_SIZE(sc7280_rpmh_clocks),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct clk_hw *sc7280_rpmh_clocks[] = &#123;</span><br><span class="line">	[RPMH_CXO_CLK]      = &amp;clk_rpmh_bi_tcxo_div4.hw,</span><br><span class="line">	[RPMH_CXO_CLK_A]    = &amp;clk_rpmh_bi_tcxo_div4_ao.hw,</span><br><span class="line">	[RPMH_LN_BB_CLK2]   = &amp;clk_rpmh_ln_bb_clk2_a2.hw,</span><br><span class="line">	[RPMH_LN_BB_CLK2_A] = &amp;clk_rpmh_ln_bb_clk2_a2_ao.hw,</span><br><span class="line">	[RPMH_RF_CLK1]      = &amp;clk_rpmh_rf_clk1_a.hw,</span><br><span class="line">	[RPMH_RF_CLK1_A]    = &amp;clk_rpmh_rf_clk1_a_ao.hw,</span><br><span class="line">	[RPMH_RF_CLK3]      = &amp;clk_rpmh_rf_clk3_a.hw,</span><br><span class="line">	[RPMH_RF_CLK3_A]    = &amp;clk_rpmh_rf_clk3_a_ao.hw,</span><br><span class="line">	[RPMH_RF_CLK4]      = &amp;clk_rpmh_rf_clk4_a.hw,</span><br><span class="line">	[RPMH_RF_CLK4_A]    = &amp;clk_rpmh_rf_clk4_a_ao.hw,</span><br><span class="line">	[RPMH_IPA_CLK]      = &amp;clk_rpmh_ipa.hw,</span><br><span class="line">	[RPMH_PKA_CLK]      = &amp;clk_rpmh_pka.hw,</span><br><span class="line">	[RPMH_HWKM_CLK]     = &amp;clk_rpmh_hwkm.hw,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中”qcom,sc7280-rpmh-clk”最终data是sc7280_rpmh_clocks[]数组，因此按index RPMH_CXO_CLK拿到的值是&amp;clk_rpmh_bi_tcxo_div4.hw</p>
<p>这个值到底是多少？</p>
<p>最后看下rpmhcc的上游：xo_board对象：</p>
<p>xo_board有两个clocks源：xo_board和sleep_clk，这里的clock-frequency是是固定晶振时钟，整个时钟树的最上游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clocks &#123;</span><br><span class="line">    xo_board: xo-board &#123;</span><br><span class="line">        compatible = &quot;fixed-clock&quot;;</span><br><span class="line">        clock-frequency = &lt;76800000&gt;;</span><br><span class="line">        #clock-cells = &lt;0&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	sleep_clk: sleep-clk &#123;</span><br><span class="line">        compatible = &quot;fixed-clock&quot;;</span><br><span class="line">        clock-frequency = &lt;32000&gt;;</span><br><span class="line">        #clock-cells = &lt;0&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&lt;&amp;rpmhcc RPMH_CXO_CLK&gt;中的index RPMH_CXO_CLK是哪个值，在SOC dts头文件可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;dt-bindings/clock/qcom,rpmh.h&gt;</span><br></pre></td></tr></table></figure>

<p>去kernel&#x2F;include的dt-bindings&#x2F;clock&#x2F;qcom,rpmh.h查找到是0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* RPMh controlled clocks */</span><br><span class="line">#define RPMH_CXO_CLK				0 </span><br><span class="line">#define RPMH_CXO_CLK_A				1</span><br><span class="line">#define RPMH_LN_BB_CLK2				2</span><br><span class="line">#define RPMH_LN_BB_CLK2_A			3</span><br></pre></td></tr></table></figure>

<p>这个头文件是厂商自定义的索引，其实没必要关系具体值是多少。</p>
<p>看下xo clock在sdhci代码怎么用的：sdhci-msm.c的probe函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* devm_clk_get是获取clock dts的API，此处获取别名未&quot;xo&quot;的clock值 */</span><br><span class="line">msm_host-&gt;xo_clk = devm_clk_get(&amp;pdev-&gt;dev, &quot;xo&quot;);</span><br><span class="line">if (IS_ERR(msm_host-&gt;xo_clk)) &#123;</span><br><span class="line">    ret = PTR_ERR(msm_host-&gt;xo_clk);</span><br><span class="line">    dev_warn(&amp;pdev-&gt;dev, &quot;TCXO clk not present (%d)\n&quot;, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dts clock参考：<a href="https://blog.csdn.net/weixin_43542305/article/details/87363277">设备树中时钟的使用</a></p>
<p>下面看下core这个clock，和xo clock不一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clocks = &lt;&amp;gcc GCC_SDCC2_AHB_CLK&gt;,</span><br><span class="line">        &lt;&amp;gcc GCC_SDCC2_APPS_CLK&gt;, /* core对应的clock */</span><br><span class="line">        &lt;&amp;rpmhcc RPMH_CXO_CLK&gt;;</span><br><span class="line">clock-names = &quot;iface&quot;, &quot;core&quot;, &quot;xo&quot;;</span><br></pre></td></tr></table></figure>

<p>GCC_SDCC2_APPS_CLK在当前SOC的qcom,gcc-sc7280.h是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define GCC_SDCC2_APPS_CLK				114</span><br></pre></td></tr></table></figure>

<p>gcc: clock-controller内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc: clock-controller@100000 &#123;</span><br><span class="line">compatible = &quot;qcom,gcc-sc7280&quot;;</span><br><span class="line">reg = &lt;0 0x00100000 0 0x1f0000&gt;;</span><br><span class="line">clocks = &lt;&amp;rpmhcc RPMH_CXO_CLK&gt;,</span><br><span class="line">	&lt;&amp;rpmhcc RPMH_CXO_CLK_A&gt;, &lt;&amp;sleep_clk&gt;,</span><br><span class="line">	&lt;0&gt;, &lt;&amp;pcie1_phy&gt;,</span><br><span class="line">	&lt;0&gt;, &lt;0&gt;, &lt;0&gt;,</span><br><span class="line">	&lt;&amp;usb_1_qmpphy QMP_USB43DP_USB3_PIPE_CLK&gt;;</span><br><span class="line">clock-names = &quot;bi_tcxo&quot;, &quot;bi_tcxo_ao&quot;, &quot;sleep_clk&quot;,</span><br><span class="line">	&quot;pcie_0_pipe_clk&quot;, &quot;pcie_1_pipe_clk&quot;,</span><br><span class="line">	&quot;ufs_phy_rx_symbol_0_clk&quot;, &quot;ufs_phy_rx_symbol_1_clk&quot;,</span><br><span class="line">	&quot;ufs_phy_tx_symbol_0_clk&quot;,</span><br><span class="line">	&quot;usb3_phy_wrapper_gcc_usb30_pipe_clk&quot;;</span><br><span class="line">#clock-cells = &lt;1&gt;;</span><br><span class="line">#reset-cells = &lt;1&gt;;</span><br><span class="line">#power-domain-cells = &lt;1&gt;;</span><br><span class="line">power-domains = &lt;&amp;rpmhpd SC7280_CX&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重点看下reg &#x3D; &lt;0 0x00100000 0 0x1f0000&gt;;</p>
<p>一般reg都是<code>&lt;address size&gt;</code>，这里怎么定义了两个从0开始的空间，size还不一样？</p>
<p>这是因为此SOC dts使用的是双32bit（64bit）定义，见SOC dts开头的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#address-cells = &lt;2&gt;; /* address使用两个cell，每个cell 32bit表示地址 */</span><br><span class="line">#size-cells = &lt;2&gt;; /* size使用两个cell，每个cell 32bit表示地址 */</span><br></pre></td></tr></table></figure>

<p>因此”0 0x00100000”是高位为0，低位为0x00100000，这就是address；”0 0x00100000”也是同理， 0x00100000就是address。</p>
<p>下面看下gcc: clock-controller@100000 的compatible有没有data：</p>
<p>linux-6.7\drivers\clk\qcom\gcc-sc7280.c：没有定义data，因此这个clock的值是reg区间定义的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const struct of_device_id gcc_sc7280_match_table[] = &#123;</span><br><span class="line">	&#123; .compatible = &quot;qcom,gcc-sc7280&quot; &#125;,</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了确保这个理解正确，全局搜索一下”qcom,gcc-sc7280”，没有其他位置有data，有个示例文档：</p>
<p>linux-6.7\linux-6.7\Documentation\devicetree\bindings\clock\qcom,gcc-sc7280.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clock-controller@100000 &#123;</span><br><span class="line">  compatible = &quot;qcom,gcc-sc7280&quot;;</span><br><span class="line">  reg = &lt;0x00100000 0x1f0000&gt;;</span><br></pre></td></tr></table></figure>

<p>进一步验证了之前分析的address和size使用双32bit定义。</p>
<p>结论：”core” clock的值要看SOC sc7280的0x00100000区间的offset 114 bytes（GCC_SDCC2_APPS_CLK）的值，取决于硬件，dts无法直接看到值。</p>
<p>题外话：在调查GCC_SDCC2_APPS_CLK时找到一些容易产生误导的代码：</p>
<p>linux-6.7\drivers\clk\qcom\gcc-sc7280.c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct clk_branch gcc_sdcc2_apps_clk = &#123;</span><br><span class="line">	.halt_reg = 0x14004,</span><br><span class="line">	.halt_check = BRANCH_HALT,</span><br><span class="line">	.clkr = &#123;</span><br><span class="line">		.enable_reg = 0x14004,</span><br><span class="line">		.enable_mask = BIT(0),</span><br><span class="line">		.hw.init = &amp;(struct clk_init_data)&#123;</span><br><span class="line">			.name = &quot;gcc_sdcc2_apps_clk&quot;,</span><br><span class="line">			.parent_hws = (const struct clk_hw*[])&#123;</span><br><span class="line">				&amp;gcc_sdcc2_apps_clk_src.clkr.hw,</span><br><span class="line">			&#125;,</span><br><span class="line">			.num_parents = 1,</span><br><span class="line">			.flags = CLK_SET_RATE_PARENT,</span><br><span class="line">			.ops = &amp;clk_branch2_ops,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct freq_tbl ftbl_gcc_sdcc2_apps_clk_src[] = &#123;</span><br><span class="line">	F(400000, P_BI_TCXO, 12, 1, 4),</span><br><span class="line">	F(19200000, P_BI_TCXO, 1, 0, 0),</span><br><span class="line">	F(25000000, P_GCC_GPLL0_OUT_EVEN, 12, 0, 0),</span><br><span class="line">	F(50000000, P_GCC_GPLL0_OUT_EVEN, 6, 0, 0),</span><br><span class="line">	F(100000000, P_GCC_GPLL0_OUT_EVEN, 3, 0, 0),</span><br><span class="line">	F(202000000, P_GCC_GPLL9_OUT_MAIN, 4, 0, 0),</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct clk_rcg2 gcc_sdcc2_apps_clk_src = &#123;</span><br><span class="line">	.cmd_rcgr = 0x1400c,</span><br><span class="line">	.mnd_width = 8,</span><br><span class="line">	.hid_width = 5,</span><br><span class="line">	.parent_map = gcc_parent_map_9,</span><br><span class="line">	.freq_tbl = ftbl_gcc_sdcc2_apps_clk_src,</span><br><span class="line">	.clkr.hw.init = &amp;(struct clk_init_data)&#123;</span><br><span class="line">		.name = &quot;gcc_sdcc2_apps_clk_src&quot;,</span><br><span class="line">		.parent_data = gcc_parent_data_9,</span><br><span class="line">		.num_parents = ARRAY_SIZE(gcc_parent_data_9),</span><br><span class="line">		.flags = CLK_OPS_PARENT_ENABLE,</span><br><span class="line">		.ops = &amp;clk_rcg2_floor_ops,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>高通平台</category>
      </categories>
      <tags>
        <tag>dts</tag>
      </tags>
  </entry>
</search>
