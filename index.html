<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/08/25/Linux-PCI-driver%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/25/Linux-PCI-driver%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Linux PCI driver的调试与分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-25 11:56:14" itemprop="dateCreated datePublished" datetime="2023-08-25T11:56:14+08:00">2023-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-29 13:55:16" itemprop="dateModified" datetime="2023-08-29T13:55:16+08:00">2023-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="PCI-tree结构"><a href="#PCI-tree结构" class="headerlink" title="PCI tree结构"></a>PCI tree结构</h3><p>关于PCIe tree的bus&#x2F;device的详细architecture，参考LDD3和Mastering Linux Device Driver Development - John Madieu</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291114824.png" alt="image-20230829111444515"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291117111.png" alt="image-20230829111727760"></p>
<blockquote>
<p>Root complex (RC): This refers to the PCIe host controller in the SoC. It can access the main memory without CPU intervening, which is a feature used by other devices to access the main memory. They are also known as Host-to-PCI bridges.</p>
<p>Bridges: These provide an interface to other buses, such as PCI or PCI X, or even another PCIe bus. A bridge can also provide an interface to the same bus</p>
<p>Endpoint (EP): Endpoints are PCIe devices, and are represented by type 00h configuration space headers. They never appear on a switch’s internal bus and have no downstream port</p>
</blockquote>
<h3 id="lspci-使用示例"><a href="#lspci-使用示例" class="headerlink" title="lspci 使用示例"></a>lspci 使用示例</h3><p>下面介绍如何找到一个PCI(e)设备的信息，及其上游端口信息，以及设备的register space内容</p>
<p>(1)查看所有pci设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 11th Gen Core Processor Host Bridge/DRAM Registers (rev 01)</span><br><span class="line">00:02.0 VGA compatible controller: Intel Corporation TigerLake-LP GT2 [Iris Xe Graphics] (rev 01)</span><br><span class="line">00:04.0 Signal processing controller: Intel Corporation TigerLake-LP Dynamic Tuning Processor Participant (rev 01)</span><br><span class="line">00:05.0 Multimedia controller: Intel Corporation Device 9a19 (rev 01)</span><br><span class="line">00:07.0 PCI bridge: Intel Corporation Tiger Lake-LP Thunderbolt 4 PCI Express Root Port #0 (rev 01)</span><br><span class="line">00:07.1 PCI bridge: Intel Corporation Tiger Lake-LP Thunderbolt 4 PCI Express Root Port #1 (rev 01)</span><br><span class="line">00:07.2 PCI bridge: Intel Corporation Tiger Lake-LP Thunderbolt 4 PCI Express Root Port #2 (rev 01)</span><br><span class="line">00:07.3 PCI bridge: Intel Corporation Tiger Lake-LP Thunderbolt 4 PCI Express Root Port #3 (rev 01)</span><br><span class="line">...</span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation Tiger Lake-LP PCI Express Root Port #8 (rev 20)</span><br><span class="line">...</span><br><span class="line">a9:00.0 Non-Volatile memory controller: Device 0012:1cc1</span><br></pre></td></tr></table></figure>

<p>(2)查看PCI设备上下游信息</p>
<p>下面关注PCIe device a9:00.0, 用 lspci -v (verbose)查看详细信息:</p>
<p>是一个nvme设备，使用的driver是nvme；device id是0012:1cc1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~$ lspci -v</span><br><span class="line">a9:00.0 Non-Volatile memory controller: Device 0012:1cc1 (prog-if 02 [NVM Express])</span><br><span class="line">	Subsystem: Device 3456:5344</span><br><span class="line">	Physical Slot: 7</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 19, NUMA node 0, IOMMU group 20</span><br><span class="line">	Memory at 88c00000 (64-bit, non-prefetchable) [size=16K]</span><br><span class="line">	Capabilities: &lt;access denied&gt;</span><br><span class="line">	Kernel driver in use: nvme</span><br><span class="line">	Kernel modules: nvme</span><br></pre></td></tr></table></figure>

<p>查看这个设备的上游信息，包括它所在的PCIe bridge（即PCIe port，端口也是PCI设备）</p>
<p>如下lspci -t (tree)列出PCI tree，其中[]内的是bus号，-xx.x是设备号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~$ lspci -t</span><br><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-02.0</span><br><span class="line">           +-04.0</span><br><span class="line">           +-05.0</span><br><span class="line">           +-07.0-[01-2a]--</span><br><span class="line">           +-07.1-[2b-54]--</span><br><span class="line">           +-07.2-[55-7e]--</span><br><span class="line">           +-07.3-[7f-a8]--</span><br><span class="line">          ....</span><br><span class="line">           +-1c.0-[a9]----00.0</span><br><span class="line">           +-1d.0-[aa]--</span><br><span class="line">          ....</span><br><span class="line">           \-1f.6</span><br></pre></td></tr></table></figure>

<p>我们关注的设备a9:00.0表示该设备的 bus是a9, device是00.0，对应PCI tree的 [a9]—-00.0</p>
<p>其上游设备是1c.0，完整设备号为00:1c.0，是个PCIe bridge；每个bridge都是PCIe设备，只不过它比较特殊，是连接其他PCIe设备的设备。根据lspci信息查看该PCIe bridge为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00:1c.0 PCI bridge: Intel Corporation Tiger Lake-LP PCI Express Root Port #8 (rev 20)</span><br></pre></td></tr></table></figure>

<p>PCIe bridge的更上游即bus 00，是PCIe RC (root complex)</p>
<p>上图中有的bridge可以支持一定范围的bus号，例如bus范围为01-2a：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+-07.0-[01-2a]--</span><br></pre></td></tr></table></figure>

<p>(3)查看PCI设备的register space</p>
<p>使用<code>lspci -s [bus]:[device].[function] -xxxx</code> 查看完整的PCIe register space(需要root权限)， -s: show, lspci –help查看各选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~$ sudo lspci -s 00:1c.0 -xxxx (或者-xxx，显示00~ff)</span><br><span class="line">[sudo] password for cursorhu: </span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation Tiger Lake-LP PCI Express Root Port #8 (rev 20)</span><br><span class="line">00: 86 80 bf a0 07 04 10 00 20 00 04 06 00 00 81 00</span><br><span class="line">10: 00 00 00 00 00 00 00 00 00 a9 a9 00 40 40 00 20</span><br><span class="line">20: c0 88 50 89 01 7e 91 7e 60 00 00 00 60 00 00 00</span><br><span class="line">30: 00 00 00 00 40 00 00 00 00 00 00 00 ff 04 02 00</span><br><span class="line">40: 10 80 42 01 01 80 00 00 20 00 11 00 13 4c 72 08</span><br><span class="line">50: 42 00 13 70 60 b2 3c 00 08 10 40 00 08 00 00 00</span><br><span class="line">60: 00 00 00 00 37 08 00 00 00 04 00 00 0e 00 00 00</span><br><span class="line">70: 03 00 1f 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">80: 05 90 01 00 78 02 e0 fe 00 00 00 00 00 00 00 00</span><br><span class="line">90: 0d a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">a0: 01 00 03 c8 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">d0: 11 10 00 07 42 18 01 40 0a 00 9e 09 00 00 00 00</span><br><span class="line">e0: 00 03 e3 00 03 90 03 90 16 00 10 00 00 00 00 00</span><br><span class="line">f0: 50 01 00 00 00 00 00 4c b5 0f 21 01 04 00 00 84</span><br><span class="line">100: 01 00 01 22 00 00 00 00 00 40 00 00 11 00 06 00</span><br><span class="line">110: 01 20 00 00 00 20 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们要确认PCI bridge的 link status register(位于capability register offset 0x12, bit 13 Link active bit) 以知道 PCIe link 是否 active.<br>如何查看：如下图 0x00 ~ 0x3C 是config space标准空间；0x34 capability pointer是地址，指向capability register空间，其值为0x40，因此capability register空间是从0x40开始；因此 link status regsiter 是 0x40+0x12 &#x3D; 0x52, 其bit13 即 0x53 的 bit5. </p>
<p>详细register mapping参考PCI Express Base Spec.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291129433.png" alt="image-20230829112915119"></p>
<h3 id="remove-x2F-reset-x2F-rescan-pci-device"><a href="#remove-x2F-reset-x2F-rescan-pci-device" class="headerlink" title="remove&#x2F;reset&#x2F;rescan pci device"></a>remove&#x2F;reset&#x2F;rescan pci device</h3><p><strong>(1)使用&#x2F;sys&#x2F;bus&#x2F;pci文件接口对device操作：</strong></p>
<p>remove设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/bus/pci/devices/AAAA:BB:CC.D/remove</span><br></pre></td></tr></table></figure>

<p>AAAA:BB:CC.D为bus-info，分别为<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-bus-pci">Domain:Bus:Device.Function</a></p>
<p>rescan设备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/bus/pci/rescan</span><br></pre></td></tr></table></figure>

<p>reset设备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/bus/pci/devices/AAAA:BB:CC.D/reset</span><br></pre></td></tr></table></figure>

<p><strong>(2) lspci &amp; dmesg &amp; 源码 分析：</strong></p>
<p>首先lspci设备，以设备03:00.0 (SD Host controller)为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~/linuxkernel/linux-6.2$ lspci</span><br><span class="line">...</span><br><span class="line">00:1c.7 PCI bridge: Intel Corporation Cannon Lake PCH PCI Express Root Port #8 (rev f0)</span><br><span class="line">...</span><br><span class="line">03:00.0 SD Host controller: O2 Micro, Inc. Device 9862 (rev 01)</span><br></pre></td></tr></table></figure>

<p>remove设备：</p>
<p>非root用户执行时需要用sudo sh -c “命令内容”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;echo 1 &gt; /sys/bus/pci/devices/0000:03:00.0/remove&quot;</span><br></pre></td></tr></table></figure>

<p>dmesg显示remove调用了该device driver的 .remove</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 241.962185] BHT-OSENTRY: BHT sd remove begin</span><br></pre></td></tr></table></figure>

<p>remove之后<code>lspci</code>看不到设备03:00.0，<code>lspci -t</code>可见其bus号03下挂的设备为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cursorhu@ubuntu-PC:~/linuxkernel/linux-6.2$ lspci -t</span><br><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-02.0</span><br><span class="line">           +-12.0</span><br><span class="line">           +-14.0</span><br><span class="line">           +-14.2</span><br><span class="line">           +-16.0</span><br><span class="line">           +-17.0</span><br><span class="line">           +-1b.0-[01]--</span><br><span class="line">           +-1c.0-[02]--</span><br><span class="line">           +-1c.7-[03]--</span><br><span class="line">           +-1d.0-[04]--</span><br><span class="line">           +-1f.0</span><br><span class="line">           +-1f.3</span><br><span class="line">           +-1f.4</span><br><span class="line">           +-1f.5</span><br><span class="line">           \-1f.6</span><br></pre></td></tr></table></figure>

<p>rescan设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;echo 1 &gt; /sys/bus/pci/rescan&quot;</span><br></pre></td></tr></table></figure>

<p>再<code>lspci -t</code>可见其bus号03下挂的设备为为00.0，即设备的[bus:device.function]为03:00.0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-02.0</span><br><span class="line">           +-12.0</span><br><span class="line">           +-14.0</span><br><span class="line">           +-14.2</span><br><span class="line">           +-16.0</span><br><span class="line">           +-17.0</span><br><span class="line">           +-1b.0-[01]--</span><br><span class="line">           +-1c.0-[02]--</span><br><span class="line">           +-1c.7-[03]----00.0</span><br><span class="line">           +-1d.0-[04]--</span><br><span class="line">           +-1f.0</span><br><span class="line">           +-1f.3</span><br><span class="line">           +-1f.4</span><br><span class="line">           +-1f.5</span><br><span class="line">           \-1f.6</span><br></pre></td></tr></table></figure>

<p>dmesg显示rescan调用了该device driver的 .probe</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 617.171735] BHT-OSENTRY: BHT sd probe begin</span><br></pre></td></tr></table></figure>

<p>reset设备：</p>
<p>备份设备的config register 0x0~0x3C，然后调用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/drivers/pci/pci.c#L5555">pci_dev_restore</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* This function does not just reset the PCI portion of a device, but</span><br><span class="line"> * clears all the state associated with the device.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[ 1116.993784] bht-sd 0000:03:00.0: saving config space at offset 0x0 (reading 0x98621217)</span><br><span class="line">[ 1116.993790] bht-sd 0000:03:00.0: saving config space at offset 0x4 (reading 0x100406)</span><br><span class="line">[ 1116.993793] bht-sd 0000:03:00.0: saving config space at offset 0x8 (reading 0x8050101)</span><br><span class="line">[ 1116.993796] bht-sd 0000:03:00.0: saving config space at offset 0xc (reading 0x10)</span><br><span class="line">[ 1116.993798] bht-sd 0000:03:00.0: saving config space at offset 0x10 (reading 0x51100000)</span><br><span class="line">[ 1116.993801] bht-sd 0000:03:00.0: saving config space at offset 0x14 (reading 0x51101000)</span><br><span class="line">[ 1116.993804] bht-sd 0000:03:00.0: saving config space at offset 0x18 (reading 0x0)</span><br><span class="line">[ 1116.993806] bht-sd 0000:03:00.0: saving config space at offset 0x1c (reading 0x0)</span><br><span class="line">[ 1116.993809] bht-sd 0000:03:00.0: saving config space at offset 0x20 (reading 0x0)</span><br><span class="line">[ 1116.993811] bht-sd 0000:03:00.0: saving config space at offset 0x24 (reading 0x0)</span><br><span class="line">[ 1116.993813] bht-sd 0000:03:00.0: saving config space at offset 0x28 (reading 0x0)</span><br><span class="line">[ 1116.993816] bht-sd 0000:03:00.0: saving config space at offset 0x2c (reading 0x21217)</span><br><span class="line">[ 1116.993818] bht-sd 0000:03:00.0: saving config space at offset 0x30 (reading 0x0)</span><br><span class="line">[ 1116.993821] bht-sd 0000:03:00.0: saving config space at offset 0x34 (reading 0x6c)</span><br><span class="line">[ 1116.993823] bht-sd 0000:03:00.0: saving config space at offset 0x38 (reading 0x0)</span><br><span class="line">[ 1116.993826] bht-sd 0000:03:00.0: saving config space at offset 0x3c (reading 0x10b)</span><br><span class="line">[ 1118.015083] pcieport 0000:00:1c.7: re-enabling LTR</span><br><span class="line">[ 1118.015133] bht-sd 0000:03:00.0: restoring config space at offset 0x3c (was 0x100, writing 0x10b)</span><br><span class="line">[ 1118.015170] bht-sd 0000:03:00.0: restoring config space at offset 0x14 (was 0x0, writing 0x51101000)</span><br><span class="line">[ 1118.015191] bht-sd 0000:03:00.0: restoring config space at offset 0x10 (was 0x0, writing 0x51100000)</span><br><span class="line">[ 1118.015205] bht-sd 0000:03:00.0: restoring config space at offset 0xc (was 0x0, writing 0x10)</span><br><span class="line">[ 1118.015227] bht-sd 0000:03:00.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100406)</span><br></pre></td></tr></table></figure>



<h3 id="PCI-driver-access-device-register"><a href="#PCI-driver-access-device-register" class="headerlink" title="PCI driver access device register"></a>PCI driver access device register</h3><p>API在LDD3的PCI driver一章已经有较详细说明：</p>
<p>*<em>Linux offers a standard interface to access the configuration space.</em><br><em>As far as the driver is concerned, the configuration space can be accessed through 8-</em><br><em>bit, 16-bit, or 32-bit data transfers. The relevant functions are prototyped in &lt;linux&#x2F;*<br>pci.h&gt;</em>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pci_read_config_byte(struct pci_dev *dev, int where, u8 *val);</span><br><span class="line">int pci_read_config_word(struct pci_dev *dev, int where, u16 *val);</span><br><span class="line">int pci_read_config_dword(struct pci_dev *dev, int where, u32 *val);</span><br><span class="line">int pci_write_config_byte(struct pci_dev *dev, int where, u8 val);</span><br><span class="line">int pci_write_config_word(struct pci_dev *dev, int where, u16 val);</span><br><span class="line">int pci_write_config_dword(struct pci_dev *dev, int where, u32 val);</span><br></pre></td></tr></table></figure>

<p>内部实现实际是pci_bus_read_config_word，参考：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/drivers/pci/access.c#L554">access.c#L554</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int pci_read_config_word(const struct pci_dev *dev, int where, u16 *val)</span><br><span class="line">&#123;</span><br><span class="line">	if (pci_dev_is_disconnected(dev)) &#123;</span><br><span class="line">		PCI_SET_ERROR_RESPONSE(val);</span><br><span class="line">		return PCIBIOS_DEVICE_NOT_FOUND;</span><br><span class="line">	&#125;</span><br><span class="line">	return pci_bus_read_config_word(dev-&gt;bus, dev-&gt;devfn, where, val);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(pci_read_config_word);</span><br></pre></td></tr></table></figure>

<p>pci_bus_read_config_word的内部实现LDD3也说了：</p>
<p><em><em>The actual implementation of pci_read_config_byte(dev, where, val), for instance, expands to:</em><br>dev-&gt;bus-&gt;ops-&gt;read(bus, devfn, where, 8, val);</em>  </p>
<p>其中bus-&gt;ops使用pci_ops结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct pci_ops &#123;</span><br><span class="line">int (*read)(struct pci_bus *bus, unsigned int devfn, int where, int size,</span><br><span class="line">u32 *val);</span><br><span class="line">int (*write)(struct pci_bus *bus, unsigned int devfn, int where, int size,</span><br><span class="line">u32 val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pci_read_config_byte的实现是宏函数，使用##连接符动态定义byte, word, dword，因此直接搜索不到，实际还是在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/drivers/pci/access.c#L74">access.c#L74</a>，就在EXPORT_SYMBOL(pci_bus_read_config_word); 的前面定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define PCI_OP_READ(size, type, len) \</span><br><span class="line">int noinline pci_bus_read_config_##size \</span><br><span class="line">	(struct pci_bus *bus, unsigned int devfn, int pos, type *value)	\</span><br><span class="line">&#123;									\</span><br><span class="line">	int res;							\</span><br><span class="line">	unsigned long flags;						\</span><br><span class="line">	u32 data = 0;							\</span><br><span class="line">	if (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	\</span><br><span class="line">	pci_lock_config(flags);						\</span><br><span class="line">	res = bus-&gt;ops-&gt;read(bus, devfn, pos, len, &amp;data);		\</span><br><span class="line">	if (res)							\</span><br><span class="line">		PCI_SET_ERROR_RESPONSE(value);				\</span><br><span class="line">	else								\</span><br><span class="line">		*value = (type)data;					\</span><br><span class="line">	pci_unlock_config(flags);					\</span><br><span class="line">	return res;							\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么bus-&gt;ops-&gt;read的底层实现到底是什么？取决于cpu和pci架构，例如arm&#x2F;x86&#x2F;ia64…</p>
<p>全局搜索定义struct pci_ops的代码即可见，以<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/pci/common.c#L72">x86为例</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct pci_ops pci_root_ops = &#123;</span><br><span class="line">	.read = pci_read,</span><br><span class="line">	.write = pci_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *value)</span><br><span class="line">&#123;</span><br><span class="line">	return raw_pci_read(pci_domain_nr(bus), bus-&gt;number,</span><br><span class="line">				 devfn, where, size, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int raw_pci_read(unsigned int domain, unsigned int bus, unsigned int devfn,</span><br><span class="line">						int reg, int len, u32 *val)</span><br><span class="line">&#123;</span><br><span class="line">	if (domain == 0 &amp;&amp; reg &lt; 256 &amp;&amp; raw_pci_ops)</span><br><span class="line">		return raw_pci_ops-&gt;read(domain, bus, devfn, reg, len, val);</span><br><span class="line">	if (raw_pci_ext_ops)</span><br><span class="line">		return raw_pci_ext_ops-&gt;read(domain, bus, devfn, reg, len, val);</span><br><span class="line">	return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>struct</em> pci_raw_ops有几处定义，direct.c, mmconfig_32.c, mmconfig_64.c, 分别对应不同的访问方式。下面以<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/pci/direct.c#L83">direct.c中的实现</a>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const struct pci_raw_ops pci_direct_conf1 = &#123;</span><br><span class="line">	.read =		pci_conf1_read,</span><br><span class="line">	.write =	pci_conf1_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct pci_raw_ops pci_direct_conf2 = &#123;</span><br><span class="line">	.read =		pci_conf2_read,</span><br><span class="line">	.write =	pci_conf2_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有两种direct config访问方式，区别在于指令结构不一样，参考PCI express base spec 的 Configuration Space Header。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Functions for accessing PCI base (first 256 bytes) and extended</span><br><span class="line"> * (4096 bytes per PCI function) configuration space with type 1</span><br><span class="line"> * accesses.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define PCI_CONF1_ADDRESS(bus, devfn, reg) \</span><br><span class="line">	(0x80000000 | ((reg &amp; 0xF00) &lt;&lt; 16) | (bus &lt;&lt; 16) \</span><br><span class="line">	| (devfn &lt;&lt; 8) | (reg &amp; 0xFC))</span><br><span class="line">	</span><br><span class="line">/*</span><br><span class="line"> * Functions for accessing PCI configuration space with type 2 accesses</span><br><span class="line"> */</span><br><span class="line">#define PCI_CONF2_ADDRESS(dev, reg)	(u16)(0xC000 | (dev &lt;&lt; 8) | reg)</span><br></pre></td></tr></table></figure>

<p>以pci_conf1_read的内部实现为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static int pci_conf1_read(unsigned int seg, unsigned int bus,</span><br><span class="line">			  unsigned int devfn, int reg, int len, u32 *value)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (seg || (bus &gt; 255) || (devfn &gt; 255) || (reg &gt; 4095)) &#123;</span><br><span class="line">		*value = -1;</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">	outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);</span><br><span class="line"></span><br><span class="line">	switch (len) &#123;</span><br><span class="line">	case 1:</span><br><span class="line">		*value = inb(0xCFC + (reg &amp; 3));</span><br><span class="line">		break;</span><br><span class="line">	case 2:</span><br><span class="line">		*value = inw(0xCFC + (reg &amp; 2));</span><br><span class="line">		break;</span><br><span class="line">	case 4:</span><br><span class="line">		*value = inl(0xCFC);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;pci_config_lock, flags);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最底层调用的是x86的in, out汇编指令，也是宏函数封装，参考<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/shared/io.h#L27">arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;shared&#x2F;io.h#L27</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline void __out##bwl(type value, u16 port)		\</span><br><span class="line">&#123;									\</span><br><span class="line">	asm volatile(&quot;out&quot; #bwl &quot; %&quot; #bw &quot;0, %w1&quot;			\</span><br><span class="line">		     : : &quot;a&quot;(value), &quot;Nd&quot;(port));			\</span><br><span class="line">&#125;									\</span><br><span class="line">									\</span><br><span class="line">static __always_inline type __in##bwl(u16 port)				\</span><br><span class="line">&#123;									\</span><br><span class="line">	type value;							\</span><br><span class="line">	asm volatile(&quot;in&quot; #bwl &quot; %w1, %&quot; #bw &quot;0&quot;			\</span><br><span class="line">		     : &quot;=a&quot;(value) : &quot;Nd&quot;(port));			\</span><br><span class="line">	return value;							\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此pci_read_config_byte一类的PCI register acess API分析完毕。</p>
<h3 id="PCIe-AER-driver"><a href="#PCIe-AER-driver" class="headerlink" title="PCIe AER driver"></a>PCIe AER driver</h3><p>AER: Advanced Error Reporting  </p>
<p>PCIe的AER是PCIe spec协议的标准功能，AER涉及到Error信号产生，上报，处理，错误恢复等。</p>
<h4 id="PCIe-base-spec摘要："><a href="#PCIe-base-spec摘要：" class="headerlink" title="PCIe base spec摘要："></a>PCIe base spec摘要：</h4><p>Error分类：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308251714033.png" alt="image-20230825171440881"></p>
<p>Error信号在数字逻辑的处理流水：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308251714855.png" alt="image-20230825171423678"></p>
<p>AER的capability regsiter:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308251715226.png" alt="image-20230825171511047"></p>
<h4 id="PCIe-AER-driver摘要"><a href="#PCIe-AER-driver摘要" class="headerlink" title="PCIe AER driver摘要"></a>PCIe AER driver摘要</h4><p>PCIe driver的使用aer service driver实现软件处理流程，aer service属于PCIe bus driver的子功能，而PCIe driver又属于PCI driver字类。</p>
<p>什么是PCIe service driver: <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v6.1/PCI/pciebus-howto.html">2. The PCI Express Port Bus Driver Guide HOWTO</a></p>
<p>什么是PCIe AER driver: <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v6.1/PCI/pcieaer-howto.html">8. The PCI Express Advanced Error Reporting Driver Guide HOWTO</a></p>
<h4 id="Kconfig设置PCIe-AER-driver"><a href="#Kconfig设置PCIe-AER-driver" class="headerlink" title="Kconfig设置PCIe AER driver"></a>Kconfig设置PCIe AER driver</h4><p>配置Kconfig可开关：make menuconfig -&gt; &#x2F; -&gt; 搜索PCIEAER -&gt; n关闭，y打开</p>
<p>如下Kconfig的AER三个相关项都被关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_PCIAER=n</span><br><span class="line">CONFIG_ACPI_APEI_PCIEAER=n</span><br><span class="line">CONFIG_PCIAER_INJECT=n</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308251756929.png" alt="image-20230825175611772"></p>
<h4 id="示例：ACS-violation-error的debug过程"><a href="#示例：ACS-violation-error的debug过程" class="headerlink" title="示例：ACS violation error的debug过程"></a>示例：ACS violation error的debug过程</h4><p>在调试SD express host controller driver过程中，发现部分SD express card（ADATA &amp; Lexar）在linux下无法正常初始化，windows下正常。以下为issue debug过程。</p>
<p>(1)首先打开PCI driver的debug打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig -&gt; /搜索 -&gt; PCI_DEBUG -&gt; y</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://cursorhu.github.io/2023/08/02/Linux-driver%E9%80%9A%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">Linux driver常用调试技术记录</a></p>
<p>(2)对比Good Case和Bad case</p>
<p>SD express card的切换是包含PCIe linkdown和linkup的过程，会有两次hot-plug中断处理。</p>
<p>Bad case的log中，发现如下两种AER error report:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291149954.png" alt="image-20230829114906631"></p>
<p>a. RxErr</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Link Training Error：一插卡就有此error. 此error发生在hot-plug中断之前</span><br><span class="line">[  106.119856] pcie port 0000:00:1b.4: pciehp: pending interrupts 0x0100 from Slot Status</span><br><span class="line">[  106.119863] pcieport 0000:00:1b.4: PCIe Bus Error: severity=Corrected, type=Physical Layer, (Receiver ID) //PCI driver检测到error属于Physical Layer</span><br><span class="line">[  106.119864] pcieport 0000:00:1b.4:   device [8086:43c4] error status/mask=00000001/00002000 //error status bit0 =1</span><br><span class="line">[  106.119866] pcieport 0000:00:1b.4:    [ 0] RxErr                  (First) //error的含义：在old version of PCIe spec表示Link Training Error.</span><br></pre></td></tr></table></figure>

<p>b. ACS Violation</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ACS Violation error: 在hot-plug driver检测到hot-plug中断之后正在处理hot-plug的card/link状态检测过程中，PCIe driver检测到此error</span><br><span class="line">[  107.493928] enter pciehp_ist</span><br><span class="line">[  107.494136] pcieport 0000:00:1b.4: DPC: containment event, status:0x1f01 source:0x0000</span><br><span class="line">[  107.494140] pcieport 0000:00:1b.4: DPC: unmasked uncorrectable error detected //PCI driver检测到error</span><br><span class="line">[  107.494145] pcieport 0000:00:1b.4: PCIe Bus Error: severity=Uncorrected (Non-Fatal), type=Transaction Layer, (Receiver ID) //PCI driver检测到error属于Transaction Layer</span><br><span class="line">[  107.494148] pcieport 0000:00:1b.4:   device [8086:43c4] error status/mask=00200000/00004000  //error status bit21 =1</span><br><span class="line">[  107.494151] pcieport 0000:00:1b.4:    [21] ACSViol                (First)     //error的含义：ACS Violation</span><br></pre></td></tr></table></figure>

<p>在此ACS error发生之后，hot-plug driver检测不到LinkUp（1st 检测）, polling 10s后也检测不到LinkUp（2nd 检测），最终打印No link，PCIe设备未启动configuration。</p>
<p>(3) ACS violation分析</p>
<p>PCIe协议分析抓包发现一个可疑的vendor defined message，可能是对应上述错误信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291158420.png" alt="image-20230829115802177"></p>
<p>ACS violation在PCIe spec描述如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308291151689.png" alt="image-20230829115115392"></p>
<p>(4)原因和解决办法</p>
<p>逻辑链：PCIe Link training到L0之后，PCI driver还没发送Config Write操作定义Bus number的时候, SD express卡就发送了一个Vendor Specific defined message，这个是违反spec规定的；而RC side ACS 功能是enable的，会检测收到的包中的bus number是否和自己已扫描的bus相符，如果不符就报错ACS violation，并放弃卡初始化。</p>
<p>解决办法(workaround)：关闭PCIe bridge driver的ACS enable bit (ACS Control register bit0&#x3D;1’b0):</p>
<p>具体代码改动为：</p>
<p>1). drivers&#x2F;pci&#x2F;pci.c -&gt; pci_std_enable_acs ：pcie默认enable ACS Control register的ACS violation bit，此处修改为disable ACS violation bit.</p>
<p>2). drivers&#x2F;pci&#x2F;quirk.c -&gt; pci_quirk_enable_intel_spt_pch_acs: 此处为Intel PCIe的特有配置，此处也 disable ACS violation bit</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/08/11/Debian12-Gnome%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/11/Debian12-Gnome%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Debian12+Gnome配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-11 10:57:59 / 修改时间：19:04:29" itemprop="dateCreated datePublished" datetime="2023-08-11T10:57:59+08:00">2023-08-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="设置sudo"><a href="#设置sudo" class="headerlink" title="设置sudo"></a>设置sudo</h3><p>普通用户(以username为例)并没有被加入sudo用户组，不能使用sudo命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username@debian:~$ sudo apt install xxx</span><br><span class="line">username is not in the sudoers file.</span><br></pre></td></tr></table></figure>

<p>有两种方式：</p>
<ol>
<li><p>在su下用visudo(nano也可以)编辑&#x2F;etc&#x2F;sudoers文件，新增username使sudo能获取root权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">username ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
</li>
<li><p>在su下用usermod -aG sudo username，将username添加到sudo组，由于&#x2F;etc&#x2F;sudoers的如下设置已经将sudo组设为root权限，所以这个操作等效于使username能用sudo获取root权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%sudo ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>sbin的命令not found问题：执行visudo或usermod时，发现command not found. Debug过程如下：</li>
</ul>
<p>​        使用whereis visudo查看路径是&#x2F;usr&#x2F;sbin；echo $PATH没有&#x2F;usr&#x2F;sbin，因此是环境变量问题。</p>
<p>   方式一：在username的~&#x2F;.bashrc下添加sbin到PATH，生效之后sbin目录的命    令才可执行：</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nano .bashrc</span><br><span class="line">export PATH=$PATH:/usr/sbin</span><br><span class="line">source ~/.bashrc</span><br><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p>   方式二：另外一种方式是加软链接，需要一个个添加</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/sbin/visudo /usr/bin/visudo</span><br></pre></td></tr></table></figure>

<ul>
<li>如何退出su：使用exit，或su username，切换到username用户</li>
</ul>
<h3 id="设置apt源"><a href="#设置apt源" class="headerlink" title="设置apt源"></a>设置apt源</h3><ul>
<li>使用iso安装的debian，首先需要取消从iso安装软件的选项：</li>
</ul>
<p>​        software&amp;update -&gt; Other Software -&gt; 取消勾选cdrom</p>
<ul>
<li>再选择国内源, 例如China-&gt; mirrors.163.com&#x2F;debian，并选中main&#x2F;free&#x2F;non-free各种下载选项。</li>
<li>如果refresh cache界面卡死，使用<code>apt update</code>手动更新源。</li>
</ul>
<h3 id="设置gnome-shell"><a href="#设置gnome-shell" class="headerlink" title="设置gnome shell"></a>设置gnome shell</h3><p>gnome shell即gnome的桌面</p>
<p>(1)通过extensions自定义桌面插件</p>
<p>参考：<a target="_blank" rel="noopener" href="https://itsfoss.com/gnome-shell-extensions/#:~:text=Installing%20GNOME%20Shell%20Extensions%201%20Use%20gnome-shell-extensions%20package,3%20Install%20GNOME%20Shell%20Extensions%20manually.%20See%20More.">How to Use GNOME Shell Extensions [Complete Guide]</a></p>
<p>可以通过gnome-shell-extension-manager直接安装extension，无需到网站下载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gnome-shell-extension-manager</span><br></pre></td></tr></table></figure>

<p>推荐安装Dash to Dock和Arc Menu</p>
<p>(2)修改主题(theme)</p>
<p>参考 <a target="_blank" rel="noopener" href="https://itsfoss.com/install-switch-themes-gnome-shell/">How to Install and Change GNOME Theme in Linux</a></p>
<p>打开extensions的User Themes插件后才可以安装自定义themes</p>
<p>手动安装单个GTK主题的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建放置themes的目录</span><br><span class="line">mkdir ~/.themes</span><br><span class="line">#从gnome-look下载themes,放到.themes目录，Ctrl+H打开隐藏目录</span><br><span class="line">https://www.gnome-look.org/browse/</span><br><span class="line">#打开gnome tweak(默认已安装)，Appearance -&gt; Shell -&gt; 使用themes</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>要完整桌面主题效果，需要安装gtk-theme，icon-theme，cursor-theme等多类theme。例如WhileSur，要达到和MacOS一样的效果，需要去GTK3&#x2F;4 themes, Full Icon Themes，Cursors分别下载top5的WhileSur主题。一个主题可能有多种模式，按github install.sh能完整安装各种模式，手动下载只能安装一种模式。</li>
<li>注意gnome桌面是基于GTK，GTK is a multi-platform toolkit for creating graphical user interfaces. 所以是在gtk-theme而不是gnome-shell找。</li>
<li>要自定义登录界面的主题，去GDM themes找top5(改GDM需要先安装loginized)；要自定义GRUB主题，去GRUB themes找。</li>
<li>Top 10 themes: <a target="_blank" rel="noopener" href="https://itsfoss.com/best-gtk-themes/">best-gtk-themes</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/08/02/Linux-driver%E9%80%9A%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/02/Linux-driver%E9%80%9A%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Linux driver常用调试技术记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-02 17:52:38" itemprop="dateCreated datePublished" datetime="2023-08-02T17:52:38+08:00">2023-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-03 14:03:11" itemprop="dateModified" datetime="2023-08-03T14:03:11+08:00">2023-08-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Printk"><a href="#Printk" class="headerlink" title="Printk"></a>Printk</h2><p>printk参考Kernel document: <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/translations/zh_CN/core-api/printk-basics.html">使用printk记录消息</a></p>
<h3 id="1-printk的基础用法"><a href="#1-printk的基础用法" class="headerlink" title="(1)printk的基础用法"></a>(1)printk的基础用法</h3><p>常用示例如下，一般是手动添加打印代码时使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">step1: 例如要打印当前函数被调用，添加pr_info(&quot;%s\n&quot;, __FUNCTION__)</span><br><span class="line">step2: echo 7 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p><strong>Tips1: 非root用户不能成功执行<code>sudo echo 7 &gt; /proc/sys/kernel/printk</code>，显示permission denied</strong></p>
<p>原因：因为sudo仅让echo按root权限执行，没有让&gt;按root权限执行</p>
<p>解决办法一：dmesg配置printk级别：<code>sudo dmesg -n 7</code></p>
<p>解决办法二：解决任何sudo echo写入的权限问题：</p>
<p><code>sudo sh -c &quot;cmd&quot;</code>，让bash将整个cmd字符串当一个命令执行，并赋予root权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;echo 7 &gt; /proc/sys/kernel/printk&quot;</span><br></pre></td></tr></table></figure>

<p>再<code>cat /proc/sys/kernel/printk</code>可见printk已变成7,4,1,7(默认是4,4,1,7)</p>
<p><strong>Tips2: (printk持久化)系统启动自动设置打印级别：</strong></p>
<p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk每次启动后都恢复为默认值4,4,1,7，要系统启动时自动配置7,4,1,7，在&#x2F;etc&#x2F;sysctl.conf添加如下内容即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.printk = 7 4 1 7</span><br></pre></td></tr></table></figure>

<p><strong>如果要观测系统启动中的driver debug打印，必须配置kernel.printk</strong></p>
<p><strong>如果要观测系统启动后的driver debug打印，建议使用dmesg -n修改printk</strong></p>
<h3 id="2-printk在driver-subsystem中的使用"><a href="#2-printk在driver-subsystem中的使用" class="headerlink" title="(2)printk在driver subsystem中的使用"></a>(2)printk在driver subsystem中的使用</h3><p>Linux driver子系统通常使用printk的封装版。以pci driver为例，pci driver代码已经提供了pci_dbg, pci_info, pci_err等打印函数，其不仅打印arg信息，也打印pci port设备信息，例如以下PCIe driver的log:</p>
<p>pcieport 0000:00:1b.4 显示了当前的PCIe port。如果有多个PCIe port的打印，可以区分是哪个port的打印输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[   44.713266] pcieport 0000:00:1b.4: DPC: containment event, status:0x1f01 source:0x0000</span><br><span class="line">[   44.713268] pcieport 0000:00:1b.4: DPC: unmasked uncorrectable error detected</span><br><span class="line">[   44.713274] pcieport 0000:00:1b.4: PCIe Bus Error: severity=Uncorrected (Non-Fatal), type=Transaction Layer, (Receiver ID)</span><br><span class="line">[   44.713277] pcieport 0000:00:1b.4:   device [8086:43c4] error status/mask=00200000/00004000</span><br><span class="line">[   44.713280] pcieport 0000:00:1b.4:    [21] ACSViol                (First)</span><br></pre></td></tr></table></figure>

<p><strong>如何设置dev_info, dev_err:</strong></p>
<p>pci_info, pci_err的打开和pr_info, pr_err一致，只需要设置打印级别大于info&#x2F;err即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 7 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p>其他驱动模块的xxx_info, xxx_err也是一样</p>
<p><strong>如何设置dev_dbg:</strong></p>
<p>dev_dbg是比较特殊和最常用的打印方式，定义如下。</p>
<p>可见dev_dbg的开启依赖于两个条件：</p>
<ul>
<li><p>driver定义了CONFIG_DYNAMIC_DEBUG 或者 DEBUG 宏才能开启，一般使用DEBUG宏</p>
</li>
<li><p>printk级别需要为8（7为debug level, 8 &gt; debug level，才能开启debug打印）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#if defined(CONFIG_DYNAMIC_DEBUG) || \</span><br><span class="line">	(defined(CONFIG_DYNAMIC_DEBUG_CORE) &amp;&amp; defined(DYNAMIC_DEBUG_MODULE))</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">	dynamic_dev_dbg(dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="line">#elif defined(DEBUG)</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">	dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define dev_dbg(dev, fmt, ...)						\</span><br><span class="line">(&#123;									\</span><br><span class="line">	if (0)								\</span><br><span class="line">		dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \</span><br><span class="line">&#125;)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>以pci_dbg为例(内部实现是dev_dbg)，要打开pci_dbg设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在Kernel Makefile定义DEBUG宏，可以在driver/pci的Makefile定义，也可以在Kernel根目录Makefile定义：</span><br><span class="line"></span><br><span class="line">方式一：DEBUG宏定义在KCFLAG，即编译此目录的任何driver .o, .ko都定义了DEBUG宏</span><br><span class="line">KCFLAGS += -DDEBUG </span><br><span class="line"></span><br><span class="line">方式二：DEBUG宏定义在某一个driver模块，即编译此模块时定义了DEBUG宏，例如</span><br><span class="line">obj-$&#123;CONFIG_PCI&#125; += -DDEBUG </span><br></pre></td></tr></table></figure>

<p>以上是对任意Driver模块打开DEBUG宏的通用方法；实际上drivers&#x2F;pci已经定义了KCONFIG可选项如下，只需要make menuconfig时设置PCI_DEBUG &#x3D; y 即可对drivers&#x2F;pci的当前目录和子目录的模块编译都定义DEBUG宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">### Makefile:</span><br><span class="line">subdir-ccflags-$(CONFIG_PCI_DEBUG) := -DDEBUG</span><br><span class="line"></span><br><span class="line">### Kconfig:</span><br><span class="line">config PCI_DEBUG</span><br><span class="line">	bool &quot;PCI Debugging&quot;</span><br><span class="line">	depends on DEBUG_KERNEL</span><br><span class="line">	help</span><br><span class="line">	  Say Y here if you want the PCI core to produce a bunch of debug</span><br><span class="line">	  messages to the system log.  Select this if you are having a</span><br><span class="line">	  problem with PCI support and want to see more of what is going on.</span><br><span class="line"></span><br><span class="line">	  When in doubt, say N.</span><br></pre></td></tr></table></figure>

<p>最后设置printk level大于DEBUG level：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 8 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p>此后dmesg可查看drivers&#x2F;pci下的所有pci_dbg都被打印（当然也包括pci_info, pci_err等）。</p>
<h2 id="make-menuconfig"><a href="#make-menuconfig" class="headerlink" title="make menuconfig"></a>make menuconfig</h2><h3 id="如何快速定位"><a href="#如何快速定位" class="headerlink" title="如何快速定位"></a>如何快速定位</h3><p>以PCIe driver为例，drivers&#x2F;pci的Makefile有以下CONFIG</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subdir-ccflags-$(CONFIG_PCI_DEBUG) := -DDEBUG</span><br></pre></td></tr></table></figure>

<p>现在make menuconfig时想快速定位CONFIG_PCI_DEBUG对应的位置再设置为y，定位操作如下：</p>
<p>step1: 输入<code>/</code> 打开查找，输入要查找的CONFIG名，注意这里不支持模糊匹配</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031201872.png" alt="Screenshot from 2023-08-03 11-52-54"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031201364.png" alt="Screenshot from 2023-08-03 11-51-31"></p>
<p>step2: 按1跳转到CONFIG对应位置</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308031202070.png" alt="Screenshot from 2023-08-03 11-51-55"></p>
<h3 id="直接修改-config文件"><a href="#直接修改-config文件" class="headerlink" title="直接修改.config文件"></a>直接修改.config文件</h3><p>make menuconfig本质是配置.config文件，可以手动修改CONFIG_XXX &#x3D; y&#x2F;m</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/07/24/windows-coredump%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/24/windows-coredump%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">windows coredump的配置和测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-24 15:42:43 / 修改时间：17:17:13" itemprop="dateCreated datePublished" datetime="2023-07-24T15:42:43+08:00">2023-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows/" itemprop="url" rel="index"><span itemprop="name">windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在存储设备的windows系统环境下调试时，因为存储设备本身的问题，有时候coredump不能成功生成到系统目录，本文记录如何修改coredump路径，以及用键盘测试coredump生成符合预期。</p>
<h2 id="使能windows的coredump"><a href="#使能windows的coredump" class="headerlink" title="使能windows的coredump"></a>使能windows的coredump</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/debugger/enabling-a-kernel-mode-dump-file">Enabling a Kernel-Mode Dump File</a></p>
<h2 id="修改coredump路径"><a href="#修改coredump路径" class="headerlink" title="修改coredump路径"></a>修改coredump路径</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/troubleshoot/windows-server/performance/memory-dump-file-options">Windows 的内存转储文件选项概述</a></p>
<p>可以修改注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\CrashControl</code>的DumpFile键值对，默认路径%SystemRoot%在cmd echo出来是”C:&quot;, 修改为指定路径例如”E:\Memory.dmp”。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241555783.png" alt="image-20230724155525547"></p>
<p>此操作也可以在控制面板完成，两者等效。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241555568.PNG" alt="crashcontrol2"></p>
<h2 id="使用键盘手动生成coredump"><a href="#使用键盘手动生成coredump" class="headerlink" title="使用键盘手动生成coredump"></a>使用键盘手动生成coredump</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/debugger/forcing-a-system-crash-from-the-keyboard">Forcing a system crash from the keyboard</a></p>
<p>以USB keyboards为例：</p>
<p>修改注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\kbdhid\Parameters</code>，创建CrashOnCtrlScroll &#x3D; 0x01，重启后“Hold down the rightmost CTRL key, and press the SCROLL LOCK key twice.”系统会直接蓝屏，重启即可查看coredump文件。如果用windbg查看KeBugCheck查看错误码是0xE2: MANUALLY_INITIATED_CRASH。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241554830.png" alt="image-20230724155442525"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/07/12/Arch%20Linux%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/12/Arch%20Linux%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Arch Linux安装和配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-12 15:50:54" itemprop="dateCreated datePublished" datetime="2023-07-12T15:50:54+08:00">2023-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-29 15:03:15" itemprop="dateModified" datetime="2023-08-29T15:03:15+08:00">2023-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近Debian12发布，尝鲜在移动硬盘装了Debian12+KDE，但不习惯Debian繁琐的包管理和Ubuntu越来越商业化的行为，最终切换到ArchLinux，进入Pacman和AUR的包管理和滚动更新风格。此文记录ArchLinux安装配置过程。</p>
<h2 id="构建多系统的U盘启动盘"><a href="#构建多系统的U盘启动盘" class="headerlink" title="构建多系统的U盘启动盘"></a>构建多系统的U盘启动盘</h2><p>使用<a target="_blank" rel="noopener" href="https://www.ventoy.net/en/doc_start.html">ventoy&#x2F;Start to use Ventoy</a>，将各系统镜像放到Ventoy目录即可，不需要用传统的UltraISO那种一个系统ISO要占用整个U盘。<br>Arch Linux的ISO<a target="_blank" rel="noopener" href="https://archlinux.org/download/">在此下载</a></p>
<h2 id="使用archinstall安装ArchLinux"><a href="#使用archinstall安装ArchLinux" class="headerlink" title="使用archinstall安装ArchLinux"></a>使用archinstall安装ArchLinux</h2><p><a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Installation_guide">传统的ArchLinux安装方式</a>过于繁琐，现在Arch Linux安装包提供一个类GUI的脚本<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Archinstall">archinstall</a>，按需求配置即可，可以一键处理包括KDE&#x2F;GNOME&#x2F;I3W等桌面在内的全部安装过程。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.linuxmi.com/archinstall-auto-arch-linux.html">使用 archinstall 自动化脚本安装 Arch Linux 完整指南</a>，<a target="_blank" rel="noopener" href="https://u.sb/archlinux-archinstall/">使用 archinstall 安装 Arch Linux 和 KDE 桌面环境</a>。</p>
<p>我的配置如下。Profile选择安装desktop Kde, Network选择Use NetworkManager后，Kde Plasma被自动安装，不需要按参考文章手动安装桌面：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307121642425.png" alt="image-20230712164243209"></p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>kde主题应用直接安装主题基本会失败，需要去<a target="_blank" rel="noopener" href="https://store.kde.org/browse/">KDE store</a>下载主题并按主题的README配置</p>
<p>一个风格统一的主题包含几个部分：Global theme，包括桌面(desktop)，图标(icon)，鼠标(cursor)，壁纸(wallpaper)，也可以包含登录界面(sddm)和启动界面(GRUB)</p>
<p>(1)配置桌面</p>
<p>下面配置MacOS风格的 <a target="_blank" rel="noopener" href="https://store.kde.org/p/1400424/">WhiteSur Dark</a>，建议在Github下载完整主题:<a target="_blank" rel="noopener" href="https://github.com/vinceliuice/WhiteSur-kde">WhiteSur-kde</a></p>
<p>使用<code>./install.sh</code>安装主题，其内部操作就是拷贝各部分配置文件到系统配置目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp -r $&#123;SRC_DIR&#125;/aurorae/normal/$&#123;name&#125;$&#123;color&#125;* $&#123;AURORAE_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/Kvantum/$&#123;name&#125; $&#123;KVANTUM_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/wallpaper/$&#123;name&#125;* $&#123;WALLPAPER_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/latte-dock/* $&#123;LATTE_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/color-schemes/* $&#123;SCHEMES_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/plasma/desktoptheme/$&#123;name&#125;$&#123;pcolor&#125; $&#123;PLASMA_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/plasma/desktoptheme/icons $&#123;PLASMA_DIR&#125;/$&#123;name&#125;$&#123;pcolor&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中的latte-dock只是配置文件，需要先安装latte-dock</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S latte-dock</span><br></pre></td></tr></table></figure>

<p>主题安装完毕后，在系统System Setting -&gt; Appearance -&gt; Global Theme的子目录apply各模块</p>
<p>(2)配置登录界面</p>
<p>登录界面SDDM需要独立安装，在WhiteSur-kde的sddm目录运行<code>install.sh</code>安装sddm，之后可在系统System Setting -&gt; Startup and Shutdown中设置sddm为WhiteSur。</p>
<p>(3)配置启动界面</p>
<p>以 <a target="_blank" rel="noopener" href="https://store.kde.org/p/1603282">Dark Matter GRUB Theme</a>为例，按github的install guide安装即可。</p>
<h2 id="中文显示和中文输入法"><a href="#中文显示和中文输入法" class="headerlink" title="中文显示和中文输入法"></a>中文显示和中文输入法</h2><p>打开网页有中文乱码（方框），需要安装noto-fonts相关字体包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br></pre></td></tr></table></figure>

<p>安装中文输入法框架（包含pinyin输入法）并配置fcitx5，具体含义参考 <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Input_method">Input method</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im fcitx5-chinese-addons  fcitx5-rime</span><br></pre></td></tr></table></figure>
<p>在desktop environment配置fcitx:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/environment</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>

<p>重启，按 <code>Win</code> 键搜索 <code>Input Method</code>, 点击 <code>Add Input Method...</code>搜索 <code>pinyin</code> 然后添加，按 <code>Ctrl</code> + <code>空格</code>可切换输入法</p>
<h2 id="安装yay以使用AUR"><a href="#安装yay以使用AUR" class="headerlink" title="安装yay以使用AUR"></a>安装yay以使用AUR</h2><p><a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/yay">yay</a>: Yet another yogurt. Pacman wrapper and AUR helper written in go.</p>
<p>yay的安装参考: <a target="_blank" rel="noopener" href="https://www.debugpoint.com/install-yay-arch/">How to Install yay AUR Helper in Arch Linux [Beginner’s Guide]</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S base-devel git</span><br><span class="line">cd /opt</span><br><span class="line">sudo git clone https://aur.archlinux.org/yay.git</span><br><span class="line">cd yay</span><br><span class="line">sudo chown -R 用户名:users .   #必须修改yay目录的owner, yay不能被sudo编译</span><br><span class="line">makepkg -si  #编译yay</span><br></pre></td></tr></table></figure>

<h2 id="Go语言包换源"><a href="#Go语言包换源" class="headerlink" title="Go语言包换源"></a>Go语言包换源</h2><p>安装yay时makepkg会显示go包安装timeout, 需要换国内源 <a target="_blank" rel="noopener" href="https://goproxy.cn/">goprixy.cn</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#临时生效</span><br><span class="line">$ export GO111MODULE=on</span><br><span class="line">$ export GOPROXY=https://goproxy.cn</span><br><span class="line"></span><br><span class="line">#永久生效</span><br><span class="line">$ echo &quot;export GO111MODULE=on&quot; &gt;&gt; ~/.profile</span><br><span class="line">$ echo &quot;export GOPROXY=https://goproxy.cn&quot; &gt;&gt; ~/.profile</span><br><span class="line">$ source ~/.profile</span><br></pre></td></tr></table></figure>

<h2 id="pacman-x2F-yay换源"><a href="#pacman-x2F-yay换源" class="headerlink" title="pacman&#x2F;yay换源"></a>pacman&#x2F;yay换源</h2><p>在archinstall时如果Mirror region选择China，则默认使用官方提供的China源，见&#x2F;etc&#x2F;pacman.conf的[core&#x2F;extra]字段都版本了&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist. </p>
<p>但官方源速度有时很慢，建议手动添加<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/archlinuxcn/">archlinuxcn源</a>，如果包在国内源有的话，yay速度直接起飞</p>
<p>有网上建议生成aur配置文件换国内源：<code>yay --aururl “https://aur.tuna.tsinghua.edu.cn” --save</code> 此处不建议，如果国内源没有的包将无法下载；换回官方源：<code>yay --aururl &quot;https://aur.archlinux.org&quot; --save</code>，并删除yay源配置文件<code>~/.config/yay/config.json</code></p>
<h2 id="yay常用命令"><a href="#yay常用命令" class="headerlink" title="yay常用命令"></a>yay常用命令</h2><p>从仓库和 AUR 中交互式搜索和安装软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay &#123;&#123;软件包|搜索词&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>同步并更新所有来自仓库和 AUR 的软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay</span><br></pre></td></tr></table></figure>

<p>从仓库和 AUR 中安装一个新的软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S &#123;&#123;软件包&#125;&#125;</span><br><span class="line">yay -Sy &#123;&#123;软件包&#125;&#125; #默认yes</span><br></pre></td></tr></table></figure>

<p>从仓库和 AUR 中搜索软件包数据库中的关键词：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Ss &#123;&#123;关键词&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>显示已安装软件包和系统健康状况的统计数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Ps</span><br></pre></td></tr></table></figure>
<p>卸载包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -R </span><br></pre></td></tr></table></figure>

<h2 id="pacman更新系统"><a href="#pacman更新系统" class="headerlink" title="pacman更新系统"></a>pacman更新系统</h2><p>更新所有安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu #仅更新</span><br><span class="line">sudo pacman -Syyu #如果系统有损坏包，能覆盖下载</span><br></pre></td></tr></table></figure>

<h2 id="Host-DNS设置"><a href="#Host-DNS设置" class="headerlink" title="Host DNS设置"></a>Host DNS设置</h2><p>NetworkManager会自动配置DNS域名解析文件&#x2F;etc&#x2F;resolv.conf，且手动修改的内容每次重启会被NetworkManager覆盖。</p>
<p>如果要手动配置，参考 <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/NetworkManager">&#x2F;etc&#x2F;resolv.conf</a>，设置dns.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/NetworkManager/conf.d/dns.conf</span><br><span class="line">[main]</span><br><span class="line">dns=none</span><br></pre></td></tr></table></figure>

<h2 id="KDE-Discover显示unable-to-load-applications"><a href="#KDE-Discover显示unable-to-load-applications" class="headerlink" title="KDE Discover显示unable to load applications"></a>KDE Discover显示unable to load applications</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S packagekit-qt5</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/29/%E4%BD%BF%E7%94%A8VSCode%E9%98%85%E8%AF%BBLinux-Kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/29/%E4%BD%BF%E7%94%A8VSCode%E9%98%85%E8%AF%BBLinux-Kernel/" class="post-title-link" itemprop="url">使用VSCode阅读Linux Kernel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-29 11:59:26" itemprop="dateCreated datePublished" datetime="2023-05-29T11:59:26+08:00">2023-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-21 11:04:50" itemprop="dateModified" datetime="2023-08-21T11:04:50+08:00">2023-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>安装kernel编译环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>

<p>安装bear</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bear</span><br></pre></td></tr></table></figure>

<p>使用bear编译kernel，生成compile_commands.json，参考：<a target="_blank" rel="noopener" href="https://forums.100ask.net/t/topic/1656/2">Ubuntu22 直接 make 内核成功，但不能使用 bear 命令</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bear -- make -j4</span><br></pre></td></tr></table></figure>

<p>在编译Kernel的源代码环境安装clangd服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clangd</span><br></pre></td></tr></table></figure>

<p>在查看代码的VSCode环境安装clangd客户端(即VSCode的clangd插件)：一般通过windows机器的VSCode SSH连接Linux的clangd服务，因此需要将VSCode的remote SSH登陆到Linux机器（注意不要同时使用Xshell等其他SSH工具，否则VSCode remote SSH连不上）</p>
<p>VSCode remote SSH中打开代码后，clangd自动indexing(完成Kernel index需要相当长时间)，CTRL+鼠标左键查看定义，ALT+左键头返回跳转</p>
<p>clangd方式可以很方便找到C函数指针的实现，而VSCode的C++ intellisense跳转不到</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/558286384">使用VSCode进行linux内核代码阅读和开发</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/17/xv6-annotated-xv6%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/17/xv6-annotated-xv6%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/" class="post-title-link" itemprop="url">xv6-annotated:xv6完全注释</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-17 10:34:55 / 修改时间：10:46:56" itemprop="dateCreated datePublished" datetime="2023-05-17T10:34:55+08:00">2023-05-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xv6/" itemprop="url" rel="index"><span itemprop="name">xv6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>xv6是mit6.828操作系统课程的基于unix v6重新实现的教学操作系统。</p>
<p>本文英文部分是x86版本的xv6(mit6.828 2018及以前的版本)完全注释，github：<a target="_blank" rel="noopener" href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p>本文中文部分是我学习xv6过程中添加了部分中文注解</p>
<h1 id="DAS-BOOT"><a href="#DAS-BOOT" class="headerlink" title="DAS BOOT"></a>DAS BOOT</h1><p>First things first: in order for a computer to run xv6, we need to load it from<br>disk into memory and tell the processor to start running it. So how does this<br>all happen?</p>
<h2 id="The-Boot-Process"><a href="#The-Boot-Process" class="headerlink" title="The Boot Process"></a>The Boot Process</h2><p>When you press the power button, the hardware gets initialized by a piece of<br>firmware called the BIOS (Basic Input&#x2F;Output System) that comes pre-installed on<br>the motherboard on a ROM chip. Nowadays, your computer probably uses UEFI loaded<br>from flash memory, but xv6 pretends like it’s 1995 and sticks with BIOS. Since<br>xv6 runs on x86 hardware, we’re gonna have to satisfy all the janky requirements<br>that come with that architecture, in addition to the BIOS’s requirements.</p>
<p>Now the BIOS has to load some <em>other</em> code called the boot loader from disk;<br>then it’s the boot loader’s job to load the OS and get it running. The boot<br>loader has to act as a middle-man because the BIOS has no idea where on the disk<br>you decided to put the OS.</p>
<p>The BIOS will look for the boot loader in the very first sector (512 bytes) of<br>whatever mass storage device you told it to boot from, which we’ll call the boot<br>disk. The processor will execute the instructions it finds there. This means<br>you have to make a choice: either your boot loader has to be less than 512 bytes<br>or you can split it up into smaller parts and have each part load the next one.<br>xv6 takes the first approach.</p>
<p>The BIOS loads the boot loader into memory at address 0x7C00, then sets the<br>processor’s <code>%ip</code> register to that address and jumps to it. Remember that <code>%eip</code><br>is the instruction pointer on x86? Okay cool. But why did I write <code>%ip</code> instead<br>of <code>%eip</code>? Well, the BIOS assumes we’re gonna be using 16 bits because of the<br>hellscape known as backwards-compatibility, so we’ve gotta pretend like it’s<br>1975 before we can pretend it’s 1995. The irony here is that this initial 16-bit<br>mode is called “real mode”. So on top of loading the OS, the boot loader will<br>also have to shepherd the processor from real mode to 32-bit “protected mode”.</p>
<p>One last detail: we’ll look at the Makefile and linker script later on, but for<br>now just keep in mind that the boot loader will be compiled separately from the<br>kernel, which will be compiled separately from all the user-space programs. This<br>makes it easier to make sure that the entire boot loader will fit in the first<br>512 bytes on disk. Eventually, the boot loader and the kernel will be stored on<br>the same boot disk together, and the user-space programs will be on a separate<br>disk that holds the file system.</p>
<h2 id="bootasm-S"><a href="#bootasm-S" class="headerlink" title="bootasm.S"></a>bootasm.S</h2><p>Boot loader space is tight, and we want to make sure our instructions are exact,<br>so we’re gonna start off in assembly. The “.S” file extension means it’s gonna<br>be assembled by the GNU assembler <code>as</code>, and we’re allowed to use C preprocessor<br>directives like <code>#include</code> or <code>#define</code> or whatever in the assembly code. Also,<br>xv6 uses AT&amp;T syntax, so if you read CS:APP or took the online course then it’ll<br>be familiar; if you don’t know what that means, then don’t worry about it.</p>
<h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>First we include some header files to use some constants; I’ll point them out<br>later. Next up, we gotta tell the assembler to generate 16-bit code, and set a<br>global label to tell the BIOS where to start executing code.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.code16         # Tell compiler to generate 16-bit code</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br></pre></td></tr></table></figure>

<p>Next up: you know how sometimes you can press a special key to tell the BIOS to<br>stop what it’s doing and let you pick a disk to boot from? Or you move your<br>mouse around in the BIOS menu and you see the pointer moving? Yeah, that needs<br>hardware interrupts in order to work, but right now, we don’t have the faintest<br>clue how to handle those if they happen, so let’s go ahead and turn those off.<br>There’s an x86 instruction to disable them by clearing the interrupt flag in<br>the CPU’s flags register.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli</span><br></pre></td></tr></table></figure>

<p>Now we’ve gotta handle some of x86’s quirks. First off, we’re gonna need 20-bit<br>memory addresses, but we only have 16 bits to work with. x86 uses six segment<br>registers <code>%cs</code> (code segment), <code>%ds</code> (data segment), <code>%ss</code> (stack segment),<br><code>%es</code> (extra segment), <code>%fs</code> and <code>%gs</code> (general-purpose segments) to create 20-<br>bit addresses from 16-bit ones; we’re gonna need the first four. The BIOS<br>guarantees that <code>%cs</code> will be set to zero, but it doesn’t make any promises<br>about the others, so we have to clear them ourselves. We’re not using <code>%eax</code> for<br>anything yet, so we’ll use that to clear the others. The <code>w</code> at the end of <code>xorw</code><br>and <code>movw</code> means we’re operating on 16-bit words.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xorw    %ax,%ax</span><br><span class="line">movw    %ax,%ds     # Data segment</span><br><span class="line">movw    %ax,%es     # Extra segment</span><br><span class="line">movw    %ax,%ss     # Stack segment</span><br></pre></td></tr></table></figure>

<p>This next part is a total hack for backwards-compatibility: sometimes a virtual<br>address might get converted to a 21-bit physical address, and oh no, what are we<br>gonna do? Well, some hardware can’t deal with 21 bits, so it just ignores it,<br>but it’s 1995, so we’ve got fancy hardware that can use that extra bit. Wow, you<br>really know we’re in the future when you’ve got a whole 2 MB of RAM to work<br>with! So we have to tell the processor not to throw away that 21st bit. The way<br>we do that is by setting the second bit of the keyboard controller’s output port<br>to line high. I don’t know. Don’t ask me why. The output ports are 0x64 and<br>0x60, so we’re gonna wait until they’re not busy, then set the magic values that<br>will make this all work.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb     $0x64,%al   # Wait for not busy</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.1</span><br><span class="line"></span><br><span class="line">    movb    $0xd1,%al   # 0xD1 -&gt; port 0x64</span><br><span class="line">    outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb     $0x64,%al   # Wait for not busy</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.2</span><br><span class="line"></span><br><span class="line">    movb    $0xdf,%al   # 0xDF -&gt; port 0x60</span><br><span class="line">    outb    %al,$0x60</span><br></pre></td></tr></table></figure>

<h3 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h3><p>Now it’s time to switch to 32-bit “protected mode”. Up until now, the processor<br>has been converting virtual addresses to physical ones using those segment<br>registers which we cleared, so the mapping has been an identity map. But let’s<br>talk about how x86 converts 32-bit virtual addresses to physical ones; this is<br>important for the rest of the boot loader code as well as the OS, so you’re<br>gonna have to bear with me for this maelstrom of x86-specific details.</p>
<p>The x86 architecture does the conversion in two steps: first segmentation, then<br>paging. A virtual address starts off life as a <em>logical address</em>. Segmentation<br>converts that to a <em>linear address</em>, and paging converts that to a physical one.</p>
<p>A logical address consists of a 20-bit <em>segment selector</em> and a 12-bit offset,<br>with the segment bits before the offset bits, like <code>segment:offset</code>. The CPU’s<br>segmentation hardware uses those segment bits to pick one of those four segment<br>registers we cleared earlier, which acts as an index into a <em>Global Descriptor<br>Table</em> or GDT. Each entry of this GDT tells you where that segment is found in<br>memory using a base physical address and a virtual address for the maximum or<br>limit.</p>
<p>The GDT entry also has some permission bits for that segment; the segmentation<br>hardware will check whether each address can be written to and whether the<br>process generating the virtual address has the right permissions to access it.<br>These checks compare the GDT entry’s <em>Descriptor Privilege Levels</em>, also known<br>as <em>ring levels</em>, against the <em>Current Privilege Level</em>. x86 has four privilege<br>levels (0-3), so if you’ve ever heard of the kernel operating in ring 0 or user<br>code in ring 3, this is where it comes from.</p>
<p>Okay, so the GDT entry will give us the first 20 bits of the new linear address;<br>the offset bits stay the same. After that, the linear address is ready to be<br>converted to a physical address by the paging hardware. We’ll go over this<br>second half of the story in the virtual memory section. For now, the point is<br>this: xv6 is mostly gonna say no thank you to segmentation and stick to paging<br>alone for memory virtualization.</p>
<p>So we’re gonna set up our GDT to map all segments the exact same way: with a<br>base of zero and the maximum possible limit (with 32 bits, that works out to a<br>grand total of 4 GB, wow so much RAM, I can’t imagine ever needing more). We<br>have to stick this GDT somewhere in our code so we can point the CPU to it, so<br>we’ll put it at the end and throw a <code>gdtdesc</code> label on it. Now we can tell the<br>CPU to load it up with a special x86 instruction for that.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt    gdtdesc</span><br></pre></td></tr></table></figure>

<h3 id="Protected-Mode"><a href="#Protected-Mode" class="headerlink" title="Protected Mode"></a>Protected Mode</h3><p>Good news, everyone! We’re finally ready to turn on protected mode, which we do<br>by setting the zero bit of the <code>%cr0</code> control register. Note that the <code>l</code> at the<br>end of the instructions here means we’re now using long words, i.e. 32 bits;<br><code>CR0_PE</code> is defined in the <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a><br>header file as 0x1.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    %cr0, %eax      # Copy %cr0 into %eax</span><br><span class="line">orl     $CR0_PE, %eax   # Set bit 0</span><br><span class="line">movl    %ax, %cr0       # Copy it back</span><br></pre></td></tr></table></figure>

<p>Oh wait, I lied. Enabling protection mode like we just did doesn’t change how<br>the processor translates addresses. We have to load a new value into a segment<br>register to make the CPU read the GDT and change its internal segmentation<br>settings. We can do that by using a long jump instruction, which lets us specify<br>a code segment selector. We’re just gonna jump to the very next line anyway, but<br>in doing so we’ll force the CPU to start using the GDT, which describes a 32-bit<br>code segment, so <em>now</em> we’re finally in 32-bit mode! Here, <code>SEG_KCODE</code> is a<br>constant defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as segment 1, for <code>%cs</code>; we bitshift it left by 3.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ljmp    $(SEG_KCODE&lt;&lt;3), $start32</span><br></pre></td></tr></table></figure>

<p>First we signal the compiler to start generating 32-bit code. Then we initialize<br>the data, extra, and stack segment registers to point to the <code>SEG_KDATA</code> entry<br>of the GDT; that constant is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as the segment for the kernel<br>data and stack. We’re not required to set up <code>%fs</code> and <code>%gs</code>, so we’ll just zero<br>them.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.code 32    # Tell assembler to generate 32-bit code now</span><br><span class="line">start32:</span><br><span class="line">    movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector</span><br><span class="line">    movw    %ax, %ds    # Data segment</span><br><span class="line">    movw    %ax, %es    # Extra segment</span><br><span class="line">    movw    %ax, %ss    # Stack segment</span><br><span class="line">    movw    $0, %ax     # Zero the segments not ready for use</span><br><span class="line">    movw    %ax, %fs</span><br><span class="line">    movw    %ax, %gs</span><br></pre></td></tr></table></figure>

<h3 id="The-Kernel-Stack"><a href="#The-Kernel-Stack" class="headerlink" title="The Kernel Stack"></a>The Kernel Stack</h3><p>Okay, last step in the assembly code now: we have to set up a stack in an unused<br>part of memory. In x86, the stack grows downwards, so the “top” of the stack–<br>that is, the most-recently-added byte–is actually at the bottom of the stack in<br>physical memory. It’s annoying, but we’re gonna have to keep track of that. The<br><code>%ebp</code> register points to the base of the stack (i.e., the first byte we pushed<br>onto the stack), and the <code>%esp</code> register holds the address of the top of the<br>stack (most-recently-pushed byte).</p>
<p>But where should we put the stack? The memory from 0xA_0000 to 0x10_0000 is<br>littered with a memory regions that I&#x2F;O devices are gonna be checking, so that’s<br>out. The boot loader starts at 0x7C00 and takes up 512 bytes, so that means it<br>ends at 0x7E00. So xv6 is gonna start the stack at 0x7C00 and have it grow down<br>from there, toward 0x0000 and away from the boot loader. Remember how back in<br>the beginning, we started off the assembly code with a <code>start</code> label? That means<br>that <code>start</code> is conveniently located at 0x7C00.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    $start, %esp</span><br></pre></td></tr></table></figure>

<p>And we’re done with assembly! Time to move on to C code for the rest of the boot<br>loader. We’ll take over with a C function called <code>bootmain()</code>, which should<br>never return. The linker will take care of connecting the call here to its<br>definition in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">bootmain.c</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    bootmain</span><br></pre></td></tr></table></figure>

<h3 id="Handling-Errors"><a href="#Handling-Errors" class="headerlink" title="Handling Errors"></a>Handling Errors</h3><p>Wait, what? There’s more assembly code after this? Why?</p>
<p>Well, if something goes wrong in <code>bootmain()</code>, then the function will return, so<br>we have to handle that here. Since we usually run OSes we’re developing in an<br>emulator like Bochs or QEMU, we’ll trigger a breakpoint and loop. Bochs listens<br>on port 0x8A00, so we can transfer control back to it there; this wouldn’t do<br>anything on real hardware.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    movw    $0x8a00, %ax    # 0x8a00 -&gt; port 0x8a00</span><br><span class="line">    movw    %ax, %dx</span><br><span class="line">    outw    %ax, %dx</span><br><span class="line">    movw    $0x8ae0, %ax    # 0x8ae0 -&gt; port 0x8a00</span><br><span class="line">    outw    %ax, %dx</span><br><span class="line">spin:</span><br><span class="line">    jmp     spin            # loop forever</span><br></pre></td></tr></table></figure>

<h3 id="The-Global-Descriptor-Table"><a href="#The-Global-Descriptor-Table" class="headerlink" title="The Global Descriptor Table"></a>The Global Descriptor Table</h3><p>Oh, and remember when we promised the hardware that we were gonna give it a GDT?<br>We even told it to load it from address <code>gdtdesc</code>, remember? Well, we have to<br>deliver on that promise now by defining the GDT here.</p>
<p>x86 expects that the GDT will be aligned on a 32-bit boundary, so we tell the<br>assembler to do that. Then we use the macros <code>SEG_NULLASM</code> and <code>SEG_ASM</code> defined<br>in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/asm.h">asm.h</a> to create three segments: a null segment, a segment for executable<br>code, and another for writeable data. The null segment has all zeroes; the first<br>argument to <code>SEG_ASM</code> has the permission bits, the second is the physical base<br>address, and the third is the maximum virtual address. As we said before, xv6<br>relies mostly on paging, so we set the segments to go from 0 to 4 GB so they<br>identity-map all the memory.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.p2align 2      # force 4-byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                             # null segment</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code segment</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)         # data segment</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word   (gdtdesc - gdt - 1)     # sizeof(gdt) - 1</span><br><span class="line">    .long   gdt                     # address of gdt</span><br></pre></td></tr></table></figure>

<h2 id="bootmain-c"><a href="#bootmain-c" class="headerlink" title="bootmain.c"></a>bootmain.c</h2><p>Okay, the rest of the boot loader is in C now! Most of the code here is just to<br>interact with the disk in order to read the kernel from disk and load it into<br>memory. Let’s start off by looking at <code>waitdisk()</code>.</p>
<h3 id="waitdisk"><a href="#waitdisk" class="headerlink" title="waitdisk"></a>waitdisk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HEAD. DESK. Why all the magic numbers? At least we’re lucky that the name makes<br>it obvious what this function does; this won’t always be true in xv6. Okay, so<br>this function does only one thing: it loops until the disk is ready. Disk specs<br>are boring as all hell, so feel free to skip to the next section if you don’t<br>care about the particulars (I don’t blame you).</p>
<p>The usual way to talk to the disk is with Direct Memory Access (DMA), in which<br>devices are hooked up directly to RAM for easy communication. But we haven’t<br>initialized the disk at all or set up any drivers for it; that’s the OS’s<br>responsibility, not the boot loader’s. Even if we could ask the disk to give us<br>some data through memory-mapped I&#x2F;O, we disabled all interrupts, so we wouldn’t<br>know when it’s ready. So instead, we have to go back to assembly code (ugh, I<br>know) to access the disk directly.</p>
<p>Storage disks have all kinds of standardized specifications, among them IDE<br>(Integrated Drive Electronics) and ATA (Advanced Technology Attachment). The<br>ATA specs include a Programmed I&#x2F;O mode where data can be transferred between<br>the disk and CPU through I&#x2F;O ports. This is usually a huge waste of resources<br>because every byte has to be transferred through a port and the CPU is busy the<br>entire time, but right now beggars can’t be choosers.</p>
<p>Each disk controller chip has two buses (primary and secondary) for use with ATA<br>PIO mode; the primary bus sends data on port 0x1F0 and has control registers on<br>ports 0x1F1 through 0x1F7. In particular, port 0x1F7 is the status port, which<br>will have some flags to let us know what it’s up to. The sixth bit (or 0x40 in<br>hex) is the RDY bit, which is set when it’s ready to receive more commands. The<br>seventh bit (i.e., 0x80) is the BSY bit, which if set says the disk is busy.</p>
<p>Since interrupts are disabled, we’ll have to manually poll the status port in an<br>infinite loop until the BSY bit is not set but the RDY bit is: <code>inb()</code> is a C<br>wrapper (defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">x86.h</a>) for the x86 assembly instruction <code>inb</code>, which reads<br>from a port. We don’t care about any of the other status flags, so we’ll get rid<br>of them by bitwise-ANDing the result with 0xC0 &#x3D; 0x40 + 0x80. If the result of<br>that is 0x40, then only the RDY bit is set and we’re good to go.</p>
<p>Phew. That was a lot for just one line of code.</p>
<h3 id="readsect"><a href="#readsect" class="headerlink" title="readsect"></a>readsect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Issue command</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);</span><br><span class="line">    outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read data</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you skipped the last section: this function reads a sector (which in the<br>current-year-according-to-xv6 of 1995 is 512 bytes) from disk. Good to see you<br>again, on to the next section for you!</p>
<p>If you powered through the pain and read about ATA PIO mode above, some of the<br>magic numbers here might be familiar. First we call <code>waitdisk()</code> to wait for the<br>RDY bit, then we send some stuff over ports 0x1F2 through 0x1F7, which we know<br>are the command registers for the primary ATA bus.</p>
<p>Note that <code>uint</code> is just a type alias for C’s <code>unsigned int</code>, defined in the<br>header file <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">types.h</a>. The <code>offset</code> argument is in bytes, and determines which<br>sector we’re gonna read; sector 0 has to hold the boot loader so the BIOS can<br>find it, and in xv6 the kernel will start on disk at sector 1.</p>
<p><code>outb()</code> is another C wrapper for an x86 instruction from <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>; this one’s<br>the opposite of <code>inb()</code> because it sends data out to a port. The disk controller<br>register at port 0x1F2 determines how many sectors we’re gonna read. Ports 0x1F3<br>through 0x1F6 are where the sector’s address goes. If you <em>really</em> must know<br>(why?) they’re the sector number register, the cylinder low and high registers,<br>and the drive&#x2F;head register, in order. Port 0x1F7 was the status port above, but<br>it also doubles as the command register; we send it command 0x20, aka READ<br>SECTORS.</p>
<p>Then we wait for the RDY bit again before reading from the bus’s data register<br>at port 0x1F0, into the address pointed to by <code>dst</code>. Once again, <code>insl()</code> is a<br>C wrapper for the x86 instruction <code>insl</code>, which reads from a port into a string.<br>The <code>l</code> at the end means it reads one long-word (32 bits) at a time.</p>
<h3 id="readseg"><a href="#readseg" class="headerlink" title="readseg"></a>readseg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(uchar *pa, uint count, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar *epa = pa + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round down to sector boundary</span></span><br><span class="line">    pa -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time. We&#x27;d write</span></span><br><span class="line">    <span class="comment">// more to memory than asked, but it doesn&#x27;t matter -- we load in increasing</span></span><br><span class="line">    <span class="comment">// order.</span></span><br><span class="line">    <span class="keyword">for</span> (; pa &lt; epa; pa += SECTSIZE, offset++) &#123;</span><br><span class="line">        readsect(pa, offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Okay, finally, we’re done with assembly and disk specs. We’re gonna read <code>count</code><br>bytes starting from <code>offset</code> into physical address <code>pa</code>. Note that <code>uchar</code> is<br>another type alias for <code>unsigned char</code> from <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>; this means that <code>pa</code> is a<br>pointer (which is 32 bits in x86) to some data where each piece is 1 byte.</p>
<p><code>epa</code> will point to the end of the part we want to read. Now, <code>count</code> might not<br>be sector-aligned, so we fix that. Declaring <code>pa</code> as a <code>uchar *</code> lets us do this<br>pointer arithmetic easily because we know that adding 1 to <code>pa</code> makes it point<br>at the next byte; if it were a <code>void *</code> like in <code>readsect()</code>, pointer arithmetic<br>would be undefined. (Actually, GCC lets you do it anyway, but GCC lets you get<br>away with a lot of crazy stuff, so let’s not go there.)</p>
<p>Now that we’ve got everything set up, we just call <code>readsect()</code> in a for loop to<br>read one sector at a time, and that’s it!</p>
<p>Some people have asked about the structure of some of the for loops in xv6,<br>because they don’t always use obvious index variables like <code>int i</code>. There are<br>plenty of reasons to hate C, but I think the way it structures for loops is by<br>far one of its most powerful features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test condition; update statements) &#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When evaluating the for loop, C first executes anything in the initialization.<br>Then it checks whether the test condition is true; if so, it executes the code<br>inside the loop. Then it carries out the update statements before checking the<br>test condition again and runnning the code if it’s still true.</p>
<p>In the for loop above, the initialization is just an empty statement; all the<br>variables we want to use have already been set up, so we don’t need it and C<br>will just move on to the next step. The test condition is simple enough. But the<br>update statement actually increments both <code>pa</code> and <code>offset</code> at once before going<br>through the loop again.</p>
<p>Okay great, so now we can read from the disk into memory, so we’re all set up to<br>load the kernel and start running it!</p>
<h3 id="ELF-Files"><a href="#ELF-Files" class="headerlink" title="ELF Files"></a>ELF Files</h3><p>Before we move on to the star of the show, <code>bootmain()</code>, we need to talk about<br>how a computer can actually recognize a file as executable. When you compile<br>some code, the result gets spit out in a format that your machine can recognize,<br>load into memory, and run; it’s usually the linker’s job to do this. Most Unix<br>and Unix-like systems use the standardized Executable and Linkable Format, or<br>ELF, for this purpose.</p>
<p>ELF divides the executable file into sections: <code>text</code> (the code’s instructions),<br><code>data</code> (initialized global variables), <code>bss</code> (statically-allocated variables<br>that have been declared but not initialized), <code>stab</code> and <code>stabstr</code> (debugging<br>symbols and similar info), <code>rodata</code> (read-only data, usually stuff like string<br>literals).</p>
<p>An ELF file starts with a header which has a magic number: 0x7F followed by the<br>letters “ELF” represented as ASCII bytes; an OS can use this to recognize an ELF<br>file. The header also tells you the file’s type: it could be an executable, or a<br>library to be linked with executables, or something else. There’s a whole bunch<br>of other info in the header, like the architecture it’s made to run on, version,<br>etc., but we’re gonna ignore most of that.</p>
<p>The most important parts of the header are the part where it tells us where in<br>the file the processor should start executing instructions and the part that<br>describes the number of entries, on-disk offset, and size of the program header<br>table.</p>
<p>The program header table is an array that has one entry for each of the file<br>sections above that’s found in this program. It describes the offset in the file<br>where each section can be found along with the physical and virtual address at<br>which that section should be loaded into memory and the size of the section,<br>both in the file and in memory; these might differ if, e.g. the program contains<br>some uninitialized variables which don’t need to be stored in the file but do<br>need to have space in memory.</p>
<p>The kernel (along with all the user-space programs) will be compiled and linked<br>as ELF files, so <code>bootmain()</code> will have to parse the ELF header to find the<br>program header table, then parse that to load each section into memory at the<br>right address. xv6 uses a <code>struct elfhdr</code> and a <code>struct proghdr</code>, both defined<br>in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/elf.h">elf.h</a>, for this purpose.</p>
<p>Okay, back to the boot loader to finish up now!</p>
<h3 id="bootmain"><a href="#bootmain" class="headerlink" title="bootmain"></a>bootmain</h3><p>This is the C function that gets called by the first part of the boot loader<br>written in assembly. Its job will be to load the kernel into memory and start<br>running it at its entry point, a program called <code>entry()</code>.</p>
<p>Next up, we’re gonna use <code>readseg()</code> to load the kernel’s ELF header into memory<br>at physical address 0x1_0000; the number isn’t too important because the header<br>won’t be used for long; we just need some scratch space in some unused memory<br>away from the boot loader’s code, the stack, and the device memory-mapped I&#x2F;O<br>region. We’ll read 4096 bytes first at offset 0; <code>readseg()</code> turns that offset<br>into sector 1. Remember that we have to convert <code>elf</code> into a <code>uchar *</code> so that<br>the pointer arithmetic in <code>readseg()</code> works out the way we want it to.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> elfhdr *) <span class="number">0x10000</span>;</span><br><span class="line">    readseg((uchar *) elf, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>While we’re at it, let’s go ahead and make sure that what we’re loading really<br>is an ELF file and not some random other garbage because any of a million things<br>went wrong during the compilation process, or we got some rootkit that totally<br>corrupted the kernel or something. It’s not really the most robust of checks,<br>but <em>eh</em>. If something went wrong we’ll just return, since we know that the code<br>in <code>bootasm.S</code> is ready to handle that with some Bochs breakpoints.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have to look at the program header table to know where to find each of<br>the kernel’s segments. The <code>elf-&gt;phoff</code> field tells us the program header<br>table’s offset from the start of the ELF header, so we’ll set <code>ph</code> to point to<br>that and <code>eph</code> to point to the end of the table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (<span class="keyword">struct</span> proghdr *) ((uchar *) elf + elf-&gt;phoff);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">eph</span> =</span> ph + elf-&gt;phnum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each entry in the program header table tells us where to find a segment, so<br>we’ll iterate over the entries, reading each one from disk and loading it up. In<br>this for loop, note that <code>ph</code> is a <code>struct proghdr *</code>, so incrementing it with<br><code>ph++</code> increments it by the size of a <code>struct proghdr</code> and not by one byte; this<br>makes it automatically point at the next entry in the table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">        uchar *pa = (uchar *) ph-&gt;paddr;    <span class="comment">// address to load section into</span></span><br><span class="line">        readseg(pa, ph-&gt;filesz, ph-&gt;off);   <span class="comment">// read section from disk</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the segment&#x27;s size in memory is larger than the file image</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;memsz &gt; ph-&gt;filesz) &#123;</span><br><span class="line">            stosb(pa + ph-&gt;filesz, <span class="number">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That if statement at the end checks if the section’s size in memory should be<br>larger than its size in the file, in which case it calls <code>stosb()</code>, which is yet<br>another C wrapper from <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a> for the x86 instruction <code>rep stosb</code>, which block<br>loads bytes into a string. It’s used here to zero the rest of the memory space<br>for that section. Okay, but why would we want to do that? Well, if the reason<br>it’s larger is because it has some uninitialized static variables, then we want<br>to make sure those start off holding zero (as the C standard requires) and not<br>whatever garbage value may have been there before.</p>
<p>Last part of the bootloader: let’s call the kernel’s entry point, <code>entry()</code>, and<br>get it running! But remember how the boot loader is compiled and linked<br>separately from the kernel? Yeah, that means we can’t just call <code>entry()</code> as a<br>function, because then the linker would go “Huh? What entry function? I don’t<br>have any <code>entry</code> function here in your symbol table. REJECTED.” And then it<br>would throw a huge error.</p>
<p>Luckily, the ELF header tells us where to find the entry point in memory, so we<br>could get a pointer to that address. That means… function pointers! If you’ve<br>never used function pointers in C before, then this won’t be the last time<br>you’ll see them in xv6, so check it out.</p>
<p>A C function is just a bunch of code to be executed in order, right? That means<br>it shows up in the ELF file’s <code>text</code> section, which will end up in memory. When<br>you call a regular old C function, the compiler just adds some extra assembly<br>instructions to throw a return address on the stack and update the registers<br><code>%ebp</code> and <code>%esp</code> to point to the new function’s stack on top of the old one. If<br>the function getting called has any arguments or local variables, they’ll get<br>pushed onto the stack too. Then the instruction register <code>%eip</code> gets updated to<br>point to the new function section, and that’s it. After the compiler is done,<br>the linker will replace the function’s name with its memory address in the<br><code>text</code> section, and voila, a function call.</p>
<p>The point of all this is that in C we can use pointers to functions; they just<br>point to the beginning of that function’s instructions in memory, where the<br><code>%eip</code> register would end up pointing if the function gets called. So in this<br>case, even though we’re not linking with the kernel, we can still call into the<br>entry point by getting its address from the ELF header, creating a function<br>pointer to that address, then calling the function pointer. The compiler will<br>still add all the usual stack magic, but instead of the linker determining where<br><code>%eip</code> should point, we’ll do that ourselves.</p>
<p>The first line below declares <code>entry</code> as a pointer to a function with argument<br>type <code>void</code> and return type <code>void</code>. Then we set <code>entry</code> to the address from the<br>ELF header, then we call it.</p>
<p>Again, this shouldn’t return, but if it does then it’s the last part of this<br>function, so this function will return back into the assembly boot loader code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">void</span> (*entry)(<span class="type">void</span>);</span><br><span class="line">    entry = (<span class="type">void</span>(*) (<span class="type">void</span>)) (elf-&gt;entry);</span><br><span class="line">    entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s it! Starting from <code>entry()</code>, we’re officially out of the boot loader and<br>into the kernel.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, the assembly part of the boot loader (1) disabled interrupts, (2)<br>set up the GDT and segment registers so the segmentation hardware is happy and<br>we can ignore it later, (3) set up a stack, and (4) got us from 16-bit real mode<br>to 32-bit protected mode.</p>
<p>Then the C part of the boot loader just loaded the kernel from disk and called<br>into its entry point.</p>
<p>ELF headers will continue to haunt us in the kernel’s linker script and when we<br>load user programs from disk in <code>exec()</code>, and function pointers will make<br>another appearance when we get around to handling interrupts. The good news: the<br>boot loader is one of the most opaque parts of the xv6 code, full of boring<br>hardware specs and backwards-compatibility requirements, so if you made it this<br>far, it does get better!</p>
<p>(But it also gets worse… looking at you, <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mp.c">mp.c</a> and <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kb.c">kbd.c</a>…)</p>
<h1 id="The-Beginning-Entry-and-Paging"><a href="#The-Beginning-Entry-and-Paging" class="headerlink" title="The Beginning: Entry and Paging"></a>The Beginning: Entry and Paging</h1><h2 id="xv6’s-Memory-Layout"><a href="#xv6’s-Memory-Layout" class="headerlink" title="xv6’s Memory Layout"></a>xv6’s Memory Layout</h2><p>The whole point of virtualizing memory is to give users the illusion that they<br>can roam freely across a limitless field of memory without worrying their pretty<br>little heads about such boring details as how much physical memory their machine<br>actually has, or where kernel code is stored, or the fact that their seemingly-<br>continuous heap space is actually shattered into tons of tiny pages spread out<br>in possibly random parts of physical memory. As long as user code is well-<br>behaved, that illusion should hold up; if they do a no-no we’ll just smack them<br>with a segmentation fault.</p>
<p>One downside is that the kernel also has to use virtual memory, so we’re faced<br>with the potentially-complicated challenge of setting things up in physical<br>memory without knowing where anything is actually located in physical memory! So<br>xv6 does something that a lot of OSes do: it sets itself up as a higher-half<br>kernel. That means that in the virtual address space (from 0 to 4 GB), the<br>kernel will reside in the upper half starting at 2 GB, i.e. address 0x8000_0000<br>and up; user code will start at 0 and end at 2 GB. Because of this, <code>KERNBASE</code><br>is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a> as 0x8000_0000.</p>
<p>Then it sets up paging so that all of physical memory is identity-mapped to<br>virtual memory starting at 0x8000_0000. This makes it really convenient for the<br>kernel to figure out the physical address of a virtual address it’s using; just<br>subtract <code>KERNBASE</code> and you’re done. The <code>V2P</code> and <code>V2P_WO</code> macros defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a> do just that, and the <code>P2V</code> and <code>P2V_WO</code> add <code>KERNBASE</code> to a<br>physical address to get the kernel virtual address.</p>
<p>Note that I said “kernel virtual address”, not just any old virtual address.<br>Users don’t get these kinds of fancy privileges, because they shouldn’t be<br>worrying about where anything is in physical memory. They’re running through a<br>limitless field of virtual memory, remember? So user virtual addresses between 0<br>and 2 GB will get mapped to totally arbitrary locations in physical memory.</p>
<p>One consequence of this is that xv6 is limited to no more than 2 GB of physical<br>memory (instead of the 4 GB that 32-bit addresses allow for) in order to map it<br>all into the top 2 GB of virtual memory. In reality, it’s even less, for two<br>reasons: (1) we also need to map device I&#x2F;O regions into virtual memory, so<br>it’ll be a little less than 2 GB, and (2) it’s hard and annoying to figure out<br>how much physical memory is actually present on any given machine, so xv6 just<br>says to hell with all that and picks the totally arbitrary value of a puny 224<br>MB as the amount of available physical memory (that’s <code>PHYSTOP</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a>).</p>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>Remember when we talked about segmentation, and how we said we’d come back to<br>paging later? Guess what? It’s later.</p>
<p>So all virtual addresses are really “logical addresses”, and segmentation turns<br>those into “linear addresses”. In xv6, the boot loader set up the segmentation<br>hardware to use an identity map, so virtual addresses are the same as logical<br>addresses are the same as linear addresses. Now paging has to turn those linear<br>addresses into physical addresses. Just like segmentation uses a GDT and the<br>segment registers for its mapping, paging uses a page directory, page tables,<br>and the <code>%cr3</code> register.</p>
<p>First, imagine a world where every single time some user code throws up an<br>address (maybe it looks up a variable, or it calls a function, or it simply<br>needs to execute the next instruction), the CPU has to stop what it’s doing,<br>save all the user’s register contents, load up some kernel code, restore its<br>register contents, find out where its stack is, get it running, and then ask the<br>OS where that virtual address is actually located in physical memory. That would<br>be <em>so</em> slow. We don’t want that. We want the hardware to do all the address<br>conversions by itself, and involve the OS only minimally to set up a new page<br>directory when it starts a new process.</p>
<p>Instead, the x86 hardware uses one of its control registers, <code>%cr3</code>, to store a<br>pointer to a page directory in memory. Then every time it needs to map a linear<br>address to a physical one, it goes to that page directory and grabs the relevant<br>entry. That entry is a pointer to a page <em>table</em> somewhere else in memory, so<br>the processor grabs the right entry from there, which points to a 4096-byte page<br>in some other location.</p>
<p>A linear address has a three-part structure: the 10 most significant bits are an<br>index that picks an entry from the page directory, the next 10 bits are an index<br>to pick an entry from whatever page table we’ve been directed to, and the last<br>12 bits are an offset that determines where to look in the page that the page<br>table entry pointed to.</p>
<p>For example, let’s say we have a virtual address like 0x9C4A_02BF. If we convert<br>to binary, split it up, and convert back to hex, we can see that the 10 most<br>significant bits are 0x271, the next 10 are 0x0A0, and the last 12 are 0x2BF. So<br>the paging hardware would look at wherever <code>%cr3</code> is pointing to find the page<br>directory; let’s just call it <code>pgdir</code>. Then it would take entry <code>pgdir[0x271]</code><br>and go look wherever that’s pointing to find the right page table; let’s call<br>that <code>pgtab271</code>. Then it would take entry <code>pgtab271[0x0A0]</code> and look wherever<br>that’s pointing to find the right page, <code>pg</code>. <em>Then</em> it would finally<br>know that the corresponding physical address is <code>pg + 0x2BF</code>. Whew.</p>
<p>This still sounds super slow, so the paging hardware uses a cache called the<br>Translation Lookaside Buffer (TLB) to store recently-used mappings and make them<br>faster in the future. Since pages are 4096 bytes, it only needs to map a new<br>page if the addresses some code is asking for crosses a page boundary.</p>
<p>xv6 provides two macros, <code>PDX</code> and <code>PTX</code> defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>, to recover just the<br>page directory index bits or the page table index bits, respectively, from a<br>virtual address.</p>
<p>Finally: an important aspect of virtual memory is that each process should be<br>isolated from the others, and the kernel should be isolated from user processes.<br>So each process will get its own page directory, and each entry of that page<br>directory will say whether it’s present (i.e., mapped) or not. If it’s present,<br>then it points to a page table for that process; if it’s not present and we try<br>to access it, we’ll get a page fault or a general protection fault. Each entry<br>in a page table will also say whether that page is present and what kinds of<br>permissions it has. The bit flags for the permissions are (in order from least<br>to most significant bit):</p>
<ul>
<li>Bit 0: present.</li>
<li>Bit 1: read&#x2F;write.</li>
<li>Bit 2: user (otherwise only the kernel can access it).</li>
<li>Bit 3: write-through.</li>
<li>Bit 4: cache disabled.</li>
<li>Bit 5: accessed (for the TLB).</li>
<li>Bit 6: page size (we’ll talk about this later).</li>
<li>Bit 7: (unused).</li>
</ul>
<p>This way, since each process has its own page directory, page tables, and pages,<br>and each level has specific permissions set, they should never be able to<br>interfere with each other.</p>
<p>Again, most of the time, the kernel will just happily ignore all this and use<br>the mapping in the higher half of virtual memory for simplicity. Each user<br>process’s page directory will have the same mapping in the higher half so that<br>the kernel can keep doing what it’s doing no matter which user process is<br>currently running.</p>
<p>Anyway, back to the code! We left off after the boot loader had finished loading<br>the kernel into memory; it ended by calling an <code>entry()</code> function in the kernel.<br>We haven’t set up paging yet, so that’s next on our to-do list. But first, the<br>kernel is compiled and linked using a <em>linker script</em>, so we’ll have to look at<br>that to understand how that sets up memory the way we want it.</p>
<h2 id="kernel-ld"><a href="#kernel-ld" class="headerlink" title="kernel.ld"></a>kernel.ld</h2><p>The gory details of linker scripts as a whole are outside the scope of these<br>posts, so I’m gonna gloss over a lot of the parts of this file and focus on<br>the important pieces.</p>
<p>It’s important to understand what a linker does in a rough sense, so I’ll just<br>generalize and wave my hands around and say that a compiler takes code in a<br>high-level language and converts it to assembly, an assembler takes that<br>assembly code and turns it into machine code, and a linker takes a whole bunch<br>of machine code files (including any code for library functions) and links them<br>all together into a single executable file.</p>
<p>注释: compiler -&gt; assembler -&gt; linker, high-level language -&gt; asm code -&gt; machine code</p>
<p>Linking involves three steps that are important for us here: first, the linker<br>has to assign each piece of code a location in memory, so that different<br>variables, functions, etc. don’t end up colliding; then it replaces references<br>to that object with its address. Second, it has to resolve any outstanding<br>symbols (variables, functions, etc.) in each file by looking them up in all the<br>other files and replacing them with those addresses; the linker can define its<br>own symbols too. Third, it has to create an output file in a format that the OS<br>can use, like ELF.</p>
<p>注释: 链接的本质是将符号(symbol)替换为地址值(address)，symbol主要指函数；链接输出二进制程序例如elf</p>
<p>xv6 has decided that command-line flags are too basic for it, so instead it’ll<br>use a linker script <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a> for the GNU linker.</p>
<p>We start off by specifying the output format (32-bit ELF), the architecture<br>(x86, also known as i386), and the entry point to start executing code. The<br>convention is to call the entry point <code>_start</code>; the ELF header will include its<br>address, which is how we were able to call it from the boot loader.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure>

<p>Next up come the sections. Remember the ELF sections <code>text</code>, <code>rodata</code>, <code>data</code>,<br><code>bss</code>, and <code>stab</code>? Well we’ve gotta tell the linker where to set them up in<br>memory, using commands like <code>. = address</code>. These are virtual addresses, so since<br>we want to set up our kernel in the higher half of virtual memory, we’ll tell it<br>to link the code start at 0x8010_0000. Again, we use that address instead of<br>0x8000_0000 (which maps to physical address 0) because we have to avoid the<br>address spaces of the boot loader and the memory-mapped I&#x2F;O devices.</p>
<p>We can also tell the linker where in physical memory the code should be placed<br>(in linker script lingo, its “load address”) using the <code>AT(address)</code> command.<br>We’ll use the physical address 0x0010_0000, since that maps to virtual address<br>0x8010_0000.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x80100000;</span><br><span class="line"></span><br><span class="line">    .text : AT(0x100000) &#123;</span><br><span class="line">        /* this part tells the linker which files to include in this section */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* more sections here... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s one other detail we should check out: the linker can create its own<br>symbols using the <code>PROVIDE(symbol = .)</code> command. If the code happens to declare<br>its own variable <code>symbol</code>, then the linker will just throw away its own version<br>of it, but if the code uses <code>symbol</code> without defining it, then the linker will<br>replace those references with the contents of that memory location.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* virtual address and text sections are defined as above */</span><br><span class="line"></span><br><span class="line">    PROVIDE(etext = .);     /* etext will be at the address right after the end</span><br><span class="line">                            of the text section */</span><br><span class="line"></span><br><span class="line">    /* rodata, stab, and stabstr sections defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(data = .);      /* data will be at the address at the very beginning</span><br><span class="line">                            of the data section */</span><br><span class="line"></span><br><span class="line">    /* data section defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(edata = .);     /* edata will be at the address right after the end</span><br><span class="line">                            of the data section */</span><br><span class="line"></span><br><span class="line">    /* bss section defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(end = .);       /* end will be at the very last address at the end</span><br><span class="line">                            of the entire kernel code */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Those variables will be used later in the kernel code; not so much for their<br>contents but for their addresses, as pointers to the virtual addresses of<br>specific parts of the kernel’s code in memory. On to the kernel!</p>
<h2 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h2><p>I have bad news. That <code>entry()</code> function that the boot loader called? It’s in<br>assembly again. :(</p>
<h3 id="Multiboot-Header"><a href="#Multiboot-Header" class="headerlink" title="Multiboot Header"></a>Multiboot Header</h3><p>Okay, so first off, we’ve got some more hideous specs to deal with for a bit in<br>the form of a multiboot header. Multiboot is a specification that lets boot<br>loaders load up kernel code in a standardized way; the GNU boot loader GRUB uses<br>it. So this part is mostly here in case you want to run xv6 on real hardware<br>using GRUB; feel free to skip to <code>entry()</code> below.</p>
<p>The original Multiboot specification has since been replaced with Multiboot 2,<br>but again, it’s 1995, so we don’t know about that yet.</p>
<p>Multiboot helps compliant kernels and boot loaders identify each other using a<br>special header. The header must be completely contained in the first 8192 bytes<br>of the kernel’s image, and it must be 32-bit aligned. The header contains three<br>things: (1) a magic number used for mutual identification and recognition<br>(0x1BADB002 for kernels, 0x2BADB002 for boot loaders), (2) some flags for the<br>kernel to inform the boot loader what the kernel requires in order to run<br>successfully, and (3) a 32-bit unsigned checksum which when added to the other<br>two fields must have a 32-bit unsigned sum of zero. Depending on the flags that<br>are set, there may be other components to the Multiboot header.</p>
<p>So we’ll start by creating a <code>multiboot_header</code> label at the beginning of the<br>file (and thus, the beginning of the kernel image) and making sure it’s aligned<br>to 32 bits.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.p2align 2      # Force 4-byte alignment</span><br><span class="line">.text</span><br><span class="line">.globl multiboot_header</span><br><span class="line">multiboot_header:</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Now we’ll just add the magic number, set the flags to 0 to indicate no special<br>requirements, and add the checksum.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define magic 0x1badboo2</span><br><span class="line">#define flags 0</span><br><span class="line">.long magic</span><br><span class="line">.long flags</span><br><span class="line">.long (-magic-flags)</span><br></pre></td></tr></table></figure>

<p>And that’s it!</p>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>Back in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, we said that the linker would set up the kernel’s ELF<br>header to specify the kernel’s entry point using <code>_start</code>, but <code>_start</code> itself<br>wasn’t actually defined there, so we have to do that first. We don’t know where<br>this code will end up in memory, so we’ll define an <code>entry</code> label and set<br><code>_start</code> to the address of <code>entry</code>. Note that the linker script used virtual<br>addresses in the higher half, but we haven’t set up paging yet, so we’ll have to<br>convert it to a physical address using one of the macros we mentioned earlier.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start = V2P_WO(entry)</span><br><span class="line">.globl entry</span><br></pre></td></tr></table></figure>

<p>Next up we want to finish setting up virtual memory by enabling paging, but<br>that’s all kinds of complicated, so we’re gonna start off with a super simple<br>version of paging. Part of that difficulty is that there’s a bootstrap problem:<br>we need to allocate pages to hold the page tables themselves, but we can’t use<br>pages without page tables… uhh…</p>
<p>We’ll solve that by starting off with a basic, super-simple page directory where<br>only two entries are mapped: the first entry maps virtual addresses 0 to 4 MB to<br>physical addresses 0 to 4 MB, and the second entry maps virtual addresses<br><code>KERNBASE</code> to <code>KERNBASE</code> + 4MB to physical addresses 0 to 4 MB. One consequence<br>is that the entire kernel code and data has to fit in 4 MB.</p>
<p>Why the two entries pointing to the same place? It’s to solve another bootstrap<br>problem. The kernel is currently running in physical addresses close to 0. Once<br>we enable paging and start using virtual addresses in the higher half, the stack<br>pointer <code>%esp</code>, instruction pointer <code>%eip</code>, even the pointer in <code>%cr3</code> to the<br>page directory itself will all still point to low addresses until we update<br>them. But updating them requires executing instructions, which would require<br>accessing low addresses a few more times. If we left out the low addresses, we’d<br>get a page fault, and since we don’t have exception handlers set up yet, that<br>would cause a double fault, which would turn into the dreaded <strong>TRIPLE FAULT</strong>,<br>in which the processor enters an infinite reboot loop. So yeah, point is, we<br>need both the low and high mappings for now; we’ll get rid of the low mappings<br>once we’re done setting up.</p>
<p>But wait! Aren’t page directory entries supposed to point to page tables? How<br>can they point directly to pages here? It turns out that x86 can skip that<br>second layer altogether if we use so-called “huge” pages of 4 MB in size instead<br>of the usual 4 KB. In the long run, this could lead to internal fragmentation,<br>but it does cut down on the overhead and allows a faster set-up. Plus we’re only<br>gonna use them for a minute while we get ready for the full paging ordeal.</p>
<p>To use 4 MB pages, we have to enable x86’s Page Size Extension (PSE) by setting<br>the fourth bit in the <code>%cr4</code> register. <code>CR4_PSE</code> is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as 0x10,<br>or 00010000 in binary.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">    movl    %cr4, %eax</span><br><span class="line">    orl     $(CR4_PSE), %eax</span><br><span class="line">    movl    %eax, %cr4</span><br></pre></td></tr></table></figure>

<p>We need a page directory before we can set up paging; again, basic version now,<br>full glorious page directory later. We’re gonna do the same thing we did in the<br>boot loader where we tell the processor to load the page directory now but then<br>procrastinate actually writing it; this time, we’ll write it in C and call it<br><code>entrypgdir</code>. Then we’ll load its physical address into register <code>%cr3</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class="line">movl    %eax, %cr3</span><br></pre></td></tr></table></figure>

<p>Now we can enable (a basic version of) paging! We tell the CPU to start using<br>the page directory in <code>%cr3</code> by setting bit 31 (paging) of register <code>%cr0</code>; we<br>can also set bit 16 (write protect) of the same register to prevent writing to<br>any pages that the page directory and page tables have marked as read-only.<br><code>CR0_PG</code> and <code>CR0_WP</code> are defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> to set these bits.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $(CR0_PG|CR0_WP), %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>

<p>Now remember how the processor is still running at low addresses? Yeah, let’s<br>fix that. First we’ll make a new kernel stack in the higher half that will still<br>be valid even after we get rid of the lower address mappings. We’ll have the<br>linker save some space for us under the symbol <code>stack</code> and set it up there;<br><code>KSTACKSIZE</code> is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 4096 bytes. So we just set the stack<br>pointer register <code>%esp</code> to the top of that section in order to let the stack<br>grow down toward the address of <code>stack</code>. Again, we’ll procrastinate actually<br>defining <code>stack</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    $(stack + KSTACKSIZE), %esp</span><br></pre></td></tr></table></figure>

<p>Now we want to call into the <code>main()</code> function, but we don’t just want to do<br>that the usual assembly way of <code>call main</code>. That would generate a jump relative<br>to the current value of <code>%eip</code>, which is still in low addresses. We’ll use an<br>indirect jump instead.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     $main, %eax</span><br><span class="line">jmp     *%eax</span><br></pre></td></tr></table></figure>

<p>Finally, we need to get around to reserving space for the stack. We can do that<br>with the assembler instruction <code>.comm symbol, size</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.comm stack, KSTACKSIZE</span><br></pre></td></tr></table></figure>

<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>Awesome, back to C code now! Remember how we procrastinated actually defining<br><code>entrypgdir</code>? Let’s do that now; it’s at the bottom of <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/main.c">main.c</a>.</p>
<h3 id="entrypgdir"><a href="#entrypgdir" class="headerlink" title="entrypgdir"></a>entrypgdir</h3><p>What in the world is this?!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entrypgdir[NPDENTRIES] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = (<span class="number">0</span>) | PTE_P | PTE_W | PTE_PS,</span><br><span class="line">    [KERNBASE&gt;&gt;PDXSHIFT] = (<span class="number">0</span>) | PTE_P | PTE_W | PTE_PS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Okay, bear with me; I promise it’s not too bad.</p>
<p>First, the <code>__attribute__</code> tells the compiler and linker that the page directory<br>should be placed in memory at an address that’s a multiple of <code>PGSIZE</code> (4096<br>bytes); that’s just a requirement of the paging hardware.</p>
<p>Next, we define <code>entrypgdir</code> as an array of <code>NPDENTRIES</code> (1024, according to<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>), each of type <code>pde_t</code> (a type alias for <code>unsigned int</code>, according to<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>).</p>
<p>Then we initialize the entries: in C, you’re allowed to initialize an array by<br>specifying the values of specific enties; all other enties become zero. You<br>specify an entry by putting its index in square brackets before its value, so<br><code>[2] 5</code> will set the entry with index 2 to be 5. Here we initialize the entries<br>with indices 0 and <code>KERNBASE &gt;&gt; PDXSHIFT</code>, which is the same thing as<br><code>PDX(KERNBASE)</code>, AKA the page directory index corresponding to the virtual<br>address <code>KERNBASE</code>, AKA 0x8000_0000. So basically, we’ve initialized the page<br>directory entries corresponding to the low virtual address 0 and the high<br>virtual address <code>KERNBASE</code>.</p>
<p>We set their value to 0, because we want them to map to physical addresses from<br>0 up to 4 MB. Oh, and remember how page directories and page tables can also<br>hold permission flags? We want to set flags to say that these pages are present<br>(so that accessing them doesn’t cause a page fault), writeable, and 4 MB in<br>size; those are defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as <code>PTE_P</code>, <code>PTE_W</code>, and <code>PTE_PS</code>. We can<br>combine them all together by bitwise-ORing them.</p>
<p>And we’re done!</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>The code in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/entry.S">entry.S</a> finished up by calling into the C function <code>main()</code>, which<br>is where the core set-up happens before we can start running processes. It calls<br>into basically every single part of the xv6 kernel, so we can’t go through all<br>the functions line-by-line yet; instead I’ll just give you an overview of what<br>they do.</p>
<ul>
<li><code>kinit1()</code> solves another bootstrap problem around paging: we need to allocate<br>  pages in order to use the rest of memory, but we can’t allocate those pages<br>  without first freeing the rest of memory, which requires allocating them…<br>  You see what I mean. This function will free the rest of memory between the<br>  <code>end</code> of the kernel code (defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, remember?) and 4 MB.</li>
<li><code>kvmalloc()</code> allocates a page of memory to hold the fancy full-fledged page<br>  directory, sets it up with mappings for the kernel’s instructions and data,<br>  all of physical memory, and I&#x2F;O space, then switches to that page directory<br>  (leaving poor old <code>entrypgdir</code> in the trash).</li>
<li><code>mpinit()</code> detects hardware components like additional CPUs, buses, interrupt<br>  controllers, etc. Then it determines whether this machine supports this<br>  crazy new idea where you can have multiple CPU cores. Wow, 1995 is crazy.</li>
<li><code>lapicinit()</code> programs this CPU’s local interrupt controller so that it’ll<br>  deliver timer interrupts, exceptions, etc. when we’re ready for them later.</li>
<li><code>seginit()</code> sets up this CPU’s kernel segment descriptors in its GDT; we still<br>  won’t really use segmentation, but we’ll at least use the permission bits.</li>
<li><code>picinit()</code> disables the <em>ancient</em> PIC interrupt controller that literally no<br>  one has ever used since the APIC was introduced in 1989. I don’t even know<br>  what to say. I guess I was mistaken when I assumed it was 1995; I don’t<br>  know.</li>
<li><code>ioapicinit()</code> programs the I&#x2F;O interrupt controller to forward interrupts<br>  from the disk, keyboard, serial port, etc., when we’re ready for them later.<br>  Each device will have to be set up to send its interrupts to the I&#x2F;O APIC.</li>
<li><code>consoleinit()</code> initializes the console (display screen) by adding it to a<br>  table that maps device numbers to device functions, with entries for reading<br>  and writing to the console. It also sets up the keyboard to send interrupts<br>  to the I&#x2F;O APIC.</li>
<li><code>uartinit()</code> initializes the serial port to send an interrupt if we ever<br>  receive any data over it. xv6 uses the serial port to communicate with<br>  emulators like QEMU and Bochs.</li>
<li><code>pinit()</code> initializes an empty process table so that we can start allocating<br>  slots in it to processes as we spin them up.</li>
<li><code>tvinit()</code> sets up and interrupt descriptor table (IDT) so that the CPU can<br>  find interrupt handler functions to deal with exceptions and interrupts when<br>  they come.</li>
<li><code>binit()</code> initializes the buffer cache, a linked list of buffers holding<br>  cached copies of disk data for more efficient reading and writing.</li>
<li><code>fileinit()</code> sets up the file table, a global array of all the open files in<br>  the system. There are other parts of the file system that need to be<br>  initialized like the logging layer and inode layer, but those might require<br>  sleeping, which we can only do from user mode, so we’ll do that in the first<br>  user process we set up.</li>
<li><code>ideinit()</code> initializes the disk controller, checks whether the file system<br>  disk is present (because both the kernel and boot loader are on the boot<br>  disk, which is separate from the disk with user programs), and sets up disk<br>  interrupts.</li>
<li><code>startothers()</code> loads the entry code for all other CPUs (in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/entryothers.S">entryothers.S</a>)<br>  into memory, then runs the whole setup process again for each new CPU.</li>
<li><code>kinit2()</code> finishes initializing the page allocator by freeing memory between<br>  4 MB and <code>PHYSTOP</code>.</li>
<li><code>userinit()</code> creates the first user process, which will run the initialization<br>  steps that have to be done in user space before spinning up a shell.</li>
<li><code>mpmain()</code> loads the interrupt descriptor table into the CPU so that we’re<br>  finally completely ready to receive interrupts, then calls the <code>scheduler()</code><br>  function in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a>, which enables interrupts on this CPU and starts<br>  scheduling processes to run. <code>scheduler()</code> never returns, so at that point<br>  we’re completely done with setup and we’re running the OS proper.</li>
</ul>
<h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>The entry code in the xv6 kernel had one job: to set up paging. It kind of<br>failed at that job, but not for lack of trying! There are just all kinds of<br>Catch-22s when it comes to paging, so at least it got us partway there by making<br>a temporary page directory to tide us over until we can throw it away and never<br>look back.</p>
<p>We also took a sneak peek at all the setup code in <code>main()</code>; we’re gonna end up<br>going through it all, but at least now you should have enough of an idea of<br>what’s going on that you can more or less skip around and look at what you need.</p>
<h1 id="Detour-Spin-Locks"><a href="#Detour-Spin-Locks" class="headerlink" title="Detour: Spin-Locks"></a>Detour: Spin-Locks</h1><p>So I know I said I wasn’t expecting you to have finished the OSTEP section on<br>concurrency, but xv6 uses locks all over the place, so we’re gonna have to get<br>comfortable with them right away. Luckily, xv6 primarily uses spin-locks, which<br>are super simple and work on bare metal; a lot of the more complex&#x2F;more awesome<br>locks that OSTEP talks about require an OS beneath them.</p>
<p>I’ll give a brief intro to concurrency first in case you haven’t made it to that<br>part in OSTEP; then we’ll turn to the spin-lock implementation in xv6.</p>
<h2 id="A-Very-Brief-Poor-Man’s-Intro-to-Concurrency"><a href="#A-Very-Brief-Poor-Man’s-Intro-to-Concurrency" class="headerlink" title="A Very Brief, Poor-Man’s Intro to Concurrency"></a>A Very Brief, Poor-Man’s Intro to Concurrency</h2><p>TL;DR: Concurrency is your worst nightmare. It’ll cause bugs in the places where<br>you least expect it, and they won’t even be consistent: your code might work 95%<br>of the time, but every once in a while it’ll randomly fail and you’ll have no<br>idea why. The good news: xv6 handles it in a super-simple way, so we’ll get to<br>appreciate it as we go along. If you’re like me, you might also see the code use<br>locks when you wouldn’t have thought they were needed, and then you’ll come to<br>appreciate just how clever the xv6 authors are.</p>
<p>First off, stop reading this and go watch the discussion of data races and locks<br>in <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=LzElj46saa8&t=8762s">the last few minutes of the CS 50 2021 lecture on SQL</a>.<br>I’m serious, go watch it right now; this post will still be here.</p>
<p>Okay, I’m gonna assume you’ve seen it now; you should have a decent sense of the<br>main issues with data races and how locks solve them. But the CS 50 lecture<br>skipped some details about locks: (1) what Brian (the TA) does when he finds a<br>locked fridge, (2) how locks are implemented in code, and (3) deadlocks.</p>
<h3 id="What-Does-Brian-Do"><a href="#What-Does-Brian-Do" class="headerlink" title="What Does Brian Do?"></a>What Does Brian Do?</h3><p>Let’s say process <code>david</code> is running on one thread, and it needs to use some<br>resource (a global variable maybe, or an I&#x2F;O device like the disk or console)<br>that other threads might want to use too, so <code>david</code> acquires the lock for that<br>resource. Then process <code>brian</code> comes along and wants to use the same resource at<br>the same time. This could cause a data race, but luckily we’ve thought ahead and<br>used a lock, so <code>brian</code> can’t access it until <code>david</code> is done with it and<br>releases the lock.</p>
<p>First of all, we better hope <code>david</code> remembers to release the lock; otherwise<br><code>brian</code> (and all other processes, even the kernel) will <em>never</em> be able to use<br>that resource. But assuming we’re smart and remembered to release it, what does<br>the <code>brian</code> process do in the meantime?</p>
<p>Well, maybe <code>brian</code> has some other work to do that he can get started on in the<br>meantime. But what would that mean for an OS? How would we know, in general,<br>whether the lines of code that follow the use of a shared resource can be safely<br>executed if we haven’t used that resource yet? That sounds impossible to figure<br>out without knowing ahead of time what the resource is and how it’s used, so<br>let’s just go ahead and skip that idea.</p>
<p>Another option that’s actually used often in the real world is for <code>brian</code> to<br>stop trying and go to sleep. Maybe he can put a note on himself asking <code>david</code><br>to wake him up when he gets back with the milk. So in code, that might look like<br><code>brian</code> signaling the OS and letting it run a different process until the lock<br>is released. That sounds nice and all, but at this early stage in our kernel, we<br>don’t even have processes or a scheduler yet, let alone a notion of sleeping.</p>
<p>Okay, another option: what if <code>brian</code> just spins around in circles, or twiddles<br>his thumbs, or does jumping jacks or whatever until <code>david</code> releases the lock?<br>In code, that means looping over and over forever until the lock is released.<br>That would be horribly inefficient; think of all the CPU time wasted when one<br>process just loops over and over again while another process does something slow<br>while holding a lock! But it’s also the approach that xv6 is gonna take, because<br>at the end of the day, our kernel is still in baby stages and beggars can’t be<br>choosers. So xv6 uses <em>spin-locks</em> with loops that only stop when we acquire a<br>lock.</p>
<p>This means we should be careful when using locks to acquire them only at the<br>last possible moment when they’re absolutely needed, and release them as soon as<br>they’re no longer required, in order to limit the amount of wasted CPU cycles.</p>
<h3 id="Implementing-Locks"><a href="#Implementing-Locks" class="headerlink" title="Implementing Locks"></a>Implementing Locks</h3><p>We can implement locks as a simple boolean variable: if it’s true, then someone<br>else is using the resource behind the lock. If it’s false, then it’s unused and<br>you can go ahead and take it. So an <code>acquire()</code> function sets the lock to <code>true</code><br>and a <code>release()</code> function sets it back to <code>false</code>. Done!</p>
<p>But it’s not so simple: there’s actually a race condition hidden in the very<br>idea of a lock. Think about it for a second: a lock protects some shared<br>resource, right? And a shared resource is something that more than one process<br>wants to use? But a lock is itself a thing that more than one process wants to<br>use… so we haven’t actually gotten rid of the race condition. (FLIPS TABLE.)</p>
<p>We have another Catch-22 on our hands, but this time we can’t get rid of it with<br>a clever software trick like we did with the <code>entrypgdir</code>. The issue is that no<br>matter how well we write our code, it will always require more than one step:<br>first we have to check whether the lock is <code>true</code>, then we have to set it to<br><code>true</code>. But if someone else is doing the same thing at the same time, our<br>instructions might get executed in parallel and then we’d both acquire the lock<br>at the same time -&gt; RACE CONDITION.</p>
<p>The solution will require hardware support, using <em>atomic</em> instructions – these<br>are hardware instructions that are indivisible; no other code can execute in<br>between ours. One example is the x86 instruction <code>xchg</code>, which atomically reads<br>a value from memory, updates it to a new value, and returns the old value.</p>
<p>Now we’re good! A lock can still be a boolean variable but now <code>acquire</code> has to<br>use <code>xchg</code>: it should get the old value while simultaneously updating it to<br><code>true</code>.</p>
<p>Atomic instructions have more overhead than regular ones, so we should only use<br>them when they’re required, like in locks, but otherwise we can stick to the<br>regular instructions we’ve always used.</p>
<p>There’s one other detail we should be careful about: a lot of the locks in xv6<br>protect resources that are needed by both interrupt handlers and kernel or user<br>code. For example, we might use a process table lock to protect the list of all<br>currently running processes; suppose some kernel code has acquired the lock in<br>order to run a new process. What happens if a timer interrupt goes off at that<br>moment? The timer interrupt handler function might need to acquire the lock in<br>order to switch processes, but it’s already being held by the kernel thread. But<br>the timer interrupt might take priority over the kernel thread and refuse to<br>return to the kernel until it finishes executing. The result: that CPU comes to<br>a total halt as the timer interrupt handler function spins forever, never to get<br>the lock it so desperately needs to move on. So sad. :(</p>
<p>xv6 avoids this issue in a really simple way: every time we acquire a lock,<br>we’ll just disable interrupts altogether. Problem solved: now a thread can’t get<br>interrupted until it’s done using the lock and releases it. This does mean that<br>a process which grabs locks often might stick around longer than it should,<br>since we won’t have timer interrupts to tell the scheduler to swap it out with<br>another process, but we’re just gonna cross our fingers and hope that doesn’t<br>happen too often.</p>
<h3 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h3><p>The last concurrency issue we need to be aware of is the problem of deadlocks.<br>Suppose two threads each need locks A and B; this happens often, e.g. when<br>loading a user program the kernel will need to hold a lock for the disk and<br>another for the process table, or a process might be reading from disk and<br>printing to the console at the same time.</p>
<p>Suppose they’re running at the same time, and one process acquires lock A while<br>the other one acquires lock B. If they each need the other lock to keep going,<br>they’d spin forever waiting for it. This is a deadlock.</p>
<p>The way to avoid these is to make sure that, if we use more than one lock, we<br><em>always</em> acquire them in the same order. That way, one process would acquire<br>lock A, the second one would be unable to acquire it and would spin, then the<br>first process acquires lock B with no issues. When it’s done, it releases both<br>locks and the second process can continue.</p>
<p>This can get complicated though: if we ever acquire a lock in a function, we’d<br>have to check any functions that that function calls to see whether they use any<br>locks, and so on. If they do, and if the order conflicts with another chain of<br>function calls, we’d have to refactor the code until the orders match. xv6 has<br>been carefully written so that the lock acquisition order is always consistent.</p>
<h2 id="spinlock-c"><a href="#spinlock-c" class="headerlink" title="spinlock.c"></a>spinlock.c</h2><p>xv6’s spin-locks are set up as a <code>struct spinlock</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/spinlock.h">spinlock.h</a>. The<br><code>locked</code> field acts as the boolean variable to determine whether the lock is<br>held; the other fields are for debugging, since we can expect concurrency issues<br>to be the one of the most common causes of bugs in the kernel code because,<br>again, concurrency is your worst nightmare.</p>
<p>Note that <code>locked</code> is an <code>unsigned int</code> instead of a <code>bool</code>; C requires the<br>standard library header <em>stdbool.h</em> in order to use the <code>bool</code> type, but on<br>bare metal we can’t assume we have a standard library to use.</p>
<h3 id="initlock"><a href="#initlock" class="headerlink" title="initlock"></a>initlock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function is pretty straightforward; it just stores the string <code>name</code> in<br>the lock and starts it off as unlocked; the <code>cpu</code> field is 0 because no CPU is<br>holding it yet. Next.</p>
<h3 id="pushcli-and-popcli"><a href="#pushcli-and-popcli" class="headerlink" title="pushcli and popcli"></a>pushcli and popcli</h3><p>For reasons mentioned above, we need to disable interrupts whenever we’re using<br>a lock and re-enable them when we release a lock. But if we’re not careful, we<br>could end up enabling interrupts too early when we release one lock while still<br>holding another; or if interrupts were already disabled when we acquired a lock,<br>we could unintentionally re-enable them upon releasing it.</p>
<p>xv6 uses paired functions <code>pushcli()</code> and <code>popcli()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushcli</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> eflags = readeflags();</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli == <span class="number">0</span>) &#123;</span><br><span class="line">        mycpu()-&gt;intena = eflags &amp; FL_IF;</span><br><span class="line">    &#125;</span><br><span class="line">    mycpu()-&gt;ncli += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readeflags()</code> is a C wrapper for some x86 assembly code that reads from the<br><code>eflags</code> register; the 9th bit is the interrupt flag, which is set whenever<br>interrupts are enabled. <code>cli</code> is another x86 instruction that clears that flag,<br>thus disabling interrupts.</p>
<p><code>mycpu()</code> returns a pointer to a <code>struct cpu</code> with information about the CPU<br>running this code; we’ll go over these when we talk about processes; here we<br>increment the <code>ncli</code> field in every call to <code>pushcli()</code>. If this is the first<br>call, we save the value of the interrupt flag in the <code>intena</code> field.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">popcli</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;popcli - interruptible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--mycpu()-&gt;ncli &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;popcli&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli == <span class="number">0</span> &amp;&amp; mycpu()-&gt;intena) &#123;</span><br><span class="line">        sti();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>popcli()</code> first checks to make sure interrupts aren’t already enabled and we’re<br>not popping without having pushed. Then it decrements the <code>ncli</code> field of the<br><code>struct cpu</code> for this CPU. If this is the last call to <code>popcli()</code>, it checks the<br><code>intena</code> field; if it was set (i.e., interrupts were enabled before the first<br><code>popcli()</code>), then it enables interrupts again.</p>
<p>Check out how these two functions are carefully written so that they’re matched:<br>it takes two calls to <code>popcli()</code> to undo two calls to <code>pushcli()</code>. Also, if<br>interrupts were already off before the first call to <code>pushcli()</code>, they’ll stay<br>off after the last <code>popcli()</code>. Pretty neat, right?</p>
<h3 id="holding"><a href="#holding" class="headerlink" title="holding"></a>holding</h3><p>This function checks whether this CPU is holding the lock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line">    <span class="type">int</span> r = lock-&gt;locked &amp;&amp; lock-&gt;cpu == mycpu();</span><br><span class="line">    popcli();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not much to talk about here; it just checks (inside calls to <code>pushcli()</code> and<br><code>popcli()</code>) whether the lock is being held and this is the CPU holding it. If<br>both conditions are true it’ll return 1; otherwise 0.</p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>The first step in this function is to disable interrupts to avoid deadlocks. We<br>also make sure we’re not already holding the lock; otherwise we’d deadlock<br>ourselves.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holding(lk)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next up, we’ve gotta acquire the lock using the atomic <code>xchg</code> instruction,<br>defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>.<br>Like we said before, the trick is to atomically set <code>locked</code><br>to 1 while returning the old value. If the returned old value is 1, that<br>means it was already 1 before we got to it, so it’s currently being held and we<br>can’t acquire it yet – gotta spin. But if the returned old value is 0, that<br>means the lock was free before we got to it, and our <code>xchg</code> just updated it to<br>1, so we’ve successfully acquired it. No other instruction can occur between<br>checking the old value and updating it to the new one, so we can be confident<br>that no one else will be holding the lock at the same time.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We do have to be careful about one other thing: compiler optimizations can get<br>pretty wild nowadays, so the order of code on the page isn’t necessarily the<br>order it’ll get compiled to or executed in. This is a critical section of code,<br>so we need to make sure acquiring the lock forms a barrier between the code that<br>comes before it and the code after it so any reordering doesn’t cross the lock<br>acquisition point. We can do that with a special compiler instruction:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll record some info about the CPU and process holding the lock for<br>debugging purposes. Don’t worry about <code>mycpu()</code> for now, but we’ll talk about<br><code>getcallerpcs()</code> below.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lk-&gt;cpu = mycpu();</span><br><span class="line">    getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>Releasing a lock is a little easier than acquiring it: to acquire it, we need to<br>check whether it’s already held and update its value, with both steps together<br>as an atomic instruction. To release it, we only have to set the value to false.<br>That’s only one instruction, so it’s automatically atomic!</p>
<p>Well, almost, but not quite. The compiler works some serious magic behind the<br>scenes, so there’s no guarantee that a single C operation like <code>lk-&gt;locked = 0</code><br>will actually get compiled down to a single assembly instruction. So we’re gonna<br>have to make sure it does by writing it directly in assembly.</p>
<p>We start off by making sure we are already holding the lock before releasing a<br>lock held by someone else. Then we clear the debug info stored in the lock, and<br>tell the compiler and processor not to reorder code past the lock release.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holding(lk)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to release the lock, i.e. an assembly instruction equivalent to<br><code>lk-&gt;locked = 0</code> in C. C allows in-line assembly code using the <code>asm</code> keyword.<br>We mark it as <code>volatile</code>, which prevents the compiler from optimizing the write<br>away and ensures it’ll get written to memory. Finally, we call <code>popcli()</code> to<br>enable interrupts again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl $0, %0&quot;</span> : <span class="string">&quot;+m&quot;</span> (lk-&gt;locked) : )</span>;</span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getcallerpcs"><a href="#getcallerpcs" class="headerlink" title="getcallerpcs"></a>getcallerpcs</h3><p>This function exists to store information about the current process in the lock<br>for use in debugging. In particular, we want to record the program counters of<br>the last 10 functions on the call stack so we can try to figure out which<br>functions were called in which order when concurrency issues inevitably bring<br>our world crashing down with data races, or to a grinding halt with deadlocks.</p>
<p>In order to get the program counters, we’re gonna have to know a bit about how<br>x86 handles function calls. The <code>%eip</code> register (or instruction pointer) holds<br>the program counter, which tracks the next instruction to be executed. The<br><code>%ebp</code> register (or base pointer) holds the address of the base of the stack<br>(i.e., its highest address, since it grows down).</p>
<p>When a function gets called all its arguments are pushed on the stack in reverse<br>order, so that the first argument is at the top (lowest address) of the stack.<br>Then the previous function’s <code>%eip</code> is pushed on the stack, followed by its<br><code>%ebp</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;- low addresses                                               high addresses -&gt;</span><br><span class="line">...  [new function&#x27;s data]  [old %ebp]  [old %eip]  [new arg1]  [new arg2]  ...</span><br><span class="line">&lt;- top of stack                                               bottom of stack -&gt;</span><br></pre></td></tr></table></figure>

<p>Anyway, the point is that if we have the address of the first argument to the<br>current function, then we can recover the contents of the previous function’s<br><code>%ebp</code> and <code>%eip</code> registers: <code>%eip</code> is one spot below it on the stack and <code>%ebp</code><br>is two spots below it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    uint *ebp = (uint *) v - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note the type casts here – <code>v</code> is a pointer to the first argument, which can be<br>of any type and size, so we use a <code>void *</code>. But both of the <code>%eip</code> and <code>%ebp</code><br>registers hold 32-bit pointers, so <code>ebp</code> is declared as a pointer to a <code>uint</code><br>(a type alias for <code>unsigned int</code>, remember?), which makes the pointer arithmetic<br>work out nicely so that subtracting 2 returns a pointer to the right spot on the<br>stack.</p>
<p>Now, what we really want is the program counter <code>%eip</code>, not the pointer to the<br>stack base <code>%ebp</code>. But we can use the address of <code>%ebp</code> to make sure we haven’t<br>gone too far back in the function call history. Remember, we wanna get the<br>program counters for the last 10 functions in the call stack, then save them in<br>the <code>pcs</code> array.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// Stop if the %ebp pointer is null or out of range</span></span><br><span class="line">        <span class="keyword">if</span> (ebp == <span class="number">0</span> || ebp &lt; (uint *) KERNBASE || ebp == (uint *) <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pcs[i] = ebp[<span class="number">1</span>];</span><br><span class="line">        ebp = (uint *) ebp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s talk about those last two lines: the <code>ebp</code> pointer in the code holds the<br>location of the saved <code>%ebp</code> register, so <code>ebp[0]</code> is the value at that address<br>(i.e., the actual value of the saved <code>%ebp</code> register) and <code>ebp[1]</code> is the value<br>stored one spot above that, i.e. the value of the saved <code>%eip</code> register. So<br>each iteration of the loop will get one <code>%eip</code> and store it in a <code>pcs</code> entry.</p>
<p>Then we update <code>ebp</code> to the actual value at the address it points to, which<br>means <code>ebp</code> will now point to the address of the saved <code>%ebp</code> register for the<br>function one step further back in the call chain. Okay sorry, I know that’s<br>confusing, but basically each iteration of the for loop moves us back to the<br>function that called this function, then the function that called that one, and<br>so on.</p>
<p>Okay, whew. So what happens if we break out of the for loop early because we<br>went all the way back in the call stack? The other entries of <code>pcs</code> might hold<br>some garbage values, so let’s just make them null pointers so we know to ignore<br>them when debugging.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        pcs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One last little trick: the previous for loop declared the loop variable <code>i</code><br>before the loop – this means <code>i</code> will be in scope for the rest of the function<br>body. If it had been declare inside the for loop like <code>for (int i = 0; ...)</code>, it<br>would fall out of scope at the end of the loop. So we can keep using the same<br><code>i</code> in this second for loop (without an initialization statement) and know it’ll<br>hold the value it had after finishing the first for loop. If we finished all the<br>iterations, that value will be 10; otherwise it’ll be less. So we use that to<br>clear any remaining entries of <code>pcs</code>.</p>
<h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>You’ll learn to hate concurrency issues in C; newer languages like Rust make<br>data races a thing of the past, though deadlocks can still rear their ugly<br>heads. But for now, the xv6 authors have done all the dirty work for us, so we<br>can just sit back and watch. Note, though, that even the xv6 authors say it’s<br>totally possible that something has slipped past them and the thousands of other<br>students and instructors that have looked at xv6, so it’s probable that xv6<br>still has some lingering race conditions. See, even the masters struggle with<br>it. -_-</p>
<p>Anyway, we saw that locks have to be implemented with hardware support using<br>atomic instructions. C and most languages provide high-level atomics that real-<br>world operating systems use, but the point of xv6 is elegance in simplicity, not<br>being a total show-off, so the xv6 spin-locks just use the basic <code>xchg</code>.</p>
<p>We took this detour into spin-locks to make sure we all understand some basic<br>details because we’re gonna be seeing a lot of them in the rest of the kernel<br>code. They’re inefficient (because the processor just spins around waiting for<br>the lock to be released, WHEEEEE), but we gotta make do with the machinery we’ve<br>built up so far. xv6 will also use some fancier locks called sleep-locks, but<br>we’ll cross that bridge when we get to it.</p>
<h1 id="Page-Allocation"><a href="#Page-Allocation" class="headerlink" title="Page Allocation"></a>Page Allocation</h1><p>When we left off before the lock detour, the boot loader had set up a GDT to<br>ignore segmentation, and the entry code set up some barebones paging with an<br><code>entrypgdir</code>. But that initial page directory is too limiting to keep for long;<br>it only mapped the first 4 MB of physical memory. So we want a new one, but we<br>have to set it up and allocate pages in it before we can actually use it. And<br>until we switch to it, everything has to happen in those first 4 MB.</p>
<h2 id="kalloc-c"><a href="#kalloc-c" class="headerlink" title="kalloc.c"></a>kalloc.c</h2><p>We start off in this file by declaring the function <code>freerange()</code>, which will be<br>defined below. We have to do this in C in order to call a function in the code<br>before the compiler has actually seen the function’s definition, which comes<br>below, or maybe in another file. A <em>declaration</em> tells the C compiler “I know I<br>haven’t shown you this symbol before, but don’t worry; it’s just a function that<br>takes this number of arguments with these types and has a return value of this<br>type.” That lets the compiler keep calm and carry on with its usual type-checks<br>(weak as they may be in C). A <em>definition</em> tells the compiler that this is the<br>function (or variable) we were talking about, so it’ll reserve some space in<br>memory for it; it also tells the compiler how to evaluate that function whenever<br>it’s called (for variables, an <em>initialization</em> will have to tell the compiler<br>what the value the variable should hold). The linker will take care of matching<br>function calls (and variable uses) to their definitions, possibly across files.</p>
<p>Usually you’d stick declarations in a C header file and tell the preprocessor to<br>copy-paste the header into your code with an <code>#include</code> directive; then other<br>files could <code>#include</code> that header too. So header files should really be more of<br>an API kind of thing, for functions that you want other code to be able to call.<br>This one is just a local helper function, so we’ll declare it here instead of in<br>a header so other code can’t use it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span>;</span><br></pre></td></tr></table></figure>

<p>Okay okay, I know function declarations are like 101-level C, but I wanted to<br>mention them because we’re about to see something similar but a little off next<br>when we declare <code>end</code> as a global array of characters.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[];</span><br></pre></td></tr></table></figure>
<p>The C keyword <code>extern</code> lets you define a global variable or function in one file<br>and use it in another, so in that sense it’s similar to the function declaration<br>above. In fact, the compiler implicitly assumes there’s an <code>extern</code> before each<br>function declaration. The difference is that an explicit <code>extern</code> lets us do the<br>same thing for global variables: we tell the compiler and linker “hey, I’m gonna<br>use a variable of this type with symbol <code>end</code>, but don’t worry about reserving a<br>spot in memory for it; that already happened elsewhere.”</p>
<p>The really cool thing about <code>extern</code> is that the function or variable might not<br>even be defined in C – it could come from any other language! We just pass the<br>compiled object files from the other language together with the C object files<br>to the linker and it’ll match up the definitions and calls.</p>
<p>In this case if you try looking for the place where <code>end</code> is defined in the C or<br>assembly code, you’re gonna be disappointed. Turns out it’s actually defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, remember? Back then, we said it was gonna be located at the very<br>first memory address right after the end of the kernel code and data in memory.<br>We’re about to see why it’s needed.</p>
<p>Next up, we define a new <code>struct</code> type:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Hmm, the only member of this <code>struct run</code> is a pointer to another <code>struct run</code>.<br>Hopefully, you’ve seen some singly-linked lists before so you can recognize it<br>as one of those. Usually it would have another member to hold the data in the<br>list, but we won’t need any extra data here; we’ll find out why soon enough.</p>
<p>Last thing before we get to the functions: we define another <code>struct</code> type and<br>declare the global variable <code>kmem</code> to be of that type.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> use_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<p>The syntax here is the usual C thing where we say the type of a variable, then<br>an identifier, like <code>int i</code>; it just looks more confusing because we’re also<br>defining the type at the same time. This <code>struct</code> type doesn’t get a name like<br><code>struct run</code> did because we’re only gonna need it this one time. The fields are<br>a spin-lock (hence the detour before coming here), a <code>use_lock</code> variable that<br>we’ll treat as a boolean, and a pointer to a <code>struct run</code> called <code>freelist</code>.</p>
<p>I’m just gonna go ahead and spoil the next two functions for you: we want to use<br>a better page directory than <code>entrypgdir</code>, right? Well then we need to assign<br>a page of memory for it, plus a page for each of its page tables, plus a page<br>for each entry in those page tables that’s mapped. That means we’ll need some<br>bookkeeping to track which pages have already been assigned. We’re gonna use a<br>linked list of free pages (that’s what <code>struct run</code> is for); we’ll allocate a<br>page by popping one off the free list, and we’ll free a page by pushing it onto<br>the top of the list.</p>
<p>Note that <code>kfree()</code> here is <em>not</em> supposed to be a kernel version of the usual C<br>standard library function <code>free()</code>, nor is <code>kalloc()</code> supposed to be a kernel<br>version of <code>malloc()</code>. We have no concept of a heap yet, so heap allocation<br>wouldn’t make sense. These functions allocate and free <em>whole physical pages</em> to<br>be added to the current page directory and its page tables.</p>
<h3 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h3><p>This function will free a single page (4096 bytes, or <code>PGSIZE</code>) of memory by<br>adding it to the front of the free list. It takes an argument <code>char *v</code> which is<br>a virtual address; we’re using <code>char *</code> here instead of <code>uint *</code> or <code>void *</code> or<br>whatever so that the pointer arithmetic increments by a single byte instead of<br>4 bytes for <code>uint</code> or whatever.</p>
<p>First, some sanity checks: <code>v</code> should be page-aligned (because we’re freeing a<br>whole page), it should be above <code>end</code> (because we don’t want to accidentally<br>overwrite the kernel code), and its corresponding physical address should be<br>below <code>PHYSTOP</code> (because the only addresses we’ll use above the top of physical<br>memory are for memory-mapped I&#x2F;O devices and we shouldn’t be freeing those pages<br>anyway).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((uint) v % PGSIZE || v &lt; end || V2P(v) &gt;= PHYSTOP) &#123;</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if you’ve programmed in C, you might have come across the dreaded (but oh-<br>so-common) bug known as a <em>use-after-free</em>. This means you called <code>free()</code> on<br>some variable (hopefully one you had <code>malloc()</code>-ed before), and then used it<br>again. Hmm, very naughty! The problem is that that memory might have been re-<br>allocated to some other variable or even another process, so you might read the<br>wrong values or overwrite something important. This is a <em>very</em> common cause of<br>security vulnerabilities in C and C++ to this day; it’s also not always easy to<br>spot because huge projects might have you call <code>malloc()</code> in one file, then use<br>the variable somewhere else thousands of lines of code later in some other file,<br>then call <code>free()</code> in yet another file – plus it’s unlikely that all of these<br>pieces were written by the same person. So let’s make this a little easier on<br>ourselves by filling the freed page with junk (a bunch of 1s everywhere) in the<br>hope that a use-after-free leads to a crash (and thus debugging and detection)<br>sooner than it would otherwise.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">1</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might be familiar with <code>memset()</code> from the C standard library in <em>string.h</em>,<br>but we can’t risk using standard library functions here because they assume the<br>code will be provided by the OS, and the implementation might require any of a<br>million features we haven’t implemented yet. So we have to make our own version<br>for the kernel in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>. We’ll get around to looking at that code later on<br>in an optional detour, but for now just know that it sets the memory starting at<br><code>v</code> and continuing for <code>PGSIZE</code> bytes to hold a bunch of repeated 1s.</p>
<p>Now let’s talk concurrency. At any time, multiple threads might want to allocate<br>or free pages simultaneously; if we’re not careful we might accidentally use the<br>same page twice, which would cause bugs in addition to security vulnerabilities,<br>because all the per-process isolation that paging gets us would be lost. So much<br>work down the drain! This is why <code>kmem</code> has a lock, which we should use any time<br>we push to or pop from the free list.</p>
<p>But in the early stages of the kernel we only use a single CPU and interrupts<br>are disabled, so there’s nothing to fear. Plus, locks add overhead, and the<br><code>acquire()</code> function needs to call <code>mycpu()</code>, which we haven’t even defined yet,<br>so let’s just go ahead and skip them in the beginning. So <code>kmem.use_lock</code> is a<br>boolean that will tell us whether we need a lock right now or not.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        acquire(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, we’re finally at the point where we can free the page. We’ll make a<br><code>struct run *r</code> that points to virtual address <code>v</code>, then make its <code>next</code> point<br>to the first entry of the free list. Then we’ll update the head of the list to<br>point at the newly-freed page. This is the standard C idiom to add to the front<br>of a singly-linked list.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> (<span class="keyword">struct</span> run *) v;</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s something interesting here: where are we storing this entry for the free<br>list? Why, in the free page itself! So each unused page will hold the address of<br>the next one in its first few bytes.</p>
<p>Finally, we’re out of the critical section where we updated the free list, so we<br>can release the lock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h3><p>Allocating a page means popping off the head of the free list. We acquire the<br>lock first, if we need one.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        acquire(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we get a pointer to the first free page in the list and update the head to<br>point to the next one in the list. But what if the list is empty? In that case,<br>the head would be a null pointer, and dereferencing a null pointer (like we do<br>here in <code>r-&gt;next</code>) is undefined behavior in C, which means BAD THINGS HAPPEN.<br>I’m serious – there are absolutely no restrictions on what might happen, so the<br>compiler could literally set your computer on fire if it wanted to. In the real<br>world, that usually means either a segmentation fault or security vulnerability,<br>or both if you’re unlucky. So we should check whether <code>r</code> is null (i.e. zero).<br>if it’s nonzero then we can update <code>r-&gt;next</code>; otherwise we should just return<br><code>r</code> and hope whoever called us checks whether it’s null. Moral of the story:<br>any call to <code>kalloc()</code>, just like any call to <code>malloc()</code> in regular C code,<br>should always be followed by checking whether the returned pointer is null.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        kmem.freelist = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now we just release the lock, and we’re done!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freerange"><a href="#freerange" class="headerlink" title="freerange"></a>freerange</h3><p><code>kalloc()</code> and <code>kfree()</code> both handle only one page at a time, which can get<br>annoying if we’re trying to free tons of pages at once; also, they can only use<br>page-aligned virtual addresses, which have to be typecast to <code>char *</code>. Let’s<br>simplify our lives with a simple wrapper function to free multiple pages between<br>two virtual memory addresses <code>vstart</code> and <code>vend</code> that may not be page-aligned.</p>
<p>Let’s assume that <code>vstart</code> is the first address after some other data in an<br>already-allocated page; we don’t want to free that page, but the next one, so we<br>align it to a page boundary by rounding up, then cast that to a <code>char *</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *) PGROUNDUP((uint) vstart);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can iterate over the pages, starting at <code>p</code> and incrementing by <code>PGSIZE</code><br>until we reach or pass <code>vend</code>, freeing pages as we go.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; p + PGSIZE &lt;= (<span class="type">char</span> *) vend; p += PGSIZE) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Done, next.</p>
<h3 id="kinit1-and-kinit2"><a href="#kinit1-and-kinit2" class="headerlink" title="kinit1 and kinit2"></a>kinit1 and kinit2</h3><p>Both of these functions get called by the kernel’s <code>main()</code>. Quick reminder:<br>we’ve got an <code>entrypgdir</code> that maps two virtual address ranges (0 to 4 MB and<br><code>KERNBASE</code> to <code>KERNBASE</code> + 4 MB) to the physical addresses range from 0 to 4 MB.<br>We want to leave this baby page directory behind for a grown-up page directory<br>that maps all of physical memory, but first we needed to figure out how to<br>allocate pages.</p>
<p>Okay cool, we already did that. But allocation needs a free list, which for now<br>is just sitting around chilling as an empty list. But we can’t free pages if<br>they’re not already allocated, right? Ahh, bootstrap problems! This one’s not an<br>issue; we’ll just cheat this one time and free all the memory between <code>end</code> (the<br>end of the kernel code and data in memory) and <code>PHYSTOP</code>, even though we didn’t<br>get it from a call to <code>kalloc()</code>. Sounds good, right?</p>
<p>I hate to burst your bubble, but kernel development <em>loves</em> bursting bubbles.<br>Turns out there’s yet another bootstrap problem: each page has to store the<br>pointer to the next free page, which means we have to write to that page, which<br>means that page must already be mapped… but we can’t map all of memory until<br>we initialize the free list by freeing all of memory…</p>
<p>HEAD. DESK. We’re screwed.</p>
<p>Okay, obviously the xv6 authors figured this out already. The trick is that we<br>do have <em>some</em> physical memory we can write to: everything between <code>end</code> and 4<br>MB. So we can free that part for now, allocate some of those pages for a fresh<br>page directory and some pages, then use those pages to map the rest of physical<br>memory, then come back later and free those pages.</p>
<p>So we’ll have to split up the work of setting up the new page directory into two<br>very similar functions, <code>kinit1()</code> and <code>kinit2()</code>. The first one will initialize<br>the lock for the free list but make <code>kmem.use_lock</code> false so we don’t use a lock<br>in the early stages of kernel setup. The second one will set it to true so we<br>start using a lock to allocate and free pages once we have multiple CPUs, a<br>scheduler, interrupts, etc.</p>
<p>Both of them will use <code>freerange()</code> to free the pages in a section of physical<br>memory. <code>main()</code> calls <code>kinit1()</code> with arguments to free the range from <code>end</code> to<br>4 MB, and calls <code>kinit2()</code> with arguments for the range from 4 MB to <code>PHYSTOP</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit1</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    kmem.use_lock = <span class="number">0</span>;</span><br><span class="line">    freerange(vstart, vend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kinit2</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    freerange(vstart, vend);</span><br><span class="line">    kmem.use_lock = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>This whole file was just to set up page allocation for the new page directory<br>we’re gonna replace <code>entrypgdir</code> with. It uses a free list in <code>kmem</code>; freeing a<br>page adds it to the front of the list and allocation pops a page off the front.<br>We have to populate the free list will pages for all of physical memory, but we<br>do that in two steps to avoid some bootstrap issues.</p>
<p>Again, this is a <em>page</em> allocator, not a <em>heap</em> allocator like <code>malloc()</code>, but<br>many heap allocator implementations use linked lists of free heap regions in the<br>same way. We talked about use-after-free bugs above, but now we can also see why<br><em>double-frees</em> (in which you free the same memory region more than once) can<br>cause bugs and security vulnerabilities: they add the same region to it twice,<br>which then might get allocated to two different variables or processes, which<br>might ruin the per-process isolation that virtualization is supposed to provide.<br>In addition, our page allocator handles fixed-size regions, but a heap allocator<br>needs to use variable regions, so when a memory region gets allocated twice<br>after a double-free, it might get split up into differently-sized pieces, of<br>which some parts get allocated to other processes, etc… It’s just a nightmare.</p>
<p>Next up, we’ll see the full story of virtual memory.</p>
<h1 id="More-Paging-The-Kernel-Side"><a href="#More-Paging-The-Kernel-Side" class="headerlink" title="More Paging: The Kernel Side"></a>More Paging: The Kernel Side</h1><p>We’ve already talked <em>plenty</em> about virtual memory, and I bet you’re probably so<br>over <code>entrypgdir</code> by now; let’s wrap up its story and get rid of it!</p>
<p>The <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/vm.c">vm.c</a> file is HUGE; only <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a> and <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/sysfile.c">sysfile.c</a> match its length. Some<br>parts deal with the general paging implementation; we’ll look at those here. The<br>rest handles the details of paging for processes and user code, we’ll need to<br>know a bit more about processes in xv6 for that.</p>
<h2 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h2><p>After the include directives for the preprocessor, we have a declaraction for<br>an external symbol defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>. This one is the beginning of the<br>data section for the kernel.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> data[];</span><br></pre></td></tr></table></figure>

<p>Next we have a definition for a pointer to a global page directory: this is the<br>fancy new one that’s gonna replace <code>entrypgdir</code>. Note that <code>pde_t</code> is a type for<br>page directory entries defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>; it’s just a type alias for <code>int</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *kpgdir;</span><br></pre></td></tr></table></figure>

<h3 id="seginit"><a href="#seginit" class="headerlink" title="seginit"></a>seginit</h3><p>This first function gets called directly by the kernel’s <code>main()</code>; it sets up<br>the segment descriptors in the GDT as identity maps to all of memory so that we<br>can ignore them from now on. Wait, didn’t we already do that in the boot loader?</p>
<p>Yes, kind of, but that was before the kernel took over, so back then we had no<br>notion of kernel space versus user space. Now that we do, we want to set the<br>permission flags for each segment so that we can use the privilege ring levels,<br>with the kernel in ring 0 and user code in ring 3. That way any misbehaving user<br>code will get slapped with a segmentation fault the way we’ve all come to know<br>and love in C.</p>
<p>We also have some permission flags for protection in the page directory and page<br>table entries, so maybe we could get away without it? I mean, both kernel code<br>and user code are read-only anyway, so maybe they could both have a Descriptor<br>Privilege Level of 3. But no, x86 is gonna shut that right down by forbidding<br>interrupts that take you from ring level 0 to ring level 3, so all the interrupt<br>handler functions have to be in kernel space with a kernel code segment selector<br>at ring level 0.</p>
<p>So we’re just gonna have to do it all over again. Great. Well, maybe it’s not<br>too bad, let’s take a look… oh god, it’s awful. Okay, deep breath.</p>
<p>Each processor has its own GDT, so we’re gonna need to call this function once<br>per CPU. First we figure out which CPU we’re on with with the <code>cpuid()</code> function<br>that we’ll see later on; for now it… (drumroll)… gets the CPU’s ID. Then we<br>look that up in a global table of CPUs (there’s an <code>extern</code> declaration for this<br>in the included <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.h">proc.h</a>) and store it in a <code>struct cpu</code>; we saw that before in<br>the spin-lock code, but we’ll get around to talking about it more later.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[cpuid()];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That <code>struct cpu</code> has a field to hold the GDT, so we’re gonna add entries for<br>the kernel code, kernel data, user code, and user data segment descriptors;<br>those entries are <code>SEG_KCODE</code>, <code>SEG_KDATA</code>, <code>SEG_UCODE</code>, and <code>SEG_UDATA</code>,<br>respectively. Recall that the permission bits are <code>STA_X</code> (executable), <code>STA_R</code><br>(readable), and <code>STA_W</code> (writeable); now we’re gonna pile on the descriptor<br>privilege levels for the kernel (0) and user (3, or <code>DPL_USER</code>) on top. Besides<br>those ring levels, we want to ignore segmentation, so each segment should be an<br>identity map for all virtual memory from 0 to 4 GB (0xffff_ffff).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c-&gt;gdt[SEG_KCODE] = SEG(STA_X|STA_R, <span class="number">0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;gdt[SEG_KDATA] = SEG(STA_W, <span class="number">0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;gdt[SEG_UCODE] = SEG(STA_X|STA_R, <span class="number">0</span>, <span class="number">0xffffffff</span>, DPL_USER);</span><br><span class="line">    c-&gt;gdt[SEG_UDATA] = SEG(STA_W, <span class="number">0</span>, <span class="number">0xffffffff</span>, DPL_USER);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The only difference between the <code>SEG</code> macro used here and the <code>SEG_ASM</code> one from<br>the boot loader is that this one is for C code and the other is for assembly.</p>
<p>Finally, we load up the new GDT into the processor with a C wrapper for the<br>x86 instruction <code>lgdt</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lgdt(c-&gt;gdt, <span class="keyword">sizeof</span>(c-&gt;gdt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done with segmentation, now on to more paging.</p>
<h3 id="walkpgdir"><a href="#walkpgdir" class="headerlink" title="walkpgdir"></a>walkpgdir</h3><p>A page directory lets the paging hardware convert virtual addresses to physical<br>ones, but we’re gonna need those mappings in the kernel too while we set up the<br>page directory, so this function does the conversion manually. Wait, but aren’t<br>we setting up paging so that all of physical memory is mapped in the higher half<br>of the virtual address space? Can’t we just add or subtract <code>KERNBASE</code> to do the<br>conversion? Well, that would work for kernel virtual addresses, but user virtual<br>addresses actually will use page directories and page tables in a non-obvious<br>way, so if we want to figure out where those go, we’ll need a function for it.</p>
<p>In C, using the <code>static</code> keyword before a function limits its scope and makes it<br>visible only within its own file. The function returns a <code>pte_t *</code>, a pointer to<br>a page table entry (the type is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as a type alias for <code>uint</code>).</p>
<p>Its arguments are a pointer to a page directory, a virtual address, and <code>alloc</code><br>(a boolean variable, but as an <code>int</code> instead of <code>bool</code>). This <code>alloc</code> lets the<br>function play a dual role: if it’s set, the function will allocate a page table<br>if needed; otherwise it reports failure if the page table doesn’t exist. The<br><code>const</code> keyword lets the compiler know a variable shouldn’t be mutated so it’ll<br>throw an error if we do. Here, <code>const void *va</code> is a pointer to a constant value<br>of any type; the address the pointer holds might change, but we can never write<br>to that address. The opposite is a <code>void *const va</code>: the address being pointed<br>to will never change, but we can overwrite the contents of that address all we<br>want. You can combine the two with <code>const void *const va</code>. What’s that I hear? C<br>syntax is the worst? No, never…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember way back when, when we talked about how “linear” addresses are set up<br>and converted to physical ones? The first 10 bits are an index for the page<br>directory to pick a page directory entry, which points to a page table; the next<br>10 bits pick a page table entry that points to a page, and the last 12 bits are<br>an offset within that page; the <code>PDX()</code> and <code>PTX()</code> macros get first 10 bits and<br>the next 10 bits from a linear address, respectively. So we start by getting the<br>page directory index and using that to get the page directory entry.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *pde = &amp;pgdir[PDX(va)];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now <code>pde</code> points to a page directory entry which has two parts: a<br>pointer to the physical address of a page table, and some flags. But who knows<br>if this page table even exists; most page directory (and page table) entries<br>aren’t mapped in order to save space. So we have to check whether <code>*pde</code> has the<br><code>PTE_P</code> (present) flag set.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the page table exists, we should get rid of the flags and recover the pointer<br>to the page table using the <code>PTE_ADDR()</code> macro. But the hardware uses physical<br>addresses for these pointers, so we need to convert it to a virtual address<br>first, which is what this function does… recursion? Bootstrap problem? No,<br>it’s actually easy because we can access the page table from within the kernel’s<br>virtual address space in the higher half by adding <code>KERNBASE</code> to the physical<br>address with the <code>P2V()</code> macro.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        pgtab = (<span class="type">pte_t</span> *) P2V(PTE_ADDR(*pde));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now for the else clause, which happens if the page directory entry doesn’t have<br>the <code>PTE_P</code> bit set. Well, if the boolean <code>alloc</code> is false (zero), then we’re<br>done and we should just report failure by returning a null pointer. On the other<br>hand, if it’s true, we just allocate a page for the page table. But wait,<br>remember how page allocation might fail and return a null pointer if we’re out<br>of free pages in the free list? And remember how I said we should always check<br>for that? Okay well let’s check for that; if allocation fails, we also return a<br>null pointer. Oh, and because this is C, we’re gonna do a jillion things at once<br>in a single line: check if <code>alloc</code> is false, try to allocate a page table, and<br>check if that allocation failed. C lets us assign to a variable and then test<br>that variable’s value in a single statement.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!alloc || (pgtab = (<span class="type">pte_t</span> *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now suppose: (1) the page table wasn’t present, (2) alloc was set, and<br>(3) we successfully allocated a page. Now what? Remember how we filled all free<br>pages with garbage in <code>kfree()</code> using <code>memset()</code>? Let’s undo that now by zeroing<br>it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">memset</span>(pgtab, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll update the page directory entry to point to this new page table and<br>add the <code>PTE_P</code> flag so it knows it’s present. Wait, while we’re at it, what<br>other permissions will it need? Is it writeable? Can users access it? Hmm, we’d<br>have to know whether we’re looking up a user virtual address or a kernel one,<br>and whether it’s gonna be used for code or data. Ah, screw it, we’ll just throw<br>all the flags on there at once. Either way, the page table entries will have<br>their own flags too, so we can restrict the page’s permissions there instead of<br>here at the page directory entry.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This probably isn’t the safest thing ever, because we’re saying that only the<br>page table will restrict permissions, so we’re throwing all that responsibility<br>over there, but hey, xv6 is supposed to be simple, not ultra-secure. Just don’t<br>do this at home, kids.</p>
<p>Finally, we return the address of the corresponding page table entry using the<br>index from the middle bits of <code>va</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pgtab[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mappages"><a href="#mappages" class="headerlink" title="mappages"></a>mappages</h3><p>Okay, so <code>walkpgdir()</code> returns a pointer to a page table entry and can even<br>crate a page table if if it doesn’t exist. That’s not quite enough to add new<br>mappings for pages though; the page itself might not be mapped, and if we just<br>created a new page table, then certainly none of the pages are mapped yet.<br><code>mappages()</code> will finish the job by installing mappings in page tables (possibly<br>newly-allocated ones) for a range of virtual addresses.</p>
<p>The arguments are a page directory, a virtual address for the beginning of the<br>range, the size of the range, a physical address to map it to, and the flags for<br>permissions we want to set. We start off by rounding the virtual address down to<br>the nearest page boundary and getting a pointer to the end of the range, also<br>page-aligned.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span> *) PGROUNDDOWN((uint) va);</span><br><span class="line">    <span class="type">char</span> *last = (<span class="type">char</span> *) PGROUNDDOWN(((uint) va) + size - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’re gonna iterate over the pages in that range; <code>for (;;)</code> is a common C<br>idiom for an infinite loop. In this case, we need to increment <code>a</code> and <code>pa</code> by<br><code>PGSIZE</code> each time, and we’ll break out of the loop when <code>a</code> reaches <code>last</code>. To<br>be completely honest, I’m not really sure why the authors chose to write this as<br>an infinite loop with the condition&#x2F;break statement and update statements inside<br>the loop rather than as a regular old for loop; I think the latter would be more<br>clear, but oh well, I didn’t write this.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (a == last) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inside the for loop, we’ll start each iteration by looking up the right page<br>table entry with <code>walkpgdir()</code>, with <code>alloc</code> set to true. Remember how that<br>function called <code>kalloc()</code>, which might fail, in which case it returns a null<br>pointer? Well that means we’ve gotta check for a null pointer here too. This<br>time however, we’ll return -1 for failure and 0 for success, because why not?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, a, <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re supposed to be allocating brand-new pages for this range of addresses, so<br>if a page has already been allocated, we’ll just flip out in rage and panic.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_P) &#123;</span><br><span class="line">            panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last thing before checking the loop condition and updating <code>a</code> and <code>pa</code> is<br>to install the mapping to the right physical address with the right permissions<br>in the page table. Then we’re done!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *pte = pa | perm | PTE_P;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cool, now we have a way to map new pages into a page directory. We’re well on<br>our way to leaving poor old <code>entrypgdir</code> behind for the shiny new <code>kpgdir</code>.</p>
<h3 id="kmap"><a href="#kmap" class="headerlink" title="kmap"></a>kmap</h3><p>Each process is gonna have its own page directory, so its mappings in the lower<br>half of the virtual address space might be totally different from those of<br>another process. But the mappings in the higher half (where the kernel lives)<br>will always be the same – that way, the kernel can always use the existing page<br>directory for whatever process it happens to be running. We’ll only use <code>kpgdir</code><br>when the kernel isn’t currently running a process, e.g. while it’s running the<br>scheduler.</p>
<p>So when we create a new process, we’ll need to copy in all the mappings that the<br>kernel expects to find into a fresh page directory for that process. Those are:<br>memory-mapped I&#x2F;O device space from physical address 0 to 0x10_0000 (the boot<br>loader is also here, but we don’t need it any more), kernel code and read-only<br>data from 0x10_0000 to the physical address of <code>data</code> (one of the symbols<br>defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>), kernel data the rest of physical memory from there to<br><code>PHYSTOP</code>, and more I&#x2F;O devices from 0xFE00_0000 and up. Each of these ranges<br>needs its own permissions too.</p>
<p>We’ll represent each of these mappings with a <code>struct kmap</code>, which has fields<br>for the starting virtual address, the starting and ending physical addresses,<br>and the permissions; then the mappings will get stored in a static global<br>variable <code>kmap</code>… oh come on, what fresh hell is THIS?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *virt;</span><br><span class="line">    uint phys_start;</span><br><span class="line">    uint phys_end;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line">&#125; kmap[] = &#123;</span><br><span class="line">    &#123; (<span class="type">void</span> *)KERNBASE, <span class="number">0</span>, EXTMEM, PTE_W &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)KERNLINK, V2P(KERNLINK), V2P(data), <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)data, V2P(data), PHYSTOP, PTE_W &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)DEVSPACE, DEVSPACE, <span class="number">0</span>, PTE_W &#125;.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Okay, there are a few things going on here. First, the <code>static</code> keyword for a<br>variable means that variable has a single fixed location in memory that it’s<br>never gonna move out of.</p>
<p>Then it does that thing again where we simultaneously define a <code>struct</code> type and<br>define a variable of that type. So the type is</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *virt;</span><br><span class="line">    uint phys_start;</span><br><span class="line">    uint phys_end;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>So then the static global variable <code>kmap</code> is an array of <code>struct kmap</code>s. I guess<br>we ran out of names or something. The array has four entries, and since each one<br>is a <code>struct</code>, it needs curly braces around it.</p>
<p>The first entry (for the lower of the two memory-mapped I&#x2F;O device regions) has<br>a <code>virt</code> field of <code>KERNBASE</code>, a <code>phys_start</code> field of 0, a <code>phys_end</code> field of<br><code>EXTMEM</code> (defined as 0x10_0000), and permission flag <code>PTE_W</code>. So it maps a<br>virtual address range starting at <code>KERNBASE</code> to the physical address range from<br>0x0 to 0x10_0000 and makes it writeable so we can communicate with the devices<br>there. The next two entries are similar, except that the kernel code isn’t<br>writeable.</p>
<p>The last entry has <code>phys_start</code> of 0xFE00_0000 and a <code>phys_end</code> of 0. That’s a<br>little strange, but it’s because we want to map all the way up to the end of the<br>virtual address space at 0xFFFF_FFFF. The end should be one byte past that, but<br>it’s impossible to represent 0x1_0000_0000 with 32 bits. Setting the end to 0<br>makes the size calculation (<code>phys_end - phys_start</code>) work out nicely: it’ll just<br>overflow to the right number. This is okay since we’re using unsigned integers,<br>but note that <em>signed</em> integer overflow is undefined behavior and thus VERY BAD<br>and the cause of many security vulnerabilities.</p>
<p>Okay, back to getting rid of <code>entrypgdir</code>!</p>
<h3 id="setupkvm"><a href="#setupkvm" class="headerlink" title="setupkvm"></a>setupkvm</h3><p>This function sets up a fresh new page directory with all the mappings in <code>kmap</code><br>in order to please the kernel when it encounters the page directory. So needy,<br>right?</p>
<p>It takes no arguments and returns a pointer to the new page directory. First,<br>let’s allocate a page of memory to hold the new directory. We’ll be good and<br>remember to check for null (in which case we return null too) and clear the page<br>of the garbage values we wrote when we freed it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *pgdir;</span><br><span class="line">    <span class="keyword">if</span> ((pgdir = (<span class="type">pde_t</span> *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The upper end of virtual memory after <code>DEVSPACE</code> has I&#x2F;O devices, so <code>PHYSTOP</code><br>should be below that; this is as good a place as any to make sure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (P2V(PHYSTOP) &gt; (<span class="type">void</span> *) DEVSPACE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;PHYSTOP too high&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll add all the mappings in <code>kmap</code> above into this page directory so<br>the kernel is happy. We’ll use <code>mappages()</code>, which returns -1 if it fails, so<br>we should check for that. The <code>freevm()</code> function is defined below, and we’ll<br>get to it soon, but for now just know that it gets rid of all the mappings we<br>just made, in case any of them fails.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> *<span class="title">k</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (k = kmap; k &lt; &amp;kmap[NELEM(kmap)]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappages(pgdir,</span><br><span class="line">                k-&gt;virt,</span><br><span class="line">                k-&gt;phys_end - k-&gt;phys_start,</span><br><span class="line">                (uint) k-&gt;phys_start,</span><br><span class="line">                k-&gt;perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            freevm(pgdir);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pgdir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s check out that for loop: <code>k</code> is a pointer to a <code>struct kmap</code>, and <code>kmap</code><br>is an array of <code>struct kmap</code>s; in C, arrays decay to pointers, so they have the<br>same type. <code>k</code> starts off pointing to the first (zero) entry of <code>kmap</code>. Then<br>incrementing it with <code>k++</code> shifts its value by the size of a <code>struct kmap</code>, so<br>it’ll point to the next entry. The loop stops when <code>k</code> points beyond the last<br>entry of <code>kmap</code>, as determined by the <code>NELEM()</code> macro which counts the number of<br>entries in an array. Note that array element-counting only works in C if the<br>array is defined in the same function or as a global variable in the same file,<br>which is why it’s so easy to do an out-of-bounds read or write in C (yet another<br>common security vulnerability).</p>
<p>Finally, if everything worked out okay, we return a pointer to the new page<br>directory.</p>
<h3 id="switchkvm"><a href="#switchkvm" class="headerlink" title="switchkvm"></a>switchkvm</h3><p>We said above that the kernel would usually just use the page directory of the<br>currently-running process, but it’ll use <code>kpgdir</code> when no process is running,<br>i.e. during the kernel setup and while it’s scheduling a new process. So we need<br>a way to tell the paging hardware to load <code>kpgdir</code> into register <code>%cr3</code>, which<br>holds a pointer to the page directory. That’s this function.</p>
<p>It’s a one-liner: get the physical address of <code>kpgdir</code> and stick it in <code>%cr3</code><br>with the assembly instruction <code>lcr3</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcr3(V2P(kpgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvmalloc"><a href="#kvmalloc" class="headerlink" title="kvmalloc"></a>kvmalloc</h3><p>FINALLY, we’re here! We’re gonna get rid of <code>entrypgdir</code>! The kernel’s <code>main()</code><br>calls this function right after <code>kinit1()</code>.</p>
<p>We already did all the hard work, so this one’s a breeze: we call <code>setupkvm()</code><br>to allocate a new page directory and fill it with the kernel’s mappings, then<br>call <code>switchkvm()</code> to load it into the paging hardware.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kvmalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    kpgdir = setupkvm();</span><br><span class="line">    switchkvm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And we’re DONE! Take that, <code>entrypgdir</code>, we don’t need you anymore. We’re big<br>kids now.</p>
<h2 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h2><p>So far, it’s been a serious odyssey just to move from no paging in the boot<br>loader, to super basic paging with <code>entrypgdir</code> in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/entry.S">entry.S</a>, to <code>kpgdir</code> now.<br>Along the way, we’ve looked at code to allocate and free pages and install new<br>mappings in page directories and page tables. That’ll come in handy when we look<br>at processes next; the virtual memory story still isn’t over.</p>
<p>Also, note that <code>kpgdir</code> still isn’t at the height of its powers: at the point<br>when <code>main()</code> calls <code>kvmalloc()</code>, the free list only contains pages for physical<br>memory between 0 and 4 MB. The rest will have to wait until <code>kinit2()</code> unleashes<br>its full potential. (Maybe some self-actualization seminars would help…)</p>
<h1 id="More-Paging-The-User-Side"><a href="#More-Paging-The-User-Side" class="headerlink" title="More Paging: The User Side"></a>More Paging: The User Side</h1><p>It’s almost time to turn to interrupts and processes so we can figure out how to<br>work that sweet multiprocessing magic, but unfortunately we have some last<br>pieces of paging to wrap up before we can get there.</p>
<p>I know, we’ve been talking about virtual memory for what feels like a century<br>now, but so far everything we’ve done has been on the kernel side, allocating<br>pages and creating new page directories with the same kernel mapping. But what<br>about the lower half of the virtual address space, where user processes live?</p>
<p>This post will go through the rest of<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/vm.c">vm.c</a><br>and set up the paging-related machinery we’ll need to run processes later on.</p>
<h2 id="Detour-Starting-a-New-Process"><a href="#Detour-Starting-a-New-Process" class="headerlink" title="Detour: Starting a New Process"></a>Detour: Starting a New Process</h2><p>When xv6 runs a new process, it will create a brand new virtual memory space for<br>it with a fresh page directory. We haven’t talked about processes in xv6 yet, so<br>you might wonder how a process gets started up in the first place.</p>
<p>Let’s forget all about xv6 for a second and think about another Unix-like OS:<br>Linux. How do we start a process there? Okay, we also have to forget about GUI<br>applications there. Let’s just say you want to run some C code (xv6 maybe?) that<br>you’ve just compiled; what happens when you run it from the terminal?</p>
<p>Hopefully, you’ve done the OSTEP project called <a target="_blank" rel="noopener" href="https://github.com/remzi-arpacidusseau/ostep-projects/tree/master/processes-shell">processes-shell</a><br>by now, so you know the answer; if you haven’t, I recommend doing that one right<br>now before I give it away. (It’s not strictly required, but are you really the<br>kind of person who loves getting movies spoiled for them?)</p>
<p>Okay, are you done?</p>
<p>The answer: it’s just an <code>exec()</code> system call! The shell finds the executable<br>file in the file system, calls <code>fork()</code> to create a new child process, which<br>then calls <code>exec()</code> to transform itself into the program you want to run.</p>
<p>We’ll get to these system calls later, so for now let’s just go over the broad<br>strokes as they relate to virtual memory. <code>fork()</code> works by taking the parent<br>process’s virtual memory space and making a copy of it for the child process.</p>
<p><code>exec()</code> allocates a new page directory, figures out how much memory the new<br>program will need when it runs, then grows the virtual memory space allocated in<br>that new page directory to the required size. Then it loads the program into<br>memory in the new page directory.</p>
<p>Next, <code>exec()</code> skips a page, leaving it mapped but user-inaccessible; then the<br>next page becomes the process’s stack. Why that empty page? It’s an important<br>one for protection: that way, user programs that blow their stack will trigger a<br>page fault or a general protection fault instead of possibly overwriting random<br>code.</p>
<p>Then <code>exec()</code> copies some arguments into the stack before it switches to using<br>the new page directory and gets rid of the old one it had before.</p>
<p>Whew, okay, that’s a lot of code to go over later, and that’s only the virtual<br>memory part of the story. So let’s just make it easier by doing all the work we<br>can right now. According to the above, we have to understand how xv6 does all of<br>the following:</p>
<ul>
<li>Makes a copy of a whole page directory,</li>
<li>Creates a new page directory,</li>
<li>Grows (or shrinks) the virtual memory space of a page directory,</li>
<li>Loads program code into a page directory,</li>
<li>Makes a page inaccessible to users,</li>
<li>Copies stuff into a page in a page directory,</li>
<li>Switches to a new process page directory, and</li>
<li>Gets rid of an unused page directory.</li>
</ul>
<p>Finally, there’s one edge case to think about: running the very first process.<br>We obviously need to start running a shell at some point, so we need a special<br>way to get that started too, so it can in turn run other processes.</p>
<h2 id="vm-c-Again"><a href="#vm-c-Again" class="headerlink" title="vm.c, Again"></a>vm.c, Again</h2><p>We’re gonna need some new functions! Actually, we already finished one of the<br>requirements – <code>setupkvm()</code> can allocate a new page directory and set up the<br>kernel portion too. <code>switchkvm()</code> lets us switch to using <code>kpgdir</code> as a page<br>directory, but now we need to switch <em>away</em> from that to a page directory for a<br>process, so that’ll be <code>switchuvm()</code>.</p>
<p><code>copyuvm()</code> creates a copy of an entire page directory for a child process.<br><code>allocuvm()</code> and <code>deallocuvm()</code> grow and shrink the virtual memory space that’s<br>allocated in a page directory, and <code>freevm()</code> clears a page directory we no<br>longer need.</p>
<p><code>loaduvm()</code> will load program code into a page directory; <code>clearpteu</code> makes a<br>page inaccessible to users, and <code>copyout()</code> copies data into a page in a page<br>directory. <code>inituvm()</code> handles the special case of setting up the page directory<br>for the very first process that xv6 will run.</p>
<p>The rest of this post will go over those functions one by one so we can be done<br>with virtual memory, but I know it’s a little strange to go through a million<br>helper functions when we haven’t seen the code that’s gonna use them yet, so if<br>you’d prefer, you can come back to this after reading about processes and system<br>calls.</p>
<h3 id="deallocuvm"><a href="#deallocuvm" class="headerlink" title="deallocuvm"></a>deallocuvm</h3><p>The arguments for this function are a page directory, the process’s old size,<br>and the new size we want to shrink it down to; it’ll return the process’s new<br>size. By “shrinking” a virtual memory space, we really mean making sure that the<br>page directory only allocates up to <code>newsz</code> worth of pages. So if we think of<br>the sizes as virtual addresses, then the page directory currently maps the<br>virtual space from 0 to <code>oldsz</code>, so we should free everything between <code>newsz</code><br>and <code>oldsz</code>, leaving behind the space from 0 to <code>newsz</code>.</p>
<p>First, we should make sure the new size is actually smaller than the old one;<br>otherwise trying to “shrink” down to the new size might cause integer overflow.<br>There; the sizes are both unsigned integers here, so at least it wouldn’t be<br>that scary boogeyman of undefined behavior, but it could still be bad: 0 would<br>wrap around to 2^32 - 1, so “shrinking” to the new size would actually grow the<br>process way beyond what physical memory could handle.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newsz &gt;= oldsz) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re gonna shrink the physical memory allocated to this page directory by<br>freeing pages until we reach the new size. Let’s start with the first page above<br><code>newsz</code>; we can get its virtual address by rounding up <code>newsz</code> to a page<br>boundary.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint a = PGROUNDUP(newsz);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll just iterate over the pages between <code>a</code> and <code>oldsz</code> one at a time and<br>free them. This is a little tricky: <code>kfree()</code> takes a virtual address (cast to a<br><code>char *</code>), but it should be a <em>kernel</em> virtual address in the higher half, not a<br>user virtual address. Luckily, we already have <code>walkpgdir()</code>, which can take an<br>arbitrary virtual address and return its page table entry, so that’s a good<br>start.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walkpgdir(pgdir, (<span class="type">char</span> *) a, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The page table entry contains the page’s physical address, plus some flags to<br>determine whether it’s mapped and what permissions are set for it.</p>
<p>Now, a virtual address space isn’t laid out contiguously. Think about it: if you<br>sit back and imagine a user process hanging out in memory, what does that<br>address space look like? You’re probably imagining the stack at one end of<br>memory and the heap at the other, with each growing toward the center, right?<br>so there will be some pages in the center that aren’t mapped; some of the page<br>tables might not exist either, in which case <code>walkpgdir()</code> would return a null<br>pointer.</p>
<p>Remember we agreed to never dereference null pointers? Yeah, so we’ll have to<br>skip all those unmapped pages. If we got a null pointer, then that means the<br>entire page table doesn’t exist, so we need to skip forward to the next page<br>directory entry (and thus the next page table). We’ll have to move <code>a</code> to the<br>virtual address that corresponds to that next page directory entry.</p>
<p>We can get the page directory index from <code>a</code> with the <code>PDX()</code> macro we’ve seen<br>seen before, and then just add 1 to get the next entry in the page directory.<br>Now we need to turn that back into a virtual address. We’ll use a new macro,<br><code>PGADDR()</code> (also from <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>),<br>to do that. So then we’ll continue to the next loop iteration, which will get<br>the page table entry for this new virtual address.</p>
<p>Wait wait wait, one last thing! After all that, <code>a</code> should now be the first<br>virtual address in the page table for the new page directory entry… except<br>it’s get <code>PGSIZE</code> added to it because of the for loop’s update statement.</p>
<p>Ugh, okay, fine, this is annoying. Let’s just fix it with a hack: subtract<br><code>PGSIZE</code> from it now, so that it gets incremented to the right value in the next<br>iteration. Okay, that’s it, I swear!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walkpgdir(pgdir, (<span class="type">char</span> *) a, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            a = PGADDR(PDX(a) + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) - PGSIZE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now the else branch: if we don’t get a null pointer then at least the page<br>table exists, but that doesn’t mean the page itself is mapped. If it’s not, then<br>we don’t need to do anything else, but if it is mapped, then we need to free it.<br>We can get the page’s physical address out of the page table entry with the<br><code>PTE_ADDR</code> macro then make sure it’s not null.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            uint pa = PTE_ADDR(*pte);</span><br><span class="line">            <span class="keyword">if</span> (pa == <span class="number">0</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The whole point of this was to be able to call <code>kfree()</code>, remember? So let’s<br>convert <code>pa</code> to a kernel virtual address as a <code>char *</code> and free it. Then after<br>the loop is done, we’ll return the new size.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="type">char</span> *v = P2V(pa);</span><br><span class="line">            kfree(v);</span><br><span class="line">            *pte = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocuvm"><a href="#allocuvm" class="headerlink" title="allocuvm"></a>allocuvm</h3><p>This is the reverse of <code>deallocuvm()</code>: instead of freeing pages with <code>kfree()</code>,<br>we’ll allocate them with <code>kalloc()</code>. Here too, we start by checking for integer<br>overflow by making sure <code>newsz</code> really is larger than <code>oldsz</code>. But now we also<br>have to check that we’re not gonna grow the process’s size into the region where<br>it could access kernel memory; otherwise it might read or modify arbitrary<br>physical memory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newsz &gt;= KERNBASE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newsz &lt; oldsz) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re gonna start adding new pages right after <code>oldsz</code>, so we have to align that<br>to a page boundary:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint a = PGROUNDUP(oldsz);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The for loop is easier this time around because we already know that the pages<br>aren’t mapped. First we allocate a new page. Any call to <code>kalloc()</code> needs two<br>things after, remember? We have to check for null, in which case we print an<br>error message to the console (that’s <code>cprintf()</code>; we’ll get to that in the<br>devices section), then undo any allocations we made and return 0. Then we have<br>to zero the page because we filled it with 1s when it was freed.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">char</span> *mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;allocuvm out of memory\n&quot;</span>);</span><br><span class="line">            deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We have a page now, but it’s not yet mapped in the page directory. We can do<br>that with <code>mappages()</code>; that might fail too (because it needs to allocate more<br>pages for the page tables), in which case we do the same as before. Then after<br>the for loop is done, we return the new size.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span>, uint oldsz, uint newsz) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappages(pgdir, (<span class="type">char</span> *) a, PGSIZE, V2P(mem), PTE_W | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;allocuvm out of memory (2)\n&quot;</span>);</span><br><span class="line">            deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freevm"><a href="#freevm" class="headerlink" title="freevm"></a>freevm</h3><p>This function will get rid of a user page directory that we no longer need. Now<br>that we have <code>deallocuvm()</code>, it’s easy: we just “shrink” the process to a size<br>of zero. Oh and we’ll remember the lessons our ancestors have taught us and make<br>sure the pointer to the page directory isn’t null before dereferencing it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pgdir == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;freevm: no pgdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    deallocuvm(pgdir, KERNBASE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Great, so all pages are freed, and we’re done!</p>
<p>Now hang on a sec… The page directory itself resides in memory; so do the page<br>tables. We have to free those too. We’ll start with the page tables; freeing the<br>page directory first would be a use-after-free vulnerability because we’d need<br>to use it to get to the page tables.</p>
<p>We’ll iterate over the page directory’s entries, checking whether each one has<br>the “present” flag set (<code>NPDENTRIES</code> is defined as 1024 in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">mmu.h</a>).<br>If it does, we’ll get the page table’s physical address from it with the<br><code>PTE_ADDR()</code> macro, then convert that to a virtual address as a <code>char *</code> to make<br><code>kfree()</code> happy. We don’t have to worry about clearing the “present” flag in the<br>page directory because it’s about to be freed anyway.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; NPDENTRIES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pgdir[i] &amp; PTE_P) &#123;</span><br><span class="line">            <span class="type">char</span> *v = P2V(PTE_ADDR(pgdir[i]));</span><br><span class="line">            kfree(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We wrap up by freeing the page directory itself.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    kfree((<span class="type">char</span> *) pgdir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copyuvm"><a href="#copyuvm" class="headerlink" title="copyuvm"></a>copyuvm</h3><p>The <code>fork()</code> system call will need to “clone” a process, which includes its<br>virtual address space. This function takes a pointer to the parent process’s<br>page directory and the size of the parent process’s address space and returns a<br>pointer to a fresh new page directory with everything set up exactly the same.</p>
<p>We start by creating a new page directory and taking care of the kernel’s half<br>of the address space with <code>setupkvm()</code>. That might fail if it can’t allocate a<br>new page, so we have to check for null. Sigh. C code is approximately 40%<br>checking for null return values.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *d;</span><br><span class="line">    <span class="keyword">if</span> ((d = setupkvm()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll iterate over the user portion of the parent process’s address space<br>from 0 to <code>sz</code>, copying everything over as we go. Say we want to copy a page<br>from the parent’s virtual address <code>i</code> to the child’s address <code>i</code> (note that<br>they’ll map to different physical addresses). We’ll have to figure out the<br>corresponding kernel virtual address for the parent’s <code>i</code> in order to do that,<br>so we use <code>walkpgdir()</code> to get the page table entry, then get the page’s<br>physical address.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, (<span class="type">void</span> *) i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;copyuvm: pte should exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; PTE_P)) &#123;</span><br><span class="line">            panic(<span class="string">&quot;copyuvm: page not present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint pa = PTE_ADDR(*pte);</span><br><span class="line">        uint flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case we know the parent process is already set up, so we don’t really<br>have to worry about <code>walkpgdir()</code> failing and returning null, but it’s bad C<br>juju to ignore a possibly-null return value, so we just panic if it does fail or<br>if the page isn’t present.</p>
<p>Next we allocate a page for the child process (checking for null again…) and<br>copy everything from the parent’s page to the new child page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">char</span> *mem;</span><br><span class="line">        <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">        memmove(mem, (<span class="type">char</span> *) P2V(pa), PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might recognize <code>memmove()</code> as a C standard library function that copies the<br>contents of one memory address into another, but we can’t use those, remember?<br>So xv6 provides its own implementation of it in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>.</p>
<p>If you haven’t seen a <code>goto</code> statement before, it’s basically a holdover from ye<br>olde days before Edsger Dijkstra preached the gospel of structured programming<br>to the world and invented the if statement. It does exactly what it sounds like:<br>you make a label somewhere in code and it takes you there.</p>
<p>Next we stick that new page into the child’s page directory, checking for null<br>again. If <code>mappages()</code> fails, then the new page won’t be in the page directory,<br>so we have to free it here or else we’ll never be able to find it again: a<br>memory leak.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (mappages(d, (<span class="type">void</span> *) i, PGSIZE, V2P(mem), flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If none of the allocations failed, we just return a pointer to the new page<br>directory. But if something went wrong, then one of those <code>goto</code> statements will<br>send us to the time out corner of <code>bad</code>, where we undo all our work by freeing<br>the page directory and returning a null pointer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    freevm(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Great, another function we’ll have to check for null.</p>
<h3 id="switchuvm"><a href="#switchuvm" class="headerlink" title="switchuvm"></a>switchuvm</h3><p>Okay, we’ve got a way to create a new process page directory. We also have a way<br>to switch to using the kernel page directory <code>kpgdir</code> with <code>switchkvm()</code>. But we<br>need a way to switch to using the process page directory too. Enter <code>switchuvm()</code>.</p>
<p>I’ll warn you – <code>switchkvm()</code> was nice and short, but <code>switchuvm()</code> is an ugly<br>one for sure.</p>
<p>The argument to this function is a pointer to a <code>struct proc</code>, which represents<br>a process. We’ll talk about that more when we get to processes; two fields are<br>important now: <code>p-&gt;kstack</code> which holds a pointer to the kernel stack for that<br>process, and <code>p-&gt;pgdir</code>, which points to that process’s page directory.</p>
<p>Okay, well let’s start with some sanity checks to make sure that the process <code>p</code><br>actually exists (the pointer is non-null) and its kernel stack and page directory<br>pointers are non-null too.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no process&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kstack == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kstack == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The main function of loading the process’s page directory will be the same as in<br><code>switchkvm()</code>: just an <code>lcr3</code> instruction. But the difference now is that the<br>x86 architecture requires some additional bookkeeping for processes.</p>
<p>See, when the kernel runs a new process, the CPU will start executing different<br>instructions. But it needs a way to keep track of where it left off in the<br>kernel code so that it can pick the thread back up after the process is done<br>executing. Similarly, interrupts and system calls might change the running<br>process, so the CPU needs to record some metadata about the process’s state too<br>before switching to another one. x86 does that by means of a structure called a<br><em>Task State Segment</em>, or TSS.</p>
<p>The TSS holds information like the current state of certain registers (e.g.,<br><code>%esp</code>, <code>%eip</code>, <code>%cr3</code>, etc.), segment descriptors (<code>%cs</code>, <code>%ss</code>, <code>%ds</code>, etc.),<br>the current privilege leve, and I&#x2F;O privilege levels – in other words, the<br>process’s <em>context</em>. It can be located anywhere in memory, but the processor<br>needs to find it, so it uses an entry in the GDT called the TSS segment<br>descriptor that points to the TSS. Remember the GDT from way back when we were<br>talking about segmentation? Good times. The CPU holds a pointer to the GDT’s TSS<br>entry in a special register called the task register.</p>
<p>Back in the segmentation days of our youth, we stored the GDT in a <code>struct cpu</code><br>that held information about the current processor. We got that <code>struct cpu</code> by<br>calling a <code>mycpu()</code> function. We’re gonna do the same thing here in order to<br>update the GDT with a segment for the TSS. Getting interrupted in the middle of<br>this might be disastrous: the TSS would be half-updated, so who knows what would<br>happen when the CPU tried to resume execution where it last left off. So we’ll<br>use the <code>pushcli()</code> and <code>popcli()</code> functions we saw with spin-locks to temporarily<br>disable interrupts.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    mycpu()-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;mycpu()-&gt;ts, <span class="keyword">sizeof</span>(mycpu()-&gt;ts)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    mycpu()-&gt;gdt[SEG_TSS].s = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whoa okay what is this?</p>
<p>We’ve seen the <code>SEG()</code> and <code>SEG_ASM()</code> macros before; they created GDT segments.<br><code>SEG16()</code> does the same with 16 bits (it’s defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>). <code>STS_T32A</code><br>is a flag that sets the segment’s type as an available 32-bit TSS. Then we pass<br>in a pointer to the task state with <code>&amp;mycpu()-&gt;ts</code>, its size, and a descriptor<br>privilege level of 0 (which means ring 0, the kernel level). The GDT’s <code>.s</code><br>field is a one-bit flag to determine whether this is a system or application<br>segment, so we set it to system.</p>
<p>Okay, so now the GDT points to the task state. Next we need to update the task<br>state, then load it into the CPU. We’ll start by storing a segment selector and<br>the stack pointer in the task state; these should look familiar from the boot<br>loader and <code>seginit()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mycpu()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    mycpu()-&gt;ts.esp0 = (uint) p-&gt;kstack + KSTACKSIZE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The TSS can also specify permissions for accessing I&#x2F;O ports: for example,<br>setting the I&#x2F;O privilege level to 0 in the <code>eflags</code> register <em>and</em> setting a<br>part of the TSS called the I&#x2F;O map base address to an address beyond the TSS<br>segment forbids I&#x2F;O instructions like <code>inb</code> and <code>outb</code> from user space. So we’ll<br>set the I&#x2F;O map base address next.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mycpu()-&gt;ts.iomb = (ushort) <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So now we have a GDT entry pointing to the TSS, which is now updated. Now we<br>just load it into the task register with the x86 instruction <code>ltr</code>; here we use<br>a C wrapper for that assembly instruction, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ltr(SEG_TSS &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, the last thing we do before re-enabling interrupts is to load the<br>process’s page directory into the <code>%cr3</code> register so we can start using it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lcr3(V2P(p-&gt;pgdir));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loaduvm"><a href="#loaduvm" class="headerlink" title="loaduvm"></a>loaduvm</h3><p>Okay, this is another function that’s gonna require extra info we haven’t seen<br>yet, but I’m gonna make it a bit easier by waving my hands around and glossing<br>over the details. It’s gonna read a program from a file into memory at virtual<br>address <code>addr</code> using page directory <code>pgdir</code>. The part we want to read has size<br><code>sz</code> and is located at position <code>offset</code> within the file.</p>
<p>Now, what about the file? We’ll talk more when we get to the file system code,<br>but for now let’s just say that files are represented in xv6 as <code>struct inode</code>s,<br>and we can read from them with the function <code>readi()</code>.</p>
<p>We’re gonna run the program from this code, so the address it’s stored in needs<br>to be page-aligned.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((uint) addr % PGSIZE != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;loaduvm: addr must be page aligned&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’re gonna iterate over pages starting from <code>addr</code>, reading from the file<br>in <code>ip</code> into that page. As usual, we’ll need to get the kernel virtual address<br>from the user address <code>addr</code>, so we start by getting the page table entry via<br><code>walkpgdir()</code>, checking for a null pointer if the corresponding page table<br>doesn’t exist. Then we can turn that into a physical address.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// Get the page table entry</span></span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, addr + i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;loaduvm: address should exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get the page&#x27;s physical address</span></span><br><span class="line">        uint pa = PTE_ADDR(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we want to read from the file one page at a time using <code>readi()</code>, which<br>takes a pointer to an inode (here, <code>ip</code>), a kernel virtual address (<code>P2V(pa)</code>),<br>the location within the file of the segment we want to read (<code>offset + i</code>), and<br>the segment’s size.</p>
<p>Now we want to read from the file one page at a time using <code>readi()</code>. We have to<br>specify a size in bytes to read; if the remaining unread part of the segment is<br>larger than a page, then the size we pass to <code>readi()</code> should be <code>PGSIZE</code>, but<br>otherwise it’ll be less. So we’ll compare <code>sz</code> to <code>i</code> and define define <code>n</code><br>accordingly.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        uint n;</span><br><span class="line">        <span class="keyword">if</span> (sz - i &lt; PGSIZE) &#123;</span><br><span class="line">            n = sz - i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n = PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The other arguments to <code>readi()</code> are a pointer to an inode (<code>ip</code>), a kernel<br>virtual address (<code>P2V(pa)</code>), and the location within the file of the segment we<br>want to read (<code>offset + i</code>). It returns the number of bytes read, so if it’s not<br><code>n</code> we’ll report an error by returning -1. Otherwise we return 0 after the for<br>loop is done.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (readi(ip, P2V(pa), offset + i, n) != n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inituvm"><a href="#inituvm" class="headerlink" title="inituvm"></a>inituvm</h3><p>Okay, the next three are nice and easy! This next one is pretty similar to<br><code>loaduvm()</code>, except instead of loading program code from disk, it copies it in<br>from memory. We’ll take <code>sz</code> bytes from a source address of <code>init</code> and stick it<br>in address 0 of the process’s page directory <code>pgdir</code>.</p>
<p>This function is also easier because we’re only gonna call it for programs that<br>are less than one page in size, so we don’t have to worry about looping over<br>pages or anything like that. I like it when xv6 keeps things simple.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sz &gt;= PGSIZE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we allocate a fresh page of memory, zero it to clear the garbage values,<br>and stick it into <code>pgdir</code> at address 0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> *mem = kalloc();</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    mappages(pgdir, <span class="number">0</span>, PGSIZE, V2P(mem), PTE_W | PTE_U);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And we wrap up by actually loading the code from <code>init</code> into the new page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    memmove(mem, init, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clearpteu"><a href="#clearpteu" class="headerlink" title="clearpteu"></a>clearpteu</h3><p>This function takes a page directory and a user virtual address and clears the<br>“user-accessible” flag so that the process can’t touch it. It’s used to create<br>an inaccessible page below a new process’s stack to guard against stack<br>overflows; this way, a stack overflow will cause a page fault instead of<br>silently overwriting memory.</p>
<p>The <code>PTE_U</code> flag is in the page table entry, so we’ll have to get that, then set<br>the flag.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearpteu</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *uva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the page table entry</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = walkpgdir(pgdir, uva, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;clearpteu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Clear the user permission flag</span></span><br><span class="line">    *pte &amp;= ~PTE_U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here <code>&amp;</code> is a bitwise-AND and <code>~</code> is a bitwise-NOT; for reference, <code>|</code> is<br>bitwise-OR and <code>^</code> is bitwise-XOR. Contrast these with their logical versions,<br><code>&amp;&amp;</code>, <code>!</code>, and <code>||</code> (XOR has no logical version). C also has corresponding<br>assignment operators (similar to <code>+=</code>, <code>-=</code>, <code>*=</code>, etc.) for each of them. So<br>the last line of code is equivalent to <code>*pte = *pte &amp; (~PTE_U)</code>.</p>
<h3 id="uva2ka"><a href="#uva2ka" class="headerlink" title="uva2ka"></a>uva2ka</h3><p>We often need to convert user virtual addresses to kernel ones; <code>uva2ka()</code> is a<br>short helper function that does that while checking that the page is actually<br>present and has the user permission flag set.</p>
<p>We’ll call walkpgdir to get the page table entry, then check both permission<br>bits before recovering the page address with <code>PTE_ADDR()</code> and converting it to a<br>kernel virtual address. We’ll return the kernel virtual address as a <code>char *</code>,<br>or null if either flag is not set.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">uva2ka</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *uva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walkpgdir(pgdir, uva, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_P) == <span class="number">0</span>) &#123;  <span class="comment">// check that it&#x27;s present</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span>) &#123;  <span class="comment">// check that it&#x27;s user-accessible</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> *) P2V(PTE_ADDR(*pte));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let me ask you a weird question: how are you feeling right now?</p>
<p>Okay, that was a test of your C coding practices, because if you took those null<br>checks to heart, you should be <em>really</em> uncomfortable right about now.</p>
<p>Check it out: <code>walkpgdir()</code> returns a pointer to the page table entry. <em>Any</em><br>time a function returns a pointer, you should immediately ask yourself whether<br>that function can return a null pointer. Tons of C functions report an error by<br>returning null. In this case, we <em>know</em> <code>walkpgdir()</code> can fail and report null<br>if the page table doesn’t exist, so we <em>know</em> we might get a null pointer out of<br>it – it’ll happen whenever a page table doesn’t exist. So what do we do with<br>that knowledge?</p>
<p>Why, we go right ahead and dereference that pointer. WKBW;NQ39Q2A4T8YHMFGRW!!!</p>
<p>Dereferencing a null pointer is undefined behavior. There’s literally no telling<br>what might happen. It can cause all kinds of bugs from segmentation faults to<br>security vulnerabilities.</p>
<p>All those null checks in the other functions serve a purpose: if something goes<br>wrong and a function returns a null pointer, they catch it before it gets<br>dereferenced, then either handle it gracefully or simply propagate the error by<br>returning null (or some other error code) and let the caller figure out what to<br>do with it.</p>
<p>Omitting a check for a null pointer like <code>uva2ka()</code> does is bad practice in C<br>because it means the programmer has to <em>guarantee</em> – by manually checking –<br>that no call to this function could <em>ever possibly</em> cause a null return value.<br>Except humans are dumb, dumb creatures who make mistakes all the time, especially<br>in big projects: there’s no way you’d be able to remember that tiny little<br>detail two years later when you decide to refactor your code or add a new<br>feature or something.</p>
<p>But maybe you can note that in the comments? Okay yeah, but think about it: how<br>often do you go and look up the source code for every single function you call?<br>Yeah, I thought so.</p>
<p>This is why C is so dangerous: there are hundreds of such problems that you need<br>to be aware of and remember to add stuff like null pointer checks to your code.<br>If you don’t because you’re a normal human who forgets things sometimes, then<br>you’ll need to remember that you forgot to do it before and manually check every<br>single call to your code and think about every possible edge case that a<br>malicious adversary might exploit.</p>
<p>Good thing no one ever makes these mistakes in C, or we’d see enormous security<br>vulnerabilities being reported every single day in all kinds of critical<br>software. Oh wait…</p>
<p>So if you ever find yourself looking at C during code review and you come across<br>a function that returns a pointer, you should stop what you’re doing and look up<br>the documentation for that function. If that function has any chance of<br>returning a null pointer, then you should yell and kick and scream until somebody<br>adds a null check and figures out how they want to handle it if it’s null. Is<br>this annoying? Yes. Hard to remember? Yes. But that’s C. <em>(cough cough use Rust<br>instead cough cough…)</em></p>
<p>Now, the xv6 authors are so awesome that I’m gonna give them the benefit of the<br>doubt and assume they left it off because they hand-checked every call to make<br>sure it would never be an issue. But you and me? Nah.</p>
<p>The point of my rant is this: if you’re reading this, then you’re probably gonna<br>find yourself hacking away at xv6 for a project sooner or later. When you do<br>that, you should treat this function as VERBOTEN. You’re not allowed to touch<br>it or call it, at least until you add a null check to it yourself.</p>
<p>The same goes for any functions that call this one, because maybe all the<br>existing calls to <code>uva2ka()</code> are fine right now, but then you make some tiny<br>change and now it’s no longer guaranteed to never be null. For reference, this<br>function currently only gets called by <code>copyout()</code>, and that one only gets<br>called by <code>exec()</code>. <code>exec()</code> gets called by <code>sys_exec()</code>, the shell, and the<br>initial user-space program <code>init</code>. So be careful if you touch any of those.</p>
<p>Whew, okay, &#x2F;rant.</p>
<h3 id="copyout"><a href="#copyout" class="headerlink" title="copyout"></a>copyout</h3><p>This function copies <code>len</code> bytes of data from a kernel virtual address <code>p</code> to a<br>user virtual address <code>va</code> using page directory <code>pgdir</code>. <code>exec()</code> will use this<br>to copy command-line arguments to the stack for a program it’s about to run.</p>
<p>You might be wondering why it’s needed – doesn’t <code>memmove()</code> do the same thing?<br>Almost, but the difficulty is that <code>pgdir</code> may not be the current page<br>directory, so we’ll have to manually translate the virtual address <code>va</code>. That’s<br>where <code>uva2ka()</code> comes in, plus it ensures that the page for <code>va</code> has the right<br>flags set. <em>Then</em> we can use <code>memmove()</code>.</p>
<p>First, <code>p</code> will be the source address, but <code>memmove()</code> requires a <code>char *</code> in<br>order to copy data byte-by-byte, so let’s convert it now:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to get the kernel virtual address corresponding to <code>va</code>, but<br>there’s a challenge: what if the data crosses a page table boundary? It might be<br>spread across separate locations in physical memory (and thus in kernel virtual<br>memory too). So we’ll need a loop in which each iteration gets the next kernel<br>virtual address and copies whatever part of the data is in this page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        len -= n;</span><br><span class="line">        buf += n;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So we’ll start each iteration by making <code>va0</code> the base address of the page <code>va</code><br>is on and <code>pa0</code> the kernel address of <code>va0</code>, converted with <code>uva2ka()</code>. I…<br>honestly don’t know why they used <code>pa0</code> as an identifier here. It makes it look<br>like it should be a physical address, but it’s not; it’s a kernel virtual<br>address. Sigh. Anyway, the call to <code>uva2ka()</code> might fail if the page isn’t<br>present or it doesn’t have a user permission bit, so we have to check for a null<br>pointer and return -1 if we find one.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        uint va0 = (uint) PGROUNDDOWN(va);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *pa0 = uva2ka(pgdir, (<span class="type">char</span> *) va0);</span><br><span class="line">        <span class="keyword">if</span> (pa0 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        va = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now <code>va</code> is in between <code>va0</code> and the next page, so the length of the data within<br>this page is <code>PGSIZE - (va - va0)</code>, unless it’s the last page, in which case we<br>should pick the lesser of this value and <code>len</code> (since <code>len</code> gets decremented on<br>each iteration through the loop).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        uint n = PGSIZE - (va - va0);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we copy the data from <code>buf</code> into the target kernel virtual address for<br><code>va</code>. Hmm, we don’t have that yet. Oh wait, <code>pa0</code> is the kernel virtual address<br>for <code>va0</code>, and <code>va</code> is just <code>va-va0</code> bytes after that, so we’ll use it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        memmove(pa0 + (va - va0), buf, n);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We return 0 if everything went okay.</p>
<h2 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h2><p>Okay, that was a lot of helper functions, but we’re ALL DONE with virtual<br>memory! From now on, we have all the tools we’ll need to manage memory and set<br>up virtual address spaces for new processes.</p>
<h1 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h1><p>It’s time to turn our attention to processes in xv6!<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a> is another<br>huge file, so I’m gonna split it up into a few posts. This one will focus on the<br>basic functions we’ll need in order to create new processes; later posts will<br>go over scheduling and system calls.</p>
<h2 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a>proc.h</h2><p>I haven’t spent much time on the header files in xv6, but<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.h">proc.h</a> defines some<br>important structures we’re gonna be using often, so let’s just get those out of<br>the way first.</p>
<p>Let’s start off with the definition for <code>struct context</code>. The processor will<br>have to switch between different processes during interrupts, system calls,<br>exceptions, etc.; these <em>context switches</em> will require saving the contents of<br>some of the CPU registers so that it can reload them when it switches back and<br>resume execution where it left off. It’ll save the process’s context by pushing<br>those register contents on the stack; that way the stack pointer is effectively<br>a pointer to the context. So the fields of a <code>struct context</code> will just list all<br>the registers that were saved on the stack.</p>
<p>Now, which registers do we need to save? Let’s look at the full list on the<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/CPU_Registers_x86">OSDev Wiki</a>. We’ve got some general-<br>purpose registers, the instruction pointer register <code>%eip</code>, segment registers,<br>a flags register, control registers, and the GDT and IDT registers (x86 doesn’t<br>use the debug, test, or LDT registers).</p>
<p>The flags register, control registers, and GDT&#x2F;IDT registers shouldn’t change<br>between processes, so we don’t need to save those. What about the segment<br>registers like <code>%cs</code>? Back when we set up segmentation, we made the segments be<br>identity maps that would always stay the same for all processes. There are<br>separate segments for user mode and kernel mode, but context switches will<br>always occur in kernel mode, so the segment registers shouldn’t change, and we<br>don’t need to save them either.</p>
<p>We should definitely save the program counter (AKA instruction pointer <code>%eip</code>),<br>since that will point to the place in the code where we should resume execution.</p>
<p>The only ones left now are the general-purpose registers: the stack base pointer<br><code>%ebp</code> and stack pointer <code>%esp</code>, along with <code>%eax</code>, <code>%ebx</code>, <code>%ecx</code>, <code>%edx</code>,<br><code>%esi</code>, and <code>%edi</code>. We said above that the stack pointer <code>%esp</code> would tell us<br>where to find the context, so that must mean we’ll already have it through some<br>other means in order to find the rest of the context, so we don’t need to save<br>it again (we’ll see how we end up getting it later on). But we do need to save<br><code>%ebp</code>.</p>
<p>There’s an x86 convention that the caller of a function has to save <code>%eax</code>,<br><code>%ecx</code>, and <code>%edx</code>, so those are already taken care of. So we’ll just save the<br>others: <code>%edi</code>, <code>%esi</code>, and <code>%ebx</code>.</p>
<p>We end up with this list of saved registers as the fields for <code>struct context</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    uint edi;</span><br><span class="line">    uint esi;</span><br><span class="line">    uint ebx;</span><br><span class="line">    uint ebp;</span><br><span class="line">    uip eip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Next up: we might end up with a bunch of processes, some of which are currently<br>running while others aren’t. Let’s set up some labels to note that. We’ll<br>definitely need a <code>RUNNING</code> label; we’ll also use one called <code>RUNNABLE</code> for<br>processes that are ready to be run the next time there’s a free CPU. We also<br>need a label for processes that are blocked waiting for something else to happen<br>(e.g., I&#x2F;O); xv6 calls this <code>SLEEPING</code>. Processes that don’t exist yet will be<br>called <code>UNUSED</code>.</p>
<p>There are two special moments in a process’s lifecycle that we should be careful<br>with: birth and death. When we create a new process, we’ll have to do a bunch of<br>setup before it’s <code>RUNNABLE</code>; killing a process requires clean-up before it goes<br>back to <code>UNUSED</code>. We’ll call those <code>EMBRYO</code> and <code>ZOMBIE</code>, respectively.</p>
<p>We could use bit flags for these states or just regular integers, except then<br>we’d have to do annoying bit arithmetic or keep track of which number represents<br>which state. And yes, we could use a bunch of <code>#define</code> directives for the<br>preprocessor for that, but there’s a better way to do it. C lets us create data<br>types for labels using <code>enum</code>s. These don’t have fields like <code>struct</code>s do;<br>they’re basically just a mapping between integers and what the labels those<br>integers represent. So it’s pretty similar to using a bunch of <code>#define</code><br>directives, except that they’re all defined neatly in a single place, so it<br>helps us remember they’re all representing the same idea. So we’ll use an <code>enum</code><br>like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Now it’s time to look at how we’ll represent processes themselves together with<br>their metadata. Let’s see… what kind of unique data does each process have?<br>We just talked about <code>struct context</code>s and <code>enum procstate</code>s; each process will<br>have both of those.</p>
<p>We also talked about virtual memory for processes in a previous post, so it<br>should also have its own page directory and stack for the kernel to use, plus a<br>way to track the size of its virtual address space. We said then that processes<br>are created using <code>fork()</code>, so let’s add a field to point to the parent process.</p>
<p>We’ll need a way for the kernel to refer to a process, so let’s give it a unique<br>process ID. That’s not super helpful when it comes to debugging, so let’s also<br>add a name for it as a string.</p>
<p>The rest of the fields are for aspects we haven’t seen yet but will talk about<br>soon: a <em>trap frame</em> for interrupts and system calls, a boolean to track whether<br>a process should be killed soon, a <em>channel</em> to be able to wake up a sleeping<br>process, an array of open files, and a current working directory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    uint sz;                    <span class="comment">// size (in bytes) of virtual address space</span></span><br><span class="line">    <span class="type">pde_t</span> *pgdir;               <span class="comment">// page directory</span></span><br><span class="line">    <span class="type">char</span> *kstack;               <span class="comment">// kernel stack for this process</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>       <span class="comment">// process state</span></span><br><span class="line">    <span class="type">int</span> pid;                    <span class="comment">// process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>        <span class="comment">// parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// trap frame for current system call</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span>    <span class="comment">// saved register contents for context switches</span></span><br><span class="line">    <span class="type">void</span> *chan;                 <span class="comment">// channel that process is sleeping on, if any</span></span><br><span class="line">    <span class="type">int</span> killed;                 <span class="comment">// boolean: should process be killed soon?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// array of open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>          <span class="comment">// current working directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];              <span class="comment">// process name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Okay, next we’ll add another structure for metadata representing each CPU.</p>
<p>If you read the previous post, then you know each CPU has its own local<br>interrupt controller with a unique ID, so we’ll write that down. The post about<br>process paging talked about the TSS, so we’ll need one of those per CPU, plus a<br>GDT too.</p>
<p>At any point in time, a processor will be running one of: its own initialization<br>routine (only once while the kernel is setting up), a user process (or any<br>interrupts or system calls that come up), or a scheduler routine to run the next<br>process. So let’s add a pointer to a <code>struct proc</code>, which will be null if it’s<br>not running a process; a boolean <code>started</code> will be false until the CPU finishes<br>its own set-up. The scheduler isn’t itself a process; it uses the <code>kpgdir</code> page<br>directory and has its own context, so we’ll store that context in a field here.</p>
<p>Finally: remember how the spin-lock post talked about nested calls to <code>pushcli()</code><br>and <code>popcli()</code> tracking whether interrupts were enabled before the first call to<br><code>pushcli()</code>, and only enabling interrupts after the last call to <code>popcli()</code> if<br>they were enabled before? Those were tracked with per-CPU fields <code>ncli</code> and<br><code>intena</code>, so we need those too.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">    uchar apicid;               <span class="comment">// ID of this CPU&#x27;s local interrupt controller</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">scheduler</span>;</span>  <span class="comment">// scheduler&#x27;s context</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span>;</span>        <span class="comment">// task state segment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[<span class="title">NSEGS</span>];</span>  <span class="comment">// global descriptor table</span></span><br><span class="line">    <span class="keyword">volatile</span> uint started;      <span class="comment">// boolean: has this CPU been initialized yet?</span></span><br><span class="line">    <span class="type">int</span> ncli;                   <span class="comment">// depth of pushcli() nesting</span></span><br><span class="line">    <span class="type">int</span> intena;                 <span class="comment">// were interrupts enabled before pushcli()?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// currently running process</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Last but not least, we’ll add declarations for the global array of CPUs and the<br>number of CPUs actually present on this machine; these were defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mp.c">mp.c</a></p>
<p>Okay, on to the functions now!</p>
<h2 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a>proc.c</h2><p>xv6 uses a global process table with an array of processes to store all the<br><code>struct proc</code>s in; this means we’ll never be able to create more processes than<br>the number of entries in the array, <code>NPROC</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 64.<br>We’ll need a lock too to prevent data races while accessing the process table.<br>The process table’s definition does that thing again where you simultaneously<br>define a <code>struct type</code> and define a variable using that type in a single<br>statement.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line">&#125; ptable;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Then we define a global static variable to point to the first process that gets<br>run on xv6, so that other files can set it up.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">initproc</span>;</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Finally, we’re gonna need to assign unique process IDs, so we’ll use a global<br>counter to know which one we should use next.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="pinit"><a href="#pinit" class="headerlink" title="pinit"></a>pinit</h3><p>This function only does one thing: initializes the lock in the process table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;ptable.lock, <span class="string">&quot;ptable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mycpu"><a href="#mycpu" class="headerlink" title="mycpu"></a>mycpu</h3><p>This function will return a pointer to the <code>struct cpu</code> for the current CPU.<br>There’s a potential concurrency bug with this function: if it gets interrupted<br>before it returns, then it might get rescheduled on a different CPU, and end up<br>returning an incorrect <code>struct cpu</code>. So we need to make sure that interrupts are<br>disabled when we call it. Normally we’d do that with <code>pushcli()</code> and <code>popcli()</code>,<br>but those functions actually call this one, so we’d get an infinite recursion.<br>So instead we’re just gonna have to remember to disable interrupts <em>before</em><br>calling this function.</p>
<p>If you’re reading this because you’re gonna do some xv6 kernel hacking for an<br>OSTEP project or something, you should read that as “DANGER DANGER DANGER!”. If<br>your code calls this function, or calls any other functions that in turn call<br>this one, you <em>have</em> to make sure you’ve disabled interrupts first.</p>
<p>Concurrency bugs are a nightmare because they’re not deterministic: for example,<br>if you forget to disable interrupts before calling this function, it might work<br>just fine most of the time until the one unlucky moment when it gets interrupted<br>and rescheduled on a different CPU. So let’s make this easier to debug by<br>starting off with a check that interrupts are disabled and panic if they’re not.<br>We can check whether the interrupt flag <code>FL_IF</code> is set in the <code>eflags</code> register.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *<span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;mycpu called with interrupts enabled\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay so how do we figure out which CPU we’re on? Well, the previous post talked<br>about interrupt controllers; each CPU has a local interrupt controller with a<br>unique ID which we can get with <code>lapicid()</code>. Once we have that, we can iterate<br>over the CPU array <code>cpus</code> until we find an entry with a matching <code>apicid</code>; we’ll<br>just panic if none of them match.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *<span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> apicid = lapicid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ncpu; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpus[i].apidid == apicid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;cpus[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;unknown apicid\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cpuid"><a href="#cpuid" class="headerlink" title="cpuid"></a>cpuid</h3><p>Those local interrupt controller IDs aren’t guaranteed to start from 0, so we’ll<br>need another way to identify CPUs. We can just use its entry number in the<br>global <code>cpus</code> array for that; <code>cpus</code> is an array of <code>struct cpu</code>s, which in C<br>means it’s really a pointer to the entry with index 0. <code>mycpu()</code> returns a<br>pointer to the entry for the current CPU, so we can just subtract those pointers<br>to get the index.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpuid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mycpu() - cpus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="myproc"><a href="#myproc" class="headerlink" title="myproc"></a>myproc</h3><p>This function returns a pointer to the <code>struct proc</code> running on this CPU. We’re<br>gonna call <code>mycpu()</code> here, so we’ll be good and remember to dsable interrupts<br>first with <code>pushcli()</code> and reenable them at the end with <code>popcli()</code>. Then we’ll<br>get the current process from the <code>struct cpu</code>‘s field.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc *<span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocproc"><a href="#allocproc" class="headerlink" title="allocproc"></a>allocproc</h3><p>Okay, we’re finally at the code to create a new process! Whew, it’s been a long<br>journey.</p>
<p>This is a <code>static</code> function, which means it can only be called by functions<br>defined in this same file. Creating a new process will require modifying the<br>process table, so we need to grab the lock so that other threads can’t mess with<br>it while we’re using it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to look through the table and find a slot that’s <code>UNUSED</code>; if we<br>find on, then great, we’ll assign that slot to the new process after the <code>found</code><br>label below. But if none of them are free, we’ll have to return a null pointer<br>to indicate that. You know what that means, right? Yup, we’re gonna have to add<br>null checks every time we call this function! Wooooo!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look through process table looking for an UNUSED slot</span></span><br><span class="line">    <span class="keyword">for</span> (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If none is found, return null pointer</span></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Check out that for loop too: <code>p</code> is a pointer to a <code>struct proc</code> that starts off<br>pointing to <code>ptable.proc</code>; that means it points to the entry and index 0. Then<br>it gets incremented by 1 each iteration; since it’s a <code>struct proc</code>, the pointer<br>arithmetic will work out so that it points to the next entry in the process<br>table.</p>
<p>Okay now let’s check out the <code>found</code> label and see what happens if we did find<br>an unused slot. First we set its state to <code>EMBRYO</code> (instead of <code>RUNNABLE</code>, since<br>we’re not done setting it up) and give it a PID. That state means it’s neither<br><code>UNUSED</code> nor <code>RUNNABLE</code>, so we can be confident that any other threads wouldn’t<br>try messing with it right now; they can’t allocate the slot to another process,<br>and they can’t try to run it yet. So we can stop hogging the process table now<br>and let other threads take a turn.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    p-&gt;state = EMBRYO;</span><br><span class="line">    p-&gt;pid = nextpid++;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to allocate a page for this process’s kernel thread to use as a<br>stack. Remember, <code>kalloc()</code> can return null, so we need a null check here.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;kstack = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;state = UNUSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we’re not gonna set up its page directory yet; that’ll happen in <code>fork()</code>,<br>which we’ll see later on. But we do need to set up the process so that it’ll<br>start executing code somewhere. It needs to start off in kernel mode, then it’ll<br>context-switch back into user mode and start running its code.</p>
<p>We haven’t looked at the mechanics of context switches yet, so I’ll spoil it a<br>little now (I know, I’m sorry). When a process is already running, it can send a<br>system call to ask for the kernel’s attention to do whatever it needs, like a<br>baby crying until it gets fed or changed or burped or whatever. Then it’ll<br>switch into kernel mode to run the system call, then switch back to where it<br>left off and pick up from there.</p>
<p>Well, xv6 is all about simplicity, right? And what’s more simple and elegant<br>than treating a special case (creating a new process and starting it off running<br>some code) the same as the general case (returning from a system call)? So xv6<br>will set up every new process to start off by “returning” from a (non-existent)<br>system call. That way the context switch code can be reused for new processes<br>too.</p>
<p>New processes are created via <code>fork()</code>, so we’ll return into a function called<br><code>forkret()</code>. Then that has to return into the function <code>trapret()</code>, which<br>closes out a <em>trap</em> (interrupt, system call, or exception) by restoring saved<br>registers and switching into user mode. We’ll get to <code>forkret()</code> and <code>trapret()</code><br>soon.</p>
<p>But first, the challenge: how do we “return” into a function that never called<br>us in the first place? We talked about function calls in x86 in the post on<br>spin-locks with the <code>getcallerpcs()</code> function, so make sure to read that now if<br>you need a refresher.</p>
<p>To summarize: when a function <code>f()</code> calls another function <code>g()</code>, it pushes the<br>arguments of <code>g()</code> on the top of its stack. Then it pushes a return address to<br>know where it should continue running the code of <code>f()</code> after <code>g()</code> returns;<br>that’s just the <code>%eip</code> register. Then it pushes the base address of the stack<br>for <code>f()</code>, i.e. the current <code>%ebp</code> register. That’s where <code>g()</code>‘s stack will<br>start off.</p>
<p>When the scheduler first runs the new process, it’ll check its context via<br><code>p-&gt;context</code> to get its register contents, including the instruction pointer<br><code>%eip</code>. So if we want it to start executing the code in <code>forkret()</code>, the <code>eip</code><br>field of its context should point to the beginning of <code>forkret()</code>. Then we can<br>trick it into thinking that the previous caller was <code>trapret()</code> by setting up<br>arguments and a return address in its stack.</p>
<p>Let’s start off by getting a pointer to the bottom of the stack. We had just<br>allocated a new stack page at <code>p-&gt;kstack</code>, but the stack grows from high to low<br>addresses, so the base of the stack is really at <code>p-&gt;kstack + KSTACKSIZE</code>. We’ll<br>make it a <code>char *</code> so we can move around one byte at a time using pointer<br>arithmetic.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> *sp = p-&gt;<span class="built_in">stack</span> + KSTACKSIZE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we should push any arguments for <code>trapret()</code> on the stack; it takes a<br><code>struct trapframe</code> (which we’ll go over later), so we’ll leave some room for it<br>and make the process point to it with <code>p-&gt;tf</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="keyword">sizeof</span>(*p-&gt;tf);</span><br><span class="line">    p-&gt;tf = (<span class="keyword">struct</span> trapframe *) sp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we add a “return address” to the beginning of <code>trapret()</code> after that.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="number">4</span>;</span><br><span class="line">    *((uint *) sp) = (uint) trapret;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last thing we need is to save some space for the process’s context on the<br>stack and point <code>p-&gt;context</code> to it. Then we’ll zero it all out, except for the<br><code>eip</code> field, which will point to the beginning of <code>forkret()</code>. And that’s it!<br>We just return the pointer to the process now.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="keyword">sizeof</span>(*p-&gt;context);</span><br><span class="line">    p-&gt;context = (<span class="keyword">struct</span> context *) sp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(*p-&gt;context));</span><br><span class="line">    p-&gt;context-&gt;eip = (uint) forkret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can create new processes now!</p>
<h3 id="growproc"><a href="#growproc" class="headerlink" title="growproc"></a>growproc</h3><p>What about growing or shrinking the size of a process’s address space? We<br>already did most of the hard work with <code>allocuvm()</code> and <code>deallocuvm()</code> from the<br>post on process paging, so let’s take a beat to thank past us for that.</p>
<p>Okay, so first we have to get the current process’s size.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    uint sz = curproc-&gt;sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Depending on the size of <code>n</code>, we’ll either grow the process or shrink it by <code>n</code><br>bytes. Both <code>allocuvm()</code> and <code>deallocuvm()</code> can fail and return zero, so let’s<br>add some checks for those and return -1 if they fail.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sz = allocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sz = deallocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curproc-&gt;sz = sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we need to tell the hardware that there’s a new page directory in town<br>with a different size than the old one, so we’ll use <code>switchuvm()</code> to update<br>the page directory and TSS stored by the hardware to reflect the changes. Then<br>we return 0 to indicate everything went okay.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    switchuvm(curproc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="procdump"><a href="#procdump" class="headerlink" title="procdump"></a>procdump</h3><p>This function is for debugging purposes: it’ll print a complete listing of any<br>processes in the process table. Quick spoiler: the keyboard interrupt handler<br>function will set things up so that pressing <code>^P</code> runs this function. Go ahead,<br>load up xv6 and try it out!</p>
<p>We want to print out the state for each process, but the states in <code>enum procstate</code> are just integers, which isn’t very debug-friendly. So let’s map them<br>all to strings first with a static array of strings.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *states[] = &#123;</span><br><span class="line">        [UNUSED]    <span class="string">&quot;unused&quot;</span>,</span><br><span class="line">        [EMBRYO]    <span class="string">&quot;embryo&quot;</span>,</span><br><span class="line">        [SLEEPING]  <span class="string">&quot;sleep &quot;</span>,</span><br><span class="line">        [RUNNABLE]  <span class="string">&quot;runble&quot;</span>,</span><br><span class="line">        [RUNNING]   <span class="string">&quot;run   &quot;</span>,</span><br><span class="line">        [ZOMBIE]    <span class="string">&quot;sombie&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This array notation might be a little unusual if you haven’t seen it before: C<br>lets you initialize arrays by specifying the value of each entry. If you leave<br>any entries out, then they’ll get initialized to zero. You can even write the<br>entries out of order by adding their index before them in square brackets. So<br><code>&#123; [1] 5, [0] 2 &#125;</code> is the same thing as <code>&#123;2, 5&#125;</code>. The <code>enum</code> turns the states<br>into integers, so they work as indices here.</p>
<p>Now we’ll just iterate over the process table to get all the processes, skipping<br>over any <code>UNUSED</code> ones.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll get the process’s state (or just use <code>&quot;???&quot;</code> if something went wrong<br>and the state isn’t recognized).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">char</span> *state;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state &gt;= <span class="number">0</span> &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state]) &#123;</span><br><span class="line">            state = states[p-&gt;state];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we can print out its PID, state, and name to the console.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        cprintf(<span class="string">&quot;%d %s %s&quot;</span>, p-&gt;pid, state, p-&gt;name);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll see later on that the <code>sleep()</code> and <code>wakeup()</code> system calls<br>involve some lock trickery, so sleeping processes could be a common cause of<br>concurrency issues like deadlocks. So if a process is sleeping, we’ll print out<br>its call stack using the <code>getcallerpcs()</code> function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">            uint pc[<span class="number">10</span>];</span><br><span class="line">            getcallerpcs((uint *) p-&gt;context-&gt;ebp + <span class="number">2</span>, pc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; pc[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">                cprintf(<span class="string">&quot; %p&quot;</span>, pc[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h2><p>Whew, we’re making good progress. The most important part of this code was how<br>xv6 creates new processes and sets them up to start running: basically, it uses<br>some stack and function call trickery to make the scheduler start running a new<br>process with the code in <code>forkret()</code>, then <code>trapret()</code>, before switching context<br>into user mode.</p>
<p>We haven’t talked about those two functions yet; we’ll hold off on that until we<br>do traps and system calls. Next up is scheduling processes!</p>
<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><p>We’ve done a lot of talking about context switching and scheduling, but we’ve<br>procrastinated looking at the code for those. It’s time to fix that.</p>
<p>There are all kinds of advanced schedulers out there, but as we’ve said before,<br>the name of the game in xv6 is simplicity, so xv6 just uses a round-robin<br>scheduling algorithm in which in loops through the exisitng processes in order.<br>Each timer interrupt will force the current process to yield the processor and<br>perform a context switch back into the scheduler so it can run the next<br>available process.</p>
<h2 id="swtch-S"><a href="#swtch-S" class="headerlink" title="swtch.S"></a>swtch.S</h2><p>The <code>struct context</code> we talked about in the last post is gonna be key here, so<br>let’s just look at its fields again:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    uint edi;</span><br><span class="line">    uint esi;</span><br><span class="line">    uint ebx;</span><br><span class="line">    uint ebp;</span><br><span class="line">    uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The context switch function is <code>swtch()</code>; it’s gonna need to save and restore<br>processor registers, so that means it’s gonna have to be written in assembly.<br>But let’s pretend it’s just a C function for a second and talk about what it’s<br>going to do.</p>
<p>This function will save the contents of the registers on the stack as a <code>struct context</code>, then save that location as the old context. Then it’ll load a new<br>context, switch to the new stack, and restore the registers of the new context.<br>Its declaration would look like this in C:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context **old, <span class="keyword">struct</span> context *new)</span>;</span><br></pre></td></tr></table></figure>
<p>The first argument is a pointer <em>to a pointer</em> to a <code>struct context</code>. That<br>double indirection might be confusing, but there’s a method to this madness: C<br>passes arguments by value, so if we used <code>struct context *old</code> and changed <code>old</code><br>to point to the saved context, it would be lost as soon as we returned from this<br>function. So instead we have to use this kind of double pointer so we can set<br><code>*old</code> to point to the saved context. This way <code>old</code> will be lost anyway, but<br><code>*old</code> was changed and will persist beyond this function’s return.</p>
<p>Note that, as we’ve said before, those arguments will be pushed on the stack<br>before <code>swtch()</code> is called. So at the beginning of <code>swtch()</code>, the stack pointer<br><code>%esp</code> points to a return address; the argument <code>old</code> is one space (4 bytes)<br>above that in the stack, and <code>new</code> is one space higher than that.</p>
<p>Okay, let’s check out the assembly code now. We’re gonna start by saving those<br>arguments into registers. We can’t just use any old registers here, or we might<br>overwrite some of the data we’re trying to save. But in the last post, I said<br>x86 has a convention that the caller has to save the contents of the <code>%eax</code>,<br><code>%ecx</code>, and <code>%edx</code> registers, so that means we’re free to overwrite them all we<br>want since they’ve already been saved.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">    movl    4(%esp), %eax</span><br><span class="line">    movl    8(%esp), %edx</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>
<p>We haven’t seen this number-parenthesis notation in assembly yet, so in case<br>you’re not familiar with x86 assembly, it’s just a way to add a number to the<br>contents of a register, then treating it as a pointer and dereferencing it. So<br><code>4(%esp)</code> in assembly is the same as <code>*(esp + 4)</code> in C. So at this point, <code>%eax</code><br>holds the <code>struct context **old</code> pointer, and <code>%edx</code> holds the<br><code>struct context *new</code> pointer.</p>
<p>Now it’s time to save all the fields in a <code>struct context</code> on the stack. The<br>stack grows from high addresses to low ones, but C <code>structs</code> expect their fields<br>to be from low to high, so we’ll save them in reverse order. Oh, and hang on –<br>remember what’s at the bottom of the stack right now, after the arguments?<br>That’s right, a return address. That’s just a saved <code>%eip</code>, so that one’s<br>already done for us! We just need to save the others.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    pushl   %ebp</span><br><span class="line">    pushl   %ebx</span><br><span class="line">    pushl   %esi</span><br><span class="line">    pushl   %edi</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Next we have to save a pointer to this old <code>struct context</code> into <code>*old</code>. Well,<br>we pushed them on the stack in reverse order, right? So <code>%esp</code> already <em>is</em><br>pointing to it, so that’s our pointer; we’ll just copy it into <code>*old</code> (remember<br>it’s stored in <code>%eax</code>, and we dereference it in assembly with parentheses).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    movl    %esp, (%eax)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Now it’s time to switch stacks to the <code>new</code> context, which we saved in <code>%edx</code>.<br>That context must have been saved by a previous call to <code>swtch()</code>, so it also<br>happens to be a stack pointer as well.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    movl    %edx, %esp</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>At this point, we’re using the stack from <code>new</code>, which will already have its<br>saved context at the top. So we can load the new context by popping it off the<br>stack in reverse order into the corresponding registers. And again, just like<br>the <code>call</code> instruction had already saved <code>%eip</code> on the stack as the return<br>address, the <code>ret</code> (return) instruction will pop it off and restore it into<br><code>%eip</code> for us.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    popl    %edi</span><br><span class="line">    popl    %esi</span><br><span class="line">    popl    %ebx</span><br><span class="line">    popl    %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>And that’s it! That’s a context switch in xv6.</p>
<h2 id="proc-c-1"><a href="#proc-c-1" class="headerlink" title="proc.c"></a>proc.c</h2><p>And now, finally, we can look at the scheduling code. Once the kernel is done<br>setting itself up, initializing all the devices and drivers, etc., the very last<br>function that <code>main()</code> calls is <code>scheduler()</code>. Interrupts were disabled in the<br>boot loader and haven’t been enabled yet, so it’s also the scheduler’s job to<br>enable them for the first time in xv6.</p>
<p><code>scheduler()</code> never returns; it’s an infinite loop that just keeps searching<br>through the process table for a <code>RUNNABLE</code> process, then runs it. So from that<br>point on, with the exception of interrupts and system calls, the kernel will<br>only ever do one thing: schedule processes to run.</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>A CPU that’s running the scheduler isn’t running its own process. So we’ll start<br>off by setting this CPU’s process pointer to null. Note that <code>mycpu()</code> requires<br>interrupts to be disabled before it’s called, but that’s okay here because<br>interrupts were disabled in the boot loader and haven’t been re-enabled before<br>the scheduler is called.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">    c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The order of the next few steps is tricky, and the authors of xv6 had to be<br>extremely careful to do them in the right order to avoid concurrency problems.<br>We need to (1) re-enable interrupts, (2) acquire the process table’s lock, and<br>(3) create an infinite loop to iterate over the process table forever, scheduling<br>processes along the way. To see why this is nontrivial, let’s check out some<br>different orders (with a <code>fake_scheduler()</code> function) and see what problems we<br>get.</p>
<p>ATTEMPT #1: interrupts -&gt; lock -&gt; loop. Let’s try it out.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fake_scheduler1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sti();                  <span class="comment">// enable interrupts</span></span><br><span class="line">    acquire(&amp;ptable.lock);  <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              <span class="comment">// infinite scheduling loop</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interrupts have been disabled since the boot loader used <code>cli</code>, so when we call<br><code>sti()</code> here they’ll be turned on for the first time in the kernel. At that<br>point we’ll find out if there were any interrupts waiting to be acknowledged,<br>and possibly jump into some handler function to take care of it. Then when<br>that’s done, we’ll come back here and acquire the process table’s lock. Acquiring<br>a lock disables interrupts, remember? So they’re disabled again in the infinite<br>scheduling loop (but not forever; we’ll release the lock before switching to a<br>user process). That sounds okay, right?</p>
<p>Not so fast! There’s a hidden problem: suppose we had a situation in which none<br>of the current processes are <code>RUNNABLE</code> – maybe they’re all blocked (or<br><code>SLEEPING</code>) waiting for I&#x2F;O or something, which is not unlikely. In that case,<br>the scheduler would just keep idly looping through the process table until one<br>of them becomes <code>RUNNABLE</code> again. But if interrupts are always disabled in the<br>loop, then this processor will never find out about, e.g., a disk interrupt<br>saying it’s done reading data which would allow a blocked process to become<br><code>RUNNABLE</code>. That means the process will never find out the condition it’s<br>waiting for has already happened, which means the scheduler will never find any<br><code>RUNNABLE</code> processes. It’ll just get stuck in an infinite loop, repeatedly and<br>desperately searching every entry of the process table. So basically, the<br>system would freeze while the CPU pointlessly spins at top speed.</p>
<p>Okay okay, so that doesn’t work. We’ll have to periodically re-enable interrupts<br>before disabling them again. So let’s try moving the call to <code>sti()</code> inside the<br>infinite loop so interrupts get re-enabled every once in a while.</p>
<p>ATTEMPT #2: lock -&gt; loop -&gt; interrupts.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fake_scheduler2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;ptable.lock);  <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              <span class="comment">// infinite scheduling loop</span></span><br><span class="line">        sti();              <span class="comment">// temporarily enable interrupts</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Problem solved, right? Actually… this one turns out to be just as bad. The<br>call to <code>acquire()</code> disables interrupts, only for <code>sti()</code> to enable them again.<br>There’s a reason that locks disable interrupts, remember? If an interrupt occurs<br>that switches away from <code>scheduler()</code>, then it might call a handler function<br>that needs to access the process table lock, which is already held by<br><code>scheduler()</code>, so that function would spin forever in a deadlock.</p>
<p>So now we arrive at the correct order: we’ll call <em>both</em> <code>sti()</code> and <code>acquire()</code><br>inside the loop, in that order. That means we’ll also need a call to <code>release()</code><br>at the end of the loop before we try to <code>acquire()</code> again in the next iteration.<br>We had already said we’d have to release the lock before running a process; now<br>we’ll have to acquire it again before context-switching back into the loop.</p>
<p>ATTEMPT #3 (the right one): loop -&gt; interrupts -&gt; lock. This will give us a<br>chance to detect any outstanding interrupts in each iteration of the for loop,<br>but before we’ve acquired the lock again and thus, before doing so could cause a<br>deadlock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        sti();</span><br><span class="line">        acquire(&amp;ptable.lock);</span><br><span class="line">        <span class="comment">// ... pick a process and run it ...</span></span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Whew, okay. Basically, we’ve learned that concurrency bugs can be hard to predict<br>and can turn seemingly-fine code into impossible-to-diagnose system crashes or<br>freezes.</p>
<p>Okay, so now let’s fill in the part of the loop where the scheduling algorithm<br>goes. We’ll add an inner for loop to iterate over the process table entries<br>and stop when we find a <code>RUNNABLE</code> process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state != RUNNABLE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... run that process ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, if we found a process, then we need to switch to that process’s virtual<br>address space; that is, we need to start using its page directory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            c-&gt;proc = p;</span><br><span class="line">            switchuvm(p);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if we just switched to an arbitrary page directory in the middle of running<br>other code, we might cause a bunch of problems: all the virtual addresses we’re<br>currently using for variables, functions, instructions, etc. might suddenly<br>become invalid and point to random other places in memory. But this is where can<br>see some of the earlier design decisions in xv6 start to pay off: remember how<br><code>setupkvm()</code> made sure every single process would have the exact same mappings<br>for the upper half of the address space, starting at <code>KERNBASE</code>? That means that<br>if we’re running in kernel mode, we can arbitrarily switch to any process’s page<br>directory and know that all of our mappings will be exactly the same. The user<br>mappings in the lower half might be different, but the kernel side will never<br>change. Nice!</p>
<p>Now we can run the process using <code>swtch()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            p-&gt;state = RUNNING;</span><br><span class="line">            swtch(&amp;(c-&gt;scheduler), p-&gt;context);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swtch()</code> will <em>not</em> return here immediately; instead, it’ll pick up execution<br>wherever the process last left off, which will be in kernel mode – if it<br>stopped running before, it must have been due to a system call, interrupt, or<br>exception, which would have been handled in kernel mode before calling the<br>scheduler.</p>
<p>Note that this process will still be holding the process table lock when it<br>starts running again. For example, that’s the main reason for the existence of<br>the <code>forkret()</code> function we mentioned before. This is another dangerous detail<br>we’ll have to remember, so I’m just gonna go ahead and hope you remember THIS<br>BIG GIANT GLARING WARNING FLAG RIGHT HERE: if you do any xv6 kernel hacking, and<br>you want to add a new system call that will let go of the CPU, then your code<br><em>must</em> release the process table lock at the point at which it starts executing<br>after switching to it from the scheduler.</p>
<p>This is pretty dangerous; if xv6 were a big project, it would be really easy to<br>forget that when adding more features later on. But in this case, there’s no<br>easy way to get around it; for example, we can’t just release the process table<br>lock before calling <code>swtch()</code> and reacquire it after. The problem becomes<br>apparent if you think of locks as protecting some invariant; that invariant<br>might be temporarily violated while you hold the lock, but it should be restored<br>before the lock is released.</p>
<p>The process table protects invariants related to the process’s <code>p-&gt;state</code> and<br><code>p-&gt;context</code> fields, e.g. that the CPU registers must hold the process’s<br>register values, that a <code>RUNNABLE</code> process must be able to be run by any idle<br>CPU’s scheduler, etc. These don’t hold true while executing in <code>swtch()</code>, so we<br>need to hold the lock then; otherwise another CPU might decide to run the<br>process before <code>swtch()</code> is done executing.</p>
<p>Now, at some point that process will be done running and will give up the CPU<br>again. Before it switches back into the scheduler, it has to acquire the process<br>table lock again. So here’s ONE MORE GIANT WARNING for good measure: you should<br>make sure to do that too if you add your own scheduling-related system call.</p>
<p>Eventually, it’ll switch back here with a call with the arguments in reverse,<br>like <code>swtch(&amp;(p-&gt;context), c-&gt;scheduler)</code>. At the point, execution of the<br>scheduler will resume right here, so we need to switch back to using the kernel<br>page directory <code>kpgdir</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            switchkvm();</span><br><span class="line">            c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After that, the outer for loop just releases the lock before looping to the top<br>again to temporarily re-enable interrupts, then acquire the lock again and check<br>for another process to run.</p>
<h3 id="forkret"><a href="#forkret" class="headerlink" title="forkret"></a>forkret</h3><p>Let’s take a quick look at one example of where a process might start to execute<br>after being scheduled. All processes (whether the very first process, or any<br>others created later through calls to <code>fork()</code>) will start running code in<br><code>forkret()</code>, then return from here into <code>trapret()</code>.</p>
<p>Most of the time, this function does just one thing: it releases the process<br>table lock. However, there are two kernel initialization functions that have to<br>be run from user mode, so we can’t just call them from <code>main()</code> and be done with<br>it. We need a place for a process to call them, and <code>forkret()</code> is as good a<br>place as any. So the very first call to <code>forkret()</code> will run these two start-up<br>functions, and the rest will ignore them.</p>
<p>The two functions are <code>iinit()</code> and <code>initlog()</code>, which are part of xv6’s file<br>system code; we’ll get to them later on. For now, we’ll just use a <code>static int</code><br>as a boolean and set it to false after we’ve run those functions once on our<br>first pass through <code>forkret()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only gets run once, on the first call</span></span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        iinit(ROOTDEV);</span><br><span class="line">        initlog(ROOTDEV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Returns into `trapret()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Any other kernel code that switches into the scheduler (e.g., <code>sleep()</code> and<br><code>yield()</code>) will have a similar lock release right after returning from<br>the scheduler.</p>
<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>We saw one example of code that runs after switching <em>away</em> from the scheduler,<br>but what about code that runs before switching <em>to</em> the scheduler? Any functions<br>that need to call into the scheduler can’t just call <code>scheduler()</code>, since the<br>scheduler probably left off last time halfway through the loop and should resume<br>in the same place. So <code>sched()</code> handles the task of picking up the scheduler<br>wherever it last left off.</p>
<p><code>sched()</code> should be called <em>after</em> acquiring the process table lock and without<br>holding any other locks (lest we cause a deadlock somewhere). Also, the process<br>should not be in the <code>RUNNING</code> state anymore since we’re about to stop running<br>it. So we’ll start off by checking that those are all true and that interrupts<br>are disabled.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!holding(&amp;ptable.lock)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched ptable.lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli != <span class="number">1</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state == RUNNING) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, remember when the <code>pushcli()</code> and <code>popcli()</code> functions checked whether<br>interrupts were enabled before turning them off while holding a lock? That’s<br>really a property of this kernel thread, not of this CPU, so we need to save<br>that now. Then we can call <code>swtch()</code> to pick up where the scheduler left off<br>(the line right after its own call to <code>swtch()</code>). This process will resume<br>executing after that line eventually, at which point we’ll restore the data<br>about whether interrupts were enabled and let it run again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save whether interrupts were enabled before acquiring the lock</span></span><br><span class="line">    <span class="type">int</span> intena = mycpu()-&gt;intena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform context switch into the scheduler</span></span><br><span class="line">    swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler);</span><br><span class="line">    <span class="comment">// Execution will eventually resume here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore whether interrupts were enabled before</span></span><br><span class="line">    mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>Okay, let’s see an example of how this all comes together now! The <code>yield()</code><br>function forces a process to give up the CPU for one scheduling round. For<br>example, this will be used to handle timer interrupts later on. Now that we know<br>how scheduling works in xv6, <code>yield()</code> is easy. We just acquire the process<br>table lock, set the current process’s state to <code>RUNNABLE</code> so it can get picked<br>up again in the next scheduling round, and call <code>sched()</code> to switch into the<br>scheduler. When we eventually return here, we’ll just release the lock again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    myproc()-&gt;state = RUNNABLE;</span><br><span class="line">    sched();</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h2><p>We’ve now seen how xv6 handles process scheduling with a super-simple round-<br>robin algorithm. The <code>scheduler()</code> function had plenty of concurrency pitfalls,<br>but luckily the xv6 authors took care of all the careful coding for us, so we<br>just get to sit back and admire their work.</p>
<p>We also saw how context switches occur in xv6, so now we can understand how, in<br>the previous post, <code>allocproc()</code> set up a new process with a context that would<br>result in it starting execution in <code>forkret()</code>.</p>
<p>Next up, we’ll look at the way xv6 handles interrupts, system calls, and software<br>exceptions.</p>
<h1 id="It’s-a-Trap"><a href="#It’s-a-Trap" class="headerlink" title="It’s a Trap!"></a>It’s a Trap!</h1><p>The last post introduced the mechanisms that xv6 uses for scheduling and context<br>switches. User processes can transfer control to kernel code with system calls,<br>potentially switching into the scheduler with <code>sleep()</code> or <code>exit()</code> to find<br>another process to run. But there are many other system calls besides those two<br>Kernel code can also be invoked during hardware interrupts or software<br>exceptions; these three together are collectively referred to as traps.</p>
<p>We’ll go over traps now to understand them more generally. First, about the<br>terminology: depending on the source, interrupts might mean hardware interrupts<br>specifically or any trap generally; similarly, exceptions might mean errors<br>arising from the code, or traps in general. It’s super frustrating because it<br>makes it really hard to know what’s meant by a word like “interrupt” or<br>“exception” in whatever specification or source you happen to be reading. So I’m<br>gonna try my best to save you that kind of pain in this post by sticking to<br>“interrupt” for the hardware interrupts only, “exception” for software errors,<br>and “trap” for those two combined with system calls.</p>
<h2 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h2><p>Imagine if, after every single time some user code carried out a division, the<br>processor stopped, context switched into the kernel, and asked the kernel to<br>check if there was a division by zero and handle it if necessary. Or every time<br>a hardware interrupt happened, the kernel had to start polling all the devices<br>to figure out which one just yelled. No. Just no. Running kernel code for all<br>this would be way too slow.</p>
<p>So it’s the processor that will have to detect traps and decide how to handle<br>them. But what exactly it should do for a specific trap depends on all kinds of<br>of particulars about that OS, e.g. a disk saying it’s done reading from a file<br>might require updating some file system data or storing the disk data in a<br>specific buffer or something. That’s too much responsibility for the processor.</p>
<p>Okay, so the kernel will set up a bunch of handler functions for every possible<br>type of trap. Then it tells the hardware, “Okay, so if you get a disk interrupt,<br>here are my instructions to handle that. For timer interrupts, use these<br>instructions. If a process tries to access an invalid page, do this…”<br>From then on, the processor can handle the traps without further input from the<br>kernel by looking up the interrupt number in a big table to get the trap handler<br>function that the kernel set up, then just running it.</p>
<p>In the x86 architecture, that table is called the <em>interrupt descriptor table</em><br>or IDT. I know, I’m sorry, I promised I’d say “trap” for the general case, but<br>the x86 specs give it the official name of IDT even though it handles all the<br>traps. Sigh. It has 256 entries (so that’s the maximum number of distinct traps<br>we can define); each one specifies a segment descriptor (ugh segmentation again,<br>you know what that means: opaque code) and an instruction pointer (<code>%eip</code>) that<br>tell the processor where it can find the corresponding trap handler<br>function.</p>
<p>xv6 won’t use all 256 entries; it’ll mostly use trap numbers 0-31 (software<br>exceptions), 32-63 (hardware interrupts), and 64 (system calls), all defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/traps.h">traps.h</a>.<br>But we do have to stick all 256 in the IDT anway, so we’re the unlucky fools who<br>get to write 256 functions’ worth of assembly code by hand. Nah, just kidding:<br>xv6 uses a script in a high-level language to do that for us and spit out the<br>entries into an assembly file.</p>
<p>Unfortunately for us, that high-level language is Perl. Sigh. Perl is infamous<br>as a “write-only” language, so I guess instead we’re just the unlucky fools who<br>get to try reading Perl.</p>
<h2 id="vectors-pl"><a href="#vectors-pl" class="headerlink" title="vectors.pl"></a>vectors.pl</h2><p>Okay, I’m not gonna assume you know Perl, and either way I really don’t wanna go<br>over every single line of this file. The syntax is similar enough to C’s (except<br>that somehow they managed to make it even <em>worse</em> than C), so you can read it on<br>your own if you want.</p>
<p>Now, no script will be able to generate 256 completely unique assembly functions<br>with enough detail to handle each trap correctly, so each function in the script<br>has to be pretty generic. They’re all gonna call the same assembly helper<br>function, which will call a C function where we can more comfortably code up<br>how to handle each interrupt.</p>
<p>The gist of this Perl script is that it prints a bunch of stuff using a for loop<br>with 256 iterations. The xv6<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a><br>will run it from the command line with <code>./vectors.pl &gt; vectors.S</code> so that the<br>output gets saved in an assembly file, which will then get assembled together<br>with all the other kernel code in <code>OBJS</code>.</p>
<p>The resulting assembly file will look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line"></span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $0</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line">.globl vector1</span><br><span class="line">vector1:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $1</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line">.globl vector2</span><br><span class="line">vector2:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $2</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Except that a handful of entries (8, 10 through 14, and 17) will skip one line<br>(I’ll explain why below):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.globl vector8</span><br><span class="line">vector8:</span><br><span class="line">    pushl   $8</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Then at the end, it defines an array <code>vectors</code> with each of those entries above:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.globl vectors</span><br><span class="line"></span><br><span class="line">vectors:</span><br><span class="line">    .long vector0</span><br><span class="line">    .long vector1</span><br><span class="line">    .long vector2</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Okay, so those are all the handler functions; the <code>vectors</code> array holds a<br>pointer to each one. They’re all more or less the same: most of them push zero<br>onto the stack, then all they push a <em>trap number</em> to indicate which trap<br>just happened, and then they jump to a point in the code called <code>alltraps</code>;<br>that’s the assembly helper function I mentioned earlier.</p>
<p>A handful of the entries don’t push zero on the stack: these are trap numbers<br>8 (a double fault, which happens when the processor encounters an error while<br>handling another trap), 10 (an invalid task state segment), 11 (segment<br>not present), 12 (a stack exception), 13 (a general protection fault), 14 (a<br>page fault), and 17 (an alignment check). These are special because the<br>processor will actually push an error code on the stack before calling into the<br>corresponding handler function in <code>vectors</code>. It doesn’t push any error codes on<br>the stack for the others, so we just push 0 ourselves to make them all match up.</p>
<h2 id="trapasm-S"><a href="#trapasm-S" class="headerlink" title="trapasm.S"></a>trapasm.S</h2><h3 id="alltraps"><a href="#alltraps" class="headerlink" title="alltraps"></a>alltraps</h3><p>The processor needs to run the trap handler in kernel mode, which means we have<br>to save some state for the process that’s currently running so we can return to<br>it later (similar to the <code>struct context</code> we saw before), then set things up to<br>run in kernel mode. The <code>alltraps</code> routine does just that.</p>
<p>Remember how we said the IDT holds segment selectors for <code>%cs</code> and <code>%ss</code>, plus<br>and instruction pointer <code>%eip</code>? (I know we haven’t seen the code to create the<br>IDT and store the entries of <code>vectors</code> in it yet; we’ll get to that below.) The<br>processor will start using those segments (and save the old ones) before running<br>the trap handler function. Each trap handler function in <code>vectors</code> above pushed<br>an error code (or 0) followed by a trap number. Now we have to push all the<br>other segment selectors on the stack one at a time, then push all the general-<br>purpose registers at once with the x86 instruction <code>pushal</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line">alltraps:</span><br><span class="line">    pushl   %ds</span><br><span class="line">    pushl   %es</span><br><span class="line">    pushl   %fs</span><br><span class="line">    pushl   %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Cool, all the registers are saved now. So now we’ll set up the <code>%ds</code> and <code>%es</code><br>registers for kernel mode (<code>%cs</code> and <code>%ss</code> were already done by the processor).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">movw    $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class="line">movw    %ax, %ds</span><br><span class="line">movw    %ax, %es</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Now we’re ready to call the C function <code>trap()</code> that’s gonna do most of the<br>work. That function expects a single argument: a pointer to the process’s saved<br>register contents. Well, we just pushed them all on the stack, so we can just<br>use <code>%esp</code> as that pointer.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">pushl   %esp</span><br><span class="line">call    trap</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>That function will return back here when it’s done, so let’s ignore the return<br>value by moving the stack pointer just above it (essentially popping it off the<br>stack).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">addl    $4, %esp</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<h3 id="trapret"><a href="#trapret" class="headerlink" title="trapret"></a>trapret</h3><p>We’ve talked about this function before; when we create a new process, it starts<br>executing in <code>forkret()</code>, which then returns into <code>trapret()</code>. More generally,<br>any call to <code>trap()</code> will return here as well.</p>
<p>This function just restores everything back to where it was before, popping<br>stored registers off the stack in reverse order. We can skip the trap number and<br>error code; we won’t need them anymore. Then we use the <code>iret</code> or “interrupt<br>return” (though you should read that as “trap return”) instruction to close out,<br>return to user mode, and start executing the process’s instructions again.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl trapret</span><br><span class="line">trapret:</span><br><span class="line">    popal</span><br><span class="line">    popl    %gs</span><br><span class="line">    popl    %fs</span><br><span class="line">    popl    %es</span><br><span class="line">    popl    %ds</span><br><span class="line">    addl    $0x8, %esp  # skip the trap number and error code</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>

<h2 id="trap-c"><a href="#trap-c" class="headerlink" title="trap.c"></a>trap.c</h2><p>Okay, on to the main part of the code! We have to do two things here: stick the<br>trap handler functions in <code>vectors</code> into an IDT, and figure out what to do with<br>each interrupt type.</p>
<p>At the top, we’ve got four global variables. The IDT is represented as an array<br>of <code>struct gatedesc</code>s, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>. It’s worth<br>taking a look at because it uses an obscure C feature (bit fields); we’ll do that<br>in the next section.</p>
<p>Then we declare the <code>vectors</code> array of trap handler (with an <code>extern</code> keyword,<br>since it’s defined in an assembly file), a global counter <code>ticks</code> that tracks<br>the number of timer interrupts so far (basically a rough timer), and a lock to<br>use with <code>ticks</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256];</span></span><br><span class="line"><span class="keyword">extern</span> uint vectors[];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">tickslock</span>;</span></span><br><span class="line">uint ticks;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="Bit-Fields"><a href="#Bit-Fields" class="headerlink" title="Bit Fields"></a>Bit Fields</h3><p>This section will get <em>deep</em> into the weeds, so feel free to skip it if you’re<br>having a nice day and don’t want to spoil it by reading about a bunch of C<br>standards.</p>
<p>So far, we’ve used bit flags with regular integers by manually doing some bit<br>arithmetic to set one bit at a time. For example, the flags for page table and<br>page directory entries are defined as powers of 2 (e.g., <code>PTE_P</code> is 0x1, <code>PTE_W</code><br>is 0x2, <code>PTE_U</code> is 0x4, etc.) so that we can set a specific bit using a bitwise-<br>OR like <code>pte |= PTE_U</code> or test whether it’s set with a bitwise-AND like<br><code>pte &amp; PTE_P</code>.</p>
<p>But sometimes that can get annoying and hard to keep track of; wouldn’t it be<br>nice if we could just have variables that represent a single bit? Or two bits,<br>or any number of bits we want?</p>
<p>The trouble is that most computer architectures don’t work with a single bit at<br>a time; they operate on bytes, words (2 bytes), long&#x2F;double words (4 bytes), or<br>quad words (8 bytes), so it would be nontrivial to compile a line of C like<br><code>a = 1</code> if <code>a</code> is a nonstandard size.</p>
<p>In fact, accessing variables that aren’t aligned to a standard size (4 bytes on<br>x86 or 8 bytes on x86_64) is much slower than when they are aligned. Compilers<br>often optimize code to correct for this by padding <code>struct</code>s so that they’ll<br>line up along those standard sizes. For example, one like</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nopadding</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>is probably left the same on x86, but one like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>is probably converted by the compiler into this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> pad0[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">char</span> pad1[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>WARNING: We’re entering the dark arts of C’s unspecified and implementation-<br>defined behavior here. Note that these are different from <em>undefined</em> behavior:<br>undefined behavior means you did something BAD BAD BAD like dereferencing a null<br>pointer, freeing a memory region twice, using a variable after freeing it,<br>accessing an out-of-bounds index in a buffer, or overflowing a signed data type.<br>Implementation-defined and unspecified behavior aren’t as dangerous as undefined<br>behavior is, but they can cause portability issues.</p>
<p>The C standard is a huge document with a bunch of legalese rules about what<br>makes C, well, C. People who write C compilers need to know exactly how C code<br>should behave under all kinds of different circumstances, so the C standard<br>spells most of it out. But there are some parts it intentionally leaves out.</p>
<p><em>Implementation-defined</em> behavior means the C standard doesn’t set any fixed<br>requirements about how a compiler should handle some behavior or feature; the<br>developers of a C compiler get to decide how to write that part of the code with<br>total freedom. One example is the number of bits in a byte; we’ve been assuming<br>it’s 8, but there are some (dumb) architectures where it’s different.</p>
<p><em>Unspecified behavior</em>, on the other hand, means that the C Standard provides<br>some specific options, and compiler developers have to choose from those options<br>for <em>each instance</em> of the behavior in the code they’re compiling (that means,<br>don’t assume it’s always gonna be the same, even with the same compiler).</p>
<p>Structure padding is implementation-defined, and there are often implementation-<br>defined ways to modify it or disable it altogether (i.e., to <em>pack</em> the <code>struct</code><br>instead of <em>padding</em> it), usually with stuff like <code>__attribute__</code>s or <code>#pragma</code><br>directives for the preprocessor.</p>
<p>Wait weren’t we gonna talk about bit manipulation? Why are we talking about<br><code>struct</code>s? Well, C does have a workaround to make bit manipulation a little<br>easier by avoiding that slightly-annoying bit arithmetic you have to do to set<br>or clear flags in an <code>int</code> or <code>unsigned int</code>: it’s called a <em>bit field</em>, and it<br>takes advantage of <code>struct</code> padding.</p>
<p>You can specify the number of bits that a field of a <code>struct</code> should occupy by<br>adding a colon and a size after the field name:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfield_example</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This way, you can set the single-bit flag <code>a</code> with simple variable assignments<br>like <code>var.a = 1</code>, and the compiler will figure out any necessary magic similar<br>to structure padding to make that happen. Awesome, right? So why haven’t we been<br>using it all the time instead of all that opaque bit arithmetic with arcane<br>operators like <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>|</code>, and <code>&amp;</code>?</p>
<p>Well, there are some big downsides to bit fields. First, the C standard sets<br>some strict rules on their use to make sure that compilers can figure out how to<br>handle them. Bit fields are only allowed inside of structures. You’re not<br>allowed to create arrays of bit fields or pointers to bit fields. Functions<br>aren’t allowed to return a bit field. You’re not allowed to get the address of a<br>bit field with the <code>&amp;</code> operator. You can only operate on a single bit field at a<br>time in any statement; that means you can’t set one bit field to equal another,<br>and you can’t compare the values of two bit fields.</p>
<p>Second, they’re <em>extremely</em> implementation-defined. Each implementation (read:<br>compiler + architecture combo) determines what data types and sizes are allowed<br>to be used in bit fields. The data types you <em>can</em> use might have different<br>signedness rules from the usual ones for signed and unsigned types. How they’re<br>laid out, ordered, and padded in memory can differ. In short: the low-level<br>details are a total black box that you can probably only figure out by reading<br><em>deep</em> into the compiler’s specifications.</p>
<p>Now imagine trying to do something that requires specific protocols like sending<br>data over a network, and you come across a bit field. Lolwut. Who knows what<br>you’d have to do. Bit fields make it impossible to port your code.</p>
<p>BUT! Bit arithmetic is annoying, so let’s use bit fields anyway!</p>
<p>Okay, so back to <code>struct gatedesc</code>. IDT entries have to contain a 16-bit code<br>segment selector (<code>%cs</code>), 16 low bits and 16 high bits for an offset in that<br>segment, the number of arguments for the handler function, a type, a system&#x2F;<br>application flag, a descriptor privilege level (0 for kernel, 3 for user), and a<br>“present” flag. And x86 is very particular about how it’s all laid out, so we<br>have to set up <code>struct gatedesc</code> in the exact right order.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    uint off_15_0 : <span class="number">16</span>;</span><br><span class="line">    uint cs : <span class="number">16</span>;</span><br><span class="line">    uint args : <span class="number">5</span>;</span><br><span class="line">    uint rsv1 : <span class="number">3</span>;</span><br><span class="line">    uint type : <span class="number">4</span>;</span><br><span class="line">    uint s : <span class="number">1</span>;</span><br><span class="line">    uint dpl : <span class="number">2</span>;</span><br><span class="line">    uint p : <span class="number">1</span>;</span><br><span class="line">    uint off_31_16 : <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Well, okay, that’s it for now.</p>
<h3 id="tvinit"><a href="#tvinit" class="headerlink" title="tvinit"></a>tvinit</h3><p>This function loads all the assembly trap handler functions in <code>vectors</code> into<br>the IDT. The <code>SETGATE()</code> macro in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> will organize<br>each entry correctly. We said before that the IDT needs a code segment selector,<br>an instruction pointer (from <code>vectors</code>), and a privilege level (0 for kernel<br>mode), so we’ll stick those in.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, SEG_KCODE &lt;&lt; <span class="number">3</span>, vectors[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re basically done now, but there’s one last hiccup: user code needs to be<br>able to generate system calls, but we just set all the privilege levels so only<br>the kernel and processor can generate traps. So we’ll fix the entry for system<br>calls as a special case.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, SEG_KCODE &lt;&lt; <span class="number">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oh and while we’re at it, let’s just go ahead and initialize the lock for the<br>tick counter.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="idtinit"><a href="#idtinit" class="headerlink" title="idtinit"></a>idtinit</h3><p>The last function stored all the trap vectors in the IDT, so now we need to tell<br>the processor where to find the IDT. There’s a special assembly instruction for<br>that in x86 called <code>lidt</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idtinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lidt(idt, <span class="keyword">sizeof</span>(idt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h3><p>This last function is the one that gets called by the assembly code in <code>alltraps</code>;<br>it’s responsible for figuring out what to do based on the trap number we pushed<br>on the stack before. Heads up: it’s gonna do that by calling a bunch of other<br>functions, many of which we haven’t seen yet. I’ll just give a quick summary<br>when we come across them, and we’ll get to them later on.</p>
<p>The only argument is a pointer to a <code>struct trapframe</code>. Wait, hang on. Up above<br>in the assembly code, the argument we pushed on the stack was <code>%esp</code>, the stack<br>pointer, not a pointer to any <code>struct trapframe</code>. What’s up with that? Did we<br>pass the wrong kind of argument in?</p>
<p>Let’s check out the definition for <code>struct trapframe</code>, found in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>. It’s got a<br>bunch of fields, starting off with the general purpose registers (those are the<br>fields from <code>%edi</code> to <code>%eax</code>). Then it has four segment registers (fields <code>%gs</code><br>through <code>%ds</code>), plus some unused padding bits in between them to round the 16-<br>bit segment registers up to 32 bits. The next two fields are a trap number and<br>an error code.</p>
<p>All that should sound familiar. Take another look at<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/trapasm.S">trapasm.S</a>: so<br>far, those are the exact same things we pushed on the stack! The other fields<br>are what the processor pushed on the stack before calling the handler function<br>in the IDT. So basically, we’re never gonna construct a <code>struct trapframe</code> in C<br>code; we already constructed it manually in assembly. It just describes<br>everything that’s already on the stack by the time this <code>trap()</code> function gets<br>called. In that sense, the <code>%esp</code> we pushed as an argument really <em>is</em> a pointer<br>to a <code>struct trapframe</code>. It’s a clever way to read values off the stack.</p>
<p>So we said we’re gonna check the trap number and decide which kernel function to<br>call based on that, right? Let’s start by checking if the trap number indicates<br>this is a system call (trap number 64, or <code>T_SYSCALL</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;trapno == T_SYSCALL) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Well how should we handle system calls? xv6 will have several, and we don’t even<br>know what they all are yet. So let’s procrastinate again and just call some<br>other function <code>syscall()</code> to handle the work of figuring out which system call<br>to execute. Now we’ll store the pointer to the <code>struct trapframe</code> in that<br>process’s <code>struct proc</code>, obtained with a call to <code>myproc()</code>. Also, processes<br>need to be killed once they’re done, or if they cause an exception; that happens<br>by setting a <code>killed</code> flag in the <code>struct proc</code>. So we’ll check for that before<br>and after carrying out the system call and close the process out with <code>exit()</code><br>if it’s due to be killed.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;trapno == T_SYSCALL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        myproc()-&gt;tf = tf;</span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now we have all the other trap numbers to think about. We could do them<br>with a ton of <code>if</code> statements, but that would be a pain; we’ll use a <code>switch</code><br>statement instead. If you haven’t seen <code>switch</code> statements, they replace big<br><code>if-else</code> blocks with cases instead. The cases can only be indexed by integers,<br>and you have to stick a <code>break</code> statement at the end or else you’ll fall through<br>to the next case and execute the code found there as well. (To be honest, I<br>don’t see a reason why the system call case wasn’t just included in this same<br>switch statement; if you see a reason for that, let me know.)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// cases go here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First up is the trap number for timer interrupts; the main function of timer<br>interrupts is to schedule a new process, but that will come further down in this<br>function. For now, we’ll just increment the <code>ticks</code> counter then call <code>wakeup()</code>,<br>which checks if any processes went to sleep until the next tick; it’ll switch to<br>running any process it finds. There’s one detail to deal with here: the system<br>may have multiple processors, each with their own timer and interrupts. We want<br>to use the <code>ticks</code> counter as a rough timer, but we don’t know whether all the<br>CPU timers will be synchronized, so we’ll only update <code>ticks</code> using the first<br>CPU to avoid those issues.</p>
<p>If you read the post on interrupt controllers then you’ll be familiar with<br><code>lapiceoi()</code>; if you didn’t (or you forgot), it just tells the local interrupt<br>controller that we’ve read and acknowledged the current interrupt so it can<br>clear it and get ready for more interrupts.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">            <span class="keyword">if</span> (cpuid() == <span class="number">0</span>) &#123;</span><br><span class="line">                acquire(&amp;tickslock);</span><br><span class="line">                ticks++;</span><br><span class="line">                wakeup(&amp;ticks);</span><br><span class="line">                release(&amp;tickslock);</span><br><span class="line">            &#125;</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Later on, we’ll see some interrupt handler functions for various devices:<br><code>ideintr()</code> handles disk interrupts, <code>kbdintr()</code> for key presses and releases,<br>and <code>uartintr()</code> for serial port data. We’ll direct the corresponding interrupts<br>to those functions, then acknowledge and clear them with <code>lapiceoi()</code>. Also,<br>devices occasionally generate spurious interrupts due to hardware malfunctions;<br>we’ll either ignore them (if they’re coming from the Bochs emulator) or print a<br>message about it to the console.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_IDE:      <span class="comment">// disk interrupt</span></span><br><span class="line">            ideintr();</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_IDE + <span class="number">1</span>:  <span class="comment">// spurious Bochs disk interrupt</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_KBD:      <span class="comment">// keyboard interrupt</span></span><br><span class="line">            kbdintr();</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ + <span class="number">7</span>:             <span class="comment">// spurious interrupt-no break, FALL THROUGH</span></span><br><span class="line">        <span class="keyword">case</span> T_IRQ + IRQ_SPURIOUS:  <span class="comment">// spurious interrupt</span></span><br><span class="line">            cprintf(<span class="string">&quot;cpu%d: spurious interrupt at %x:%x\n&quot;</span>,</span><br><span class="line">                    cpuid(), tf-&gt;cs, tf-&gt;eip);</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now we’ve dealt with system calls and hardware interrupts, so any other<br>trap must be a software exception. <code>switch</code> statements allow a catch-all case<br>with <code>default</code>, so we’ll use that to catch the rest of the trap numbers. Now,<br>this may have come from a kernel error or a misbehaving user process. We can<br>check with <code>myproc()</code>, which returns a null pointer if we were running kernel<br>code or a pointer to a <code>struct proc</code> if we were in user space, or by checking<br>the current privilege level in the code segment selector. Depending on the<br>source, we’ll print out an appropriate error message and either panic (if in the<br>kernel) or mark the process so it gets killed soon.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (myproc() == <span class="number">0</span> || (tf-&gt;cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Kernel code exception</span></span><br><span class="line">                cprintf(<span class="string">&quot;unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n&quot;</span>,</span><br><span class="line">                        tf-&gt;trapno, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">                panic(<span class="string">&quot;trap&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// User process exception</span></span><br><span class="line">            cprintf(<span class="string">&quot;pid %d %s: trap %d err %d on cpu %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;eip 0x%x addr 0x%x--kill proc\n&quot;</span>,</span><br><span class="line">                    myproc()-&gt;pid, myproc()-&gt;name, tf-&gt;trapno,</span><br><span class="line">                    tf-&gt;err, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">            myproc()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The reason we don’t kill it immediately is because the process might be executing<br>some kernel code right now; for example, system calls allow other interrupts and<br>exceptions to occur while they’re being handled. Killing it now might corrupt<br>whatever it’s doing. So instead we just give it the kiss of death for now and<br>come back to finish the job later.</p>
<p>So next up, we’ll check if this trap was generated by a user process that’s due<br>to be killed, and that process is running in ring 3. If so, we finally do<br>the deed with <code>exit()</code>; otherwise if it’s running in ring 0, it’ll live for now<br>and get killed the next time it generates a trap instead.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;killed &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == DPL_USER) &#123;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Up above, the only thing a timer interrupt did was increment <code>ticks</code>. But we<br>know a really important function of timer interrupts is to force a process to<br>let go of the CPU and let someone else run. It’s time to do that. We’ll check if<br>the process’s state is <code>RUNNING</code> and the trap was a timer interrupt; if so, we<br>call <code>yield()</code> to let another process get scheduled on this CPU.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;state == RUNNING &amp;&amp;</span><br><span class="line">            tf-&gt;trapno == T_IRQ0 + IRQ_TIMER) &#123;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have one last check: a process that yielded, then got picked up again<br>later might have been marked as killed in the meantime, so if it was, we need to<br>finish it off now. So we do the exact same check as above again, and then we’re<br>done.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;killed &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == DPL_USER) &#123;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that this function will return into <code>trapret</code> in the assembly code, which<br>will then send it back to user mode.</p>
<h2 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h2><p>Let’s take a moment to assess how much of xv6 we’ve already covered. Remember,<br>the xv6 kernel has four main functions: (1) finishing the boot process that the<br>boot loader started, (2) virtualizing resources in order to isolate processes<br>from each other, (3) scheduling processes to run, and (4) interfacing<br>between user processes and hardware devices. Let’s take that as a checklist and<br>go through those items now.</p>
<p>We’ve already seen some of the initialization routines that get run on boot in<br><code>main()</code>; most of the code there sets up virtual memory and all the hardware<br>devices. We still have a few more devices to talk about: the keyboard, serial<br>port, console, and disk; each of those has its own boot function that we’ll need<br>to go over in order to wrap up point (1).</p>
<p>On the other hand, we’re already done with (2) and (3): we spent a lot of time<br>going over virtual memory and paging, and the last post on scheduling showed us<br>how xv6 virtualizes the CPU as well as it runs processes.</p>
<p>The code we saw in this post was our introduction to point (4). Traps are the<br>primary mechanism for user processes to communicate with the hardware; the<br>kernel coordinates that communication by setting up trap handler functions. The<br>code we’ve seen here basically acts like an usher, directing traps to the<br>right trap handler function depending on its type.</p>
<p>When a trap occurs (x86 instruction <code>int</code>), the processor will stop executing<br>code, find the IDT, and looks up the entry for that trap number. The script that<br>xv6 uses to generate the IDT entries just makes them all point to the same<br>function <code>alltraps()</code>, which saves all the process’s registers, switches into<br>kernel mode, and calls <code>trap()</code>. Then that function uses the trap number to<br>figure out how the kernel wants it to respond to this particular trap. So any<br>hardware interrupt, software exception, or user system call will get funneled<br>into the functions here before getting dispatched to some other appropriate<br>kernel code that will know what to do with it.</p>
<p>We haven’t finished point (4) yet, though: we have to actually see what each of<br>those trap handler functions does. But we did see some of them: for example, we<br>saw that a software exception either kills the process that caused it or panics<br>if it occurred in kernel code. That already takes care of one of the three types<br>of traps, so we’re left with hardware interrupts and system calls. All the<br>system calls got redirected to a <code>syscall()</code> function which we haven’t seen yet.</p>
<p>We have seen how some of the hardware interrupts are dealt with: a timer<br>interrupt increments a <code>ticks</code> counter (if it’s on CPU 0), then calls <code>yield()</code><br>to force a process to give up the CPU until the next scheduling round. Spurious<br>interrupts either get ignored or print a message to the console. But we’ve<br>procrastinated some of the others: disk interrupts call an <code>ideintr()</code> function<br>to handle them, keyboard interrupts call <code>kdbintr()</code>, and serial port interrupts<br>call <code>uartintr()</code>, none of which we’ve gone over.</p>
<p>So in order to wrap up the xv6 kernel, we still have to understand how system<br>calls are routed in general, as well as how devices are initialized at boot and<br>how the kernel responds to specific system calls that require use of those<br>devices. The general system call routing mechanism is up next.</p>
<h1 id="System-Calls-Routing"><a href="#System-Calls-Routing" class="headerlink" title="System Calls: Routing"></a>System Calls: Routing</h1><p>We said in the last post that system calls are the primary means for user<br>processes to request some action by the kernel; system calls mediate processes’<br>access to hardware resources.</p>
<p>If a user process wants to generate a system call, it starts a trap with the<br>trap number for system calls. Then it identifies which of the various xv6 system<br>calls it wants to do and passes any required arguments. The processor will then<br>handle the trap instruction using the code we saw in the last post. Eventually,<br>it’ll get to the <code>trap()</code> function, which will recognize the trap number as a<br>system call and pass it on to the <code>syscall()</code> function.</p>
<p><code>syscall()</code> is itself a routing function like <code>trap()</code>; it’ll figure out which<br>system call the process created and redirect it again to the appropriate kernel<br>code.</p>
<h2 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h2><p>All system calls use the same trap number: 64, or <code>T_SYSCALL</code>, but xv6 has<br>multiple system calls, so we need another number for a process to identify which<br>system call it wants to run. The convention on x86 is to use a system call<br>number which the calling process should put in the <code>%eax</code> register, which<br>usually holds return values. Then the kernel’s handler function (here,<br><code>syscall()</code>) can just check <code>%eax</code> to figure out which system call to run. The<br>system call numbers are defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/syscall.h">syscall.h</a>. There<br>you can see that, e.g. <code>SYS_fork</code> is defined as 1, <code>SYS_exit</code> is 2, and so on.</p>
<p>All the system call functions are defined in other files, so we’ll have to<br>import their declarations with the <code>extern</code> keyword:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Now we’ve got the numbers and the functions. Note that the numbers start with<br>uppercase <code>SYS_</code> and the functions start with lowercase <code>sys_</code>, so make sure<br>your kernel hacking adventures don’t do anything like <code>SYS_fork()</code>; use<br><code>sys_fork()</code> instead.</p>
<p>We’ll also need a way to map the numbers to those system call functions so that<br><code>syscall()</code> can call the right one depending on the number. We could use another<br><code>switch</code> statement like we did in <code>trap()</code>, but there are 21 system calls here,<br>so that would get pretty long; also, each number will just call the specific<br>function, unlike the different trap numbers which required different responses<br>(e.g., the timer interrupt trap number didn’t call any function at all). xv6<br>does something else this time that’s much simpler and more elegant, but it uses<br>some slightly-obscure C features, so we’ll go over it carefully.</p>
<p>Remember function pointers from way back in the boot loader? Functions are just<br>a set of instructions in order, loaded somewhere in the kernel’s code segment,<br>so C lets us use the function’s name as a pointer to the beginning of its code<br>in memory. So if we have a C function like <code>int func(char c)</code>, then <code>func</code> is<br>its function pointer. We could even assign it to a variable; that variable’s<br>type would be a pointer to a function of argument type <code>char</code> and return type<br><code>int</code>; then we could call the function using the new pointer too. Here’s an<br>example that would print “Match!” to the screen:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = func(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*func_ptr)(<span class="type">char</span>) = &amp;func;</span><br><span class="line"><span class="type">int</span> n = (*func_ptr)(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So instead of a big old <code>switch</code> statement, the <code>syscall()</code> function will use a<br>static, global array of pointers to all the system call functions we just<br>imported above. (Remember that the <code>static</code> keyword in front of a variable means<br>it always occupies the same fixed place in memory.) It’ll work because all the<br>functions have the same argument type (<code>void</code>) and return type (<code>int</code>), so their<br>pointers all have the same type and can fit inside a single array. Then we can<br>get the right function by just using the system call number to index into the<br>array of function pointers.</p>
<p>Now, we’d have to be super careful to add the function pointers into the array<br>in the right order so that the indices match up. Even worse, there is no system<br>call with number zero, so we’d have to skip that entry of the array. This could<br>get complicated. Luckily, even though humans are bad at this kind of thing,<br>computers are <em>really</em> good at it. So instead of trying to line them up by hand,<br>we can use the array notation from <code>procdump()</code> in the post on processes where<br>we specified the value of each entry of an array like this with the index in<br>square brackets, like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; [<span class="number">2</span>] <span class="number">5</span>, [<span class="number">0</span>] <span class="number">1</span>, [<span class="number">4</span>] <span class="number">-2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>The C compiler will use the indices we wrote there to figure out that the array<br>needs 5 entries (indices 0 to 4), and entry 0 is 1, entry 2 is 5, and entry 4 is<br>-2. Entries 1 and 3 will just be initialized to zero.</p>
<p>So at the end of the day, our array of pointers to system call functions looks<br>like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork]      sys_fork,</span><br><span class="line">    [SYS_exit]      sys_exit,</span><br><span class="line">    [SYS_wait]      sys_wait,</span><br><span class="line">    [SYS_pipe]      sys_pipe,</span><br><span class="line">    [SYS_read]      sys_read,</span><br><span class="line">    [SYS_kill]      sys_kill,</span><br><span class="line">    [SYS_exec]      sys_exec,</span><br><span class="line">    [SYS_fstat]     sys_fstat,</span><br><span class="line">    [SYS_chdir]     sys_chdir,</span><br><span class="line">    [SYS_dup]       sys_dup,</span><br><span class="line">    [SYS_getpid]    sys_getpid,</span><br><span class="line">    [SYS_sbrk]      sys_sbrk,</span><br><span class="line">    [SYS_sleep]     sys_sleep,</span><br><span class="line">    [SYS_uptime]    sys_uptime,</span><br><span class="line">    [SYS_open]      sys_open,</span><br><span class="line">    [SYS_write]     sys_write,</span><br><span class="line">    [SYS_mknod]     sys_mknod,</span><br><span class="line">    [SYS_unlink]    sys_unlink,</span><br><span class="line">    [SYS_link]      sys_link,</span><br><span class="line">    [SYS_mkdir]     sys_mkdir,</span><br><span class="line">    [SYS_close]     sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Okay great, now we’re ready to route system calls to the right function.</p>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>The first thing we need to do is get the system call number so we can figure out<br>which function to call. We said above that the x86 convention is to store it in<br>the <code>%eax</code> register, but we might have a problem: by the time we get to<br><code>syscall()</code>, the processor has already executed the code in the trap handler<br>function for trap number <code>T_SYSCALL</code>, which sent it to <code>alltraps()</code>, which<br>replaced all the register contents with those of <code>trap()</code>, so the system call<br>number is probably long gone from <code>%eax</code>.</p>
<p>But wait, all is not lost! <code>alltraps()</code> saved all the registers in a<br><code>struct trapframe</code> for the current process. So we can just read the value of<br><code>%eax</code> from there. Whew, that was some good forward-thinking.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> num = curproc-&gt;tf-&gt;eax;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we just need to do one more thing: call the function that corresponds to<br>that number. We’re gonna use the array of function pointers above, but we have<br>to be careful: this number was given to us by a user process. A malicious user<br>process might pass in an invalid number in the hopes of getting the kernel to<br>carry out some undefined behavior which might lead to an easy exploit. So in<br>order to keep up good security practices, the kernel should <em>always</em> distrust<br>anything originating from user code and handle it carefully, preferably with<br>three-inch-thick lead-lined gloves. So let’s think about it: what might go<br>wrong?</p>
<p>First of all, any entries that weren’t explicitly initialized above (including<br>the 0 entry) will have been automatically initialized to zero, i.e. a null<br>pointer. Also, a number that’s bigger than the highest system call number will<br>make us do an out-of-bounds read from the array, thus possibly executing some<br>arbitrary kernel code that’s stored after the array in memory. So we should<br>check that (1) the number is greater than 0, (2) it’s smaller than the number of<br>elements in the array, and (3) the entry it points to is not a null pointer.</p>
<p>Finally, the <code>%eax</code> register is usually used in x86 to store return values, so<br>we’ll put the return value of the system call function there. If any of the<br>above checks failed, we’ll just print a message to the console and return -1 to<br>indicate failure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invalid system call number</span></span><br><span class="line">        cprintf(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>, curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">        curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The system call handler function will store its return value in <code>%eax</code>; after<br>that, <code>syscall()</code> will return to the line below where it was called in <code>trap()</code>.<br>After executing the rest of the code there, <code>trap()</code> will return into <code>trapret()</code>,<br>which ends with an <code>iret</code> (interrupt return) instruction to tell the processor<br>to switch to user mode and resume executing the process’s code.</p>
<h3 id="fetchint"><a href="#fetchint" class="headerlink" title="fetchint"></a>fetchint</h3><p>Take a look at the <code>sys_</code> functions we imported above: they all have argument<br>type <code>void</code>. But if you think about it, many system calls need an argument: for<br>example, <code>open()</code> needs to know which file to open, <code>chdir()</code> needs to know<br>which directory to open, <code>kill()</code> needs a PID to know which process to kill,<br>etc. So why did we make them all have argument type <code>void</code>?</p>
<p>The trouble is that until we get the system call number in <code>syscall()</code> above, we<br>have no way of knowing which function we’ll need. And each function takes<br>arguments with different types, e.g. <code>open()</code> might need a string for the file<br>to open but <code>kill()</code> might need an integer for the PID. So there’s no way for<br>the kernel to know which arguments to expect in <code>syscall()</code>, even though the<br>arguments were already pushed on the stack. The task of recovering the arguments<br>from the stack will have to fall to each of the <code>sys_</code> functions. But let’s go<br>ahead and make their lives a little easier by setting up some nice helper<br>functions now.</p>
<p>The system call functions might take integers, strings, or pointers, so we’ll<br>need functions to fetch each of those types. <code>fetchint()</code> is one example; it<br>takes a user virtual address (an integer argument’s location in memory) and a<br>pointer to an integer where we can store the integer we find. Then it returns 0<br>if it was able to find it, or -1 if it failed.</p>
<p>Just like <code>syscall()</code> above, we need to treat anything passed from user space<br>with extreme caution. A user process that tries to read or write memory outside<br>its address space will cause a segmentation fault or page fault and be killed,<br>but the kernel has free reign over memory, so a malicious process might try to<br>trick the kernel into doing that <em>for</em> it by putting its “argument” outside of<br>the user’s address space. So we have to start by checking that the entire 4<br>bytes of the integer is inside the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchint</span><span class="params">(uint addr, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt;= curproc-&gt;sz || addr + <span class="number">4</span> &gt; curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can just cast the address to a pointer, dereference it, and store the<br>value in <code>*ip</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchint</span><span class="params">(uint addr, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *ip = *(<span class="type">int</span> *)(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we can use an address like <code>addr</code> which will be in the lower half of<br>memory because traps don’t perform a full context switch, so we’re still using<br>the process’s page directory even though we’re in kernel mode (ring 0). If we<br>had switched to a kernel page directory, we’d have to call <code>walkpgdir()</code> or<br><code>uva2ka()</code> to figure out the corresponding kernel virtual address for <code>addr</code>.</p>
<p>Now hopefully, if you’ve taken anything away from my past rants about undefined<br>behavior in C, you noticed something wrong with this function. If you didn’t,<br>take another look; I’ll wait.</p>
<p>Did you see it? We’re dereferencing <code>addr</code> without checking that it’s not null,<br>so if the user passed in a null address, we’d dereference a null pointer! We<br>also dereference <code>ip</code> without a similar check, but at the very least <code>ip</code> is<br>passed in by the kernel.</p>
<p>This could be very dangerous – in general, it’s undefined behavior in C, but<br>now that we’ve seen the code for handling traps, we’re actually at a point where<br>we can figure out what would happen in xv6 if a null pointer gets dereferenced,<br>so let’s take the opportunity to think about it for a bit.</p>
<p>First, what would happen if the kernel dereferenced a null pointer? Well, if the<br>kernel is currently using <code>kpgdir</code> as a page directory, the address 0 isn’t<br>mapped to anything, so when the paging hardware goes to figure out which physical<br>address corresponds to the kernel virtual address 0, it would fail and generate<br>a “General Protection Fault” (trap number 13, or <code>T_GPFLT</code>). That would start<br>running the trap handler code, which would eventually get to the <code>switch</code><br>statement in <code>trap()</code> (see the last post). Trap number 13 would fall under the<br><code>default</code> case, and the if statement there would recognize that it originated in<br>the kernel. So it would print an error message to the console, then panic.</p>
<p>Okay, what if we’re using a process’s page directory, e.g. during a system call?<br>Address 0 is in the lower half of memory, so it’s a user virtual address. The<br>result will depend on whether that page and its page table are mapped in the<br>process’s page directory. If they are, then dereferencing a null pointer might<br>be fine after all. But if they’re not mapped, dereferencing a null pointer will<br>cause a General Protection Fault. This time, <code>trap()</code> would print an error<br>message to the console, then mark the process to be killed.</p>
<p>Now, killing a process or causing a kernel panic might not sound like a huge<br>deal. In fact, xv6 does a great job here by killing a process that might have<br>dereferenced a null pointer or caused the kernel to do so. A kernel panic would<br>be much worse – think about how annoying it would be if that PDF you downloaded<br>from that one sketchy website installed some malware that made your kernel panic<br>all the time – the OS would become unusable. In fact, this is an example of a<br>“denial of service” vulnerability – a malicious process might not be able to<br>read or write arbitrary memory or execute arbitrary code, but it can still keep<br>you from using your machine the way you expect to.</p>
<p>Just like <code>uva2ka()</code>, this function will only get called by one other function<br>(we’ll see it soon), so it just so happens that under the current xv6 code,<br>it’ll all be okay because it should never get passed a null pointer. But<br>everything from my rant about <code>uva2ka()</code> applies here: if you add any kernel<br>code that calls this function, be <em>VERY</em> careful and add your own null checks.</p>
<p>Okay, deep breath now. &#x2F;rant.</p>
<h3 id="fetchstr"><a href="#fetchstr" class="headerlink" title="fetchstr"></a>fetchstr</h3><p>Fetching a string argument is tricky too; strings in C are just pointers to an<br>array of characters that ends in nul, i.e. <code>&#39;\0&#39;</code>, so this time we have to make<br>sure that both the pointer <em>and</em> the entire string are in the user’s address<br>space; otherwise, we could unwittingly read from some arbitrary memory location<br>and pass the data back to the user process.</p>
<p>So we’ll start by making sure the pointer itself is in a valid address:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt;= curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll store the string pointer in <code>*pp</code>. We’ll also get a pointer to the end<br>of the process’s virtual address space so we can make sure the entire string is<br>inside its bounds.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pp = (<span class="type">char</span> *) addr;</span><br><span class="line">    <span class="type">char</span> *ep = (<span class="type">char</span> *) curproc-&gt;sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>How can we check if the entire string is inside user memory? Well, a string ends<br>with a nul byte, <code>&#39;\0&#39;</code>, so we just have to start scanning the memory starting<br>from <code>*pp</code> up to <code>ep</code> until we find a zero byte. If we find one in that range,<br>then the entire string is in user memory and we can return its length to<br>indicate success; otherwise the string overflows past the end of the process’s<br>virtual address space, so we should return -1 to indicate failure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for a nul byte inside process&#x27;s address space</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> *s = *pp; s &lt; ep; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If nul byte found, return the length</span></span><br><span class="line">            <span class="keyword">return</span> s - *pp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// String is not nul-terminated inside process&#x27;s memory, so report failure</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that again, we’re dereferencing <code>pp</code> and <code>addr</code> without any null checks<br>(where <code>addr</code> is definitely the bigger concern, since it’s user-generated), and<br>again, it’s gonna work out okay (a misbehaving process will just get killed),<br>but once more: be careful if you use this function for your own kernel hacks.</p>
<h3 id="argint"><a href="#argint" class="headerlink" title="argint"></a>argint</h3><p>This is the main function that the <code>sys_</code> system call functions will use to<br>recover an integer argument; it’s basically just a wrapper for <code>fetchint()</code>. The<br>arguments are an integer <code>n</code> to say we want the nth integer argument, and a<br>pointer <code>ip</code> to store the recovered argument in. We have to call <code>fetchint()</code><br>with an address argument, so the main task now is to figure out where in memory<br>the nth integer argument should be.</p>
<p>We’re gonna have to use the x86 function call conventions again. Remember how<br>whenever we call a function in x86, its arguments get pushed onto the stack in<br>reverse order (i.e., from right to left), so that the first argument is at the<br>top of the stack (i.e., lowest memory address)? Then we push a return address<br>(<code>%eip</code>) and the old stack base pointer <code>%ebp</code>. Normally, the stack pointer<br>would just keep going on to the next slot on the callee’s stack, but in this<br>case the code in <code>alltraps()</code> saved all the registers (including the stack<br>pointer <code>%esp</code>) in a <code>struct trapframe</code> before calling <code>trap()</code> or <code>syscall()</code>.</p>
<p>That means we can recover the old value of <code>%esp</code> from the trap frame and look<br>one spots below that on the stack (i.e., 4 bytes higher in memory, since <code>int</code>s<br>are 4 bytes) to get the first (<code>n = 0</code>) argument. The second argument (<code>n = 1</code>)<br>would be 8 bytes higher than <code>%esp</code>, and so on. Pretty neat.</p>
<p>Okay, now that we’ve got that down, the code for this function is pretty<br>straightforward.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fetchint((myproc()-&gt;tf-&gt;esp) + <span class="number">4</span> + <span class="number">4</span>*n, ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="argptr"><a href="#argptr" class="headerlink" title="argptr"></a>argptr</h3><p>Some of the system call functions will have pointer arguments, so this function<br>recovers them. Pointers are 4 bytes in x86, so we can use <code>argint()</code> to get the<br>pointer itself before performing some additional checks to make sure the pointer<br>and the address it points to are valid.</p>
<p>The arguments are <code>n</code> (to retrieve the nth function argument), a pointer <code>pp</code> to<br>an address where we can store the retrieved pointer, and the size of the block<br>of memory that the retrieved pointer points to.</p>
<p>Let’s start off by just retrieving the value of the pointer as an integer using<br><code>argint()</code>; that’ll make sure that the number <code>n</code> is valid.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (argint(n, &amp;i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have to make sure that the pointer we just retrieved is itself valid,<br>i.e. that the size is nonnegative and the beginning and end of the memory block<br>it points to are both within the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (uint) i &gt;= curproc-&gt;sz || (uint) i + size &gt; curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we can store the pointer in <code>*pp</code> and return 0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pp = (<span class="type">char</span> *) i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="argstr"><a href="#argstr" class="headerlink" title="argstr"></a>argstr</h3><p>A string is just a pointer in C, so we can recover the pointer’s value using<br><code>argint()</code> again, then pass it to <code>fetchstr()</code>. The former will make sure <code>n</code> is<br>valid, and the latter will make sure the string is nul-terminated and resides<br>entirely in the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (argint(n, &amp;addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchstr(addr, pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sysproc-c"><a href="#sysproc-c" class="headerlink" title="sysproc.c"></a>sysproc.c</h2><p>So now we know how <code>syscall()</code> will route a system call trap to the right <code>sys_</code><br>function, and we’ve seen how those functions can recover arguments from the<br>process’s stack. Let’s see some examples in action; most of these will be simple<br>wrapper functions.</p>
<h3 id="sys-fork"><a href="#sys-fork" class="headerlink" title="sys_fork"></a>sys_fork</h3><p>All the hard work here is gonna be done by <code>fork()</code>, which will create a new<br>child process by cloning the parent process’s virtual address space. We don’t<br>need any arguments for this, so we’ll just call <code>fork()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-exit"><a href="#sys-exit" class="headerlink" title="sys_exit"></a>sys_exit</h3><p><code>exit()</code> closes out a process, but it puts it in the <code>ZOMBIE</code> state so that the<br>parent process can call <code>wait()</code> to find out it’s done running. <code>exit()</code> should<br>never return, so we’ll add a return value here to make the compiler happy, but<br>it should never get executed.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-wait"><a href="#sys-wait" class="headerlink" title="sys_wait"></a>sys_wait</h3><p>This system call is the parent process’s counterpart to <code>exit()</code>; it’ll do as<br>its name says and wait until the child process exits.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-kill"><a href="#sys-kill" class="headerlink" title="sys_kill"></a>sys_kill</h3><p>The <code>kill()</code> system call sounds like a more aggressive version of <code>exit()</code>:<br>after all, we’re killing another process against its will, right? But in reality<br>it would be way too complicated to do that: the process might be running on<br>another CPU, midway through updating some kernel data structure, or about to<br>wake up another process that’s asleep. Killing it by force might screw up a lot<br>of other things.</p>
<p>So instead <code>kill()</code> just tags it with the <code>killed</code> field in its <code>struct proc</code>;<br>eventually either the process will call <code>exit()</code> on its own, or it’ll generate<br>another trap, at which point the code in <code>trap()</code> will call <code>exit()</code> on it.</p>
<p><code>kill()</code> needs an integer argument: the process ID for the process we wish to<br>kill. So now we can see the payoff of writing those functions above.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;pid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kill(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-getpid"><a href="#sys-getpid" class="headerlink" title="sys_getpid"></a>sys_getpid</h3><p>The <code>getpid()</code> system call is so simple that it doesn’t even have another<br>function for this <code>sys_getpid()</code> to call. We’ll just return the PID for the<br>current process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> myproc()-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-sbrk"><a href="#sys-sbrk" class="headerlink" title="sys_sbrk"></a>sys_sbrk</h3><p>If you’re not familiar with system calls like <code>brk()</code> and <code>sbrk()</code> on Unix<br>systems, here’s what they do: they grow or shrink the virtual address space of a<br>process. <code>brk()</code> sets its new size to a specific maximum address; <code>sbrk()</code> grows<br>or shrinks the process by a certain size in bytes and returns its old size.<br>They’re mostly used to implement higher-level memory management functions like<br><code>malloc()</code>. Heh, “high-level” probably isn’t high on your mind when you think of<br>adjectives for <code>malloc()</code>, right? Anyway, xv6 only has <code>sbrk()</code>, so let’s check<br>out its <code>sys_</code> wrapper function.</p>
<p>We’ll need an integer argument (the number of bytes to grow or shrink by), so<br>let’s grab that.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can use <code>growproc()</code> from our posts on paging to grow the process by <code>n</code><br>bytes. But we want to return the old size, so we’ll have to grab that before we<br>change it with the call to <code>growproc()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> addr = myproc()-&gt;sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (growproc(n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-sleep"><a href="#sys-sleep" class="headerlink" title="sys_sleep"></a>sys_sleep</h3><p>The <code>sleep()</code> function is pretty interesting; we’ll get to the implementation<br>details later, but let’s talk about the broad strokes now. You might be familiar<br>with the <code>sleep()</code> system call in Unix systems; you pass it an integer (usually<br>in milliseconds) and it puts your process to sleep (i.e., leaves it inactive or<br>not running) for that amount of time.</p>
<p>However, <code>sleep()</code> plays a dual role in xv6: the kernel will call <code>sleep()</code> for<br>processes that need to wait while something else happens, e.g. waiting for a<br>disk to read or write data. That way the processes don’t end up idly spinning in<br>a loop or something and wasting valuable CPU time.</p>
<p>Implementing that is tricky; there’s no way to know how long it would take for<br>whatever condition the process is waiting on to be satisfied, so it’s not like<br>we can just stick in a random amount of time in the call to <code>sleep()</code> and hope<br>the condition is satisfied by then. So instead the <code>sleep()</code> function will just<br>“put a process to sleep” (read: make its state <code>SLEEPING</code> so it can’t be run by<br>the scheduler) on a <em>channel</em>, which is just an arbitrary integer. Then later on<br>the kernel can wake up any processes sleeping on that channel. So for example,<br>the kernel can put a process waiting on the disk to sleep using a specific<br>channel that’s assigned to the disk; then when the next disk interrupt occurs it<br>can wake up any processes that might be sleeping on the disk channel.</p>
<p>Okay so that’s all well and good for the kernel’s use of <code>sleep()</code>. But what<br>about the regular old <code>sleep()</code> system call? The argument is an integer that<br>represents the number of ticks to sleep for; how are we gonna turn that into a<br>channel to sleep on?</p>
<p>The answer is pretty neat (at least I think so): we’ll set the channel to the<br>address of the <code>ticks</code> counter. Remember, <code>ticks</code> is a global variable that gets<br>incremented with every timer interrupt. Go check out the code in <code>trap()</code> again:<br>each timer interrupt sends a wakeup call to any processes that might be sleeping<br>on the <code>&amp;ticks</code> channel. That should wake the process at every timer interrupt.<br>Then we’ll just stick that inside a for loop so it keeps sleeping forever until<br>the right amount of ticks have passed.</p>
<p>Let’s start by retrieving the integer argument, which is the number of ticks to<br>sleep for.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That argument <code>n</code> is a relative count, since a user process won’t necessarily<br>know how many ticks have already gone by. So let’s get the current tick count<br>before we put the process to sleep.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    uint ticks0 = ticks;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we just have to write that while loop I mentioned above to put the process<br>to sleep until <code>n</code> ticks have passed. Since we started counting at <code>ticks0</code>, the<br>condition should be satisfied when <code>ticks - ticks0 == n</code>.</p>
<p>Two more details: first, we’ll add a check inside the while loop to see if the<br>current process has been tagged to be killed; if so, we’ll just return -1 so we<br>can hasten the process’s actual death by letting it run more code so the kernel<br>will call <code>exit()</code> on it at the next trap. Second, the function <code>sleep()</code> takes<br>another argument in addition to the channel: a lock. It’ll release the lock for<br>us and reacquire it before waking up so that a sleeping process doesn’t hog a<br>lock when it doesn’t need it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (ticks - ticks0 &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            release(&amp;tickslock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-uptime"><a href="#sys-uptime" class="headerlink" title="sys_uptime"></a>sys_uptime</h3><p>The <code>uptime()</code> system call just returns the amount of ticks that have passed<br>since the system started. This is another one that’s so simple it doesn’t need<br>another function, so we’ll take care of it all here.</p>
<p>We just acquire the lock for <code>ticks</code>, get its current value, release the lock,<br>and return the value we got.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    uint xticks = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> xticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Running-System-Calls-from-User-Code"><a href="#Running-System-Calls-from-User-Code" class="headerlink" title="Running System Calls from User Code"></a>Running System Calls from User Code</h2><p>We have system calls now! Well, not quite – we still have to check out the<br>actual functions like <code>exit()</code>, <code>sleep()</code>, <code>kill()</code>, etc. Plus, we only saw the<br><code>sys_</code> wrapper functions for <em>some</em> of the system calls here; the rest are in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/sysfile.c">sysfile.c</a>, which<br>we’ll get to after we understand the xv6 file system.</p>
<p>But let’s pause for a second and think about how a user process will send a<br>system call. Like let’s say you’re writing some C code for a user program that<br>will run on xv6 and you want to create a child process with <code>fork()</code>. What<br>should you do?</p>
<p>Well, if you were coding for a Unix system like Linux or macOS, you’d just write<br>a call to <code>fork()</code> in your code. But that can’t be right in xv6, can it? After<br>all, <code>fork()</code> is a kernel function, to be run in kernel mode with a current<br>privilege level of 0. Plus, isn’t it supposed to be called by <code>sys_fork()</code>? So<br>should we call that?</p>
<p>None of these options will work. Well, yes, you do end up just calling <code>fork()</code>,<br>but it’s <em>not</em> the kernel function <code>fork()</code>, so if you’re expecting that one,<br>you’ll be surprised when it doesn’t behave the way you want it to. You won’t be<br>able to use any kernel code at all in your user program for xv6. This is a<br>mistake I’ve seen a <em>lot</em> of people make in their xv6 OSTEP projects, so bear<br>with me for a second while I explain why you can’t do it; feel free to skip the<br>next section on the Makefile if you already know why.</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>To see why, let’s check out the xv6<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a> to see<br>how xv6 is actually compiled, built, and run. There’s a ton of stuff in there,<br>but take a second to think about this: how do you usually run xv6? I bet it’s<br>a command like <code>make qemu</code> or <code>make qemu-nox</code>, right?</p>
<p>If you’re not familiar with Makefiles, here’s a quick primer: each command like<br><code>make qemu</code>, <code>make clean</code>, etc. is specified in the Makefile with a rule that<br>looks like this:</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mycmd: dependency1 dependency2 ...</span></span><br><span class="line">    build_cmd1</span><br><span class="line">    build_cmd2</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>So if I run <code>make mycmd</code>, the <code>make</code> program will check that <code>dependency1</code>,<br><code>dependency2</code>, etc. are up to date; if they’re not, it’ll update them by looking<br>up <em>their</em> rules and executing those to update them. Then it’ll execute<br><code>build_cmd1</code> on the shell, followed by <code>build_cmd2</code>, etc.</p>
<p>Okay, I know that might be confusing, so let me simply the <code>make qemu</code> command a<br>bit to make it more readable (note that I cut a lot of stuff out here, so don’t<br>try to run xv6 with what I wrote below).</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">qemu: fs.img xv6.img</span></span><br><span class="line">    qemu -drive file=fs.img,index=1 -drive file=xv6.img,index=0</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>This just says that in order to run <code>make qemu</code> when you type it on the<br>terminal, the <code>make</code> program first has to make sure that both <code>fs.img</code> and<br><code>xv6.img</code> are fully up to date. Then once they are, it can just run the shell<br>command <code>qemu</code> with the options <code>-drive file=fs.img,index=1</code> and<br><code>-drive file=xv6.img,index=0</code>. Those options are just regular flags like the<br>ones you’re probably used to with stuff like <code>ls -a</code> or <code>rm -rf</code>. In this case,<br>they tell <code>qemu</code> to use the files <code>fs.img</code> and <code>xv6.img</code> as virtual hard drives,<br>with <code>xv6.img</code> as disk number 0 and <code>fs.img</code> as disk number 1.</p>
<p>Okay, let’s check out the <code>make</code> command for <code>xv6.img</code> next.</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">xv6.img: bootblock kernel</span></span><br><span class="line">    <span class="comment"># some dd commands here</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Hey, that’s interesting, we already saw <code>bootblock</code> in a prior post. That’s the<br>one we get when we compile the boot loader. <code>kernel</code> is, well, all the kernel<br>code. The <code>dd</code> command is often used in Unix systems to format and set up disks;<br>the details aren’t important here, so I left them out for now. The point is that<br>the boot loader got compiled separately from the kernel code, remember? But<br>their machine code files get smushed into the same (virtual) disk together as<br><code>xv6.img</code>, which will be disk 0 when we run in <code>qemu</code>.</p>
<p>Not let’s check out the (slightly simplified) <code>make</code> command for <code>fs.img</code>.</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">UPROGS = cat echo forktest grep init kill ln ls <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="section">fs.img: mkfs README <span class="variable">$(UPROGS)</span></span></span><br><span class="line">    ./mkfs fs.img README <span class="variable">$(UPROGS)</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Okay, so <code>UPROGS</code> is just a list of all the user programs. Each of those gets<br>compiled separately; e.g. if you look in their source code, you’ll see each one<br>has its own <code>main()</code> function. Then the shell command says to run <code>mkfs</code> to<br>create a file system called <code>fs.img</code> with <code>README</code> and all the user programs as<br>files.</p>
<p>The point of this detour is this: the boot loader gets compiled as a single<br>unit, as does the entire kernel code. But the user programs are compiled one at<br>a time. So if you write a user program for xv6, you should add it to the list in<br><code>UPROGS</code> (as well as in <code>EXTRA</code>) and expect it to get compiled individually and<br>stuck onto the <code>fs.img</code> disk.</p>
<p>That means there’s no way for a user program to call into any kernel code; the<br>linker wouldn’t even be able to match up the call to the right function. So no<br>user program will ever be able to call functions like (the kernel’s) <code>fork()</code>.<br>Think about it: if you write a program in C and compile it to run on Linux, do<br>you expect to have to recompile the entire Linux kernel just to run your one<br>little program? No, right?</p>
<p>But certainly we can’t just expect every single program ever to be totally self-<br>contained. You also don’t have to rewrite and recompile all of <code>malloc()</code> every<br>time you write a C program. So operating systems provide libraries for users to<br>include and call in their programs. Aha! So all we need to do in order for<br>user processes to execute system calls is to provide a library. That library is<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/usys.S">usys.S</a>.</p>
<h3 id="usys-S"><a href="#usys-S" class="headerlink" title="usys.S"></a>usys.S</h3><p>Let’s trace back to the beginning of a trap. In order to execute a system call,<br>we’re supposed to send the processor an <code>int</code> instruction with a specific trap<br>number; that would be <code>int 64</code> for system calls on xv6. We’re also supposed to<br>stick the system call number in the <code>%eax</code> register. Let’s say we want to call<br><code>fork()</code>. According to<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/syscall.h">syscall.h</a>, the<br>system call number for fork is <code>SYS_fork</code>, or 1. In order to send a specific x86<br>instruction and manipulate individual registers, we’ll have to write our system<br>call library in assembly. Here’s what it would look like for the <code>fork()</code> system<br>call:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.globl fork</span><br><span class="line">fork:</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>Okay, that’s easy enough, but we have 21 of these to write, and it would be<br>pretty easy to make a mistake or write the wrong system call number. Let’s<br>automate it instead with a C preprocessor macro. We’ve seen plenty of examples<br>of defining simple constants with <code>#define</code> directives for the preprocessor, but<br>we haven’t looked at them too closely until now.</p>
<p>The C preprocessor is a piece of software that edits C (or assembly) code before<br>it’s compiled. Preprocessor directives like <code>#define A 5</code> create macros that are<br>expanded to replace every instance of <code>A</code> in the code with the number 5;<br>directives like <code>#include &quot;header.h&quot;</code> expand such that they essentially copy-<br>paste all the code in the file <code>header.h</code>. We can also create function-like<br>macros like the <code>P2V()</code> and <code>V2P()</code> macros we’ve used often by adding a<br>parameter inside parentheses; unlike functions, these will be expanded <em>before</em><br>compilation to paste the code into every instance of its use, thus avoiding the<br>usual overhead associated with a function call. Function-like macros are also<br>generic, in a sense, since they don’t require specifying parameter types or<br>return types (as long as it works within the places where the macro will be<br>used). Note that there are some drawbacks: macros aren’t type-checked, they can<br>evaluate their arguments more than once, we can’t use pointers to them like we<br>can with functions, and they can result in larger code.</p>
<p>We’re gonna use a function-like macro here to create the assembly code for each<br>system call function so that it gets expanded before the code is assembled.<br>We’ll use <code>T_SYSCALL</code> instead of 64 in the code above, and <code>SYS_fork</code> (or its<br>equivalent for each system call) for the system call number. We’ll have to<br>replace the part after the underscore in <code>SYS_</code> with the name of the system call<br>function; we can do that with the token-pasting operator <code>##</code>, which glues two<br>tokens together to form a single token. Also, macros must be defined on a single<br>line, so we’ll escape the newline characters with <code>\</code> and end each assembly line<br>with a semicolon.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line">#include &quot;traps.h&quot;</span><br><span class="line"></span><br><span class="line">#define SYSCALL(name) \</span><br><span class="line">    .globl name; \</span><br><span class="line">    name: \</span><br><span class="line">        movl    $SYS_##name, %eax; \</span><br><span class="line">        int $T_SYSCALL; \</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>Now we can just invoke the macro on the name of each function we want to create:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">SYSCALL(fork)</span><br><span class="line">SYSCALL(exit)</span><br><span class="line">SYSCALL(wait)</span><br><span class="line"># and so on ...</span><br></pre></td></tr></table></figure>

<p>After the preprocessor runs on the file, the result will look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.globl fork</span><br><span class="line">fork:</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl exit</span><br><span class="line">exit:</span><br><span class="line">    movl    $2, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl wait</span><br><span class="line">wait:</span><br><span class="line">    movl    $3, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"># and so on...</span><br></pre></td></tr></table></figure>

<p>Great! Now we have 21 functions for the system calls, all written in assembly.<br>All user programs for xv6 will be compiled together with the code for these<br>functions: see <code>ULIB</code> in the Makefile. So now, a user program can execute a<br>system call by calling these functions, e.g. <code>fork()</code>.</p>
<h2 id="Summary-9"><a href="#Summary-9" class="headerlink" title="Summary"></a>Summary</h2><p>After all the preparations are handled by the trap handler functions in the IDT,<br><code>alltraps()</code>, and <code>trap()</code>, system calls get routed to the <code>syscall()</code> function,<br>which uses a system call number to pick the right function out of an array. That<br>function will have to recover any arguments to the system call before passing it<br>on to the real system call function later on.</p>
<p>Next up, we’ll take a look at some of those system calls; we’ll leave the rest<br>until after we go over xv6’s file system.</p>
<h1 id="System-Calls-Processes"><a href="#System-Calls-Processes" class="headerlink" title="System Calls: Processes"></a>System Calls: Processes</h1><p>In a previous post, I pointed out some of the most important functions a kernel<br>has to fulfill. System calls take care of two of these: virtualizing resources<br>via virtual memory and processes, and mediating communication between user-mode<br>processes and the hardware. We’ll wrap up the former now by looking at the<br>system call functions relating to processes and scheduling.</p>
<h2 id="proc-c-2"><a href="#proc-c-2" class="headerlink" title="proc.c"></a>proc.c</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>Unlike some of the other functions we’ll talk about in this post, <code>fork()</code> is<br>used almost exclusively by user code as a system call; the kernel never calls<br>it. That said, it has an extremely important role: after the first process has<br>started, it’s the only way to create more processes. It does that by copying the<br>parent process’s virtual address space into a new page directory. We haven’t<br>talked about the file system yet, but hopefully you’re familiar with file I&#x2F;O in<br>Linux, so you know each process has its own list of open files and a current<br>working directory; <code>fork()</code> will clone those as well for the child process.</p>
<p>Let’s start off by getting a pointer to the parent process and creating a slot<br>in the process table for the child process with <code>allocproc()</code>. Remember, that<br>function returns a pointer to the new process’s <code>struct proc</code>, but it can fail<br>and return null (e.g., if there is no available slot in the process table, or if<br>its call to <code>kalloc()</code> fails), so we’ll need to check for that.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate process table slot for child process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((np = allocproc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allocproc()</code> also sets up the new process’s stack so that it’ll return into<br><code>forkret()</code>, then <code>trapret()</code>, before context switching into user mode, and sets<br>the process’s state to <code>EMBRYO</code>.</p>
<p>Next we need a page directory for the new child process; it should be a copy of<br>the parent process’s page directory. Luckily, we already did the hard work for<br>this back in the virtual memory posts, so we can just use <code>copyuvm()</code> now. That<br>function can also fail, in which case we’ll free the stack that <code>allocproc()</code><br>created and set the child process’s state back to <code>UNUSED</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((np-&gt;pgdir = copyuvm(curproc-&gt;pgdir, curproc-&gt;sz)) == <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(np-&gt;kstack);</span><br><span class="line">        np-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        np-&gt;state = UNUSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll copy the parent process’s size and trap frame; the latter will make<br>sure the child starts executing after <code>trapret()</code> with the same register<br>contents as the parent. We’ll set the child process’s parent to, well, its<br>parent (the current process).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    np-&gt;sz = curproc-&gt;sz;</span><br><span class="line">    np-&gt;parent = curproc;</span><br><span class="line">    *np-&gt;tf = *curproc-&gt;tf;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The two processes will be nearly identical, so we need a way to distiguish them<br>from user space so that a user program can give different instructions to each.<br>xv6 follows the Unix convention that <code>fork()</code> should return the child process’s<br>PID to the parent and return 0 for the child. The parent’s return value is easy;<br>we’ll just literally return the child’s PID at the end. But the child didn’t<br>actually call <code>fork()</code>, so how can we set a return value that it will see?</p>
<p>Well, the x86 convention is for return values to be passed in the <code>%eax</code><br>register, right? And that register will be restored from the trap frame before<br>switching into user mode. So we’ll just store the value 0 there.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    np-&gt;tf-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll copy all the parent process’s open files and its current working<br>current working directory. The files are stored in a per-process file array<br><code>curproc-&gt;ofile</code> of size <code>NOFILE</code>, so we can copy them over with the function<br><code>filedup()</code> (which we’ll see later). The current working directory is in<br><code>curproc-&gt;cwd</code> and can be copied with <code>idup()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NOFILE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> curproc-&gt;ofile[i]) &#123;</span><br><span class="line">            np-&gt;ofile[i] = filedup(curproc-&gt;ofile[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    np-&gt;cwd = idup(curproc-&gt;cwd);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we’ll copy the parent process’s name with <code>safestrcpy()</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>. You<br>might be familiar with the C standard library funtion <code>strncpy()</code>; this function<br>is almost identical, except that unlike <code>strncpy()</code> it’s guaranteed to nul-<br>terminate the string it copies. If you haven’t seen this kind of thing before,<br>it’s a fairly common practice to write your own safe wrappers for some of the C<br>standard library functions, especially the ones in <code>string.h</code> which are so often<br>error-prone and dangerous.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    safestrcpy(np-&gt;name, curproc-&gt;name, <span class="keyword">sizeof</span>(curproc-&gt;name));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll set the child process’s state to <code>RUNNABLE</code> and return its PID<br>for the parent.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    np-&gt;state = RUNNABLE;</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>This is one of the functions that can get called both by the kernel and as a<br>system call. The kernel will use it to terminate malicious or buggy processes,<br>and user code can use it as a system call to kill another process too.</p>
<p>We said before that killing a process immediately would present all kinds of<br>risks (e.g. corrupting any kernel data structures it might be updating, etc.),<br>so all we’re gonna do is give it the ominous mark of death with the <code>p-&gt;killed</code><br>field. Then the code in <code>trap()</code> will handle the actual murder the next time the<br>process passes through there.</p>
<p>The argument is a process ID number, so let’s just iterate over the process<br>table until we find a process with a matching PID; we’ll return -1 if we don’t<br>find any.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we do find a matching process, then we’ll set <code>p-&gt;killed</code>. Also, some of the<br>calls to <code>sleep()</code> will occur inside a while loop that checks if <code>p-&gt;killed</code> has<br>been set since the process started sleeping, so let’s hasten the process’s death<br>a little by setting its state to <code>RUNNABLE</code> so it’ll wake up and encounter those<br>checks faster. There’s no risk of screwing up by waking up a process too early,<br>since each call to <code>sleep()</code> should be in a loop that will just put it back to<br>sleep if it’s not ready to wake up yet.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">                p-&gt;state = RUNNABLE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            release(&amp;ptable.lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>The last post went over the basics of <code>sleep()</code> and <code>wakeup()</code>; they act as<br>mechanisms for <em>sequence coordination</em> or <em>conditional synchronization</em>, which<br>allows processes to communicate with each other by sleeping while waiting for<br>conditions to be fulfilled and waking up other processes when those conditions<br>are satisfied.</p>
<p>Processes can go to sleep on a channel or wake up other processes sleeping on a<br>channel. In many operating systems, this is achieved via channel queues or even<br>more complex data structures, but xv6 makes it as simple as possible by simply<br>using pointers (or equivalently, integers) as channels; the kernel can just use<br>any convenient address as a pointer for one process to sleep on while other<br>processes send a wakeup call using the same pointer.</p>
<p>This does mean that multiple processes might be sleeping on the same channel,<br>either because they are waiting for the same condition before resuming execution<br>or because two different <code>sleep()</code>&#x2F;<code>wakeup()</code> pairs accidentally used the same<br>channel. The result would be that a process might be woken up before the<br>condition it’s waiting for has been fulfilled. We can solve that problem by<br>requiring every call to <code>sleep()</code> to occur inside a loop that checks the<br>condition; that way, if a process receives a spurious wakeup call before it<br>really should have been woken up, the loop will put it right back to sleep<br>anyway. We saw one example of this in the <code>sys_sleep()</code> function, in which the<br>while loop checked if the right number of ticks had passed.</p>
<p>A common concurrency danger with conditional synchronization in any operating<br>system is the problem of missed wakeup calls: if the process that’s supposed to<br>send the wakeup call runs <em>before</em> the process that’s supposed to sleep, it’s<br>possible that the sleeping process will never be woken up again. The problem is<br>more general than just processes; it applies to devices too.</p>
<p>Imagine this scenario: a process tries to read from the disk; it’ll check<br>whether the data is ready yet and go to sleep (inside a while loop) until it is.<br>If the disk gets to run first, then the process will just find the data ready<br>and waiting for it, so it can continue on to use the data. If the process runs<br>before the disk does, then it’ll see the data isn’t ready yet and sleep in a<br>loop until it is; the disk will wake the process up once the data is ready.</p>
<p>But suppose they run at the same time, or in between each other. The process<br>does its check and finds the data isn’t ready, but before it can go to sleep, a<br>timer interrupt or some other trap goes off and the kernel switches processes.<br><em>Then</em> the disk finishes reading and starts a disk interrupt that sends a wakeup<br>call to any sleeping processes, but the process isn’t sleeping yet. When the<br>process starts running again later on, it’ll go to sleep – having already<br>missed its wakeup call.</p>
<p>The problem is that the process can get interrupted between checking the<br>condition and going to sleep, right? So why don’t we just disable interrupts<br>there with <code>pushcli()</code> and <code>popcli()</code>? add a lock there? Ah, but there’s another<br>problem: what if the disk driver is running simultaneously on another CPU?<br>Disabling interrupts on the process’s CPU wouldn’t stop the other CPU from<br>sending the disk’s wakeup call too early.</p>
<p>Okay fine, so let’s use a lock instead. The process will hold the lock while it<br>checks the condition and sleeps, and the disk driver will have to acquire the<br>lock before it can send its wakeup call… Can you see the problem here? If the<br>process holds the lock while it’s sleeping, the disk driver will never be able<br>to acquire the lock in order to wake it up. That’s a deadlock.</p>
<p>HEAD. DESK.</p>
<p>Ugh, okay, fine, you got me. So let’s use a lock, but let’s have <code>sleep()</code><br>release it right away, then reacquire it before waking up; that way the lock<br>will be free while the process is sleeping so the disk driver can acquire it.<br>Done, right? Everybody’s happy?</p>
<p>Nope. Now we’re back to the original problem: if the lock gets released inside<br><code>sleep()</code> before the process is actually sleeping, then the wakeup call might<br>happen in between those and get missed.</p>
<p>@*#&amp;@#$**&amp;@#%$!!!</p>
<p>So we need a lock. And we can’t hold the lock while sleeping, or we’d get a<br>deadlock. But we also can’t release it before sleeping, or we might miss a<br>wakeup call. So… ???</p>
<p>See, I told you: concurrency is your worst nightmare. Ever since we decided we’d<br>like our operating systems to do more than run a single basic process at a time,<br>we introduced all <em>kinds</em> of problems we have to reason through. Let’s check out<br>how xv6 actually writes the <code>sleep()</code> function and think through it ourselves<br>and try to understand if it manages to solve this problem.</p>
<p>We’ll start by making sure of two things: (1) this CPU is currently running a<br>process and not the scheduler (which can’t ever go to sleep), and (2) the caller<br>passed in a lock (which can be any arbitrary lock).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lk == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sleep without lk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to release the lock and put the process to sleep. That will require<br>modifying its state, so we should now acquire the lock for the process table.<br>But if the lock that the process is already holding <em>is</em> the process table lock,<br>then trying to acquire it again would cause a panic, so let’s add a check for<br>that; if we’re already holding it then we’ll keep using it and we don’t need to<br>release it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (lk != &amp;ptable.lock) &#123;</span><br><span class="line">        acquire(&amp;ptable.lock);</span><br><span class="line">        release(lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s nap time for this process. We just update its channel to <code>chan</code><br>and its state to <code>SLEEPING</code>, then call <code>sched()</code> to perform a context switch<br>into the scheduler so it can run a new process. We <em>have</em> to be holding the<br>process table lock before calling <code>sched()</code>, remember?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;chan = chan;</span><br><span class="line">    p-&gt;state = SLEEPING;</span><br><span class="line">    sched();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the process wakes up later on (if indeed it turns out that the code here<br>works and doesn’t miss any wakeup calls), it’ll eventually be run by the<br>scheduler, at which point it will context switch back here. So at that point<br>we’ll reset its channel and reacquire the original lock before returning.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lk != &amp;ptable.lock) &#123;</span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">        acquire(lk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, well I don’t know about you, but I’m still not convinced that this<br>implementation won’t miss any wakeup calls. After all, we release the original<br>lock before putting the process to sleep, right? We’re holding the process table<br>lock at that point, which at least means that interrupts are disabled, but the<br>process that will wake this one up might already be running on another CPU and<br>might send the wakeup signal in between releasing the original lock and<br>updating this process’s channel and state. Hmm… Well, as always, xv6 is<br>brilliant, so we’ll see how this gets solved in the code for <code>wakeup()</code>.</p>
<p>But wait! Before we move on, I have a warning for you about using this function<br>in your own code when you start hacking away at xv6. Remember that when we first<br>talked about deadlocks, we saw we can cause a deadlock if two processes acquire<br>two locks in opposite orders? If process 1 tries to acquire lock A, then lock B,<br>and process 2 simultaneously tries to acquire lock B, then lock A, then the end<br>result is that process 1 will acquire lock A and process 2 will acquire lock B,<br>but neither will be able to acquire the other lock since it’s already being held.</p>
<p>If you look at the code above, the process that called <code>sleep()</code> must have<br>already been holding a lock <code>lk</code>, then <code>sleep()</code> acquires <code>ptable.lock</code> before<br>releasing <code>lk</code>. You know what that means: there’s potential for a deadlock. So<br>in order to avoid that, you should make sure that <em>any</em> lock you pass in to<br><code>sleep()</code> must <em>always</em> get acquired before <code>ptable.lock</code>. If any other function<br>(or chain of function calls) could potentially acquire <code>ptable.lock</code> before <code>lk</code>,<br>then you might end up with a deadlock. As always, the xv6 authors have been<br>extremely careful to make sure that that never happens in the existing code, so<br>you’ll have to do the same thing for any code you add.</p>
<h3 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup"></a>wakeup</h3><p>This function is short and sweet because it procrastinates all the work it has<br>to do by pushing it off to a helper function, <code>wakeup1()</code>. It just acquires the<br>process table lock, calls <code>wakeup1()</code>, then releases the process table lock. It<br>has to grab that lock since it’s gonna modify the process’s state in the process<br>table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    wakeup1(chan);</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xv6 has to use this kind of a wrapper function for the real wakeup function<br><code>wakeup1()</code> in order to let processes that are already holding the process table<br>lock send wakeup calls too.</p>
<p>Okay, now before we go look at <code>wakeup1()</code>, let’s get back to figuring out<br>whether xv6’s implementation of <code>sleep()</code> and <code>wakeup()</code> can lead to missed<br>wakeup calls. Take a look at the code in <code>sleep()</code> again where the original lock<br>gets released – we have to acquire the process table lock <em>before</em> we can<br>release the other lock. So now there are always two locks in play whenever we<br>use <code>sleep()</code> and <code>wakeup()</code>.</p>
<p>Let’s go back to the example of a process waiting on a disk read. The process<br>acquires some disk-related lock first, then checks to see if the disk is done<br>reading; if not, it’ll call <code>sleep()</code> inside a while loop. If the disk driver<br>runs now before the process gets to call <code>sleep()</code>, that’s okay: the disk driver<br>also has to acquire the same lock before calling <code>wakeup()</code>, so the disk would<br>just end up spinning idly. Eventually, the process runs again and gets to<br>call <code>sleep()</code>; there, it will first acquire the process table lock before<br>releasing the original disk-related lock.</p>
<p>So what happens if the disk driver’s code runs now? Now the disk would be able<br>to acquire the original lock, so there’s nothing stopping it from calling<br><code>wakeup()</code>. But the very first thing it has to do there is acquire the process<br>table lock, which the process is already holding, so it just spins idly again!<br>There’s no way the disk driver could ever beat the process to acquiring this<br>second lock, because the process already held the first (disk-related) lock<br>before acquiring the second one (the process table lock). Now the process can<br>finish going to sleep and switch into the scheduler, which will eventually<br>release the process table lock. So then the disk driver can acquire it, release<br>the first lock, and finally send its wakeup call.</p>
<p>Moral of the story? There’s no way for xv6 to ever have any missed wakeup calls!<br>The trick was to use two locks, and acquire the second before releasing the<br>first. But coming up with that solution isn’t as easy as saying “oh, just use<br>two locks!” The solution only works because of the way the process table lock is<br>already being handled by so many other parts of the kernel code. For example, if<br>the context switch into the scheduler wasn’t guaranteed to release the process<br>table lock, then the disk driver in the example would never be able to acquire<br>it after the process goes to sleep, resulting in a deadlock. The solution works<br>because of all the design decisions in xv6 up to this point.</p>
<h3 id="wakeup1"><a href="#wakeup1" class="headerlink" title="wakeup1"></a>wakeup1</h3><p>Okay, I’ll stop fawning over the intricacies of xv6 concurrency management now<br>so we can look at how wakeup calls actually happen. Remember, this is a separate<br>function from <code>wakeup()</code> because sometimes the scheduler needs to send a wakeup<br>call while it’s already holding the process table lock. So we’re gonna assume<br>that every function that ever calls this is already holding it.</p>
<p>The implementation here is actually pretty simple now: we’ll just iterate over<br>the process table and set every single process that’s sleeping on channel<br><code>chan</code> to <code>RUNNABLE</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wakeup1</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">            p-&gt;state = RUNNABLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, there might be multiple processes sleeping on this channel, so this will<br>wake them all up. For some of those processes, this might be a spurious wakeup,<br>so again, we should always make sure to call <code>sleep()</code> in a loop that checks for<br>some condition to be satisfied. Even if multiple processes do have their<br>sleep conditions satisfied, they’ll have to reacquire their original lock before<br>returning out of <code>sleep()</code>, so only one of them will do so and the others will<br>spin until the first one is done.</p>
<p>Why not just wake up the first process we find that’s sleeping on <code>chan</code>? Then<br>we could avoid the extra overhead of a bunch of processes waking up, checking a<br>condition, and going back to sleep, or even spinning idly waiting to reacquire<br>the lock before returning. The issue is that the channels may not be unique, so<br>there’s no way to know which of all the sleeping processes is the one whose<br>sleep condition has just been fulfilled. If we wake up the wrong process, it’ll<br>just go back to sleep, but the right process didn’t wake up, so that means we’ve<br>lost a wakeup call.</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>Okay, so we saw above that <code>kill()</code> doesn’t really kill a process immediately;<br>it shirks that responsibility and lets <code>exit()</code> handle it instead… except<br>even <code>exit()</code> won’t really fully kill a process. Whew, a process’s death just<br>keeps getting dragged out forever, doesn’t it? It’s starting to feel like a<br>cheesy death scene in a tragedy; I bet the process is tired of suffering the<br>slings and arrows of outrageous fortune by now.</p>
<p>But it does make sense. Think about what we have to do in order to wrap up a<br>process and recycle its slot in the process table: we have to close out any open<br>files and reset its current working directory, free its kernel stack and its<br>entire page directory, then notify the parent that it’s done running.</p>
<p>The trouble comes with freeing the kernel stack and process page directory. This<br>function runs in kernel mode, so while the user stack in the lower half of<br>memory will be unused now, the kernel stack is still needed in order to keep<br>executing the instructions for <code>exit()</code>. Also, with the exception of the times<br>when it’s running the scheduling algorithm, the kernel uses the page directory<br>of the current process. The moment we free that page directory, the very next<br>memory access will be to an invalid page; the CPU would trigger an exception<br>then. That exception would eventually get routed to <code>exit()</code> again, except, oh<br>wait, we can’t even run any instructions without generating another exception,<br>because the entire page directory and stack have been freed; that’s a double<br>fault. So then the CPU would try to handle <em>that</em> exception, which would cause<br>the dreaded boogeyman of OS devs around the world: a triple fault. After a fault<br>triggers a second exception, which itself triggers a third exception, the CPU<br>just decides that the kernel in its current state doesn’t have its shit together<br>enough to keep running, so it takes over and reboots the whole system. Oops.</p>
<p>Okay, so let’s not do that. That means we can’t free the kernel stack nor the<br>page directory until we’re running on a different stack&#x2F;page directory combo.<br>That could happen in <code>scheduler()</code> while we’re using the page directory <code>kpgdir</code>,<br>or it could happen while we’re running another process. xv6 does it while it’s<br>running the parent process, in the <code>wait()</code> system call. If you haven’t used<br>that in Linux before, <code>wait()</code> lets a parent process sleep until a child process<br>is done running. xv6 will use <code>wait()</code> to finish cleaning up after an exited<br>child process too.</p>
<p>Now, the very first process that starts running in xv6 (<code>initproc</code>, which loads<br>and runs the shell) obviously has no parent process, but that’s okay because<br>that one should never exit as long as the system is up. So let’s start this<br>function off by making sure that the process that’s exiting isn’t the initial<br>process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (curproc == initproc) &#123;</span><br><span class="line">        panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll close all open files and clear the current working directory; again,<br>we haven’t seen the file system functions used here, but we’ll get to them soon.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all open files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curproc-&gt;ofile[fd]) &#123;</span><br><span class="line">            fileclose(curproc-&gt;ofile[fd]);</span><br><span class="line">            curproc-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the current working directory</span></span><br><span class="line">    begin_op();</span><br><span class="line">    iput(curproc-&gt;cwd);</span><br><span class="line">    end_op();</span><br><span class="line">    curproc-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we only have one thing left to do: notify the parent process that this<br>process has exited. If the parent process is currently sleeping in <code>wait()</code>,<br>then we’ll need to wake it up. But maybe the parent process is currently in the<br>middle of executing other code before it gets to <code>wait()</code>; we don’t want it to<br>miss the wakeup call… oh wait, but that’s okay, remember? The implementations<br>of <code>sleep()</code> and <code>wakeup()</code>&#x2F;<code>wakeup1()</code> guarantee that we can’t miss a wakeup<br>call as long as we’re holding the right lock; <code>wait()</code> will use the process<br>table lock for that. So let’s acquire it now and send a wakeup call.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    wakeup1(curproc-&gt;parent);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, remember that a sleeping process needs to check some condition in a loop;<br>how can the parent process know that the child has exited? Hmm, okay, let’s set<br>the child’s state to <code>ZOMBIE</code>. That’ll also prevent the scheduler from trying to<br>run it again.</p>
<p>Ah, but hang on a sec… what if the parent process has itself been killed, i.e.<br>the current process has been orphaned? (Again with the melodrama…) A process<br>can’t run any more user code after <code>exit()</code>, so an undead parent process would<br>never get to call <code>wait()</code> to clean up after its children. In that case, we’d<br>have to find another process that could adopt a child.</p>
<p>So let’s just solve that problem now: this process is about to shuffle off its<br>mortal coil, so let’s figure out if it has any children and pass them off to<br>another process that can keep raising them as its own. But which process is<br>guaranteed to live long enough to clean up after those children once they die?<br>Ah, <code>initproc</code>, of course! That first process is immortal, so it should be able<br>to look after any children that this process might leave behind after it makes<br>its quietus with a bare bodkin.</p>
<p>So we’ll iterate over the process table, looking for any processes with parent<br>process equal to <code>curproc</code>; if we find any, we’ll have <code>initproc</code> adopt them.<br>If any of our now-abandoned children has already exited before we did, we’ll<br>send a wakeup signal to <code>initproc</code> too in case it’s sleeping in <code>wait()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parent == curproc) &#123;</span><br><span class="line">            p-&gt;parent = initproc;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == ZOMBIE) &#123;</span><br><span class="line">                wakeup1(initproc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s finally time for this process to find out what dreams may come in<br>that sleep of death. We’ll set its state to <code>ZOMBIE</code> and context-switch into the<br>scheduler, never to return; if something goes wrong and the scheduler <em>does</em><br>return, we’ll panic in order to keep this function from returning into user code<br>again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    curproc-&gt;state = ZOMBIE;</span><br><span class="line">    sched();</span><br><span class="line"></span><br><span class="line">    panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>Like we said above, this system call lets a parent process wait for a child<br>process to exit; it also cleans up after the child process has exited.</p>
<p>First, we don’t even know if this process has any children, so we’ll have to<br>check by iterating through the process table and checking each process’s parent<br>to see if it matches the current process. If it does, then we’ll check if it’s a<br>zombie, in which case we can clean it up and return its process ID.</p>
<p>We should also deal with two edge cases: first, if the process has no children<br>at all, and second, if the process does have children but none of them are dead<br>yet. In the first case, we’ll just return -1 to report failure; in the second<br>case we’ll put the current process to sleep until one of its children exits. The<br><code>sleep()</code> call means we’ll have to do these checks inside an infinite loop.</p>
<p>Alright, let’s get started by getting the current process and acquiring the<br>process table lock, then starting an infinite loop.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inside the loop, we’ll use a variable <code>havekids</code> as a boolean to track whether<br>we’ve found any child processes. Then we can iterate over the process table,<br>skipping any processes for which the current process is not the parent. If we<br>find any children, we’ll set <code>havekids</code> to 1.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> havekids = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent != curproc) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            havekids = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we did find a child process, we should check if it’s a zombie, in which case<br>it’s time to finish its clean-up. That means freeing its kernel stack and its<br>page directory and recycling its <code>struct proc</code> so that it can be reallocated to<br>another process later on.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == ZOMBIE) &#123;</span><br><span class="line">                <span class="type">int</span> pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Free child&#x27;s kernel stack</span></span><br><span class="line">                kfree(p-&gt;kstack);</span><br><span class="line">                p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Free child&#x27;s page directory</span></span><br><span class="line">                freevm(p-&gt;pgdir);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Recycle child&#x27;s struct proc</span></span><br><span class="line">                p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">                p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">                p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">                p-&gt;state = UNUSED;</span><br><span class="line"></span><br><span class="line">                release(&amp;ptable.lock);</span><br><span class="line">                <span class="keyword">return</span> pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if <code>havekids</code> is still zero by the time we finish the for loop, that means<br>the process doesn’t have any children, so we should report failure. We’ll also<br>check if the process has been marked as killed in the meantime.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!havekids || curproc-&gt;killed) &#123;</span><br><span class="line">            release(&amp;ptable.lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, if it <em>does</em> have children, but none of them have exited yet, we’ll put<br>the process to sleep. It’ll get woken up when a child exits, at which point<br>it’ll restart the outer for loop at the top and start looking through the<br>process table again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        sleep(curproc, &amp;ptable.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-10"><a href="#Summary-10" class="headerlink" title="Summary"></a>Summary</h2><p>By now, we’ve looked at a good chunk of the system calls available in xv6. These<br>system calls wrap up the mechanisms that xv6 uses to create and exit processes<br>with <code>fork()</code>, <code>kill()</code>, <code>exit()</code>, and <code>wait()</code>, and introduced <code>sleep()</code> and<br><code>wakeup()</code> as a means for (limited) inter-process communication.</p>
<p>So what’s left now? The rest of the kernel code we’re gonna look at will just<br>focus on communicating with various hardware devices like the serial port,<br>console, and keyboard. Those drivers are relatively short, but there’s one<br>device that will require a lot more work: the disk. Storing files on disk and<br>making sure they persist across reboots require careful planning, and making<br>files conveniently accessible to users requires an entire system of abstractions<br>layered on top of each other, along with a whole host of file-related system<br>calls.</p>
<h1 id="Sleep-Locks"><a href="#Sleep-Locks" class="headerlink" title="Sleep Locks"></a>Sleep Locks</h1><p>We’ve used plenty of spin-locks, and a previous post looked at their<br>implementation in xv6. Spin-locks have pretty harsh performance costs: a process<br>that’s waiting to acquire a lock will just spin idly in a while loop, wasting<br>valuable CPU time that could be used to run other processes. So far, we’ve only<br>seen locks for kernel resources like the process table, page allocator, and<br>console, for which all operations should be relatively fast, on the order of a<br>few dozen CPU cycles at most.</p>
<p>Now it’s time to look at the disk driver and file system implementation, and<br>we’ll need some locks there too. But disk operations are <em>slow</em> – reading from<br>and writing to disk might take milliseconds, which is a literal eternity for a<br>CPU. Imagine a process hogging a spin-lock for the disk while other processes<br>spin around and around waiting <em>forever</em> for the disk to finish writing. It<br>would be an enormous waste!</p>
<p>Spin-locks were the best we could do at the time, since we didn’t have any<br>infrastructure to support more complex locks, but now we really do need a better<br>alternative. We also have some more kernel building blocks in place relating to<br>processes, including a bunch of system calls.</p>
<p>For example, we’ve seen the <code>sleep()</code> and <code>wakeup()</code> system calls, which let a<br>process give up the CPU until some condition is met. Well, hang on a second –<br>what if that condition is that a lock is free to acquire? Then a process could<br>sleep while another process holds the lock, and wake up when it’s ready to be<br>acquired; that would let other processes run instead of forcing a process to<br>spin and spin. xv6 calls these <em>sleep-locks</em>, and it’s time to find out how they<br>work.</p>
<h2 id="sleeplock-h"><a href="#sleeplock-h" class="headerlink" title="sleeplock.h"></a>sleeplock.h</h2><p>If we want a process holding a sleep-lock to give up the processor in the middle<br>of a critical section, then sleep-locks have to work well when held across<br>context switches. They also have to leave interrupts enabled. This couldn’t<br>happen with spin-locks: it was important that they disable interrupts to prevent<br>deadlocks and ensure a kernel thread can’t get rescheduled in the middle of<br>updating some important data structure.</p>
<p>Leaving interrupts on adds some extra challenges. First, we have to make sure<br>the lock can still be acquired atomically; second, we have to make sure that any<br>operations in the critical section can safely resume after being interrupted.</p>
<p>Let’s solve the first problem: how can we make sure a sleep-lock will always be<br>acquired atomically? Well, if we want to do something atomically, we already<br>have a solution: spin-locks! So rather than reinventing the wheel, we’ll just<br>make each sleep-lock a two-tiered deal with a spin-lock to protect its<br>acquisition.</p>
<p>We’ll use a <code>locked</code> field just like the one all spin-locks have, but then we’ll<br>add a spin-lock to protect it. We’ll also make debugging a little easier by<br>adding a name for the lock and a field for a PID to identify which process is<br>holding it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">    uint locked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="sleeplock-c"><a href="#sleeplock-c" class="headerlink" title="sleeplock.c"></a>sleeplock.c</h2><h3 id="initsleeplock"><a href="#initsleeplock" class="headerlink" title="initsleeplock"></a>initsleeplock</h3><p>We can initialize a sleep-lock by initializing its guard spin-lock, then adding<br>a name for it, setting <code>locked</code> to false, and the <code>pid</code> field to zero.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initsleeplock</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;lk-&gt;lk, <span class="string">&quot;sleep lock&quot;</span>);</span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acquiresleep"><a href="#acquiresleep" class="headerlink" title="acquiresleep"></a>acquiresleep</h3><p>In order to make sure sleep-lock acquisition is atomic, we’ll bookend this<br>function by acquiring and releasing a spin-lock. This will also make sure that<br>interrupts are disabled during this function but re-enabled when it’s done. It<br>does add some overheard in the form of spinning until this lock is free, but the<br>code here should be relatively short and fast to execute. What we really want is<br>to avoid spinning once the sleep-lock is acquired, i.e. spinning <em>after</em> this<br>function is done. So we’ll tolerate a little waste here.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now we have to do the actual acquisition. We said above that we’d use the<br><code>sleep()</code> function to avoid wasting processor time. Hopefully you remember one<br>important detail about <code>sleep()</code>: it must always be called inside a while loop<br>in order to make sure that we don’t miss any wakeup calls. So let’s check if the<br>sleep-lock is already being held and go to sleep if it is. We’ll need a channel<br>and a lock for <code>sleep()</code> to release, so let’s use the pointer to this lock <code>lk</code><br>as the channel, and the outer spin-lock <code>lk-&gt;lk</code> as the lock to be released.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">        sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s important to keep the two locks separate in your head right now: <code>lk</code> is<br>the sleep-lock, and <code>lk-&gt;lk</code> is the spin-lock it uses to protect the sleep-lock’s<br>acquisition. Note that we’re checking <code>lk-&gt;locked</code> here, <em>not</em> the spin-lock<br><code>lk-&gt;lk</code> – this process is already holding <code>lk-&gt;lk</code>, but we need to acquire<br><code>lk</code> itself by updating <code>lk-&gt;locked</code>. Phew, try saying that ten times fast.</p>
<p>Now the process will go to sleep and yield the CPU until the sleep-lock is free.<br>If multiple processes are sleeping waiting on the same sleep-lock, they will all<br>wake up at the same time, but all of them have to reacquire <code>lk-&gt;lk</code> before<br>returning from sleep, so only one will get to return here and complete the<br>sleep-lock acquisition. The others will spin a bit longer, then return here only<br>to find that <code>lk-&gt;locked</code> is already being held by another process, so the while<br>loop will put them to sleep again.</p>
<p>Once the sleep-lock is free, the process can exit the while loop and claim the<br>sleep-lock for itself.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">    lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We don’t need fancy atomic operations like <code>xchg</code> anymore, since the guarding<br>spin-lock has already made sure that interrupts are disabled and all operations<br>are effectively atomic. So that’s all we need! Now we just release the spin-lock<br>and return.</p>
<h3 id="releasesleep"><a href="#releasesleep" class="headerlink" title="releasesleep"></a>releasesleep</h3><p>Now that we’ve seen how a process acquires a sleep-lock, releasing it is easy,<br>we just do the opposite. We’ll set <code>lk-&gt;locked</code> to zero and clear the <code>lk-&gt;pid</code><br>field. And what’s the opposite of <code>sleep()</code>? Well, <code>wakeup()</code>, of course! That<br>will check whether there are any processes sleeping on this channel and let them<br>know they can attempt to acquire the sleep-lock now.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line"></span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    wakeup(lk);</span><br><span class="line"></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="holdingsleep"><a href="#holdingsleep" class="headerlink" title="holdingsleep"></a>holdingsleep</h3><p>This function is even more simple: it just checks whether a sleep-lock is being<br>held, and if so, whether it’s being held by the current process. The first is<br>done by just checking <code>lk-&gt;locked</code>; the second is done by checking that <code>lk-&gt;pid</code><br>matches the current process’s PID. The result is a boolean stored in a temporary<br>variable so we can release the guarding spin-lock before returning the result.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holdingsleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);</span><br><span class="line"></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-11"><a href="#Summary-11" class="headerlink" title="Summary"></a>Summary</h2><p>Okay, that wasn’t too bad! It makes sense why we couldn’t use sleep-locks in a<br>kernel without system calls like <code>sleep()</code> and <code>wakeup()</code>. But xv6 already has<br>those, so why not use them everywhere? If sleep-locks really do cut down on the<br>wasted CPU time, can we just go back and replace all the spin-locks with<br>sleep-locks? Then the only use for spin-locks would be as a guard for the more-<br>sophisticated sleep-locks.</p>
<p>Hold your horses! It’s not that easy. Sleep-locks leave interrupts enabled, so<br>they can’t be used in interrupt handler functions, or inside a critical section<br>where a spin-lock is being used, since interrupts will be disabled (though spin-<br>locks can be used inside sleep-lock critical sections). They also can’t be used<br>by kernel threads like the scheduler, since those aren’t processes and thus<br>can’t be put to sleep.</p>
<p>Finally, there are some situations in which a sleep-lock might actually add<br><em>more</em> overhead than a spin-lock: it takes some time to put a process to sleep,<br>schedule another process, send a wakeup call, schedule the first process again,<br>and so on, and the process will hold the sleep-lock the entire time. If another<br>process is waiting on the sleep-lock, it might actually end up waiting longer<br>than with a spin-lock, although it’ll wait in a sleeping state instead of a<br>running state where it just spins in a loop.</p>
<p>Additionally, sleep-locks can only be used when it’s safe to interrupt a process<br>in the middle of a critical section and wake it up later. Sure, no other process<br>can acquire the sleep-lock in the meantime, but it’s still not great for time-<br>sensitive operations like getting the current number of <code>ticks</code>.</p>
<p>So sleep-locks are great, but their applications are more limited than spin-<br>locks. The perfect use for them is when a process needs to complete an operation<br>atomically, but that operation itself might take a very long time. A great<br>example of that is disk I&#x2F;O, and we’ll see next how xv6 puts them to use in its<br>file system implementation.</p>
<h1 id="Devices-Disk-Driver"><a href="#Devices-Disk-Driver" class="headerlink" title="Devices: Disk Driver"></a>Devices: Disk Driver</h1><p>At this point, we’ve seen how xv6 virtualizes memory and the processor to give<br>each user process the illusion of a contiguous, near-infinite memory space and a<br>dedicated CPU to run it; we’ve also seen how xv6 mediates interactions between<br>most of a computer’s hardware components and user processes via system calls.<br>But there’s one more piece of hardware that’s critically important for an OS<br>that we haven’t looked at yet: the disk. All that’s left in the kernel code for<br>us to look at is how xv6 manages data storage on the disk and how it presents<br>that data to users in a simplified way.</p>
<p>The function of a disk is to provide <em>persistence</em> for an operating system. RAM<br>is volatile memory: it gets erased when the machine is turned off, so any data<br>stored there is fleeting. A disk allows an OS to store and retrieve data across<br>shut-offs. The disk driver we’ll go over in this post allows the xv6 kernel<br>direct access to that device so it can read and write data to it.</p>
<p>But unlike other devices, a simple driver isn’t enough here. We don’t just need<br>to be able to read and write data; we’d like to present users with a simplified,<br>accessible framework to navigate that data. Imagine using a computer where you<br>had to specify which byte of the disk to read or write, then remember that<br>yourself in order to access it again later. It’s madness! Enter file systems;<br>“files” don’t really exist in any real sense on a disk, but the OS can provide<br>the illusion of discrete, individual files in order to simplify access to data.</p>
<p>We also need to make sure concurrent accesses of the same file don’t risk<br>corrupting the file (or even the entire file system). We need to separate out<br>kernel data (like the kernel code itself) from user data on the disk, so that a<br>malicious user process can’t just overwrite arbitrary kernel code. Finally,<br>there’s that oh-so-famous line about Unix systems, “everything is a file”. We’ll<br>need a way to present “everything” in the elegant abstraction of a file.</p>
<p>All of these abstractions and security checks will require far more code than a<br>simple driver to implement them, so before we go on to the driver, let’s check<br>out how xv6 will organize its file system to get a preview of what’s ahead.</p>
<h2 id="File-System-Organization"><a href="#File-System-Organization" class="headerlink" title="File System Organization"></a>File System Organization</h2><p>Laying the abstraction of a complete file system on top of a physical disk will<br>require several steps. xv6 does this using seven layers. From bottom (direct<br>hardware interaction) to top (user-facing code), they are:</p>
<ul>
<li>Disk driver: reads and writes blocks on an IDE hard drive.</li>
<li>Buffer cache: caches disk blocks in memory and synchronizes access to them.</li>
<li>Logging: provides atomic disk writes to mitigate the risk of a crash.</li>
<li>Inodes: turns disk blocks into individual files that the OS can manipulate.</li>
<li>Directories: creates a tree of named directories that contain other files.</li>
<li>Path names: provides hierarchical, human-readable path names in the directory tree structure.</li>
<li>File descriptors: abstracts OS resources like pipes and devices as files to provide a unified API for user programs.</li>
</ul>
<p>That’s a lot of work to do now, but it’ll pay off! The kernel will do all this<br>labor so that users are free to be lazy later on and can live in blissful<br>ignorance of the fact that their precious little files actually exist as nothing<br>but ones and zeroes in totally arbitrary locations on the disk.</p>
<p>Note that hard drives are usually divided into <em>sectors</em>, which are physical<br>divisions (originally referring to literal geometric sectors), traditionally of<br>512 bytes. Operating systems can then collect these into larger <em>blocks</em> which<br>are multiples of the sector size. xv6 uses 512-byte blocks for simplicity so<br>that the sector and block sizes match up; I’ll use the two terms interchangeably.</p>
<p>On the disk, block 0 usually contains the boot sector, so it’s not used by xv6<br>(but remember the Makefile – xv6 actually stores the boot loader and kernel<br>code on an entirely separate physical disk). Block 1 is called the <em>superblock</em><br>because it contains metadata about the file system like its total size, the size<br>of the log, the number of files, and their location on the disk. Then the log<br>starts at block 2 and on.</p>
<h2 id="buf-h"><a href="#buf-h" class="headerlink" title="buf.h"></a>buf.h</h2><p>If you’ve read any of the previous optional posts on device drivers, you know<br>that interacting directly with the hardware means all kinds of opaque code with<br>seemingly-arbitrary port I&#x2F;O and cryptic magic numbers. Drivers are also specific<br>to the actual (or virtual) hardware in the machine that xv6 will run on, so it<br>tends to be less useful for showing general OS concepts – hence why all the<br>other device driver posts were optional. That being said, the disk driver nicely<br>rounds out the rest of the file system code, so I recommend checking it out, but<br>if you’re short on time or bored with all the talk about hardware specs, feel<br>free to skip to the summary section below.</p>
<p>Reading and writing disk data is super slow, so the second layer in the file<br>system is the buffer cache, which will store copies of disk blocks in memory for<br>faster access. But we still have to read from the disk to create that buffer,<br>and we still have to write any modified data to the disk once we’re done, so<br>we still need a layer below the buffer cache to do that. That layer is the disk<br>driver; its purpose is to copy data from the disk to the in-memory cache and<br>vice versa. A single block is represented in the cache as a <code>struct buf</code>, defined<br>in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/buf.h">buf.h</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    uint dev;               <span class="comment">// device number</span></span><br><span class="line">    uint blockno;           <span class="comment">// block number (same as sector number)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span>  <span class="comment">// sleep-lock to protect buffer reads and writes</span></span><br><span class="line">    uint refcnt;            <span class="comment">// how many processes are using this buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span>       <span class="comment">// for use with buffer cache doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span>       <span class="comment">// for use with buffer cache doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span>      <span class="comment">// for use with disk driver queue</span></span><br><span class="line">    uchar data[BSIZE];      <span class="comment">// data stored in the buffer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_VALID 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_DIRTY 0x4</span></span><br></pre></td></tr></table></figure>

<p>The two constants defined at the bottom are used in the <code>flags</code> field; <code>B_VALID</code><br>indicates that a buffer has been read from disk and should accurately reflect<br>the sector’s contents on the disk, and <code>B_DIRTY</code> says we’ve modified the buffer<br>but haven’t yet updated the on-disk version of a file, so we need to write the<br>buffer to disk soon.</p>
<p>We’ll see later on that the buffer cache uses a doubly-linked list of buffers;<br>the <code>prev</code> and <code>next</code> fields are used there. However, the disk driver also<br>maintains its own queue of buffers that are waiting to be read from or written<br>to the disk; that’s implemented as a singly-linked list using the <code>qnext</code> field.</p>
<h2 id="ide-c"><a href="#ide-c" class="headerlink" title="ide.c"></a>ide.c</h2><p>We’ve already seen some code to read and write disk data in the <a href="boot.md">boot loader</a>;<br>I know it’s been a while, so you can check that out again if you want. We can’t<br>reuse the code there for a few reasons, though: (1) the boot loader has to be<br>compiled separately from the kernel, so we can’t access any of the functions<br>there, and (2) we need to store data in the buffer cache, so we can’t even copy-<br>paste the code we used before since the boot loader barely even knows what<br>memory is, let alone a buffer cache.</p>
<h3 id="ATA-Programmed-I-x2F-O-Mode"><a href="#ATA-Programmed-I-x2F-O-Mode" class="headerlink" title="ATA Programmed I&#x2F;O Mode"></a>ATA Programmed I&#x2F;O Mode</h3><p>Modern disk drivers usually talk to the disk via direct memory access (DMA), but<br>to keep things simple xv6 is just gonna talk to it with port I&#x2F;O. That’s much,<br>much slower, and it requires active participation by the CPU (which means it<br>can’t do anything else at the same time), but hey, xv6 thinks it’s 1995,<br>remember? So PIO mode is still (relatively) cutting edge. Either way, extreme<br>performance isn’t the goal here, so we’ll just have to suck it up.</p>
<p>Okay, let’s do a super-quick summary. <code>inb</code> is a C wrapper for an x86 assembly<br>instruction that reads a single byte of data from a port; <code>outb</code> writes a byte<br>to a port. The disk controller chip has primary and secondary buses; the primary<br>bus sends data on port 0x1F0 and has control registers on ports 0x1F1 through<br>0x1F7. Port 0x1F7 doubles as a command register and a status port with some<br>useful flags we can check in order to know what the disk is up to; we saw some<br>of those before, but I’ll give you the full list now.</p>
<ul>
<li>Bit 0 (0x01) - ERR (indicates an error occurred)</li>
<li>Bit 1 (0x02) - IDX (index; always set to zero)</li>
<li>Bit 2 (0x04) - CORR (corrected data; always set to zero)</li>
<li>Bit 3 (0x08) - DRQ (drive has data to transfer or is ready to receive data)</li>
<li>Bit 4 (0x10) - SRV (service request)</li>
<li>Bit 5 (0x20) - DF (drive fault error)</li>
<li>Bit 6 (0x40) - RDY (ready; clear when drive isn’t running or after an error and set otherwise)</li>
<li>Bit 7 (0x80) - BSY (busy; drive is in the middle of sending&#x2F;receiving data)</li>
</ul>
<p>The disk driver defines some of these with preprocessor macros at the top of the<br>file.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECTOR_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_BSY     0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_DRDY    0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_DF      0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_ERR     0x01</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>We also saw one command example in the boot loader: sending 0x20 to port 0x1F7<br>tells the disk to read a sector and send it to us through data port 0x1F0. Now<br>we’ll also use commands to write a sector, as well as to read or write multiple<br>sectors at once.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_READ    0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_WRITE   0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_RDMUL   0xc4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_WRMUL   0xc5</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>If, for some reason beyond mortal comprehension, you decide you want to know<br>more about the eldritch secrets of ancient hard drives, you can read <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/ATA-d1410r3a.pdf">this<br>resource on ATA disks</a>.</p>
<p>After those constants, we find three static global variables: a spin-lock for<br>accessing the disk, the queue of buffers waiting to be synchronized with their<br>on-disk counterparts, and a boolean to track whether xv6 is running with only<br>disk 0 (boot loader and kernel) or with disk 1 (user file system) as well.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">idelock</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">idequeue</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> havedisk1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="idewait"><a href="#idewait" class="headerlink" title="idewait"></a>idewait</h3><p>This function takes an integer <code>checkerr</code> argument that should be a boolean and<br>waits for the disk to be ready to receive more commands. If <code>checkerr</code> is true,<br>it’ll also check whether the status port includes any error flags.</p>
<p>It starts by reading from the disk’s status port and looping until the busy<br>flag is not set but the ready flag is. The bitwise-OR <code>IDE_BSY | IDE_DRDY</code><br>combines both flags, and the bitwise-AND tests whether either one is set in <code>r</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">idewait</span><span class="params">(<span class="type">int</span> checkerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (((r = inb(<span class="number">0x1f7</span>)) &amp; (IDE_BSY | IDE_DRDY)) != IDE_DRDY)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now if <code>checkerr</code> is nonzero we have to check that neither the error nor the<br>drive failure flag is set in the status port. If either one is set, we’ll return<br>-1; we’ll return 0 otherwise.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">idewait</span><span class="params">(<span class="type">int</span> checkerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (checkerr &amp;&amp; (r &amp; (IDE_DF | IDE_ERR)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ideinit"><a href="#ideinit" class="headerlink" title="ideinit"></a>ideinit</h3><p>This function is called by the kernel’s <code>main()</code> during set-up to initialize the<br>disk. We start by initializing the disk lock, then tell the I&#x2F;O interrupt<br>controller to forward all disk interrupts to the last CPU. We talked about the<br><code>ioapicenable()</code> function in detail in the post on interrupt controllers.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;idelock, <span class="string">&quot;ide&quot;</span>);</span><br><span class="line">    ioapicenable(IRQ_IDE, ncpu - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we wait for the disk to be ready to accept commands (ignoring any error<br>flags that may be present).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    idewait(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We said above that disk 0 should contain the boot loader and kernel, so we can<br>assume any machine running xv6 should have that present. However, we need to<br>make sure disk 1 is present; the<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a> includes<br>some configurations like <code>make qemu-memfs</code> under which xv6 can run without a<br>dedicated disk for the file system, storing files in memory instead.</p>
<p>Port 0x1F6 is used to select a drive. Bits 5 and 7 should always be set, and bit<br>6 picks the right mode we need to indicate a disk. Bit 4 determines whether we<br>want to select disk 0 or disk 1. So we can select drive 1 by setting bits 5-7<br>(0xE0 when combined), then bit 4 (<code>1 &lt;&lt; 4</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to wait for disk 1 to be ready; we need to handle this as a special<br>case since <code>waitdisk()</code> can’t check a specific disk for us, and because an<br>absent disk 1 would make the while loop there continue forever. So we’ll check<br>the status register 1000 times; if it ever reports that it’s ready, we’ll set<br><code>havedisk1</code> to true and break, but otherwise we’ll assume disk 1 isn’t present<br>and leave <code>havedisk1</code> as zero (i.e., false).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inb(<span class="number">0x1f7</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            havedisk1 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll switch back to using disk 0 by changing the fourth bit of the<br>register at port 0x1F6.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">0</span> &lt;&lt; <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="idestart"><a href="#idestart" class="headerlink" title="idestart"></a>idestart</h3><p>This is the core function that will read or write a buffer to or from the disk.<br>It’s a <code>static</code> function, so it can only be called by other functions in this<br>file; <code>ideintr()</code> and <code>iderw()</code> will both use it as a helper function. It takes<br>a pointer to a buffer, so the first thing to do is make sure that pointer isn’t<br>null. We’ll also make sure the buffer’s block number is within the maximum limit<br>set by <code>FSSIZE</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 1000.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;blockno &gt;= FSSIZE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;incorrect blockno&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to figure out which disk sector to read from or write to. Since xv6<br>uses blocks that are the same size as a sector, this should just be <code>b-&gt;blockno</code>,<br>but we’ll add a conversion here in case that gets changed later on (especially<br>if we want higher disk throughput).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> sector_per_block = BSIZE / SECTOR_SIZE;</span><br><span class="line">    <span class="type">int</span> sector = b-&gt;blockno * sector_per_block;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If each block fits exactly one sector, then we’ll need to use the single-sector<br>read and write commands; otherwise we should use the multi-sector versions of<br>those commands. We’ll set <code>read_cmd</code> and <code>write_cmd</code> to the right versions.<br>We’ll also make sure that there are no more than 7 sectors per block.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> read_cmd = (sector_per_block == <span class="number">1</span>) ? IDE_CMD_READ : IDE_CMD_RDMUL;</span><br><span class="line">    <span class="type">int</span> write_cmd = (sector_per_block == <span class="number">1</span>) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;</span><br><span class="line">    <span class="keyword">if</span> (sector_per_block &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s wait for the disk to be ready, ignoring any error flags.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    idewait(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s time to brace yourself, because this next part is a hot mess of<br>port I&#x2F;O operations with lots of magic numbers. First we’ll tell the disk<br>controller to generate an interrupt once it’s done reading or writing by setting<br>the device control register at 0x3F6 to zero. Then we’ll tell it how many total<br>sectors we want to read or write by writing that number (AKA <code>sector_per_block</code>)<br>to port 0x1F2.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x3f6</span>, <span class="number">0</span>);                 <span class="comment">// generate interrupt when done</span></span><br><span class="line">    outb(<span class="number">0x1f2</span>, sector_per_block);  <span class="comment">// number of sectors to read/write</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Before sending the read or write command, we have to tell the disk which sector<br>to read from, using our <code>sector</code> variable from above. Let’s take a second to<br>talk about hard drive geometry. A hard drive consists of a bunch of stacked<br>circular surfaces, where each surface has a corresponding <em>head</em> that changes<br>its position to read or write from the right place on the disk. Each surface has<br>a number of <em>tracks</em>: concentric circles that contain data. If you pick a track<br>number (i.e. pick a distance from the center of the surfaces) and collect all<br>those tracks from all the surfaces, you get a <em>cylinder</em>.</p>
<p>A sector number acts as a kind of address with each part specifying a different<br>geometric component, similar to how linear addresses contain a page directory<br>index, page table index, and offset. The eight most significant bits (24 through<br>31) identify the drive and&#x2F;or head that the sector is located on (plus some<br>flags); bits 8 through 23 identify the cylinder, and bits 0 through 7 pick a<br>sector within that cylinder. Altogether, these define a 3D coordinate system<br>that uniquely identifies all sectors on a machine’s disks.</p>
<p>Port 0x1F3 is the sector number register, ports 0x1F4 and 0x1F5 are the cylinder<br>low and high registers, and port 0x1F6 is the drive&#x2F;head register. We can write<br>the sector number as <code>sector &amp; 0xFF</code>; the cylinder low and high numbers can be<br>recovered by bitshifting <code>sector</code> down by 8 and 16, respectively.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f3</span>, sector &amp; <span class="number">0xff</span>);             <span class="comment">// sector number</span></span><br><span class="line">    outb(<span class="number">0x1f4</span>, (sector &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);      <span class="comment">// cylinder low</span></span><br><span class="line">    outb(<span class="number">0x1f5</span>, (sector &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);     <span class="comment">// cylinder high</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now for the drive&#x2F;head register, we’ll use <code>b-&gt;dev</code> to get the block’s device<br>and <code>(sector &gt;&gt; 24)</code> to get the head it’s on. Finally, we’ll set bits 5-7 as<br>required (and as mentioned above in <code>ideinit()</code>) with 0xE0. Then we can<br>bitwise-OR all of these together and write them to port 0x1F6.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | ((b-&gt;dev &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>) | ((sector &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0f</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, that was the worst of it! Deep breath now. The last part is just sending<br>the actual read or write command. But how do we know which one we’re supposed to<br>do? The only argument is a pointer to a buffer <code>b</code>, not any sort of boolean that<br>might tell us which to carry out. Well, remember the buffer flag <code>B_DIRTY</code>? That<br>one indicates that a buffer has been modified and needs to be written to disk.<br>If that flag is set, reading from the disk would overwrite any changes, which<br>probably isn’t what we want. So let’s just assume that the <code>B_DIRTY</code> flag means<br>we should write to disk, and the absence of that flag means we should read from<br>disk.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;flags &amp; B_DIRTY) &#123;</span><br><span class="line">        outb(<span class="number">0x1f7</span>, write_cmd);</span><br><span class="line">        outsl(<span class="number">0x1f0</span>, b-&gt;data, BSIZE / <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outb(<span class="number">0x1f7</span>, read_cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here <code>outsl()</code> is another C wrapper for an x86 instruction; this one writes data<br>from a string, four bytes at a time.</p>
<p>That’s it! This is by far the most cryptic function in the disk driver; the last<br>two are relatively easy now.</p>
<h3 id="ideintr"><a href="#ideintr" class="headerlink" title="ideintr"></a>ideintr</h3><p>We saw in <code>idestart()</code> that we set up the disk to send an interrupt whenever<br>it’s done reading or writing data. Back when we looked at<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/trap.c">trap.c</a>, we saw that<br>the <code>trap()</code> function directs all disk interrupts to the handler function<br><code>ideintr()</code>. It’s time to check that one out now.</p>
<p>We’ll start by acquiring the disk’s spin-lock; note that we don’t use a sleep-<br>lock because this is an interrupt handler function, so interrupts should be<br>disabled while it runs.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;idelock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we got an interrupt, then it usually means the disk is done with the most<br>recent request. Those requests are stored in the global <code>idequeue</code> linked list,<br>with the current request at the front of the queue. So we’ll get the head of the<br>queue as <code>b</code>, then set <code>idequeue</code> to point to the next buffer in the queue. If<br>the head is null, then we’ll just return early.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((b = idequeue) == <span class="number">0</span>) &#123;</span><br><span class="line">        release(&amp;idelock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idequeue = b-&gt;next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The read command in <code>idestart()</code> didn’t specify where to read the data to, so we<br>do that now. We’ll check if the <code>B_DIRTY</code> flag was set; if it wasn’t (i.e. the<br>operation was a disk read), then we’ll wait for the disk to be ready (without<br>any errors, using <code>idewait(1)</code> instead of <code>idewait(0)</code> as we have before) and<br>read the data into <code>b-&gt;data</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(b-&gt;flags &amp; B_DIRTY) &amp;&amp; idewait(<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        insl(<span class="number">0x1f0</span>, b-&gt;data, BSIZE / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we set the <code>B_VALID</code> flag with a bitwise-OR and clear any <code>B_DIRTY</code> flag<br>with a bitwise-AND and a bitwise-NOT. Then we’ll wake up any user process that<br>went to sleep on a channel for this buffer after requesting a disk I&#x2F;O operation.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b-&gt;flags |= B_VALID;</span><br><span class="line">    b-&gt;flags &amp;= ~B_DIRTY;</span><br><span class="line">    wakeup(b);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll get the disk started on the next operation, for the next buffer<br>in the queue.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (idequeue != <span class="number">0</span>) &#123;</span><br><span class="line">        idestart(idequeue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iderw"><a href="#iderw" class="headerlink" title="iderw"></a>iderw</h3><p>The <code>idestart()</code> function is <code>static</code>, so it can’t be called by anything outside<br>of this file; we need to provide a mechanism for both kernel and user threads to<br>read and write disk data. That’s what <code>iderw()</code> does. Note that processes should<br>never call this function directly; it only gets called by the code for the<br>buffer cache layer of the file system. In other words, processes will use system<br>calls like <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>, etc., which in turn will<br>use functions from higher layers of abstraction, which in turn call functions<br>from lower layers, and so on, until they reach the buffer cache, which calls<br><code>iderw()</code> to finally read&#x2F;write directly from&#x2F;to the disk.</p>
<p>By the time a process gets to <code>iderw()</code>, it should already be holding a sleep-<br>lock <code>b-&gt;lock</code> for the buffer <code>b</code> it wants to read or write, and either the<br><code>B_DIRTY</code> flag should be set (to write to disk) or the <code>B_VALID</code> flag should be<br>absent (to read from disk). We’ll start off with some sanity checks for those,<br>and make sure that we’re not trying to read from disk 1 if it’s not present on<br>this machine. Then we’ll acquire the disk’s spin-lock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;iderw: buf not locked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((b-&gt;flags &amp; (B_VALID | B_DIRTY)) == B_VALID) &#123;</span><br><span class="line">        <span class="comment">// B_VALID is set, so we don&#x27;t need to read it; B_DIRTY is not set, so</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to write it</span></span><br><span class="line">        panic(<span class="string">&quot;iderw: nothing to do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev != <span class="number">0</span> &amp;&amp; !havedisk1) &#123;</span><br><span class="line">        panic(<span class="string">&quot;iderw: ide disk 1 not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;idelock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There may be other buffers waiting in line in the disk queue, so we have to<br>append this buffer <code>b</code> to the end of <code>idequeue</code>. We can do that by setting<br><code>b-&gt;qnext</code> to null, then creating a variable <code>pp</code> to traverse the entire queue.<br>When <code>pp</code> points to the last element, we’ll set its <code>qnext</code> field to point to<br><code>b</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b-&gt;qnext = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse the queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> **<span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (pp = &amp;idequeue; *pp; pp = &amp;(*pp)-&gt;qnext)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append b to end of queue</span></span><br><span class="line">    *pp = b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That traversal might look confusing as all hell, so let’s take a closer look.<br>It defines <code>pp</code> as a double pointer: a pointer to a pointer to a <code>struct buf</code>.<br>(If you’ve seen the interview of Linus Torvalds where he talks about good style<br>with linked lists, it’s similar to the code there; there’s a nice summary<br><a target="_blank" rel="noopener" href="https://github.com/mkirchner/linked-list-good-taste">here</a>.) <code>pp</code> starts off<br>equal pointing to <code>idequeue</code>, i.e. the head of the linked list. Each iteration<br>checks that <code>pp</code> points to a valid (non-null) pointer, i.e. the loop will end<br>when we reach the end of the list. The body of the loop is empty, so none of the<br>iterations actually do anything; the purpose of the for loop is just to update<br><code>pp</code> several times. At the end of each iteration, <code>pp</code> is updated to point to a<br>pointer to the next buffer in the queue.</p>
<p>Suppose the last buffer in the queue is <code>end</code>. At the end of the for loop, <code>pp</code><br>will hold the address of <code>end-&gt;qnext</code>, so <code>*pp = b</code> sets <code>end-&gt;qnext = b</code>. The<br>double indirection makes it easy to update the last buffer in the queue; without<br>it, we would have to stop the loop one step earlier when <code>pp</code> points to <code>end</code><br>instead of <code>end-&gt;qnext</code> then be careful to update the actual buffer at the end<br>of the queue instead of just updating the local variable <code>pp</code>. All in all, it’s<br>just an elegant way to write a linked list traversal in a single line.</p>
<p>Okay, so now our buffer <code>b</code> is at the end of the queue. If there are others in<br>front of it, then <code>ideintr()</code> will make sure that each disk interrupt starts the<br>disk on the next operation. But what if <code>b</code> is actually the only buffer in the<br>queue? In that case, the disk isn’t running yet, so we need to get it started<br>ourselves.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (idequeue == b) &#123;</span><br><span class="line">        idestart(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At this point, we can be confident that the disk will either start our request<br>now or get to it eventually (if there are other requests in the queue). This<br>process just has to wait for the disk to finish, so we’ll put it to sleep until<br>the buffer has been synchronized with the disk. We’ll check that by making sure<br>the <code>B_VALID</code> flag is present but <code>B_DIRTY</code> is not set. The call to <code>sleep()</code><br>will release <code>idelock</code> and reacquire it before returning.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> ((b-&gt;flags &amp; (B_VALID | B_DIRTY)) != B_VALID) &#123;</span><br><span class="line">        sleep(b, &amp;idelock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-12"><a href="#Summary-12" class="headerlink" title="Summary"></a>Summary</h2><p>The disk driver handles direct communication with the hard drive, issuing orders<br>to read or write sectors. It exposes two API functions, <code>ideintr()</code> and<br><code>iderw()</code>. The former is called by <code>trap()</code> to handle disk interrupts, while the<br>latter is called by the code for the buffer cache layer of the file system to<br>update blocks in the buffer cache with their corresponding sectors on disk. Next<br>up we’ll look at the buffer cache itself, as well as the logging layer, which<br>provides crash recovery.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/06/xv6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/06/xv6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">xv6笔记之环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-06 17:37:22" itemprop="dateCreated datePublished" datetime="2023-05-06T17:37:22+08:00">2023-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-15 18:04:02" itemprop="dateModified" datetime="2023-05-15T18:04:02+08:00">2023-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xv6/" itemprop="url" rel="index"><span itemprop="name">xv6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文在Ubuntu22.04上搭建xv6(x86版本)的开发环境，用于编译、调试xv6源码。</p>
<ul>
<li>xv6 x86版本参考<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/overview.html">MIT6.828&#x2F;2018</a></li>
<li>xv6 riscv版本参考<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/">MIT6.S081</a> ，MIT6.828从2019年以后以RISCV指令集实现，并拆分了课程</li>
</ul>
<p>两者的课程内容区别：</p>
<p>6.828 and 6.S081 will be offered as two separate classes. 6.S081 (Introduction to Operating Systems) will be taught as a stand-alone AUS subject for undergraduates, and will provide an introduction to operating systems. 6.828 will be offered as a graduate-level seminar-style class focused on research in operating systems. 6.828 will assume you have taken 6.S081 or an equivalent class.</p>
<p>为什么选用x86版本：</p>
<p>x86版本有更完善的资料和更细节的代码讲解，参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/woai3c/MIT6.828">woai3c&#x2F;MIT6.828</a></p>
<p>学完x86版本再学riscv版本，只需要关注指令集差异即可</p>
<h2 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h2><p>主流程参考：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/tools.html">Tools Used in 6.828</a></p>
<p>这里只记录我操作过程中和该wiki的差异点</p>
<p>1.下载包有的连接失败，bing搜索到合适的下载源后，最终成功下载的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br></pre></td></tr></table></figure>

<p>2.编译Toolchain中的问题：</p>
<p>(0)<strong>注意!!!</strong> 在编译Toolchain完成以后要恢复默认的LD_LIBRARY_PATH，不要在toolchain配置了LD_LIBRARY_PATH的情况下去完成后续的安装qemu等其他任何操作，否则可能系统损害无法进入桌面且不能recovery，报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libgnutls.so.30 undefined symbol: __gmpz_limbs_write</span><br></pre></td></tr></table></figure>

<p>问题原因和解决办法参考：<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined"><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined">apt-get wants an older GNUTLS version to be defined</a></a></p>
<p><strong>LIB PATH导致系统损坏的经验：搭建开发环境配置的LD_LIBRARY_PATH不要随便export；在使用时export, 使用完毕后恢复</strong></p>
<p>(1)如果安装在&#x2F;usr&#x2F;local，所有make install都要sudo；安装在home不需要sudo</p>
<p>(2)编译gcc时报错：<code>configure: error: cannot compute suffix of object files: cannot compile</code></p>
<p>需要export PATH，由于所有编译包都安装在&#x2F;usr&#x2F;local&#x2F;，所以export PATH也为&#x2F;usr&#x2F;local&#x2F;，保存为export-path.sh方便重启后使用，也可以加到~&#x2F;.bashrc：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>(3)编译gdb时报错：<code>error: no termcap library found</code></p>
<p>要手动下载termcap包并编译，操作过程和toolchain一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>完整的编译脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export PFX=~/xv6/toolchain #这里编译到home,也可以用/usr/local</span><br><span class="line">mkdir -p $PFX</span><br><span class="line">cd $PFX</span><br><span class="line"></span><br><span class="line">#install a development environment.</span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line">sudo apt-get install gcc-multilib</span><br><span class="line"></span><br><span class="line">#Building Your Own Compiler Toolchain</span><br><span class="line">#wget容易失败，因此这部分最好手动执行，确保全部下载成功</span><br><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br><span class="line"></span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">tar xjf gmp-5.0.2.tar.bz2</span><br><span class="line">cd gmp-5.0.2</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf mpfr-3.1.2.tar.bz2</span><br><span class="line">cd mpfr-3.1.2</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xzf mpc-0.9.tar.gz</span><br><span class="line">cd mpc-0.9</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf binutils-2.21.1.tar.bz2</span><br><span class="line">cd binutils-2.21.1</span><br><span class="line">./configure --prefix=$PFX --target=i386-jos-elf --disable-werror</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gcc-core-4.6.4.tar.bz2</span><br><span class="line">cd gcc-4.6.4</span><br><span class="line">mkdir build              # GCC will not compile correctly unless you build in a separate directory</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=$PFX \ </span><br><span class="line">    --with-gmp=$PFX --with-mpfr=$PFX --with-mpc=$PFX \ #指定gmp, mpfr, mpc位置</span><br><span class="line">    --target=i386-jos-elf --disable-werror \</span><br><span class="line">    --disable-libssp --disable-libmudflap --with-newlib \</span><br><span class="line">    --without-headers --enable-languages=c MAKEINFO=missing</span><br><span class="line">make all-gcc</span><br><span class="line">make install-gcc         # This step may require privilege (sudo make install-gcc)</span><br><span class="line">make all-target-libgcc</span><br><span class="line">make install-target-libgcc     # This step may require privilege (sudo make install-target-libgcc)</span><br><span class="line">cd ../..</span><br><span class="line"></span><br><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gdb-7.3.1.tar.bz2</span><br><span class="line">cd gdb-7.3.1</span><br><span class="line">./configure --prefix=$PFX \</span><br><span class="line">    --target=i386-jos-elf --program-prefix=i386-jos-elf- \</span><br><span class="line">    --disable-werror</span><br><span class="line">make all</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">i386-jos-elf-objdump -i</span><br><span class="line"># Should produce output like:</span><br><span class="line"># BFD header file version (GNU Binutils) 2.21.1</span><br><span class="line"># elf32-i386</span><br><span class="line">#  (header little endian, data little endian)</span><br><span class="line">#   i386...</span><br><span class="line"></span><br><span class="line">i386-jos-elf-gcc -v</span><br><span class="line"># Should produce output like:</span><br><span class="line"># Using built-in specs.</span><br><span class="line"># COLLECT_GCC=i386-jos-elf-gcc</span><br><span class="line"># COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/i386-jos-elf/4.6.4/lto-wrapper</span><br><span class="line"># Target: i386-jos-elf</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=&quot;&quot; #恢复系统本身的libpath(默认空)，避免装其他软件有lib冲突造成系统损坏</span><br></pre></td></tr></table></figure>

<h2 id="交叉编译的参数"><a href="#交叉编译的参数" class="headerlink" title="交叉编译的参数"></a>交叉编译的参数</h2><p>在交叉编译configure时，通常会需要设置–build、–host和–target选项。各个选项的含义如下：</p>
<ul>
<li>–build：编译所用的机器的平台。</li>
<li>–host：编译出的代码运行的平台。</li>
<li>–target：编译出来的工具链生成的代码的运行平台。这个选项不常用，一般只在编译gcc、ld等工具链的过程中用到。</li>
</ul>
<p>在不涉及到交叉编译的时候，–build、–host、–target缺省值都是本机平台，不需要特别设置。</p>
<p>在交叉编译的时候，比如需要在x86平台编译arm程序，就需要设置–build和–host选项；其中host的内容为目标平台名称，通常编译器的名字前缀就是目标平台名称，例如用arm-unknown-linux-gnueabi-gcc编译，–host设置为arm-unknown-linux-gnueabi；–build可以缺省不设置就是使用当前平台名称</p>
<h2 id="编译QEMU"><a href="#编译QEMU" class="headerlink" title="编译QEMU"></a>编译QEMU</h2><p>xv6使用的QEMU是patched version，要手动编译，过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mit-pdos/6.828-qemu.git qemu</span><br><span class="line"></span><br><span class="line">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span><br><span class="line"></span><br><span class="line">#此qemu版本需要python2 (2.7), 由于python2和3不兼容, 且系统只有Python3, 因此需要安装</span><br><span class="line">sudo apt install python2</span><br><span class="line">python2 -V</span><br><span class="line">cd qemu</span><br><span class="line"></span><br><span class="line">./configure --disable-kvm --disable-werror --prefix=$PFX --target-list=&quot;i386-softmmu x86_64-softmmu&quot; --python=/usr/bin/python2</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>qemu编译错误的解决办法：<a target="_blank" rel="noopener" href="https://github.com/woai3c/MIT6.828/blob/master/docs/install.md">MIT6.828 实验环境安装教程</a></p>
<p>其中以下错误的解决方法： 在 <code>qga/commands-posix.c</code> 文件中加 <code>#include &lt;sys/sysmacros.h&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: In function ‘dev_major_minor’:</span><br><span class="line">qga/commands-posix.c:633:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;.</span><br></pre></td></tr></table></figure>

<h2 id="运行xv6"><a href="#运行xv6" class="headerlink" title="运行xv6"></a>运行xv6</h2><p>下载6.828的jos lab，make产生kernel.img</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></pre></td></tr></table></figure>

<p>运行qemu的xv6之前，需要export PATH和LD_LIBRARY_PATH；运行之后要清掉LD_LIBRARY_PATH为空(重启或手动清除)</p>
<p>写export_xv6.sh如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PFX=~/xv6/toolchain</span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>建议给调用export_xv6.sh的命令加别名(alias)到.bashrc，可以用get-xv6命令一键export：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias get_xv6=&#x27;. $HOME/xv6/export_xv6.sh&#x27;</span><br></pre></td></tr></table></figure>

<p>如果是本地执行qemu(带GUI)用<code>make qemu</code>; 如果是远程终端执行用<code>make qemu-nox</code>。qemu内容如下表示qemu环境搭建OK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit</span><br><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log </span><br><span class="line">VNC server running on `127.0.0.1:5900&#x27;</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/05/esp32%E7%AC%94%E8%AE%B0%E4%B9%8BPWM%E5%AE%9E%E7%8E%B0LED%E5%91%BC%E5%90%B8%E7%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/esp32%E7%AC%94%E8%AE%B0%E4%B9%8BPWM%E5%AE%9E%E7%8E%B0LED%E5%91%BC%E5%90%B8%E7%81%AF/" class="post-title-link" itemprop="url">esp32笔记之PWM实现LED呼吸灯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 16:50:16" itemprop="dateCreated datePublished" datetime="2023-05-05T16:50:16+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-06 20:16:07" itemprop="dateModified" datetime="2023-05-06T20:16:07+08:00">2023-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/esp32/" itemprop="url" rel="index"><span itemprop="name">esp32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h2><p>先从应用上讲讲PWM：</p>
<p>有一盏日光灯，一般我们只能打开它或者关闭它，不存在中间状态；</p>
<p>有另一个LED灯，支持在一秒以内极快速的速度开关开关，其变化超过人眼识别的24帧率，LED灯看上去就像一直开着，但亮度比常开暗一些；如果控制灯快速开关过程中的打开时间和关闭时间的比例，就可以调节人眼看到的灯亮度。</p>
<p>以上就是PWM的大概应用原理：用高频率的开关信号，控制输出信号的平均强度，使输出信号能在0%到100%强度间任意调节。</p>
<p>用电路语句讲PWM原理：用数字信号的占空比来调制模拟信号的幅度(电压)。</p>
<p>PWM详细介绍参考：<a target="_blank" rel="noopener" href="https://circuitdigest.com/tutorial/what-is-pwm-pulse-width-modulation">What is PWM: Pulse Width Modulation</a></p>
<p>脉冲宽度(pulse width)是指单位时间的高电平的持续时间，脉冲宽度越大被调制的模拟信号电压越大。</p>
<ul>
<li>在一定的频率下，通过不同的(高电平)占空比即可得到不同脉冲宽度，进而调节输出的模拟电压信号</li>
<li>在一定的占空比下，通过不同的频率实现不同的调节速度；频率要适配不同设备，不能任意设置，例如电机频率50HZ，MCU外设1000Hz。频率不决定被调制电压的幅度。</li>
</ul>
<p>PWM的调制信号如下：</p>
<p><img src="https://circuitdigest.com/sites/default/files/inlineimages/pulse-width-modulation-duty-cycle.gif" alt="img"></p>
<p>PWM调制电路通常用RC filter实现：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051659127.jpg" alt="Converting-PWM-signals-into-Analog"></p>
<p>PWM一般对具体设备使用固定频率，再调整高电平的占空比决定模拟信号的幅度。</p>
<p>如下图，占空比从0%调节到100%，对应输出电压为0V~5V</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305061100234.jpg" alt="Pulse-Width-Modulation"></p>
<p>从原理上讲就是开关控制，在一个周期内调制信号的高电平时间越长，RC电荷积分更多，输出电压越大：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051657299.png" alt="image-20230505165748199"></p>
<h2 id="MicroPython控制PWM"><a href="#MicroPython控制PWM" class="headerlink" title="MicroPython控制PWM"></a>MicroPython控制PWM</h2><p>官方tutorial参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.micropython.org/en/latest/esp32/quickref.html">Quick reference for the ESP32</a> PWM (pulse width modulation)</p>
<p><a target="_blank" rel="noopener" href="https://docs.micropython.org/en/latest/esp32/tutorial/pwm.html#esp32-pwm">Pulse Width Modulation</a> 其中有调整频率和占空比的sample code:</p>
<ul>
<li><p>Example of a smooth frequency change:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">F_MIN = 500</span><br><span class="line">F_MAX = 1000</span><br><span class="line"></span><br><span class="line">f = F_MIN</span><br><span class="line">delta_f = 1</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), f)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.freq(f)</span><br><span class="line"></span><br><span class="line">    sleep(10 / F_MIN)</span><br><span class="line"></span><br><span class="line">    f += delta_f</span><br><span class="line">    if f &gt;= F_MAX or f &lt;= F_MIN:</span><br><span class="line">        delta_f = -delta_f</span><br></pre></td></tr></table></figure>
</li>
<li><p>Example of a smooth duty change:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">DUTY_MAX = 2**16 - 1</span><br><span class="line"></span><br><span class="line">duty_u16 = 0</span><br><span class="line">delta_d = 16</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), 1000, duty_u16=duty_u16)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.duty_u16(duty_u16)</span><br><span class="line"></span><br><span class="line">    sleep(1 / 1000)</span><br><span class="line"></span><br><span class="line">    duty_u16 += delta_d</span><br><span class="line">    if duty_u16 &gt;= DUTY_MAX:</span><br><span class="line">        duty_u16 = DUTY_MAX</span><br><span class="line">        delta_d = -delta_d</span><br><span class="line">    elif duty_u16 &lt;= 0:</span><br><span class="line">        duty_u16 = 0</span><br><span class="line">        delta_d = -delta_d</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="呼吸灯示例"><a href="#呼吸灯示例" class="headerlink" title="呼吸灯示例"></a>呼吸灯示例</h2><p>参考：<a target="_blank" rel="noopener" href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/03.PWMhuxideng">itproject.cn&#x2F;Python+ESP32快速上手&#x2F;3.PWM呼吸灯</a></p>
<p>esp32的micropython代码以script形式执行，主程序必须命名为main.py(参考 <a target="_blank" rel="noopener" href="https://docs.micropython.org/en/v1.9.3/pyboard/pyboard/tutorial/script.html">Running your first script</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from machine import Pin, PWM</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">led2 = PWM(Pin(2))</span><br><span class="line">led2.freq(1000)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    for i in range(0, 1024):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br><span class="line">        </span><br><span class="line">    for i in range(1023, -1, -1):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br></pre></td></tr></table></figure>

<p>LED渐变呼吸闪烁：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305052003803.gif" alt="mmexport1683287925729"></p>
<p>如果将led duty调整为512，最大亮度会变小，验证了最大占空比决定最大电压</p>
<p>如果将led freq调整为50，最大亮度不变，但led渐变过程中会闪烁，也就是说开关调节频率太低，导致人眼都可以观察到led的开关电，看上去就是led闪烁</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/04/esp32%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/04/esp32%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">esp32笔记之环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-04 13:07:23" itemprop="dateCreated datePublished" datetime="2023-05-04T13:07:23+08:00">2023-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-09 16:57:20" itemprop="dateModified" datetime="2023-05-09T16:57:20+08:00">2023-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/esp32/" itemprop="url" rel="index"><span itemprop="name">esp32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>esp32是乐鑫的SOC，支持Wifi, BLE等IOT功能；官方教程：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html">ESP-IDF编程指南</a></p>
<h1 id="ESP-IDF环境搭建"><a href="#ESP-IDF环境搭建" class="headerlink" title="ESP-IDF环境搭建"></a>ESP-IDF环境搭建</h1><p>按官方教程在Linux ubuntu搭建ESP-IDF开发环境，有clone idf一直失败的问题</p>
<p>本节记录不用翻墙搭建ESP-ID环境的过程，视频参考：<a target="_blank" rel="noopener" href="https://b23.tv/VCYbC2m">Linux 如何安装 ESP-IDF ESP32 开发环境搭建</a></p>
<h2 id="版本发布、下载"><a href="#版本发布、下载" class="headerlink" title="版本发布、下载"></a>版本发布、下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/releases">https://github.com/espressif/esp-idf/releases</a></p>
<p>手动下载release版本的idf压缩包，例如下载esp-idf-v5.0.1.zip</p>
<p>解压到 ~&#x2F;esp&#x2F;esp-idf (<code>mv esp-idf-v5.0.1 esp-idf</code>)</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git wget flex bison gperf python3 python3-venv python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0</span><br></pre></td></tr></table></figure>

<h2 id="安装-ESP-IDF"><a href="#安装-ESP-IDF" class="headerlink" title="安装 ESP-IDF"></a>安装 ESP-IDF</h2><p>安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">./install.sh esp32 #esp32 chip,用此命令即可</span><br><span class="line">./install.sh all #所有esp chips</span><br></pre></td></tr></table></figure>

<p>如果安装遇到网络问题，需要设置下载服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">export IDF_GITHUB_ASSETS=&quot;dl.espressif.com/github_assets&quot;</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>如果遇到 Python 包安装问题则需要设置 Python 源</p>
<h2 id="设置环境变量："><a href="#设置环境变量：" class="headerlink" title="设置环境变量："></a>设置环境变量：</h2><p>每次运行都export环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. $HOME/esp/esp-idf/export.sh</span><br></pre></td></tr></table></figure>

<p>或把将以下语句加入 ~&#x2F;.bashrc，每次执行只需要 <code>get_idf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias get_idf=&#x27;. $HOME/esp/esp-idf/export.sh&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="串口相关设置"><a href="#串口相关设置" class="headerlink" title="串口相关设置"></a>串口相关设置</h2><p><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/establish-serial-connection.html">与 ESP32 创建串口连接</a></p>
<p>查看串口: ls &#x2F;dev&#x2F;tty* (esp32应该是ttyUSB0)</p>
<p>必须将将用户添加到 <code>dialout</code> 组，从而获许串口读写权限，否则串口无法连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br></pre></td></tr></table></figure>

<h2 id="编译和烧录"><a href="#编译和烧录" class="headerlink" title="编译和烧录"></a>编译和烧录</h2><ul>
<li>设置：idf.py menuconfig</li>
<li>编译：idf.py build</li>
<li>烧录：idf.py -p PORT 【-b BAUD】 flash</li>
<li>监视：idf.py -p PORT monitor，使用快捷键 <code>Ctrl+]</code>，退出 IDF 监视器</li>
<li>一次性执行构建、烧录和监视过程：idf.py -p PORT flash monitor</li>
</ul>
<h1 id="MicroPython环境搭建"><a href="#MicroPython环境搭建" class="headerlink" title="MicroPython环境搭建"></a>MicroPython环境搭建</h1><p>分为esp32侧的Firmware和PC侧的IDE两部分。</p>
<p>本文是Linux环境，windows环境参考：<a target="_blank" rel="noopener" href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/01.dajianhuanjing">Thonny+MicroPython+ESP32开发环境搭建</a></p>
<h2 id="ESP32安装MicroPython"><a href="#ESP32安装MicroPython" class="headerlink" title="ESP32安装MicroPython"></a>ESP32安装MicroPython</h2><p>Micropython是在嵌入式平台上运行Python的基础库，参考：<a target="_blank" rel="noopener" href="https://docs.micropython.org/en/latest/">https://docs.micropython.org/en/latest/</a></p>
<p>下载和安装esp32的Micropython，参考：<a target="_blank" rel="noopener" href="https://micropython.org/download/esp32/">Installation instructions</a></p>
<p>先擦除flash, 其中esptool.py已经被esp-idf&#x2F;export.sh导出到环境变量；如果ls &#x2F;dev&#x2F;tty*显示有ttyUSB0，但esptool.py还找不到ttyUSB0，需要重启并用<code>get_idf</code>重新export idf，再插拔esp32就可以找到.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash</span><br></pre></td></tr></table></figure>

<p>烧写支持micropython的 &lt;esp32-firmware.bin&gt;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 &lt;esp32-firmware.bin&gt;</span><br></pre></td></tr></table></figure>

<p>例如我的Firmware使用的是：</p>
<p><strong><a target="_blank" rel="noopener" href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.bin">v1.20.0 (2023-04-26) .bin</a></strong> [<a target="_blank" rel="noopener" href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.elf">.elf]</a> [<a target="_blank" rel="noopener" href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.map">.map]</a> [<a target="_blank" rel="noopener" href="https://github.com/micropython/micropython/releases/tag/v1.20.0">Release notes]</a> (latest)</p>
<h2 id="使用VScode-Pymakr搭建Micropython开发环境"><a href="#使用VScode-Pymakr搭建Micropython开发环境" class="headerlink" title="使用VScode+Pymakr搭建Micropython开发环境"></a>使用VScode+Pymakr搭建Micropython开发环境</h2><p>总体的安装流程参考：<a target="_blank" rel="noopener" href="https://randomnerdtutorials.com/micropython-esp32-esp8266-vs-code-pymakr/">MicroPython: Program ESP32&#x2F;ESP8266 using VS Code and Pymakr</a></p>
<p>Pymakr如何使用，参考<a target="_blank" rel="noopener" href="https://github.com/pycom/pymakr-vsc/blob/next/GET_STARTED.md">Pymakr Getting Started</a></p>
<p>写一个LED闪烁的sample code验证开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from machine import Pin</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">led = Pin(2, Pin.OUT) #GPIO2, output mode</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">  led.value(not led.value())</span><br><span class="line">  sleep(0.5)</span><br></pre></td></tr></table></figure>

<p>LED如何控制，要根据esp32具体开发板的电路图找到LED相关的GPIO，以及配什么输入&#x2F;输出模式使GPIO导通&#x2F;关闭。</p>
<p>如下图，我的esp32 LED连接到GPIO2(IO2)，并且GPIO2输出高电平时LED导通</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042003091.png" alt="image-20230504200335998"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042004848.png" alt="image-20230504200411499"></p>
<p>选择VSCode的Pymakr Project -&gt; connect device -&gt; ’sync project to device‘，上传该LED python代码到esp32上运行；右键Pymakr Project的Hard reset device以后执行python代码</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051116409.png" alt="image-20230505111655320"></p>
<p>esp32 GPIO2的LED不停闪烁</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051156061.gif" alt="mmexport1683202673677"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
