<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/11/30/NVMe%E8%AE%BE%E5%A4%87%E7%9A%84Firmware%20Update%E5%85%A8%E6%A0%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EWindows%20Storport%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/30/NVMe%E8%AE%BE%E5%A4%87%E7%9A%84Firmware%20Update%E5%85%A8%E6%A0%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EWindows%20Storport%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">NVMe设备的Firmware Update全栈分析（一）：基于Windows Storport环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-30 17:41:00 / 修改时间：17:41:57" itemprop="dateCreated datePublished" datetime="2022-11-30T17:41:00+08:00">2022-11-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NVMe/" itemprop="url" rel="index"><span itemprop="name">NVMe</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update"><a href="#1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update" class="headerlink" title="1.1 Windows Storport Driver环境下的NVMe设备Firmware Update"></a>1.1 Windows Storport Driver环境下的NVMe设备Firmware Update</h2><p>Windows系统下，NVMe设备的Firmware Update都是基于以下Microsoft API文档 ：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/upgrading-firmware-for-an-nvme-device">upgrading-firmware-for-an-nvme-device</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/07/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程笔记：使用GDB调试多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-15 15:29:31" itemprop="dateCreated datePublished" datetime="2022-07-15T15:29:31+08:00">2022-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:46:24" itemprop="dateModified" datetime="2022-12-05T15:46:24+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-GDB简介"><a href="#1-GDB简介" class="headerlink" title="1.GDB简介"></a>1.GDB简介</h1><p>官网文档：<br><a target="_blank" rel="noopener" href="https://www.gnu.org/software/gdb/documentation/">GDB: The GNU Project Debugger</a></p>
<p>关于GDB的原理：<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1365186">GDB实现原理和使用范例</a><br><a target="_blank" rel="noopener" href="http://oenhan.com/gdb-principle">GDB工作原理和内核实现</a><br><a target="_blank" rel="noopener" href="http://www.docin.com/p-18618736.html">GDB的基本工作原理</a></p>
<p>其他教程：<a target="_blank" rel="noopener" href="http://c.biancheng.net/gdb/">GDB调试教程</a></p>
<p>几个重点：</p>
<ul>
<li>多种运行方式：gdb启动程序再调试(独立功能程序)，gdb attach进程再调试(服务端程序)，gdb加载core dump调试(离线调试)</li>
<li>GDB的本质是“截获”被调试程序，attach用ptrace截获了OS和应用程序之间的通信, 端点本质是trap中断，截获了CPU正常取指执行流程</li>
</ul>
<p>本文源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/SimpleMultiThread/tree/master/4.gdb_thread">cursorhu&#x2F;SimpleMultiThread&#x2F;4.gdb_thread&#x2F;</a></p>
<h1 id="2-多线程程序的GDB调试"><a href="#2-多线程程序的GDB调试" class="headerlink" title="2.多线程程序的GDB调试"></a>2.多线程程序的GDB调试</h1><p>待调试代码：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 0;
std::mutex g_mutex;

void thread_func1()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        if(g_mydata == 1024)
            g_mydata = 0;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);
    t1.join();
    t2.join();
    return 0;
&#125;
</code></pre>
<p>编译：</p>
<pre><code>g++ -g -std=c++11 cppthread.cpp -o cppthread -lpthread
</code></pre>
<p>-g: 带debug信息，gdb要用<br>-lpthread：链接pthread库。当应用直接调用POSIX&#x2F;pthread接口，或Linux环境中运行多线程都需要</p>
<h2 id="attach方式调试"><a href="#attach方式调试" class="headerlink" title="attach方式调试"></a>attach方式调试</h2><p>(1)后台运行并获取PID</p>
<ul>
<li>GDB调试已运行的程序，cppthread线程写成死循环，后台运行。</li>
<li>ps -ef | grep NAME 获取PID</li>
<li>pstree可以查看线程关系</li>
<li>LWP:轻量级进程，是用户线程和内核的中间接口。用户级线程连接LWP上便具有内核线程的所有属性。因此可以认为LWP ID对应线程ID</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534342.png" alt="1"></p>
<p>(2)gdb attach，管控进程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051544779.png" alt="2"></p>
<p>(3)查看所有线程信息<br>*表示当前在1号线程，注意这个ID是GDB attach后分配的，真实线程ID参考LWP<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534546.png" alt="3"></p>
<p>(4)查看线程backtrace<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535566.png" alt="4"></p>
<p>(5)切换线程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535346.png" alt="5"></p>
<p>(6)单步调试线程</p>
<ul>
<li>注意，GDB调试时是支持线程切换的，等同正常执行多线程，也可以禁用切换：<code>set scheduler-locking on</code>。本示例有mutex锁,未见到切换</li>
<li><code>next</code>: 单步（一步），<code>next n</code>: 单步n步</li>
<li><code>watch 变量</code>，可见<code>next 6</code>后g_mydata + 1</li>
<li><code>watch</code>会自动隐式的加断点，后文会看到断点信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535751.png" alt="6"></p>
<p>(7)断点</p>
<ul>
<li><code>break i</code>: 在代码i行加断点， <code>break func</code>:在函数加断点</li>
<li><code>clear i</code>: 清除i行的断点， <code>delete id</code>: 清除指定id的断点</li>
<li>注意看watch引入了一个断点11</li>
<li><code>continue</code>：继续执行，通常配合断点使用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535502.png" alt="7"></p>
<p>(8)线程外调试+多断点<br>两个工作线程都加断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535139.png" alt="8"><br>一次运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535180.png" alt="9"><br>继续运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536672.png" alt="10"></p>
<ul>
<li>Thread2和Thread3即工作线程，Thread1为主线程</li>
<li>Thread1会切到工作线程，LWP&#x3D;6080或6081</li>
<li>两次运行,Thread1切到的LWP不一样</li>
</ul>
<p>GDB显示主线程切到哪个工作线程，实际是CPU当前在执行哪个工作线程，因此两次运行到断点时，当前执行线程分别是Thread2和Thread3，主线程实际是阻塞的。</p>
<h2 id="GDB直接运行程序"><a href="#GDB直接运行程序" class="headerlink" title="GDB直接运行程序"></a>GDB直接运行程序</h2><p>用GDB运行程序的调试方式：</p>
<pre><code> gdb &lt; prog_name &gt;
</code></pre>
<p>(1)运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536065.png" alt="11"></p>
<p>(2)加断点和执行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536275.png" alt="12"></p>
<p>(3)查看变量值<br><code>p 变量</code>：打印变量，和<code>watch</code>相比不会加隐含的断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536108.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051537112.png" alt="14"></p>
<h2 id="core-dump文件方式调试"><a href="#core-dump文件方式调试" class="headerlink" title="core dump文件方式调试"></a>core dump文件方式调试</h2><p>有关core dump<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/computer1-2-3/p/11114981.html">Linux 下如何产生core文件（core dump设置）</a><br><a target="_blank" rel="noopener" href="https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/">Understand and configure core dumps on Linux</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/uhziel/p/cpp_segmentation_fault.html">C++中段错误的常见情况</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xuzhina/category_1322964.html">coredump问题原理探究(Linux版)
</a></p>
<p>下面修改前面的程序，制造core dump<br>(1)数组越界<br>cppthread_dump_array.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int g_mydata = 0;
std::mutex g_mutex;

char test_dump_buf[10] = &#123;0&#125;;

void thread_func1()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        char c;
        sprintf(&amp;c, &quot;%d&quot;, g_mydata);
        std::strcat(test_dump_buf, &amp;c); //持续追加g_mydata字符串
        if(g_mydata == 1024)
            g_mydata = 0;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;test_dump_buf: &quot; &lt;&lt; test_dump_buf &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538738.png" alt="15"><br>并未发生段错误，更不谈core dump。因为CPP对数组没有越界限制，这是个“合法”行为</p>
<p>(2)使用空指针<br>cppthread_dump_nullptr.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
&#123;
    public:
        Foo(int m)
        &#123;
            m_data = m;
        &#125;
        ~Foo()&#123;&#125;
        void printval() 
        &#123;
            std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
        &#125;
        void increase()
        &#123;
            ++m_data;
        &#125;
        int getval()
        &#123;
            return m_data;
        &#125;
        void resetval()
        &#123;
            m_data = 0;
        &#125;
        
    private:
        int m_data;
&#125;;

void thread_func1(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.increase();
        if(p.getval() == 1024)
            p.resetval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.printval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;    
    Foo *pFoo = new Foo(0);

    std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
    std::thread t2(thread_func2, std::ref(*pFoo));

    //t1.join();  //这里故意不join
    //t2.join();
    sleep(10);  //sleep等一下thread1,2
    
    delete pFoo; 
    pFoo = NULL;  //这时thread1,2还没执行完，形成了使用空指针的条件
            
    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538644.png" alt="16"></p>
<p>下面gdb调试这个core dump</p>
<ul>
<li><p>设置core dump文件大小限制为不受限<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538876.png" alt="17"><br>最好写入配置文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538835.png" alt="18"></p>
</li>
<li><p>gdb加载程序和core dump文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538139.png" alt="19"><br>可见siganl 6发生，使进程终止</p>
</li>
<li><p>看dump位置，bt或where都可以<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538557.png" alt="20"></p>
</li>
<li><p>看所有线程的栈<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538027.png" alt="21"></p>
</li>
<li><p>直接看dump附近的代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051539217.png"></p>
</li>
</ul>
<p>结论：根据bt&#x2F;where, dump发生时，主进程在在执行67行：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542767.png" alt="image-20221205154207720"></p>
<p>根据源码，具体是工作线程调用对象的方法时发生<br>再看dump打印，正好要打印<code>m_data = 10</code>的时候dump，结合main中sleep(10)和工作线程sleep(1)，dump原因是main把对象指针置空了，而两个工作线程还在调用对象的方法，位置是thread_func2的p.printval()处</p>
<h2 id="一个示例：调试死锁"><a href="#一个示例：调试死锁" class="headerlink" title="一个示例：调试死锁"></a>一个示例：调试死锁</h2><p>最常见的死锁是双重加锁，和双重delete的道理一样，代码复杂了，层层调用的情况下容易出现<br>示例代码cppthread_deadlock.cpp：<br>线程函数和其调用的类方法都加锁了，形成死锁</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
&#123;
    public:
        Foo(int m)
        &#123;
            m_data = m;
        &#125;
        ~Foo()&#123;&#125;
        void printval() 
        &#123;
            std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
        &#125;
        void increase()
        &#123;
            g_mutex.lock(); //故意制造双重加锁
            ++m_data;
            g_mutex.unlock();
        &#125;
        int getval()
        &#123;
            return m_data;
        &#125;
        void resetval()
        &#123;
            m_data = 0;    
        &#125;
        
    private:
        int m_data;
&#125;;

void thread_func1(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.increase();
        if(p.getval() == 1024)
            p.resetval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.printval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;    
    Foo *pFoo = new Foo(0);

    std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
    std::thread t2(thread_func2, std::ref(*pFoo));

    t1.join();
    t2.join();
    
    delete pFoo;
    pFoo = NULL;
            
    return 0;
&#125;
</code></pre>
<p>调试：</p>
<ul>
<li>直接运行方式，要run起来才有线程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542989.png" alt="23"></p>
<ul>
<li>backtrace可见两个线程都停止于lock_wait()，其中thread2回溯看到死锁代码在45行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051546645.png" alt="24"></p>
<p>对于互斥锁推荐用RAII机制的<code>std::lock_guard&lt;mutex&gt; lockGuard(m)</code>，能避免忘记unlock情况。但在此示例中，lock_guard也会双重加锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/07/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">多线程笔记：线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 15:21:30" itemprop="dateCreated datePublished" datetime="2022-07-12T15:21:30+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:24:35" itemprop="dateModified" datetime="2022-12-05T15:24:35+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>线程池的概念和相关示例可以参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/MOU_IT/article/details/88712090">C++实现线程池</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ailumiyana/p/10016965.html">基于C++11实现线程池的工作原理</a></p>
<p>本代码相关的C++基础，参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8459250.html">c++拷贝构造函数详解</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiayayao/archive/2016/12/03/6128877.html">智能指针shared_ptr的用法</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量</a></p>
<p>其他相关文章<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/9456fecb5f96">jorion&#x2F;c++11 多线程（X）</a><br><a target="_blank" rel="noopener" href="https://github.com/jorionwen/threadtest">jorionwen&#x2F;threadtest</a></p>
<h1 id="线程池示例"><a href="#线程池示例" class="headerlink" title="线程池示例"></a>线程池示例</h1><h2 id="调用线程池"><a href="#调用线程池" class="headerlink" title="调用线程池"></a>调用线程池</h2><pre><code>#include &quot;TaskPool.h&quot;
#include &lt;chrono&gt;

int main()
&#123;
    TaskPool threadPool;
    threadPool.init(); //初始化线程对象队列

    Task* task = NULL;
    for (int i = 0; i &lt; 10; ++i)
    &#123;
        task = new Task();
        threadPool.addTask(task); //初始化任务对象队列，调度线程时会取出执行
    &#125;
    
    std::this_thread::sleep_for(std::chrono::seconds(2));

    threadPool.stop(); //等待所有工作线程结束

    return 0; //析构
&#125;
</code></pre>
<h2 id="线程池的方法"><a href="#线程池的方法" class="headerlink" title="线程池的方法"></a>线程池的方法</h2><pre><code>#include &quot;TaskPool.h&quot;

TaskPool::TaskPool() : m_bRunning(false)
&#123;

&#125;

TaskPool::~TaskPool()
&#123;
    removeAllTasks();
&#125;

void TaskPool::init(int threadNum/* = 5*/)
&#123;
    if (threadNum &lt;= 0)
        threadNum = 5;

    m_bRunning = true;

    for (int i = 0; i &lt; threadNum; ++i)
    &#123;
        std::shared_ptr&lt;std::thread&gt; spThread;
        //shared_ptr.reset带参数是初始化，指向new出的thread对象
        //bind绑定了thread对象和其执行函数threadFunc
        spThread.reset(new std::thread(std::bind(&amp;TaskPool::threadFunc, this))); 
        m_threads.push_back(spThread); //thread对象入队
    &#125;
&#125;

void TaskPool::threadFunc() //thread对象唤醒时执行
&#123;
    std::shared_ptr&lt;Task&gt; spTask;
    while (true)
    &#123;
        std::unique_lock&lt;std::mutex&gt; guard(m_mutexList); //RAII实现，作用域结束自动解锁
        while (m_taskList.empty())
        &#123;                 
            if (!m_bRunning)
                break;
            
            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
            m_cv.wait(guard);
        &#125;

        if (!m_bRunning)
            break;

        spTask = m_taskList.front(); //取m_taskList的task对象
        m_taskList.pop_front(); //更新m_taskList

        if (spTask == NULL)
            continue;

        spTask-&gt;doIt(); //执行task
        spTask.reset(); //shared_ptr.reset不带参数，指向对象的计数-1
    &#125;

    std::unique_lock&lt;std::mutex&gt; guard(m_mutexList); //为了打印的原子性，再加锁
    &#123;
        std::cout &lt;&lt; &quot;Exit thread, threadID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    &#125;
    
&#125;

void TaskPool::stop()
&#123;
    m_bRunning = false;
    m_cv.notify_all(); //唤醒所有等待条件变量的线程

    //等待所有线程退出
    for (auto&amp; iter : m_threads)
    &#123;
        if (iter-&gt;joinable())   //该线程是否可join
            iter-&gt;join();       //主线程等待该线程
    &#125;
&#125;

void TaskPool::addTask(Task* task)
&#123;
    std::shared_ptr&lt;Task&gt; spTask;
    spTask.reset(task); //shared_ptr初始化，指向task

    &#123;
        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);       
        //m_taskList.push_back(std::make_shared&lt;Task&gt;(task));
        m_taskList.push_back(spTask); //Task对象入队
        std::cout &lt;&lt; &quot;Add a Task.&quot; &lt;&lt; std::endl;
    &#125;
    
    m_cv.notify_one(); //唤醒随机一个等待条件变量的线程
&#125;

void TaskPool::removeAllTasks()   //析构时调用
&#123;
    &#123;
        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);
        for (auto&amp; iter : m_taskList)
        &#123;
            iter.reset();
        &#125;
        m_taskList.clear();
    &#125;
&#125;
</code></pre>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><pre><code>#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt; //for visual studio build

class Task
&#123;
public:
    virtual void doIt()
    &#123;
        std::cout &lt;&lt; &quot;Do a task...&quot; &lt;&lt; std::endl;
    &#125;

    virtual ~Task()
    &#123;
        //为了看到一个task的销毁，这里刻意补上其析构函数
        std::cout &lt;&lt; &quot;A task destructed...&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

class TaskPool final
&#123;
public:
    TaskPool();
    ~TaskPool();
    TaskPool(const TaskPool&amp; rhs) = delete;     //delete: 禁用某函数（C++11），阻止拷贝和赋值构造，C++98用private
    TaskPool&amp; operator=(const TaskPool&amp; rhs) = delete;

public:
    void init(int threadNum = 5);   //默认初始化
    void stop();

    void addTask(Task* task);
    void removeAllTasks();

private:
    void threadFunc();

private:
    std::list&lt;std::shared_ptr&lt;Task&gt;&gt;            m_taskList;
    std::mutex                                  m_mutexList;
    std::condition_variable                     m_cv;
    bool                                        m_bRunning;
    std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt;   m_threads;
&#125;;
</code></pre>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221205152435385.png" alt="image-20221205152435385"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/07/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">多线程笔记：线程库的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 15:21:19" itemprop="dateCreated datePublished" datetime="2022-07-02T15:21:19+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:27:27" itemprop="dateModified" datetime="2022-12-05T15:27:27+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>多线程概述：应用层的多线程的目的就是让每一个任务（例如一系列函数调用）都认为自己独占CPU资源，即宏观上，多个任务可以同时执行（实际可能是轮转的串行执行）。<br>代码实现：线程库可以由编程语言的标准库或者操作系统的库实现，具体包含的头文件如下：</p>
<ul>
<li>C&#x2F;C++ : &lt; thread &gt;</li>
<li>POSIX(Portable Operating System Interface of UNIX, Linux环境使用较多) ：&lt; pthread.h &gt;</li>
<li>Windows OS : &lt; windows.h &gt;</li>
</ul>
<p>具体环境使用哪个库，有不同的观点，参考<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36236334/answer/98422670">c++多线程编程主要用pthread还是c++11中的thread类？</a><br>即使是同一环境，也有不同封装层次的API<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22642239/article/details/90445414">CreateThread()与_beginthread()的区别详细解析</a></p>
<p>主线程与工作线程：<br>一般应用程序都有主要的执行流程，例如C&#x2F;C++的main入口函数，主要执行流程是在进程中执行的，也可以认为main是线程，独占了进程的全部资源，称为主线程。如果在该进程执行时，创建多个线程，用于并行处理其他任务，称为工作线程。</p>
<p>本文讲不同风格的线程创建\销毁，和访问共享数据的锁操作<br>本系列源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="Windows风格多线程"><a href="#Windows风格多线程" class="headerlink" title="Windows风格多线程"></a>Windows风格多线程</h1><p>(1)双线程打印</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s &lt;&lt; endl;
    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    CloseHandle(hThread);
    
    return 0;
&#125;
</code></pre>
<p>主线程和工作线程都运行Print()，各线程的栈空间保存自己的局部数据。<br>windows API使用CreateThread和CloseHandle创建线程、释放线程句柄，说明如下</p>
<pre><code>HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD：线程安全相关的属性，常置为NULL
    SIZE_T dwStackSize,//initialstacksize：新线程的初始化栈的大小，可设置为0
    LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction：被线程执行的回调函数，也称为线程函数
    LPVOID lpParameter,//threadargument：传入线程函数的参数，不需传递参数时为NULL
    DWORD dwCreationFlags,//creationoption：控制线程创建的标志
    LPDWORD lpThreadId//threadidentifier：传出参数，用于获得线程ID，如果为NULL则不返回线程ID
    )
 
/*
lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，决定返回的句柄是否可被子进程继承，如果为NULL则表示返回的句柄不能被子进程继承。
dwStackSize：设置初始栈的大小，以字节为单位，如果为0，那么默认将使用与调用该函数的线程相同的栈空间大小。
任何情况下，Windows根据需要动态延长堆栈的大小。
lpStartAddress：指向线程函数的指针，函数名称没有限制，但是必须以下列形式声明：
DWORD WINAPI 函数名 (LPVOID lpParam) ，格式不正确将无法调用成功。
lpParameter：向线程函数传递的参数，是一个指向结构的指针，不需传递参数时，为NULL。
dwCreationFlags：控制线程创建的标志，可取值如下：
（1）CREATE_SUSPENDED(0x00000004)：创建一个挂起的线程（就绪状态），直到线程被唤醒时才调用
（2）0：表示创建后立即激活。
（3）STACK_SIZE_PARAM_IS_A_RESERVATION(0x00010000)：dwStackSize参数指定初始的保留堆栈的大小，
如果STACK_SIZE_PARAM_IS_A_RESERVATION标志未指定，dwStackSize将会设为系统预留的值
lpThreadId:保存新线程的id
返回值：函数成功，返回线程句柄，否则返回NULL。如果线程创建失败，可通过GetLastError函数获得错误信息。
*/
 
BOOL WINAPI CloseHandle(HANDLE hObject);        //关闭一个被打开的对象句柄
/*可用这个函数关闭创建的线程句柄，如果函数执行成功则返回true(非0),如果失败则返回false(0)，
如果执行失败可调用GetLastError.函数获得错误信息。
*/
</code></pre>
<p>LPVOID 与 std::string类型的转换，需要用char*类型作中介，LPVOID接受buffer数组类型的转换<br>注意CloseHandle只是释放句柄资源，线程的资源释放是其函数执行完毕自动销毁的。</p>
<p>2次的运行结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png" alt="image-20221205152628474"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png"></p>
<p>可见，两个线程是随机切换的，导致如下现象：</p>
<ul>
<li>Print()内的<code>cout &lt;&lt; s</code>和<code>&lt;&lt;endl</code>之间线程被切换，导致没有换行+双重换行。</li>
<li>存在工作线程没执行完，主线程就执行完导致main return，整个进程销毁的情况。</li>
</ul>
<p>改进如下：</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s;
    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread\n&quot;;
    std::string s2 = &quot;Main thread\n&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    CloseHandle(hThread);
    Sleep(100);
    return 0;
&#125;
</code></pre>
<p>使用以下方法解决上述问题</p>
<ul>
<li><p>主线程完成Print后，休眠100s，这个时间足够工作线程完成，Sleep结束后，main进程执行完毕</p>
</li>
<li><p>把换行放到字符串中，使该字符串的完整打印成为不可被中途切换的操作，即原子操作</p>
</li>
</ul>
<p>输出如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526645.png" alt="image-20221205152645608"></p>
<p>如果Print有很多句打印，又不希望中途切换线程，如何做？</p>
<ul>
<li>互斥锁可以实现“大块代码的原子操作”</li>
<li>锁是全局变量，因为主线程main和工作线程Print都能看到全局变量，而看不到对方的局部变量</li>
</ul>
<p>代码如下:</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
HANDLE hMutex = NULL;//互斥锁的句柄

DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;

    for (int i = 0; i &lt; 10; i++)
    &#123;
        WaitForSingleObject(hMutex, INFINITE);//请求锁
        cout &lt;&lt; s &lt;&lt; endl;
        ReleaseMutex(hMutex);//释放锁
    &#125;

    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;

    hMutex = CreateMutex(NULL, FALSE, NULL); //创建互斥锁
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    
    CloseHandle(hThread);
    CloseHandle(hMutex);//销毁互斥锁
    
    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526485.png" alt="image-20221205152654439"><br>关于windows的互斥锁：</p>
<pre><code>互斥量：
        采用互斥对象机制。互斥锁，像一个物件，这个物件只能同时被一个线程持有。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。
        一、创建 创建互斥锁的方法是调用函数CreateMutex： CreateMutex(&amp;sa, bInitialOwner, szName);第一个参数是一个指向SECURITY_ATTRIBUTES结构体的指针，一般的情况下，可以是nullptr。 第二个参数类型为BOOL，表示互斥锁创建出来后是否被当前线程持有。 第三个参数类型为字符串（const TCHAR*），是这个互斥锁的名字，如果是nullptr，则互斥锁是匿名的。 例： HANDLE hMutex = CreateMutex(nullptr, FALSE, nullptr);上面的代码创建了一个匿名的互斥锁，创建出来后，当前线程不持有这个互斥锁。

         二、持有 WaitForSingleObject函数可以让一个线程持有互斥锁。用法： WaitForSingleObject(hMutex, dwTimeout);这个函数的作用比较多。这里只介绍第一个参数为互斥锁句柄时的作用。 它的作用是等待，直到一定时间之后，或者，其他线程均不持有hMutex。第二个参数是等待的时间（单位：毫秒），如果该参数为INFINITE，则该函数会一直等待下去。

        三、释放 用ReleaseMutex函数可以让当前线程“放开”一个互斥锁（不持有它了），以便让其他线程可以持有它。用法 ReleaseMutex(hMutex)

         四、销毁 当程序不再需要互斥锁时，要销毁它。 CloseHandle(hMutex)

         五、命名互斥锁 如果CreateMutex函数的第三个参数传入一个字符串，那么所创建的锁就是命名的。当一个命名的锁被创建出来以后，当前进程和其他进程如果试图创建相同名字的锁，CreateMutex会返回原来那把锁的句柄，并且GetLastError函数会返回ERROR_ALREADY_EXISTS。这个特点可以使一个程序在同一时刻最多运行一个实例
</code></pre>
<h1 id="C-风格多线程"><a href="#C-风格多线程" class="headerlink" title="C++风格多线程"></a>C++风格多线程</h1><p>双线程分别实现计算和打印</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 1;
std::mutex g_mutex;

void thread_func1()
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>几点说明：</p>
<ul>
<li>C++使用&lt; thread &gt;调用线程库</li>
<li>std::thread t(thread_func)创建一个thread对象，传入参数为thread_fun，即线程内执行的函数</li>
<li>t.join()的含义是，线程t执行完毕后，join函数才能返回，主线程才能继续向后执行，宏观上就是，主线程被t线程阻塞在join函数处，这也许就是join的含义，t线程“加入”主线程的队伍，主线程必须原地等待t准备好了（执行完了）才能继续向后走。</li>
<li>由于全局数据g_mydata和打印语句都不是原子操作，要保证完整操作，需要加锁，库定义在&lt; mutex &gt;</li>
<li>为什么要sleep? 注意两个工作线程都while循环操作，sleep是手动使当前线程休眠，操作系统会轮换到其他active状态的线程执行，如果不sleep, 一个线程一直执行再被OS切换，间隔可能很久。&lt; chrono &gt;库用于时间</li>
<li>INT_MAX是C++定义的int类最大值，2^31-1</li>
</ul>
<p>运行结果:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051527091.png" alt="image-20221205152705047"></p>
<h1 id="POSIX-x2F-Linux风格"><a href="#POSIX-x2F-Linux风格" class="headerlink" title="POSIX&#x2F;Linux风格"></a>POSIX&#x2F;Linux风格</h1><p>逻辑同上节，代码如下</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;limits.h&gt; //for INT_MAX

int g_mydata = 1;
pthread_mutex_t m;

void* thread_function1(void* args)
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        pthread_mutex_lock(&amp;m);
        ++g_mydata;
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    &#125;
    
    return NULL;
&#125; 

void* thread_function2(void* args)
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;    
        pthread_mutex_lock(&amp;m);
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl;
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    &#125;
    
    return NULL;
&#125; 

int main()
&#123;
    pthread_mutex_init(&amp;m, NULL);
    
    pthread_t threadIDs[2];    
    pthread_create(&amp;threadIDs[0], NULL, thread_function1, NULL);
    pthread_create(&amp;threadIDs[1], NULL, thread_function2, NULL);
    
    for(int i = 0; i &lt; 2; ++i)
    &#123;
        pthread_join(threadIDs[i], NULL);
    &#125;
    
    pthread_mutex_destroy(&amp;m);

    return 0;
&#125;
</code></pre>
<p>win32应用程序使用pthread，需要配置pthread dll库，下载地址和配置方法：<br><a target="_blank" rel="noopener" href="http://sourceware.org/pthreads-win32/">pthreads-win32</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhigang/p/7326022.html">VS2013 配置pthread</a></p>
<p>pthread的几个锁，参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/guotianqing/article/details/80559865">linux线程互斥量pthread_mutex_t使用简介</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/04/18/Qt%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-1.RGB%E8%B0%83%E8%89%B2%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/Qt%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-1.RGB%E8%B0%83%E8%89%B2%E5%99%A8/" class="post-title-link" itemprop="url">Qt学习之路-1.RGB调色器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-18 11:49:00" itemprop="dateCreated datePublished" datetime="2022-04-18T11:49:00+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-17 14:11:27" itemprop="dateModified" datetime="2022-05-17T14:11:27+08:00">2022-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文基于Qt官方示例<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/designer-quick-start.html#:~:text=%20Using%20Qt%20Designer%20involves%20four%20basic%20steps%3A,the%20slots%204%20Preview%20the%20form%20More%20"> A Quick Start to Qt Designer</a>, 实现自定义的slot函数，新增RGB色彩窗口显示色彩。</p>
<ul>
<li>本文源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/QtSampleTest/tree/master/1.rgbSlider">QtSampleTest&#x2F;1.rgbSlider</a></li>
<li>环境：基于Qt5.9 + Qt creater</li>
</ul>
<p>本文只记录项目过程中的注意事项，以及增量开发，其他部分参考Qt官方示例。</p>
<h2 id="1-UI部分"><a href="#1-UI部分" class="headerlink" title="1.UI部分"></a>1.UI部分</h2><ul>
<li>建立带UI的项目rgbSlider, 基于Qwidget生成默认自定义类名widget</li>
<li>双击widget.ui进入UI编辑</li>
</ul>
<p>UI 编辑模式下使用两种模式：widget编辑模式， slot&#x2F;signal编辑模式</p>
<ol>
<li><p>widget编辑模式如下：使用水平、网格布局<br>RGB数值控制部分，使用Label,  spinBox和scrollBar三种控件，按先竖直，后水平排列<br>RGB颜色显示部分，使用 graphicsView窗口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181201206.png"><br>注意调整布局的比例需要先选中，然后在layout属性调整<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181202783.png"></p>
</li>
<li><p>slot&#x2F;signal编辑模式<br>直接拖拽起始控件和目标控件，设置控件的信号和槽<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181203784.png"></p>
</li>
</ol>
<h2 id="2-自定义槽"><a href="#2-自定义槽" class="headerlink" title="2.自定义槽"></a>2.自定义槽</h2><p>graphicsView窗口预期效果是：只要调整RGB数值，自动显示对应的颜色<br>UI界面不能设置控件信号触发自定义槽，需要在代码中实现信号和槽的连接。</p>
<ol>
<li>右键转到graphicsView窗口的槽函数，自定义为 <code>Widget::on_rgbChanged()</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181400431.png"><br>函数实现如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;QColor&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;QPalette&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_rgbChanged()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> QPalette pal = QPalette();</span><br><span class="line"></span><br><span class="line"> QColor color;</span><br><span class="line"></span><br><span class="line"> //分别设置R,G,B,透明度</span><br><span class="line"></span><br><span class="line"> color.setRgb(ui-&gt;spinBoxRed-&gt;value(), ui-&gt;spinBoxGreen-&gt;value(), ui-&gt;spinBoxBlue-&gt;value(), 255);</span><br><span class="line"></span><br><span class="line"> //QPalette::Base</span><br><span class="line"></span><br><span class="line"> //Used mostly as the background color for text entry widgets, It is usually white or another light color.</span><br><span class="line"></span><br><span class="line"> pal.setColor(QPalette::Base, color);</span><br><span class="line"></span><br><span class="line"> ui-&gt;graphicsView-&gt;setPalette(pal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在UI基础上使用控件对象的方法，只需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;控件名-&gt;控件的方法</span><br></pre></td></tr></table></figure>

<p>注意<code>setColor</code>可以给不同图层上色，这里使用<code>QPalette::Base</code>，而不能是<code>QPalette::Window</code>或<code>QPalette::Background</code></p>
<p>代码设置信号与槽, 注意，手动设置的代码要在<code>ui-&gt;setupUi(this);</code>的后面添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line"></span><br><span class="line"> QWidget(parent),</span><br><span class="line"></span><br><span class="line"> ui(new Ui::Widget)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxRed, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxGreen, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxBlue, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3.测试效果"></a>3.测试效果</h2><ul>
<li>拖动滑块，对应数值会更新，颜色同步更新</li>
<li>修改数值，对应滑块更新，颜色更新<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181410181.png"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/03/25/Linux%20MMC%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84UHS-II%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/25/Linux%20MMC%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84UHS-II%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">Linux MMC框架下的UHS-II驱动调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-25 11:21:00" itemprop="dateCreated datePublished" datetime="2022-03-25T11:21:00+08:00">2022-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-17 14:43:49" itemprop="dateModified" datetime="2022-08-17T14:43:49+08:00">2022-08-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Linux-MMC-框架现状"><a href="#1-Linux-MMC-框架现状" class="headerlink" title="1. Linux MMC 框架现状"></a>1. Linux MMC 框架现状</h2><p>Linux MMC driver是支持包括SD卡，eMMC卡等等，属于MultiMediaCard设备和接口的驱动<br>其源码路径位于Kernel source code的drivers&#x2F;mmc路径, 头文件位于include&#x2F;linux&#x2F;mmc<br>mmc源码分为core&#x2F;host两层，是为了解耦：</p>
<ul>
<li>通用的SD&#x2F;eMMC流程(core)</li>
<li>具体的硬件操作流程(host)，在此层又可分为通用的SDHCI框架和非SDHCI框架，各eMMC&#x2F;SD host厂商实现最底层driver时，可以遵循SDHCI框架下的API, 间接实现core层定义的方法(driver称为operations), 也可以不遵循SDHCI框架，直接实现core层定义的方法。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301058425.png"></li>
</ul>
<p>本文重点关注mmc框架对SD卡驱动的支持</p>
<h3 id="1-1-SD卡的类型概述"><a href="#1-1-SD卡的类型概述" class="headerlink" title="1.1 SD卡的类型概述"></a>1.1 SD卡的类型概述</h3><p>SD卡可以分为三种类型：<br>UHS-I, UHS-II, SD express</p>
<p>详细信息参考<a target="_blank" rel="noopener" href="https://www.sdcard.org/">https://www.sdcard.org</a></p>
<ul>
<li>Physical Layer Specification Ver.7.10 (从各层描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD Host Controller Specification Ver7.0 (从host控制器角度，描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD_Specifications_Part_1_UHS_II_Addendum(描述SD UHSII的附录规范)</li>
</ul>
<p>UHS即Ultra High Speed, express也表示高速，这三代SD卡的读写速度是依次增加，参考下图：</p>
<ul>
<li>UHSI：50~104MB&#x2F;s</li>
<li>UHSII: 156~624MB&#x2F;s</li>
<li>SD express: 985MB&#x2F;s</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301119947.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301120184.png"></p>
<h3 id="1-2-Linux-MMC框架对SD卡的支持"><a href="#1-2-Linux-MMC框架对SD卡的支持" class="headerlink" title="1.2 Linux MMC框架对SD卡的支持"></a>1.2 Linux MMC框架对SD卡的支持</h3><p>基本概念：只有mmc框架的core层支持某种SD模式，host层才能实现这种模式；如果core层都不支持，只能厂商自己开发core层，以patch补丁的方式发布。</p>
<p>core层对于上述三种SD模式的支持：</p>
<ul>
<li>Linux kernel 5.11 以前，只支持UHS-I及其更低速度的legacy-SD模式</li>
<li>Linux kernel 5.11 开始，在core层添加了SD express的支持</li>
<li>目前没有UHS-II的支持，只有提交待审核的，参考：<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/?q=Jason%20Lai">lore.kernel.org&#x2F;Jason Lai&#x2F;patch</a></li>
</ul>
<p>host层对于上述三种SD模式的支持：</p>
<ul>
<li>UHS-I: 基本host目录的大多数SD厂商驱动都支持，很多符合sdhci框架</li>
<li>SD express: Realtek基于Linux kernel 5.11的core层API, 实现了 驱动的host底层部分，参考kernel的host&#x2F;rtsx_pci_sdmmc.c, 其没有使用SDHCI框架。</li>
<li>UHS-II: 只有以patch方式实现的，参考<a target="_blank" rel="noopener" href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a>，其实现了core&#x2F;host-sdhci&#x2F;host vendor多个层次的UHS-II支持。</li>
</ul>
<p>综上所述，本文参考uhs2-gl8755 patch，实现自己的SD UHSII driver。</p>
<h2 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2. 编译过程"></a>2. 编译过程</h2><p>本节描述编译mmc driver module和整个kernel的过程，同时描述中间踩的坑。</p>
<h3 id="2-1-直接编译整个Kernel-带UHS-II-Patch"><a href="#2-1-直接编译整个Kernel-带UHS-II-Patch" class="headerlink" title="2.1 直接编译整个Kernel(带UHS-II Patch)"></a>2.1 直接编译整个Kernel(带UHS-II Patch)</h3><p>安装Linux Ubuntu 20版本，Ubuntu环境下载和解压待编译的整个Linux kernel 源码：<a target="_blank" rel="noopener" href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a></p>
<p>注意：一定要在Linux环境下解压待编译源码，不能在windows下解压再拷到Linux编译，因为源码中有些大小写不同的同名文件，例如net&#x2F;netfilter的很多头文件。windows不区分大小，解压时写会让你替换或重命名，这些同名文件的内容不一样，所以不能替换或重命名，强行替换会导致编译Linux报错找不到相关文件。</p>
<ol>
<li><p>编译环境准备<br>gcc&#x2F;make等工具，都需要先安装build-essential才能使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置，编译和安装 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd linux-uhs2-gl9755-v3-patch #进入待编译Kernel源码</span><br><span class="line">make menuconfig #配置内核，生成.config文件</span><br><span class="line">make -j4 #以4线程编译内核，等同于make bzImage，make modules</span><br><span class="line">make modules_install #安装各Driver模块</span><br><span class="line">make install #安装内核(包括更新模块信息)</span><br></pre></td></tr></table></figure>
<p>编译完成后会自动update-grub, 重启后选择编译好的kernel版本启动。</p>
</li>
</ol>
<p>也可以设置默认启动的kernel，编辑&#x2F;etc&#x2F;default&#x2F;grub的<code>GRUB_DEFAULT=&quot;1&gt;X&quot;</code>, 其中1表示从advanced选项启动，X表示从哪个kernel启动(0 based)，例如下图如果默认要从5.19启动，X设置为0，默认从5.8.0-rc4启动，X设置为6.<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202208171414943.png"><br>配置完毕update-grub重启生效</p>
<ol start="3">
<li><p>查看内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r #查看当前运行的kernel版本</span><br><span class="line">cat Makefile #查看待编译kernel源码的内核版本</span><br></pre></td></tr></table></figure>
<p>以linux-uhs2-gl9755-v3-patch为例，其根目录Makefile如下，表示kernel源码版本为 5.8.0-rc4<br>编译完成重启后应该选择5.8.0-rc4启动，进入桌面后用<code>uname -r</code>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VERSION = 5</span><br><span class="line">PATCHLEVEL = 8</span><br><span class="line">SUBLEVEL = 0</span><br><span class="line">EXTRAVERSION = -rc4</span><br><span class="line">NAME = Kleptomaniac Octopus</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译报错记录<br>(1) 生成vmlinux Image时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to generate BTF for vmlinux  </span><br><span class="line">Try to disable CONFIG_DEBUG_INFO_BTF</span><br></pre></td></tr></table></figure>
<p>修改Kernel源码根目录的.config文件，CONFIG_DEBUG_INFO_BTF&#x3D;n 关闭此选项</p>
</li>
</ol>
<p>(2) 编译完成，但运行新kernel时报错<code>out of memory</code><br>解决办法：裁剪module大小，编译模块时使用 <code>make  INSTALL_MOD_STRIP=1 modules_install</code>，.ko被编译时会缩减非必要的debug信息。</p>
<h3 id="2-2-合并UHSII-patch后再编译整个Kernel"><a href="#2-2-合并UHSII-patch后再编译整个Kernel" class="headerlink" title="2.2 合并UHSII patch后再编译整个Kernel"></a>2.2 合并UHSII patch后再编译整个Kernel</h3><p>官方kernel源码可以到<a target="_blank" rel="noopener" href="https://www.kernel.org/">kernel.org</a>下载</p>
<p>合并UHSII patch，仅涉及到mmc模块的代码，如果差异不大可以将linux-uhs2-gl9755-v3-patch的drivers&#x2F;mmc和include头文件直接拷到待编译kernel的drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc。</p>
<p>如果是手动合并UHS-II patch，需要考虑以下部分：</p>
<ul>
<li>源码，包括drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc</li>
<li>Makefile, 包括drivers&#x2F;mmc&#x2F;core和drivers&#x2F;mmc&#x2F;host</li>
<li>Kconfig, 包括drivers&#x2F;mmc，及其子目录core和host</li>
</ul>
<p>具体合并方法参考《Linux设备驱动开发详解》<br>合并完后，Kernel编译流程和上节相同</p>
<h3 id="2-3-单独编译MMC模块"><a href="#2-3-单独编译MMC模块" class="headerlink" title="2.3 单独编译MMC模块"></a>2.3 单独编译MMC模块</h3><p>一般的驱动开发，都是可以单独编译成module模块，然后用rmmod和insmod替换原系统的模块</p>
<p>但是UHS-II patch涉及到mmc&#x2F;core层的改动，而core是build-in的，不能作为模块编译，因此只能编译整个kernel。以后如果只修改host层的代码，可以将mmc&#x2F;host单独编译为module后安装。</p>
<p>待编译kernel目录是<code>~/linux-5.8-rc4</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#编译模块，&quot;M=&quot;指定待编译源码，编译完拷贝.ko到&quot;-C&quot;指定的目录，此目录为系统存放模块的目录</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc</span><br><span class="line"></span><br><span class="line">#安装模块</span><br><span class="line">make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc modules_install</span><br><span class="line">	</span><br><span class="line">#清除模块,包括.o和.ko文件</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc clean</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/kbuild/modules.html"># Building External Modules</a></p>
<p>注意，<code>make xxx modules_install</code>是不能让模块自动加载的，只是安装到了&#x2F;lib&#x2F;modules位置。使用<code>modinfo</code>查看模块信息，似乎是使用了&#x2F;lib&#x2F;modules下的，但没有实际加载和生效。<br>要加载模块，两种方法：</p>
<ol>
<li>rmmod&#x2F;insmod 手动替换, 参考下一节</li>
<li>make modules_install 之后再 make install，更新整个kernel, 此后外部模块才会被内核自动加载（通常使用这种方式）</li>
</ol>
<h3 id="2-4-手动替换MMC模块"><a href="#2-4-手动替换MMC模块" class="headerlink" title="2.4 手动替换MMC模块"></a>2.4 手动替换MMC模块</h3><h4 id="2-4-1-UHS-II相关模块的依赖关系"><a href="#2-4-1-UHS-II相关模块的依赖关系" class="headerlink" title="2.4.1 UHS-II相关模块的依赖关系"></a>2.4.1 UHS-II相关模块的依赖关系</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301640662.png"></p>
<p>可以从mmc&#x2F;host的Kconfig得知依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config MMC_SDHCI_PCI</span><br><span class="line">	tristate &quot;SDHCI support on PCI bus&quot;</span><br><span class="line">	depends on MMC_SDHCI &amp;&amp; PCI</span><br><span class="line">	select MMC_SDHCI_UHS2</span><br><span class="line">	</span><br><span class="line">config MMC_SDHCI_UHS2</span><br><span class="line">	tristate &quot;UHS2 support on SDHCI controller&quot;</span><br><span class="line">	depends on MMC_SDHCI</span><br></pre></td></tr></table></figure>

<p>使用<code>lsmod</code>可以得知module依赖关系，如下图，sdhci_uhs2被sdhci_pci引用1次, sdhci被sdhci_uhs2和sdhci_pci引用2次<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645712.png"><br><code>modinfo</code>可以得知已加载module的.ko路径<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645737.png"></p>
<h4 id="2-4-2-手动卸载和装载module"><a href="#2-4-2-手动卸载和装载module" class="headerlink" title="2.4.2 手动卸载和装载module"></a>2.4.2 手动卸载和装载module</h4><p>卸载和装载都要按依赖顺序处理，shell脚本如下.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">sudo rmmod sdhci_pci</span><br><span class="line">sudo rmmod sdhci_uhs2</span><br><span class="line">sudo rmmod sdhci</span><br><span class="line"></span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-uhs2.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-pci.ko </span><br></pre></td></tr></table></figure>
<h2 id="3-调试过程"><a href="#3-调试过程" class="headerlink" title="3. 调试过程"></a>3. 调试过程</h2><h3 id="3-1-调试工具"><a href="#3-1-调试工具" class="headerlink" title="3.1 调试工具"></a>3.1 调试工具</h3><ol>
<li>printk<br>printk是很常用的driver调试手段，配合dmesg查看kernel log可以定位常见问题。<br>printk如何开启不同打印级别，参考<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/core-api/printk-basics.html"># Message logging with printk</a></li>
</ol>
<p>例如，使用<code>dmesg -n 6</code>开启KERN_INFO级别，然后在driver中添加pr_info()作为info打印, 在dmesg中查看打印log。</p>
<p>注意KERN_DEBUG比较特殊，不仅要<code>dmesg -n 7</code>开启, 还需要在driver module的makefile添加Debug CFLAGS, 有两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#该Makefile相关模块全部启用debug</span><br><span class="line">EXTRA_CFLAGS += -DDEBUG</span><br><span class="line"></span><br><span class="line">#指定模块启用debug</span><br><span class="line">CFLAGS-xxx-mmc += -DDEBUG</span><br></pre></td></tr></table></figure>
<p>示例：使用<code>pr_info(“enter %s\n”, __FUNCTION__);</code> 打印函数调用流程</p>
<ol start="2">
<li>dmesg<br>示例参考 <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/how-to-use-the-dmesg-command-on-linux/"># How to use the dmesg Command on Linux</a><br>比较常用的有：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg</span><br><span class="line">sudo dmesg -c </span><br><span class="line">sudo dmesg | head -100</span><br><span class="line">sudo dmesg | tail</span><br><span class="line">sudo dmesg | xxx</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.vscode<br>vscode比vim&#x2F;gedit更方便直接改代码，用.deb安装容易失败，推荐命令行安装方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#更新相关microsoft源</span><br><span class="line">wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] \</span><br><span class="line">https://packages.microsoft.com/repos/code stable main&quot; &gt; /etc/apt/sources.list.d/vscode.list&#x27;</span><br><span class="line"></span><br><span class="line">rm -f packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install code</span><br></pre></td></tr></table></figure>
<h3 id="3-2-UHSII调试"><a href="#3-2-UHSII调试" class="headerlink" title="3.2 UHSII调试"></a>3.2 UHSII调试</h3><ol>
<li><p>模块加载初始化过程中dmesg显示直接dump<br>基本是空指针问题，例如：</p>
<ul>
<li>只编译UHSII host 模块，而不编译kernel的core层，insmod host模块时就会dump, 因为core层相关API不存在。</li>
<li>获取相关数据结构方法不对导致空指针<br>例如获取slot要使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  struct sdhci_pci_slot *slot = sdhci_priv(host);</span><br><span class="line"></span><br><span class="line">static inline void *sdhci_priv(struct sdhci_host *host)&#123;</span><br><span class="line">   return host-&gt;private;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
而host-&gt;private实际指向sdhci_host结构体的最后定义的如下0长度数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned long private[] ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct"># <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct">Explanation on private variable in c struct</a></a><br>基本含义是可以获取结构体外部的数据，而host指针本身确实属于slot结构体sdhci_pci_slot的一部分，所以host-&gt;private能访问到slot。</li>
</ul>
</li>
<li><p>贴一段dmesg log，包含UHSII初始化过程直到最后一步GO_DORMANT fail<br>具体流程参考UHSII spec:  SD_Specifications_Part_1_UHS_II_Addendum</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">[  522.171631] sdhci_uhs2 [sdhci_uhs2_do_detect_init()]: sdhci_uhs2_do_detect_init: begin UHS2 init.</span><br><span class="line">[  522.171632] enter sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171632] exit sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171835] sdhci_uhs2 [sdhci_uhs2_interface_detect()]: mmc0: UHS2 Lane synchronized in UHS2 mode, PHY is initialized.</span><br><span class="line">[  522.171855] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171856] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 0</span><br><span class="line">[  522.171858] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171865] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.171874] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.171885] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.171887] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171887] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 1</span><br><span class="line">[  522.171888] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171894] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188184] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188205] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188254] [uhs2_dev_init()]: CF is set, device is initialized!</span><br><span class="line">[  522.188257] [uhs2_enum()]: Begin ENUMERATE, header=0x80, arg=0x392, payload=0xf0.</span><br><span class="line">[  522.188260] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x392</span><br><span class="line">[  522.188262] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=8</span><br><span class="line">[  522.188266] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188277] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188290] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188308] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188318] [uhs2_enum()]: id_f = 6, id_l = 6.</span><br><span class="line">[  522.188320] [uhs2_enum()]: Enumerate Cmd Completed. No. of Devices connected = 1</span><br><span class="line">[  522.188322] [uhs2_config_read()]: INQUIRY_CFG: read Generic Caps.</span><br><span class="line">[  522.188324] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x10.</span><br><span class="line">[  522.188326] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x10</span><br><span class="line">[  522.188328] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188331] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188342] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188363] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188392] mmc0: req done (CMD0): 0: 00010100 00000000 00000000 00000000</span><br><span class="line">[  522.188398] [uhs2_config_read()]: Device Generic Caps (0-31) is: 0x10100.</span><br><span class="line">[  522.188399] [uhs2_config_read()]: INQUIRY_CFG: read PHY Caps.</span><br><span class="line">[  522.188401] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x220.</span><br><span class="line">[  522.188404] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x220</span><br><span class="line">[  522.188410] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188415] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188427] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188447] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188476] mmc0: req done (CMD0): 0: 00008000 00000080 00000000 00000000</span><br><span class="line">[  522.188482] [uhs2_config_read()]: Device PHY Caps (0-31) is: 0x8000.</span><br><span class="line">[  522.188484] [uhs2_config_read()]: Device PHY Caps (32-63) is: 0x80.</span><br><span class="line">[  522.188487] [uhs2_config_read()]: INQUIRY_CFG: read LINK-TRAN Caps.</span><br><span class="line">[  522.188492] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x420.</span><br><span class="line">[  522.188499] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x420</span><br><span class="line">[  522.188504] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188507] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188516] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188554] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188582] mmc0: req done (CMD0): 0: 20024000 00000000 00000000 00000000</span><br><span class="line">[  522.188601] [uhs2_config_read()]: Device LINK-TRAN Caps (0-31) is: 0x20024000.</span><br><span class="line">[  522.188604] [uhs2_config_read()]: Device LINK-TRAN Caps (32-63) is: 0x0.</span><br><span class="line">[  522.188605] [uhs2_config_write()]: SET_COMMON_CFG: write Generic Settings.</span><br><span class="line">[  522.188607] [uhs2_config_write()]: Both Host and device support 2L-HD.</span><br><span class="line">[  522.188609] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0</span><br><span class="line">[  522.188611] [uhs2_config_write()]: UHS2 write Generic Settings 00000000 00000000</span><br><span class="line">[  522.188613] [uhs2_config_write()]: flags=00000005 dev_prop.n_lanes_set=0 host_caps.n_lanes_set=0</span><br><span class="line">[  522.188615] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188618] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188620] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188632] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188650] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188678] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188684] [uhs2_config_write()]: SET_COMMON_CFG: PHY Settings.</span><br><span class="line">[  522.188686] [uhs2_config_write()]: set dev_prop.speed_range_set to SPEED_B</span><br><span class="line">[  522.188689] [uhs2_config_write()]: UHS2 SET PHY Settings  40000000 04000000</span><br><span class="line">[  522.188691] [uhs2_config_write()]: host-&gt;flags=00000015 dev_prop.speed_range_set=1</span><br><span class="line">[  522.188693] [uhs2_config_write()]: dev_prop.n_lss_sync_set=4 host_caps.n_lss_sync_set=4</span><br><span class="line">[  522.188694] [uhs2_config_write()]: dev_prop.n_lss_dir_set=0 host_caps.n_lss_dir_set=8</span><br><span class="line">[  522.188696] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xaa0</span><br><span class="line">[  522.188698] [uhs2_config_write()]: 		payload[0]=0x40000000 payload[1]=0x4000000</span><br><span class="line">[  522.188700] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xaa0</span><br><span class="line">[  522.188703] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=4</span><br><span class="line">[  522.188705] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188715] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188730] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188741] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188746] [uhs2_config_write()]: SET_COMMON_CFG: LINK-TRAN Settings.</span><br><span class="line">[  522.188748] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xca0</span><br><span class="line">[  522.188750] [uhs2_config_write()]: 		payload[0]=0x80320 payload[1]=0x1000000</span><br><span class="line">[  522.188752] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xca0</span><br><span class="line">[  522.188754] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188756] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188766] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188780] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188808] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188813] [uhs2_config_write()]: SET_COMMON_CFG: Set Config Completion.</span><br><span class="line">[  522.188815] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0, payload[0] = 0x0.</span><br><span class="line">[  522.188817] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188819] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=5</span><br><span class="line">[  522.188821] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188831] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188842] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188855] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188862] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 0.</span><br><span class="line">[  522.201612] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 3.</span><br><span class="line">[  522.201614] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 2.</span><br><span class="line">[  522.201616] [uhs2_go_dormant()]: Begin GO_DORMANT_STATE, header=0x86, arg=0x192, payload=0x0.</span><br><span class="line">[  522.201617] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x192</span><br><span class="line">[  522.201618] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=0</span><br><span class="line">[  522.201619] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.201626] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x8c0 is set to UHS2 CMD register.</span><br><span class="line">[  522.218633] mmc0: sdhci: IRQ status 0x00008000</span><br><span class="line">[  522.218636] sdhci_uhs2 [sdhci_uhs2_irq()]: *** mmc0 got UHS2 interrupt: 0x00010000</span><br><span class="line">[  522.218651] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218652] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218652] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218654] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218659] mmc0: req done (CMD0): -110: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.218666] mmc0: uhs2_go_dormant: UHS2 CMD send fail, err= 0xffffff92!</span><br><span class="line">[  522.218668] mmc0: uhs2_change_speed: UHS2 GO_DORMANT_STATE fail, err= 0xfffffffb!</span><br><span class="line">[  522.218669] mmc0: UHS2 uhs2_change_speed() fail!</span><br></pre></td></tr></table></figure>
<p>含义是UHSII初始化接近完成，切换到高速的RangeB时，GO_DORMANT_STATE命令未完成，超时。<br>解决办法：先绕过RangeB模式，使用RangA(较低速度的UHSII模式)，为此要从一开始就上报host不支持RangeB。<br>修改mmc&#x2F;host&#x2F;sdhci-uhs2.c中的上报host能力(capability)的speed_range为不支持RangeB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//mmc-&gt;uhs2_caps.speed_range =(caps_phy &amp; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_MASK) &gt;&gt; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_SHIFT;</span><br><span class="line"></span><br><span class="line">mmc-&gt;uhs2_caps.speed_range = 0; //Range-A</span><br></pre></td></tr></table></figure>
<p>重新编译安装module后，UHSII初始化正常，读写正常。</p>
</li>
</ol>
<p>事实上此GO_DORMANT fail issue的根本原因是兼容性问题：<br>UHSII初始化流程中，SD host侧对lane speed的配置最好在卡处在dormant状态下进行，host侧提高速度（从Range-A提高到RangeB）以后，卡侧在退出dormant状态时重新配置速度，和host速度匹配。<br>如果host侧修改lane speed时间点错误，有的SD卡来不及反应，不能同步速度，所以GO_DORMANT fail；而有的SD 卡性能好，随时同步host侧的速度，没有此issue。</p>
<p>另外有的Issue和硬件特性相关，例如上电需要等待一定时间以后，才能启动UHSII设备初始化，这个等待时间取决于SD host厂商的硬件特性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/03/09/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/09/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">python正则表达式使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-09 19:12:00" itemprop="dateCreated datePublished" datetime="2022-03-09T19:12:00+08:00">2022-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-18 13:50:24" itemprop="dateModified" datetime="2022-05-18T13:50:24+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Python正则表达式简介"><a href="#1-Python正则表达式简介" class="headerlink" title="1.Python正则表达式简介"></a>1.Python正则表达式简介</h2><p>参考<a target="_blank" rel="noopener" href="https://www.programiz.com/python-programming/regex"># Python RegEx</a></p>
<h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h2><p>芯片ATE测试中，不同ATE平台的测试模式文件格式有不同，需要匹配字符串并按特定转换<br>转换前：</p>
<blockquote>
<p>Pattern “pll_dll_100m_test” {<br>waveform_start:<br>W pll_dll_100m_wft;</p>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>转后后：</p>
<blockquote>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;} W pll_dll_100m_wft;<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>规则：将以“W_xxx”的字符串放到下一个以“V_xxx”的字符串后面</p>
<p>利用python正则匹配，配合读取文件到字符串数组，实现如下转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">infile_name = <span class="built_in">input</span>(<span class="string">&quot;Please input the name of file in current directory to convert: &quot;</span>)</span><br><span class="line">name_flag = infile_name.find(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> name_flag == -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file name error, need input the suffix of file name&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(infile_name):</span><br><span class="line">        outfile_name = infile_name[<span class="number">0</span>:name_flag] + <span class="string">&quot;_updated&quot;</span> + infile_name[name_flag:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no such file!&quot;</span>)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">infile = <span class="built_in">open</span>(infile_name, <span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(outfile_name, <span class="string">&quot;w&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lines = infile.readlines()</span><br><span class="line">infile.close()</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">    str_obj = re.match(<span class="string">&#x27;[\s]*W[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;W ...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        temp_index = index</span><br><span class="line">        temp_str = str_obj.group()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_obj = re.match(<span class="string">&#x27;[\s]*V[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;V ...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                lines[temp_index] = <span class="string">&#x27;\n&#x27;</span> <span class="comment">#clear last &quot;W ...&quot;</span></span><br><span class="line">                lines[index] = str_obj.group() + <span class="string">&#x27; &#x27;</span> + temp_str + <span class="string">&#x27;\n&#x27;</span> <span class="comment">#add the &quot;W ...&quot; from &quot;V ...&quot; end</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">outfile.writelines(lines)</span><br><span class="line">outfile.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;outputfile is &quot;</span> + outfile_name)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的W和V前面加了额外的匹配项：<code>[\s]*</code>，是因为文件存在不可见的回车换行等引起，如果不加匹配不到</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/02/28/%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84Markdown%E5%86%99%E4%BD%9C%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%EF%BC%9AObsidian+PicGo+Hexo+Github/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84Markdown%E5%86%99%E4%BD%9C%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%EF%BC%9AObsidian+PicGo+Hexo+Github/" class="post-title-link" itemprop="url">搭建高可移植的Markdown写作和博客环境：Obsidian+PicGo+Hexo+Github</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 15:04:18" itemprop="dateCreated datePublished" datetime="2022-02-28T15:04:18+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-17 14:23:39" itemprop="dateModified" datetime="2022-05-17T14:23:39+08:00">2022-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/markdown/" itemprop="url" rel="index"><span itemprop="name">markdown</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0-背景"><a href="#0-背景" class="headerlink" title="0.背景"></a>0.背景</h2><p>写技术笔记并发布博客，通常有以下方式：</p>
<ul>
<li>第三方平台CSDN&#x2F;cnblogs，最简单但是最不可控，例如我写过一篇如何使用shadow-sock，直接被删掉，各种广告也是技术洁癖症不能忍的。</li>
<li>使用云服务器自建Leanote博客系统，我用过几年，最大缺点是服务器续费太贵，且文章数据存在数据库很难导出，优点是自建的Leanote写作发布一体化体验极好。</li>
<li>使用github+picgo+hexo， github作为图床和博客的云服务，picgo用于建立图床通道，hexo用于发布博客。缺点是github访问慢，用开源CDN可以很好解决；优点是全部免费，数据可移植(图片链接都在github图床)，可长期使用（只要github不倒闭不锁区）</li>
</ul>
<p>最终我选择github+picgo+hexo方案。<br>为什么不用gitee: gitee上传图片限制1M, github有25M。有了CDN, github的速度也不是问题</p>
<p>现在只需要确定Markdown编辑器</p>
<p>VSCode加Markdown插件试过，体验并不完美<br><a target="_blank" rel="noopener" href="https://www.typora.io/">Typora</a>是很不错的选择，除了收费<br><a target="_blank" rel="noopener" href="https://obsidian.md/">Obsidian</a>免费且优雅：</p>
<ul>
<li>支持动态渲染，即写出的Markdown语句自动显示预览</li>
<li>支持各种快捷键，无需手动输入Markdown语法格式（<a target="_blank" rel="noopener" href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法</a>）。比如标题，链接，列表，引用，可以设置标准的Markdown快捷键。</li>
<li>支持关联PicGo实现粘贴图片即上传到云端图床，这一点对于写作体验和文章的可迁移性很重要</li>
<li>特色的Zettelkasten笔记管理方法，本文不描述这部分，参考<a target="_blank" rel="noopener" href="https://sspai.com/post/62414#!">玩转 Obsidian 01：打造知识循环利器</a></li>
</ul>
<h2 id="1-搭建可移植的Markdown写作环境"><a href="#1-搭建可移植的Markdown写作环境" class="headerlink" title="1. 搭建可移植的Markdown写作环境"></a>1. 搭建可移植的Markdown写作环境</h2><p>Markdown文档本身是可移植的，但是其图片资源不是, 因为图片不是以二进制嵌入文档，而只是个图片地址的链接。</p>
<p>如果只是在本地写写Markdown，完全不需要考虑图片的可移植，只需要存本地固定路径即可。<br>如果想在本地写Markdown，且这个文档拿到别的机器，或者放到博客论坛发布，别人都可以看到图片，就要一个云端的图片存储服务，即图床。</p>
<p>本节讲如何实现一个“一处写作，到处可见”的Markdown写作环境，并优化工具设置，让写作顺滑流程</p>
<h3 id="1-1-Github-PicGo搭建图床"><a href="#1-1-Github-PicGo搭建图床" class="headerlink" title="1.1 Github+PicGo搭建图床"></a>1.1 Github+PicGo搭建图床</h3><p>完整流程参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/yefcion/article/details/88412025">PicGo + GitHub 搭建个人图床工具</a></p>
<p>流程包含以下部分：</p>
<ul>
<li>一个public的Github仓库，用来存放文章链接的图片，注意单仓库最大容量1GB。</li>
<li>一个personal access token，用于PicGo免密访问github实现自动上传图片</li>
<li>一个图片上传工具：PicGo及其插件，用它上连Github图床仓库，下连本地markdown编辑器，实现“图片粘贴即上传”</li>
<li>一个CDN(推荐，很好用)：使用开源CDN jsdelivr加速Github访问，避免因访问速度造成图片上传失败</li>
</ul>
<p>最终我的配置如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281014786.png"></p>
<p>单元测试：<br>手动上传本地图片，如果上传成功，且图片可预览，则功能正常<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024870.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024344.png"></p>
<p>遇到的坑：<br>仓库名必须填&lt;用户名&gt;&lt;仓库名&gt;，不是完整的http或git仓库链接！否则上传图片error404</p>
<p>PicGo支持log调试，参考：<br><a target="_blank" rel="noopener" href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html"><a target="_blank" rel="noopener" href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html">PicGo上传图片到GitHub总是失败的特殊解决办法</a></a></p>
<p>2022&#x2F;5&#x2F;17更新：<br>最近发现jsdelivr在大陆挂了，那么只能放弃使用CDN, 直接使用github图床的raw链接</p>
<p>将Picgo默认图床路径从jsdelivr的<br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D@master">https://cdn.jsdelivr.net/gh/账户名/图床仓库名@master</a><br>改为：<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D/master">https://raw.githubusercontent.com/账户名/图床仓库名/master</a></p>
<p>对于已发布的博客的图床链接，直接用VSCode全局查找替换以上前缀即可，后面的图片id是不变的。</p>
<p><strong>如何删除Github图床的图片：</strong><br>PicGo默认的Github图床不能通过相册删除github仓库的图片，需要使用第三方插件github-plus，建议作为默认图床工具，支持相册删除同步到github仓库:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281208516.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281209075.png"></p>
<h3 id="1-2-Obsidian链接图床"><a href="#1-2-Obsidian链接图床" class="headerlink" title="1.2 Obsidian链接图床"></a>1.2 Obsidian链接图床</h3><p>流程参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4c30495f4325"># 在Obsidian中使用图床实现“一次上传、多次搬运”省心又省力</a></p>
<p>重点部分：配置自动上传插件。写Markdown文章时粘贴的图片自动上传到Github+PicGo图床，无需手动上传和写链接<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029686.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029586.png"></p>
<p>可以看到，此插件相当于一个PicGo客户端，而本地运行的PicGo Server已开启端口36677的监听。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281033479.png"></p>
<p>单元测试：<br>以上配置好后，Obsidian新建一个Markdown文档，粘贴图片会显示updating… ，成功后可在github图床仓库看到该图片，且Markdown本地预览也可以看到。</p>
<p>遇到的坑：<br>一开始上传的图片，github可预览，Obsidian预览失败<br>在PicGo客户端查看刚才上传图片预览也不正常，PicGo客户端手动上传一张后才正常预览。<br>此后Obsidian再粘贴上传图片，预览正常。<br>可能是PicGo首次链接Obsidian插件的bug。</p>
<h3 id="1-3-优化Obsidian写作体验"><a href="#1-3-优化Obsidian写作体验" class="headerlink" title="1.3 优化Obsidian写作体验"></a>1.3 优化Obsidian写作体验</h3><h4 id="1-3-1-Markdown快捷键"><a href="#1-3-1-Markdown快捷键" class="headerlink" title="1.3.1 Markdown快捷键"></a>1.3.1 Markdown快捷键</h4><p>很多Markdown编辑器支持各种快捷键，写作时不需要手动输入Markdown语法，例如一个ctrl+h形成标题，一个ctrl+k形成代码格式。<br>Obsidian默认快捷键不完整，需要补全优化<br>我之前用的Leanote写博客，Obsidian也快捷键设置如下。</p>
<blockquote>
<p>提升标题 Ctrl + H (header)<br>有序列表 Ctrl + O (Ordered)<br>无序列表 Ctrl + U (Un-Ordered)<br>插入链接 Ctrl + L (Link)<br>插入代码 Ctrl + K (K &#x3D; Code, 因为ctrl+C用于粘贴)<br>加粗 Ctrl + B (Bold)<br>斜体 Ctrl + I (Italian体)<br>引用 Ctrl + Q (Quote)<br>插入图片 Ctrl + G (Graph, 有了“粘贴即上传”，这个实际上用不上)</p>
</blockquote>
<p>其他我基本不用的就没设置，例如表格，删除线，分割线等等。<br>如果经常用表格，推荐 Advanced Tables插件。<br>读者也可以参考VS Code的Markdown插件设置。</p>
<h4 id="1-3-2-实时预览和标题大纲"><a href="#1-3-2-实时预览和标题大纲" class="headerlink" title="1.3.2 实时预览和标题大纲"></a>1.3.2 实时预览和标题大纲</h4><p>实时预览是你写一句Markdown，自动转换成预览格式，而不显示Markdown源码。这样不需要开两个窗口，一个写源码一个看预览。在设置-&gt;编辑器里开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281103907.png"></p>
<p>标题大纲是侧边栏显示文章标题列表，就像word的导航窗口一样。在设置-核心插件开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281104255.png"></p>
<h2 id="2-搭建hexo博客发布环境"><a href="#2-搭建hexo博客发布环境" class="headerlink" title="2. 搭建hexo博客发布环境"></a>2. 搭建hexo博客发布环境</h2><h3 id="2-1-环境安装"><a href="#2-1-环境安装" class="headerlink" title="2.1 环境安装"></a>2.1 环境安装</h3><p>整体流程参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/105715224"># 个人博客第5篇——安装node.js和Hexo</a><br>官方文档参考：<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">hexo.io</a></p>
<p>简单总结一下：</p>
<ul>
<li>hexo是一个基于nodeJS的博客框架，nodeJS提供JavaScript实现后端服务的能力。</li>
<li>hexo可以将本地写好的Markdown文本和图片资源，以JavaScript网页资源的方式打包。hexo可以在本机运行服务，通过浏览器可以在网页访问。</li>
<li>如果要使博客外网可访问，需要一个云服务存放hexo生成的博客，我们使用github仓库作为博客云端。前面已经搭建了github图床仓库，因此图片并不需要放到此hexo仓库。</li>
<li>使用git实现hexo博客部署到github仓库</li>
</ul>
<p>遇到的坑：<br>如果你以前用过hexo，之后nodeJS升级了版本，一定不要用以前的hexo博客目录，必须新建博客目录，重新<code>hexo init</code>安装相关hexo插件。否则nodeJS和hexo插件可能不兼容导致部署失败。</p>
<p>hexo插件版本是根据nodeJS版本自动安装的，配置文件是package.json。以nodeJS 16.3为例，自动生成的依赖版本如下：</p>
<p><code>&#123;   &quot;name&quot;: &quot;hexo-site&quot;,   &quot;version&quot;: &quot;0.0.0&quot;,   &quot;private&quot;: true,   &quot;scripts&quot;: &#123;     &quot;build&quot;: &quot;hexo generate&quot;,     &quot;clean&quot;: &quot;hexo clean&quot;,     &quot;deploy&quot;: &quot;hexo deploy&quot;,     &quot;server&quot;: &quot;hexo server&quot;   &#125;,   &quot;hexo&quot;: &#123;     &quot;version&quot;: &quot;6.0.0&quot;   &#125;,   &quot;dependencies&quot;: &#123;     &quot;hexo&quot;: &quot;^6.0.0&quot;,     &quot;hexo-deployer-git&quot;: &quot;^3.0.0&quot;,     &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,     &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,     &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,     &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,     &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,     &quot;hexo-renderer-marked&quot;: &quot;^5.0.0&quot;,     &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;,     &quot;hexo-server&quot;: &quot;^3.0.0&quot;,     &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot;   &#125; &#125;</code></p>
<p>博客的github仓库，主题等关键配置都在<code>hexo init</code>对应目录下的<code>_config.yml</code><br>我修改了几个关键配置如下：<br>博客框架的语言一定要配，否则默认德语阿拉伯语…</p>
<blockquote>
<p>title: ThinkNotes<br>   subtitle: Simple is not easy<br>   author: Cursorhu<br>   language: zh-CN</p>
</blockquote>
<p>Github部署配置</p>
<blockquote>
<p>url: <a href="https://cursorhu.github.io/">https://cursorhu.github.io</a><br>deploy:<br>      type: git<br>      repo: <a target="_blank" rel="noopener" href="https://github.com/cursorhu/cursorhu.github.io">https://github.com/cursorhu/cursorhu.github.io</a><br>      branch: master</p>
</blockquote>
<h3 id="2-2-发布博客"><a href="#2-2-发布博客" class="headerlink" title="2.2 发布博客"></a>2.2 发布博客</h3><p>hexo new命令可以从0新建markdown写博客，一般不用这么麻烦。</p>
<p>我们直接将Obsidian写好的Markdown（图片资源是图床链接）放到hexo博客目录的post文件夹，例如我的本地目录是：</p>
<blockquote>
<p>F:\HexoBlog\source_posts</p>
</blockquote>
<p>在Markdown文件前添加hexo博客特有的头，说明博客的标题时间，分类等属性。这个头如果用<code>hexo new</code>命令会自动生成，可以先new一个然后拷过来。</p>
<blockquote>
<p>title: 博客文章名<br>date: 2022-02-28 15:04:18<br>tags: markdown<br>categories: markdown</p>
</blockquote>
<p>最后使用git生成网页文件并发布到github博客仓库, 注意不是用node命令行！<br>在hexo博客目录下运行：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-博客主题"><a href="#2-3-博客主题" class="headerlink" title="2.3 博客主题"></a>2.3 博客主题</h3><p>博客主题(theme)取决于不同人喜好，github有大量的hexo主题，按需配置<br>推荐几个主流的：<br><a target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-theme-next">Next</a><br><a target="_blank" rel="noopener" href="https://github.com/bollnh/hexo-theme-material">hexo-theme-material</a></p>
<p>以Next主题为例，安装：</p>
<blockquote>
<p>$ cd hexo博客目录<br>   $ git clone <a target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> themes&#x2F;next</p>
</blockquote>
<p>已我的配置为例，就会在F:\HexoBlog\themes\next看到next主题的源码和配置文件config.yml</p>
<p>Next配置可以自定义各种设置，例如子主题:</p>
<blockquote>
<p> scheme: Muse<br>#scheme: Mist<br>#scheme: Pisces<br>#scheme: Gemini</p>
</blockquote>
<p>我们前面已经用jsdelivr开源CDN为PicGo上传图片加速，可以配置Next主题的网页静态文件的相关库也用jsdelivr加速。最好用到才开启，例如motion enable, 其依赖库velocity就可以设置jsdelivr加速：</p>
<blockquote>
<p>motion:<br>      enable: true<br>    velocity: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.min.js<br>    velocity_ui: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.ui.min.js</p>
</blockquote>
<p>注意这些配置文件也是Markdown格式，<code># </code> 注释一定要带空格</p>
<p>hexo要使用next, 在hexo配置文件设置:</p>
<blockquote>
<p>theme: next</p>
</blockquote>
<p>hexo clean, hexo g, hexo s 跑本地服务，看一下效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203041651883.png"></p>
<p>最后hexo clean, g, d 命令三连部署到github</p>
<h3 id="2-4-速度优化"><a href="#2-4-速度优化" class="headerlink" title="2.4 速度优化"></a>2.4 速度优化</h3><p>参考<a target="_blank" rel="noopener" href="https://ednovas.gitee.io/2021/09/23/speeduphexo/"># Hexo 网站访问速度优化</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">多线程笔记：多线程的同步机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 15:21:04" itemprop="dateCreated datePublished" datetime="2021-07-05T15:21:04+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:22:59" itemprop="dateModified" datetime="2022-12-05T15:22:59+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文讲解并发环境中的几个线程同步示例<br>线程同步，即多个线程如何协调，谁先谁后<br>本文基于Linux&#x2F;POSIX API<br>本系列源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p>生产者&#x2F;消费者模式是并发环境常见的模式，简单地讲，通过中介缓冲，支持多组任务并发执行，避免任务间发生通信阻塞。<br>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/darkdragonking/article/details/89208124">生产者&#x2F;消费者模式的理解及实现</a></p>
<p>常用的实现方式</p>
<ul>
<li>互斥量(参考<a target="_blank" rel="noopener" href="http://47.100.221.149:9010/blog/post/admin/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89">多线程入门（一）</a>)</li>
<li>信号量</li>
<li>条件变量</li>
<li>读写锁</li>
</ul>
<h1 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h1><p>关于LInux信号量：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e72ff770244">Linux信号量</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
&#123;
public:
    Task(int taskID)
    &#123;
        this-&gt;taskID = taskID;
    &#125;
    
    void doTask()
    &#123;
        std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
    &#125;
    
private:
    int taskID;
&#125;;

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
sem_t            mysemaphore;

void* consumer_thread(void* param)
&#123;    
    Task* pTask = NULL;
    while (true)
    &#123;
        struct timespec ts;
        ts.tv_sec = 3;
        ts.tv_nsec = 0;
        
        if (sem_timewait(&amp;mysemaphore, &amp;ts) != 0)
        &#123;
            if (errno == ETIMEOUT)
            &#123;
                std::cout &lt;&lt; &quot;ETIMEOUT&quot; &lt;&lt; std::endl;
            &#125;
            continue;
        &#125;
        
        if (tasks.empty())
            continue;
        
        pthread_mutex_lock(&amp;mymutex);    
        pTask = tasks.front();
        tasks.pop_front();
        pthread_mutex_unlock(&amp;mymutex);
        
        pTask-&gt;doTask();
        delete pTask;
    &#125;
    
    return NULL;
&#125;

void* producer_thread(void* param)
&#123;
    int taskID = 0;
    Task* pTask = NULL;
    
    while (true)
    &#123;
        pTask = new Task(taskID);
            
        pthread_mutex_lock(&amp;mymutex);
        tasks.push_back(pTask);
        std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
        
        pthread_mutex_unlock(&amp;mymutex);
        
        //释放信号量，通知消费者线程
        sem_post(&amp;mysemaphore);
        
        taskID ++;

        //休眠1秒
        sleep(1);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_mutex_init(&amp;mymutex, NULL);
    //初始信号量资源计数为0
    sem_init(&amp;mysemaphore, 0, 0);

    //创建5个消费者线程
    pthread_t consumerThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
    &#125;
    
    //创建一个生产者线程
    pthread_t producerThreadID;
    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

    pthread_join(producerThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(consumerThreadID[i], NULL);
    &#125;
    
    sem_destroy(&amp;mysemaphore);
    pthread_mutex_destroy(&amp;mymutex);

    return 0;
&#125;
</code></pre>
<p>说明几点：</p>
<ul>
<li>信号量和锁一样，全局的</li>
<li>sem_post和sem_wait是P(), V()操作的具体实现，即计数+1，-1</li>
</ul>
<h1 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h1><p>关于条件变量(cv)：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量(condition variables)</a><br>条件变量同锁一起使用使得线程可以以一种无竞争的方式等待任意条件的发生。所谓无竞争就是，条件改变这个信号会发送到所有等待这个信号的线程。</p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
&#123;
public:
    Task(int taskID)
    &#123;
        this-&gt;taskID = taskID;
    &#125;
    
    void doTask()
    &#123;
        std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
    &#125;
    
private:
    int taskID;
&#125;;

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
pthread_cond_t   mycv;

void* consumer_thread(void* param)
&#123;    
    Task* pTask = NULL;
    while (true)
    &#123;
        pthread_mutex_lock(&amp;mymutex);
        while (tasks.empty())
        &#123;                
            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
            pthread_cond_wait(&amp;mycv, &amp;mymutex);
        &#125;
        
        pTask = tasks.front();
        tasks.pop_front();

        pthread_mutex_unlock(&amp;mymutex);
        
        if (pTask == NULL)
            continue;

        pTask-&gt;doTask();
        delete pTask;
        pTask = NULL;        
    &#125;
    
    return NULL;
&#125;

void* producer_thread(void* param)
&#123;
    int taskID = 0;
    Task* pTask = NULL;
    
    while (true)
    &#123;
        pTask = new Task(taskID);
            
        pthread_mutex_lock(&amp;mymutex);
        tasks.push_back(pTask);
        std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
        
        pthread_mutex_unlock(&amp;mymutex);
        
        //释放条件信号，通知消费者线程
        pthread_cond_signal(&amp;mycv);
        
        taskID ++;

        //休眠1秒
        sleep(1);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_mutex_init(&amp;mymutex, NULL);
    pthread_cond_init(&amp;mycv, NULL);

    //创建5个消费者线程
    pthread_t consumerThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
    &#125;
    
    //创建一个生产者线程
    pthread_t producerThreadID;
    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

    pthread_join(producerThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(consumerThreadID[i], NULL);
    &#125;
    
    pthread_cond_destroy(&amp;mycv);
    pthread_mutex_destroy(&amp;mymutex);

    return 0;
&#125;
</code></pre>
<h1 id="读写锁实现"><a href="#读写锁实现" class="headerlink" title="读写锁实现"></a>读写锁实现</h1><p>关于读写锁，参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/love-DanDan/p/8723931.html">Linux：使用读写锁使线程同步</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;

int resourceID = 0;
pthread_rwlock_t myrwlock;

void* read_thread(void* param)
&#123;    
    while (true)
    &#123;
        //请求读锁
        pthread_rwlock_rdlock(&amp;myrwlock);

        std::cout &lt;&lt; &quot;read thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
                
        //使用睡眠模拟读线程读的过程消耗了很久的时间
        sleep(1);
                
        pthread_rwlock_unlock(&amp;myrwlock);
    &#125;
    
    return NULL;
&#125;

void* write_thread(void* param)
&#123;
    while (true)
    &#123;
        //请求写锁
        pthread_rwlock_wrlock(&amp;myrwlock);

        ++resourceID;
        std::cout &lt;&lt; &quot;write thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
                
        //使用睡眠模拟读线程读的过程消耗了很久的时间
        sleep(1);
                
        pthread_rwlock_unlock(&amp;myrwlock);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_rwlock_init(&amp;myrwlock, NULL);

    //创建5个请求读锁线程
    pthread_t readThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);
    &#125;
    
    //创建一个请求写锁线程
    pthread_t writeThreadID;
    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);

    pthread_join(writeThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(readThreadID[i], NULL);
    &#125;
    
    pthread_rwlock_destroy(&amp;myrwlock);

    return 0;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/04/17/Vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/Vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Vim使用笔记.</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 12:30:05" itemprop="dateCreated datePublished" datetime="2021-04-17T12:30:05+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 14:37:07" itemprop="dateModified" datetime="2022-12-06T14:37:07+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在ChromeOS上做一些shell script测试用例开发，ChromeOS基于Debian9，但没有Ubuntu那种GNOME的gedit编辑器，更不谈安装Linux版VSCode，正好借此机会练习一下之前一直不熟悉的vim编辑器。</p>
<p>ChromeOS不方便截图，所以本文以ubuntu上的linux0.11代码为例，整理vim最常用的操作。</p>
<p>关于Linux上的文本编辑器基础概念，可以参考&lt;Linux命令行与shell脚本编程大全.第3版&gt;</p>
<h2 id="1-三种编辑模式"><a href="#1-三种编辑模式" class="headerlink" title="1. 三种编辑模式"></a>1. 三种编辑模式</h2><p>我将vim归为三种编辑模式：</p>
<ul>
<li><p>文本编辑模式<br>文本编辑模式是默认模式，vim编辑器会将按键解释成命令。在任意模式按esc进入此默认模式。</p>
</li>
<li><p>文本插入模式<br>文本插入模式， vim会将你在当前光标位置输入的每个键都插入到缓冲区，即文本输入字符。在普通模式下按下”i 键” 进入(含义:insert)</p>
</li>
<li><p>命令行模式<br>命令行模式和shell命令行类似，在普通模式下按下”: 键”进入(形似shell terminal的冒号)</p>
</li>
</ul>
<p>怎么知道当前处于哪种模式？<br>vim左下角是状态行，以下是三种模式的状态示例：</p>
<ul>
<li><code>vim init/main.c</code>默认进入文本编辑模式，下面显示文件名和行号<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171047554.png"></li>
</ul>
<p>输入i, 进入文本插入模式，下面显示insert状态<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171052433.png"></p>
<p>按esc退出文本编辑，再输入<code>:</code> 进入命令行模式，例如输入<code>:wq</code>保存文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171053124.png"></p>
<p>还有一种visual模式是复制粘贴时会用到：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181032041.png"></p>
<p>下面讲文本编辑模式和命令行模式的常用命令<br>主要分为几类场景：</p>
<ul>
<li>光标移动</li>
<li>增删改查</li>
<li>文件保存</li>
</ul>
<p>光标移动类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>移到第一行 (gg重来)</td>
</tr>
<tr>
<td>G</td>
<td>移到最后一行 (记为大G)</td>
</tr>
<tr>
<td>PageUp&#x2F;PageDown</td>
<td>翻页</td>
</tr>
<tr>
<td>:行号</td>
<td>光标移动到指定行(属于命令行模式)</td>
</tr>
</tbody></table>
<p>增删改查类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>进入insert模式，在当前光标的左侧输入</td>
</tr>
<tr>
<td>a</td>
<td>追加文本（append），在当前光标的右侧输入</td>
</tr>
<tr>
<td>o</td>
<td>插入空行，在空行光标处可输入</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行 (记为双击delete)</td>
</tr>
<tr>
<td>dw</td>
<td>删除当前词（记为delete word）</td>
</tr>
<tr>
<td>delete键，或x键</td>
<td>删除当前字符，注意，Backspace在vim没有删除的作用！</td>
</tr>
<tr>
<td>v+方向键选中+y</td>
<td>复制选中的文本，v: visual，可视光标选中的文本范围， y: yank 复制</td>
</tr>
<tr>
<td>yw</td>
<td>复制当前词</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p</td>
<td>在复制之后，粘贴文本(paste)，注意粘贴内容来自vim缓冲区，而不是外部剪切板的</td>
</tr>
<tr>
<td>dw&#x2F;dd + p</td>
<td>剪切，d操作删除的文本位于缓冲区，可以直接用p粘贴</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>(当前文件内)查找字符串，按n查找下一个</td>
</tr>
<tr>
<td>:s&#x2F;old&#x2F;new&#x2F;g</td>
<td>(当前文件内)全局查找和替换</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步</td>
</tr>
</tbody></table>
<p>文件保存类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:q!</td>
<td>不保存文件退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存文件退出</td>
</tr>
</tbody></table>
<h2 id="2-多文件编辑"><a href="#2-多文件编辑" class="headerlink" title="2.多文件编辑"></a>2.多文件编辑</h2><p>下面讲多个文本的常用命令<br>主要分为几类场景：</p>
<ul>
<li>多文本搜索</li>
<li>多文件编辑</li>
</ul>
<p>多文本搜索类：<br>参考<a target="_blank" rel="noopener" href="https://thevaluable.dev/vim-search-find-replace/"># Vim Search and Replace With Examples</a><br>本文只以quickfix方式为例：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>:vimgrep pattern **</code></td>
<td>搜索当前目录和子目录的包含指定pattern的文件，vimgrep可缩写为vim, ** 表示递归子目录</td>
</tr>
<tr>
<td><code>:vimgrep pattern **/*.c</code></td>
<td>同上，只搜索.c文件</td>
</tr>
<tr>
<td>:copen</td>
<td>搜索完后使用此命令打开文件列表，才能用光标选择</td>
</tr>
<tr>
<td>:cn (cnext) 和 :cp (cprev)</td>
<td>上下选择搜索文件列表</td>
</tr>
</tbody></table>
<p>示例：搜索linux0.11下的所有包含main的.c文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171959744.png"></p>
<p>quickfix list即文件列表，copen后可方向键选择打开文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205172002631.png"></p>
<ul>
<li>多文件编辑<br><strong>打开多个文件，分隔并列显示</strong></li>
</ul>
<ol>
<li>用vim打开文件后，命令行输入<code>:vs newfile</code>，竖排并列打开新文件（vs是vertical split缩写，竖排分隔）</li>
<li>特殊用法：<code>:vs ./</code>可以打开当前路径下的所有文件列表</li>
<li>在窗口间切换：<code>ctrl + ww</code></li>
<li>关闭文件只需要先切换到窗口再<code>:q!</code></li>
<li>调整竖排的窗口比例：<br> 先按ctrl+w选择窗口模式，再按&lt;&gt;+-调整。&lt; 左移，&gt; 右移，+ 上移， - 下移。</li>
</ol>
<p>示例：实现类似IDE的界面，左侧是文件列表，下侧是查找栏，右侧文件内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181006035.png"></p>
<p>  <strong>打开多个文件，不并列显示</strong><br>直接<code>:open file</code>打开新文件, 用 <code>:bn 和 :bN</code> (buffer next)切换文件, </p>
<p>  <strong>多文件之间复制粘贴</strong><br>vim的多个文件直接可以直接用 y + p 命令复制粘贴，因为共用vim环境的缓冲区</p>
<p>  退出所有文件<br><code>:qall!</code> 和 <code>:wqall</code></p>
<h2 id="3-类似IDE的跳转功能"><a href="#3-类似IDE的跳转功能" class="headerlink" title="3.类似IDE的跳转功能"></a>3.类似IDE的跳转功能</h2><p>推荐cscope插件，具体参考<a target="_blank" rel="noopener" href="http://cscope.sourceforge.net/cscope_vim_tutorial.html">## The Vim&#x2F;Cscope tutorial</a></p>
<p>关键步骤：</p>
<ul>
<li>建立cscope.vim<br>将  <a target="_blank" rel="noopener" href="http://cscope.sourceforge.net/cscope_maps.vim">http://cscope.sourceforge.net/cscope_maps.vim</a>  另存到文件<code>~/.vim/plugin/cscope_maps.vim</code></li>
<li>源码目录建立cscope.out<br><code>cscope -R</code> 建立符号索引，<code>ctrl+D</code> 退出</li>
<li>打开某符号的代码<br>例如 <code>vim -t main</code> 打开main所在文件</li>
<li>查找函数的定义和调用<br>如果光标已经在函数上，用 “<code>ctrl +＼</code>“ 再输入s，查找所有调用、定义该函数的列表，输入索引号回车<br>更推荐用cscope的命令行，<code>:cs f s 函数名</code> 是一样的结果，且光标不需要位于函数上。参数含义 f: find, s: symbol<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181103274.png"></li>
<li>跳转回之前的位置<br>“<code>ctrl + t</code></li>
</ul>
<h2 id="4-vim配置文件修改配色，行号"><a href="#4-vim配置文件修改配色，行号" class="headerlink" title="4.vim配置文件修改配色，行号"></a>4.vim配置文件修改配色，行号</h2><p>在有的Linux服务器上，Vim默认深蓝色亮瞎眼，修改配色为流行的Molokai.</p>
<p>效果对比:</p>
<p>默认配色看不清注释内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061435384.png" alt="image-20221206143528332"><br>Molokai配色<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061437401.png" alt="image-20221206143701354"></p>
<p>配置过程：</p>
<p>默认的配色方案：</p>
<pre><code>ls /usr/share/vim/vim74/colors
</code></pre>
<p>下载molokai配色文件,拷贝到vim配色文件目录</p>
<pre><code>cd ~
git clone git@github.com:tomasr/molokai.git
cd molokai/colors
cp molokai.vim /usr/share/vim/vim74/colors
</code></pre>
<p>在home下创建.vimrc用于配色详细设置</p>
<pre><code>cd ~
vim .vimrc
</code></pre>
<p>.vimrc设置如下：</p>
<pre><code>  set t_Co=256
  set background=dark
  set ts=4
  set nu!
  syntax on
  colorscheme molokai
</code></pre>
<p><code>:wq</code>保存后即生效<br>如果要全局用户通用，<code>vim /etc/vimrc</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
