<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/3/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/08/27/Github%E4%BB%93%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/Github%E4%BB%93%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Github仓库初始化配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-27 10:57:00" itemprop="dateCreated datePublished" datetime="2020-08-27T10:57:00+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:01:54" itemprop="dateModified" datetime="2022-12-05T15:01:54+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h2><h2 id="2-进入本地源码目录"><a href="#2-进入本地源码目录" class="headerlink" title="2.进入本地源码目录"></a>2.进入本地源码目录</h2><pre><code>git init
</code></pre>
<p>会出现.git目录<br>首次需要配置github账户和邮箱</p>
<pre><code>git config --global user.name &quot;github注册的用户名&quot;
git config --global user.mail &quot;github注册的邮箱&quot;
</code></pre>
<h2 id="3-添加远程仓库"><a href="#3-添加远程仓库" class="headerlink" title="3.添加远程仓库"></a>3.添加远程仓库</h2><p>在github网页新建仓库</p>
<pre><code>git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<p>.git&#x2F;config文件内容会出现remote等内容，ssh方式的url是git开头，http(s)方式是http(s)开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051116187.png" alt="image-20221205111653141"><br>如果是从别人拉过来的仓库，修改后新建仓库，上传遇到<code>fatal: remote origin already exists</code>问题，解决方法:</p>
<pre><code>git remote rm origin
git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<h2 id="4-git-add-commit-push三连"><a href="#4-git-add-commit-push三连" class="headerlink" title="4.git add, commit, push三连"></a>4.git add, commit, push三连</h2><pre><code>git add -A
git commit -m &#39;first commit&#39;
git push -f --set-upstream origin master //首次提交
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117987.png" alt="image-20221205111703940"><br>完成以后远程可以看得到仓库的文件   </p>
<h2 id="5-创建分支"><a href="#5-创建分支" class="headerlink" title="5.创建分支"></a>5.创建分支</h2><p>如果已经有主线，在本地<code>git checkout branchname</code>, 远程创建分支，记录.git链接， 然后关联远程分支即可：</p>
<pre><code>git remote add origin https://github.com/*/*.git
</code></pre>
<p>然后推送</p>
<pre><code>git push origin branchname
</code></pre>
<h2 id="5-首次配置可能的问题："><a href="#5-首次配置可能的问题：" class="headerlink" title="5.首次配置可能的问题："></a>5.首次配置可能的问题：</h2><p>push时有RSA key错误<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117281.png" alt="image-20221205111713234"><br>因为Git使用SSH连接，而SSH第一次连接需要验证GitHub服务器的Key。确认GitHub的Key的指纹信息是否真的来自GitHub的服务器。解决办法是在本地生成key，配置到github服务器<br>（1)创建ssh key</p>
<pre><code>ls -al ~/.ssh
ssh-keygen -t rsa -C &quot;github用户名&quot;
cat ~/.ssh/id_rsa.pub
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117255.png" alt="image-20221205111721197"><br>在push三连过程可以设置global全局配置，以后默认push到github<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117055.png" alt="image-20221205111728996"></p>
<p>（2）配置ssh key到github<br>登陆github,头像-settings-new SSH,复制新生成的SSH配置到服务器<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117386.png" alt="image-20221205111737339"><br>（3）需要重新add origin新建仓库（或者网页上新建仓库)，再push，<code>git status</code>和<code>git log</code>查看分支和日志</p>
<p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">Linux Shell笔记：实现芯片固件的批量编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-12 14:58:37" itemprop="dateCreated datePublished" datetime="2020-08-12T14:58:37+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:00:41" itemprop="dateModified" datetime="2022-12-05T15:00:41+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某软件有不同的配置参数，实现不同功能版本的编译<br>批量测试需要批量编译各种版本，实现方式为：<br>1.将编译参数组合，生成大量配置文件<br>2.编译过程遍历这些配置文件，依次编译对应版本<br>3.有参数加入，修改，删除，只需要更新这些配置文件<br>如何实现这些配置文件的更新？</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某芯片的Firmware批量编译实现：<br>Firmware代码为C, 配置参数用宏实现，后缀为.def<br>目录结构如下</p>
<p>|–project_folder<br>　　|–config<br>　　　|–build.def<br>　　　|–defs<br>　　　　　|–1.def 2.def … n.def<br>　　|–src<br>　　|–Makefile<br>　　|–build_All.sh<br>　　|–update.sh</p>
<h2 id="批量编译脚本"><a href="#批量编译脚本" class="headerlink" title="批量编译脚本"></a>批量编译脚本</h2><p>批量编译脚本如下<br>基本过程：<br>1.依次拷贝def文件夹中的每个def，替换默认的build.def<br>2.编译，接受所有编译参数<br>3.拷贝编译输出的image到包含git tag, def名，时间等信息的文件夹</p>
<pre><code>#!/bin/bash

echo &quot;Batch build support args:&quot;
echo &quot;1. functin version:&quot;
echo &quot;verargs=mp_fpga&quot;
echo &quot;verargs=mpw_asic&quot;
echo &quot;2. boot debug:&quot;
echo &quot;bootargs=debug&quot;

OUTPUT=batch_build_$1$2

mkdir -p $&#123;OUTPUT&#125;
rm -rf ./batch_build_*

build_time=`date +%Y%m%d%H%M%S`

#commit_id=`git rev-parse HEAD`

tag_name=`git describe --exact-match --tags 2&gt;/dev/null`

if [ -z &quot;$&#123;tag_name&#125;&quot; ]; then
    tag_name=&quot;NO_TAG&quot;
fi

mv ./config/build.def ./config/build.def.bak 

for file in `ls ./config/defs/*.def`;
do
    file_name=$&#123;file##*/&#125;
    config_name=$&#123;file_name%.def&#125;
    
    cp -rf $&#123;file&#125; ./config/build.def
    make clean
    make -j4 $@
    #mv ./build/image ./batch_build/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;_cid_$&#123;commit_id&#125;
    mkdir -p ./$&#123;OUTPUT&#125;/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;
    mv ./build/image/* ./$&#123;OUTPUT&#125;/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;
done

mv ./config/build.def.bak ./config/build.def
</code></pre>
<p>def文件内的.def文件即各种参数配置文件，.def文件名即参数功能的别名组合<br>例如：</p>
<pre><code>CQ_emmc_two_card_enhance_hs400_always_l0_MSIx_dllphase14_tuning_on.def
</code></pre>
<p>对应的内容是：</p>
<pre><code>/*0: Non-CQ mode 1:CQ mode enable*/
#define BB_CQ_MODE_ENABLE 1
/*the card number support emmc#0:0 emmc#1:1 two card:2*/
#define BB_CARD_NUMBER 2
/*0:legacy 1:High Speed 50MHz 2:HS200 3:HS400 4:Enhance HS400*/
#define BB_MAX_TRANSFER_MODE 4
/* power mode management: 0: Low Power 1:Balance 2:High Performance 3:Direct HP 4:Always L0*/
#define POWER_MANAGEMENT_MODE 4
/* INT_MODE: 0:MSI_X 1:INTx 2:MSI_MULTIPLE 3:MSI_SINGLE */
#define INT_MODE 0
/* The selection of DLL PHASE COUNT is 11 or 14 */
#define DLL_phase_cnt 14
/* 0: fixed output phase  1: auto output tuning */
#define AUTO_OUTPUT_TUNING 1
</code></pre>
<h2 id="批量编辑配置文件"><a href="#批量编辑配置文件" class="headerlink" title="批量编辑配置文件"></a>批量编辑配置文件</h2><p>配置文件def有两个属性<br>1.文件名每个词代表一个功能，各词用下划线“_”分隔<br>2.内部用宏定义实现功能配置，宏定义的值要和外部文件名匹配</p>
<p>基于以上属性，编辑脚本需求为：<br>1.新增：增加一个宏定义，并增加对应的功能缩写到文件名<br>2.修改：修改一个已存在的宏定义，并修改对应的功能缩写到文件名<br>3.删除：删除一个已存在的宏定义，并删除对应的功能缩写到文件名<br>4.其他功能，如直接删除含某缩写的文件，备份原配置文件</p>
<p>shell实现为update.sh,如下:</p>
<pre><code>#!/bin/bash

DEFS_PATH=&quot;./config/defs&quot;
DEFS_BACKUP_PATH=&quot;./config/defs_backup&quot;
DEFS_TEMP_PATH=&quot;./config/defs_temp&quot;

if [ $# -lt 1 ];then
        echo &quot;usage: ./update.sh [option] [args]&quot;

        echo &quot;example 0:&quot;
        echo &quot;        backup defs files:&quot;
        echo &quot;        ./update.sh -bf&quot;
        echo &quot;&quot;

        echo &quot;example 1:&quot;
        echo &quot;        add a macro name and macro value to defs, and add file postfix:&quot;
        echo &quot;        ./update.sh -b&quot;
        echo &quot;        ./update.sh -a balance POWER_MANAGEMENT_MODE 1 &quot;
        echo &quot;        ./update.sh -a high_performance POWER_MANAGEMENT_MODE 2 &quot;
        echo &quot;        add other values...&quot;
        echo &quot;&quot;

        echo &quot;example 2:&quot;
        echo &quot;        update a macro name and macro value to defs, and update file postfix:&quot;
        echo &quot;        ./update.sh -u balance lowpower POWER_MANAGEMENT_MODE 1 &quot;
        echo &quot;&quot;

        echo &quot;example 3:&quot;
        echo &quot;        delete a macro name and macro value of defs, and delete file postfix:&quot;
        echo &quot;        ./update.sh -d lowpower POWER_MANAGEMENT_MODE&quot;
        echo &quot;&quot;

        echo &quot;example 4:&quot;
        echo &quot;        delete target files:&quot;
        echo &quot;        ./update.sh -df lowpower&quot;
        echo &quot;&quot;

        echo &quot;example 5:&quot;
        echo &quot;        clean backup defs files:&quot;
        echo &quot;        ./update.sh -cf&quot;
        echo &quot;&quot;

        exit;
    fi

if [ $1 = &quot;-bf&quot; ];then #backup defs
    mkdir -p $DEFS_BACKUP_PATH
    mv $DEFS_PATH/*.def $DEFS_BACKUP_PATH

elif [ $1 = &quot;-cf&quot; ];then #clear backup defs
    rm -rf $DEFS_BACKUP_PATH
</code></pre>
<p>​<br>​    #add a macro name and macro value to defs, and add file postfix<br>​    elif [ $1 &#x3D; “-a” ];then<br>​<br>        if [ $# !&#x3D; 4 ];then<br>            echo “usage: .&#x2F;update.sh -a FILE_POSTFIX MACRO_NAME MACRO_VALUE”<br>            exit;<br>        fi</p>
<pre><code>    mkdir -p $DEFS_TEMP_PATH &amp;&amp; cp -rf $DEFS_BACKUP_PATH/*.def $DEFS_TEMP_PATH
    
    FILE_POSTFIX=$2
    MACRO_NAME=$3
    MACRO_VALUE=$4
    # sed -i makes change on original file, otherwise on stream
    # xargs transfer multiple output from stream to multiple args to sed
    find $&#123;DEFS_TEMP_PATH&#125; -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
    
    for file in `ls $&#123;DEFS_TEMP_PATH&#125;/*.def`
    do
     mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
    done
    
    cp -rf $DEFS_TEMP_PATH/*.def $DEFS_PATH
    rm -rf $DEFS_TEMP_PATH

#update a macro name and macro value to defs, and update file postfix
elif [ $1 = &quot;-u&quot; ];then

    if [ $# != 5 ];then
        echo &quot;usage: ./update.sh -u ORIGIN_POSTFIX UPDATED_POSTFIX MACRO_NAME MACRO_UPDATED_VALUE&quot;
        exit;
    fi

    ORIGIN_POSTFIX=$2
    UPDATED_POSTFIX=$3
    MACRO_NAME=$4
    MACRO_UPDATED_VALUE=$5

    #replace all lines that pattern matches $MACRO_NAME
    find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
    #update file postfix
    for file in `ls $&#123;DEFS_PATH&#125;/*$ORIGIN_POSTFIX*.def`
    do
         mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
    done
</code></pre>
<p>​<br>​    #delete a macro name and macro value of defs, and delete file postfix<br>​    elif [ $1 &#x3D; “-d” ];then<br>​<br>        if [ $# !&#x3D; 3 ];then<br>            echo “usage: .&#x2F;update.sh -d DELETE_POSTFIX MACRO_NAME”<br>            exit;<br>        fi</p>
<pre><code>    DELETE_POSTFIX=$2
    MACRO_NAME=$3
    #delete all lines that contain $MACRO_NAME
    find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
    #delete file postfix
    for file in `ls $&#123;DEFS_PATH&#125;/*.def`
    do
         mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
    done

#delete target file by postfix
elif [ $1 = &quot;-df&quot; ];then
    
    if [ $# != 2 ];then
        echo &quot;usage: ./update.sh -df DELETE_POSTFIX&quot;
        exit;
    fi

    DELETE_POSTFIX=$2
    rm -f $&#123;DEFS_PATH&#125;/*$DELETE_POSTFIX*.def

fi
</code></pre>
<p><strong>重点讲下其中的几个sed和文件操作</strong><br>1.多个文件，每个文件最后一行追加内容</p>
<pre><code>find $&#123;DEFS_TEMP_PATH&#125; -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
</code></pre>
<ul>
<li>xargs的作用： find <path> -name <string> 输出的是多个文件名，不能直接传给sed， <strong>xargs将多个文件名转化成多个参数</strong>，每个参数是一个文件名，sed可以接收</li>
<li>-i的作用：sed本身是在文件的拷贝上操作，不直接在文件本身修改，-i（insert）使sed的操作在文件上生效，<strong>如果不加-i，源文件不会被修改</strong></li>
<li>$：表示最后一行，sed ‘a\string’是基础格式</li>
<li>注意sed怎么用带空格和变量的字符串：<strong>空格用转义’\ ‘表示，变量是单引号内加双引号</strong>，即’”$ARG”‘</li>
</ul>
<p>2.找到包含字符串A的所有文件，替换内容：将字符串B替换为C</p>
<pre><code>#replace all lines that pattern matches $MACRO_NAME
find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
</code></pre>
<ul>
<li>find | grep 是常用套路，先找在过滤，注意find -name 可以使用*， grep不要用*，否则grep会把它当成要匹配的字符</li>
<li>sed ‘s&#x2F;stringB&#x2F;stringC’是基础格式，g表示全局，注意要-i</li>
</ul>
<p>3.找到包含字符串A的所有文件，删除内容：包含字符串B的行</p>
<pre><code>#delete all lines that contain $MACRO_NAME
find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
</code></pre>
<p>4.对多个文件的文件名，增加，修改，删除特定字符串</p>
<pre><code>#在原文件名最后，后缀之前，增加字符串“_$FILE_POSTFIX”
for file in `ls $&#123;DEFS_TEMP_PATH&#125;/*.def`
    do
     mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
    done

#替换文件名中匹配的字符
for file in `ls $&#123;DEFS_PATH&#125;/*$ORIGIN_POSTFIX*.def`
do
     mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
done

#删除文件名指定字符
for file in `ls $&#123;DEFS_PATH&#125;/*.def`
do
     mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
done
</code></pre>
<ul>
<li>for &lt; args &gt; in `ls &lt; path &gt;`是把多个文件名依次写入变量args的常用操作，类似于xargs，不过是用循环每次处理一个文件名变量</li>
<li>mv $file `echo $file | sed ‘s&#x2F;stringA&#x2F;stringB&#x2F;g’&#96;实际是两个步骤：先用echo把当前处理的文件名传给sed, sed处理完的输出文件名，作为mv的目标文件名，覆盖了原文件</li>
<li>注意，文件名xargs传给sed,处理的是文件内容，for-in-do一个个mv，才是处理文件名本身</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a target="_blank" rel="noopener" href="https://linux.cn/article-11367-1.html">使用 sed 命令查找和替换文件中的字符串的 16 个示例</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40572607/article/details/90812959">sed引入变量的几种方法</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/elong490/article/details/52587171">sed 批量替换文件内容</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/" class="post-title-link" itemprop="url">Linux Shell笔记：文本编辑利器sed+awk+grep</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 14:50:22" itemprop="dateCreated datePublished" datetime="2020-05-30T14:50:22+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:00:29" itemprop="dateModified" datetime="2022-12-05T15:00:29+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shell增删改查概述"><a href="#shell增删改查概述" class="headerlink" title="shell增删改查概述"></a>shell增删改查概述</h1><p>Linux Shell环境对文本增删改查，可以通过sed，awk和grep命令完成。</p>
<ul>
<li>sed: 支持特定模式匹配的增加、插入、删除、替换、提取等操作</li>
<li>awk: 支持特定模式匹配的过滤查找，如提取某行列的字符串</li>
<li>grep: 支持包含特定字符串的结果提取，可配合find和awk实现过滤查找</li>
</ul>
<p>这几种命令都支持流输入和文本输入，支持管道传递参数，也可以命令行传参。对于多个步骤的处理，可以几个命令串行使用。</p>
<h1 id="shell的输入参数概述"><a href="#shell的输入参数概述" class="headerlink" title="shell的输入参数概述"></a>shell的输入参数概述</h1><p>Shell的命令，如<code>cat, echo, sed, awk, grep</code>, 管道命令<code>|</code>等，都要有输入参数，即待处理的数据。<br>输入参数有两种类型：</p>
<ul>
<li>标准输入：本质是stdin文件，即读取该文件的内容作为命令的输入参数，该文件内容可由其他命令的输出，或者用户输入来产生</li>
<li>命令行输入：直接接受用户在命令行输入的字符串，一次性使用,不存储在stdin</li>
</ul>
<p>支持标准输入作为参数的命令：<code>cat, sed, awk, grep, |</code> 等<br>只支持命令行输入字符串的命令：<code>echo, ls</code>等<br>标准输入示例：</p>
<pre><code>cat /etc/passwd | grep root
</code></pre>
<p>上面的代码使用了管道命令<code>|</code>，管道命令的作用是将左侧命令<code>cat /etc/passwd</code>的标准输出转换为标准输入，提供给右侧命令<code>grep root</code>作为参数。<br>以上命令也可以写成命令行输入形式：</p>
<pre><code>grep root /etc/passwd
</code></pre>
<p>不支持标准输入的示例：</p>
<pre><code>echo &quot;hello world&quot; | echo
</code></pre>
<p>输出为空，管道右侧的echo不接受管道传来的标准输入作为参数。<br>xargs的作用：将标准输入转为命令行参数</p>
<pre><code>echo &quot;hello world&quot; | xargs echo
</code></pre>
<p>输出“hello world”，xargs和管道配合使用，能使管道也支持非标准输入命令。<br>xargs支持一些选项做进一步细化处理，如-p(打印), -d(分割) 等。</p>
<h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><h2 id="sed命令概述"><a href="#sed命令概述" class="headerlink" title="sed命令概述"></a>sed命令概述</h2><p>sed支持文本编辑，实现增、删、改的功能。<br>sed命令格式：</p>
<pre><code>sed [options] &#39;command&#39; filename
</code></pre>
<p>sed的输入参数可以用命令行，管道和xargs传入：</p>
<pre><code>//命令行传入文件名参数
sed [options] &#39;command&#39; filename 
//管道传入文件名参数
cat filename | sed [options] &#39;command&#39;
//xargs传入文件名参数
cat filename | xargs sed [options] &#39;command&#39;
</code></pre>
<p>sed对文件的编辑在缓冲区，不直接修改文本。要直接修改文本有以下方法：</p>
<ul>
<li>重定向覆盖文本， <code>sed - x &#39;XXX&#39; file.txt &gt; file.txt</code></li>
<li>特定的sed命令支持直接修改文本，如<code>sed -i &#39;XXX&#39; file.txt</code></li>
</ul>
<p>sed的常用选项：</p>
<pre><code>-n ：关闭默认输出,只显示匹配的行
-i ：直接修改读取的文件内容，而不是输出到终端。
-e ：直接在命令列模式上进行sed的动作编辑；
-f ：直接将sed的动作写在一个文件内，-f filename 则可以运行filename内的sed动作；
-r ：启用扩展的正则表达式
</code></pre>
<p>sed的常用命令：</p>
<pre><code>a ：新增行，在指定行的后面附加一行，[address]a\新文本内容
i ：插入行，在指定行的前面插入一行，[address]i\新文本内容
s ：替换特定模式匹配的字符串, [address]s/pattern/replacement/flags
c ：将指定行中的所有内容，替换成该选项后面的字符串, [address]c\用于替换的新文本
d ：删除行，[address]d
p ：打印， 通常与参数 -n 一起用，[address]p
w : 将文本中指定行的内容写入文件, [address]w filename
</code></pre>
<h2 id="sed命令详解"><a href="#sed命令详解" class="headerlink" title="sed命令详解"></a>sed命令详解</h2><p>本节从sed文本操作的“增删改查”举例说明其具体命令用法</p>
<h3 id="新增和插入：a和i"><a href="#新增和插入：a和i" class="headerlink" title="新增和插入：a和i"></a>新增和插入：a和i</h3><p>sed的命令a和i都能实现新增行，其区别在于：</p>
<ul>
<li>a ：append, 指定行后面新增一行</li>
<li>i : insert, 表示在指定行前面插入一行</li>
</ul>
<p>注意区分i命令和i选项<br>a和i命令的基本格式完全相同：</p>
<pre><code>[address]a（或 i）\新文本内容
</code></pre>
<p>将一个新行插入到数据流第三行前：</p>
<pre><code>sed &#39;3i\This is an inserted line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is an inserted line.
This is line number 3.
This is line number 4.
</code></pre>
<p>将一个新行附加到数据流中第三行后:</p>
<pre><code>sed &#39;3a\This is an appended line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is line number 3.
This is an appended line.
This is line number 4.
</code></pre>
<p>将一个多行数据添加到数据流中，只需对要行末尾添加反斜线即可，类似C语言的代码换行</p>
<pre><code>sed &#39;1i\
This is one line of new text.\
This is another line of new text.&#39; data6.txt

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
</code></pre>
<h3 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h3><ul>
<li>d: delete, 删除行</li>
</ul>
<p>格式：</p>
<pre><code>[address]d
</code></pre>
<p>删除第三行：</p>
<pre><code>[root@localhost ~]# cat data6.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
[root@localhost ~]# sed &#39;3d&#39; data6.txt
This is line number 1.
This is line number 2.
This is line number 4.
</code></pre>
<p>删除二、三行：</p>
<pre><code>sed &#39;2,3d&#39; data6.txt
This is line number 1.
This is line number 4.
</code></pre>
<p>删除第三行开始的后续所有行：</p>
<pre><code>[root@localhost ~]# sed &#39;3,$d&#39; data6.txt
This is line number 1.
This is line number 2.
</code></pre>
<p>注意：sed d 命令并不会修改原始文件，这里被删除的行只是从 sed 的缓冲区中消失了，原始文件没做任何改变，若要修改源文件，可重定向sed的输出到源文件，覆盖原内容使修改生效。</p>
<h3 id="匹配定位：-x2F-pattern-x2F"><a href="#匹配定位：-x2F-pattern-x2F" class="headerlink" title="匹配定位：&#x2F;pattern&#x2F;"></a>匹配定位：&#x2F;pattern&#x2F;</h3><p>sed的增删操作，可以针对包含匹配字符串的行进行操作，其原理是活用[address], 支持匹配字符串的定位，以插入命令’i’为例，匹配格式如下：</p>
<pre><code>sed [option] &#39;/匹配字符串/i \插入字符串&#39;
[option] 通常为 -i, 修改直接在源文件生效
</code></pre>
<p>原文件：</p>
<pre><code>cat testfile 
hello
</code></pre>
<p>在包含”hello”的一行的上一行，插入”upline”:</p>
<pre><code>sed -i &#39;/hello/i\upline&#39; testfile
</code></pre>
<p>“hello”下一行插入”upline”:</p>
<pre><code>sed -i &#39;/hello/a\down&#39; testfile
</code></pre>
<p>修改后的文件：</p>
<pre><code>cat testfile 
up
hello
down
</code></pre>
<p>删除匹配到”hello”的行：</p>
<pre><code>sed -i &#39;/hello/d&#39; testfile
</code></pre>
<p>如果匹配字符串有“&#x2F;”，为了和sed命令的分隔符“&#x2F;”，使用“\”转义。<br>例如删除匹配某个路径字符串的行：</p>
<pre><code>匹配&quot;\etc\install.sh&quot;
set -i &#39;/\/etc\/install.sh/d&#39; test.txt
</code></pre>
<p>sed 命令包含一些预定义特殊符号，代表行尾，行首等。<br>删除以A开头的行：</p>
<pre><code>sed -i &#39;/^A.*/d&#39; test.txt
^A表示开头是A, .*表示后跟任意字符串
</code></pre>
<p>在行尾追加一行内容:</p>
<pre><code>sed -i &#39;$a\added-content&#39; test.txt
$表示定位到行尾，a是追加命令，added-content是追加内容
</code></pre>
<h3 id="替换修改-s"><a href="#替换修改-s" class="headerlink" title="替换修改: s"></a>替换修改: s</h3><p>s替换命令内部格式为：</p>
<pre><code>[address]s/pattern/replacement/flags
</code></pre>
<ul>
<li>address 指定要操作的具体行</li>
<li>pattern 指定需要替换的内容</li>
<li>replacement 指定替换的新内容</li>
<li>flags 指定特殊功能</li>
</ul>
<p>常用的flags:</p>
<ul>
<li>n    1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换</li>
<li>g    对数据中所有匹配到的内容进行替换，否则只会在第一次匹配成功时做替换操作</li>
<li>p    会打印与替换命令中指定的模式匹配的行。此标记通常与 -n    选项一起使用</li>
<li>\    转义（转义替换部分包含：&amp;、\ 等）。</li>
</ul>
<p>替换每行第二个匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/2&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the trial script
This is second test of the trial script
</code></pre>
<p>只替换第二行的匹配字符串：</p>
<pre><code>sed &#39;2s/test/trial/&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the test script
This is second test of the trial script
</code></pre>
<p>全局替换所有匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/g&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first trial of the trial script
This is second trial of the trial script
</code></pre>
<h3 id="提取：p"><a href="#提取：p" class="headerlink" title="提取：p"></a>提取：p</h3><p>sed p命令配合字符串匹配，可以输出包含指定字符串的行内容。</p>
<pre><code>sed -n &#39;/string/p&#39; filename
提取filename文件中,所有包含string的行的内容，并打印到标准输出
-n是只打印匹配命中的内容
</code></pre>
<p>sed p和grep都能提取内容，其区别在于：</p>
<ul>
<li><code>sed &#39;/string/p&#39;</code>是提取指定文件的行内容，重点在内容提取</li>
<li><code>grep &quot;string&quot; path</code>是输出包含指定内容的所有文件路径，重点在查找文件位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452182.png" alt="image-20221205145238133"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452191.png" alt="image-20221205145248149"></p>
<h2 id="sed进阶与实战"><a href="#sed进阶与实战" class="headerlink" title="sed进阶与实战"></a>sed进阶与实战</h2><h3 id="多文件批量追加和删除"><a href="#多文件批量追加和删除" class="headerlink" title="多文件批量追加和删除"></a>多文件批量追加和删除</h3><p>背景介绍：<br>底层固件代码有一些功能由宏定义控制，不同功能需要不同的宏定义组合，因此有不同的宏定义文件，命名为.def后缀。批量编译不同版本，编译脚本依次提取def文件夹内的.def文件和源代码一起编译。单个def内容如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453765.png" alt="image-20221205145321718"></p>
<p>每一个宏都有多个取值，因此组合起来，需要生成一堆.def文件，批量编译才能覆盖各自功能。<br>每新增一个宏，都要修改所有.def文件，如果这个宏有两个取值，.def文件数量将翻倍。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453942.png" alt="image-20221205145327892"></p>
<p>人工修改过于低效，使用sed可解决此问题。</p>
<p>查找指定文件，并批量追加一行内容：</p>
<pre><code>find . -name &#39;*.def*&#39; | xargs sed -i &#39;$a\added-content&#39;
</code></pre>
<p>各命令含义：</p>
<pre><code>find [path] -name &quot;*.def&quot;
查找path路径下，以.def结尾的所有文件，结果存储在stdout
|
管道，将查找结果转存到标准输入stdin
xargs
查找结果有很多个，用xargs转成命令行输入，sed才能批量处理
sed -i &#39;$a\added-content&#39;
    -i 直接修改文件，&#39;$a\added-content&#39; 最后一行追加added-content
</code></pre>
<p>查找指定文件，并批量删除匹配某字符串的行：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/deleteString/d&quot;
</code></pre>
<p>查找指定文件，并批量替换匹配某字符串：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/oldString/newString/&quot;
</code></pre>
<p>在实际shell脚本中，通常由用户输入变量，<code>$1, $2, $@</code> 解析变量。a、i、d和s能否在命令中使用双引号解析变量，实现动态编辑？<br>实验如下：</p>
<pre><code>ARGS=&quot;AA BB&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$a\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$i\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/$&#123;ARGS&#125;/d&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/aabb/$ARGS/&quot;
</code></pre>
<ul>
<li>i 和 a 命令不能解析变量，实际追加的就是是${ARGS}</li>
<li>d命令可以解析变量，实际删除的是有”AA BB”的行</li>
<li>s命令可以解析变量，实际替换后的结果是”AA BB”</li>
</ul>
<p>结论：将命令中的单引号改成双引号，理论上可以解析$包含的变量，实际上有的命令支持，有的命令不支持。</p>
<h3 id="提取文件中的关键内容"><a href="#提取文件中的关键内容" class="headerlink" title="提取文件中的关键内容"></a>提取文件中的关键内容</h3><p>背景介绍：<br>底层固件需要将代码段、数据段等关键信息存储在固件头部，编译过程中用编译器的size命令可以获取这些信息，并存储到文本，但是固件头部需要按自己的格式存储起始地址和大小信息，因此需要用sed提取并编辑该文本。</p>
<p>原文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453983.png" alt="image-20221205145348933"></p>
<p>提取后文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453414.png"></p>
<p>sed命令：</p>
<pre><code>sed -n &#39;/string/p&#39; oldFile | awk &#39;&#123;print $3&#125;&#39; &gt;&gt; newFile
提取oldFile内包含string的行，并用awk提取第三列，再写入newFile
</code></pre>
<p>该命令在Makefile实现，需要根据Makefile和shell特性做修改：</p>
<ul>
<li>@：编译过程隐藏命令输出，类似于后台执行</li>
<li>$(shell xxxx): Makefile执行shell命令</li>
<li>$$: Makefile不能直接用shell的“$”解析变量，用“$$”</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051454928.png" alt="image-20221205145409877"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/" class="post-title-link" itemprop="url">Linux Shell笔记：判断语句if-then-else-fi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-05 14:46:30" itemprop="dateCreated datePublished" datetime="2020-05-05T14:46:30+08:00">2020-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:00:22" itemprop="dateModified" datetime="2022-12-05T15:00:22+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>shell中if-then-else-fi判断语句如下：</p>
<pre><code>a=&quot;abc&quot;

if [ $a = &quot;abc&quot; ]
then
   echo &quot;$a = $b&quot;
else
   echo &quot;$a != $b&quot;
fi
</code></pre>
<p>注意以下几点：</p>
<ul>
<li>shell中的等号：<code>=</code>可用于赋值，也可以用于判断；<code>==</code>只用于判断，更规范</li>
<li>shell中的if语句各符号间都要空格分隔：<code>if</code>和<code>[ ]</code>之间要空格；<code>[ ]</code>和<code>“ ”</code>之间要空格； <code>&quot;</code>和<code>=</code>之间要空格。否则if语句中的符号会解析失败。</li>
<li>shell变量没有数据类型的区分，把任何存储在变量中的值，皆视为“字符串”</li>
<li>对于变量可能为空的情况，需要用双括号<code>[[ $a = &quot;abc&quot; ]]</code></li>
<li>if-then可以写在同一行，用;分隔两个语句：<code>if [ $a = &quot;abc&quot; ];then</code></li>
</ul>
<h1 id="不同类型的判断语句"><a href="#不同类型的判断语句" class="headerlink" title="不同类型的判断语句"></a>不同类型的判断语句</h1><h2 id="关系运算符判断"><a href="#关系运算符判断" class="headerlink" title="关系运算符判断"></a>关系运算符判断</h2><p>-eq    检测两个数是否相等，相等返回 true。    [ $a -eq $b ] 返回 false。</p>
<p>-ne    检测两个数是否不相等，不相等返回 true。    [ $a -ne $b ] 返回 true。</p>
<p>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ] 返回 false。</p>
<p>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ] 返回 true。</p>
<p>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。    [ $a -ge $b ] 返回 false。</p>
<p>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。    [ $a -le $b ] 返回 true。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>
<h2 id="布尔和逻辑运算符判断"><a href="#布尔和逻辑运算符判断" class="headerlink" title="布尔和逻辑运算符判断"></a>布尔和逻辑运算符判断</h2><p>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ] 返回 true。</p>
<p>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ] 返回 true。</p>
<p>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a == $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>
<p>&amp;&amp;    逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</p>
<p>||    逻辑的 OR    [[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<pre><code>#!/bin/bash

a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>
<h2 id="字符串运算符判断"><a href="#字符串运算符判断" class="headerlink" title="字符串运算符判断"></a>字符串运算符判断</h2><p>&#x3D;    检测两个字符串是否相等，相等返回 true。    [ $a &#x3D; $b ] 返回 false。</p>
<p>!&#x3D;    检测两个字符串是否相等，不相等返回 true。    [ $a !&#x3D; $b ] 返回 true。</p>
<p>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。  </p>
<p>-n    检测字符串长度是否不为 0，不为 0 返回 true。    [ -n “$a” ] 返回 true。</p>
<p><code>$</code> 检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。</p>
<pre><code>#!/bin/bash

a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a != $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a = $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n &quot;$a&quot; ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>
<h2 id="文件检查运算符判断"><a href="#文件检查运算符判断" class="headerlink" title="文件检查运算符判断"></a>文件检查运算符判断</h2><p>b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ] 返回 false。</p>
<p>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -c $file ] 返回 false。</p>
<p>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ] 返回 false。</p>
<p>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。</p>
<p>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] 返回 false。</p>
<p>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。</p>
<p>-p file    检测文件是否是有名管道，如果是，则返回 true。    [ -p $file ] 返回 false。</p>
<p>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。</p>
<p>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。</p>
<p>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。</p>
<p>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。</p>
<p>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。</p>
<p>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。</p>
<p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。</p>
<pre><code>#!/bin/bash

file=&quot;/root/test.sh&quot;

if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>
<h1 id="判断语句报错：”unary-operator-expected”"><a href="#判断语句报错：”unary-operator-expected”" class="headerlink" title="判断语句报错：”unary operator expected”"></a>判断语句报错：”unary operator expected”</h1><p>在匹配字符串相等时，用了类似这样的语句：</p>
<pre><code>if [ $STATUS == &quot;OK&quot; ]; then     
echo &quot;OK&quot;
fi
</code></pre>
<p>在运行时出现了 <code>[: =: unary operator expected</code> 的错误</p>
<pre><code>if [[ $STATUS == &quot;OK&quot; ]]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>究其原因，是因为如果变量STATUS值为空，那么就成了 [ &#x3D; “OK”] ，显然 [ 和 “OK” 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。<br>或者用下面的方法也能避免这种错误：</p>
<pre><code>if [ &quot;$STATUS&quot;x == &quot;OK&quot;x ]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>当然，x也可以是其他字符。shell中有没有双引号在很多情况下是一致的,因此x可以不加引号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/02/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Linux常用命令行笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-15 14:30:12" itemprop="dateCreated datePublished" datetime="2020-02-15T14:30:12+08:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 14:33:26" itemprop="dateModified" datetime="2022-12-05T14:33:26+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="查找包含指定内容的文件"><a href="#查找包含指定内容的文件" class="headerlink" title="查找包含指定内容的文件"></a>查找包含指定内容的文件</h1><pre><code>grep -r 字符串 目录
</code></pre>
<p>示例：查找当前目录的包含“stream”内容的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &quot;stream&quot; ./</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
