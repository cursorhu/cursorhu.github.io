<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/3/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">多线程笔记：多线程的同步机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 15:21:04" itemprop="dateCreated datePublished" datetime="2021-07-05T15:21:04+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:22:59" itemprop="dateModified" datetime="2022-12-05T15:22:59+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文讲解并发环境中的几个线程同步示例<br>线程同步，即多个线程如何协调，谁先谁后<br>本文基于Linux&#x2F;POSIX API<br>本系列源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p>生产者&#x2F;消费者模式是并发环境常见的模式，简单地讲，通过中介缓冲，支持多组任务并发执行，避免任务间发生通信阻塞。<br>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/darkdragonking/article/details/89208124">生产者&#x2F;消费者模式的理解及实现</a></p>
<p>常用的实现方式</p>
<ul>
<li>互斥量(参考<a target="_blank" rel="noopener" href="http://47.100.221.149:9010/blog/post/admin/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89">多线程入门（一）</a>)</li>
<li>信号量</li>
<li>条件变量</li>
<li>读写锁</li>
</ul>
<h1 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h1><p>关于LInux信号量：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e72ff770244">Linux信号量</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
&#123;
public:
    Task(int taskID)
    &#123;
        this-&gt;taskID = taskID;
    &#125;
    
    void doTask()
    &#123;
        std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
    &#125;
    
private:
    int taskID;
&#125;;

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
sem_t            mysemaphore;

void* consumer_thread(void* param)
&#123;    
    Task* pTask = NULL;
    while (true)
    &#123;
        struct timespec ts;
        ts.tv_sec = 3;
        ts.tv_nsec = 0;
        
        if (sem_timewait(&amp;mysemaphore, &amp;ts) != 0)
        &#123;
            if (errno == ETIMEOUT)
            &#123;
                std::cout &lt;&lt; &quot;ETIMEOUT&quot; &lt;&lt; std::endl;
            &#125;
            continue;
        &#125;
        
        if (tasks.empty())
            continue;
        
        pthread_mutex_lock(&amp;mymutex);    
        pTask = tasks.front();
        tasks.pop_front();
        pthread_mutex_unlock(&amp;mymutex);
        
        pTask-&gt;doTask();
        delete pTask;
    &#125;
    
    return NULL;
&#125;

void* producer_thread(void* param)
&#123;
    int taskID = 0;
    Task* pTask = NULL;
    
    while (true)
    &#123;
        pTask = new Task(taskID);
            
        pthread_mutex_lock(&amp;mymutex);
        tasks.push_back(pTask);
        std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
        
        pthread_mutex_unlock(&amp;mymutex);
        
        //释放信号量，通知消费者线程
        sem_post(&amp;mysemaphore);
        
        taskID ++;

        //休眠1秒
        sleep(1);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_mutex_init(&amp;mymutex, NULL);
    //初始信号量资源计数为0
    sem_init(&amp;mysemaphore, 0, 0);

    //创建5个消费者线程
    pthread_t consumerThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
    &#125;
    
    //创建一个生产者线程
    pthread_t producerThreadID;
    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

    pthread_join(producerThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(consumerThreadID[i], NULL);
    &#125;
    
    sem_destroy(&amp;mysemaphore);
    pthread_mutex_destroy(&amp;mymutex);

    return 0;
&#125;
</code></pre>
<p>说明几点：</p>
<ul>
<li>信号量和锁一样，全局的</li>
<li>sem_post和sem_wait是P(), V()操作的具体实现，即计数+1，-1</li>
</ul>
<h1 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h1><p>关于条件变量(cv)：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/harlanc/p/8596211.html">深入解析条件变量(condition variables)</a><br>条件变量同锁一起使用使得线程可以以一种无竞争的方式等待任意条件的发生。所谓无竞争就是，条件改变这个信号会发送到所有等待这个信号的线程。</p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;list&gt;
#include &lt;semaphore.h&gt;
#include &lt;iostream&gt;

class Task
&#123;
public:
    Task(int taskID)
    &#123;
        this-&gt;taskID = taskID;
    &#125;
    
    void doTask()
    &#123;
        std::cout &lt;&lt; &quot;handle a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
    &#125;
    
private:
    int taskID;
&#125;;

pthread_mutex_t  mymutex;
std::list&lt;Task*&gt; tasks;
pthread_cond_t   mycv;

void* consumer_thread(void* param)
&#123;    
    Task* pTask = NULL;
    while (true)
    &#123;
        pthread_mutex_lock(&amp;mymutex);
        while (tasks.empty())
        &#123;                
            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
            pthread_cond_wait(&amp;mycv, &amp;mymutex);
        &#125;
        
        pTask = tasks.front();
        tasks.pop_front();

        pthread_mutex_unlock(&amp;mymutex);
        
        if (pTask == NULL)
            continue;

        pTask-&gt;doTask();
        delete pTask;
        pTask = NULL;        
    &#125;
    
    return NULL;
&#125;

void* producer_thread(void* param)
&#123;
    int taskID = 0;
    Task* pTask = NULL;
    
    while (true)
    &#123;
        pTask = new Task(taskID);
            
        pthread_mutex_lock(&amp;mymutex);
        tasks.push_back(pTask);
        std::cout &lt;&lt; &quot;produce a task, taskID: &quot; &lt;&lt; taskID &lt;&lt; &quot;, threadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; 
        
        pthread_mutex_unlock(&amp;mymutex);
        
        //释放条件信号，通知消费者线程
        pthread_cond_signal(&amp;mycv);
        
        taskID ++;

        //休眠1秒
        sleep(1);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_mutex_init(&amp;mymutex, NULL);
    pthread_cond_init(&amp;mycv, NULL);

    //创建5个消费者线程
    pthread_t consumerThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);
    &#125;
    
    //创建一个生产者线程
    pthread_t producerThreadID;
    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);

    pthread_join(producerThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(consumerThreadID[i], NULL);
    &#125;
    
    pthread_cond_destroy(&amp;mycv);
    pthread_mutex_destroy(&amp;mymutex);

    return 0;
&#125;
</code></pre>
<h1 id="读写锁实现"><a href="#读写锁实现" class="headerlink" title="读写锁实现"></a>读写锁实现</h1><p>关于读写锁，参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/love-DanDan/p/8723931.html">Linux：使用读写锁使线程同步</a></p>
<p>示例：</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;

int resourceID = 0;
pthread_rwlock_t myrwlock;

void* read_thread(void* param)
&#123;    
    while (true)
    &#123;
        //请求读锁
        pthread_rwlock_rdlock(&amp;myrwlock);

        std::cout &lt;&lt; &quot;read thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
                
        //使用睡眠模拟读线程读的过程消耗了很久的时间
        sleep(1);
                
        pthread_rwlock_unlock(&amp;myrwlock);
    &#125;
    
    return NULL;
&#125;

void* write_thread(void* param)
&#123;
    while (true)
    &#123;
        //请求写锁
        pthread_rwlock_wrlock(&amp;myrwlock);

        ++resourceID;
        std::cout &lt;&lt; &quot;write thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;
                
        //使用睡眠模拟读线程读的过程消耗了很久的时间
        sleep(1);
                
        pthread_rwlock_unlock(&amp;myrwlock);
    &#125;
    
    return NULL;
&#125;

int main()
&#123;
    pthread_rwlock_init(&amp;myrwlock, NULL);

    //创建5个请求读锁线程
    pthread_t readThreadID[5];
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);
    &#125;
    
    //创建一个请求写锁线程
    pthread_t writeThreadID;
    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);

    pthread_join(writeThreadID, NULL);
    
    for (int i = 0; i &lt; 5; ++i)
    &#123;
        pthread_join(readThreadID[i], NULL);
    &#125;
    
    pthread_rwlock_destroy(&amp;myrwlock);

    return 0;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/07/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">多线程笔记：线程库的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 15:21:19" itemprop="dateCreated datePublished" datetime="2021-07-02T15:21:19+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 10:26:55" itemprop="dateModified" datetime="2022-12-08T10:26:55+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>多线程概述：应用层的多线程的目的就是让每一个任务（例如一系列函数调用）都认为自己独占CPU资源，即宏观上，多个任务可以同时执行（实际可能是轮转的串行执行）。<br>代码实现：线程库可以由编程语言的标准库或者操作系统的库实现，具体包含的头文件如下：</p>
<ul>
<li>C&#x2F;C++ : &lt; thread &gt;</li>
<li>POSIX(Portable Operating System Interface of UNIX, Linux环境使用较多) ：&lt; pthread.h &gt;</li>
<li>Windows OS : &lt; windows.h &gt;</li>
</ul>
<p>具体环境使用哪个库，有不同的观点，参考<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36236334/answer/98422670">c++多线程编程主要用pthread还是c++11中的thread类？</a><br>即使是同一环境，也有不同封装层次的API<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22642239/article/details/90445414">CreateThread()与_beginthread()的区别详细解析</a></p>
<p>主线程与工作线程：<br>一般应用程序都有主要的执行流程，例如C&#x2F;C++的main入口函数，主要执行流程是在进程中执行的，也可以认为main是线程，独占了进程的全部资源，称为主线程。如果在该进程执行时，创建多个线程，用于并行处理其他任务，称为工作线程。</p>
<p>本文讲不同风格的线程创建\销毁，和访问共享数据的锁操作<br>本系列源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/SimpleMultiThread">cursorhu&#x2F;SimpleMultiThread</a></p>
<h1 id="Windows风格多线程"><a href="#Windows风格多线程" class="headerlink" title="Windows风格多线程"></a>Windows风格多线程</h1><p>(1)双线程打印</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s &lt;&lt; endl;
    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    CloseHandle(hThread);
    
    return 0;
&#125;
</code></pre>
<p>主线程和工作线程都运行Print()，各线程的栈空间保存自己的局部数据。<br>windows API使用CreateThread和CloseHandle创建线程、释放线程句柄，说明如下</p>
<pre><code>HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD：线程安全相关的属性，常置为NULL
    SIZE_T dwStackSize,//initialstacksize：新线程的初始化栈的大小，可设置为0
    LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction：被线程执行的回调函数，也称为线程函数
    LPVOID lpParameter,//threadargument：传入线程函数的参数，不需传递参数时为NULL
    DWORD dwCreationFlags,//creationoption：控制线程创建的标志
    LPDWORD lpThreadId//threadidentifier：传出参数，用于获得线程ID，如果为NULL则不返回线程ID
    )
 
/*
lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，决定返回的句柄是否可被子进程继承，如果为NULL则表示返回的句柄不能被子进程继承。
dwStackSize：设置初始栈的大小，以字节为单位，如果为0，那么默认将使用与调用该函数的线程相同的栈空间大小。
任何情况下，Windows根据需要动态延长堆栈的大小。
lpStartAddress：指向线程函数的指针，函数名称没有限制，但是必须以下列形式声明：
DWORD WINAPI 函数名 (LPVOID lpParam) ，格式不正确将无法调用成功。
lpParameter：向线程函数传递的参数，是一个指向结构的指针，不需传递参数时，为NULL。
dwCreationFlags：控制线程创建的标志，可取值如下：
（1）CREATE_SUSPENDED(0x00000004)：创建一个挂起的线程（就绪状态），直到线程被唤醒时才调用
（2）0：表示创建后立即激活。
（3）STACK_SIZE_PARAM_IS_A_RESERVATION(0x00010000)：dwStackSize参数指定初始的保留堆栈的大小，
如果STACK_SIZE_PARAM_IS_A_RESERVATION标志未指定，dwStackSize将会设为系统预留的值
lpThreadId:保存新线程的id
返回值：函数成功，返回线程句柄，否则返回NULL。如果线程创建失败，可通过GetLastError函数获得错误信息。
*/
 
BOOL WINAPI CloseHandle(HANDLE hObject);        //关闭一个被打开的对象句柄
/*可用这个函数关闭创建的线程句柄，如果函数执行成功则返回true(非0),如果失败则返回false(0)，
如果执行失败可调用GetLastError.函数获得错误信息。
*/
</code></pre>
<p>LPVOID 与 std::string类型的转换，需要用char*类型作中介，LPVOID接受buffer数组类型的转换<br>注意CloseHandle只是释放句柄资源，线程的资源释放是其函数执行完毕自动销毁的。</p>
<p>2次的运行结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png" alt="image-20221205152628474"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526515.png"></p>
<p>可见，两个线程是随机切换的，导致如下现象：</p>
<ul>
<li>Print()内的<code>cout &lt;&lt; s</code>和<code>&lt;&lt;endl</code>之间线程被切换，导致没有换行+双重换行。</li>
<li>存在工作线程没执行完，主线程就执行完导致main return，整个进程销毁的情况。</li>
</ul>
<p>改进如下：</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;
    for (int i = 0; i &lt; 10; i++)
        cout &lt;&lt; s;
    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread\n&quot;;
    std::string s2 = &quot;Main thread\n&quot;;
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    CloseHandle(hThread);
    Sleep(100);
    return 0;
&#125;
</code></pre>
<p>使用以下方法解决上述问题</p>
<ul>
<li><p>主线程完成Print后，休眠100s，这个时间足够工作线程完成，Sleep结束后，main进程执行完毕</p>
</li>
<li><p>把换行放到字符串中，使该字符串的完整打印成为不可被中途切换的操作，即原子操作</p>
</li>
</ul>
<p>输出如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526645.png" alt="image-20221205152645608"></p>
<p>如果Print有很多句打印，又不希望中途切换线程，如何做？</p>
<ul>
<li>互斥锁可以实现“大块代码的原子操作”</li>
<li>锁是全局变量，因为主线程main和工作线程Print都能看到全局变量，而看不到对方的局部变量</li>
</ul>
<p>代码如下:</p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;windows.h&gt;   
using namespace std;
 
HANDLE hMutex = NULL;//互斥锁的句柄

DWORD WINAPI Print(LPVOID lpParamter)
&#123;
    std::string s = (char*)lpParamter;

    for (int i = 0; i &lt; 10; i++)
    &#123;
        WaitForSingleObject(hMutex, INFINITE);//请求锁
        cout &lt;&lt; s &lt;&lt; endl;
        ReleaseMutex(hMutex);//释放锁
    &#125;

    return 0;
&#125;
 
int main()
&#123;
    std::string s1 = &quot;Work thread&quot;;
    std::string s2 = &quot;Main thread&quot;;

    hMutex = CreateMutex(NULL, FALSE, NULL); //创建互斥锁
    HANDLE hThread = CreateThread(NULL, 0, Print, (LPVOID)s1.c_str(), 0, NULL);
    Print((LPVOID)s2.c_str());
    
    CloseHandle(hThread);
    CloseHandle(hMutex);//销毁互斥锁
    
    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051526485.png" alt="image-20221205152654439"><br>关于windows的互斥锁：</p>
<pre><code>互斥量：
        采用互斥对象机制。互斥锁，像一个物件，这个物件只能同时被一个线程持有。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。
        一、创建 创建互斥锁的方法是调用函数CreateMutex： CreateMutex(&amp;sa, bInitialOwner, szName);第一个参数是一个指向SECURITY_ATTRIBUTES结构体的指针，一般的情况下，可以是nullptr。 第二个参数类型为BOOL，表示互斥锁创建出来后是否被当前线程持有。 第三个参数类型为字符串（const TCHAR*），是这个互斥锁的名字，如果是nullptr，则互斥锁是匿名的。 例： HANDLE hMutex = CreateMutex(nullptr, FALSE, nullptr);上面的代码创建了一个匿名的互斥锁，创建出来后，当前线程不持有这个互斥锁。

         二、持有 WaitForSingleObject函数可以让一个线程持有互斥锁。用法： WaitForSingleObject(hMutex, dwTimeout);这个函数的作用比较多。这里只介绍第一个参数为互斥锁句柄时的作用。 它的作用是等待，直到一定时间之后，或者，其他线程均不持有hMutex。第二个参数是等待的时间（单位：毫秒），如果该参数为INFINITE，则该函数会一直等待下去。

        三、释放 用ReleaseMutex函数可以让当前线程“放开”一个互斥锁（不持有它了），以便让其他线程可以持有它。用法 ReleaseMutex(hMutex)

         四、销毁 当程序不再需要互斥锁时，要销毁它。 CloseHandle(hMutex)

         五、命名互斥锁 如果CreateMutex函数的第三个参数传入一个字符串，那么所创建的锁就是命名的。当一个命名的锁被创建出来以后，当前进程和其他进程如果试图创建相同名字的锁，CreateMutex会返回原来那把锁的句柄，并且GetLastError函数会返回ERROR_ALREADY_EXISTS。这个特点可以使一个程序在同一时刻最多运行一个实例
</code></pre>
<h1 id="C-风格多线程"><a href="#C-风格多线程" class="headerlink" title="C++风格多线程"></a>C++风格多线程</h1><p>双线程分别实现计算和打印</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 1;
std::mutex g_mutex;

void thread_func1()
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>几点说明：</p>
<ul>
<li>C++使用&lt; thread &gt;调用线程库</li>
<li>std::thread t(thread_func)创建一个thread对象，传入参数为thread_fun，即线程内执行的函数</li>
<li>t.join()的含义是，线程t执行完毕后，join函数才能返回，主线程才能继续向后执行，宏观上就是，主线程被t线程阻塞在join函数处，这也许就是join的含义，t线程“加入”主线程的队伍，主线程必须原地等待t准备好了（执行完了）才能继续向后走。</li>
<li>由于全局数据g_mydata和打印语句都不是原子操作，要保证完整操作，需要加锁，库定义在&lt; mutex &gt;</li>
<li>为什么要sleep? 注意两个工作线程都while循环操作，sleep是手动使当前线程休眠，操作系统会轮换到其他active状态的线程执行，如果不sleep, 一个线程一直执行再被OS切换，间隔可能很久。&lt; chrono &gt;库用于时间</li>
<li>INT_MAX是C++定义的int类最大值，2^31-1</li>
</ul>
<p>运行结果:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051527091.png" alt="image-20221205152705047"></p>
<h1 id="POSIX-x2F-Linux风格"><a href="#POSIX-x2F-Linux风格" class="headerlink" title="POSIX&#x2F;Linux风格"></a>POSIX&#x2F;Linux风格</h1><p>逻辑同上节，代码如下</p>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;limits.h&gt; //for INT_MAX

int g_mydata = 1;
pthread_mutex_t m;

void* thread_function1(void* args)
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;
        pthread_mutex_lock(&amp;m);
        ++g_mydata;
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    &#125;
    
    return NULL;
&#125; 

void* thread_function2(void* args)
&#123;
    while (g_mydata &lt; INT_MAX)
    &#123;    
        pthread_mutex_lock(&amp;m);
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID: &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl;
        pthread_mutex_unlock(&amp;m);
        sleep(1);
    &#125;
    
    return NULL;
&#125; 

int main()
&#123;
    pthread_mutex_init(&amp;m, NULL);
    
    pthread_t threadIDs[2];    
    pthread_create(&amp;threadIDs[0], NULL, thread_function1, NULL);
    pthread_create(&amp;threadIDs[1], NULL, thread_function2, NULL);
    
    for(int i = 0; i &lt; 2; ++i)
    &#123;
        pthread_join(threadIDs[i], NULL);
    &#125;
    
    pthread_mutex_destroy(&amp;m);

    return 0;
&#125;
</code></pre>
<p>win32应用程序使用pthread，需要配置pthread dll库，下载地址和配置方法：<br><a target="_blank" rel="noopener" href="http://sourceware.org/pthreads-win32/">pthreads-win32</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhigang/p/7326022.html">VS2013 配置pthread</a></p>
<p>pthread的几个锁，参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/guotianqing/article/details/80559865">linux线程互斥量pthread_mutex_t使用简介</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/04/17/Vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/Vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Vim使用笔记.</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 12:30:05" itemprop="dateCreated datePublished" datetime="2021-04-17T12:30:05+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 14:37:07" itemprop="dateModified" datetime="2022-12-06T14:37:07+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在ChromeOS上做一些shell script测试用例开发，ChromeOS基于Debian9，但没有Ubuntu那种GNOME的gedit编辑器，更不谈安装Linux版VSCode，正好借此机会练习一下之前一直不熟悉的vim编辑器。</p>
<p>ChromeOS不方便截图，所以本文以ubuntu上的linux0.11代码为例，整理vim最常用的操作。</p>
<p>关于Linux上的文本编辑器基础概念，可以参考&lt;Linux命令行与shell脚本编程大全.第3版&gt;</p>
<h2 id="1-三种编辑模式"><a href="#1-三种编辑模式" class="headerlink" title="1. 三种编辑模式"></a>1. 三种编辑模式</h2><p>我将vim归为三种编辑模式：</p>
<ul>
<li><p>文本编辑模式<br>文本编辑模式是默认模式，vim编辑器会将按键解释成命令。在任意模式按esc进入此默认模式。</p>
</li>
<li><p>文本插入模式<br>文本插入模式， vim会将你在当前光标位置输入的每个键都插入到缓冲区，即文本输入字符。在普通模式下按下”i 键” 进入(含义:insert)</p>
</li>
<li><p>命令行模式<br>命令行模式和shell命令行类似，在普通模式下按下”: 键”进入(形似shell terminal的冒号)</p>
</li>
</ul>
<p>怎么知道当前处于哪种模式？<br>vim左下角是状态行，以下是三种模式的状态示例：</p>
<ul>
<li><code>vim init/main.c</code>默认进入文本编辑模式，下面显示文件名和行号<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171047554.png"></li>
</ul>
<p>输入i, 进入文本插入模式，下面显示insert状态<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171052433.png"></p>
<p>按esc退出文本编辑，再输入<code>:</code> 进入命令行模式，例如输入<code>:wq</code>保存文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171053124.png"></p>
<p>还有一种visual模式是复制粘贴时会用到：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181032041.png"></p>
<p>下面讲文本编辑模式和命令行模式的常用命令<br>主要分为几类场景：</p>
<ul>
<li>光标移动</li>
<li>增删改查</li>
<li>文件保存</li>
</ul>
<p>光标移动类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>移到第一行 (gg重来)</td>
</tr>
<tr>
<td>G</td>
<td>移到最后一行 (记为大G)</td>
</tr>
<tr>
<td>PageUp&#x2F;PageDown</td>
<td>翻页</td>
</tr>
<tr>
<td>:行号</td>
<td>光标移动到指定行(属于命令行模式)</td>
</tr>
</tbody></table>
<p>增删改查类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>进入insert模式，在当前光标的左侧输入</td>
</tr>
<tr>
<td>a</td>
<td>追加文本（append），在当前光标的右侧输入</td>
</tr>
<tr>
<td>o</td>
<td>插入空行，在空行光标处可输入</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行 (记为双击delete)</td>
</tr>
<tr>
<td>dw</td>
<td>删除当前词（记为delete word）</td>
</tr>
<tr>
<td>delete键，或x键</td>
<td>删除当前字符，注意，Backspace在vim没有删除的作用！</td>
</tr>
<tr>
<td>v+方向键选中+y</td>
<td>复制选中的文本，v: visual，可视光标选中的文本范围， y: yank 复制</td>
</tr>
<tr>
<td>yw</td>
<td>复制当前词</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p</td>
<td>在复制之后，粘贴文本(paste)，注意粘贴内容来自vim缓冲区，而不是外部剪切板的</td>
</tr>
<tr>
<td>dw&#x2F;dd + p</td>
<td>剪切，d操作删除的文本位于缓冲区，可以直接用p粘贴</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>(当前文件内)查找字符串，按n查找下一个</td>
</tr>
<tr>
<td>:s&#x2F;old&#x2F;new&#x2F;g</td>
<td>(当前文件内)全局查找和替换</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步</td>
</tr>
</tbody></table>
<p>文件保存类：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:q!</td>
<td>不保存文件退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存文件退出</td>
</tr>
</tbody></table>
<h2 id="2-多文件编辑"><a href="#2-多文件编辑" class="headerlink" title="2.多文件编辑"></a>2.多文件编辑</h2><p>下面讲多个文本的常用命令<br>主要分为几类场景：</p>
<ul>
<li>多文本搜索</li>
<li>多文件编辑</li>
</ul>
<p>多文本搜索类：<br>参考<a target="_blank" rel="noopener" href="https://thevaluable.dev/vim-search-find-replace/"># Vim Search and Replace With Examples</a><br>本文只以quickfix方式为例：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>:vimgrep pattern **</code></td>
<td>搜索当前目录和子目录的包含指定pattern的文件，vimgrep可缩写为vim, ** 表示递归子目录</td>
</tr>
<tr>
<td><code>:vimgrep pattern **/*.c</code></td>
<td>同上，只搜索.c文件</td>
</tr>
<tr>
<td>:copen</td>
<td>搜索完后使用此命令打开文件列表，才能用光标选择</td>
</tr>
<tr>
<td>:cn (cnext) 和 :cp (cprev)</td>
<td>上下选择搜索文件列表</td>
</tr>
</tbody></table>
<p>示例：搜索linux0.11下的所有包含main的.c文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205171959744.png"></p>
<p>quickfix list即文件列表，copen后可方向键选择打开文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205172002631.png"></p>
<ul>
<li>多文件编辑<br><strong>打开多个文件，分隔并列显示</strong></li>
</ul>
<ol>
<li>用vim打开文件后，命令行输入<code>:vs newfile</code>，竖排并列打开新文件（vs是vertical split缩写，竖排分隔）</li>
<li>特殊用法：<code>:vs ./</code>可以打开当前路径下的所有文件列表</li>
<li>在窗口间切换：<code>ctrl + ww</code></li>
<li>关闭文件只需要先切换到窗口再<code>:q!</code></li>
<li>调整竖排的窗口比例：<br> 先按ctrl+w选择窗口模式，再按&lt;&gt;+-调整。&lt; 左移，&gt; 右移，+ 上移， - 下移。</li>
</ol>
<p>示例：实现类似IDE的界面，左侧是文件列表，下侧是查找栏，右侧文件内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181006035.png"></p>
<p>  <strong>打开多个文件，不并列显示</strong><br>直接<code>:open file</code>打开新文件, 用 <code>:bn 和 :bN</code> (buffer next)切换文件, </p>
<p>  <strong>多文件之间复制粘贴</strong><br>vim的多个文件直接可以直接用 y + p 命令复制粘贴，因为共用vim环境的缓冲区</p>
<p>  退出所有文件<br><code>:qall!</code> 和 <code>:wqall</code></p>
<h2 id="3-类似IDE的跳转功能"><a href="#3-类似IDE的跳转功能" class="headerlink" title="3.类似IDE的跳转功能"></a>3.类似IDE的跳转功能</h2><p>推荐cscope插件，具体参考<a target="_blank" rel="noopener" href="http://cscope.sourceforge.net/cscope_vim_tutorial.html">## The Vim&#x2F;Cscope tutorial</a></p>
<p>关键步骤：</p>
<ul>
<li>建立cscope.vim<br>将  <a target="_blank" rel="noopener" href="http://cscope.sourceforge.net/cscope_maps.vim">http://cscope.sourceforge.net/cscope_maps.vim</a>  另存到文件<code>~/.vim/plugin/cscope_maps.vim</code></li>
<li>源码目录建立cscope.out<br><code>cscope -R</code> 建立符号索引，<code>ctrl+D</code> 退出</li>
<li>打开某符号的代码<br>例如 <code>vim -t main</code> 打开main所在文件</li>
<li>查找函数的定义和调用<br>如果光标已经在函数上，用 “<code>ctrl +＼</code>“ 再输入s，查找所有调用、定义该函数的列表，输入索引号回车<br>更推荐用cscope的命令行，<code>:cs f s 函数名</code> 是一样的结果，且光标不需要位于函数上。参数含义 f: find, s: symbol<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202205181103274.png"></li>
<li>跳转回之前的位置<br>“<code>ctrl + t</code></li>
</ul>
<h2 id="4-vim配置文件修改配色，行号"><a href="#4-vim配置文件修改配色，行号" class="headerlink" title="4.vim配置文件修改配色，行号"></a>4.vim配置文件修改配色，行号</h2><p>在有的Linux服务器上，Vim默认深蓝色亮瞎眼，修改配色为流行的Molokai.</p>
<p>效果对比:</p>
<p>默认配色看不清注释内容<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061435384.png" alt="image-20221206143528332"><br>Molokai配色<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061437401.png" alt="image-20221206143701354"></p>
<p>配置过程：</p>
<p>默认的配色方案：</p>
<pre><code>ls /usr/share/vim/vim74/colors
</code></pre>
<p>下载molokai配色文件,拷贝到vim配色文件目录</p>
<pre><code>cd ~
git clone git@github.com:tomasr/molokai.git
cd molokai/colors
cp molokai.vim /usr/share/vim/vim74/colors
</code></pre>
<p>在home下创建.vimrc用于配色详细设置</p>
<pre><code>cd ~
vim .vimrc
</code></pre>
<p>.vimrc设置如下：</p>
<pre><code>  set t_Co=256
  set background=dark
  set ts=4
  set nu!
  syntax on
  colorscheme molokai
</code></pre>
<p><code>:wq</code>保存后即生效<br>如果要全局用户通用，<code>vim /etc/vimrc</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/03/18/MFC%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/MFC%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">MFC笔记：多线程磁盘读写测试工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 15:05:47" itemprop="dateCreated datePublished" datetime="2021-03-18T15:05:47+08:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 16:03:27" itemprop="dateModified" datetime="2022-12-05T16:03:27+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows/" itemprop="url" rel="index"><span itemprop="name">windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MFC（Microsoft Foundation Classes）是微软在win32 API上，用C++封装的GUI框架，在现在，MFC相比其他的GUI框架有些过时，可以参考：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/327876401">很多人说 C++ 的 MFC 已经过时了，那新入门的人到底应该学什么？</a><br>不同环境的选择：</p>
<ul>
<li>跨平台： QT</li>
<li>C#: WPF</li>
<li>Web：React，Vue，Electron</li>
</ul>
<p>既然如此，为何本文用MFC？<br>1.部分功能从老MFC项目移植，且VS环境能快速上手<br>2.技术本身不会过时，过时的是应用场景，GUI回调式的交互机制，以及Win32线程和进程的使用都是通用的技术。这是写本文的原因</p>
<p>本文源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/myMFCForAutoRWTest.git">cursorhu&#x2F;myMFCForAutoRWTest</a></p>
<p>GUI界面：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051510224.png" alt="1"></p>
<h1 id="初识MFC项目"><a href="#初识MFC项目" class="headerlink" title="初识MFC项目"></a>初识MFC项目</h1><p>VS新建MFC项目，例如“myMFC”，目录结构如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514738.png" alt="2"><br>myMFC.cpp是VS自动创建的MFC项目入口，其主要功能是：创建一个窗口实例，注册会话对象（Dialog)<br>界面的交互一定是分层的</p>
<ul>
<li>对用户的是控件层，即各种按钮，输入输出框等可见可操作的东西</li>
<li>处理数据的是逻辑层，例如从输入框输入，底层保存该字符串，点击运行，底层开始执行对应函数</li>
</ul>
<p>在MFC中，会话对象就是处理底层逻辑的类对象，其方法定义在myMFCDlg.cpp<br>也是开发的主要内容</p>
<h2 id="MFC入口"><a href="#MFC入口" class="headerlink" title="MFC入口"></a>MFC入口</h2><p>下面介绍myMFC.cpp的MFC入口：</p>
<pre><code>BOOL CmyMFCApp::InitInstance()
&#123;
    // 如果一个运行在 Windows XP 上的应用程序清单指定要
    // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
    //则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
    INITCOMMONCONTROLSEX InitCtrls;
    InitCtrls.dwSize = sizeof(InitCtrls);
    // 将它设置为包括所有要在应用程序中使用的
    // 公共控件类。
    InitCtrls.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&amp;InitCtrls);

    CWinApp::InitInstance();
    
    AfxEnableControlContainer();

    // 创建 shell 管理器，以防对话框包含
    // 任何 shell 树视图控件或 shell 列表视图控件。
    CShellManager *pShellManager = new CShellManager;

    // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
    CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

    // 标准初始化
    // 如果未使用这些功能并希望减小
    // 最终可执行文件的大小，则应移除下列
    // 不需要的特定初始化例程
    // 更改用于存储设置的注册表项
    // TODO: 应适当修改该字符串，
    // 例如修改为公司或组织名
    SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;));

    CmyMFCDlg dlg;
    m_pMainWnd = &amp;dlg;
    INT_PTR nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    &#123;
        // TODO: 在此放置处理何时用
        //  “确定”来关闭对话框的代码
    &#125;
    else if (nResponse == IDCANCEL)
    &#123;
        // TODO: 在此放置处理何时用
        //  “取消”来关闭对话框的代码
    &#125;
    else if (nResponse == -1)
    &#123;
        TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;);
        TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;);
    &#125;

    // 删除上面创建的 shell 管理器。
    if (pShellManager != nullptr)
    &#123;
        delete pShellManager;
    &#125;

#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)
    ControlBarCleanUp();
#endif

    return FALSE;
&#125;
</code></pre>
<p>只需要关注这几句</p>
<pre><code>CmyMFCDlg dlg;
m_pMainWnd = &amp;dlg;
INT_PTR nResponse = dlg.DoModal();
</code></pre>
<p>CmyMFCDlg类是在myMFCDlg.cpp定义的，即底层逻辑类。m_pMainWnd是myMFC.cpp的CmyMFCApp类(继承win32 API)的成员，表示主窗口，这两句就是把会话对象注册到窗口类，这样窗口运行时可以回调会话对象的方法。dlg.DoModal()是运行会话窗口，运行哪个会话？其调用者CmyMFCDlg类对象dlg。</p>
<h2 id="MFC逻辑层"><a href="#MFC逻辑层" class="headerlink" title="MFC逻辑层"></a>MFC逻辑层</h2><p>VS自动创建myMFC项目的会话逻辑层，myMFCDlg.cpp<br>几个自动生成的方法如下，这里为了作为示例，加了自定义的类成员m_src, m_dst和方法OnBnClickedButtonsrc，OnBnClickedButtondst<br>(1)会话类构造函数</p>
<pre><code>CmyMFCDlg::CmyMFCDlg(CWnd* pParent /*=nullptr*/)
    : CDialogEx(IDD_MYMFC_DIALOG, pParent)
    , m_src(_T(&quot;&quot;)) //初始化为空串，_T是兼容不同编码的转换
    , m_dst(_T(&quot;&quot;))
&#123;
    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
&#125;
</code></pre>
<p>(2)界面和类成员数据关联</p>
<pre><code>void CmyMFCDlg::DoDataExchange(CDataExchange* pDX)
&#123;
    CDialogEx::DoDataExchange(pDX);
    DDX_Text(pDX, IDC_EDIT_src, m_src); //关联m_src和IDC_EDIT_src控件，该控件是界面输入框
    DDX_Text(pDX, IDC_EDIT_dst, m_dst);
&#125;
</code></pre>
<p>(3)界面和类方法的关联</p>
<pre><code>BEGIN_MESSAGE_MAP(CmyMFCDlg, CDialogEx)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_BUTTON_src, &amp;CmyMFCDlg::OnBnClickedButtonsrc) //关联IDC_BUTTON_src按钮和OnBnClickedButtonsrc方法
    ON_BN_CLICKED(IDC_BUTTON_dst, &amp;CmyMFCDlg::OnBnClickedButtondst)
END_MESSAGE_MAP()
</code></pre>
<p>类在头文件的定义：</p>
<pre><code>class CmyMFCDlg : public CDialogEx
&#123;
// 构造
public:
    CmyMFCDlg(CWnd* pParent = nullptr);    // 标准构造函数

// 对话框数据
#ifdef AFX_DESIGN_TIME
    enum &#123; IDD = IDD_MYMFC_DIALOG &#125;;
#endif

    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
    HICON m_hIcon;

    // 生成的消息映射函数
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    DECLARE_MESSAGE_MAP()
    
public:
    CString m_src; //CString: MFC的字符串类型
    CString m_dst;
    afx_msg void OnBnClickedButtonsrc(); //afx_msg: MFC的方法对应的消息响应类型
    afx_msg void OnBnClickedButtondst();
&#125;;
</code></pre>
<p>在VS环境下,这些变量和方法的定义都不需要写代码，在控件资源视图直接配置即可。</p>
<h2 id="界面资源层"><a href="#界面资源层" class="headerlink" title="界面资源层"></a>界面资源层</h2><p>注意项目文件有个Resource.h，包含界面相关的资源，如每个按钮有个ID，这个不要手动配置，在编辑UI控件时自动生成</p>
<pre><code>//&#123;&#123;NO_DEPENDENCIES&#125;&#125;
// Microsoft Visual C++ 生成的包含文件。
// 供 myMFC.rc 使用
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MYMFC_DIALOG                102
#define IDR_MAINFRAME                   128
#define IDC_BUTTON_src                  1000
#define IDC_BUTTON_dst                  1001
</code></pre>
<p>myMFC.rc是UI的资源文件，打开就是UI界面<br><img src="C:\Users\thomas.hu\Desktop\3.png" alt="3"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514703.png" alt="4"><br>可以看到界面的按钮，右键查看属性，可以修改标题和控件ID，会映射到Resource.h。双击按钮，myMFCDlg.cpp会自动创建方法<code>CmyMFCDlg::OnBnClickedButtondst()</code>，头文件自动加方法声明。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051514147.png" alt="5"></p>
<p>前文的Dlg.cpp中的控件ID, dlg类的方法，变量，从一开始就可以从资源界面配置，自动生成：</p>
<ul>
<li>在资源界面选按钮或其他控件</li>
<li>右键配置控件ID</li>
<li>右键添加值变量或控件变量</li>
<li>双击添加方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515208.png" alt="6"><br>关于值变量和控件变量：<br>值变量用于关联界面和类成员，值变量就是类成员名，例如点击dst按钮调用其方法后，获得的路径，会写入m_dst值变量<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051512803.png" alt="7"><br>控件变量代表控件本身，用于底层逻辑中，直接调用控件的方法，例如控件变量叫dst_ctrl，可以在某个方法中<code>ctrl_dst.SetWindowText(_T(&quot;&quot;))</code>清空界面的字符串<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051512701.png" alt="8"></p>
<h1 id="简单拷贝校验的实现"><a href="#简单拷贝校验的实现" class="headerlink" title="简单拷贝校验的实现"></a>简单拷贝校验的实现</h1><p>实现从src目录拷贝所有文件到dst目录，并比较拷贝前后的文件是否一致</p>
<h2 id="获取文件路径"><a href="#获取文件路径" class="headerlink" title="获取文件路径"></a>获取文件路径</h2><p>两个路径选择按钮和对应的编辑框显示路径，一个Start按钮<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051513686.png" alt="9"></p>
<p>button src的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonsrc()
&#123;
    CString SrcPath;
    SrcPath = GetFolderPath(); //获取文件夹路径
    ctrl_src.SetWindowText(SrcPath); //显示获取的路径字符串
    m_src = SrcPath; //保存路径到会话对象的变量
&#125;
</code></pre>
<p>GetFolderPath打开一个目录框，让用户选择：<br>SHBrowseForFolder是win32 API，专用于打开目录</p>
<pre><code>CString CmyMFCDlg::GetFolderPath(void)
&#123;
    CString strPath;
    BROWSEINFO bInfo;
    ZeroMemory(&amp;bInfo, sizeof(bInfo));
    bInfo.hwndOwner = m_hWnd;
    bInfo.lpszTitle = _T(&quot;Select Folder: &quot;);
    bInfo.ulFlags = BIF_RETURNONLYFSDIRS;

    LPITEMIDLIST lpDlist;                    
    lpDlist = SHBrowseForFolder(&amp;bInfo); //win32 API, 打开目录    
    if (lpDlist != NULL)                        
    &#123;
        TCHAR chPath[255];                    
        SHGetPathFromIDList(lpDlist, chPath);
        strPath = chPath;                    
    &#125;
    return strPath;
&#125;
</code></pre>
<p>如果是打开文件，用CFileDialog</p>
<pre><code>CString CmyMFCDlg::GetFilePath(void)
&#123;
    CFileDialog mFileDlg(TRUE, NULL, NULL,
        OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT | OFN_NOCHANGEDIR,
        _T(&quot;All Files(*.*)|*.*||&quot;), AfxGetMainWnd());
    CString str(&quot; &quot;, 10000);
    mFileDlg.m_ofn.lpstrFile = str.GetBuffer(10000);
    mFileDlg.m_ofn.lpstrTitle = _T(&quot;Select File&quot;);
    str.ReleaseBuffer();
    mFileDlg.DoModal();
    POSITION mPos = mFileDlg.GetStartPosition();
    CFileStatus status;
    CString strPath;
    while (mPos != NULL)
    &#123;
        strPath = mFileDlg.GetNextPathName(mPos);
        CFile::GetStatus(strPath, status);
    &#125;
    return strPath;
&#125;
</code></pre>
<p>不管哪一种，效果如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515196.png" alt="10"><br>选择完后，路径会在编辑框显示，这就是控件语句<code>ctrl_src.SetWindowText(SrcPath)</code>的效果<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051515342.png" alt="11"></p>
<h2 id="拷贝和比较"><a href="#拷贝和比较" class="headerlink" title="拷贝和比较"></a>拷贝和比较</h2><p>拷贝函数如下，只需关注几个函数：</p>
<ul>
<li>CFileFind类的CFileFind(), FindNextFile(), GetFilePath(), GetFilePath()，这些都是afx.h定义，属于MFC库的类</li>
<li>CopyFile()， 执行拷贝，这个也是继承自MFC类</li>
</ul>
<p>代码：</p>
<pre><code>BOOL CmyMFCDlg::ModeTestCopyFileFromSRCtoDST(CString SRC, CString DST, CString&amp; StrResult)
&#123;

    CFileFind ff, ff_DST;
    CString SRCDir = SRC;                 //source folder path
    CString DSTDir = DST;
    UINT copyFileResult = 0;
    int i = 0;

    BOOL bmakedir = MakeDirectory(DSTDir);

    if (SRCDir.Right(1) != _T(&quot;\\&quot;))
        SRCDir += _T(&quot;\\&quot;);
    SRCDir += _T(&quot;*.*&quot;);

    if (DSTDir.Right(1) != _T(&quot;\\&quot;))
        DSTDir += _T(&quot;\\&quot;);
</code></pre>
<p>​<br>​        SetLastError(0);<br>​        CString DST_tmp &#x3D; DSTDir + _T(“<em>.</em>“);<br>​        BOOL res_DST &#x3D; ff_DST.FindFile(DST_tmp);<br>​        if (res_DST &#x3D;&#x3D; 0)<br>​        {<br>​            StrResult.Format(_T(“Access DST folder error, error code is %d. “), GetLastError());<br>​        }<br>​        BOOL res &#x3D; ff.FindFile(SRCDir);<br>​<br>        while (res)<br>        {<br>            res &#x3D; ff.FindNextFile();<br>            if (!ff.IsDirectory() &amp;&amp; !ff.IsDots())<br>            {<br>                CString DSTFildPath;<br>                CString SRCFilePath &#x3D; ff.GetFilePath();<br>                DSTFildPath &#x3D; DSTDir + ff.GetFileName();<br>                copyFileResult &#x3D; CopyFile(ff.GetFilePath(), DSTFildPath, FALSE);</p>
<pre><code>            Sleep(2000);

            if (copyFileResult == 0)
            &#123;
                DWORD ErrCode = GetLastError();
                StrResult.Format(_T(&quot;CopyFile failed! The ErrCode is %d. &quot;), ErrCode);

                for (i = 0; i &lt; 10; i++)
                &#123;
                    copyFileResult = CopyFile(ff.GetFilePath(), DSTFildPath, FALSE);
                    Sleep(2000);
                    if (copyFileResult == 0)
                    &#123;
                        ErrCode = GetLastError();
                        StrResult.Format(_T(&quot;Retry CopyFile failed! The ErrCode is %d. &quot;), ErrCode);
                    &#125;
                    else
                    &#123;
                        break;
                    &#125;
                &#125;

                if (copyFileResult == 0)
                &#123;
                    ff.Close();
                    return FALSE;
                &#125;
            &#125;
        &#125;
        else if (ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFildPath;
            DSTFildPath = DSTDir + ff.GetFileName();
            copyFileResult = ModeTestCopyFileFromSRCtoDST(ff.GetFilePath(), DSTFildPath, StrResult);
            if (copyFileResult == 0)
                break;
        &#125;
    &#125;

    ff.Close();
    if (copyFileResult == 0)
        return FALSE;
    else
        return TRUE;
&#125;
</code></pre>
<p>比较两个路径的文件：<br>其方法是，文件读到buffer, 再用memcmp比较buffer, 其FindNextFile也是如何从目录搜索到文件的关键方法</p>
<pre><code>BOOL CmyMFCDlg::ModeTestCompareFilesBetweenSRCandDST(CString SRC, CString DST, CString&amp; StrResult)
&#123;
    CFileFind ff;
    CString SRCDir = SRC;
    CString DSTDir = DST;
    BOOL bRes = TRUE;
    HANDLE hSrcFile, hDstFile;
    DWORD dwSRCFile, dwDSTFile, dwCB;

    if (SRCDir.Right(1) != _T(&quot;\\&quot;))
        SRCDir += _T(&quot;\\&quot;);
    SRCDir += _T(&quot;*.*&quot;);

    if (DSTDir.Right(1) != _T(&quot;\\&quot;))
        DSTDir += _T(&quot;\\&quot;);
    hSrcFile = hDstFile = NULL;
    BYTE* pSrcBuffer = new BYTE[M_BUFSIZE];
    BYTE* pDstBuffer = new BYTE[M_BUFSIZE];
    memset(pSrcBuffer, 0, M_BUFSIZE);
    memset(pSrcBuffer, 0, M_BUFSIZE);

    BOOL res = ff.FindFile(SRCDir);

    while (res)
    &#123;
        res = ff.FindNextFile();
        if (!ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFilePath;
            DSTFilePath = DSTDir + ff.GetFileName();
            CString SRCFilePath = ff.GetFilePath();

            if (hSrcFile)
            &#123;
                CloseHandle(hSrcFile);
                hSrcFile = NULL;
            &#125;

            if (hDstFile)
            &#123;
                CloseHandle(hDstFile);
                hSrcFile = NULL;
            &#125;

            hSrcFile = CreateFile(SRCFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
            if (hSrcFile == INVALID_HANDLE_VALUE)
            &#123;
                StrResult.Format(_T(&quot;\n Create Source file failed!! Error code = %d \n&quot;), GetLastError());
                bRes = FALSE;
                break;
            &#125;

            hDstFile = CreateFile(DSTFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
            if (hDstFile == INVALID_HANDLE_VALUE)
            &#123;
                StrResult.Format(_T(&quot;\n Create Destination file failed!! Error code = %d \n&quot;), GetLastError());
                bRes = FALSE;
                break;
            &#125;

            LARGE_INTEGER SrcFileSize, DstFileSize;

            dwSRCFile = GetFileSizeEx(hSrcFile, &amp;SrcFileSize);
            dwDSTFile = GetFileSizeEx(hDstFile, &amp;DstFileSize);

            if (SrcFileSize.LowPart != DstFileSize.LowPart)
            &#123;
                StrResult.Format(_T(&quot;\n Compare file is different!! Src Length = %d, Dest Length = %d \n&quot;), SrcFileSize.LowPart, DstFileSize.LowPart);
                bRes = FALSE;
                break;
            &#125;

            while (SrcFileSize.LowPart &gt; 0)
            &#123;
                BOOL bCmpResult;
                bCmpResult = ReadFile(hSrcFile, pSrcBuffer, M_BUFSIZE, &amp;dwCB, NULL);
                if (bCmpResult == 0)
                &#123;
                    bRes = FALSE;
                    break;
                &#125;
                bCmpResult = ReadFile(hDstFile, pDstBuffer, M_BUFSIZE, &amp;dwCB, NULL);
                if (bCmpResult == 0)
                &#123;
                    bRes = FALSE;
                    break;
                &#125;
                bCmpResult = memcmp(pSrcBuffer, pDstBuffer, dwCB);

                if (bCmpResult != 0)
                &#123;
                    bRes = FALSE;
                    CString DiffByte;

                    CString PostCmpErrorStr;
                    CString SrcDumpData, DstDumpData;
                    StrResult.Format(_T(&quot;\n Fatal_Error: Src Data from %d to %d.\n&quot;), (DstFileSize.LowPart - SrcFileSize.LowPart), (DstFileSize.LowPart - SrcFileSize.LowPart + dwCB));

                    PostCmpErrorStr = _T(&quot;SourceFilePath: &quot;) + SRCFilePath + _T(&quot; To \r\n&quot;) + _T(&quot;DstFilePath: &quot;) + DSTFilePath;
                    StrResult = PostCmpErrorStr + _T(&quot;  has compare error! \r\n&quot;);
                    //HugoPostMessageAndShowSD1(PostCmpErrorStr,1);
                    //HugoPostMessageAndShowSD2(PostCmpErrorStr,1);

                    ::MessageBox(
                        NULL,
                        (LPCWSTR)L&quot;Compare error happened!!&quot;,
                        (LPCWSTR)L&quot;Fatal Error!&quot;,
                        MB_OK
                    );

                    break;
                &#125;
                SrcFileSize.LowPart -= dwCB;
            &#125;

            if (bRes == FALSE)
                break;
            else
                ReadFile(hDstFile, pDstBuffer, 512, &amp;dwCB, NULL);
        &#125;
        else if (ff.IsDirectory() &amp;&amp; !ff.IsDots())
        &#123;
            CString DSTFildPath;
            DSTFildPath = DSTDir + ff.GetFileName();
            bRes = ModeTestCompareFilesBetweenSRCandDST(ff.GetFilePath(), DSTFildPath, StrResult);
            if (bRes == FALSE)
                break;
        &#125;
    &#125;

    if (hSrcFile)
    &#123;
        CloseHandle(hSrcFile);
        hSrcFile = NULL;
    &#125;

    if (hDstFile)
    &#123;
        CloseHandle(hDstFile);
        hSrcFile = NULL;
    &#125;

    if (bRes == FALSE)
    &#123;
        delete[]pSrcBuffer;
        delete[]pDstBuffer;
        ff.Close();
        return FALSE;
    &#125;
    else
    &#123;
        delete[]pSrcBuffer;
        delete[]pDstBuffer;
        ff.Close();
        return TRUE;
    &#125;
&#125;
</code></pre>
<p>关于CString的格式化输出：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangkaishou/article/details/5846152">MFC中CString.Format的详细用法</a><br>关于CFile文件操作：<a target="_blank" rel="noopener" href="https://blog.csdn.net/perfectguyipeng/article/details/60148222">MFC——文件操作（CFile）</a></p>
<h2 id="开始按钮"><a href="#开始按钮" class="headerlink" title="开始按钮"></a>开始按钮</h2><p>一般操作顺序：选择src和dst，再点击Start按钮<br>start按钮的方法调用已保存的m_src和m_dst路径，传入拷贝和比较，再输出结果即可，大致流程如下</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonrun()
&#123;
    //读入所有界面数据
    UpdateData(true);
    
    BOOL ret;
    CString outStr;
    
    ret = ModeTestCopyFileFromSRCtoDST(m_src, m_dst, outStr);
    if (!ret)
            MessageBox(NULL, _T(outStr), _T(&quot;ERROR&quot;), MB_OK);
    
    ret = ModeTestCompareFilesBetweenSRCandDST(m_src, m_dst, outStr);
    if (!ret)
            MessageBox(NULL, _T(outStr), _T(&quot;ERROR&quot;), MB_OK);
&#125;
</code></pre>
<p>这里用messagebox输出结果，即弹窗，弹窗是阻塞式的。也可以用编辑框，写文件输出。<br>关于messagebox，参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox">MessageBox function (winuser.h)</a><br>关于updateData：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lidabo/archive/2012/07/17/2595464.html">MFC中UpdateData()函数的使用</a><br>以上完成一个简单的文件拷贝和比较功能</p>
<h1 id="多线程文件拷贝和写日志"><a href="#多线程文件拷贝和写日志" class="headerlink" title="多线程文件拷贝和写日志"></a>多线程文件拷贝和写日志</h1><p>将简单拷贝扩展，支持：</p>
<ul>
<li>多线程拷贝和比较，每个线程完成简单拷贝比较的功能</li>
<li>在每个工作线程，输出打印到界面文本框，同时写到同一个日志文件</li>
<li>界面主线程需要等待所有工作线程完成后，输出测试完成信息到文本框和日志</li>
</ul>
<h2 id="线程列表获取各自路径"><a href="#线程列表获取各自路径" class="headerlink" title="线程列表获取各自路径"></a>线程列表获取各自路径</h2><p>add和delete配置几个工作线程，每个线程配置其src和dst路径</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516636.png" alt="12"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516611.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516530.png" alt="14"></p>
<p>这种动态增删的列表，在资源界面新建listbox类型变量和方法：</p>
<pre><code>CListBox m_rwlist;
afx_msg void OnLbnSelchangeListrwlist();
</code></pre>
<p>Add和Delete对应的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonadd()
void CmyMFCDlg::OnBnClickedButtondelete()
</code></pre>
<p>Add和Delete的方法控制listbox变量m_rwlist，选中任意m_rwlist后又会调用其方法OnLbnSelchangeListrwlist，获取每个线程各自的src、dst。</p>
<p>按键控制m_rwlist的实现：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonadd()
&#123;
    CString Threadtest = _T(&quot;TestThread&quot;);
    UINT ThreadCount = m_rwlist.GetCount();
    if (ThreadCount == 0)
    &#123;
        m_rwlist.AddString(_T(&quot;TestThread1&quot;));
    &#125;
    else if (ThreadCount &lt; MAX_THREAD_COUNT)
    &#123;
        CString ThreadNum;
        ThreadNum.Format(_T(&quot;%d&quot;), ThreadCount + 1);
        Threadtest = Threadtest + ThreadNum;
        m_rwlist.AddString(Threadtest);
    &#125;
    else if (ThreadCount == MAX_THREAD_COUNT)
    &#123;
        CString str;
        str.Format(_T(&quot;Only support %d threads at most!!&quot;), MAX_THREAD_COUNT);
        MessageBox(str);
    &#125;
    m_rwlist.SetCurSel(ThreadCount);
    if (ThreadCount &lt; MAX_THREAD_COUNT)
        totalThreadCount++;
&#125;

void CmyMFCDlg::OnBnClickedButtondelete()
&#123;
    UINT ThreadCount = m_rwlist.GetCount();
    if (ThreadCount != 0)
    &#123;
        m_rwlist.DeleteString(ThreadCount - 1);
        m_rwlist.SetCurSel(0);
    &#125;
    if (ThreadCount &gt; 0)
        totalThreadCount--;
&#125;
</code></pre>
<p>线程列表m_rwlist的方法读取路径到会话对象成员变量：</p>
<pre><code>void CmyMFCDlg::OnLbnSelchangeListrwlist()
&#123;
    UpdateData(true); //update true: 从界面读入值到变量（使上次编辑生效）
    if (m_rwlist.GetCount() != 0)
    &#123;
        UINT selectNum = m_rwlist.GetCurSel();
        RWTestParamArray[selectNum].ThreadNum = m_rwlist.GetCount();
        RefreshRWParam(RWTestParamArray, selectNum);
    &#125;
&#125;

void CmyMFCDlg::RefreshRWParam(TabDialogRWTestParam(&amp;Array)[MAX_THREAD_COUNT], UINT CSel)
&#123;
    ctrl_src.SetWindowText(Array[CSel].SRCFolder_Path);
    ctrl_dst.SetWindowText(Array[CSel].DSTFolder_Path);

    UpdateData(false); //update false: 把变量写入到界面（实时显示）
&#125;
</code></pre>
<p>真正读入路径的是dst、src按钮的方法：</p>
<pre><code>void CmyMFCDlg::OnBnClickedButtonsrc()
&#123;
    CString SrcPath;
    UINT ThreadCSelNum = m_rwlist.GetCurSel();
    SrcPath = GetFolderPath();
    ctrl_src.SetWindowText(SrcPath);
    RWTestParamArray[ThreadCSelNum].SRCFolder_Path = SrcPath;
&#125;

void CmyMFCDlg::OnBnClickedButtondst()
&#123;
    CString DstPath;
    UINT ThreadCSelNum = m_rwlist.GetCurSel();
    DstPath = GetFolderPath();
    ctrl_dst.SetWindowText(DstPath);
    RWTestParamArray[ThreadCSelNum].DSTFolder_Path = DstPath;
&#125;
</code></pre>
<p>线程数组定义在会话类，存储每个工作线程要用的数据</p>
<pre><code>TabDialogRWTestParam RWTestParamArray[MAX_THREAD_COUNT];
typedef struct TabRWParam
&#123;
    CString SRCFolder_Path;
    CString DSTFolder_Path;
    UINT ThreadNum;
    UINT TestTimes;
&#125;TabDialogRWTestParam;
</code></pre>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>创建线程参考MS文档：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-160">beginthread、_beginthreadex</a><br>关注2点：</p>
<ul>
<li>传入线程内要执行的函数，和参数(可为NULL)</li>
<li>返回线程句柄，如果是多个线程则是个数组</li>
</ul>
<p>创建线程的部分代码：</p>
<pre><code>void CmyMFCDlg::RunModeTestInstance()
&#123;
    ....
    
    //线程内除了对象，还需要知道自己是哪个线程，因此打包this和ThreadCount
    pTransParam ThreadTransPArray[MAX_THREAD_COUNT];

    for (int i = 0; i &lt; totalThreadCount; i++)
    &#123;
        ThreadTransPArray[i] = new(TransParam);
        ThreadTransPArray[i]-&gt;i = i;
        ThreadTransPArray[i]-&gt;translpParam = this;

        unsigned int rwThreadID;

        //hThread defined as global data
        hThread[i] = (HANDLE)_beginthreadex(
            NULL,
            0,
            DoThreadProc,
            ThreadTransPArray[i],
            0,
            &amp;rwThreadID);

        if (hThread[i] == NULL)
            MessageBox(_T(&quot;CreateThread Fail!!&quot;), MB_OK);
        
        ....
        
        //release resource
        for (int i = 0; i &lt; totalThreadCount; i++)
        &#123;
            delete ThreadTransPArray[i];
            ThreadTransPArray[i] = NULL;
            CloseHandle(hThread[i]);
        &#125;
    &#125;
</code></pre>
<p>由于要在线程内打印当前是哪个线程，这个从Dlg对象的this指针是获取不到的，因此把this指针和线程id打包结构体，传入DoThreadProc线程函数，结构体如下</p>
<pre><code>typedef struct transParam
&#123;
    LPVOID translpParam;
    int i;
&#125;TransParam, *pTransParam;

#define MAX_THREAD_COUNT 6
</code></pre>
<p>注意使用完后释放线程句柄和其他相关资源</p>
<h2 id="主线程和工作线程的通信：Message机制"><a href="#主线程和工作线程的通信：Message机制" class="headerlink" title="主线程和工作线程的通信：Message机制"></a>主线程和工作线程的通信：Message机制</h2><p>先明白几点：</p>
<ul>
<li>所有工作线程都共享主线程（界面线程）的数据，即会话类对象的成员</li>
<li>界面控件的操作函数，都是主线程独有的，工作线程不能调用</li>
<li>主线程如果要等待工作线程，一般会阻塞</li>
</ul>
<p>问题：<br>如何将工作线程的打印输出到主线程界面控件？</p>
<p>Windows消息机制可以解决工作线程和主线程通信问题，简单的讲，主线程有消息队列，工作线程可以发送消息到消息队列中，主线程用FIFO原则处理队列中的消息，在阻塞等待动作线程时，也支持消息队列的处理。<br>关于消息队列：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5fd5bdaac69c">windows消息机制（MFC）</a></p>
<p>（1）工作线程函数</p>
<pre><code>unsigned int WINAPI DoThreadProc(void *threadTransParam)
&#123;
    pTransParam pTrans = (pTransParam)threadTransParam;
    CString strResult;
    BOOL res = 0;

    CmyMFCDlg* pDlg = (CmyMFCDlg *)pTrans-&gt;translpParam;
    int thread_id = pTrans-&gt;i;

    for (int i = 0; i &lt; (int)pDlg-&gt;rwtime; i++)
    &#123;
        
        res = pDlg-&gt;ModeTestCopyFileFromSRCtoDST(pDlg-&gt;RWTestParamArray[thread_id].SRCFolder_Path, pDlg-&gt;RWTestParamArray[thread_id].DSTFolder_Path, strResult);

        res = pDlg-&gt;ModeTestCompareFilesBetweenSRCandDST(pDlg-&gt;RWTestParamArray[thread_id].SRCFolder_Path, pDlg-&gt;RWTestParamArray[thread_id].DSTFolder_Path, strResult);
        if (res)
        &#123;
            criticalSec.Lock();
            ::PostMessage(pDlg-&gt;GetSafeHwnd(), WM_USER_MSG, WPARAM(thread_id + 1), LPARAM(i + 1));
            criticalSec.Unlock();
        &#125;
    &#125;

    return res;
&#125;
</code></pre>
<p>几点说明：</p>
<ul>
<li>线程函数要用WINAPI实现，不属于会话类内的方法，因此需要this指针显式调用</li>
<li>rwtime是测试次数，每个线程执行多次拷贝比较</li>
<li>PostMessage是发布消息到主线程消息队列，可以传参：WPARAM和LPARAM</li>
<li>由于不确定PostMessage是不是线程安全，这里加了锁：CCriticalSection类型的criticalSec</li>
</ul>
<p>(2)消息处理函数<br>来看message处理函数：</p>
<pre><code>LRESULT CmyMFCDlg::OnMsg(WPARAM wp, LPARAM lp)
&#123;
    strAppend.Format(_T(&quot;Thread %d src:%s ---&gt; des:%s, Copy&amp;Compare Pass: test loop: %d \n&quot;), wp, RWTestParamArray[wp-1].SRCFolder_Path, RWTestParamArray[wp-1].DSTFolder_Path, lp);
    ShowLogInEditBox(); //字符串显示到界面
    return 0;
&#125;
</code></pre>
<p>主界面字符串显示函数</p>
<pre><code>/* call by message handler, for multiple child thread*/
void CmyMFCDlg::ShowLogInEditBox()
&#123;
    CString str;
    UINT i;

    /*message 队列只在主线程内处理，无需加锁*/
    //criticalSec.Lock();
        WriteLogFile(this-&gt;strAppend); //only write append str
    //criticalSec.Unlock();

    this-&gt;GetDlgItemText(IDC_EDIT_logbox, str);
    str += this-&gt;strAppend; //update old+append str
    str += &quot;\r\n&quot;; //这里换行没用，要在控件设置中允许换行

    this-&gt;SetDlgItemText(IDC_EDIT_logbox, str);

    i = ((CEdit*)GetDlgItem(IDC_EDIT_logbox))-&gt;GetLineCount();
    ((CEdit*)GetDlgItem(IDC_EDIT_logbox))-&gt;LineScroll(++i, 0); //定位到下一行

&#125;
</code></pre>
<p>写日志的相关方法如下：</p>
<pre><code>BOOL CmyMFCDlg::CreateLogFile()
&#123;
    CString strName;
    SYSTEMTIME st;

    GetLocalTime(&amp;st);
    strName.Format(_T(&quot;UtilityLogFile_%4d-%d-%d_%d-%d-%d.log&quot;), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);

    if (!m_File.Open(strName, (CFile::modeCreate | CFile::modeReadWrite), 0))
    &#123;
        ::AfxMessageBox(_T(&quot;Create Utility Log File Error!!&quot;));
        return FALSE;
    &#125;

    m_logCreated = 1;
    return TRUE;
&#125;

void CmyMFCDlg::WriteLogFile(CString str)
&#123;
    BOOL CreateRes = TRUE;

    if (m_logCreated == 0)
        CreateRes = CreateLogFile();

    if (CreateRes)
    &#123;
        str += _T(&quot;\r\n&quot;);
        int length = str.GetLength();
        length *= 2;
        m_File.Write(str, length);
        m_File.Flush();
    &#125;
&#125;

void CmyMFCDlg::CloseLogFile()
&#123;
    if (m_logCreated == 1)
    &#123;
        m_File.Close();
        m_logCreated = 0;
    &#125;
&#125;
</code></pre>
<p>注意message处理函数的关键点：</p>
<ul>
<li>只在主线程中处理，不存在其他线程操作，无临界区问题。因此上述的窗口输出，日志文件写入都是线程安全的。</li>
</ul>
<p>编辑框作为输出要注意几点：</p>
<ul>
<li>换行要在设置里配置，字符串换行没用</li>
<li>设置输出滚动显示</li>
</ul>
<p>效果如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051516097.png" alt="15"></p>
<p>（3）线程同步<br>日志完成的输出是主线程等待所有工作线程函数返回后才执行，如何实现？<br>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shangdawei/p/4015772.html">WaitForMultipleObject与MsgWaitForMultipleObjects用法</a><br>我们的需求是主线程在阻塞等待时要处理消息，因此用MsgWaitForMultipleObjects方法。<br>代码如下：</p>
<pre><code>//wait all child threads return

    /*
    //主线程阻塞，不能处理消息
    DWORD dwWaitResult = WaitForMultipleObjects(
        totalThreadCount,
        hThread,
        TRUE,
        INFINITE);
    */
    //主线程阻塞，但不阻塞消息
    int nWaitCount = totalThreadCount;
    int nExitThreadCount = 0;      //标记已经有几个线程退出了
    BOOL bWaitAll = FALSE;        //不等待所有线程完成，实时处理。如果TRUE, 会阻塞到所有线程完成
    DWORD result;
    MSG msg;

    while (TRUE)
    &#123;
        /*该函数等待：多个线程的完成信号，或其他消息信号,有任意一种就返回
        *返回值为[WAIT_OBJECT_0, WAIT_OBJECT_0 + nWaitCount - 1]表示对应下标的线程已完成
        *返回值为WAIT_OBJECT_0 + nWaitCount表示有其他信号，如线程内发送的message
        *WAIT_OBJECT_0值为0
        */
        result = MsgWaitForMultipleObjects(nWaitCount, hThread, bWaitAll, INFINITE, QS_ALLINPUT);

        if (result == WAIT_OBJECT_0 + nWaitCount) //表示收到消息
        &#123;
            while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) //处理所有已入队的消息
            &#123;
                TranslateMessage(&amp;msg); //message translat and format, add into message queue
                DispatchMessage(&amp;msg); //call message handler
            &#125;
        &#125;
        else if (result &gt;= WAIT_OBJECT_0 &amp;&amp; result &lt; WAIT_OBJECT_0 + nWaitCount) //表示收到了线程结束信号
        &#123;
            nExitThreadCount++;
            if (nExitThreadCount &lt; totalThreadCount)
            &#123;
                /*必须更新hThread，否则已退出的线程一直被检测到*/
                int nIndex = result - WAIT_OBJECT_0; //退出线程的index
                hThread[nIndex] = hThread[nWaitCount - 1]; //更新等待列表：hThread, 交换退出的成员和尾部成员
                hThread[nWaitCount - 1] = NULL;

                nWaitCount--; //更新要等待的线程数
            &#125;
            else
            &#123;
                break; //等待的所有线程都已完成
            &#125;
        &#125;
    &#125;

    //All threads returned
</code></pre>
<p>MsgWaitForMultipleObjects的MS说明文档：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects">MsgWaitForMultipleObjects function (winuser.h)</a><br>返回值的含义是重点，这个文档说的很隐晦：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051517122.png" alt="16"></p>
<p>大意是：等待n个线程</p>
<ul>
<li>如果返回的值i是属于0~n-1，说明第i个工作线程结束了</li>
<li>如果返回值是n，不是线程结束，而是收了到消息，例如工作线程内发送的消息。</li>
</ul>
<p>因此代码逻辑是：<br>1.如果有消息，就处理消息<br>关于message的peek,translate和dispatch:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/caimagic/article/details/50629570">PeekMessage使用方法</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang15061955806/article/details/52066559">消息循环中TranslateMessage和Dispatch函数的作用</a></p>
<p>2.如果有线程结束，要更新线程句柄数组，只保留未等待到的线程；<br>当所有线程都等待到，退出等待循环</p>
<p>以上完成了主线程和多个工作线程的同步机制</p>
<h1 id="再进一步：调用其他进程"><a href="#再进一步：调用其他进程" class="headerlink" title="再进一步：调用其他进程"></a>再进一步：调用其他进程</h1><p>现需求如下：<br>有多个功能的FW需要测试，要求测试工具遍历每个FW, 调用其他的程序，更新到磁盘固件后，做之前的多进程读写比较流程<br>重点关注如何调用其他程序。假设FW更新程序是FirwmareUpdateTool.exe，接受FW相关的参数<br>需要实现：</p>
<ul>
<li>界面接收参数</li>
<li>调用其他程序，传参，且注意与主线程的同步</li>
</ul>
<p>代码：</p>
<pre><code>BOOL CmyMFCDlg::DoUpdateFirmware(CString filename)
&#123;
    TCHAR szFilePath[MAX_PATH + 1] = &#123; 0 &#125;;
    GetModuleFileName(NULL, szFilePath, MAX_PATH);
    (_tcsrchr(szFilePath, _T(&#39;\\&#39;)))[1] = 0;

    CString strToolPath(szFilePath);
    strToolPath = strToolPath + _T(&quot;FirwmareUpdateTool.exe&quot;);
    CString strPath;
    strPath.Format(_T(&quot;%s %s %s %d&quot;), strToolPath.GetBuffer(0), m_str_VendorID.GetBuffer(0), filename.GetBuffer(0), m_SlotID);
    
    strAppend = strPath;
    ShowLogInEditBox();

    if (!PathFileExists(strToolPath))
    &#123;
        strAppend.Format(_T(&quot;The %s is not exist!&quot;), strToolPath.GetBuffer(0));
        ShowLogInEditBox();
        MessageBox(strAppend, MB_OK);
        return FALSE;
    &#125;

    STARTUPINFO si = &#123; sizeof(STARTUPINFO) &#125;;//在产生子进程时，子进程的窗口相关信息
    PROCESS_INFORMATION pi;                  //子进程的ID/线程相关信息
    memset(&amp;pi, 0, sizeof(PROCESS_INFORMATION));
    DWORD returnCode = -1;              //用于保存子程进的返回值;

    BOOL bRet = CreateProcess(              //调用失败，返回0；调用成功返回非0；
        NULL,                               //一般都是空；（另一种批处理情况：此参数指定&quot;cmd.exe&quot;,下一个命令行参数 &quot;/c otherBatFile&quot;)
        strPath.GetBuffer(0),              //命令行参数         
        NULL,                               //_In_opt_    LPSECURITY_ATTRIBUTES lpProcessAttributes,
        NULL,                               //_In_opt_    LPSECURITY_ATTRIBUTES lpThreadAttributes,
        FALSE,                              //_In_        BOOL                  bInheritHandles,
        CREATE_NEW_CONSOLE,                 //新的进程使用新的窗口。
        NULL,                               //_In_opt_    LPVOID                lpEnvironment,
        NULL,                               //_In_opt_    LPCTSTR               lpCurrentDirectory,
        &amp;si,                                //_In_        LPSTARTUPINFO         lpStartupInfo,
        &amp;pi);                               //_Out_       LPPROCESS_INFORMATION lpProcessInformation

    if (bRet)
    &#123;
        while (TRUE) //这里也是为了输出打印和日志而等待进程，同时也阻塞了主线程
        &#123;
            DWORD result;
            MSG msg;
            result = MsgWaitForMultipleObjects(1, &amp;pi.hProcess, FALSE, INFINITE, QS_ALLINPUT);
            if (result == (WAIT_OBJECT_0))
            &#123;
                //获取子进程的返回值
                GetExitCodeProcess(pi.hProcess, &amp;returnCode);
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                break;
            &#125;
            else
            &#123;
                PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE);
                DispatchMessage(&amp;msg);
            &#125;
        &#125;
        strAppend.Format(_T(&quot;%s returnCode : %d &quot;), strToolPath.GetBuffer(0), returnCode);
        ShowLogInEditBox();
    &#125;
    else
    &#123;
        strAppend.Format(_T(&quot;Start the %s failed!&quot;), strToolPath.GetBuffer(0));
        ShowLogInEditBox();
        MessageBox(strAppend, MB_OK);
    &#125;

    if (!returnCode)
    &#123;
        return TRUE;
    &#125;
    return FALSE;
&#125;
</code></pre>
<p>CreateProcess创建进程，执行第三方程序<br>MsgWaitForMultipleObjects等待第三方进程返回，阻塞了当前主进程</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文涉及的知识点：</p>
<ul>
<li>界面控件与底层类的数据交互</li>
<li>MFC的文件，字符串操作</li>
<li>线程创建和线程同步</li>
<li>线程通信：消息机制</li>
<li>进程创建与同步</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/12/12/Markdown%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/Markdown%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Markdown使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 14:40:07" itemprop="dateCreated datePublished" datetime="2020-12-12T14:40:07+08:00">2020-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-12 14:40:57" itemprop="dateModified" datetime="2022-12-12T14:40:57+08:00">2022-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/markdown/" itemprop="url" rel="index"><span itemprop="name">markdown</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>有的文字或代码和markdown解析有冲突<br>如$, @等<br>在这些字符前加转义字符即可：$, @</p>
<h1 id="tab缩进"><a href="#tab缩进" class="headerlink" title="tab缩进"></a>tab缩进</h1><p>markdown本身不支持tab缩进，有以下方法：<br>1.可以用全角输入+2个空格实现缩进<br>2.输入<code>&amp;emsp</code>，就是全角空格符号<br>3.输入<code>&gt;</code></p>
<h1 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h1><pre><code>[标题](URL)
</code></pre>
<h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><pre><code>- line
* line
</code></pre>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><pre><code>#
##
###
</code></pre>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><pre><code>|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/12/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82UML%E7%B1%BB%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/09/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82UML%E7%B1%BB%E5%9B%BE/" class="post-title-link" itemprop="url">如何看懂UML类图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-09 14:33:00" itemprop="dateCreated datePublished" datetime="2020-12-09T14:33:00+08:00">2020-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 16:05:42" itemprop="dateModified" datetime="2022-12-05T16:05:42+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UML/" itemprop="url" rel="index"><span itemprop="name">UML</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。<br>统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。<br>UML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图<br>本文介绍开发中常用的类图</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。<br>首先讲解关系, 先来看一个例子：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148263.png" alt="image-20221205114810203"></p>
<p>分析一下上面的图, 首先从动物开始<br>动物是一个类 动物依赖氧气和水<br>然后鸟继承了动物，所以鸟的父类是动物 所以鸟是属于动物<br>然后鸟和翅膀是组合关系 一只鸟有两个翅膀<br>大雁鸭子和企鹅都是鸟所以继承了鸟类<br>大雁会有大雁群，大雁群是由大雁组成所以是聚合关系<br>企鹅和气候是关联关系因为企鹅需要依赖气候<br>然后再看大雁 大雁会飞翔 所以就实现了飞翔接口<br>唐老鸭是属于鸭子的 所以唐老鸭继承了鸭子这个类<br>上图是借鉴了大话设计模式里面的图。下面具体介绍各个符号的作用</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类一般是用三层矩形框表示，第一层表示类的名称，第二层表示的是字段和属性，第三层则是类的方法。第一层中，如果是抽象类，需用斜体显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148740.png" alt="image-20221205114819689"></p>
<h2 id="类符号"><a href="#类符号" class="headerlink" title="类符号"></a>类符号</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148030.png" alt="image-20221205114830981"><br>看上面的学生类里面有五个属性和两个方法</p>
<pre><code>+号表示公共的 public
-表示 私有的 private
#表示protected
</code></pre>
<p>带下划线表示静态属性，一般表示方法: +属性:类型。<br>括号内表示参数，后面是返回类型, 没有表示无返回值</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包(Package)： 是一种常规用途的组合机制。在UML中用一个Tab框表示，Tab里写上包的名称，框里则用来放一些其他子元素，比如类，子包等等。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148985.png" alt="image-20221205114837947"></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口(interface)：接口包含操作但不包含属性，且它没有对外界可见的关联<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148968.png" alt="image-20221205114843929"></p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>依赖(Dependency) 表示的是类之间的调用关系。UML中用带箭头的虚线表示依赖关系，而箭头所指的则是被依赖的类。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148704.png" alt="image-20221205114849672"></p>
<h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>泛化(Generalization)： 表示的是类之间的继承关系，注意是子类指向父类。UML中用带空心三角箭头的实线表示泛化关系，箭头指向的是一般个体。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051148143.png" alt="image-20221205114855112"></p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联(Association) 表示的是类与类之间存在某种特定的对应关系。UML中用双向带箭头的虚线表示关联关系，箭头两端为相互关联的两个类<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051149187.png" alt="image-20221205114902153"></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合(Aggregation)： 是关联关系的一种特例，表示的是整体与部分之间的关系，部分不能离开整体单独存在。UML中用空心菱形头的实线表示聚合关系，菱形头指向整体<br><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221205114909206.png" alt="image-20221205114909206"></p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合(Composition)： 是聚合的一种特殊形式，表示的是类之间更强的组合关系。UML中用实心菱形头的实线来表示组合，菱形头指向整体。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051149567.png" alt="image-20221205114949528"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/12/07/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll/" class="post-title-link" itemprop="url">浅谈Linux网络编程: IO多路复用之select、poll、epoll</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-07 13:58:53" itemprop="dateCreated datePublished" datetime="2020-12-07T13:58:53+08:00">2020-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 14:03:05" itemprop="dateModified" datetime="2022-12-05T14:03:05+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>I&#x2F;O多路复用：通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<p>但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>IO多路复用适用如下场合：</p>
<ul>
<li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li>
</ul>
<p>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p>
<h1 id="select实现"><a href="#select实现" class="headerlink" title="select实现"></a>select实现</h1><p>逻辑时序：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401453.png" alt="1"><br>具体实现：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401118.png" alt="2"></p>
<p>fd_set(监听的端口个数)：32位机默认是1024个，64位机默认是2048。</p>
<p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间<br>（2）注册回调函数__pollwait<br>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）<br>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。<br>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。<br>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。<br>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。<br>（8）把fd_set从内核空间拷贝到用户空间。</p>
<p>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024</p>
<h1 id="poll实现"><a href="#poll实现" class="headerlink" title="poll实现"></a>poll实现</h1><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，而使其没有连接数的限制。其他的都差不多。</p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051401522.png" alt="3"></p>
<h2 id="epoll的几大改进"><a href="#epoll的几大改进" class="headerlink" title="epoll的几大改进"></a>epoll的几大改进</h2><p>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。<br>每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中。<br>而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。即epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关。</p>
<p>对于第三个缺点，epoll没有这个限制。<br>它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看,一般来说这个数目和系统内存关系很大。</p>
<h2 id="epoll小结："><a href="#epoll小结：" class="headerlink" title="epoll小结："></a>epoll小结：</h2><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。<br>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<h1 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h1><ol>
<li><p>支持一个进程所能打开的最大连接数<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051402990.png" alt="4"></p>
</li>
<li><p>FD剧增后带来的IO效率问题<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051402536.png" alt="5"></p>
</li>
<li><p>消息传递方式<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051403370.png"></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p>
<ul>
<li>连接数多，活跃链接占比不高的场景下，epoll的性能最好</li>
<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>
<li>select低效是因为每次它都需要轮询。但低效也是相对的，可通过良好的设计改善。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/12/03/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9ATinyhttpd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/03/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9ATinyhttpd/" class="post-title-link" itemprop="url">开源项目学习：Tinyhttpd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-03 14:45:44" itemprop="dateCreated datePublished" datetime="2020-12-03T14:45:44+08:00">2020-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-12 14:56:31" itemprop="dateModified" datetime="2022-12-12T14:56:31+08:00">2022-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/open-source/" itemprop="url" rel="index"><span itemprop="name">open source</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Tinyhttpd是一个C + CGI实现的简单http server，适合初学者学习。代码许可协议：GPL，copyright 1999, by J. David Blackstone.<br>本文对Tinyhttp稍作注释和改动，验证并理解其主要流程, 本文源码：<br>Github: <a target="_blank" rel="noopener" href="https://github.com/cursorhu/myTinyHttpd">cursorhu&#x2F;myTinyHttpd</a></p>
<h1 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2.背景知识"></a>2.背景知识</h1><h2 id="TCP套接字的通信流程"><a href="#TCP套接字的通信流程" class="headerlink" title="TCP套接字的通信流程"></a>TCP套接字的通信流程</h2><p>网络协议栈的核心是TCP&#x2F;IP协议，HTTP本质上是对TCP的应用层封装，要理解HTTP服务程序，首先要理解TCP层的通信机制，在Linux环境中TCP采用socket接口通信，流程如下图<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121451104.png" alt="image-20221212145149039"><br>关于Linux网络编程相关知识，参考《Linux网络编程-第二版》<br>TinyHttpd实现服务端的流程。</p>
<h2 id="HTTP的请求方式"><a href="#HTTP的请求方式" class="headerlink" title="HTTP的请求方式"></a>HTTP的请求方式</h2><p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/9099940.html">浅谈HTTP中GET、POST用法以及它们的区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/eson_15/article/details/88083280">99%的人都理解错了HTTP中GET与POST的区别</a><br>理解以下几点：</p>
<ul>
<li>GET，POST，PUT，DELETE是http层对数据操作的封装，底层本质还是TCP的read&#x2F;write过程</li>
<li>http server处理请求的基本流程：读取-拆解-处理-封装-回写，拆解和封装的就是http层的请求和数据格式，处理是指TCP层能理解的数据。就像快递退货时的流程：取件-拆包-查看-装包-寄出</li>
</ul>
<h2 id="CGI的时代背景"><a href="#CGI的时代背景" class="headerlink" title="CGI的时代背景"></a>CGI的时代背景</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c4dc22699a42">CGI是什么</a></p>
<ul>
<li>CGI是2000年的web接口标准，后端部署perl-CGI脚本，连接server处理程序和web客户端</li>
<li>CGI目前还应用在嵌入式web等C-based环境，这个和当前web主流的Java Spring + Vue(JS)是完全不同的应用场景，所以CGI技术本身并无过时一说。</li>
</ul>
<h1 id="3-调试httpd"><a href="#3-调试httpd" class="headerlink" title="3.调试httpd"></a>3.调试httpd</h1><h2 id="部署httpd服务"><a href="#部署httpd服务" class="headerlink" title="部署httpd服务"></a>部署httpd服务</h2><p>Aliyun CentOS环境，运行如下deploy.sh：</p>
<pre><code>#!/bin/bash
chmod +x htdocs/*.cgi
yum install -y perl perl-CGI
make clean &amp;&amp; make
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452836.png" alt="image-20221212145206784"></p>
<h2 id="浏览器访问httpd"><a href="#浏览器访问httpd" class="headerlink" title="浏览器访问httpd"></a>浏览器访问httpd</h2><p>服务端直接运行httpd，会分配随机可用端口，本地chrome浏览器访问该服务所在的ip:端口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452831.png" alt="image-20221212145218796"></p>
<p>这里ip即为httpd所在主机ip，默认访问资源是htdocs&#x2F;index.html，原因可见httpd.c的http Get请求解析url的处理<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452854.png" alt="image-20221212145227807"></p>
<p>index.h调用color.cgi脚本：</p>
<pre><code>&lt;HTML&gt;
&lt;TITLE&gt;Index&lt;/TITLE&gt;
&lt;BODY&gt;
&lt;P&gt;Welcome to J. David&#39;s webserver.
&lt;H1&gt;CGI demo: get color
&lt;FORM ACTION=&quot;color.cgi&quot; METHOD=&quot;POST&quot;&gt;
Enter color(example: red, pink, blue): &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;color&quot;&gt;
&lt;INPUT TYPE=&quot;submit&quot;&gt;
&lt;/FORM&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p>color.cgi内容：</p>
<pre><code>#!/usr/bin/perl -Tw

use strict;
use CGI;

my($cgi) = new CGI;

print $cgi-&gt;header;
my($color) = &quot;blue&quot;;
$color = $cgi-&gt;param(&#39;color&#39;) if defined $cgi-&gt;param(&#39;color&#39;);

print $cgi-&gt;start_html(-title =&gt; uc($color),
                       -BGCOLOR =&gt; $color); 
print $cgi-&gt;h1(&quot;This is $color&quot;);
print $cgi-&gt;end_html;
</code></pre>
<p>干了两件事：</p>
<ul>
<li>html页面的bgcolor参数设置成了用户输入的color变量字符串</li>
<li>显示字符串：This is $color</li>
</ul>
<p>输入“red”, 浏览器显示效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452042.png" alt="image-20221212145241997"></p>
<p>F12打开浏览器调试窗口，可见：</p>
<ul>
<li>访问资源为color.cgi</li>
<li>查看http head内容，浏览器客户端的请求是POST，类型是text文本，表单数据(Form data):color的值是red</li>
<li>查看http response内容，即httpd返回的内容。返回了html文本，即浏览器可见的红色页面</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121452614.png" alt="image-20221212145258548"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121455408.png" alt="image-20221212145533364"></p>
<p>现在理解以下整个流程：</p>
<ul>
<li>服务器上httpd先运行，处于监听(listen)客户端请求的状态</li>
<li>本地浏览器输入服务器ip：端口，访问httpd，发送的http请求类型是GET,即获取文本</li>
<li>httpd收到请求，在处理过程中调用cgi脚本，生成response的内容</li>
<li>httpd打包内容成http层的格式(head+body+…)，返回浏览器客户端</li>
<li>浏览器客户端解析html文本并显示成可见的页面。</li>
</ul>
<p>再看另外一个获取时间的功能：<br>浏览器输入<code>ip:port/date.html</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453695.png" alt="image-20221212145316645"><br>访问的资源是date.cgi，返回了显示当前时间的页面<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453222.png" alt="image-20221212145338163"><br>看下http请求和响应<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453850.png" alt="image-20221212145345780"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121453273.png" alt="image-20221212145353230"></p>
<p>date.cgi的实现：shell直接调用linux <code>date</code>命令</p>
<pre><code>#!/bin/bash
echo &quot;Content-Type: text/html&quot;
echo
echo &quot;&lt;HTML&gt;&lt;BODY&gt;&quot;
echo &quot;&lt;CENTER&gt;Today is:&lt;/CENTER&gt;&quot;
echo &quot;&lt;CENTER&gt;&lt;B&gt;&quot;
date
echo &quot;&lt;/B&gt;&lt;/CENTER&gt;&quot;
echo &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;
</code></pre>
<h2 id="TCP-socket访问httpd-测试"><a href="#TCP-socket访问httpd-测试" class="headerlink" title="TCP socket访问httpd(测试)"></a>TCP socket访问httpd(测试)</h2><p>client.c直接使用socket接口访问httpd，这是个测试功能，因此用编译参数控制了该功能, <code>make test_sock=y</code>编译该版本的httpd<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454984.png" alt="image-20221212145401934"><br>client和httpd在同一主机，直接访问回环地址127.0.0.1，可见httpd返回了client发送的字符’A’</p>
<h1 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h1><h2 id="1-httpd的处理http请求的主要流程"><a href="#1-httpd的处理http请求的主要流程" class="headerlink" title="(1) httpd的处理http请求的主要流程"></a>(1) httpd的处理http请求的主要流程</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454501.png" alt="image-20221212145417431"></p>
<ol>
<li>服务器启动，在指定端口或随机选取端口绑定 httpd 服务</li>
<li>收到一个 HTTP 请求时（其实就是 listen 的端口 accpet 的时候），派生一个线程运行 accept_request 函数</li>
<li>取出 HTTP 请求中的 method (GET 或 POST) 和 url,。对于 GET 方法，如果有携带参数，则 query_string 指针指向 url 中 ？ 后面的 GET 参数</li>
<li>格式化 url 到 path 数组，表示浏览器请求的服务器文件路径，在 tinyhttpd 中服务器文件是在 htdocs 文件夹下。当 url 以 &#x2F; 结尾，或 url 是个目录，则默认在 path 中加上 index.html，表示访问主页</li>
<li>如果文件路径合法，对于无参数的 GET 请求，直接输出服务器文件到浏览器，即用 HTTP 格式写到套接字上，然后跳到（10）。其他情况（带参数 GET，POST 方式，url 为可执行文件），则调用 excute_cgi 函数执行 cgi 脚本</li>
<li>读取整个 HTTP 请求并丢弃，如果是 POST 则找出 Content-Length. 把 HTTP 200 状态码写到套接字</li>
<li>建立两个管道，cgi_input 和 cgi_output, 并 fork 一个进程</li>
<li>在子进程中，把 STDOUT 重定向到 cgi_outputt 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端，设置 request_method 的环境变量，GET 的话设置 query_string 的环境变量，POST 的话设置 content_length 的环境变量，这些环境变量都是为了给 cgi 脚本调用，接着用 execl 运行 cgi 程序</li>
<li>在父进程中，关闭 cgi_input 的读取端 和 cgi_output 的写入端，如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT。接着关闭所有管道，等待子进程结束。管道状态参考下图。</li>
<li>关闭与浏览器的连接，完成了一次 HTTP 请求与回应， HTTP是无连接的。</li>
</ol>
<p>管道初始状态：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454140.png" alt="image-20221212145427091"><br>管道最终状态：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121454591.png" alt="image-20221212145432542"></p>
<p>主要函数：</p>
<ul>
<li>startup: 初始化httpd服务，包括建立服务端的套接字，绑定端口，进行监听等</li>
<li>accept_request: 处理从套接字上监听到的一个 HTTP 请求，是服务器处理请求的主流程</li>
<li>execute_cgi: 运行cgi程序的处理，对应POST请求</li>
<li>sever_file: 调用cat把服务器文件返回给浏览器，对应GET请求</li>
</ul>
<p>辅助功能函数：</p>
<ul>
<li>get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束</li>
<li>unimplemented: 返回给浏览器表明收到的HTTP请求所用的method不支持，httpd只支持GET和POST</li>
<li>headers: 把HTTP响应的头部写到套接字</li>
<li>cat: 读取服务器上的指定文件写到socket套接字</li>
</ul>
<h2 id="2-httpd处理client的socket请求"><a href="#2-httpd处理client的socket请求" class="headerlink" title="(2)httpd处理client的socket请求"></a>(2)httpd处理client的socket请求</h2><p>参考TCP套接字流程，注意一点，server端回写数据后，要close掉，client才能正常close。<br>编译选项的实现讲一下：<br>Makefile根据输入参数，定义宏, 如果编译输入带参<code>make test_sock=y</code>，则定义宏TEST_SOCK，等价于在源码<code>#define TEST_SOCK</code></p>
<pre><code>#用编译选项定义宏
ifeq ($(test_sock), y)
CFLAGS+= -D TEST_SOCK
endif
</code></pre>
<p>httpd.c对宏的处理：</p>
<pre><code>#ifdef TEST_SOCK
void test_sock(int);
#else
#define test_sock(...)  do&#123;&#125;while(0)
#endif
</code></pre>
<p>这里如果没定义TEST_SOCK，直接把test_sock函数声明成do{}while(0)形式，这种控制在linux kernel源码中很常见，好处是不需要在调用处加宏控制，若TEST_SOCK未定义，调用test_sock()等价于空语句。<code>...</code>代表所有入参</p>
<p>扩展：httpd能否同时支持浏览器和client程序访问?<br>一个socket描述符只能对应一个客户端，如果server想要一对多的IO复用，需要select-poll机制，参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/feily/articles/14030297.html">IO多路复用之select、poll、epoll</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zouli415/article/details/79696766">linux下socket编程实现一个服务器连接多个客户端</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nengm1988/p/7816618.html">Tinyhttpd精读解析</a><br><a target="_blank" rel="noopener" href="https://github.com/EZLippi/Tinyhttpd">EZLippi&#x2F;Tinyhttpd</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/12/03/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/03/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Git常用操作笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-03 12:02:00" itemprop="dateCreated datePublished" datetime="2020-12-03T12:02:00+08:00">2020-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-01 14:32:49" itemprop="dateModified" datetime="2023-03-01T14:32:49+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="拉取和同步"><a href="#拉取和同步" class="headerlink" title="拉取和同步"></a>拉取和同步</h2><pre><code>git clone http://xxx.xxx.git //http方式, 从远程clone仓库
git pull //拉取远程分支
git branch //查看本地
git branch -a //查看远程和本地
git checkout xxxbranch //本地切到某分支
git checkout xxx/xxx //仅拉取部分目录或文件
</code></pre>
<h2 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a>推送到远程</h2><pre><code>git add -A //推送所有修改到本地仓库
git commit -m &quot;change logs&quot; //提交到本地仓库（记录修改信息）
git push //推送本地分支到远程的同名分支，需要先关联
git push origin &lt;本地分支名&gt; //推送本地分支到远程同名分支
git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; //推送本地分支到远程指定分支
</code></pre>
<h2 id="加tag-x2F-删tag"><a href="#加tag-x2F-删tag" class="headerlink" title="加tag&#x2F;删tag"></a>加tag&#x2F;删tag</h2><pre><code>git tag -a TAGNAME -m &quot;TAG LOG&quot; //加tag
git push origin TAGNAME //推送tag到远程
git tag -d TAGNAME //删除本地tag
git push origin :refs/tags/TAGNAME //删除远程tag
</code></pre>
<h2 id="创建-x2F-删除-x2F-修改分支"><a href="#创建-x2F-删除-x2F-修改分支" class="headerlink" title="创建&#x2F;删除&#x2F;修改分支"></a>创建&#x2F;删除&#x2F;修改分支</h2><p>创建分支并关联远程</p>
<pre><code>git checkout -b BRANCH_NAME //本地创建分支
git push origin BRANCH_NAME //推送到远程
git push --set-upstream origin BRANCH_NAME //关联远程，便于以后分支pull/push
</code></pre>
<p>删除本地分支    </p>
<pre><code>git branch -d branch_name
git branch -D branch_name //强制删除
</code></pre>
<p>删除远程分支</p>
<pre><code>git push origin -d branch_name
</code></pre>
<p>分支重命名(本地)</p>
<pre><code>git branch -m OLD_NAME NEW_NAME
</code></pre>
<h2 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h2><p>可以用<code>git diff --help</code>直接查看git diff的Manual Page</p>
<pre><code>git diff COMMIT_ID //比较本地和某commit_id的内容
git diff ID1 ID2 //比较两个提交的内容，比较新增时，旧版本在前，新版本在后
git diff &lt;path of file&gt; //比较本地某文件的内容
git diff --name-only ID1 ID2 //只显示有差异的文件名列表
git diff &lt;commit&gt;..&lt;commit&gt; [&lt;path&gt;…​] //比较两个提交中指定文件名或者路径的差异
</code></pre>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre><code>git reset --hard HEAD^ //回退到上个版本
git reset --hard HEAD^^ //回退到上上个版本
git reset --hard COMMIT_ID //回退到指定提交
git push -f //强制提交，覆盖远程，使远程也回退
git push origin master -f //强制推送到远程的master分支
</code></pre>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>两个分支A和B，要把分支B的所有提交合并到A分支上</p>
<pre><code>git checkout &lt;branch A&gt; //切到待合并分支A
git merge &lt;branch B&gt; //拉取分支B，合并到当前分支A
git merge &lt;branch B&gt;  --squash //合并分支，将B的多个提交融合成一个再合并到A，而不是B的所有提交记录都照搬到A（这个更常用）
git merge --abort //终止合并
</code></pre>
<p>如果有<code>merge conflict</code>,手动修改冲突文件-&gt;保存文件-&gt;<code>git add -A</code>提交修改-&gt;<code>git commit -m &quot;xxx&quot;</code>提交该合并</p>
<p>如果本地仓库已经处于待merge状态，又想取消merge,同步成远程仓库状态，只需要reset本地仓库到当前commit-id</p>
<pre><code>git reset --hard HEAD
</code></pre>
<p>也可以reset到指定commit-id:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog &amp;&amp; git reset --hard commit-id</span><br></pre></td></tr></table></figure>

<h2 id="合并提交"><a href="#合并提交" class="headerlink" title="合并提交"></a>合并提交</h2><h3 id="合并当前提交"><a href="#合并当前提交" class="headerlink" title="合并当前提交"></a>合并当前提交</h3><p>如果当前修改还未提交, 想合并到最近的一次提交里，例如最近提交有个错误，可以用<code>--amend</code>修订提交</p>
<pre><code>git add -A
git commit --amend
git push -f //amend后通常强制推送，因为没有新增commit
</code></pre>
<h3 id="合并历史提交"><a href="#合并历史提交" class="headerlink" title="合并历史提交"></a>合并历史提交</h3><p>有时同一个功能分多次提交，提交过于频繁，需要合并成一个提交。<br>如下有三次提交</p>
<pre><code>$git log
commit_3: xxxxx
    message_3 ....
commit_2: xxxxx
    message_2 ....
commit_1: xxxxx
    message_1 ....
</code></pre>
<p>现在想把commit_3 和 commit_2合并成一个commit.</p>
<pre><code>git rebase -i commit_1 //重定位到要合并的前一个提交
</code></pre>
<p>进入commit信息编辑模式：</p>
<pre><code>pick commit_2 message_2...
pick commit_3 message_3...
</code></pre>
<p>将要合并的commit_3前的属性<code>pick</code>（选用）改为<code>squash</code>（压扁），<code>wq</code>保存，进入当前合并commit的信息提交界面，再次<code>wq</code>保存, 查看合并后提交记录如下：</p>
<pre><code>$git log
commit_4: xxxxx
    message_3 ....
    message_2 ....
commit_1: xxxxx
    message_1 ....
</code></pre>
<p>两次提交已合成一次（新的）提交</p>
<h1 id="多人提交的冲突解决办法"><a href="#多人提交的冲突解决办法" class="headerlink" title="多人提交的冲突解决办法"></a>多人提交的冲突解决办法</h1><p>A和B同时开发某项目的同一个分支，A拉取最新版本1.0后，在本地新增功能，此时B也在1.0上修改并提交到了新版本1.1到远程仓库。A在B提交之后再提交，发现自己本地的修改已是旧版本，无法直接提交，如下图是A的add,commit,push三连的结果</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051005366.png" alt="1631249531971_115"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051006842.png" alt="image-20221205100655798"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051007268.png" alt="image-20221205100726224"></p>
<h3 id="手动解决conflict"><a href="#手动解决conflict" class="headerlink" title="手动解决conflict"></a>手动解决conflict</h3><p><code>git pull</code> 拉取远程仓库最新版本，此时有两种情况</p>
<ul>
<li>代码有冲突，需手动修改冲突区域的代码块，二选一，然后重新add-commit-push三连提交</li>
<li>无冲突，pull代码会自动合并，直接重新三连提交即可</li>
</ul>
<p>以下是有冲突的情况<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051008610.png" alt="image-20221205100836563"></p>
<p>找到冲突源码，冲突的符号定义如下：</p>
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt; HEAD</code>：当前本地的代码块</li>
<li><code>======</code>：分割冲突块</li>
<li><code>&gt;&gt;&gt;&gt;&gt;&gt;b699a7fc</code>：远程最新hash版本号的代码块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051008970.png" alt="image-20221205100855921"></p>
<p>修改方法：先拷贝冲突关键语句，再删除所有冲突域符号，最后只保留如下代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051019814.png" alt="image-20221205101900769"></p>
<p>修改完后，<code>git add, git commit, git push</code>，成功提交<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051020311.png" alt="image-20221205102021265"></p>
<p>查看提交后版本：<code>git log</code></p>
<h3 id="修改某次提交的commit信息"><a href="#修改某次提交的commit信息" class="headerlink" title="修改某次提交的commit信息"></a>修改某次提交的commit信息</h3><p>有时需要修改commit信息便于区分哪个是解决冲突后的提交<br>解决方案：</p>
<ul>
<li>修改最新的commit，只需要amend修改commit信息后，再push</li>
<li>修改历史的commit，需要先rebase修改属性为edit后，再commit –amend</li>
</ul>
<p>下面讲修改历史commit<br>如下图，想修改9877的commit信息<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051023197.png" alt="image-20221205102348131"></p>
<p>先rebase到之前的commit<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051024479.png" alt="image-20221205102432433"><br>显示其后的版本属性如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051024531.png" alt="image-20221205102447476"><br>修改9877的属性为edit(待编辑模式)，将原始commit改成如下内容,<code>:wq</code>保存:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051026868.png" alt="image-20221205102658821"></p>
<p>然后<code>commit --amend, rebase --continue</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051027201.png" alt="image-20221205102751155"><br>再查看下git og修改成功<br>最后<code>git push</code>同步到远程仓库</p>
<h1 id="从另一个分支拉取指定的几个commit内容"><a href="#从另一个分支拉取指定的几个commit内容" class="headerlink" title="从另一个分支拉取指定的几个commit内容"></a>从另一个分支拉取指定的几个commit内容</h1><p>A和B都在git的master分支提交代码，一天发现master某个版本有问题，回退n各版本都找不到是谁提交引起的问题，由于master还要作稳定测试等其他用途，决定先回退master分支到较早的指定版本，而master最新版和稳定版之间提交的内容，分别由各自A和B“认领”，拉取master上自己提交的功能到自己的分支，debug好以后在合并回master。<br>需求：<br>如何在开发者分支上拉取master分支的指定几个commit的内容，注意不是某个commit以前的内容，是commit内的内容？</p>
<h2 id="创建自己分支，回退master"><a href="#创建自己分支，回退master" class="headerlink" title="创建自己分支，回退master"></a>创建自己分支，回退master</h2><p>首先切到master分支上，创建一个自己的分支thomas，自己分支是master的拷贝</p>
<pre><code>git checkout master //当前在那个分支，决定创建分支的内容
git checkout -b thomas //做两件事：在本地创建thomas分支，内容和master一样；切到thomas分支
git push --set-upstream origin thomas //推送分支到远程，这步很容易漏掉
git branch //查看当前在哪个分支
git branch -a //查看所有分支
</code></pre>
<p>以上操作完成后，自己分支就创建好了，注意动作只影响到本地仓库的.git文件，要同步远程仓库还要push到远程<br>下面备份master, 再回退master</p>
<pre><code>git checkout master
git checkout -b master_backup //先备份master,上面有自己分支要拉取的内容
git checkout master //切到master,准备回退
git reset --hard COMMIT_ID //回退到稳定版本commit_id
git push -f //由于是回退，提交比远程的还早，一般需要强制提交，这个操作也会把本地的.git修改一同提交到远程
</code></pre>
<p>这样就有三个分支：</p>
<pre><code>master: 包含稳定版本的旧代码
master_backup: master的备份，包含稳定版和之后的A、B的一些提交
thomas: 开发者A的个人分支，现在和master稳定版完全一样
</code></pre>
<p>下面只需要从master_backup拉取自己相关的提交到thomas分支即可。</p>
<h2 id="cherry-pick拉取指定commit"><a href="#cherry-pick拉取指定commit" class="headerlink" title="cherry-pick拉取指定commit"></a>cherry-pick拉取指定commit</h2><p>先把要拉取的commit id存起来：</p>
<pre><code>git checkout master_backup
git log &gt; ../master_backup.log
</code></pre>
<p>截取commit log片段如图<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051038438.png" alt="image-20221205103857374"></p>
<p>切到thomas分支，拉取master_backup的commit</p>
<pre><code>git checkout thomas
git cherry-pick 3d6b3be
</code></pre>
<p>这种方法只拉了一个commit, 更好的方式是按功能，一次拉多个commit,甚至一次把所有的commit都拉完。<br>cherry-pick支持多个pick一步到位<br>例如git log如下</p>
<pre><code>commit4 id4
commit3 id3
commit2 id2
commit1 id1
</code></pre>
<p>离散拉取：只拉取id1和id4：</p>
<pre><code>git cherry-pick id1 id4
</code></pre>
<p>！注意，提交顺序很重要，旧版本写在前新版本写在后<br>如果是区间拉取,即全部的id1，id2, id3，id4</p>
<pre><code>git cherry-pick id1..id4 //加两个点即为区间拉取
</code></pre>
<p>为了验证是不是真的拉取了多个版本，可以<code>git diff --name-only id1 id4</code>看下拉取后的修改哪些文件，对比被拉取分支的修改，如果一致，说明确实拉取多个commit<br>对于上图的commit，建议按功能多次cherry-pick并commit+push，便于后续debug。</p>
<h2 id="cherry-pick的冲突问题"><a href="#cherry-pick的冲突问题" class="headerlink" title="cherry-pick的冲突问题"></a>cherry-pick的冲突问题</h2><p>cherry-pick也是合并，只要是合并代码，就可能有冲突<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051039238.png" alt="image-20221205103926181"><br>合并单个commit,使用使用常规的冲突解决办法即可：</p>
<ul>
<li>到源码改冲突， <code>&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;</code>三个标记之间代码块二选一</li>
<li><code>git status</code>查看哪些待提交</li>
<li><code>git add -A</code>提交修改后的源码到本地.git</li>
</ul>
<h3 id="单个提交的冲突解决"><a href="#单个提交的冲突解决" class="headerlink" title="单个提交的冲突解决"></a>单个提交的冲突解决</h3><p>由于是从其他分支的commit id合并到当前分支（HEAD）,可以不加考虑的删掉<code>&lt;&lt;&lt;&lt;HEAD</code>和<code>====</code>之间的内容，采用<code>====</code>和<code>commit_id</code>之间的内容，随后删掉三个标记即可。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051039681.png" alt="image-20221205103951579"><br>有可能出现冲突代码块有重叠区的情况</p>
<pre><code>&lt;&lt;&lt;&lt; HEAD
code 1
=====
&lt;&lt;&lt;&lt; commit_id 1
code 2
&gt;&gt;&gt;&gt; commit_id 2
code 3
=====
code 4
&gt;&gt;&gt;&gt; commit_id 3
</code></pre>
<p>只要确定一个原则：&lt;&lt;&lt;&lt;是冲突块的起始点，&#x3D;&#x3D;&#x3D;&#x3D;是分界，&gt;&gt;&gt;&gt;是终止点，分两步删代码就可以了。</p>
<h3 id="多个提交的冲突解决："><a href="#多个提交的冲突解决：" class="headerlink" title="多个提交的冲突解决："></a>多个提交的冲突解决：</h3><p>如果是cherry-pick多个commit，冲突的解决方法就不一样了。<br>其区别在于，多个commit_id的cherry-pick，一旦遇到冲突，就会停下pick,需要手动解决冲突后，用<code>cherry-pick --continue</code>继续接下来的commit合并，直到由遇到冲突，再次手动解决。也就是说冲突会阻塞多个commit的cherry-pick，它不会一次性合并所有commit,让你一次性解决冲突。具体流程如下：</p>
<ul>
<li><code>cherry-pick id1 id2 id3 id4 .... idn</code></li>
<li>冲突报错，到源码手动解决</li>
<li><code>git add -A</code> 添加解决冲突后的文件到.git</li>
<li><code>cherry-pick --continue</code> 继续后面的合并,cherry-pick成功会自动提交commit信息</li>
<li>再遇到冲突，再次解决….</li>
<li>所有id1 … idn全部pick完成</li>
</ul>
<p>批量cherry-pick每次成功后都会有一次commit信息，有时候会报错，需要手动commit之后再continue</p>
<h3 id="特殊的冲突情况"><a href="#特殊的冲突情况" class="headerlink" title="特殊的冲突情况"></a>特殊的冲突情况</h3><p>提示有一个commit是合并的提交，即这个提交是两个分支的交汇，cherry-pick不知道以哪个分支为准<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040545.png" alt="image-20221205104005491"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040453.png" alt="image-20221205104017399"></p>
<p>如何解决：cherry-pick添加-m 1选项</p>
<pre><code>For example, if your commit tree is like below:

- A - D - E - F -   master
   \     /
    B - C           branch one
then git cherry-pick E will produce the issue you faced.

git cherry-pick E -m 1 means using D-E, while git cherry-pick E -m 2 means using B-C-E
</code></pre>
<p>例如选择cherry-pick commid_id -m 1, 结果如下，可手动解决冲突了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051040782.png" alt="image-20221205104053730"><br>注意有merge的commit,会包含其他人的更新，如果只是pick自己的代码，不需要pick带merge的commit.</p>
<h1 id="跨仓库合并代码"><a href="#跨仓库合并代码" class="headerlink" title="跨仓库合并代码"></a>跨仓库合并代码</h1><p>假设某公司windows driver主线仓库为storport, 为了某产品定制的driver仓库为gg8, 现在gg8的所有feature已充分测试，准备合并到主线仓库storport, 这两个仓库的代码差异非常大，维护者众多，如何处理？</p>
<p>首先划分代码各部分归谁负责：<br>每个人用git，找出其在gg8仓库的个人修改，用winmerge手动合并到主线仓库storport<br>那么具体如何高效，可靠的合并：</p>
<p>git部分：<br>用git只找差异部分，具体操作：</p>
<pre><code>git diff commit_a commit_b //找所有文件+代码差异
git diff commit_a commit_b --stat //只显示有差异的文件名，这个信息对应winmerge手动合并很重要
git diff commit_a commit_b 指定文件路径 //只显示指定文件的内容差异，这个信息对应winmerge手动合并很重要
</code></pre>
<p>winmerge部分：<br>winmerge可以比较两个仓库所有差异，但是有些差异可能不需要合并，例如换行，修改时间等。总之winmerge的差异有很多“误报”<br>如果只一个个打开有差异的文件去比效率太低，需要借助git定位到哪些该开发者负责的文件有改变，以及文件内哪些代码是该开发者改变的。</p>
<p>找出某开发者A的提交改了哪些文件：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046241.png" alt="image-20221205104623191"></p>
<p>找出具体代码：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046320.png"></p>
<p>winmerge直接合并：<br>只是一句打印差异，但是如果不用git先定位，要从左侧差异栏找出此代码，相当困难<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051046886.png" alt="image-20221205104642794"></p>
<p>这样，开发者A在代码合并过程中，完全不受其他开发者B, C的差异代码干扰</p>
<h1 id="强制覆盖本地代码"><a href="#强制覆盖本地代码" class="headerlink" title="强制覆盖本地代码"></a>强制覆盖本地代码</h1><p>git本地代码有时checkout到旧版本代码，想回到最新版本时，直接pull无法成功，且强制pull也不行。有以下两种方式解决：</p>
<h2 id="重新克隆"><a href="#重新克隆" class="headerlink" title="重新克隆"></a>重新克隆</h2><p>最简单是直接删掉本地项目，再重新<code>git clone</code></p>
<h2 id="fetch覆盖"><a href="#fetch覆盖" class="headerlink" title="fetch覆盖"></a>fetch覆盖</h2><pre><code>git fetch --all //拉取远程repo所有branch到本地，但不合并到本地repo
git reset --hard origin/master //本地repo强制同步远程repo的master分支
git pull -f //强制拉取远程repo最新代码
</code></pre>
<p>注意，如果本地旧版本代码有xxx.c，而远程最新代码没这个文件，本地需要手动删掉这个文件。因为以上操作不会删除本地文件，只会拉取本地没有的，或者覆盖不同的文件到本地。为了确保旧版本多出的文件删除，直接删除目录下除了<code>.git</code>以外的所有项目文件，再<code>fetch,reset,pull</code></p>
<h1 id="将本地未初始化git的项目上传到远程已初始化的git仓库"><a href="#将本地未初始化git的项目上传到远程已初始化的git仓库" class="headerlink" title="将本地未初始化git的项目上传到远程已初始化的git仓库"></a>将本地未初始化git的项目上传到远程已初始化的git仓库</h1><p>有一些项目代码是基于开源的庞大项目基础上开发，例如UEFI EDK2, Linux kernel.</p>
<p>项目开发时，可能基于不同的开源项目版本，例如：</p>
<p>远程git仓库是EDK2版本A0 + 自定义功能B0；本地的新功能是基于EDK2版本A1 + 自定义功能B1，且本地项目还没有初始化git。这种情况如何将本地项目直接上传到远程已有的项目上面去？</p>
<p>1.首先在本地建立git仓库</p>
<p>在本地新项目目录初始化git仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit信息&quot;</span><br></pre></td></tr></table></figure>

<p>2.将本地git仓库关联到远程已有的git仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http://远程仓库地址.git</span><br></pre></td></tr></table></figure>

<p>3.拉取远程仓库到本地 (如果远程仓库为空不需要此步)</p>
<p>注意<code>--allow-unrelated-histories</code>是忽略本地项目和远程项目没有历史关联的关键参数，否则不能pull成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<p>合并代码通常会有冲突，手动解决冲突后再<code>git add, git commit -m &quot;fix merge conflict&quot;</code></p>
<p>4.最后推送本地仓库到远程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<h1 id="链接外部repo作为子模块"><a href="#链接外部repo作为子模块" class="headerlink" title="链接外部repo作为子模块"></a>链接外部repo作为子模块</h1><p>在github的项目仓库中，通常看到如下有@符号的外部仓库链接，点进去可能打开其他的项目仓库。这种外部仓库相当于当前项目仓库的子模块。</p>
<p>类似于Linux的软链接，子模块方式可以链接到其他项目仓库，并自动同步其他仓库最新的代码。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212091106114.png" alt="image-20221209110659056"></p>
<p>1.如何创建外部repo的链接:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &quot;外部repo地址.git&quot; 外部repo文件夹名</span><br></pre></td></tr></table></figure>

<p>本地就clone了外部仓库到外部repo文件夹名中, 提交本项目和正常的提交流程相同</p>
<p>2.如何clone带外部repo的项目：</p>
<p>git clone 的时候需要加上<code>--recursive</code>，否则外部repo文件夹是空文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive &quot;项目地址.git&quot;</span><br></pre></td></tr></table></figure>

<p>如果已经忘记加<code>--recursive</code>，可以手动初始化子模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/12/01/C-STL%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/C-STL%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++ STL类使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 17:07:33" itemprop="dateCreated datePublished" datetime="2020-12-01T17:07:33+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 17:18:20" itemprop="dateModified" datetime="2022-12-08T17:18:20+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><p><strong>查找指定字符串的位置（下标）</strong></p>
<p>string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）</p>
<pre><code>//find函数返回类型 size_type
string s(&quot;1a2b3c4d5e6f7jkg8h9i1a2b3c4d5e6f7g8ha9i&quot;);
int position;
//find 函数 返回jk 在s 中的下标位置
position = s.find(&quot;jk&quot;);
if (position != s.npos)  //如果没找到，返回一个特别的标志c++中用npos表示
&#123;
    printf(&quot;position is : %d\n&quot; ,position);
&#125;
else
&#123;
    printf(&quot;Not found the flag\n&quot;);
&#125;
</code></pre>
<p>##查找某字符首次出现，或最后出现的位置<br>find_first_of() 和 find_last_of()返回子串出现在母串中的首次出现的位置，和最后一次出现的位置<br>查找上面示例的’c’的下标：</p>
<pre><code>flag = &quot;c&quot;;
position = s.find_first_of(flag);
printf(&quot;s.find_first_of(flag) is :%d\n&quot;,position);
position = s.find_last_of(flag);
printf(&quot;s.find_last_of(flag) is :%d\n&quot;,position);
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081711721.png" alt="image-20221208171122674"></p>
<p><strong>查找某给定位置后的子串的位置</strong></p>
<pre><code>//从字符串s 下标5开始，查找字符串b ,返回b 在s 中的下标
position=s.find(&quot;b&quot;,5);
cout&lt;&lt;&quot;s.find(b,5) is : &quot;&lt;&lt;position&lt;&lt;endl;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081711350.png"></p>
<p><strong>查找所有子串在母串中出现的位置</strong></p>
<pre><code>//查找s 中flag 出现的所有位置。
flag=&quot;a&quot;;
position=0;
int i=1;
while((position=s.find(flag,position))!=string::npos)
&#123;
    cout&lt;&lt;&quot;position  &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;position&lt;&lt;endl;
    position++;
    i++;
&#125;
</code></pre>
<h1 id="map与unordered-map的区别"><a href="#map与unordered-map的区别" class="headerlink" title="map与unordered_map的区别"></a>map与unordered_map的区别</h1><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p><strong>map：</strong><br>map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），<strong>红黑树具有自动排序的功能，因此map内部的所有元素都是有序的</strong>，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>
<p><strong>unordered_map:</strong><br>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，<strong>查找的时间复杂度可达到O(1</strong>)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<h2 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h2><p><strong>map</strong><br>优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。<br>红黑树结构：内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>
<p>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红&#x2F;黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map：</strong></p>
<p>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结：</strong><br>两种map性能分析的内存占用比较，就是红黑树 VS hash表的性能比较, 还是unorder_map占用的内存要高。<br>但是unordered_map查找的时间复杂度低，执行效率要比map高很多。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>unordered_map的用法和map是一样的，都提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。但其内部实现是不同的，对使用者来说不可见。</p>
<p>示例（map_and_unordered.cpp）：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;unordered_map&gt;  
#include &lt;map&gt;
#include &lt;string&gt;  

using namespace std;  

int main()  
&#123;  
    ////使用&#123;&#125;赋值, 注意：C++11才开始支持括号初始化
    unordered_map&lt;int, string&gt; myMap = &#123;&#123; 3, "C" &#125;,&#123; 4, "D" &#125;&#125;; 
    //使用[ ]进行单个插入，若已存在键值2，则修改其值
    myMap[1] = &quot;A&quot;;  
    myMap.insert(pair&lt;int, string&gt;(2, &quot;B&quot;));//使用insert和pair插入
  
    //遍历输出+迭代器的使用
    //auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator
    auto iter = myMap.begin(); 
    while (iter!= myMap.end())
    &#123;  
        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;  
        ++iter;  
    &#125;  
    
    //查找元素并输出+迭代器的使用
    //find()返回一个指向2的迭代器
    auto iterator = myMap.find(2);
    if (iterator != myMap.end())
        cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iterator-&gt;second &lt;&lt; endl;  
     
    return 0;  
&#125;
</code></pre>
<p>编译：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081713270.png" alt="image-20221208171339229"></p>
<p>结果：<br>unordered_map：没有按值的大小排序，从最近插入的到最早插入的，依次显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081714465.png" alt="image-20221208171412418"><br>把unordered_map改成map: 按值的大小，从小到大显示<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081713971.png" alt="image-20221208171351937"></p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>sort()函数是STL中的排序函数，由模板函数实现，复杂度N*logN。该函数专门用来对容器或普通数组中指定范围内的元素进行排序，该函数使用频率较高，且其实现综合了几种经典排序方法<br>使用格式如下：</p>
<pre><code>sort (first, last) //排序从first到last的数据，默认从小到大
sort (first, last, rule) //以某种规则排序，rule可使用std定义的，或自定义实现
</code></pre>
<h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><p>几种典型的使用方式：</p>
<ul>
<li>默认：从小到大</li>
<li>greater&lt; Type &gt;()：std提供的从大到小</li>
<li>自定义规则：函数，运算符，Lambda实现，这里规则都是传入两个参数（分别是要比较数组的靠左值，靠右值），返回bool类型，如果左值&lt;右值，即从小到大排序，反之从大到小</li>
</ul>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::sort
#include &lt;vector&gt;       // std::vector
#include &lt;stdlib.h&gt;

using namespace std;

//以普通函数的方式实现自定义排序规则
bool myComp(int i, int j) &#123;
    return (i &lt; j);
&#125;

//以对象的方式实现自定义排序规则
class myCompOper &#123;
public:
    bool operator() (int i, int j) &#123;
        return (i &gt; j);
    &#125;
&#125;;

//打印数组
void print_array(std::vector&lt;int&gt; &amp;a, const char *s)
&#123;
    printf(&quot;%s\n&quot;, s);
    vector&lt;int&gt;::iterator it;
    for (it = a.begin(); it != a.end(); ++it)
    &#123;
        printf(&quot;%d &quot;, *it);
    &#125;
    printf(&quot;\n&quot;);
&#125;

int main() &#123;
    //std::vector&lt;int&gt; array;
    //char num;
    //while(cin.get() != &#39;\n&#39;)
    //&#123;
    //    cin &gt;&gt; num;
    //    array.push_back(num);
    //&#125;

    vector&lt;int&gt; array&#123;1,3,4,2,5,7,6,8,9&#125;;
    print_array(array, &quot;input array:&quot;);

    //默认排序，从小到大
    std::sort(array.begin(), array.end());
    print_array(array, &quot;default sort:&quot;);

    //使用STL标准库提供的其它比较规则, 比如 greater&lt;T&gt;，从大到小
    std::sort(array.begin(), array.end(), std::greater&lt;int&gt;());
    print_array(array, &quot;std::greater&lt;T&gt; sort:&quot;);

    //自定义比较规则: 普通函数
    std::sort(array.begin(), array.end(), myComp);
    print_array(array, &quot;myComp sort:&quot;);

    //自定义比较规则: 类内运算符重载
    std::sort(array.begin(), array.end(), myCompOper());
    print_array(array, &quot;myCompOper sort:&quot;);

    //自定义比较规则: Lambda匿名函数
    std::sort(array.begin(), array.end(), [](int i, int j) &#123;return i &lt; j;&#125;);
    print_array(array, &quot;Lambda sort:&quot;);
</code></pre>
<p>​<br>        return 0;<br>    }</p>
<p>结果如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081715702.png" alt="image-20221208171536663"></p>
<h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p>
<p><strong>(1)普通快排</strong><br>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p>
<ul>
<li>如果S中的元素只有0个或1个，结束。</li>
<li>取S中的任何一个元素作为枢轴pivot。</li>
<li>将S分割为L、R两端，使L内的元素都小于等于pivot，R内的元素都大于等于pivot。 </li>
<li>对L、R递归执行上述过程。</li>
</ul>
<p>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称为median-of-three，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p>
<p>分割的方法通常采用两个迭代器head和tail，head从头端往尾端移动，tail从尾端往头端移动，当head遇到大于等于pivot的元素就停下来，tail遇到小于等于pivot的元素也停下来，若head迭代器仍然小于tail迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p>
<p><strong>(2)内省式排序 Introsort</strong><br>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 O(n2)。David R.Musser于1996年提出一种混合式排序算法：Introspective Sorting（内省式排序），简称IntroSort，其行为大部分与上面所说的median-of-three Quick Sort完全相同，但是当分割行为有恶化为二次方的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 O(nlgn)，又比一开始就使用堆排序来得好。</p>
<p>sort声明：</p>
<pre><code>#include &lt;algorithm&gt;
 
template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );
 
template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );
</code></pre>
<p>sort实现：</p>
<pre><code>template &lt;class _RandomAccessIter&gt;
inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123;
  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,
                 _LessThanComparable);
  if (__first != __last) &#123;
    __introsort_loop(__first, __last,
                     __VALUE_TYPE(__first),
                     __lg(__last - __first) * 2);
    __final_insertion_sort(__first, __last);
  &#125;
&#125;
</code></pre>
<p>__introsort_loop便是上面介绍的内省式排序，其第三个参数中所调用的函数__lg()便是用来控制分割恶化情况，求lg(n)（取下整），意味着快速排序的递归调用最多 2*lg(n) 层。<br>__lg()实现如下</p>
<pre><code>template &lt;class Size&gt;
inline Size __lg(Size n) &#123;
    Size k;
    for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k;
    return k;
&#125;
</code></pre>
<p>__introsort_loop实现：</p>
<ul>
<li>首先判断元素规模是否大于阀值__stl_threshold，__stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。</li>
<li>若元素规模大于__stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。</li>
<li>若没有超过递归调用深度，则调用函数__unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。</li>
<li>经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。</li>
</ul>
<p>递归上述过程，直到元素规模小于__stl_threshold，然后返回sort函数，对整个元素序列调用一次插入排序，此时序列中的元素已基本有序，所以插入排序也很快。至此，整个sort函数运行结束。</p>
<p>__introsort_loop代码：</p>
<pre><code>template &lt;class _RandomAccessIter, class _Tp, class _Size&gt;
void __introsort_loop(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Tp*,
                      _Size __depth_limit)
&#123;
  while (__last - __first &gt; __stl_threshold) &#123;
    if (__depth_limit == 0) &#123;
      partial_sort(__first, __last, __last);
      return;
    &#125;
    --__depth_limit;
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1))));
    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit);
    __last = __cut;
  &#125;
&#125;
</code></pre>
<p>__unguarded_partition()函数</p>
<pre><code>template &lt;class _RandomAccessIter, class _Tp&gt;
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, 
                                        _RandomAccessIter __last, 
                                        _Tp __pivot) 
&#123;
    while (true) &#123;
        while (*__first &lt; __pivot)
            ++__first;
        --__last;
        while (__pivot &lt; *__last)
            --__last;
        if (!(__first &lt; __last))
            return __first;
        iter_swap(__first, __last);
        ++__first;
    &#125;
&#125;
</code></pre>
<p>参考： 《STL源码剖析》–侯捷</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
