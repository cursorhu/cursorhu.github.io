<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/3/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/11/30/NVMe%E8%AE%BE%E5%A4%87%E7%9A%84Firmware%20Update%E5%85%A8%E6%A0%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EWindows%20Storport%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/30/NVMe%E8%AE%BE%E5%A4%87%E7%9A%84Firmware%20Update%E5%85%A8%E6%A0%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EWindows%20Storport%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">NVMe设备的Firmware Update全栈分析（一）：基于Windows Storport环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-30 17:41:00 / 修改时间：17:41:57" itemprop="dateCreated datePublished" datetime="2022-11-30T17:41:00+08:00">2022-11-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NVMe/" itemprop="url" rel="index"><span itemprop="name">NVMe</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update"><a href="#1-1-Windows-Storport-Driver环境下的NVMe设备Firmware-Update" class="headerlink" title="1.1 Windows Storport Driver环境下的NVMe设备Firmware Update"></a>1.1 Windows Storport Driver环境下的NVMe设备Firmware Update</h2><p>Windows系统下，NVMe设备的Firmware Update都是基于以下Microsoft API文档 ：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/upgrading-firmware-for-an-nvme-device">upgrading-firmware-for-an-nvme-device</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/04/18/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ARGB%E8%B0%83%E8%89%B2%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ARGB%E8%B0%83%E8%89%B2%E5%99%A8/" class="post-title-link" itemprop="url">Qt学习笔记：RGB调色器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-18 11:49:00" itemprop="dateCreated datePublished" datetime="2022-04-18T11:49:00+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-12 14:58:40" itemprop="dateModified" datetime="2022-12-12T14:58:40+08:00">2022-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文基于Qt官方示例<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/designer-quick-start.html#:~:text=%20Using%20Qt%20Designer%20involves%20four%20basic%20steps%3A,the%20slots%204%20Preview%20the%20form%20More%20"> A Quick Start to Qt Designer</a>, 实现自定义的slot函数，新增RGB色彩窗口显示色彩。</p>
<ul>
<li>本文源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/QtSampleTest/tree/master/1.rgbSlider">QtSampleTest&#x2F;1.rgbSlider</a></li>
<li>环境：基于Qt5.9 + Qt creater</li>
</ul>
<p>本文只记录项目过程中的注意事项，以及增量开发，其他部分参考Qt官方示例。</p>
<h2 id="1-UI部分"><a href="#1-UI部分" class="headerlink" title="1.UI部分"></a>1.UI部分</h2><ul>
<li>建立带UI的项目rgbSlider, 基于Qwidget生成默认自定义类名widget</li>
<li>双击widget.ui进入UI编辑</li>
</ul>
<p>UI 编辑模式下使用两种模式：widget编辑模式， slot&#x2F;signal编辑模式</p>
<ol>
<li><p>widget编辑模式如下：使用水平、网格布局<br>RGB数值控制部分，使用Label,  spinBox和scrollBar三种控件，按先竖直，后水平排列<br>RGB颜色显示部分，使用 graphicsView窗口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181201206.png"><br>注意调整布局的比例需要先选中，然后在layout属性调整<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181202783.png"></p>
</li>
<li><p>slot&#x2F;signal编辑模式<br>直接拖拽起始控件和目标控件，设置控件的信号和槽<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181203784.png"></p>
</li>
</ol>
<h2 id="2-自定义槽"><a href="#2-自定义槽" class="headerlink" title="2.自定义槽"></a>2.自定义槽</h2><p>graphicsView窗口预期效果是：只要调整RGB数值，自动显示对应的颜色<br>UI界面不能设置控件信号触发自定义槽，需要在代码中实现信号和槽的连接。</p>
<ol>
<li>右键转到graphicsView窗口的槽函数，自定义为 <code>Widget::on_rgbChanged()</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181400431.png"><br>函数实现如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;QColor&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;QPalette&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Widget::on_rgbChanged()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> QPalette pal = QPalette();</span><br><span class="line"></span><br><span class="line"> QColor color;</span><br><span class="line"></span><br><span class="line"> //分别设置R,G,B,透明度</span><br><span class="line"></span><br><span class="line"> color.setRgb(ui-&gt;spinBoxRed-&gt;value(), ui-&gt;spinBoxGreen-&gt;value(), ui-&gt;spinBoxBlue-&gt;value(), 255);</span><br><span class="line"></span><br><span class="line"> //QPalette::Base</span><br><span class="line"></span><br><span class="line"> //Used mostly as the background color for text entry widgets, It is usually white or another light color.</span><br><span class="line"></span><br><span class="line"> pal.setColor(QPalette::Base, color);</span><br><span class="line"></span><br><span class="line"> ui-&gt;graphicsView-&gt;setPalette(pal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在UI基础上使用控件对象的方法，只需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;控件名-&gt;控件的方法</span><br></pre></td></tr></table></figure>

<p>注意<code>setColor</code>可以给不同图层上色，这里使用<code>QPalette::Base</code>，而不能是<code>QPalette::Window</code>或<code>QPalette::Background</code></p>
<p>代码设置信号与槽, 注意，手动设置的代码要在<code>ui-&gt;setupUi(this);</code>的后面添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line"></span><br><span class="line"> QWidget(parent),</span><br><span class="line"></span><br><span class="line"> ui(new Ui::Widget)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxRed, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxGreen, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line"> connect(ui-&gt;spinBoxBlue, SIGNAL(valueChanged(int)), this, SLOT(on_rgbChanged()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3.测试效果"></a>3.测试效果</h2><ul>
<li>拖动滑块，对应数值会更新，颜色同步更新</li>
<li>修改数值，对应滑块更新，颜色更新<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202204181410181.png"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/03/25/Linux%20MMC%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84UHS-II%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/25/Linux%20MMC%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84UHS-II%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">Linux MMC框架下的UHS-II驱动调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-25 11:21:00" itemprop="dateCreated datePublished" datetime="2022-03-25T11:21:00+08:00">2022-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-09 20:25:56" itemprop="dateModified" datetime="2023-08-09T20:25:56+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Linux-MMC-框架现状"><a href="#1-Linux-MMC-框架现状" class="headerlink" title="1. Linux MMC 框架现状"></a>1. Linux MMC 框架现状</h2><p>Linux MMC driver是支持包括SD卡，eMMC卡等等，属于MultiMediaCard设备和接口的驱动<br>其源码路径位于Kernel source code的drivers&#x2F;mmc路径, 头文件位于include&#x2F;linux&#x2F;mmc<br>mmc源码分为core&#x2F;host两层，是为了解耦：</p>
<ul>
<li>通用的SD&#x2F;eMMC流程(core)</li>
<li>具体的硬件操作流程(host)，在此层又可分为通用的SDHCI框架和非SDHCI框架，各eMMC&#x2F;SD host厂商实现最底层driver时，可以遵循SDHCI框架下的API, 间接实现core层定义的方法(driver称为operations), 也可以不遵循SDHCI框架，直接实现core层定义的方法。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301058425.png"></li>
</ul>
<p>本文重点关注mmc框架对SD卡驱动的支持</p>
<h3 id="1-1-SD卡的类型概述"><a href="#1-1-SD卡的类型概述" class="headerlink" title="1.1 SD卡的类型概述"></a>1.1 SD卡的类型概述</h3><p>SD卡可以分为三种类型：<br>UHS-I, UHS-II, SD express</p>
<p>详细信息参考<a target="_blank" rel="noopener" href="https://www.sdcard.org/">https://www.sdcard.org</a></p>
<ul>
<li>Physical Layer Specification Ver.7.10 (从各层描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD Host Controller Specification Ver7.0 (从host控制器角度，描述SD 7.0, SD 4.0, 以及更早版本SD的规范)</li>
<li>SD_Specifications_Part_1_UHS_II_Addendum(描述SD UHSII的附录规范)</li>
</ul>
<p>UHS即Ultra High Speed, express也表示高速，这三代SD卡的读写速度是依次增加，参考下图：</p>
<ul>
<li>UHSI：50~104MB&#x2F;s</li>
<li>UHSII: 156~624MB&#x2F;s</li>
<li>SD express: 985MB&#x2F;s</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301119947.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301120184.png"></p>
<h3 id="1-2-Linux-MMC框架对SD卡的支持"><a href="#1-2-Linux-MMC框架对SD卡的支持" class="headerlink" title="1.2 Linux MMC框架对SD卡的支持"></a>1.2 Linux MMC框架对SD卡的支持</h3><p>基本概念：只有mmc框架的core层支持某种SD模式，host层才能实现这种模式；如果core层都不支持，只能厂商自己开发core层，以patch补丁的方式发布。</p>
<p>core层对于上述三种SD模式的支持：</p>
<ul>
<li>Linux kernel 5.11 以前，只支持UHS-I及其更低速度的legacy-SD模式</li>
<li>Linux kernel 5.11 开始，在core层添加了SD express的支持</li>
<li>目前没有UHS-II的支持，只有提交待审核的，参考：<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/?q=Jason%20Lai">lore.kernel.org&#x2F;Jason Lai&#x2F;patch</a></li>
</ul>
<p>host层对于上述三种SD模式的支持：</p>
<ul>
<li>UHS-I: 基本host目录的大多数SD厂商驱动都支持，很多符合sdhci框架</li>
<li>SD express: Realtek基于Linux kernel 5.11的core层API, 实现了 驱动的host底层部分，参考kernel的host&#x2F;rtsx_pci_sdmmc.c, 其没有使用SDHCI框架。</li>
<li>UHS-II: 只有以patch方式实现的，参考<a target="_blank" rel="noopener" href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a>，其实现了core&#x2F;host-sdhci&#x2F;host vendor多个层次的UHS-II支持。</li>
</ul>
<p>综上所述，本文参考uhs2-gl8755 patch，实现自己的SD UHSII driver。</p>
<h2 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2. 编译过程"></a>2. 编译过程</h2><p>本节描述编译mmc driver module和整个kernel的过程，同时描述中间踩的坑。</p>
<h3 id="2-1-直接编译整个Kernel-带UHS-II-Patch"><a href="#2-1-直接编译整个Kernel-带UHS-II-Patch" class="headerlink" title="2.1 直接编译整个Kernel(带UHS-II Patch)"></a>2.1 直接编译整个Kernel(带UHS-II Patch)</h3><p>安装Linux Ubuntu 20版本，Ubuntu环境下载和解压待编译的整个Linux kernel 源码：<a target="_blank" rel="noopener" href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755/"># linux-uhs2-gl9755</a></p>
<p>注意：一定要在Linux环境下解压待编译源码，不能在windows下解压再拷到Linux编译，因为源码中有些大小写不同的同名文件，例如net&#x2F;netfilter的很多头文件。windows不区分大小，解压时写会让你替换或重命名，这些同名文件的内容不一样，所以不能替换或重命名，强行替换会导致编译Linux报错找不到相关文件。</p>
<ol>
<li>编译环境准备<br>gcc&#x2F;make等工具，都需要先安装build-essential等工具才能使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>遇到的问题:</li>
</ul>
<p>apt如果有依赖问题，建议apt手动安装，如果要特定版本，例如指定依赖libc6库版本为2.35-0ubuntu3，使用<code>apt install libc6=2.35-0ubuntu3</code>, 可以用apt policy libc6查看。</p>
<p>这里不建议sudo apt install aptitude（使用aptitude自动安装需要的依赖库版本），因为会导致make menuconfig出现&lt;sys&#x2F;types.h&gt;找不到的问题，这个问题的原因是libc6-dev未安装，必须用apt安装libc6-dev解决此问题。</p>
<ol start="2">
<li>配置，编译和安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd linux-uhs2-gl9755-v3-patch #进入待编译Kernel源码</span><br><span class="line">make menuconfig #配置内核，生成.config文件</span><br><span class="line">make -j4 #以4线程编译内核，等同于make bzImage，make modules</span><br><span class="line">make modules_install #安装各Driver模块</span><br><span class="line">make install #安装内核(包括更新模块信息)</span><br></pre></td></tr></table></figure>
<p>编译完成后会自动update-grub, 重启后选择编译好的kernel版本启动。</p>
<p>也可以设置默认启动的kernel，编辑&#x2F;etc&#x2F;default&#x2F;grub的<code>GRUB_DEFAULT=&quot;1&gt;X&quot;</code>, 其中1表示从advanced选项启动，X表示从哪个kernel启动(0 based)，例如下图如果默认要从5.19启动，X设置为0，默认从5.8.0-rc4启动，X设置为6.<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202208171414943.png"><br>配置完毕必须要update-grub重启生效</p>
<ul>
<li><p>遇到的问题</p>
<p>make有canonical-certs.pem证书问题：修改.config，取消证书要求：CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;””，CONFIG_SYSTEM_REVOCATION_KEYS&#x3D;””</p>
</li>
</ul>
<ol start="3">
<li><p>查看内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r #查看当前运行的kernel版本</span><br><span class="line">cat Makefile #查看待编译kernel源码的内核版本</span><br></pre></td></tr></table></figure>
<p>以linux-uhs2-gl9755-v3-patch为例，其根目录Makefile如下，表示kernel源码版本为 5.8.0-rc4<br>编译完成重启后应该选择5.8.0-rc4启动，进入桌面后用<code>uname -r</code>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VERSION = 5</span><br><span class="line">PATCHLEVEL = 8</span><br><span class="line">SUBLEVEL = 0</span><br><span class="line">EXTRAVERSION = -rc4</span><br><span class="line">NAME = Kleptomaniac Octopus</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译报错记录<br>(1) 生成vmlinux Image时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to generate BTF for vmlinux  </span><br><span class="line">Try to disable CONFIG_DEBUG_INFO_BTF</span><br></pre></td></tr></table></figure>
<p>修改Kernel源码根目录的.config文件，CONFIG_DEBUG_INFO_BTF&#x3D;n 关闭此选项</p>
</li>
</ol>
<p>​      (2) 编译完成，但运行新kernel时报错<code>out of memory</code><br>解决办法：裁剪module大小，编译模块时使用 <code>make  INSTALL_MOD_STRIP=1 modules_install</code>，.ko被编译时会缩减非必要的debug信息。</p>
<h3 id="2-2-合并UHSII-patch后再编译整个Kernel"><a href="#2-2-合并UHSII-patch后再编译整个Kernel" class="headerlink" title="2.2 合并UHSII patch后再编译整个Kernel"></a>2.2 合并UHSII patch后再编译整个Kernel</h3><p>官方kernel源码可以到<a target="_blank" rel="noopener" href="https://www.kernel.org/">kernel.org</a>下载</p>
<p>合并UHSII patch，仅涉及到mmc模块的代码，如果差异不大可以将linux-uhs2-gl9755-v3-patch的drivers&#x2F;mmc和include头文件直接拷到待编译kernel的drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc。</p>
<p>如果是手动合并UHS-II patch，需要考虑以下部分：</p>
<ul>
<li>源码，包括drivers&#x2F;mmc和include&#x2F;linux&#x2F;mmc</li>
<li>Makefile, 包括drivers&#x2F;mmc&#x2F;core和drivers&#x2F;mmc&#x2F;host</li>
<li>Kconfig, 包括drivers&#x2F;mmc，及其子目录core和host</li>
</ul>
<p>具体合并方法参考《Linux设备驱动开发详解》<br>合并完后，Kernel编译流程和上节相同</p>
<h3 id="2-3-单独编译MMC模块"><a href="#2-3-单独编译MMC模块" class="headerlink" title="2.3 单独编译MMC模块"></a>2.3 单独编译MMC模块</h3><p>一般的驱动开发，都是可以单独编译成module模块，然后用rmmod和insmod替换原系统的模块</p>
<p>但是UHS-II patch涉及到mmc&#x2F;core层的改动，而core是build-in的，不能作为模块编译，因此只能编译整个kernel。以后如果只修改host层的代码，可以将mmc&#x2F;host单独编译为module后安装。</p>
<p>待编译kernel目录是<code>~/linux-5.8-rc4</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#编译模块，&quot;M=&quot;指定待编译源码，编译完拷贝.ko到&quot;-C&quot;指定的目录，此目录为系统存放模块的目录</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc</span><br><span class="line"></span><br><span class="line">#安装模块</span><br><span class="line">make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc modules_install</span><br><span class="line">	</span><br><span class="line">#清除模块,包括.o和.ko文件</span><br><span class="line">sudo make -C /lib/modules/`uname -r`/build M=~/linux-5.8-rc4/drivers/mmc clean</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/kbuild/modules.html"># Building External Modules</a></p>
<p>注意，<code>make xxx modules_install</code>是不能让模块自动加载的，只是安装到了&#x2F;lib&#x2F;modules位置。使用<code>modinfo</code>查看模块信息，似乎是使用了&#x2F;lib&#x2F;modules下的，但没有实际加载和生效。<br>要加载模块，两种方法：</p>
<ol>
<li>rmmod&#x2F;insmod 手动替换, 参考下一节</li>
<li>make modules_install 之后再 make install，更新整个kernel, 此后外部模块才会被内核自动加载（通常使用这种方式）</li>
</ol>
<h3 id="2-4-手动替换MMC模块"><a href="#2-4-手动替换MMC模块" class="headerlink" title="2.4 手动替换MMC模块"></a>2.4 手动替换MMC模块</h3><h4 id="2-4-1-UHS-II相关模块的依赖关系"><a href="#2-4-1-UHS-II相关模块的依赖关系" class="headerlink" title="2.4.1 UHS-II相关模块的依赖关系"></a>2.4.1 UHS-II相关模块的依赖关系</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301640662.png"></p>
<p>可以从mmc&#x2F;host的Kconfig得知依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config MMC_SDHCI_PCI</span><br><span class="line">	tristate &quot;SDHCI support on PCI bus&quot;</span><br><span class="line">	depends on MMC_SDHCI &amp;&amp; PCI</span><br><span class="line">	select MMC_SDHCI_UHS2</span><br><span class="line">	</span><br><span class="line">config MMC_SDHCI_UHS2</span><br><span class="line">	tristate &quot;UHS2 support on SDHCI controller&quot;</span><br><span class="line">	depends on MMC_SDHCI</span><br></pre></td></tr></table></figure>

<p>使用<code>lsmod</code>可以得知module依赖关系，如下图，sdhci_uhs2被sdhci_pci引用1次, sdhci被sdhci_uhs2和sdhci_pci引用2次<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645712.png"><br><code>modinfo</code>可以得知已加载module的.ko路径<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203301645737.png"></p>
<h4 id="2-4-2-手动卸载和装载module"><a href="#2-4-2-手动卸载和装载module" class="headerlink" title="2.4.2 手动卸载和装载module"></a>2.4.2 手动卸载和装载module</h4><p>卸载和装载都要按依赖顺序处理，shell脚本如下.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">sudo rmmod sdhci_pci</span><br><span class="line">sudo rmmod sdhci_uhs2</span><br><span class="line">sudo rmmod sdhci</span><br><span class="line"></span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-uhs2.ko</span><br><span class="line">sudo insmod /lib/modules/`uname -r`/build/drivers/mmc/host/sdhci-pci.ko </span><br></pre></td></tr></table></figure>

<h2 id="3-调试过程"><a href="#3-调试过程" class="headerlink" title="3. 调试过程"></a>3. 调试过程</h2><h3 id="3-1-调试工具"><a href="#3-1-调试工具" class="headerlink" title="3.1 调试工具"></a>3.1 调试工具</h3><ol>
<li>printk<br>printk是很常用的driver调试手段，配合dmesg查看kernel log可以定位常见问题。<br>printk如何开启不同打印级别，参考<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/core-api/printk-basics.html"># Message logging with printk</a></li>
</ol>
<p>例如，使用<code>dmesg -n 6</code>开启KERN_INFO级别，然后在driver中添加pr_info()作为info打印, 在dmesg中查看打印log。</p>
<p>注意KERN_DEBUG比较特殊，不仅要<code>dmesg -n 7</code>开启, 还需要在driver module的makefile添加Debug CFLAGS, 有两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#该Makefile相关模块全部启用debug</span><br><span class="line">EXTRA_CFLAGS += -DDEBUG</span><br><span class="line"></span><br><span class="line">#指定模块启用debug</span><br><span class="line">CFLAGS-xxx-mmc += -DDEBUG</span><br></pre></td></tr></table></figure>
<p>示例：使用<code>pr_info(“enter %s\n”, __FUNCTION__);</code> 打印函数调用流程</p>
<ol start="2">
<li>dmesg<br>示例参考 <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/how-to-use-the-dmesg-command-on-linux/"># How to use the dmesg Command on Linux</a><br>比较常用的有：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg</span><br><span class="line">sudo dmesg -c </span><br><span class="line">sudo dmesg | head -100</span><br><span class="line">sudo dmesg | tail</span><br><span class="line">sudo dmesg | xxx</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.vscode<br>vscode比vim&#x2F;gedit更方便直接改代码，用.deb安装容易失败，推荐命令行安装方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#更新相关microsoft源</span><br><span class="line">wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] \</span><br><span class="line">https://packages.microsoft.com/repos/code stable main&quot; &gt; /etc/apt/sources.list.d/vscode.list&#x27;</span><br><span class="line"></span><br><span class="line">rm -f packages.microsoft.gpg</span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install code</span><br></pre></td></tr></table></figure>
<h3 id="3-2-UHSII调试"><a href="#3-2-UHSII调试" class="headerlink" title="3.2 UHSII调试"></a>3.2 UHSII调试</h3><ol>
<li><p>模块加载初始化过程中dmesg显示直接dump<br>基本是空指针问题，例如：</p>
<ul>
<li>只编译UHSII host 模块，而不编译kernel的core层，insmod host模块时就会dump, 因为core层相关API不存在。</li>
<li>获取相关数据结构方法不对导致空指针<br>例如获取slot要使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  struct sdhci_pci_slot *slot = sdhci_priv(host);</span><br><span class="line"></span><br><span class="line">static inline void *sdhci_priv(struct sdhci_host *host)&#123;</span><br><span class="line">   return host-&gt;private;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
而host-&gt;private实际指向sdhci_host结构体的最后定义的如下0长度数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned long private[] ____cacheline_aligned;</span><br></pre></td></tr></table></figure>
参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct"># <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17931491/explanation-on-private-variable-in-c-struct">Explanation on private variable in c struct</a></a><br>基本含义是可以获取结构体外部的数据，而host指针本身确实属于slot结构体sdhci_pci_slot的一部分，所以host-&gt;private能访问到slot。</li>
</ul>
</li>
<li><p>贴一段dmesg log，包含UHSII初始化过程直到最后一步GO_DORMANT fail<br>具体流程参考UHSII spec:  SD_Specifications_Part_1_UHS_II_Addendum</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">[  522.171631] sdhci_uhs2 [sdhci_uhs2_do_detect_init()]: sdhci_uhs2_do_detect_init: begin UHS2 init.</span><br><span class="line">[  522.171632] enter sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171632] exit sdhci_pci_o2_pre_detect_init.</span><br><span class="line">[  522.171835] sdhci_uhs2 [sdhci_uhs2_interface_detect()]: mmc0: UHS2 Lane synchronized in UHS2 mode, PHY is initialized.</span><br><span class="line">[  522.171855] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171856] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171856] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 0</span><br><span class="line">[  522.171858] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171865] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.171874] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.171885] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.171887] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x292</span><br><span class="line">[  522.171887] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=6</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Begin DEVICE_INIT, header=0x80, arg=0x292, payload=0x8808.</span><br><span class="line">[  522.171888] [uhs2_dev_init()]: Sending DEVICE_INIT. Count = 1</span><br><span class="line">[  522.171888] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.171894] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188184] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188205] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188254] [uhs2_dev_init()]: CF is set, device is initialized!</span><br><span class="line">[  522.188257] [uhs2_enum()]: Begin ENUMERATE, header=0x80, arg=0x392, payload=0xf0.</span><br><span class="line">[  522.188260] uhs2_cmd_assemble: uhs2_cmd: header=0x80 arg=0x392</span><br><span class="line">[  522.188262] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=8</span><br><span class="line">[  522.188266] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188277] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x800 is set to UHS2 CMD register.</span><br><span class="line">[  522.188290] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188308] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188318] [uhs2_enum()]: id_f = 6, id_l = 6.</span><br><span class="line">[  522.188320] [uhs2_enum()]: Enumerate Cmd Completed. No. of Devices connected = 1</span><br><span class="line">[  522.188322] [uhs2_config_read()]: INQUIRY_CFG: read Generic Caps.</span><br><span class="line">[  522.188324] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x10.</span><br><span class="line">[  522.188326] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x10</span><br><span class="line">[  522.188328] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188331] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188342] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188363] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188392] mmc0: req done (CMD0): 0: 00010100 00000000 00000000 00000000</span><br><span class="line">[  522.188398] [uhs2_config_read()]: Device Generic Caps (0-31) is: 0x10100.</span><br><span class="line">[  522.188399] [uhs2_config_read()]: INQUIRY_CFG: read PHY Caps.</span><br><span class="line">[  522.188401] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x220.</span><br><span class="line">[  522.188404] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x220</span><br><span class="line">[  522.188410] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188415] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188427] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188447] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188476] mmc0: req done (CMD0): 0: 00008000 00000080 00000000 00000000</span><br><span class="line">[  522.188482] [uhs2_config_read()]: Device PHY Caps (0-31) is: 0x8000.</span><br><span class="line">[  522.188484] [uhs2_config_read()]: Device PHY Caps (32-63) is: 0x80.</span><br><span class="line">[  522.188487] [uhs2_config_read()]: INQUIRY_CFG: read LINK-TRAN Caps.</span><br><span class="line">[  522.188492] [uhs2_config_read()]: Begin INQUIRY_CFG, header=0x86, arg=0x420.</span><br><span class="line">[  522.188499] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x420</span><br><span class="line">[  522.188504] uhs2_cmd_assemble:           payload_len=0 packet_len=4 resp_len=0</span><br><span class="line">[  522.188507] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188516] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x400 is set to UHS2 CMD register.</span><br><span class="line">[  522.188554] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188582] mmc0: req done (CMD0): 0: 20024000 00000000 00000000 00000000</span><br><span class="line">[  522.188601] [uhs2_config_read()]: Device LINK-TRAN Caps (0-31) is: 0x20024000.</span><br><span class="line">[  522.188604] [uhs2_config_read()]: Device LINK-TRAN Caps (32-63) is: 0x0.</span><br><span class="line">[  522.188605] [uhs2_config_write()]: SET_COMMON_CFG: write Generic Settings.</span><br><span class="line">[  522.188607] [uhs2_config_write()]: Both Host and device support 2L-HD.</span><br><span class="line">[  522.188609] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0</span><br><span class="line">[  522.188611] [uhs2_config_write()]: UHS2 write Generic Settings 00000000 00000000</span><br><span class="line">[  522.188613] [uhs2_config_write()]: flags=00000005 dev_prop.n_lanes_set=0 host_caps.n_lanes_set=0</span><br><span class="line">[  522.188615] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188618] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188620] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188632] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188650] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188678] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188684] [uhs2_config_write()]: SET_COMMON_CFG: PHY Settings.</span><br><span class="line">[  522.188686] [uhs2_config_write()]: set dev_prop.speed_range_set to SPEED_B</span><br><span class="line">[  522.188689] [uhs2_config_write()]: UHS2 SET PHY Settings  40000000 04000000</span><br><span class="line">[  522.188691] [uhs2_config_write()]: host-&gt;flags=00000015 dev_prop.speed_range_set=1</span><br><span class="line">[  522.188693] [uhs2_config_write()]: dev_prop.n_lss_sync_set=4 host_caps.n_lss_sync_set=4</span><br><span class="line">[  522.188694] [uhs2_config_write()]: dev_prop.n_lss_dir_set=0 host_caps.n_lss_dir_set=8</span><br><span class="line">[  522.188696] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xaa0</span><br><span class="line">[  522.188698] [uhs2_config_write()]: 		payload[0]=0x40000000 payload[1]=0x4000000</span><br><span class="line">[  522.188700] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xaa0</span><br><span class="line">[  522.188703] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=4</span><br><span class="line">[  522.188705] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188715] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188730] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188741] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188746] [uhs2_config_write()]: SET_COMMON_CFG: LINK-TRAN Settings.</span><br><span class="line">[  522.188748] [uhs2_config_write()]: Begin SET_COMMON_CFG header=0x86 arg=0xca0</span><br><span class="line">[  522.188750] [uhs2_config_write()]: 		payload[0]=0x80320 payload[1]=0x1000000</span><br><span class="line">[  522.188752] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0xca0</span><br><span class="line">[  522.188754] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=0</span><br><span class="line">[  522.188756] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188766] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188780] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188808] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188813] [uhs2_config_write()]: SET_COMMON_CFG: Set Config Completion.</span><br><span class="line">[  522.188815] [uhs2_config_write()]: Begin SET_COMMON_CFG, header=0x86, arg=0x8a0, payload[0] = 0x0.</span><br><span class="line">[  522.188817] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x8a0</span><br><span class="line">[  522.188819] uhs2_cmd_assemble:           payload_len=8 packet_len=12 resp_len=5</span><br><span class="line">[  522.188821] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.188831] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0xc00 is set to UHS2 CMD register.</span><br><span class="line">[  522.188842] mmc0: sdhci: IRQ status 0x00000001</span><br><span class="line">[  522.188855] mmc0: req done (CMD0): 0: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.188862] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 0.</span><br><span class="line">[  522.201612] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 3.</span><br><span class="line">[  522.201614] sdhci_uhs2 [sdhci_uhs2_do_set_reg()]: Begin sdhci_uhs2_set_reg, act 2.</span><br><span class="line">[  522.201616] [uhs2_go_dormant()]: Begin GO_DORMANT_STATE, header=0x86, arg=0x192, payload=0x0.</span><br><span class="line">[  522.201617] uhs2_cmd_assemble: uhs2_cmd: header=0x86 arg=0x192</span><br><span class="line">[  522.201618] uhs2_cmd_assemble:           payload_len=4 packet_len=8 resp_len=0</span><br><span class="line">[  522.201619] mmc0: starting CMD0 arg 00000000 flags 00000000</span><br><span class="line">[  522.201626] sdhci_uhs2 [sdhci_uhs2_send_command()]: 0x8c0 is set to UHS2 CMD register.</span><br><span class="line">[  522.218633] mmc0: sdhci: IRQ status 0x00008000</span><br><span class="line">[  522.218636] sdhci_uhs2 [sdhci_uhs2_irq()]: *** mmc0 got UHS2 interrupt: 0x00010000</span><br><span class="line">[  522.218651] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218652] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218652] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] enter sdhci_pci_o2_reset.</span><br><span class="line">[  522.218654] enter o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218654] exit o2_uhs2_reset_sd_tran.</span><br><span class="line">[  522.218659] mmc0: req done (CMD0): -110: 00000000 00000000 00000000 00000000</span><br><span class="line">[  522.218666] mmc0: uhs2_go_dormant: UHS2 CMD send fail, err= 0xffffff92!</span><br><span class="line">[  522.218668] mmc0: uhs2_change_speed: UHS2 GO_DORMANT_STATE fail, err= 0xfffffffb!</span><br><span class="line">[  522.218669] mmc0: UHS2 uhs2_change_speed() fail!</span><br></pre></td></tr></table></figure>
<p>含义是UHSII初始化接近完成，切换到高速的RangeB时，GO_DORMANT_STATE命令未完成，超时。<br>解决办法：先绕过RangeB模式，使用RangA(较低速度的UHSII模式)，为此要从一开始就上报host不支持RangeB。<br>修改mmc&#x2F;host&#x2F;sdhci-uhs2.c中的上报host能力(capability)的speed_range为不支持RangeB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//mmc-&gt;uhs2_caps.speed_range =(caps_phy &amp; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_MASK) &gt;&gt; SDHCI_UHS2_HOST_CAPS_PHY_RANGE_SHIFT;</span><br><span class="line"></span><br><span class="line">mmc-&gt;uhs2_caps.speed_range = 0; //Range-A</span><br></pre></td></tr></table></figure>
<p>重新编译安装module后，UHSII初始化正常，读写正常。</p>
</li>
</ol>
<p>事实上此GO_DORMANT fail issue的根本原因是兼容性问题：<br>UHSII初始化流程中，SD host侧对lane speed的配置最好在卡处在dormant状态下进行，host侧提高速度（从Range-A提高到RangeB）以后，卡侧在退出dormant状态时重新配置速度，和host速度匹配。<br>如果host侧修改lane speed时间点错误，有的SD卡来不及反应，不能同步速度，所以GO_DORMANT fail；而有的SD 卡性能好，随时同步host侧的速度，没有此issue。</p>
<p>另外有的Issue和硬件特性相关，例如上电需要等待一定时间以后，才能启动UHSII设备初始化，这个等待时间取决于SD host厂商的硬件特性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/03/09/python%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/09/python%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">python使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-09 19:12:00" itemprop="dateCreated datePublished" datetime="2022-03-09T19:12:00+08:00">2022-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-12 15:03:14" itemprop="dateModified" datetime="2022-12-12T15:03:14+08:00">2022-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Python使用正则表达式示例"><a href="#Python使用正则表达式示例" class="headerlink" title="Python使用正则表达式示例"></a>Python使用正则表达式示例</h2><p>Python的正则表达式比较全面的教程，参考<a target="_blank" rel="noopener" href="https://www.programiz.com/python-programming/regex"># Python RegEx</a></p>
<p>使用背景：芯片ATE测试中，不同ATE平台的测试模式文件格式有不同，需要匹配字符串并按特定转换<br>转换前：</p>
<blockquote>
<p>Pattern “pll_dll_100m_test” {<br>waveform_start:<br>W pll_dll_100m_wft;</p>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>转后后：</p>
<blockquote>
<p>&#x2F;&#x2F;Enter PLL&#x2F;DLL Mode<br>V {pll_dll_100m_group &#x3D; 0 0 1 0 0 1 1 0 X X ;} W pll_dll_100m_wft;<br>V {pll_dll_100m_group &#x3D; 0 1 1 0 0 1 1 0 X X ;}</p>
</blockquote>
<p>规则：将以“W_xxx”的字符串放到下一个以“V_xxx”的字符串后面</p>
<p>利用python正则匹配，配合读取文件到字符串数组，实现如下转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">infile_name = <span class="built_in">input</span>(<span class="string">&quot;Please input the name of file in current directory to convert: &quot;</span>)</span><br><span class="line">name_flag = infile_name.find(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> name_flag == -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file name error, need input the suffix of file name&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(infile_name):</span><br><span class="line">        outfile_name = infile_name[<span class="number">0</span>:name_flag] + <span class="string">&quot;_updated&quot;</span> + infile_name[name_flag:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no such file!&quot;</span>)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">infile = <span class="built_in">open</span>(infile_name, <span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(outfile_name, <span class="string">&quot;w&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lines = infile.readlines()</span><br><span class="line">infile.close()</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">    str_obj = re.match(<span class="string">&#x27;[\s]*W[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;W ...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        temp_index = index</span><br><span class="line">        temp_str = str_obj.group()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_obj = re.match(<span class="string">&#x27;[\s]*V[\s].*&#x27;</span>, lines[index]) <span class="comment">#match the &quot;V ...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> str_obj != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                lines[temp_index] = <span class="string">&#x27;\n&#x27;</span> <span class="comment">#clear last &quot;W ...&quot;</span></span><br><span class="line">                lines[index] = str_obj.group() + <span class="string">&#x27; &#x27;</span> + temp_str + <span class="string">&#x27;\n&#x27;</span> <span class="comment">#add the &quot;W ...&quot; from &quot;V ...&quot; end</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">outfile.writelines(lines)</span><br><span class="line">outfile.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;outputfile is &quot;</span> + outfile_name)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Please press Enter key to exit&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的W和V前面加了额外的匹配项：<code>[\s]*</code>，是因为文件存在不可见的回车换行等引起，如果不加匹配不到</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/02/28/%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84Markdown%E5%86%99%E4%BD%9C%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%EF%BC%9AObsidian+PicGo+Hexo+Github/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84Markdown%E5%86%99%E4%BD%9C%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%EF%BC%9AObsidian+PicGo+Hexo+Github/" class="post-title-link" itemprop="url">搭建高可移植的Markdown写作和博客环境：Obsidian+PicGo+Hexo+Github</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 15:04:18" itemprop="dateCreated datePublished" datetime="2022-02-28T15:04:18+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-17 14:23:39" itemprop="dateModified" datetime="2022-05-17T14:23:39+08:00">2022-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/markdown/" itemprop="url" rel="index"><span itemprop="name">markdown</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0-背景"><a href="#0-背景" class="headerlink" title="0.背景"></a>0.背景</h2><p>写技术笔记并发布博客，通常有以下方式：</p>
<ul>
<li>第三方平台CSDN&#x2F;cnblogs，最简单但是最不可控，例如我写过一篇如何使用shadow-sock，直接被删掉，各种广告也是技术洁癖症不能忍的。</li>
<li>使用云服务器自建Leanote博客系统，我用过几年，最大缺点是服务器续费太贵，且文章数据存在数据库很难导出，优点是自建的Leanote写作发布一体化体验极好。</li>
<li>使用github+picgo+hexo， github作为图床和博客的云服务，picgo用于建立图床通道，hexo用于发布博客。缺点是github访问慢，用开源CDN可以很好解决；优点是全部免费，数据可移植(图片链接都在github图床)，可长期使用（只要github不倒闭不锁区）</li>
</ul>
<p>最终我选择github+picgo+hexo方案。<br>为什么不用gitee: gitee上传图片限制1M, github有25M。有了CDN, github的速度也不是问题</p>
<p>现在只需要确定Markdown编辑器</p>
<p>VSCode加Markdown插件试过，体验并不完美<br><a target="_blank" rel="noopener" href="https://www.typora.io/">Typora</a>是很不错的选择，除了收费<br><a target="_blank" rel="noopener" href="https://obsidian.md/">Obsidian</a>免费且优雅：</p>
<ul>
<li>支持动态渲染，即写出的Markdown语句自动显示预览</li>
<li>支持各种快捷键，无需手动输入Markdown语法格式（<a target="_blank" rel="noopener" href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法</a>）。比如标题，链接，列表，引用，可以设置标准的Markdown快捷键。</li>
<li>支持关联PicGo实现粘贴图片即上传到云端图床，这一点对于写作体验和文章的可迁移性很重要</li>
<li>特色的Zettelkasten笔记管理方法，本文不描述这部分，参考<a target="_blank" rel="noopener" href="https://sspai.com/post/62414#!">玩转 Obsidian 01：打造知识循环利器</a></li>
</ul>
<h2 id="1-搭建可移植的Markdown写作环境"><a href="#1-搭建可移植的Markdown写作环境" class="headerlink" title="1. 搭建可移植的Markdown写作环境"></a>1. 搭建可移植的Markdown写作环境</h2><p>Markdown文档本身是可移植的，但是其图片资源不是, 因为图片不是以二进制嵌入文档，而只是个图片地址的链接。</p>
<p>如果只是在本地写写Markdown，完全不需要考虑图片的可移植，只需要存本地固定路径即可。<br>如果想在本地写Markdown，且这个文档拿到别的机器，或者放到博客论坛发布，别人都可以看到图片，就要一个云端的图片存储服务，即图床。</p>
<p>本节讲如何实现一个“一处写作，到处可见”的Markdown写作环境，并优化工具设置，让写作顺滑流程</p>
<h3 id="1-1-Github-PicGo搭建图床"><a href="#1-1-Github-PicGo搭建图床" class="headerlink" title="1.1 Github+PicGo搭建图床"></a>1.1 Github+PicGo搭建图床</h3><p>完整流程参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/yefcion/article/details/88412025">PicGo + GitHub 搭建个人图床工具</a></p>
<p>流程包含以下部分：</p>
<ul>
<li>一个public的Github仓库，用来存放文章链接的图片，注意单仓库最大容量1GB。</li>
<li>一个personal access token，用于PicGo免密访问github实现自动上传图片</li>
<li>一个图片上传工具：PicGo及其插件，用它上连Github图床仓库，下连本地markdown编辑器，实现“图片粘贴即上传”</li>
<li>一个CDN(推荐，很好用)：使用开源CDN jsdelivr加速Github访问，避免因访问速度造成图片上传失败</li>
</ul>
<p>最终我的配置如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281014786.png"></p>
<p>单元测试：<br>手动上传本地图片，如果上传成功，且图片可预览，则功能正常<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024870.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281024344.png"></p>
<p>遇到的坑：<br>仓库名必须填&lt;用户名&gt;&lt;仓库名&gt;，不是完整的http或git仓库链接！否则上传图片error404</p>
<p>PicGo支持log调试，参考：<br><a target="_blank" rel="noopener" href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html"><a target="_blank" rel="noopener" href="https://www.shopee6.com/web/web-tutorial/picgo-github-fail.html">PicGo上传图片到GitHub总是失败的特殊解决办法</a></a></p>
<p>2022&#x2F;5&#x2F;17更新：<br>最近发现jsdelivr在大陆挂了，那么只能放弃使用CDN, 直接使用github图床的raw链接</p>
<p>将Picgo默认图床路径从jsdelivr的<br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D@master">https://cdn.jsdelivr.net/gh/账户名/图床仓库名@master</a><br>改为：<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/%E8%B4%A6%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D/master">https://raw.githubusercontent.com/账户名/图床仓库名/master</a></p>
<p>对于已发布的博客的图床链接，直接用VSCode全局查找替换以上前缀即可，后面的图片id是不变的。</p>
<p><strong>如何删除Github图床的图片：</strong><br>PicGo默认的Github图床不能通过相册删除github仓库的图片，需要使用第三方插件github-plus，建议作为默认图床工具，支持相册删除同步到github仓库:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281208516.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281209075.png"></p>
<h3 id="1-2-Obsidian链接图床"><a href="#1-2-Obsidian链接图床" class="headerlink" title="1.2 Obsidian链接图床"></a>1.2 Obsidian链接图床</h3><p>流程参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4c30495f4325"># 在Obsidian中使用图床实现“一次上传、多次搬运”省心又省力</a></p>
<p>重点部分：配置自动上传插件。写Markdown文章时粘贴的图片自动上传到Github+PicGo图床，无需手动上传和写链接<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029686.png"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281029586.png"></p>
<p>可以看到，此插件相当于一个PicGo客户端，而本地运行的PicGo Server已开启端口36677的监听。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281033479.png"></p>
<p>单元测试：<br>以上配置好后，Obsidian新建一个Markdown文档，粘贴图片会显示updating… ，成功后可在github图床仓库看到该图片，且Markdown本地预览也可以看到。</p>
<p>遇到的坑：<br>一开始上传的图片，github可预览，Obsidian预览失败<br>在PicGo客户端查看刚才上传图片预览也不正常，PicGo客户端手动上传一张后才正常预览。<br>此后Obsidian再粘贴上传图片，预览正常。<br>可能是PicGo首次链接Obsidian插件的bug。</p>
<h3 id="1-3-优化Obsidian写作体验"><a href="#1-3-优化Obsidian写作体验" class="headerlink" title="1.3 优化Obsidian写作体验"></a>1.3 优化Obsidian写作体验</h3><h4 id="1-3-1-Markdown快捷键"><a href="#1-3-1-Markdown快捷键" class="headerlink" title="1.3.1 Markdown快捷键"></a>1.3.1 Markdown快捷键</h4><p>很多Markdown编辑器支持各种快捷键，写作时不需要手动输入Markdown语法，例如一个ctrl+h形成标题，一个ctrl+k形成代码格式。<br>Obsidian默认快捷键不完整，需要补全优化<br>我之前用的Leanote写博客，Obsidian也快捷键设置如下。</p>
<blockquote>
<p>提升标题 Ctrl + H (header)<br>有序列表 Ctrl + O (Ordered)<br>无序列表 Ctrl + U (Un-Ordered)<br>插入链接 Ctrl + L (Link)<br>插入代码 Ctrl + K (K &#x3D; Code, 因为ctrl+C用于粘贴)<br>加粗 Ctrl + B (Bold)<br>斜体 Ctrl + I (Italian体)<br>引用 Ctrl + Q (Quote)<br>插入图片 Ctrl + G (Graph, 有了“粘贴即上传”，这个实际上用不上)</p>
</blockquote>
<p>其他我基本不用的就没设置，例如表格，删除线，分割线等等。<br>如果经常用表格，推荐 Advanced Tables插件。<br>读者也可以参考VS Code的Markdown插件设置。</p>
<h4 id="1-3-2-实时预览和标题大纲"><a href="#1-3-2-实时预览和标题大纲" class="headerlink" title="1.3.2 实时预览和标题大纲"></a>1.3.2 实时预览和标题大纲</h4><p>实时预览是你写一句Markdown，自动转换成预览格式，而不显示Markdown源码。这样不需要开两个窗口，一个写源码一个看预览。在设置-&gt;编辑器里开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281103907.png"></p>
<p>标题大纲是侧边栏显示文章标题列表，就像word的导航窗口一样。在设置-核心插件开启。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202202281104255.png"></p>
<h2 id="2-搭建hexo博客发布环境"><a href="#2-搭建hexo博客发布环境" class="headerlink" title="2. 搭建hexo博客发布环境"></a>2. 搭建hexo博客发布环境</h2><h3 id="2-1-环境安装"><a href="#2-1-环境安装" class="headerlink" title="2.1 环境安装"></a>2.1 环境安装</h3><p>整体流程参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/105715224"># 个人博客第5篇——安装node.js和Hexo</a><br>官方文档参考：<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">hexo.io</a></p>
<p>简单总结一下：</p>
<ul>
<li>hexo是一个基于nodeJS的博客框架，nodeJS提供JavaScript实现后端服务的能力。</li>
<li>hexo可以将本地写好的Markdown文本和图片资源，以JavaScript网页资源的方式打包。hexo可以在本机运行服务，通过浏览器可以在网页访问。</li>
<li>如果要使博客外网可访问，需要一个云服务存放hexo生成的博客，我们使用github仓库作为博客云端。前面已经搭建了github图床仓库，因此图片并不需要放到此hexo仓库。</li>
<li>使用git实现hexo博客部署到github仓库</li>
</ul>
<p>遇到的坑：<br>如果你以前用过hexo，之后nodeJS升级了版本，一定不要用以前的hexo博客目录，必须新建博客目录，重新<code>hexo init</code>安装相关hexo插件。否则nodeJS和hexo插件可能不兼容导致部署失败。</p>
<p>hexo插件版本是根据nodeJS版本自动安装的，配置文件是package.json。以nodeJS 16.3为例，自动生成的依赖版本如下：</p>
<p><code>&#123;   &quot;name&quot;: &quot;hexo-site&quot;,   &quot;version&quot;: &quot;0.0.0&quot;,   &quot;private&quot;: true,   &quot;scripts&quot;: &#123;     &quot;build&quot;: &quot;hexo generate&quot;,     &quot;clean&quot;: &quot;hexo clean&quot;,     &quot;deploy&quot;: &quot;hexo deploy&quot;,     &quot;server&quot;: &quot;hexo server&quot;   &#125;,   &quot;hexo&quot;: &#123;     &quot;version&quot;: &quot;6.0.0&quot;   &#125;,   &quot;dependencies&quot;: &#123;     &quot;hexo&quot;: &quot;^6.0.0&quot;,     &quot;hexo-deployer-git&quot;: &quot;^3.0.0&quot;,     &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,     &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,     &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,     &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,     &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,     &quot;hexo-renderer-marked&quot;: &quot;^5.0.0&quot;,     &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;,     &quot;hexo-server&quot;: &quot;^3.0.0&quot;,     &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot;   &#125; &#125;</code></p>
<p>博客的github仓库，主题等关键配置都在<code>hexo init</code>对应目录下的<code>_config.yml</code><br>我修改了几个关键配置如下：<br>博客框架的语言一定要配，否则默认德语阿拉伯语…</p>
<blockquote>
<p>title: ThinkNotes<br>   subtitle: Simple is not easy<br>   author: Cursorhu<br>   language: zh-CN</p>
</blockquote>
<p>Github部署配置</p>
<blockquote>
<p>url: <a href="https://cursorhu.github.io/">https://cursorhu.github.io</a><br>deploy:<br>      type: git<br>      repo: <a target="_blank" rel="noopener" href="https://github.com/cursorhu/cursorhu.github.io">https://github.com/cursorhu/cursorhu.github.io</a><br>      branch: master</p>
</blockquote>
<h3 id="2-2-发布博客"><a href="#2-2-发布博客" class="headerlink" title="2.2 发布博客"></a>2.2 发布博客</h3><p>hexo new命令可以从0新建markdown写博客，一般不用这么麻烦。</p>
<p>我们直接将Obsidian写好的Markdown（图片资源是图床链接）放到hexo博客目录的post文件夹，例如我的本地目录是：</p>
<blockquote>
<p>F:\HexoBlog\source_posts</p>
</blockquote>
<p>在Markdown文件前添加hexo博客特有的头，说明博客的标题时间，分类等属性。这个头如果用<code>hexo new</code>命令会自动生成，可以先new一个然后拷过来。</p>
<blockquote>
<p>title: 博客文章名<br>date: 2022-02-28 15:04:18<br>tags: markdown<br>categories: markdown</p>
</blockquote>
<p>最后使用git生成网页文件并发布到github博客仓库, 注意不是用node命令行！<br>在hexo博客目录下运行：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-博客主题"><a href="#2-3-博客主题" class="headerlink" title="2.3 博客主题"></a>2.3 博客主题</h3><p>博客主题(theme)取决于不同人喜好，github有大量的hexo主题，按需配置<br>推荐几个主流的：<br><a target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-theme-next">Next</a><br><a target="_blank" rel="noopener" href="https://github.com/bollnh/hexo-theme-material">hexo-theme-material</a></p>
<p>以Next主题为例，安装：</p>
<blockquote>
<p>$ cd hexo博客目录<br>   $ git clone <a target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> themes&#x2F;next</p>
</blockquote>
<p>已我的配置为例，就会在F:\HexoBlog\themes\next看到next主题的源码和配置文件config.yml</p>
<p>Next配置可以自定义各种设置，例如子主题:</p>
<blockquote>
<p> scheme: Muse<br>#scheme: Mist<br>#scheme: Pisces<br>#scheme: Gemini</p>
</blockquote>
<p>我们前面已经用jsdelivr开源CDN为PicGo上传图片加速，可以配置Next主题的网页静态文件的相关库也用jsdelivr加速。最好用到才开启，例如motion enable, 其依赖库velocity就可以设置jsdelivr加速：</p>
<blockquote>
<p>motion:<br>      enable: true<br>    velocity: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.min.js<br>    velocity_ui: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;velocity-animate@1&#x2F;velocity.ui.min.js</p>
</blockquote>
<p>注意这些配置文件也是Markdown格式，<code># </code> 注释一定要带空格</p>
<p>hexo要使用next, 在hexo配置文件设置:</p>
<blockquote>
<p>theme: next</p>
</blockquote>
<p>hexo clean, hexo g, hexo s 跑本地服务，看一下效果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202203041651883.png"></p>
<p>最后hexo clean, g, d 命令三连部署到github</p>
<h3 id="2-4-速度优化"><a href="#2-4-速度优化" class="headerlink" title="2.4 速度优化"></a>2.4 速度优化</h3><p>参考<a target="_blank" rel="noopener" href="https://ednovas.gitee.io/2021/09/23/speeduphexo/"># Hexo 网站访问速度优化</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/01/25/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9AMD5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/25/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9AMD5/" class="post-title-link" itemprop="url">浅谈加密和编码：MD5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-25 14:28:58" itemprop="dateCreated datePublished" datetime="2022-01-25T14:28:58+08:00">2022-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-12 14:35:40" itemprop="dateModified" datetime="2022-12-12T14:35:40+08:00">2022-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/encrypt/" itemprop="url" rel="index"><span itemprop="name">encrypt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-MD5简介"><a href="#1-MD5简介" class="headerlink" title="1.MD5简介"></a>1.MD5简介</h1><p>MD5的全称是Message-Digest Algorithm 5（<strong>信息摘要算法</strong>），经MD2、MD3和MD4发展而来。<br>所谓信息摘要，就是包含数据关键特性，能（唯一）识别原数据的关键信息。</p>
<p>MD5也称为<strong>单向散列算法</strong>，这是从其实现方式命名，因为：</p>
<ul>
<li>MD5能对大量数据，进行哈希映射，输出固定长度(128bit)的数据，输出数据也称为原数据的信息摘要。</li>
<li>不能由摘要推测出原数据，即MD5算法是单向的，当加密来用的话，只能加密不能解密。</li>
</ul>
<p>MD5的特点：</p>
<ul>
<li>固定长度：输入任意长度的信息，经过MD5处理，输出总是128位的信息。</li>
<li>唯一性：不同的输入得到的不同的结果；同样的输入一定得到相同的结果。</li>
<li>不可逆：根据128位的输出结果不可能反推出输入的信息。</li>
</ul>
<h1 id="2-MD5的应用"><a href="#2-MD5的应用" class="headerlink" title="2.MD5的应用"></a>2.MD5的应用</h1><p>1、防止被篡改：<br>1）比如A和B发送一个电子文档，发送前，A先自己计算出数据的MD5输出结果a。<br>然后在B收到电子文档后，B计算得到一个MD5的输出结果b。<br>如果a与b一样就代表传输中途数据未被篡改。<br>2）比如A提供文件下载，为了防止不法分子在文件中添加木马，伪装成A的文件。A可以在网站上公布由安装文件得到的MD5输出结果。<br>要下载文件的人只需要下载后，验证MD5是否和A一致，如果不一致，就是被其他人修改过。</p>
<p>2、防止暴露明文：<br>基本上存储用户密码的场景，都用到MD5加密明文。<br>1）例如网站服务器在其数据库存储用户的密码，都是存储用户密码的MD5值。就算不法分子得用户密码的MD5值，也无法知道用户的密码。<br>2）在UNIX、Linux系统中，用户密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。</p>
<p>3、防止抵赖（数字签名）：<br>这需要一个存储MD5值的第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。</p>
<h1 id="3-MD5算法实现"><a href="#3-MD5算法实现" class="headerlink" title="3.MD5算法实现"></a>3.MD5算法实现</h1><p>对MD5算法简要的叙述可以为：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<p>第一步、填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N<em>512+448(bit)；<br>第二步、记录信息长度：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N</em>512+448+64&#x3D;(N+1)*512位。<br>第三步、装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A&#x3D;(01234567) 16 ，B&#x3D;(89ABCDEF) 16 ，C&#x3D;(FEDCBA98) 16 ，D&#x3D;(76543210) 16 ）。如果在程序中定义应该考虑大小端（A&#x3D;0X67452301L，B&#x3D;0XEFCDAB89L，C&#x3D;0X98BADCFEL，D&#x3D;0X10325476L）。<br>第四步、四轮循环运算：循环的次数是分组的个数（N+1）。 最终由4个32bit数据拼成128bit的结果。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121430277.png" alt="image-20221212143002209"></p>
<h1 id="4-MD5的安全性"><a href="#4-MD5的安全性" class="headerlink" title="4.MD5的安全性"></a>4.MD5的安全性</h1><p>普遍认为MD5是很安全，因为哈希散列是强抗碰撞的：已知原数据和其MD5值，想通过枚举找到一个相同MD5值的数据，基本不可能。如果暴力破解MD5，其运算时间是不可想象的。</p>
<p>但是实际应用上，如果把用户密码仅仅MD5处理后再存储到数据库，其实是很不安全的。因为用户的密码的固有特征，让枚举集合变小了许多，原因：</p>
<ul>
<li>用户密码是比较短的一般8位左右。</li>
<li>很多用户的密码有规律，例如使用生日，手机号码，或者使用常用数字组合，或某个英文单词。</li>
<li>许多用户的常用密码只有一个，也就是说，泄漏了微信的密码，也很有可能QQ,支付宝密码也泄漏了</li>
</ul>
<p>如果把常用的密码先MD5处理后存储结果，然后再跟用户的MD5结果匹配，这时就有较大概率“碰撞”，得到明文。这种预先存储的MD5表称为rainbow-table。<br>因此MD5作为“信息摘要”的用途多一些，作为加密，还需要配合其他的算法（例如AES等几种公钥算法），或者“加盐”。<br>安全性比较好的网站，都会用一种叫做 “加盐”(salt)的方式来存储密码:</p>
<ul>
<li>先将用户输入的密码进行一次MD5（或其它哈希算法）加密。</li>
<li>将得到的MD5值前后加上一些只有管理员自己知道的随机串，再进行一次MD5加密。</li>
<li>这个随机串中可以包括某些固定的串，也可以包括用户名（用来保证每个用户加密使用的密钥都不一样）。</li>
<li>在管理员和用户的两个salt没有泄露的情况下，黑客拿到加密串，就几乎不可能推算出原始的密码是什么了。</li>
</ul>
<h1 id="5-MD5库"><a href="#5-MD5库" class="headerlink" title="5.MD5库"></a>5.MD5库</h1><p>在涉及到文件传输的场景，通常用MD5校验文件的一致性，openSSL库提供MD5计算函数：</p>
<p><a target="_blank" rel="noopener" href="https://www.openssl.org/docs/man3.0/man3/MD5_Update.html">MD5_Update</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int MD5_Init(MD5_CTX *c);</span><br><span class="line">int MD5_Update(MD5_CTX *c, const void *data, unsigned long len);</span><br><span class="line">int MD5_Final(unsigned char *md, MD5_CTX *c);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/01/22/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9Abase64/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/22/%E6%B5%85%E8%B0%88%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A0%81%EF%BC%9Abase64/" class="post-title-link" itemprop="url">浅谈加密和编码：base64</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-22 14:36:51" itemprop="dateCreated datePublished" datetime="2022-01-22T14:36:51+08:00">2022-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-12 14:38:31" itemprop="dateModified" datetime="2022-12-12T14:38:31+08:00">2022-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/encrypt/" itemprop="url" rel="index"><span itemprop="name">encrypt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-什么是编码解码"><a href="#1-什么是编码解码" class="headerlink" title="1.什么是编码解码"></a>1.什么是编码解码</h1><p>编码：利用特定的算法，对原始内容进行处理，生成运算后的内容，形成另一种数据的表现形式，可以根据算法，再还原回来，这种操作称之为编码。<br>解码：利用编码使用的算法的逆运算，对经过编码的数据进行处理，还原出原始数据，这种操作称之为解码。</p>
<h1 id="2-什么是Base64编码算法"><a href="#2-什么是Base64编码算法" class="headerlink" title="2.什么是Base64编码算法"></a>2.什么是Base64编码算法</h1><p>将任意的字节数组数据，通过Base64算法，生成只有（大小写英文、数字、+、&#x2F;）（一共64个字符）内容表示的字符串数据。即将任意的内容转换为可见的字符串形式。</p>
<h1 id="3-为什么需要Base64编码"><a href="#3-为什么需要Base64编码" class="headerlink" title="3.为什么需要Base64编码"></a>3.为什么需要Base64编码</h1><p>Base64算法最开始是被用于解决电子邮件数据传输问题。以前发送邮件只支持可见字符的传送，但ASCII码中，有一部分不支持直接显示。由此，需要有一个方法将不可见的字符转换为可见的字符，便产生了Base64编码算法。</p>
<h1 id="4-Base64算法的实现"><a href="#4-Base64算法的实现" class="headerlink" title="4.Base64算法的实现"></a>4.Base64算法的实现</h1><p>特点：</p>
<ul>
<li>将数据按照 3个字节一组的形式进行处理，每三个字节在编码之后被转换为4个字节。即：如果一个数据有6个字节，可编码后将包含6&#x2F;3*4&#x3D;8个字节</li>
<li>当数据的长度无法满足3的倍数的情况下，最后的数据需要进行填充操作，即补“&#x3D;” ，这里“&#x3D;”是填充字符，不要理解为第65个字符。因此我们经常看见base64编码的字符串结尾有几个”&#x3D;”号</li>
</ul>
<p>示例：</p>
<p> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121437191.png" alt="image-20221212143753149"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121438580.png" alt="image-20221212143830525"></p>
<p>上面示例将原始数据的每三个字节分为一组，按位进行分割为每6位一个字节的形式，进行转换，形成新的4个字节。空缺的两个bit用0填补。<br>这四个字节才通过Base64编码表进行映射，形成最后实际的Base64编码结果。<br>如果原始数据最后无法凑成3个字节，则以“&#x3D;”填充。</p>
<p>注：上图中的1234567表示bit的位置，不是bit的值。</p>
<p>将字符串”ABC”进行Base64编码流程如下。</p>
<p>1.使用ASCII编码方式将字符串”ABC”转换成二进制数据 01000001 | 01000010 | 01000011<br>2.将步骤1的二进制数据进行分组，每个分组6bit 010000 | 010100 | 001001 | 000011<br>3.将步骤2的4组6bit二进制编码数据进行补位（高位补0），变成4组8bit二进制 00010000 | 00010100 | 00001001 | 00000011<br>4.将步骤3中的4组8bit转换成十进制。16 | 20 | 9 | 3<br>5.以步骤4的十进制数据为索引，去Base64编码映射表中寻找对应的字符。16在编码表中映射的字符是Q，20映射的字符是U，9映射的字符是J，3映射的字符是D。<br>所以，字符串”ABC”经过Base64编码后的数据是”QUJD”。</p>
<p><strong>Base64编码索引表</strong><br>26个字母 * 2(大小写) + 10个数字 + 2个运算符号 &#x3D; 64个字符<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212121438704.png" alt="image-20221212143820653"></p>
<h1 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h1><p>http协议中，GET方式和POST方式是Http请求常用的两种方式，GET方法只能传递ASCII数据，但某些情况下会要求使用GET来传递二进制数据。<br>此时用Base64对Get传输的二进制数据，编码成ASCII数据，例如，客户端和服务器传递JSON数据时，经常会进行base64编解码。</p>
<p>注意：</p>
<ul>
<li>Base64是编码算法，不是加密算法，只是用来编码二进制的字节数组，形成可视的ASCII字符串。</li>
<li>Base64编码实际上是把原数据的3个字节映射成了4个字节，所以相比于原数据长度，编码后的长度会增加1&#x2F;3。会降低传输效率。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/09/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8ALSA-A2DP-PulseAudio%E8%87%AA%E5%88%B6%E8%93%9D%E7%89%99%E9%9F%B3%E7%AE%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8ALSA-A2DP-PulseAudio%E8%87%AA%E5%88%B6%E8%93%9D%E7%89%99%E9%9F%B3%E7%AE%B1/" class="post-title-link" itemprop="url">树莓派笔记：使用ALSA+A2DP+PulseAudio自制蓝牙音箱</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-09 19:54:39" itemprop="dateCreated datePublished" datetime="2021-09-09T19:54:39+08:00">2021-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 19:49:24" itemprop="dateModified" datetime="2022-12-08T19:49:24+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/raspi/" itemprop="url" rel="index"><span itemprop="name">raspi</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>树莓派4B自带蓝牙和Wifi, 无需外接 USB dongle；<br>蓝牙最常见的应用是近距离传输数据，比如蓝牙传文件，蓝牙音箱等。正好家里有个普通的usb供电的便携音箱；</p>
<p>本文用树莓派蓝牙+普通音箱，实现简单的蓝牙音箱。</p>
<p>首先需要了解Linux音频系统的整体框架：<br><img src="C:\Users\thomas.hu\AppData\Roaming\Typora\typora-user-images\image-20221208194352559.png" alt="image-20221208194352559"></p>
<p>大致分为三个部分：</p>
<ul>
<li>kernel&#x2F;driver层的ALSA驱动框架</li>
<li>蓝牙音频协议栈：A2DP, 这是使蓝牙具有传输音频流能力的基石; Linux官方的bluez包实现了A2DP</li>
<li>音频应用层, Linux最常用的音频服务器是Pulse Audio</li>
</ul>
<p>怎样理解这三层：可以类比Linux网络层：<br>ALSA 类似网络驱动框架<br>A2DP 类似TCP&#x2F;UDP层<br>PulseAudio 类似HTTP层的服务器，类比Apache</p>
<p>而蓝牙连接类似http连接和会话；<br>声卡(输入、输出)类似网卡(Ethernet和wifi)，音频设备(音箱，麦克风)类似具体的网口设备</p>
<p>深入了解 ALSA 音频驱动和 A2DP 蓝牙音频协议，参考：<br><a target="_blank" rel="noopener" href="https://www.alsa-project.org/wiki/Main_Page">Advanced Linux Sound Architecture (ALSA) project homepage</a><br><a target="_blank" rel="noopener" href="http://www.dslreports.com/r0/download/2285126~a70eb148e16b921dc323dbb977d4b4b1/A2DP_SPEC.pdf">A2DP Spec</a></p>
<p>本文的环境<br>树莓派4B, 系统: ubuntu-server raspberry pi版本<br>音箱：usb供电，音频线<br>安卓手机：用于配对树莓派的蓝牙音频服务</p>
<p>连接示意图</p>
<pre><code> Audio source (i.e. smartphone) 
                |
                v
 (((  Wireless Bluetooth Channel  )))
                |
                v
  Raspberry PI (with A2DP service)
                |
                v
         Audio Interface
                |
                v
             Speakers
</code></pre>
<h1 id="使用alsa-utils测试音频设备"><a href="#使用alsa-utils测试音频设备" class="headerlink" title="使用alsa-utils测试音频设备"></a>使用alsa-utils测试音频设备</h1><p>首先测试Linux上如何使用普通音箱<br>将音箱USB连到树莓派USB, 音频线连到音频接口</p>
<h2 id="查看音频设备"><a href="#查看音频设备" class="headerlink" title="查看音频设备"></a>查看音频设备</h2><p>ALSA在应用层提供了alsa-utils包，其含有arecord、aplay等工具来查看和使用音频设备。</p>
<pre><code>apt-get install alsa-utils
</code></pre>
<p>查看声卡列表：</p>
<pre><code>cat /proc/asound/cards
</code></pre>
<p>可以看到当前有两张声卡</p>
<p>card 0是树莓派的bcm2835集成声卡，card 1 是另外接的USB麦克风</p>
<p>注意区分声卡和音频设备，一个声卡可以管理多个音频设备，类似于”总线”和”设备”的关系。</p>
<p>音频设备可以细分为输入和输出两种：例如音箱是播放音频，属于输出；麦克风是录入音频，属于输入。下面分别查看这两类设备。</p>
<p>查看音频输入设备：</p>
<pre><code>arecord -l
</code></pre>
<p>查看音频输出设备：</p>
<pre><code>aplay -l
</code></pre>
<h2 id="使用音频设备"><a href="#使用音频设备" class="headerlink" title="使用音频设备"></a>使用音频设备</h2><p>(1)测试音频输出：</p>
<pre><code>aplay test.wav -D plughw:CARD=0,DEV=0
</code></pre>
<p>音频设备用 CARD 和 DEV 指定，来自于前文<code>aplay -l</code>查看音频设备的输出<br>测试音频(wav格式)可以在此下载：<a target="_blank" rel="noopener" href="https://www.ape8.cn/wav/">ape8.cn</a></p>
<p>(2)测试音频输入：</p>
<p>使用arecord录制音频输入<br>-f 录制音频格式。例如 cd 表示 (16 bit little endian, 44100, stereo)<br>-d 录制时间，单位秒<br>-c 输入通道的个数，如果是麦克风阵列可能有多通道<br>-D 使用的设备：-D hw:1,0 表示使用 card 1 下的device 0设备</p>
<p>测试如下：</p>
<pre><code>arecord -f cd -d 5 -c 1 -D hw:1,0 &gt; test.pcm
</code></pre>
<p>然后播放此音频：</p>
<pre><code>aplay test.pcm
</code></pre>
<h1 id="蓝牙服务相关配置"><a href="#蓝牙服务相关配置" class="headerlink" title="蓝牙服务相关配置"></a>蓝牙服务相关配置</h1><h2 id="蓝牙协议栈和服务的安装"><a href="#蓝牙协议栈和服务的安装" class="headerlink" title="蓝牙协议栈和服务的安装"></a>蓝牙协议栈和服务的安装</h2><p>首先确保系统软件是最新：</p>
<pre><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>
<p>安装 bluez，pulseaudio 等蓝牙基础组件，对于树莓派还要安装pi-bluetooth</p>
<pre><code>sudo apt-get install pi-bluetooth bluez bluez-tools pulseaudio pulseaudio-module-bluetooth
</code></pre>
<p>bluez 是Linux官方的蓝牙协议栈，其内部实现 A2DP 蓝牙音频协议，参考<a target="_blank" rel="noopener" href="http://www.bluez.org/about/">bluez.org</a></p>
<p>PulseAudio 是Linux音频服务器, 其最主要的作用是：<br>PulseAudio clients can send audio to “sinks” and receive audio from “sources”</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.freedesktop.org/wiki/Software/PulseAudio/About/">PulseAudio&#x2F;About</a></p>
<p>简单说明下蓝牙的发送、接收的概念：<br>蓝牙的Source端为发送码流的端，Sink端为接收码流的端；可类比生产者和消费者模型</p>
<h2 id="启动音频服务"><a href="#启动音频服务" class="headerlink" title="启动音频服务"></a>启动音频服务</h2><p>PulseAudio服务需要创建用户名和用户组，示例如下：</p>
<pre><code>sudo usermod -G bluetooth -a ubuntu
</code></pre>
<p>启动服务器</p>
<pre><code>pulseaudio --start
</code></pre>
<h2 id="启动蓝牙配对"><a href="#启动蓝牙配对" class="headerlink" title="启动蓝牙配对"></a>启动蓝牙配对</h2><p>蓝牙首次连接需要配对，使用 bluez 的 <code>bluetoothctl</code>工具</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.makeuseof.com/manage-bluetooth-linux-with-bluetoothctl/">How to Manage Bluetooth Devices on Linux Using bluetoothctl</a></p>
<pre><code>bluetoothctl //进入蓝牙配置模式，会显示用户为[bluetooth]#
[bluetooth]# list //列出树莓派的蓝牙控制器列表
[bluetooth]# agent on //注册蓝牙代理
[bluetooth]# default-agent //使用默认代理
[bluetooth]# discoverable on //树莓派的蓝牙可被其他设备发现
[bluetooth]# scan on //开始扫描可连接蓝牙设备
</code></pre>
<p>此后选择要连接的蓝牙设备，手机蓝牙打开，<code>scan on</code>列表找到手机的 MAC地址 进行连接配对。<br>手机的MAC可在设置-&gt;系统信息查看</p>
<pre><code>[bluetooth]# pair &lt;dev&gt; //配对设备，首次需要密码
[bluetooth]# trust &lt;dev&gt; //信任该设备，此后可以自动配对无需密码
[bluetooth]# connect &lt;dev&gt; //建立连接
</code></pre>
<p>现在可以退出 bluetoothctl模式，然后测试蓝牙音频播放：</p>
<pre><code>[bluetooth]# quit
aplay test.wav
</code></pre>
<p>关于蓝牙的agent，参考<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/763939/bluetoothctl-what-is-a-bluetooth-agent">bluetoothctl - What is a bluetooth agent?</a></p>
<h2 id="设置自动配对连接"><a href="#设置自动配对连接" class="headerlink" title="设置自动配对连接"></a>设置自动配对连接</h2><p>为了避免每次pair都要指定设备，可以配置蓝牙打开时，自动pair上次的设备。</p>
<p>编辑PulseAudio配置文件 <code>/etc/pulse/default.pa</code> </p>
<pre><code># automatically switch to newly-connected devices
load-module module-switch-on-connect
</code></pre>
<p>编辑bluez配置文件 <code>/etc/bluetooth/main.conf</code></p>
<pre><code>[Policy]
AutoEnable=true
</code></pre>
<p>系统重启后只需要重启PulseAudio服务：</p>
<pre><code>pulseaudio --start
</code></pre>
<h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><h2 id="找不到蓝牙controller"><a href="#找不到蓝牙controller" class="headerlink" title="找不到蓝牙controller"></a>找不到蓝牙controller</h2><p>最开始bluetoothctl list显示的蓝牙控制器列表是空的，我一度怀疑买了假的raspi-4B</p>
<p>原因是树莓派需要安装专门的蓝牙包 pi-bluetooth，参考<a target="_blank" rel="noopener" href="https://raspberrypi.stackexchange.com/questions/114586/rpi-4b-bluetooth-unavailable-on-ubuntu-20-04">rpi-4b-bluetooth-unavailable-on-ubuntu</a></p>
<p>树莓派很多功能都要求系统有定制包，大多数硬件失效都是定制包未安装。</p>
<h2 id="蓝牙连接正常，播放没声音"><a href="#蓝牙连接正常，播放没声音" class="headerlink" title="蓝牙连接正常，播放没声音"></a>蓝牙连接正常，播放没声音</h2><p>首先确认音频设备物理连接是否正常；</p>
<p>然后确认PulseAudio音频服务是否正常，检查服务状态和配置文件；</p>
<pre><code>pacmd info
pactl info
</code></pre>
<p>问题仍没有解决，仔细听似乎有很小的声音，检测音量配置：</p>
<pre><code>pacmd list-sinks //找到sink设备，即音箱
pacmd set-sink-volume &lt;sink&gt; &lt;value&gt; //设置音量，value取值 [0, 65536] 代表标准音量 0~100%
</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/219739/adjust-max-possible-volume-in-pulseaudio#:~:text=pactl%20set-sink-volume%200%20100%25%20Where%200%20is%20the,100%25%20to%20get%20audio%20boost%20%28200%25%20for%20example%29.">adjust max possible volume in pulseaudio</a></p>
<p>此时播放音乐可以听到但声音极小；<br>检查音箱的线控音量调节，调到最大；<br>此时蓝牙音乐只有正常音箱大概 30% 的播放音量。</p>
<p>原因是树莓派的USB供电驱动能力有限，同一音箱，在PC-USB供电下30%的音量大小等同于树莓派上100%的音量大小。</p>
<p>自此蓝牙播放音量可以达到正常水平，需要更高音量和音质建议220V供电的音箱。</p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1b79537da86d">Ubuntu音频设备检测</a><br><a target="_blank" rel="noopener" href="https://www.nicolabs.net/2020/Make-RPi-bluetooth-speaker-part-1">Make-RPi-bluetooth-speaker-part-1</a><br><a target="_blank" rel="noopener" href="https://gist.github.com/actuino/9548329d1bba6663a63886067af5e4cb">actuino&#x2F;bt_speaker-raspberry_pi-zero_w</a><br><a target="_blank" rel="noopener" href="https://gist.github.com/oleq/24e09112b07464acbda1#file-a2dp-autoconnect-L17">A2DP audio streaming using Raspberry PI</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/08/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8mjpg-streamer-Apache+SSH%E8%87%AA%E5%88%B6%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8mjpg-streamer-Apache+SSH%E8%87%AA%E5%88%B6%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/" class="post-title-link" itemprop="url">树莓派笔记：使用mjpg-streamer+Apache+SSH自制网络摄像头</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-23 23:38:12" itemprop="dateCreated datePublished" datetime="2021-08-23T23:38:12+08:00">2021-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 19:50:26" itemprop="dateModified" datetime="2022-12-08T19:50:26+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/raspi/" itemprop="url" rel="index"><span itemprop="name">raspi</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h1><ul>
<li>为什么用树莓派4：</li>
</ul>
<p>资料多遇到容易解决问题；<br>性能较强适合作为终端服务器；<br>自带WIFI, BT5.0，GPIO 方便拓展开发IOT相关项目；<br>适配系统丰富，基本PC上linux版本树莓派都有对应版本</p>
<ul>
<li>为什么用USB摄像头：</li>
</ul>
<p>为了快速实现，Linux对USB设备支持非常好，USB设备基本都是免驱；<br>USB摄像头支持高分辨率，带麦克风，满足其他项目拓展应用；<br>当然CSI接口摄像头也有优势，同等条件下其CPU占用率比USB低；不过本地测试中CPU并不是USB摄像头性能瓶颈<br>关于CSI和USB 摄像头区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ZhaoDongyu_AK47/article/details/103981905">CSI摄像头 vs USB摄像头</a></p>
<ul>
<li>树莓派用什么系统：</li>
</ul>
<p>看个人喜好，我用的ubuntu server的树莓派版本，软件源基本最新；</p>
<ul>
<li>用什么云服务器：</li>
</ul>
<p>看个人喜好和价格；云服务器最大价值在于公网IP<br>我目前用的Aliyun + CentOS7 系统</p>
<p>系统实拍：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081944910.png" alt="image-20221208194427802"></p>
<h1 id="树莓派系统安装"><a href="#树莓派系统安装" class="headerlink" title="树莓派系统安装"></a>树莓派系统安装</h1><p>准备：电源，网线，SD卡<br>安装步骤：</p>
<ul>
<li>1.下载ubuntu server for raspi</li>
</ul>
<p>注意一定要下载raspi版本的镜像，普通ubuntu server版本安装完不能直接使用SSH<br><a target="_blank" rel="noopener" href="https://ubuntu.com/download/raspberry-pi">Install Ubuntu on a RaspberryPi</a></p>
<ul>
<li>2.Win32DiskImager写.img镜像到SD卡，作为系统盘</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/bhniunan/article/details/104790090">使用win32DiskImager为树莓派4B安装系统</a></p>
<ul>
<li>3.SSH 登陆</li>
</ul>
<p>ubuntu server for raspi系统装机启动后，连接网线到主机局域网后就可以SSH登陆<br>树莓派连到主机网段路由器的LAN口，树莓派系统默认开了dhcp, 用Advanced IP Scanner扫描树莓派IP</p>
<p>树莓派4b：mac地址“dc-a6-32”开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081944582.png" alt="image-20221208194446543"></p>
<p>SSH 软件看个人喜好，putty, SecureCRT, Xshell都可以，我个人使用的SecureCRT</p>
<p>ubuntu server for raspi系统的SSH会话初始化如下：<br>新建会话-&gt; SSH2链接-&gt; 树莓派ip -&gt; 账户名(默认ubuntu)<br>初始密码：ubuntu，登陆成功后需要重设密码。</p>
<p>wifi配置方式参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42378324/article/details/114631521">树莓派安装ubuntu server, 无显示屏和键盘</a></p>
<ul>
<li>4.固定树莓派IP</li>
</ul>
<p>DHCP方式每次启动树莓派IP可能不一样，有两种方式固定IP</p>
<ul>
<li>MAC绑定IP<br>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/Echozi/article/details/104210167">TL-WR886N路由器+树莓派绑定IP地址</a></li>
<li>手动配置固定ip<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010169607/article/details/111316624">Pi4B 树莓派 ubuntu20.04 设置固定IP地址</a></li>
</ul>
<h1 id="USB摄像头测试"><a href="#USB摄像头测试" class="headerlink" title="USB摄像头测试"></a>USB摄像头测试</h1><ul>
<li>首先主机win10上验证摄usb像头功能正常</li>
</ul>
<p>设备管理器禁用笔记本原装摄像头驱动，搜索相机-&gt; 打开视频，视频流应该正常</p>
<ul>
<li>在树莓派上验证摄像头设备</li>
</ul>
<p>usb摄像头设备既是usb设备又是v4l2设备，应该挂载在&#x2F;dev&#x2F;videoX</p>
<pre><code>ls /dev/video*
ls /dev | grep video
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945191.png" alt="image-20221208194510165"><br>插拔摄像头确认usb摄像头对应设备是video0</p>
<h1 id="树莓派安装mjpg-streamer"><a href="#树莓派安装mjpg-streamer" class="headerlink" title="树莓派安装mjpg-streamer"></a>树莓派安装mjpg-streamer</h1><p>mjpg-streamer的作用是将摄像头采集的YUV&#x2F;JPEG数据，封装成流服务，其他设备可以通过http方式获取图片或视频流。<br>mjpg-streamer属于应用层实现流媒体服务端，其底层调用的是Linux V4L2框架接口。</p>
<p>安装过程：</p>
<ol>
<li><p>依赖库安装</p>
<p>sudo apt-get install subversion libjpeg8-dev imagemagick libv4l-dev cmake git</p>
</li>
<li><p>安装mjpg-streamer</p>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com/jacksonliam/mjpg-streamer.git">https://github.com/jacksonliam/mjpg-streamer.git</a><br>cd mjpg-streamer&#x2F;mjpg-streamer-experimental&#x2F;<br>make all<br>sudo make install</p>
</li>
</ol>
<h1 id="局域网测试mjpg-streamer"><a href="#局域网测试mjpg-streamer" class="headerlink" title="局域网测试mjpg-streamer"></a>局域网测试mjpg-streamer</h1><p>mjpg-streamer&#x2F;mjpg-streamer-experimental目录下有测试脚本：<code>start.sh</code><br>环境变量添加依赖库路径：</p>
<pre><code>export LD_LIBRARY_PATH=&quot;$(pwd)&quot; 
</code></pre>
<p>运行示例：</p>
<pre><code>./mjpg_streamer -i &quot;./input_uvc.so&quot; -o &quot;./output_http.so -w ./www&quot; 
</code></pre>
<p>其YUV&#x2F;MJPEG的输入使用 input_uvc.so， 输出流到 http依赖于 output_http.so，<code>-w ./www</code> 表示http客户端访问时返回www文件夹下的资源，即对应的浏览器页面。</p>
<p>可以自定义参数，参考：</p>
<pre><code>mjpg_streamer -i &quot;input_uvc.so --help&quot;
</code></pre>
<p>修改start.sh的自定义启动语句如下：</p>
<pre><code>./mjpg_streamer -i &quot;./input_uvc.so -n -f 30 -r 640x480 -d /dev/video0&quot;  -o &quot; ./output_http.so -w ./www&quot;
</code></pre>
<p>-n 用于跳过一些ioctrl请求，我的摄像头如果不用-n，有一些ioctrl会返回错误，尽管不影响流传输功能，还是跳过。<br>-f 设置fps，如果有卡顿考虑降低该值<br>-r 分辨率，1080P摄像头可以支持到1920x1080<br>-d 设备名，默认&#x2F;dev&#x2F;video0</p>
<p>一般USB摄像头支持直接输出压缩后的MJPEG格式图像，有的只支持YUV格式图像；<br>摄像头优先使用MJPEG格式，因为不用mjpg-streamer软件边采集边做压缩，减少CPU使用</p>
<p>启动信息：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945245.png" alt="image-20221208194525192"></p>
<p>此时流服务已运行，在局域网任意设备用浏览器访问<code>树莓派ip:流服务端口</code>即可获取www目录的网页资源<br>192.168.0.105是我树莓派固定ip, 8080是mjpg-streamer服务默认端口<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081945636.png" alt="image-20221208194549504"><br>局域网下即使是1080p 30fps也非常流畅，看不出卡顿</p>
<h1 id="公网服务器搭建反向代理"><a href="#公网服务器搭建反向代理" class="headerlink" title="公网服务器搭建反向代理"></a>公网服务器搭建反向代理</h1><h2 id="反向代理的概念"><a href="#反向代理的概念" class="headerlink" title="反向代理的概念"></a>反向代理的概念</h2><p>正向代理和反向代理的概念图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946618.png" alt="image-20221208194609572"></p>
<p>正向代理：代理的是客户端，例如GFW禁止某用户直接访问目标服务器的8080端口，但没有禁止访问正向代理服务器，客户端访问正向代理服务器，代理服务将用户请求转发给目标服务器，实现“蛙跳式”访问。对于目标服务器来说，正向代理服务器才是其客户端，用户ip对其是不可见的。<br>反向代理：代理的是服务端，应用于以下场景：</p>
<ul>
<li>出于安全考虑，目标服务器不直接暴露其ip和端口，用户通过访问反向代理服务器来间接访问目标服务器</li>
<li>保证系统稳定性：反向代理服务器可以代理多个目标服务器，当用户请求量大时作为负载均衡(<a target="_blank" rel="noopener" href="https://blog.csdn.net/ywd1992/article/details/112858537">负载均衡和反向代理的区别</a>); 支持目标服务器作为集群管理，当某个目标服务器失效时将请求转发到其他服务器, 参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jkko123/p/6426857.html">centos7下apache2.4反向代理</a></li>
</ul>
<p>对于本项目，树莓派的mjpg-streamer进程是真正提供流媒体服务的目标服务器，阿里云公网服务器上安装apache服务，实现反向代理。</p>
<h2 id="安装apache服务"><a href="#安装apache服务" class="headerlink" title="安装apache服务"></a>安装apache服务</h2><p>Apache实现http web服务器；没有apache, 客户浏览器页面没办法访问对应服务。<br>阿里云主机 cent-OS 7 上的安装过程：</p>
<pre><code>//安装Apache
yum install httpd
//设置服务器开机自动启动Apache
systemctl enable httpd.service
//启动Apache
systemctl start httpd.service
//重启
systemctl restart httpd.service
//停止
systemctl stop httpd.service    
</code></pre>
<p>启动apache后，直接访问阿里云ip，默认端口 80 即为 apache 进程端口，得到如下页面说明服务正常<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946493.png" alt="image-20221208194622426"></p>
<h2 id="配置apache为反向代理"><a href="#配置apache为反向代理" class="headerlink" title="配置apache为反向代理"></a>配置apache为反向代理</h2><p>apache相关配置路径在&#x2F;etc&#x2F;httpd的几个conf目录<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946576.png" alt="image-20221208194635517"></p>
<p><code>vim /etc/httpd/conf/httpd.conf</code> 查看关键内容如下:</p>
<pre><code>Listen 80 //监听80端口
Include conf.modules.d/*.conf //包含module.d目录的所有conf
DocumentRoot &quot;/var/www/html&quot; //默认返回该目录的html资源
IncludeOptional conf.d/*.conf //包含conf.d目录的所有conf
</code></pre>
<p><code>/etc/httpd/conf.modules.d</code>目录下的<code>00-proxy.conf</code>是针对代理的配置项，其中有大量LoadModule加载proxy模块。<br>配置内容是XML格式，在此自定义反向代理，追加以下内容：</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ProxyRequests off
    &lt;Proxy raspi&gt;
        Order allow,deny
        Allow from all
    &lt;/Proxy&gt;
    ProxyPass /raspi http://127.0.0.1:9020
    ProxyPassReverse /raspi http://127.0.0.1:9020
&lt;/VirtualHost&gt;
</code></pre>
<p>含义：<br><code>&lt;VirtualHost *:80&gt;</code> 定义一个虚拟主机，<em>表示任意命名，端口80<br><code>ProxyRequests off</code> 关闭正向代理<br><code>&lt;Proxy raspi&gt;</code>定义一个代理对象，可以命名为</em>，这里命名为raspi因为后端服务是raspi流服务<br><code>ProxyPass</code> 和 <code>ProxyPassReverse</code> 内容要完全一样，<code>ProxyPassReverse /raspi http://127.0.0.1:9020</code> 表示用户访问&#x2F;raspi资源实际访问的是本地（apache所在云主机）的9020端口。</p>
<p>注意阿里云端口要支持外部可访问，需要在控制台配置安装组，参考：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/767328">阿里云服务器开放端口教程</a></p>
<p>我个人的配置是直接(1~65535)全部端口打开（不推荐，有风险）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081946296.png" alt="image-20221208194652256"></p>
<p>配置完毕重启apache服务</p>
<h2 id="配置SSH反向隧道"><a href="#配置SSH反向隧道" class="headerlink" title="配置SSH反向隧道"></a>配置SSH反向隧道</h2><p>树莓派的mjpg-streamer服务如何连接到阿里云的apache服务？<br>使用SSH连通。关于SSH，参考<a target="_blank" rel="noopener" href="https://www.ssh.com/academy/ssh">SSH (Secure Shell) Home Page</a></p>
<p>前文的SecureCRT登陆树莓派就是使用SSH2协议，下面将树莓派的mjpg-streamer服务端口通过SSH反向隧道连接到apache的代理端口</p>
<pre><code>ssh -fN -R &lt;阿里云apache代理端口&gt;:&lt;树莓派localhost&gt;:&lt;树莓派mjpg-streamer服务端口&gt; &lt;阿里云服务器用户名&gt;@&lt;服务器IP&gt;
</code></pre>
<p>例如 <code>ssh -fN -R 9020:localhost:8080 root@47.100.221.149</code><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947690.png" alt="image-20221208194724640"></p>
<p>输入服务器的登录密码完成通道建立，在阿里云可以查看：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947971.png" alt="image-20221208194733933"></p>
<h1 id="验证公网可访问-mjpg-streamer-服务"><a href="#验证公网可访问-mjpg-streamer-服务" class="headerlink" title="验证公网可访问 mjpg-streamer 服务"></a>验证公网可访问 mjpg-streamer 服务</h1><ul>
<li><p>1.验证树莓派到apache的视频流通道：</p>
<ol>
<li>阿里云服务器启动apache</li>
<li>树莓派建立SSH反向隧道</li>
<li>树莓派启动mjpg-streamer</li>
<li>在阿里云curl访问本地的代理端口</li>
</ol>
<p> curl 127.0.0.1:9020&#x2F;?action&#x3D;stream</p>
</li>
</ul>
<p>如果有大量数据输出，说明连接没问题</p>
<ul>
<li>2.验证apache到客户端浏览器的反向代理通道：</li>
</ul>
<p>使用处于任意网络的设备的浏览器，访问：</p>
<pre><code>http://云服务器IP / Apache代理名 / ?action=stream
</code></pre>
<p>本文中配置对应的输入是：<code>47.100.221.149/raspi/?action=stream</code>，注意<code>?action=stream</code>不能掉，直接访问<code>/raspi</code>得到的是静态页面，跳转不到<code>action=stream</code>的页面<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947462.png" alt="image-20221208194745374"></p>
<p>直接访问 SSH 通道的 9020 端口支持主页面访问和跳转到<code>action=stream</code>页面：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081947787.png" alt="image-20221208194754703"></p>
<p>自此验证完毕公网可访问树莓派的视频流服务</p>
<h1 id="性能测试与优化"><a href="#性能测试与优化" class="headerlink" title="性能测试与优化"></a>性能测试与优化</h1><p>实测发现mjpg-streamer启动时使用 640x480分辨率, 30fps，MJPEG格式，延迟卡顿严重</p>
<p>树莓派 ping 阿里云延迟很小：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081948699.png" alt="image-20221208194803656"><br>可能是阿里云带宽不足以支撑大数据量，只能降低分辨率和帧率</p>
<p>我的阿里云服务器只有 3M 带宽，计算一下合适的配置：</p>
<pre><code>3 * 1M/8 = 3 * 128KB = 384KB
</code></pre>
<p>理论上当分辨率 640x480 &#x3D; 300KB, fps 要设置为 1 才几乎无延迟</p>
<p>测试一： 分辨率&#x3D;640x480, fps&#x3D;5<br>结果：初始延迟在 1s 以内，之后延迟增加到几秒；</p>
<p>测试二： 分辨率&#x3D;640x480, fps&#x3D;1<br>结果：初始延迟在 0.5s 左右，半小时后延迟也稳定在1s以内，效果明显比 fps&#x3D;5 好；<br>测试符合理论预期，分辨率 和 FPS 要满足带宽</p>
<p>延迟的测试方法：手机计时，网页视频显示，放一起拍照，时间差即视频延迟<br>以下显示都在1分47秒，延迟小于 1s<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081948279.png" alt="image-20221208194813177"></p>
<p>注意: 树莓派长时间运行发热较明显，需要配散热片。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2021/07/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程笔记：使用GDB调试多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 15:29:31" itemprop="dateCreated datePublished" datetime="2021-07-15T15:29:31+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 10:26:47" itemprop="dateModified" datetime="2022-12-08T10:26:47+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-GDB简介"><a href="#1-GDB简介" class="headerlink" title="1.GDB简介"></a>1.GDB简介</h1><p>官网文档：<br><a target="_blank" rel="noopener" href="https://www.gnu.org/software/gdb/documentation/">GDB: The GNU Project Debugger</a></p>
<p>关于GDB的原理：<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1365186">GDB实现原理和使用范例</a><br><a target="_blank" rel="noopener" href="http://oenhan.com/gdb-principle">GDB工作原理和内核实现</a><br><a target="_blank" rel="noopener" href="http://www.docin.com/p-18618736.html">GDB的基本工作原理</a></p>
<p>其他教程：<a target="_blank" rel="noopener" href="http://c.biancheng.net/gdb/">GDB调试教程</a></p>
<p>几个重点：</p>
<ul>
<li>多种运行方式：gdb启动程序再调试(独立功能程序)，gdb attach进程再调试(服务端程序)，gdb加载core dump调试(离线调试)</li>
<li>GDB的本质是“截获”被调试程序，attach用ptrace截获了OS和应用程序之间的通信, 端点本质是trap中断，截获了CPU正常取指执行流程</li>
</ul>
<p>本文源码：<a target="_blank" rel="noopener" href="https://github.com/cursorhu/SimpleMultiThread/tree/master/4.gdb_thread">cursorhu&#x2F;SimpleMultiThread&#x2F;4.gdb_thread&#x2F;</a></p>
<h1 id="2-多线程程序的GDB调试"><a href="#2-多线程程序的GDB调试" class="headerlink" title="2.多线程程序的GDB调试"></a>2.多线程程序的GDB调试</h1><p>待调试代码：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;

int g_mydata = 0;
std::mutex g_mutex;

void thread_func1()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        if(g_mydata == 1024)
            g_mydata = 0;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);
    t1.join();
    t2.join();
    return 0;
&#125;
</code></pre>
<p>编译：</p>
<pre><code>g++ -g -std=c++11 cppthread.cpp -o cppthread -lpthread
</code></pre>
<p>-g: 带debug信息，gdb要用<br>-lpthread：链接pthread库。当应用直接调用POSIX&#x2F;pthread接口，或Linux环境中运行多线程都需要</p>
<h2 id="attach方式调试"><a href="#attach方式调试" class="headerlink" title="attach方式调试"></a>attach方式调试</h2><p>(1)后台运行并获取PID</p>
<ul>
<li>GDB调试已运行的程序，cppthread线程写成死循环，后台运行。</li>
<li>ps -ef | grep NAME 获取PID</li>
<li>pstree可以查看线程关系</li>
<li>LWP:轻量级进程，是用户线程和内核的中间接口。用户级线程连接LWP上便具有内核线程的所有属性。因此可以认为LWP ID对应线程ID</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534342.png" alt="1"></p>
<p>(2)gdb attach，管控进程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051544779.png" alt="2"></p>
<p>(3)查看所有线程信息<br>*表示当前在1号线程，注意这个ID是GDB attach后分配的，真实线程ID参考LWP<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051534546.png" alt="3"></p>
<p>(4)查看线程backtrace<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535566.png" alt="4"></p>
<p>(5)切换线程<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535346.png" alt="5"></p>
<p>(6)单步调试线程</p>
<ul>
<li>注意，GDB调试时是支持线程切换的，等同正常执行多线程，也可以禁用切换：<code>set scheduler-locking on</code>。本示例有mutex锁,未见到切换</li>
<li><code>next</code>: 单步（一步），<code>next n</code>: 单步n步</li>
<li><code>watch 变量</code>，可见<code>next 6</code>后g_mydata + 1</li>
<li><code>watch</code>会自动隐式的加断点，后文会看到断点信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535751.png" alt="6"></p>
<p>(7)断点</p>
<ul>
<li><code>break i</code>: 在代码i行加断点， <code>break func</code>:在函数加断点</li>
<li><code>clear i</code>: 清除i行的断点， <code>delete id</code>: 清除指定id的断点</li>
<li>注意看watch引入了一个断点11</li>
<li><code>continue</code>：继续执行，通常配合断点使用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535502.png" alt="7"></p>
<p>(8)线程外调试+多断点<br>两个工作线程都加断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535139.png" alt="8"><br>一次运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051535180.png" alt="9"><br>继续运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536672.png" alt="10"></p>
<ul>
<li>Thread2和Thread3即工作线程，Thread1为主线程</li>
<li>Thread1会切到工作线程，LWP&#x3D;6080或6081</li>
<li>两次运行,Thread1切到的LWP不一样</li>
</ul>
<p>GDB显示主线程切到哪个工作线程，实际是CPU当前在执行哪个工作线程，因此两次运行到断点时，当前执行线程分别是Thread2和Thread3，主线程实际是阻塞的。</p>
<h2 id="GDB直接运行程序"><a href="#GDB直接运行程序" class="headerlink" title="GDB直接运行程序"></a>GDB直接运行程序</h2><p>用GDB运行程序的调试方式：</p>
<pre><code> gdb &lt; prog_name &gt;
</code></pre>
<p>(1)运行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536065.png" alt="11"></p>
<p>(2)加断点和执行<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536275.png" alt="12"></p>
<p>(3)查看变量值<br><code>p 变量</code>：打印变量，和<code>watch</code>相比不会加隐含的断点<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051536108.png" alt="13"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051537112.png" alt="14"></p>
<h2 id="core-dump文件方式调试"><a href="#core-dump文件方式调试" class="headerlink" title="core dump文件方式调试"></a>core dump文件方式调试</h2><p>有关core dump<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/computer1-2-3/p/11114981.html">Linux 下如何产生core文件（core dump设置）</a><br><a target="_blank" rel="noopener" href="https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/">Understand and configure core dumps on Linux</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/uhziel/p/cpp_segmentation_fault.html">C++中段错误的常见情况</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xuzhina/category_1322964.html">coredump问题原理探究(Linux版)
</a></p>
<p>下面修改前面的程序，制造core dump<br>(1)数组越界<br>cppthread_dump_array.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int g_mydata = 0;
std::mutex g_mutex;

char test_dump_buf[10] = &#123;0&#125;;

void thread_func1()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        ++g_mydata;
        char c;
        sprintf(&amp;c, &quot;%d&quot;, g_mydata);
        std::strcat(test_dump_buf, &amp;c); //持续追加g_mydata字符串
        if(g_mydata == 1024)
            g_mydata = 0;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2()
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;test_dump_buf: &quot; &lt;&lt; test_dump_buf &lt;&lt; std::endl;
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538738.png" alt="15"><br>并未发生段错误，更不谈core dump。因为CPP对数组没有越界限制，这是个“合法”行为</p>
<p>(2)使用空指针<br>cppthread_dump_nullptr.cpp：</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
&#123;
    public:
        Foo(int m)
        &#123;
            m_data = m;
        &#125;
        ~Foo()&#123;&#125;
        void printval() 
        &#123;
            std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
        &#125;
        void increase()
        &#123;
            ++m_data;
        &#125;
        int getval()
        &#123;
            return m_data;
        &#125;
        void resetval()
        &#123;
            m_data = 0;
        &#125;
        
    private:
        int m_data;
&#125;;

void thread_func1(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.increase();
        if(p.getval() == 1024)
            p.resetval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.printval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;    
    Foo *pFoo = new Foo(0);

    std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
    std::thread t2(thread_func2, std::ref(*pFoo));

    //t1.join();  //这里故意不join
    //t2.join();
    sleep(10);  //sleep等一下thread1,2
    
    delete pFoo; 
    pFoo = NULL;  //这时thread1,2还没执行完，形成了使用空指针的条件
            
    return 0;
&#125;
</code></pre>
<p>运行结果：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538644.png" alt="16"></p>
<p>下面gdb调试这个core dump</p>
<ul>
<li><p>设置core dump文件大小限制为不受限<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538876.png" alt="17"><br>最好写入配置文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538835.png" alt="18"></p>
</li>
<li><p>gdb加载程序和core dump文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538139.png" alt="19"><br>可见siganl 6发生，使进程终止</p>
</li>
<li><p>看dump位置，bt或where都可以<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538557.png" alt="20"></p>
</li>
<li><p>看所有线程的栈<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051538027.png" alt="21"></p>
</li>
<li><p>直接看dump附近的代码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051539217.png"></p>
</li>
</ul>
<p>结论：根据bt&#x2F;where, dump发生时，主进程在在执行67行：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542767.png" alt="image-20221205154207720"></p>
<p>根据源码，具体是工作线程调用对象的方法时发生<br>再看dump打印，正好要打印<code>m_data = 10</code>的时候dump，结合main中sleep(10)和工作线程sleep(1)，dump原因是main把对象指针置空了，而两个工作线程还在调用对象的方法，位置是thread_func2的p.printval()处</p>
<h2 id="一个示例：调试死锁"><a href="#一个示例：调试死锁" class="headerlink" title="一个示例：调试死锁"></a>一个示例：调试死锁</h2><p>最常见的死锁是双重加锁，和双重delete的道理一样，代码复杂了，层层调用的情况下容易出现<br>示例代码cppthread_deadlock.cpp：<br>线程函数和其调用的类方法都加锁了，形成死锁</p>
<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt; //for linux sleep()

std::mutex g_mutex;

class Foo 
&#123;
    public:
        Foo(int m)
        &#123;
            m_data = m;
        &#125;
        ~Foo()&#123;&#125;
        void printval() 
        &#123;
            std::cout &lt;&lt; &quot;m_data = &quot; &lt;&lt; m_data &lt;&lt; std::endl;
        &#125;
        void increase()
        &#123;
            g_mutex.lock(); //故意制造双重加锁
            ++m_data;
            g_mutex.unlock();
        &#125;
        int getval()
        &#123;
            return m_data;
        &#125;
        void resetval()
        &#123;
            m_data = 0;    
        &#125;
        
    private:
        int m_data;
&#125;;

void thread_func1(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.increase();
        if(p.getval() == 1024)
            p.resetval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

void thread_func2(Foo&amp; p)
&#123;
    while (true)
    &#123;
        g_mutex.lock();
        p.printval();
        g_mutex.unlock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    &#125;
&#125;

int main()
&#123;    
    Foo *pFoo = new Foo(0);

    std::thread t1(thread_func1, std::ref(*pFoo)); //std::ref用于std::thread传入参数，以引用的形式
    std::thread t2(thread_func2, std::ref(*pFoo));

    t1.join();
    t2.join();
    
    delete pFoo;
    pFoo = NULL;
            
    return 0;
&#125;
</code></pre>
<p>调试：</p>
<ul>
<li>直接运行方式，要run起来才有线程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051542989.png" alt="23"></p>
<ul>
<li>backtrace可见两个线程都停止于lock_wait()，其中thread2回溯看到死锁代码在45行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051546645.png" alt="24"></p>
<p>对于互斥锁推荐用RAII机制的<code>std::lock_guard&lt;mutex&gt; lockGuard(m)</code>，能避免忘记unlock情况。但在此示例中，lock_guard也会双重加锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
