<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/my_icon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/my_icon/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/my_icon/manifest.json">
  <meta name="msapplication-config" content="/images/my_icon/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/3/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy | 化繁为简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--Firmware%20Architecture%20part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL%20API%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--Firmware%20Architecture%20part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL%20API%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">STM32--Firmware Architecture part1：开发环境和HAL API应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:50:28" itemprop="dateModified" datetime="2025-11-18T10:50:28+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32/" itemprop="url" rel="index"><span itemprop="name">STM32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–Firmware-Architecture-part1：开发环境和HAL-API应用"><a href="#STM32–Firmware-Architecture-part1：开发环境和HAL-API应用" class="headerlink" title="STM32–Firmware Architecture part1：开发环境和HAL API应用"></a>STM32–Firmware Architecture part1：开发环境和HAL API应用</h1><h1 id="STM32–开发环境"><a href="#STM32–开发环境" class="headerlink" title="STM32–开发环境"></a>STM32–开发环境</h1><p>当前主流的几种方案：(软件免费，无法律风险)：</p>
<p>1.STM32CubeMX + Keil（社区版）+ VSCode：使用CubeMX快速创建工程并导出为MDK-ARM项目文件，使用Keil编译调试MDK-ARM项目包，使用VSCode编辑代码和版本管理。</p>
<p>优势：兼容老项目，资料最多；Keil的调试经验可以复用到其他非STM32 ARM芯片；</p>
<p><a target="_blank" rel="noopener" href="https://www.keil.arm.com/mdk-community/">https://www.keil.arm.com/mdk-community/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubemx.html">https://www.st.com/en/development-tools/stm32cubemx.html</a></p>
<p>2.STM32CubeIDE：ST主推的方式，专用于ST32芯片的IDE，本质是STM32CubeMX + Eclipse IDE + ST的编译调试工具链。</p>
<p>优势：集成度最高；缺陷：只用于STM32</p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubeide.html#overview">https://www.st.com/en/development-tools/stm32cubeide.html#overview</a></p>
<p>3.VSCode + ARM&#x2F;ST插件 + GDB + OpenOCD + + STM32CubeMX</p>
<p>优势：通用性最强，对各类ARM&#x2F;RISCV等SOC都适用此方案。</p>
<p>缺陷：资料少，GDB debug效率没有Keil高。</p>
<p><a target="_blank" rel="noopener" href="https://stm32world.com/wiki/STM32_development_and_debugging_using_VSCode">https://stm32world.com/wiki/STM32_development_and_debugging_using_VSCode</a></p>
<p>结论：对于生产环境的STM32开发还是首选方案1，Keil社区版的功能和付费版基本一致。</p>
<h1 id="STM32–必读手册和固件"><a href="#STM32–必读手册和固件" class="headerlink" title="STM32–必读手册和固件"></a>STM32–必读手册和固件</h1><h2 id="STM32开发手册"><a href="#STM32开发手册" class="headerlink" title="STM32开发手册"></a>STM32开发手册</h2><p>helps-&gt;docs &amp; resource, 下载F0系列的：</p>
<p>Data Sheet(DS), Reference Manual(RM), Programming Manual(PM). </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101741846.png" alt="image-20240510174102795"></p>
<p>此外还有F1系列才有的<strong>User Manual UM1850</strong>，里面详细介绍各外设Driver的设计标准和API如何使用，对F0的Firmware也是通用，去ST官网下载。</p>
<h2 id="STM32固件包"><a href="#STM32固件包" class="headerlink" title="STM32固件包"></a>STM32固件包</h2><p>CubeMX&#x2F;CubeMXIDE首次运行STM32工程会要求安装STM32FXX的固件包，路径：CubeMX工程管理页面 -&gt; Firmware Package Path</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101708801.png" alt="image-20240510170810653"></p>
<p>原厂固件包的作用：</p>
<p>1.固件包是MCU厂商提供，学习任何一种MCU应该首先参考原厂固件包，不然容易被第三方教程误导。</p>
<p>2.对于STM32CubeMX, 其创建工程的原理是从固件包拷贝现成的模板代码，再根据用户在GUI界面配置的外设功能参数，自动输出项目代码。这个操作类似于VisualStudio开发MFC&#x2F;WinForm GUI应用，GUI模块被自动生成C#代码。</p>
<p>对于STM32F072xb的固件包，重点关注：</p>
<p>1.固件说明文档：STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Documentation\STM32CubeF0GettingStarted.pdf</p>
<p>2.模板代码和示例代码：STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Projects\STM32072B_EVAL\Examples</p>
<p>3.User Manual：整个固件库的代码文档，一般用HAL库关键词索引完整API定义</p>
<p>STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Drivers\STM32F0xx_HAL_Driver\STM32F072xB_User_Manual.chm</p>
<h2 id="小结：STM32项目的代码架构"><a href="#小结：STM32项目的代码架构" class="headerlink" title="小结：STM32项目的代码架构"></a>小结：STM32项目的代码架构</h2><p>根据开发手册和固件包文档做个小结。</p>
<p>STM32固件的架构，这也是STM32 Firmware项目的基本架构：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131502283.png" alt="image-20240513150236222"></p>
<ol>
<li>HAL和LL APIs是ST提供的STM32 chipset API，目的是hide theMCU and peripheral complexity to end user</li>
</ol>
<p>区别：</p>
<p>HAL drivers offer high-level and function-oriented APIs, with a high level of portability. Product&#x2F;IPs complexity is hidden for end users.</p>
<p>LL drivers offer low-layer APIs at registers level, with a better optimization but less portability. They require a deep knowledge of product&#x2F;IPs specifications.</p>
<p>HAL可以理解为硬件协议层，不直接配置register level，只实现通信协议和硬件配置流程。</p>
<p>LL是register level，完全不涉及通信协议和设备流程性的配置。</p>
<p>SysTick interrupts 只能在HAL使用，LL API无法调用SysTick interrupts，因为SysTick实际上是Hardware Timer的应用，而不是操作timer本身。</p>
<ol start="2">
<li><p>CMSIS（Cortex Microcontroller Software Interface Standard)  ARM指定的Cortex-M 硬件抽象层标准</p>
</li>
<li><p>Middleware：相当于应用层的基础库。The middleware is a set of libraries covering USB Device Libraries, STMTouch touch sensing, STemWin, FreeRTOS and FatFS</p>
</li>
</ol>
<h1 id="STM32–编译过程"><a href="#STM32–编译过程" class="headerlink" title="STM32–编译过程"></a>STM32–编译过程</h1><p>对于嵌入式代码的分析，首先应该看Makefile，去总览项目结构和编译过程。</p>
<p>以下有两种编译生态：</p>
<ol>
<li><p>Keil style：在Keil中编译MDK-ARM工程，编译过程被Keil隐藏到项目配置中；</p>
</li>
<li><p>Makefile style：CubeMX将MDK-ARM工程输出为Makefile工程，能一次看清整个编译过程。</p>
</li>
</ol>
<h2 id="Keil-style"><a href="#Keil-style" class="headerlink" title="Keil style"></a>Keil style</h2><h3 id="Keil编译配置"><a href="#Keil编译配置" class="headerlink" title="Keil编译配置"></a>Keil编译配置</h3><p>指定ARM编译器，指定代码目标是RAM\Flash位置的基地址</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102037591.png" alt="image-20240510203738554"></p>
<p>指定输出文件</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039243.png" alt="image-20240510203910212"></p>
<p>链接输出的符号总览文件.map</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039879.png" alt="image-20240510203928847"></p>
<p>编译的后处理过程，从hex生产bin</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102040886.png" alt="image-20240510204028853"></p>
<p>指定代码优化级别，警告级别，语言标准；指定头文件，组合成编译参数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102042899.png" alt="image-20240510204213867"></p>
<p>指定汇编器，一些伪汇编符号语法(syntax)和汇编器类型相关，例如Arm syntax和GUN syntax有很大差异</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102043211.png" alt="image-20240510204344181"></p>
<p>指定链接文件(scatter file), 功能对应Makefile的.ld链接脚本文件，用于指定各段分布。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102047297.png" alt="image-20240510204720264"></p>
<p>Debug和JLink烧录的配置，这里勾选JLink烧录后自动reset启动新程序:</p>
<p>这里实际是Keil调用JFlash烧写，需要指定Flash地址和大小，一般和Keil项目配置的ROM区间一致</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405170952108.png" alt="image-20240517095249013"></p>
<p>项目的目录配置中指定哪些.c参与编译:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102059394.png" alt="image-20240510205959362"></p>
<h3 id="Keil链接配置"><a href="#Keil链接配置" class="headerlink" title="Keil链接配置"></a>Keil链接配置</h3><p>Keil的链接脚本是.sct文件，链接配置的主要作用是在对.o文件链接时，指定链接基础地址，指定排列顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LR_IROM1 0x08000000 0x00020000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00020000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00004000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个比较重要的概念：</p>
<ol>
<li>加载域与执行域</li>
</ol>
<p>LR： Load Address，MCU从哪个空间加载代码</p>
<p>ER：Execute Address，MCU在哪个空间执行代码</p>
<p>以上STM32链接脚本，所有Flash的代码(IROM: *.o, RO, XO)的执行域和加载域都是Flash(0x08000000 ~ 0x00020000)，且指定bootloader entry：RESET为最开始执行的函数。</p>
<p>RAM的代码(IRAM: RW, ZI)加载域是SRAM，这部分是数据是运行时直接在RAM初始化，不需要从Flash取指令。</p>
<p><img src="https://img-blog.csdnimg.cn/d8d908434dad4d18b654fdbefa5778b9.png#pic_center" alt="img"></p>
<p>下图示例是执行Flash的RO data时，RW数据段（有初始值的数据）应该被bootloader拷贝到RAM。</p>
<p><img src="https://img-blog.csdnimg.cn/fa87d75e57db492e8a86582baf8971be.png#pic_center" alt="img"></p>
<ol start="2">
<li>代码段，数据段，BSS段…</li>
</ol>
<p>STM32的代码段分布如下表, 其中CODE（包括RO&#x2F;RW CODE和TEXT），DATA(RO&#x2F;RW DATA)，ZI(BSS) 即常规意义的可执行程序的三段。</p>
<p>在.sct链接脚本中对应：RO，RW和ZI(zero initialized )<br>      RO是程序中的指令和常量<br>      RW是程序中已初始化变量<br>      ZI是程序中未初始化或初始化为0的变量</p>
<p><img src="https://img-blog.csdnimg.cn/4ccfeec4537a4a40ad5a8102707c2705.png" alt="img"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/apythonlearner/article/details/133034055">【STM32】sct 分散加载文件的格式与应用</a></p>
<h2 id="Makefile-style"><a href="#Makefile-style" class="headerlink" title="Makefile style"></a>Makefile style</h2><h3 id="makefile编译配置"><a href="#makefile编译配置" class="headerlink" title="makefile编译配置"></a>makefile编译配置</h3><p>将已有的CubeMX+MDK工程输出为Makefile工程，产生Makefile和STM32F072C8Tx_FLASH.ld文件.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102056555.png" alt="image-20240510205610521"></p>
<p>Makefile分析：</p>
<p>指定编译目标，debug和优化级别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># target</span><br><span class="line">TARGET = stm32f072c8t6</span><br><span class="line"># debug build?</span><br><span class="line">DEBUG = 1</span><br><span class="line"># optimization</span><br><span class="line">OPT = -Og</span><br></pre></td></tr></table></figure>

<p>指定参与编译的源码.c和.s  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># C sources</span><br><span class="line">C_SOURCES =  \</span><br><span class="line">Core/Src/main.c \</span><br><span class="line">Core/Src/gpio.c \</span><br><span class="line">Core/Src/can.c \</span><br><span class="line">Core/Src/i2c.c \</span><br><span class="line">Core/Src/spi.c \</span><br><span class="line">Core/Src/usart.c \</span><br><span class="line">Core/Src/stm32f0xx_it.c \</span><br><span class="line">Core/Src/stm32f0xx_hal_msp.c \</span><br><span class="line">....</span><br><span class="line">Core/Src/system_stm32f0xx.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_ctlreq.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_ioreq.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Class/CustomHID/Src/usbd_customhid.c \</span><br><span class="line">Core/Src/sysmem.c \</span><br><span class="line">Core/Src/syscalls.c </span><br><span class="line"></span><br><span class="line"># ASM sources</span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">startup_stm32f072xb.s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定目标平台的编译器和链接器，指定输出hex&#x2F;bin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PREFIX = arm-none-eabi-</span><br><span class="line"></span><br><span class="line">CC = $(PREFIX)gcc</span><br><span class="line">AS = $(PREFIX)gcc -x assembler-with-cpp</span><br><span class="line">CP = $(PREFIX)objcopy</span><br><span class="line">SZ = $(PREFIX)size</span><br><span class="line"></span><br><span class="line">HEX = $(CP) -O ihex</span><br><span class="line">BIN = $(CP) -O binary -S</span><br></pre></td></tr></table></figure>

<p>编译参数CFLAGS和ASFLAGS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU = -mcpu=cortex-m0</span><br><span class="line"># float-abi</span><br><span class="line">MCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)</span><br></pre></td></tr></table></figure>

<p>宏定义和头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># macros for gcc</span><br><span class="line"># AS defines</span><br><span class="line">AS_DEFS = </span><br><span class="line"></span><br><span class="line"># C defines</span><br><span class="line">C_DEFS =  \</span><br><span class="line">-DUSE_HAL_DRIVER \</span><br><span class="line">-DSTM32F072xB</span><br><span class="line"></span><br><span class="line"># AS includes</span><br><span class="line">AS_INCLUDES = </span><br><span class="line"></span><br><span class="line"># C includes</span><br><span class="line">C_INCLUDES =  \</span><br><span class="line">-ICore/Inc \</span><br><span class="line">-IUSB_DEVICE/App \</span><br><span class="line">-IUSB_DEVICE/Target \</span><br><span class="line">-IDrivers/STM32F0xx_HAL_Driver/Inc \</span><br><span class="line">-IDrivers/STM32F0xx_HAL_Driver/Inc/Legacy \</span><br><span class="line">-IMiddlewares/ST/STM32_USB_Device_Library/Core/Inc \</span><br><span class="line">-IMiddlewares/ST/STM32_USB_Device_Library/Class/CustomHID/Inc \</span><br><span class="line">-IDrivers/CMSIS/Device/ST/STM32F0xx/Include \</span><br><span class="line">-IDrivers/CMSIS/Include</span><br></pre></td></tr></table></figure>

<p>最终的完整GCC FLAGS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># compile gcc flags</span><br><span class="line">ASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line">CFLAGS += $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br></pre></td></tr></table></figure>

<p>链接脚本与库路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># link script</span><br><span class="line">LDSCRIPT = STM32F072C8Tx_FLASH.ld</span><br><span class="line"></span><br><span class="line"># libraries</span><br><span class="line">LIBS = -lc -lm -lnosys </span><br><span class="line">LIBDIR = </span><br><span class="line">LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections</span><br></pre></td></tr></table></figure>

<p>输出文件：elf + hex + bin，参考：[elf,hex,bin,axf的区别](# elf,hex,bin,axf的区别)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># default action: build all</span><br><span class="line">all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin</span><br></pre></td></tr></table></figure>

<p>编译执行部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># list of objects</span><br><span class="line">OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))</span><br><span class="line">vpath %.c $(sort $(dir $(C_SOURCES)))</span><br><span class="line"># list of ASM program objects</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))</span><br><span class="line">vpath %.s $(sort $(dir $(ASM_SOURCES)))</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASMM_SOURCES:.S=.o)))</span><br><span class="line">vpath %.S $(sort $(dir $(ASMM_SOURCES)))</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) </span><br><span class="line">	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)</span><br><span class="line">	$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(BUILD_DIR)/%.o: %.S Makefile | $(BUILD_DIR)</span><br><span class="line">	$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile</span><br><span class="line">	$(CC) $(OBJECTS) $(LDFLAGS) -o $@</span><br><span class="line">	$(SZ) $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	$(HEX) $&lt; $@</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	$(BIN) $&lt; $@	</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR):</span><br><span class="line">	mkdir $@</span><br></pre></td></tr></table></figure>

<p>清理编译输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	-rm -fR $(BUILD_DIR)</span><br></pre></td></tr></table></figure>

<h3 id="makefile链接配置"><a href="#makefile链接配置" class="headerlink" title="makefile链接配置"></a>makefile链接配置</h3><p>GNU linker（LD）的语法参考：<a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/index.html">GNU linker ld (GNU Binutils)</a></p>
<p>STM32F072C8Tx_FLASH.ld：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* Entry Point */</span><br><span class="line">ENTRY(Reset_Handler)</span><br><span class="line"></span><br><span class="line">/* Highest address of the user mode stack */</span><br><span class="line">_estack = ORIGIN(RAM) + LENGTH(RAM);    /* end of RAM */</span><br><span class="line">/* Generate a link error if heap and stack don&#x27;t fit into RAM */</span><br><span class="line">_Min_Heap_Size = 0x300;      /* required amount of heap  */</span><br><span class="line">_Min_Stack_Size = 0x500; /* required amount of stack */</span><br><span class="line"></span><br><span class="line">/* Specify the memory areas */</span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 16K</span><br><span class="line">FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 64K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Define output sections */</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* The startup code goes first into FLASH */</span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    KEEP(*(.isr_vector)) /* Startup code */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* The program code and other data goes into FLASH */</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.text)           /* .text sections (code) */</span><br><span class="line">    *(.text*)          /* .text* sections (code) */</span><br><span class="line">    *(.glue_7)         /* glue arm to thumb code */</span><br><span class="line">    *(.glue_7t)        /* glue thumb to arm code */</span><br><span class="line">    *(.eh_frame)</span><br><span class="line"></span><br><span class="line">    KEEP (*(.init))</span><br><span class="line">    KEEP (*(.fini))</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _etext = .;        /* define a global symbols at end of code */</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* Constant data goes into FLASH */</span><br><span class="line">  .rodata :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.rodata)         /* .rodata sections (constants, strings, etc.) */</span><br><span class="line">    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH</span><br><span class="line">  .ARM : &#123;</span><br><span class="line">    __exidx_start = .;</span><br><span class="line">    *(.ARM.exidx*)</span><br><span class="line">    __exidx_end = .;</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .preinit_array     :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_start = .);</span><br><span class="line">    KEEP (*(.preinit_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .init_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.init_array.*)))</span><br><span class="line">    KEEP (*(.init_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .fini_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.fini_array.*)))</span><br><span class="line">    KEEP (*(.fini_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* used by the startup to initialize data */</span><br><span class="line">  _sidata = LOADADDR(.data);</span><br><span class="line"></span><br><span class="line">  /* Initialized data sections goes into RAM, load LMA copy after code */</span><br><span class="line">  .data : </span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _sdata = .;        /* create a global symbol at data start */</span><br><span class="line">    *(.data)           /* .data sections */</span><br><span class="line">    *(.data*)          /* .data* sections */</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _edata = .;        /* define a global symbol at data end */</span><br><span class="line">  &#125; &gt;RAM AT&gt; FLASH</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  /* Uninitialized data section */</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  .bss :</span><br><span class="line">  &#123;</span><br><span class="line">    /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">    _sbss = .;         /* define a global symbol at bss start */</span><br><span class="line">    __bss_start__ = _sbss;</span><br><span class="line">    *(.bss)</span><br><span class="line">    *(.bss*)</span><br><span class="line">    *(COMMON)</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _ebss = .;         /* define a global symbol at bss end */</span><br><span class="line">    __bss_end__ = _ebss;</span><br><span class="line">  &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">  /* User_heap_stack section, used to check that there is enough RAM left */</span><br><span class="line">  ._user_heap_stack :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">    PROVIDE ( end = . );</span><br><span class="line">    PROVIDE ( _end = . );</span><br><span class="line">    . = . + _Min_Heap_Size;</span><br><span class="line">    . = . + _Min_Stack_Size;</span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">  &#125; &gt;RAM</span><br></pre></td></tr></table></figure>

<h2 id="编译输出-elf-hex-bin-axf的区别"><a href="#编译输出-elf-hex-bin-axf的区别" class="headerlink" title="编译输出: elf,hex,bin,axf的区别"></a>编译输出: elf,hex,bin,axf的区别</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131142491.png" alt="image-20240513114246442"></p>
<h2 id="链接输出的-map符号表"><a href="#链接输出的-map符号表" class="headerlink" title="链接输出的.map符号表"></a>链接输出的.map符号表</h2><p>链接过程可以输出.map符号表，可用于分析代码和数据分布，再裁剪代码。</p>
<ol>
<li>ROM(Flash)的.hex&#x2F;bin文件的符号分布:</li>
</ol>
<p>可以看到，.sct指定的首个符号RESET在最开始位置，其他符号是链接器自动排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Memory Map of the image</span><br><span class="line"></span><br><span class="line">  Image Entry point : 0x080000c1</span><br><span class="line"></span><br><span class="line">  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x000082f0, Max: 0x00020000, ABSOLUTE, COMPRESSED[0x00008148])</span><br><span class="line"></span><br><span class="line">    Execution Region ER_IROM1 (Exec base: 0x08000000, Load base: 0x08000000, Size: 0x00007f84, Max: 0x00020000, ABSOLUTE)</span><br><span class="line"></span><br><span class="line">    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object</span><br><span class="line"></span><br><span class="line">    0x08000000   0x08000000   0x000000c0   Data   RO            3    RESET               startup_stm32f072xb.o</span><br><span class="line">    0x080000c0   0x080000c0   0x00000000   Code   RO         2440  * .ARM.Collect$$$$00000000  mc_p.l(entry.o)</span><br><span class="line">    0x080000c0   0x080000c0   0x00000004   Code   RO         2728    .ARM.Collect$$$$00000001  mc_p.l(entry2.o)</span><br><span class="line">    0x080000c4   0x080000c4   0x00000004   Code   RO         2731    .ARM.Collect$$$$00000004  </span><br><span class="line">    </span><br><span class="line">    ....         </span><br><span class="line"></span><br><span class="line">mc_p.l(init.o)</span><br><span class="line">    0x08000244   0x08000244   0x00000020   Code   RO         2768    .text               mc_p.l(llshl.o)</span><br><span class="line">    0x08000264   0x08000264   0x00000056   Code   RO         2784    .text               mc_p.l(__dczerorl2.o)</span><br><span class="line">    0x080002ba   0x080002ba   0x00000002   PAD</span><br><span class="line">    0x080002bc   0x080002bc   0x00000064   Code   RO          769    .text.CDC_Control_FS  usbd_cdc_if.o</span><br><span class="line">    0x08000320   0x08000320   0x00000004   Code   RO          767    .text.CDC_DeInit_FS  usbd_cdc_if.o</span><br><span class="line">    0x08000324   0x08000324   0x00000024   Code   RO          765    .text.CDC_Init_FS   usbd_cdc_if.o</span><br><span class="line">    0x08000348   0x08000348   0x00000034   Code   RO          771    .text.CDC_Receive_FS  usbd_cdc_if.o</span><br><span class="line">    0x0800037c   0x0800037c   0x00000044   Code   RO          773    .text.CDC_Transmit_FS  usbd_cdc_if.o</span><br><span class="line">    0x080003c0   0x080003c0   0x00000010   Code   RO          136    .text.CEC_CAN_IRQHandler  stm32f0xx_it.o</span><br><span class="line">    0x080003d0   0x080003d0   0x00000004   Code   RO          750    .text.CUSTOM_HID_DeInit_FS  usbd_custom_hid_if.o</span><br><span class="line">    0x080003d4   0x080003d4   0x00000004   Code   RO          748    .text.CUSTOM_HID_Init_FS  usbd_custom_hid_if.o</span><br><span class="line"></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>RAM中的数据段分布，包括.data段和.bss段：</p>
<p>可以看到，有初始值和无初始值的全局变量分布在.data和.bss区域。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Execution Region RW_IRAM1 (Exec base: 0x20000000, Load base: 0x08007f88, Size: 0x000021b8, Max: 0x00004000, ABSOLUTE, COMPRESSED[0x000001c0])</span><br><span class="line"></span><br><span class="line">    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object</span><br><span class="line"></span><br><span class="line">    0x20000000   COMPRESSED   0x00000004   Data   RW         2742    .data               mc_p.l(stdout.o)</span><br><span class="line">    0x20000004   COMPRESSED   0x00000008   Data   RW         1117    .data..L_MergedGlobals  stm32f0xx_hal.o</span><br><span class="line">    0x2000000c   COMPRESSED   0x00000022   Data   RW          754    .data.CUSTOM_HID_ReportDesc_FS  usbd_custom_hid_if.o</span><br><span class="line">    0x2000002e   COMPRESSED   0x00000002   PAD</span><br><span class="line">    0x20000030   COMPRESSED   0x0000001c   Data   RW          733    .data.FS_Desc       usbd_desc.o</span><br><span class="line">    0x2000004c   COMPRESSED   0x00000004   Data   RW         2228    .data.SystemCoreClock  system_stm32f0xx.o</span><br><span class="line">    0x20000050   COMPRESSED   0x00000038   Data   RW         2427    .data.USBD_CDC      usbd_cdc.o</span><br><span class="line">    0x20000088   COMPRESSED   0x00000043   Data   RW         2429    .data.USBD_CDC_CfgFSDesc  usbd_cdc.o</span><br><span class="line">    0x200000cb   COMPRESSED   0x00000001   PAD</span><br><span class="line">    0x200000cc   COMPRESSED   0x00000043   Data   RW         2428    .data.USBD_CDC_CfgHSDesc  usbd_cdc.o</span><br><span class="line">    0x2000010f   COMPRESSED   0x00000001   PAD</span><br><span class="line">    0x20000110   COMPRESSED   0x0000000a   Data   RW         2431    .data.USBD_CDC_DeviceQualifierDesc  usbd_cdc.o</span><br><span class="line">    0x2000011a   COMPRESSED   0x00000002   PAD</span><br><span class="line">    0x2000011c   COMPRESSED   0x00000010   Data   RW          775    .data.USBD_CDC_Interface_fops_FS  usbd_cdc_if.o</span><br><span class="line">    0x2000012c   COMPRESSED   0x00000008   Data   RW          776    .data.USBD_CDC_LineCoding  usbd_cdc_if.o</span><br><span class="line">    0x20000134   COMPRESSED   0x00000043   Data   RW         2430    .data.USBD_CDC_OtherSpeedCfgDesc  usbd_cdc.o</span><br><span class="line">  </span><br><span class="line">  ....</span><br><span class="line">  </span><br><span class="line">    0x20000368        -       0x0000002c   Zero   RW           29    .bss..L_MergedGlobals  main.o</span><br><span class="line">    0x20000394        -       0x00000030   Zero   RW          287    .bss..L_MergedGlobals  systime.o</span><br><span class="line">    0x200003c4        -       0x00000024   Zero   RW          569    .bss..L_MergedGlobals  can.o</span><br><span class="line">    0x200003e8        -       0x00000048   Zero   RW          756    .bss..L_MergedGlobals  usbd_custom_hid_if.o</span><br><span class="line">    0x20000430        -       0x00000008   Zero   RW         2388    .bss..L_MergedGlobals  usbd_composite.o</span><br><span class="line">    0x20000438        -       0x00000400   Zero   RW           25    .bss.UART2_RxBuffer  main.o</span><br><span class="line">    0x20000838        -       0x00000001   Zero   RW         2299    .bss.USBD_SetConfig.cfgidx  usbd_ctlreq.o</span><br><span class="line">    0x20000839   COMPRESSED   0x00000003   PAD</span><br><span class="line">    0x2000083c        -       0x00000200   Zero   RW          737    .bss.USBD_StrDesc   usbd_desc.o</span><br><span class="line">    0x20000a3c        -       0x00000040   Zero   RW          778    .bss.UserRxBufferFS  usbd_cdc_if.o</span><br><span class="line">    0x20000a7c        -       0x00000040   Zero   RW          779    .bss.UserTxBufferFS  usbd_cdc_if.o</span><br><span class="line">    0x20000abc        -       0x00000001   Zero   RW          777    .bss.cdc_receive_flag  usbd_cdc_if.o</span><br><span class="line">    0x20000abd   COMPRESSED   0x00000003   PAD</span><br><span class="line">    0x20000ac0        -       0x000002c4   Zero   RW          712    .bss.hUsbDeviceFS   usb_device.o</span><br><span class="line">    0x20000d84        -       0x00000028   Zero   RW          568    .bss.hcan           can.o</span><br><span class="line">    0x20000dac        -       0x00000044   Zero   RW          109    .bss.hdma_usart2_rx  usart.o</span><br><span class="line">    0x20000df0        -       0x0000004c   Zero   RW           59    .bss.hi2c1          i2c.o</span><br><span class="line">    0x20000e3c        -       0x000002f4   Zero   RW          850    .bss.hpcd_USB_FS    usbd_conf.o</span><br><span class="line">    0x20001130        -       0x00000064   Zero   RW           77    .bss.hspi1          spi.o</span><br><span class="line">    0x20001194        -       0x00000048   Zero   RW          419    .bss.htim6          tim.o</span><br><span class="line">    0x200011dc        -       0x00000084   Zero   RW          106    .bss.huart1         usart.o</span><br><span class="line">    0x20001260        -       0x00000084   Zero   RW          107    .bss.huart2         usart.o</span><br><span class="line">    0x200012e4        -       0x00000084   Zero   RW          108    .bss.huart3         usart.o</span><br><span class="line">    0x20001368        -       0x00000001   Zero   RW          227    .bss.i2c_error      usb_handle.o</span><br><span class="line">    0x20001369        -       0x00000400   Zero   RW          239    .bss.inter_buffer   uart_data_analysis.o</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>输出的hex&#x2F;bin中，各.obj对应的Code， Data， ZI段大小：</p>
<p>可快速定位哪些代码占用Flash&#x2F;RAM空间过大。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Image component sizes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line">        26          4          0          0         76       4060   can.o</span><br><span class="line">        48          4          0          0          0       1769   dma.o</span><br><span class="line">       348          0          0          0          0       9083   fifo.o</span><br><span class="line">        92         16          0          0          0       3240   flash.o</span><br><span class="line">       258          0          0          0          0       4158   general_function.o</span><br><span class="line">       252         16          0          0          0       2882   gpio.o</span><br><span class="line">       428         72          0          0         76       7196   i2c.o</span><br><span class="line">         2          0          0          0          0      23860   jaguar.o</span><br><span class="line">       788        128          0          0       2092       8846   main.o</span><br><span class="line">       872        206         25          0        152      10137   one_wire.o</span><br><span class="line">       268         28          0         32        100       5426   spi.o</span><br><span class="line">        28          8        192          0       1280        656   startup_stm32f072xb.o</span><br><span class="line">       168         24          0          8          4       5420   stm32f0xx_hal.o</span><br><span class="line">       958          6          0          0          0      14230   stm32f0xx_hal_can.o</span><br><span class="line">       164         28          0          0          0       5576   stm32f0xx_hal_cortex.o</span><br><span class="line">       678         12          0          0          0       8163   stm32f0xx_hal_dma.o</span><br><span class="line">       694         32          0          0          0       4994   stm32f0xx_hal_gpio.o</span><br><span class="line">      1786         60          0          0          0      63508   stm32f0xx_hal_i2c.o</span><br><span class="line">       132          0          0          0          0       5319   stm32f0xx_hal_i2c_ex.o</span><br><span class="line">        44          4          0          0          0       1058   stm32f0xx_hal_msp.o</span><br><span class="line">      3124        100          0          0          0      15820   stm32f0xx_hal_pcd.o</span><br><span class="line">        96          0          0          0          0       5855   stm32f0xx_hal_pcd_ex.o</span><br><span class="line">      1672         52         32          0          0       8371   stm32f0xx_hal_rcc.o</span><br><span class="line">       328         12          0          0          0       6715   stm32f0xx_hal_rcc_ex.o</span><br><span class="line">      1544          8          0          0          0      27530   stm32f0xx_hal_spi.o</span><br><span class="line">       736         44          0          0          0      63633   stm32f0xx_hal_tim.o</span><br><span class="line">        96          0          0          0          0      22483   stm32f0xx_hal_tim_ex.o</span><br><span class="line">      2884         92         16          0          0      41313   stm32f0xx_hal_uart.o</span><br><span class="line">       122          0          0          0          0       8856   stm32f0xx_hal_uart_ex.o</span><br><span class="line">       106         20          0          0          0       2835   stm32f0xx_it.o</span><br><span class="line">      3540        152          0          0          0      23016   stm32f0xx_ll_usb.o</span><br><span class="line">         2          0         24          4          0       1745   system_stm32f0xx.o</span><br><span class="line">       236         36          0          0         48       2973   systime.o</span><br><span class="line">       152         20          0          0         72       5392   tim.o</span><br><span class="line">       160         12          0          0       1024       1279   uart_data_analysis.o</span><br><span class="line">       828         84          0          0        464       7567   usart.o</span><br><span class="line">        64         12          0          0        708       2859   usb_device.o</span><br><span class="line">      1268        120          0          0          1       9115   usb_handle.o</span><br><span class="line">       722         20          0        267         92      10062   usbd_cdc.o</span><br><span class="line">       260         24          0         24        129       4611   usbd_cdc_if.o</span><br><span class="line">       452         64          0        181          8       5864   usbd_composite.o</span><br><span class="line">       758         32          0          0        756      15665   usbd_conf.o</span><br><span class="line">       718          0          0          0          0       8036   usbd_core.o</span><br><span class="line">      1252         28          0          0          1       8339   usbd_ctlreq.o</span><br><span class="line">       140         16          0         50         72       3641   usbd_custom_hid_if.o</span><br><span class="line">       594         46          0        198         84       7979   usbd_customhid.o</span><br><span class="line">       504        144          0         76        512       4167   usbd_desc.o</span><br><span class="line">       162          0          0          0          0       4514   usbd_ioreq.o</span><br></pre></td></tr></table></figure>

<h1 id="STM32–启动过程"><a href="#STM32–启动过程" class="headerlink" title="STM32–启动过程"></a>STM32–启动过程</h1><p>本部分介绍从上电到进入main函数的过程。</p>
<h2 id="启动位置"><a href="#启动位置" class="headerlink" title="启动位置"></a>启动位置</h2><p>STM32能从Flash&#x2F;SRAM或System memory(远程)启动。启动位置直接决定链接脚本的加载和运行的基地址配置。</p>
<p>如何确认：</p>
<ol>
<li>查固件包Reference Manual：对于F0系列，由BOOT0 pin和nBOOT1 register bit决定启动位置。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131603031.png" alt="image-20240513160303987"></p>
<ol start="2">
<li>查开发板BOOT0 pin：下拉接地，因此开发板是Boot from Flash。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131605456.png" alt="image-20240513160533426"></p>
<ol start="3">
<li>顺便查一下nBOOT1 register：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131606693.png" alt="image-20240513160652648"></p>
<h2 id="startup-s"><a href="#startup-s" class="headerlink" title="startup.s"></a>startup.s</h2><p>根据链接脚本指定的asm找到启动文件startup_stm32f072xb.s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ASM sources</span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">startup_stm32f072xb.s</span><br></pre></td></tr></table></figure>

<p>根据链接脚本的RESET符号，找到CPU复位时执行指令的入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp                   ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                  ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                    ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler              ; Hard Fault Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SVC_Handler                    ; SVCall Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     PendSV_Handler                 ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler                ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">                DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">                DCD     RCC_IRQHandler                 ; RCC</span><br><span class="line">                DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">                DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">                DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">                DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">                DCD     DMA1_Channel4_5_IRQHandler     ; DMA1 Channel 4 and Channel 5</span><br><span class="line">                DCD     ADC1_IRQHandler                ; ADC1 </span><br><span class="line">                DCD     TIM1_BRK_UP_TRG_COM_IRQHandler ; TIM1 Break, Update, Trigger and Commutation</span><br><span class="line">                DCD     TIM1_CC_IRQHandler             ; TIM1 Capture Compare</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM3_IRQHandler                ; TIM3</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM14_IRQHandler               ; TIM14</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM16_IRQHandler               ; TIM16</span><br><span class="line">                DCD     TIM17_IRQHandler               ; TIM17</span><br><span class="line">                DCD     I2C1_IRQHandler                ; I2C1</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SPI1_IRQHandler                ; SPI1</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     USART1_IRQHandler              ; USART1</span><br><span class="line">                DCD     USART2_IRQHandler              ; USART2</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     USB_IRQHandler                 ; USB</span><br><span class="line"></span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure>

<p>这里面的AREA&#x2F;DCD等伪汇编符号含义，参考[指令集与伪汇编](# 指令集与伪汇编)</p>
<p>以上代码声明了中断向量表，定义CPU中断、异常发生时的入口地址。</p>
<p>STM32 中断向量表的定义参考固件包Program Manual：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131542062.png" alt="image-20240513154213024"></p>
<p>MCU启动或者reset时：</p>
<p>PC指针从0x0: __initial_sp取指令，<del>此处没任何内容</del>  此处不是个指令，而是栈顶指针的值，由编译器根据代码量+StackSize自动生成；《STM32–Firmware Architecture part2》详细分析如何生成。</p>
<p>然后PC + 4，从0x4取指令，即执行Reset_Handler：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler routine</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler                 [WEAK]</span><br><span class="line">        IMPORT  __main</span><br><span class="line">        IMPORT  SystemInit  </span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>

<p>这里先后执行SystemInit和__main</p>
<ol>
<li>SystemInit的作用如下，o2link代码没有用此函数（空）</li>
</ol>
<p>This function is called at startup just after reset and before branch to main program. User can setups the default system clock (System clock source, PLL Multiplier and Divider factors, AHB&#x2F;APBx prescalers and Flash settings</p>
<ol start="2">
<li>__main符号即C的main函数 <em>int</em> main(<em>void</em>)，从此进入C代码执行。</li>
</ol>
<h2 id="指令集与伪汇编"><a href="#指令集与伪汇编" class="headerlink" title="指令集与伪汇编"></a>指令集与伪汇编</h2><p>指令集：MCU硬件决定的指令，例如STM32是Cortex M0指令集。 详见固件包Program Manual。</p>
<p>伪汇编指令：是编译器扩展的汇编语法，取决于编译器类型。根据汇编器找user guide，例如 armasm：</p>
<p><a target="_blank" rel="noopener" href="https://documentation-service.arm.com/static/63eb50c09567172d4e2aa777">https://documentation-service.arm.com/static/63eb50c09567172d4e2aa777</a></p>
<ol>
<li>Cortex M0指令集：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557835.png" alt="image-20240513155719763"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557727.png" alt="image-20240513155736664"></p>
<ol start="2">
<li>armasm的一些伪汇编指令：</li>
</ol>
<blockquote>
<p>AREA:声明一块区域的属性，例如：AREA A64ex, CODE, READONLY;  Name this block of code A64ex</p>
<p>EXPORT：使符号对其他文件可见。Labels are local to the source file unless you make them global using the EXPORT directive  </p>
<p>DCD: Declares one or more words of store. 声明一块区域，如果区域是函数符号表示声明该函数所占用的区域。</p>
</blockquote>
<h1 id="STM32–main初始化流程"><a href="#STM32–main初始化流程" class="headerlink" title="STM32–main初始化流程"></a>STM32–main初始化流程</h1><h2 id="HAL-Init"><a href="#HAL-Init" class="headerlink" title="HAL_Init"></a>HAL_Init</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">	HAL_Init();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */</span><br><span class="line">HAL_InitTick(TICK_INT_PRIORITY);</span><br><span class="line">--&gt; HAL_SYSTICK_Config: Configure the SysTick to have interrupt in 1ms time basis</span><br><span class="line">--&gt; HAL_NVIC_SetPriority: Configure the SysTick IRQ priority</span><br></pre></td></tr></table></figure>

<ol>
<li>关于HAL_SYSTICK_Config的底层实现（参考HAL user manual.chm：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00043    (+) The HAL_SYSTICK_Config()function calls the SysTick_Config() function which</span><br><span class="line">00044        is a CMSIS function that:</span><br><span class="line">00045         (++) Configures the SysTick Reload register with value passed as function parameter.</span><br><span class="line">00046         (++) Configures the SysTick IRQ priority to the lowest value (0x03).</span><br><span class="line">00047         (++) Resets the SysTick Counter register.</span><br><span class="line">00048         (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).</span><br><span class="line">00049         (++) Enables the SysTick Interrupt.</span><br><span class="line">00050         (++) Starts the SysTick Counter.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关于systick的NVIC中断优先级：</li>
</ol>
<p> * <em>@note</em> In the default implementation, SysTick timer is the source of time base. </p>
<p> *    It is used to generate interrupts at regular time intervals. </p>
<p> *    Care must be taken if HAL_Delay() is called from a peripheral ISR process, </p>
<p> *    The SysTick interrupt must have higher priority (numerically lower) </p>
<p> *    than the peripheral interrupt. Otherwise the caller ISR process will be blocked.</p>
<ol start="3">
<li>STM32 所有的中断和异常的优先级总表，参考Reference Manual：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131633379.png" alt="image-20240513163316319"></p>
<h2 id="SystemClock-Config"><a href="#SystemClock-Config" class="headerlink" title="SystemClock_Config"></a>SystemClock_Config</h2><ol>
<li>整个时钟树配置参数可以在CubeMX初始化项目时配置，系统时钟SYSCLK有外部HSE（8M OSC）和内部HSI（内部RC）多个源，由下图当前配置生效的是HSI 48M RC作为源。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131647697.png" alt="image-20240513164731624"></p>
<p>不同外设模式对时钟树的要求：</p>
<blockquote>
<p>I2c input frequency should up to 48M to support 1M i2c clock.</p>
<p>UART input frequency should be changed to HIS 8M to support lower than 1K baud rate and changed to 48M to support 1M baud rate.</p>
<p>USB modules need 48M input frequency</p>
</blockquote>
<ol start="2">
<li>系统时钟配置过程：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Configure the system clock */</span><br><span class="line">	SystemClock_Config();</span><br></pre></td></tr></table></figure>

<p>主要分两步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Initializes the RCC Oscillators</span><br><span class="line">Initializes the CPU, AHB and APB buses clocks</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>具体配置过程，以HAL_RCC_OscConfig的HSI Configuration为例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">HAL_RCC_OscConfig：</span><br><span class="line"></span><br><span class="line">/*----------------------------- HSI Configuration --------------------------*/ </span><br><span class="line">  if(((RCC_OscInitStruct-&gt;OscillatorType) &amp; RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)</span><br><span class="line">  &#123;</span><br><span class="line">    /* Check the parameters */</span><br><span class="line">    assert_param(IS_RCC_HSI(RCC_OscInitStruct-&gt;HSIState));</span><br><span class="line">    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct-&gt;HSICalibrationValue));</span><br><span class="line">    </span><br><span class="line">    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ </span><br><span class="line">    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) </span><br><span class="line">       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) &amp;&amp; (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))</span><br><span class="line">    &#123;</span><br><span class="line">      /* When HSI is used as system clock it will not disabled */</span><br><span class="line">      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) &amp;&amp; (RCC_OscInitStruct-&gt;HSIState != RCC_HSI_ON))</span><br><span class="line">      &#123;</span><br><span class="line">        return HAL_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">      /* Otherwise, just the calibration is allowed */</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/</span><br><span class="line">        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct-&gt;HSICalibrationValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      /* Check the HSI State */</span><br><span class="line">      if(RCC_OscInitStruct-&gt;HSIState != RCC_HSI_OFF)</span><br><span class="line">      &#123;</span><br><span class="line">       /* Enable the Internal High Speed oscillator (HSI). */</span><br><span class="line">        __HAL_RCC_HSI_ENABLE();</span><br><span class="line">        </span><br><span class="line">        /* Get Start Tick */</span><br><span class="line">        tickstart = HAL_GetTick();</span><br><span class="line">        </span><br><span class="line">        /* Wait till HSI is ready */</span><br><span class="line">        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)</span><br><span class="line">        &#123;</span><br><span class="line">          if((HAL_GetTick() - tickstart ) &gt; HSI_TIMEOUT_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">            return HAL_TIMEOUT;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/</span><br><span class="line">        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct-&gt;HSICalibrationValue);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        /* Disable the Internal High Speed oscillator (HSI). */</span><br><span class="line">        __HAL_RCC_HSI_DISABLE();</span><br><span class="line">        </span><br><span class="line">        /* Get Start Tick */</span><br><span class="line">        tickstart = HAL_GetTick();</span><br><span class="line">        </span><br><span class="line">        /* Wait till HSI is disabled */</span><br><span class="line">        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)</span><br><span class="line">        &#123;</span><br><span class="line">          if((HAL_GetTick() - tickstart ) &gt; HSI_TIMEOUT_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">            return HAL_TIMEOUT;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里判断HSI时钟源Ready的代码逻辑：</p>
<ul>
<li><p>根据时钟类型，读对应的register的ready bit是否为0。</p>
</li>
<li><p>如果到超时没ready，即此时钟不可用，继续初始化其他时钟。</p>
</li>
</ul>
<p>这里有个问题：系统时钟源还没配置完，为什么可以用HAL_GetTick去判断Ready超时，systick从哪来？</p>
<p>原因：CPU Reset后默认使用HSI时钟，前面的HAL_Init利用HSI初始化了1ms systick功能，因此systick可用；SystemClock_Config只是再次配置时钟，并不是说此时没有时钟。</p>
<ol start="4">
<li>判断时钟源ready register相关的代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)：</span><br><span class="line"></span><br><span class="line">typedef enum </span><br><span class="line">&#123;</span><br><span class="line">  RESET = 0U, </span><br><span class="line">  SET = !RESET</span><br><span class="line">&#125; FlagStatus, ITStatus;</span><br><span class="line"></span><br><span class="line">#define RCC_FLAG_HSERDY                  ((uint8_t)((CR_REG_INDEX &lt;&lt; 5U) | RCC_CR_HSERDY_BitNumber))</span><br><span class="line">#define CR_REG_INDEX                     ((uint8_t)1U)</span><br><span class="line">#define RCC_CR_HSERDY_BitNumber           17</span><br><span class="line"></span><br><span class="line">#define __HAL_RCC_GET_FLAG(__FLAG__) (((((__FLAG__) &gt;&gt; 5U) == CR_REG_INDEX)? RCC-&gt;CR :      \</span><br><span class="line">                                       (((__FLAG__) &gt;&gt; 5U) == CR2_REG_INDEX)? RCC-&gt;CR2 :    \</span><br><span class="line">                                       (((__FLAG__) &gt;&gt; 5U) == BDCR_REG_INDEX) ? RCC-&gt;BDCR : \</span><br><span class="line">                                       RCC-&gt;CSR) &amp; (1U &lt;&lt; ((__FLAG__) &amp; RCC_FLAG_MASK)))</span><br></pre></td></tr></table></figure>

<p>RCC-&gt;CR的定义为例：bit17为HSE RDY bit.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131708364.png" alt="image-20240513170841325"></p>
<h2 id="MX-GPIO-Init"><a href="#MX-GPIO-Init" class="headerlink" title="MX_GPIO_Init"></a>MX_GPIO_Init</h2><p>GPIO初始化入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Initialize all configured peripherals */</span><br><span class="line">	MX_GPIO_Init();</span><br></pre></td></tr></table></figure>

<p>GPIO重点描述几个话题：</p>
<ol>
<li><p>GPIO分组与复用</p>
<p>GPIO有A~F多组，各组的pin独立；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737151.png" alt="image-20240513173750127"></p>
<p>每组GPIO pin都有复用不同的功能；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737965.png" alt="image-20240513173701913"></p>
</li>
<li><p>GPIO的模式</p>
<p>参考Datasheet：Each of the GPIO pins can be configured by software as output (push-pull or open-drain), as input (with or without pull-up or pull-down) or as peripheral alternate function.   </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131747355.png" alt="image-20240513174736319"></p>
<p>输出模式的开漏和推挽模式的主要特性：</p>
<p>（1）开漏输出的高电平不是MCU驱动的，MCU仅作为控制源；输出高电平是借助外部上拉电平；可以自定义输出电平，例如3.3V&#x2F;5V只需要调节上拉电平，不需受到MCU驱动能力限制。</p>
<p>（2）推挽输出的高电平是MCU驱动，即MCU通过内部P&#x2F;N MOS结构真正输出电压（一般3.3V），MCU驱动能力有限。</p>
</li>
</ol>
<p>GPIO代码示例（输出模式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//初始化配置模式：输出，推挽</span><br><span class="line">//恢复默认值（GPIO_PIN_RESET，0）</span><br><span class="line">/*Configure GPIO pin Output Level */</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_8 | GPIO_PIN_15, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">//配置模式</span><br><span class="line">/*Configure GPIO pin : PA */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_8 | GPIO_PIN_15;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">//使用：翻转PA15</span><br><span class="line">HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_15);</span><br><span class="line">//使用：设置高</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);</span><br></pre></td></tr></table></figure>

<p>GPIO中断模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//设置中断模式和优先级</span><br><span class="line">/*Configure GPIO pin : PB */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_4;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING; //中断模式</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">//GPIO_MODE_IT_RISING_FALLING实际是设置EXTI中断</span><br><span class="line">#define  GPIO_MODE_IT_RISING_FALLING            (MODE_INPUT | EXTI_IT | TRIGGER_RISING | TRIGGER_FALLING) </span><br><span class="line"></span><br><span class="line">/* EXTI interrupt init*/</span><br><span class="line">HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);</span><br><span class="line">HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);</span><br><span class="line"></span><br><span class="line">//中断回调</span><br><span class="line">//GPIO4实际是PB4，因为仅PB4设置为INT模式</span><br><span class="line">void EXTI4_15_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MX-DMA-Init"><a href="#MX-DMA-Init" class="headerlink" title="MX_DMA_Init"></a>MX_DMA_Init</h2><h3 id="DMA的常规操作"><a href="#DMA的常规操作" class="headerlink" title="DMA的常规操作"></a>DMA的常规操作</h3><p>参考UM1850：</p>
<p>How to use this driver</p>
<ol>
<li>Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM &#x2F;FLASH memories: no initialization is necessary). Please refer to the Reference manual for connectionbetween peripherals and DMA requests.</li>
<li>For a given Channel, program the required configuration through the following parameters: Channel request,Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level,Source and Destination Increment mode using HAL_DMA_Init() function.</li>
<li>Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of errordetection.4. Use HAL_DMA_Abort() function to abort the current transfer</li>
</ol>
<p>轮询和中断两种模式：</p>
<p>Polling mode IO operation</p>
<p>• Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred</p>
<p>• Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can beconfigured by User depending from his application</p>
<p>Interrupt mode IO operation</p>
<p>• Configure the DMA interrupt priority using HAL_NVIC_SetPriority()</p>
<p>• Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()</p>
<p>• Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred. In this case the DMA interrupt is configured</p>
<p>• Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine</p>
<p>• At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can add his own functionby customization of function pointer XferCpltCallback and XferErrorCallback (i.e. a member of DMA handlestructure).</p>
<h3 id="DMA-Init和IRQ-handler"><a href="#DMA-Init和IRQ-handler" class="headerlink" title="DMA_Init和IRQ handler"></a>DMA_Init和IRQ handler</h3><p>DMA用于UART RX传输中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void MX_DMA_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* DMA controller clock enable */</span><br><span class="line">  __HAL_RCC_DMA1_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  /* DMA interrupt init */</span><br><span class="line">  /* DMA1_Channel4_5_6_7_IRQn interrupt configuration */</span><br><span class="line">  HAL_NVIC_SetPriority(DMA1_Channel4_5_6_7_IRQn, 0, 0);</span><br><span class="line">  HAL_NVIC_EnableIRQ(DMA1_Channel4_5_6_7_IRQn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DMA1_Channel4_5_6_7_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">  HAL_DMA_IRQHandler(&amp;hdma_usart2_rx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Drivers\CMSIS\Device\ST\STM32F0xx\Include\stm32f072xb.h:</span><br><span class="line">DMA1_Channel4_5_6_7_IRQn    = 11,     /*!&lt; DMA1 Channel 4 to Channel 7 Interrupt </span><br><span class="line"></span><br><span class="line">Drivers\CMSIS\Device\ST\STM32F0xx\Source\Templates\arm\startup_stm32f072xb.s:</span><br><span class="line">IRQ 11的handler即DMA1_Channel4_5_6_7_IRQHandler</span><br><span class="line">; External Interrupts</span><br><span class="line">DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">DCD     PVD_VDDIO2_IRQHandler          ; PVD through EXTI Line detect</span><br><span class="line">DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">DCD     RCC_CRS_IRQHandler             ; RCC and CRS</span><br><span class="line">DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">DCD     TSC_IRQHandler                 ; TS</span><br><span class="line">DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">DCD     DMA1_Channel4_5_6_7_IRQHandler ; DMA1 Channel 4, Channel 5, Channel 6 and Channel 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UART RX 使用DMA channel 5 处理接收数据中断</span><br><span class="line">HAL_UART_MspInit()：</span><br><span class="line">/* USART2 DMA Init */</span><br><span class="line">    /* USART2_RX Init */</span><br><span class="line">    hdma_usart2_rx.Instance = DMA1_Channel5;</span><br><span class="line">    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;</span><br><span class="line">    if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HAL_DMA_IRQHandler的具体操作:</p>
<p>处理DMA传输完成中断：分为half transfer complete和Transfer Complete两种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Transfer Complete Interrupt management ***********************************/</span><br><span class="line">  else if ((RESET != (flag_it &amp; (DMA_FLAG_TC1 &lt;&lt; hdma-&gt;ChannelIndex))) &amp;&amp; (RESET != (source_it &amp; DMA_IT_TC)))</span><br><span class="line">  &#123;</span><br><span class="line">  	if((hdma-&gt;Instance-&gt;CCR &amp; DMA_CCR_CIRC) == 0U)</span><br><span class="line">  	&#123;</span><br><span class="line">  		/* Disable the transfer complete  &amp; transfer error interrupts */</span><br><span class="line">  		/* if the DMA mode is not CIRCULAR */</span><br><span class="line">  		hdma-&gt;Instance-&gt;CCR &amp;= ~(DMA_IT_TC | DMA_IT_TE);</span><br><span class="line">  		</span><br><span class="line">  		/* Change the DMA state */</span><br><span class="line">  		hdma-&gt;State = HAL_DMA_STATE_READY;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	/* Clear the transfer complete flag */</span><br><span class="line">  	hdma-&gt;DmaBaseAddress-&gt;IFCR = DMA_FLAG_TC1 &lt;&lt; hdma-&gt;ChannelIndex;</span><br></pre></td></tr></table></figure>

<p>DMA传输完成的回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(hdma-&gt;XferCpltCallback != NULL)</span><br><span class="line">  	&#123;</span><br><span class="line">  		/* Transfer complete callback */</span><br><span class="line">  		hdma-&gt;XferCpltCallback(hdma);</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<p>o2link的UART2处理1KB DMA buffer的自定义逻辑，就是在此中断回调中实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UART_Start_Receive_DMA():</span><br><span class="line">/* Set the UART DMA transfer complete callback */</span><br><span class="line">    huart-&gt;hdmarx-&gt;XferCpltCallback = UART_DMAReceiveCplt;</span><br></pre></td></tr></table></figure>

<p>DMA传输错误中断的判断和回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Transfer Error Interrupt management ***************************************/</span><br><span class="line">  else if (( RESET != (flag_it &amp; (DMA_FLAG_TE1 &lt;&lt; hdma-&gt;ChannelIndex))) &amp;&amp; (RESET != (source_it &amp; DMA_IT_TE)))</span><br><span class="line">  &#123;</span><br><span class="line">  	/* When a DMA transfer error occurs */</span><br><span class="line">    /* A hardware clear of its EN bits is performed */</span><br><span class="line">    /* Then, disable all DMA interrupts */</span><br><span class="line">    hdma-&gt;Instance-&gt;CCR &amp;= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);</span><br><span class="line">    </span><br><span class="line">    /* Clear all flags */</span><br><span class="line">    hdma-&gt;DmaBaseAddress-&gt;IFCR = DMA_FLAG_GL1 &lt;&lt; hdma-&gt;ChannelIndex;</span><br><span class="line">    </span><br><span class="line">    /* Update error code */</span><br><span class="line">    hdma-&gt;ErrorCode = HAL_DMA_ERROR_TE;</span><br><span class="line">    </span><br><span class="line">    /* Change the DMA state */</span><br><span class="line">    hdma-&gt;State = HAL_DMA_STATE_READY;    </span><br><span class="line">    </span><br><span class="line">    /* Process Unlocked */</span><br><span class="line">    __HAL_UNLOCK(hdma); </span><br><span class="line">    </span><br><span class="line">    if(hdma-&gt;XferErrorCallback != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    	/* Transfer error callback */</span><br><span class="line">    	hdma-&gt;XferErrorCallback(hdma);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="DMA-channel和外设的对应关系"><a href="#DMA-channel和外设的对应关系" class="headerlink" title="DMA channel和外设的对应关系"></a>DMA channel和外设的对应关系</h3><p>参考（RM0091）：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132023514.png" alt="image-20240513202302455"></p>
<h2 id="MX-I2C1-Init"><a href="#MX-I2C1-Init" class="headerlink" title="MX_I2C1_Init"></a>MX_I2C1_Init</h2><p>首先明确一个问题：是硬件实现的I2C还是软件GPIO模拟的I2C？</p>
<p>怎么确认：看电路图+Datasheet+底层数据传输代码</p>
<ul>
<li>硬件I2C：此GPIO应该支持I2C功能，Datasheet确认，软件查看是否配成了I2C功能，数据传输是否配置I2C register</li>
<li>软件I2C：此GPIO是普通的GPIO功能，用软件控制high、low和delay控制I2C数据传输，底层操作不是用I2C register实现。</li>
</ul>
<p>根据以下，本环境是硬件I2C功能。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171539178.png" alt="image-20240517153927141"><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541038.png" alt="image-20240517154143995"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541688.png" alt="image-20240517154158646"></p>
<p>下面看初始化代码。</p>
<p>I2C初始化包括两步：</p>
<ol>
<li>设置I2C通信参数</li>
</ol>
<p>速度：standard (up to 100 kHz), Fast-mode (up to 400 kHz) or Fast-mode Plus (up to 1 MHz)  </p>
<p>寻址：7-bit&#x2F;10 bit addressing mode，决定i2c slave设备寻址空间</p>
<p>其他能力见RM0091:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132036579.png" alt="image-20240513203608542"></p>
<p>代码配置的速度和寻址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hi2c1.Init.Timing = SETTING_CLK_100K;</span><br><span class="line">hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置GPIO pin为I2C模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Init</span><br><span class="line"></span><br><span class="line">--&gt; HAL_I2C_MspInit:</span><br><span class="line"></span><br><span class="line">/**I2C1 GPIO Configuration</span><br><span class="line">PB6   ------&gt; I2C1_SCL</span><br><span class="line">PB7   ------&gt; I2C1_SDA</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_I2C1;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="MX-SPI1-Init"><a href="#MX-SPI1-Init" class="headerlink" title="MX_SPI1_Init"></a>MX_SPI1_Init</h2><p>和I2C初始化结构基本类似</p>
<ol>
<li><p>设置SPI通信参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hspi1.Init.Mode = SPI_MODE_MASTER;</span><br><span class="line">hspi1.Init.Direction = SPI_DIRECTION_2LINES; //双向</span><br><span class="line">hspi1.Init.DataSize = SPI_DATASIZE_8BIT; //数据是8bit模式</span><br><span class="line">hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH; //</span><br><span class="line">hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;</span><br></pre></td></tr></table></figure>

<p>关于SPI配置，主要关注数据模式是8bit还是16bit, 以及数据采样和传输的时间点(极性和相位)。</p>
<p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/689464409">SPI的四种传输模式及工作机制分析</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132055783.png" alt="image-20240513205538749"></p>
<p>黑线为数据采样点，与之相反为数据发送点</p>
</li>
<li><p>设置GPIO为SPI模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**SPI1 GPIO Configuration</span><br><span class="line">PA5     ------&gt; SPI1_SCK</span><br><span class="line">PA6     ------&gt; SPI1_MISO</span><br><span class="line">PA7     ------&gt; SPI1_MOSI</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MX-USART1-UART-Init"><a href="#MX-USART1-UART-Init" class="headerlink" title="MX_USART1_UART_Init"></a>MX_USART1_UART_Init</h2><p>对于o2link board, 使用三个UART：</p>
<p>(1) UART 1 PA9 PA10 is used as debug port.</p>
<p>(2) UART 2 PA2 PA3 is used as USB TO UART port</p>
<p>(3) UART 3 PB10 PB11 is used as system communication port.</p>
<p>本节讨论UART1</p>
<ol>
<li><p>设置UART通信参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">huart1.Instance = USART1;</span><br><span class="line">huart1.Init.BaudRate = 115200; //波特率</span><br><span class="line">huart1.Init.WordLength = UART_WORDLENGTH_8B; //8-bit long UART frame(可配7,8,9bit)</span><br><span class="line">huart1.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">huart1.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">huart1.Init.Mode = UART_MODE_TX_RX; //双向</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置GPIO为UART模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**USART1 GPIO Configuration</span><br><span class="line">PA9     ------&gt; USART1_TX</span><br><span class="line">PA10     ------&gt; USART1_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_USART1;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
</li>
<li><p>UART Idle frame和Break frame的概念</p>
<p>为什么UART pin默认拉高？</p>
<p>UART除了正常的数据传输情况，还有idle和break frame的特殊情况：</p>
<p>An Idle character is interpreted as an entire frame of “1”s (the number of “1”s includes the number of stop bits).</p>
<p>A Break character is interpreted on receiving “0”s for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132106226.png" alt="image-20240513210648197"></p>
<p>默认上拉, 如果MCU没有drive UART RX&#x2F;TX pin为低，则可以识别为idle frame；</p>
<p>默认上拉，UART start时MCU开始drive RX&#x2F;TX, 直接拉低pin形成Start信号。</p>
</li>
</ol>
<h2 id="MX-USART2-UART-Init"><a href="#MX-USART2-UART-Init" class="headerlink" title="MX_USART2_UART_Init"></a>MX_USART2_UART_Init</h2><p>o2link的UART 2 PA2 PA3 is used as USB TO UART port.</p>
<p>什么是USB to UART：涉及USB CDC虚拟串口的概念，参考： <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#Communications_Devices_Class_-CDC-_2">Communications Devices Class (CDC)</a>，即USB实现的虚拟串口协议；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132127552.png" alt="image-20240513212722508"></p>
<p>MCU侧配置UART2参数是来自于USBD_CDC_LineCoding.</p>
<p>对于o2link的USB to UART2:</p>
<p>UART TX has no buffer, it will send data directly to the TX pin when it receives data from USB HID, the max data is 64 bytes one time. UART RX has 1K bytes buffer, it uses idle frame to receive data, when it sees this idle frame, it will generate interrupt to tell the app code, and the app code will split data into 64 bytes and transmit the data to the USB.  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132125954.png" alt="image-20240513212534924"></p>
<h3 id="UART2初始化过程"><a href="#UART2初始化过程" class="headerlink" title="UART2初始化过程"></a>UART2初始化过程</h3><ol>
<li>根据USB CDC的配置，设置UART2参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void MX_USART2_UART_Init(uint32_t baurate)</span><br><span class="line">&#123;</span><br><span class="line">  USBD_CDC_LineCoding.bitrate = baurate; //1000 000</span><br><span class="line">  USBD_CDC_LineCoding.paritytype = UART_PARITY_NONE;</span><br><span class="line">  USBD_CDC_LineCoding.datatype = UART_WORDLENGTH_8B;</span><br><span class="line">  USBD_CDC_LineCoding.format = UART_STOPBITS_1;</span><br><span class="line">  UART2_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UART2_Init():</span><br><span class="line"></span><br><span class="line">huart2.Init.BaudRate = USBD_CDC_LineCoding.bitrate;</span><br><span class="line">switch (USBD_CDC_LineCoding.paritytype)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">    break;</span><br><span class="line">  case 1:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_ODD;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_EVEN;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart3.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (USBD_CDC_LineCoding.datatype)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0x07:</span><br><span class="line">    huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    break;</span><br><span class="line">  case 0x08:</span><br><span class="line">    if (huart2.Init.Parity == UART_PARITY_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">      huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      huart2.Init.WordLength = UART_WORDLENGTH_9B;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (USBD_CDC_LineCoding.format)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_2;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>配置GPIO，配置UART使用DMA模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**USART2 GPIO Configuration</span><br><span class="line">PA2     ------&gt; USART2_TX</span><br><span class="line">PA3     ------&gt; USART2_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_USART2;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">/* USART2 DMA Init */</span><br><span class="line">/* USART2_RX Init */</span><br><span class="line">hdma_usart2_rx.Instance = DMA1_Channel5;</span><br><span class="line">hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">hdma_usart2_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;</span><br><span class="line">if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__HAL_LINKDMA(uartHandle, hdmarx, hdma_usart2_rx);</span><br><span class="line"></span><br><span class="line">/* USART2 interrupt Init */</span><br><span class="line">HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);</span><br><span class="line">HAL_NVIC_EnableIRQ(USART2_IRQn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动DMA，随时准备处理UART RX的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">reset_uart_buffer() </span><br><span class="line">--&gt;</span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2, UART2_RxBuffer, UART_PACKAGE_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">参数如下：</span><br><span class="line">* @param huart UART handle.</span><br><span class="line">* @param pData Pointer to data buffer (uint8_t or uint16_t data elements).</span><br><span class="line">* @param Size  Amount of data elements (uint8_t or uint16_t) to be received.</span><br><span class="line"></span><br><span class="line">其中UART2_RxBuffer是1KB buffer， UART_PACKAGE_MAX_SIZE = 1024</span><br><span class="line"></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA的内容：</span><br><span class="line">/* Set Reception type to reception till IDLE Event*/</span><br><span class="line">huart-&gt;ReceptionType = HAL_UART_RECEPTION_TOIDLE; //Reception till completion or IDLE event. 即UART有idle frame能产生DMA中断，不一定要传输完整个buffer的1KB数据。</span><br><span class="line">//启动DMA</span><br><span class="line">status = UART_Start_Receive_DMA(huart, pData, Size);</span><br></pre></td></tr></table></figure>

<p>启动DMA传输的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UART_Start_Receive_DMA():</span><br><span class="line"></span><br><span class="line">/* Set the UART DMA transfer complete callback */</span><br><span class="line">huart-&gt;hdmarx-&gt;XferCpltCallback = UART_DMAReceiveCplt;</span><br><span class="line">/* Enable the DMA channel */</span><br><span class="line">HAL_DMA_Start_IT()    </span><br></pre></td></tr></table></figure>

<p>UART_DMAReceiveCplt里面自定义了完成的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">UART_DMAReceiveCplt()</span><br><span class="line">--&gt; HAL_UARTEx_RxEventCallback():</span><br><span class="line"></span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">&#123;</span><br><span class="line">	/* Prevent unused argument(s) compilation warning */</span><br><span class="line">	UNUSED(huart);</span><br><span class="line">	UNUSED(Size);</span><br><span class="line"></span><br><span class="line">	if (huart-&gt;Instance == USART2)</span><br><span class="line">	&#123;</span><br><span class="line">	    //Size是DMA已传输完的总长度（DMA硬件自动计算）</span><br><span class="line">        //Rx_buf_pos是firmware自定义, 记录RX buffer的偏移。 </span><br><span class="line">		//Rx_length即当前DMA complete的传输数据长度（不包括历史总长度）</span><br><span class="line">		Rx_length = Size - Rx_buf_pos;</span><br><span class="line">		if ((Size &lt; Rx_buf_pos) || (Size &gt; UART_PACKAGE_MAX_SIZE))</span><br><span class="line">		&#123;</span><br><span class="line">			Rx_buf_pos = Size;</span><br><span class="line">			if (Rx_buf_pos &gt;= UART_PACKAGE_MAX_SIZE)</span><br><span class="line">				Rx_buf_pos = 0;</span><br><span class="line">			printf(&quot;dma buffer error\r\n &quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//这里uart_rx_fifo和UART2_RxBuffer都是1KB buffer，uart_rx_fifo用于每次DMA的buffer，每次数据都从0开始存；UART2_RxBuffer是存储多次DMA的总数据，按偏移组合；</span><br><span class="line">		fifo_s_puts(&amp;uart_rx_fifo, (char *)&amp;UART2_RxBuffer[Rx_buf_pos], Rx_length);</span><br><span class="line">		Rx_buf_pos += Rx_length;</span><br><span class="line">		if (Rx_buf_pos &gt;= UART_PACKAGE_MAX_SIZE) //1024</span><br><span class="line">			Rx_buf_pos = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解以上代码，就可以理解USB to UART2的RX机制，是将下位机的大量UART data(最多1024 bytes)，分多次DMA存到UART2_RxBuffer，再按64bytes&#x2F;USB buffer发给上位机。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141625450.png" alt="image-20240514162541398"></p>
</li>
</ol>
<h3 id="UART的DMA传输小结"><a href="#UART的DMA传输小结" class="headerlink" title="UART的DMA传输小结"></a>UART的DMA传输小结</h3><p>UART为什么使用DMA：</p>
<ol>
<li>常规的UART传输，不管是轮询还是中断，一般需要先指定好传输长度是多少个byte，即必须数据长度已知。</li>
</ol>
<p>常规的UART传输如何知道传输完成：</p>
<p>如果是轮询就预估超时时间，如果是中断就按传输完成多少byte作为标志。</p>
<ol start="2">
<li>使用DMA中断的UART传输，可以支持不定长度的数据。</li>
</ol>
<p>使用DMA的UART如何知道传输完成：</p>
<p>数据传输完成；或者有UART event如Idle event，RTO event…</p>
<h2 id="MX-USART3-UART-Init"><a href="#MX-USART3-UART-Init" class="headerlink" title="MX_USART3_UART_Init"></a>MX_USART3_UART_Init</h2><p>UART 3 PB10 PB11 is used as system communication port.</p>
<p>和UART1配置区别仅在波特率，uart3实例没实际使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huart3.Init.BaudRate = 1000000;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**USART3 GPIO Configuration</span><br><span class="line">PB10     ------&gt; USART3_TX</span><br><span class="line">PB11     ------&gt; USART3_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_10 | GPIO_PIN_11;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF4_USART3;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<h2 id="MX-USB-DEVICE-Init"><a href="#MX-USB-DEVICE-Init" class="headerlink" title="MX_USB_DEVICE_Init"></a>MX_USB_DEVICE_Init</h2><p>USB设备的功能实现从上到下分为几层API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Middleware层的USB API：usbd_core (.c, .h), 例如USBD_Init</span><br><span class="line">--&gt; Low level层的USB API：例如USBD_LL_Init</span><br><span class="line">--&gt; HAL的USB host或peripheral API：例如HAL_PCD_Init</span><br><span class="line"></span><br><span class="line">HCD：USB host controller driver</span><br><span class="line">PCD：USB peripheral controller driver</span><br></pre></td></tr></table></figure>

<p>参考： <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#USB_device_library_overview">USB device library overview</a></p>
<p>下面具体分析USB初始化各层负责什么工作：</p>
<p>USBD_Init：Initializes the device stack and load the class driver. 负责USB协议范畴的设备class，设备descriptor等信息的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Unlink previous class*/</span><br><span class="line">  if (pdev-&gt;pClass != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    pdev-&gt;pClass = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Assign USBD Descriptors */</span><br><span class="line">  if (pdesc != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    pdev-&gt;pDesc = pdesc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Set Device initial State */</span><br><span class="line">  pdev-&gt;dev_state = USBD_STATE_DEFAULT;</span><br><span class="line">  pdev-&gt;id = id;</span><br></pre></td></tr></table></figure>

<p>USBD_LL_Init：Initializes the low level portion of the device driver. 负责PCD设备对象的初始化，包括设备属性，设备初始化，DMA配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PCD_HandleTypeDef hpcd_USB_FS;</span><br><span class="line"></span><br><span class="line">/* Link the driver to the stack. */</span><br><span class="line">hpcd_USB_FS.pData = pdev;</span><br><span class="line">pdev-&gt;pData = &amp;hpcd_USB_FS;</span><br><span class="line">//设备属性</span><br><span class="line">hpcd_USB_FS.Instance = USB;</span><br><span class="line">hpcd_USB_FS.Init.dev_endpoints = 8;</span><br><span class="line">hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;</span><br><span class="line">hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;</span><br><span class="line">hpcd_USB_FS.Init.low_power_enable = DISABLE;</span><br><span class="line">hpcd_USB_FS.Init.lpm_enable = DISABLE;</span><br><span class="line">hpcd_USB_FS.Init.battery_charging_enable = DISABLE;</span><br><span class="line"></span><br><span class="line">//设备初始化</span><br><span class="line">if (HAL_PCD_Init(&amp;hpcd_USB_FS) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//DMA配置</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , 0x00 , PCD_SNG_BUF, 0x28);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , 0x80 , PCD_SNG_BUF, 0x80);</span><br><span class="line"></span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CUSTOM_HID_EPIN_ADDR , PCD_SNG_BUF, 0xc0);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CUSTOM_HID_EPOUT_ADDR , PCD_SNG_BUF, 0x100);</span><br><span class="line"></span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_IN_EP , PCD_SNG_BUF, 0x140);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_OUT_EP , PCD_SNG_BUF, 0x180);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_CMD_EP , PCD_SNG_BUF, 0x1c0);</span><br></pre></td></tr></table></figure>

<p>USB设备对象PCD_HandleTypeDef的定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141148488.png" alt="image-20240514114808440"></p>
<p>初始化完成后是USBD_RegisterClass和USBD_Start，结构类似不细讲。</p>
<p>最终通过HAL_PCD_Start返回的USBD_OK status确认初始化OK。</p>
<h2 id="MX-CAN-Init"><a href="#MX-CAN-Init" class="headerlink" title="MX_CAN_Init"></a>MX_CAN_Init</h2><p>目前o2link没使用MX_CAN_Init，代码为空</p>
<h2 id="MX-TIM6-Init"><a href="#MX-TIM6-Init" class="headerlink" title="MX_TIM6_Init"></a>MX_TIM6_Init</h2><p>关于timer有两点背景：</p>
<ol>
<li>hardware timer和systick(Cortex System Timer)的区别：</li>
</ol>
<p>从大概功能上看，都是计时器计数产生中断；</p>
<p>主要是应用上的区别：</p>
<p>a. systick精度一般是1ms，属于系统运行时就一直产生中断，生命周期不停的计时器；常用于应用层的ms_delay延时。</p>
<p>b. hardware timer精度可以达到us, ns，属于即用即停，单次运行的计时器；常用于硬件操作相关的，比如时序要求的us_delay延时。</p>
<ol start="2">
<li>STM32的hardware timer有几类：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141206215.png" alt="image-20240514120637192"></p>
<p>o2link只用到base timer 6. 以下讨论都是针对base timer 6</p>
<ol>
<li>timer的计时原理图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141407505.png" alt="image-20240514140729465"></p>
<ol start="2">
<li><p>timer的计时精度和最大时间</p>
<p>对timer模块时钟的分频决定精度：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TIME_BASE_1US 48</span><br><span class="line">#define TIME_BASE_100US 4800</span><br></pre></td></tr></table></figure>

<p> timer模块的时钟是48MHZ, 所以48分频为1us计时.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141409488.png" alt="image-20240514140933458"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">htim6.Init.Prescaler = Prescaler - 1; //分频后的时钟，决定每个counter计数的时间间隔</span><br><span class="line">htim6.Init.CounterMode = TIM_COUNTERMODE_UP; //counter累加模式</span><br><span class="line">htim6.Init.Period = 0xffff; //最大counter数：65535</span><br><span class="line">htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE; //counter满后自动reload计数</span><br></pre></td></tr></table></figure>

<p>o2link设置timer6的Prescaler &#x3D; 4800, 即100us&#x2F;count，最大时间是100us*65535，约6.5s。</p>
<p>o2link对timer6的应用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim6);</span><br><span class="line">while (one_wire_timer_counter_100US &lt; one_wire_parameter.sync_high_time)&#123;&#125;;</span><br><span class="line">HAL_TIM_Base_Stop_IT(&amp;htim6);</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">#define one_wire_timer_counter_100US (htim6.Instance-&gt;CNT * 100) // 转化成微秒</span><br></pre></td></tr></table></figure>

<h2 id="使能irq和systick"><a href="#使能irq和systick" class="headerlink" title="使能irq和systick"></a>使能irq和systick</h2><p>全部外设配置完毕，启动系统：</p>
<p>enable irq：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  \brief   Enable IRQ Interrupts</span><br><span class="line">  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.</span><br><span class="line">           Can only be executed in Privileged modes.</span><br><span class="line"> */</span><br><span class="line">__STATIC_FORCEINLINE void __enable_irq(void)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM volatile (&quot;cpsie i&quot; : : : &quot;memory&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enable systick：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void systime_init()</span><br><span class="line">&#123;</span><br><span class="line">  systime_tick.tick_ms = 0;</span><br><span class="line">  systime_tick.tick_10ms = 0;</span><br><span class="line">  systime_tick.tick_100ms = 0;</span><br><span class="line">  systime_tick.tick_sec = 0;</span><br><span class="line">  systime_tick.tick_min = 0;</span><br><span class="line">  systime_tick.tick_hour = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  @brief:    Start systick, including IRQ (TBD)</span><br><span class="line"> *        Used when system is powered on</span><br><span class="line"> *  @param:    None</span><br><span class="line"> *  @return:  None</span><br><span class="line"> */</span><br><span class="line">void systime_start(void)</span><br><span class="line">&#123;</span><br><span class="line">  SysTick-&gt;CTRL |= (SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="STM32–while-loop业务流程"><a href="#STM32–while-loop业务流程" class="headerlink" title="STM32–while loop业务流程"></a>STM32–while loop业务流程</h1><p>以下分析基于o2link firmware</p>
<p>while(1)的处理主要分为几大类：</p>
<ol>
<li>用systick更新应用时间</li>
<li>处理UART DMA的RX buffer的数据</li>
<li>处理USB下发的控制信号</li>
</ol>
<h2 id="systick管理时间"><a href="#systick管理时间" class="headerlink" title="systick管理时间"></a>systick管理时间</h2><p>这个目前没什么应用，仅用于LED闪烁；真实用户场景可能用到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">systime_update()：</span><br><span class="line">void systime_update(void)</span><br><span class="line">&#123;</span><br><span class="line">  if (systime_tick.tick_ms != HAL_GetTick())</span><br><span class="line">  &#123;</span><br><span class="line">    systime_tick.tick_ms = HAL_GetTick();</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_10MS) == (TICKRATE_10MS - 1))</span><br><span class="line">      systime_tick.tick_10ms++;</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_100MS) == (TICKRATE_100MS - 1))</span><br><span class="line">      systime_tick.tick_100ms++;</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_HZ) == (TICKRATE_HZ - 1))</span><br><span class="line">    &#123;</span><br><span class="line">      systime_tick.tick_sec++;</span><br><span class="line">      systime_tick.tick_min = (systime_tick.tick_sec / MIN_UNIT);</span><br><span class="line">      systime_tick.tick_hour = (systime_tick.tick_sec / HOUR_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理UART-RX的DMA数据"><a href="#处理UART-RX的DMA数据" class="headerlink" title="处理UART RX的DMA数据"></a>处理UART RX的DMA数据</h2><p>UART从RX的DMA buffer中返回给USB接口，有USB-HID和USB-CDC两种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">uart_data_analysis():</span><br><span class="line">void uart_data_analysis(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t len;</span><br><span class="line">	uint8_t usb_back_buf[64] = &#123;0&#125;; //USB的buffer</span><br><span class="line">	uint8_t *buffer = inter_buffer;</span><br><span class="line">	len = fifo_s_used(&amp;uart_rx_fifo); // 待发送数据长度</span><br><span class="line">	if (len &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fifo_s_gets(&amp;uart_rx_fifo, (char *)inter_buffer, len); //从FIFO取数据</span><br><span class="line">		if (cdc_receive_flag == 0) //no CDC,即HID模式</span><br><span class="line">		&#123;</span><br><span class="line">			while (len &gt; 0) //fifo取到数据？</span><br><span class="line">			&#123;</span><br><span class="line">				usb_back_buf[0] = 0x01; //见o2link spec, 0101 for UART</span><br><span class="line">				usb_back_buf[1] = 0x01;</span><br><span class="line">				//fifo取了60bytes是否还有多的？4bytes是USB加的header</span><br><span class="line">				if (len &gt; MAX_USB_UART_PACKET_NUM)</span><br><span class="line">				&#123;</span><br><span class="line">					usb_back_buf[2] = (MAX_USB_UART_PACKET_NUM &amp; 0xff00) &gt;&gt; 8;</span><br><span class="line">					usb_back_buf[3] = (MAX_USB_UART_PACKET_NUM &amp; 0x00ff);</span><br><span class="line">					memcpy(&amp;usb_back_buf[4], buffer, MAX_USB_UART_PACKET_NUM);</span><br><span class="line">					usb_send(usb_back_buf, USB_TIMEOUT_TIME);</span><br><span class="line">					len -= MAX_USB_UART_PACKET_NUM;</span><br><span class="line">					buffer += MAX_USB_UART_PACKET_NUM;</span><br><span class="line">				&#125;</span><br><span class="line">				else //fifo数据小于60bytes</span><br><span class="line">				&#123;</span><br><span class="line">					usb_back_buf[2] = (len &amp; 0xff00) &gt;&gt; 8;</span><br><span class="line">					usb_back_buf[3] = (len &amp; 0x00ff);</span><br><span class="line">					memcpy(&amp;usb_back_buf[4], buffer, len);</span><br><span class="line">					usb_send(usb_back_buf, USB_TIMEOUT_TIME);</span><br><span class="line">					len = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else //USB-CDC模式</span><br><span class="line">			CDC_Transmit_FS(inter_buffer, len, USB_TIMEOUT_TIME);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>USB-HID发送数据的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint8_t usb_send(uint8_t *send_data,uint32_t time_out)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t tickstart = 0U;</span><br><span class="line">	tickstart = HAL_GetTick();</span><br><span class="line">	</span><br><span class="line">	 while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(USBD_OK == USBD_CUSTOM_HID_SendReport(&amp;hUsbDeviceFS, send_data, USBD_CUSTOMHID_OUTREPORT_BUF_SIZE))</span><br><span class="line">			return USBD_OK;</span><br><span class="line">		if((HAL_GetTick() - tickstart) &gt; time_out)</span><br><span class="line">			return USB_SEND_TIMEOUT;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>USB Custom HID的实现在此不详细分析，参考固件库Sample code和 <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#CustomHID_Class">5.3.2.2 CustomHID Class</a></p>
<h3 id="USB-COMPOSITE设计"><a href="#USB-COMPOSITE设计" class="headerlink" title="USB COMPOSITE设计"></a>USB COMPOSITE设计</h3><p>为什么这里USB能同时支持HID和CDC两种方式？这里有USBD_COMPOSITE的概念：</p>
<p>USB设备初始化时，注册class是USBD_COMPOSITE类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USBD_RegisterClass(&amp;hUsbDeviceFS, &amp;USBD_COMPOSITE) != USBD_OK</span><br></pre></td></tr></table></figure>

<p>compisite指USB可以工作为不同设备类型，其描述符包含HID&#x2F;CDC多种模式：Middlewares\ST\STM32_USB_Device_Library\Class\usbd_composite.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">/* USB composite device Configuration Descriptor */</span><br><span class="line">/*   All Descriptors (Configuration, Interface, Endpoint, Class, Vendor */</span><br><span class="line">__ALIGN_BEGIN uint8_t USBD_Composite_CfgFSDesc[USBD_COMPOSITE_DESC_SIZE] __ALIGN_END =</span><br><span class="line">    &#123;</span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        /************** Descriptor of Custom HID interface ****************/</span><br><span class="line">        /* 09 */</span><br><span class="line">        0x09,                    /*bLength: Interface Descriptor size*/</span><br><span class="line">        USB_DESC_TYPE_INTERFACE, /*bDescriptorType: Interface descriptor type*/</span><br><span class="line">        USBD_HID_INTERFACE,      /*bInterfaceNumber: Number of Interface 接口编号 0 */</span><br><span class="line">        0x00,                    /*bAlternateSetting: Alternate setting  备用接口 */</span><br><span class="line">        0x02,                    /*bNumEndpoints 使用的端点数 1 */</span><br><span class="line">        0x03,                    /*bInterfaceClass: HID*/</span><br><span class="line">        0x00,                    /*bInterfaceSubClass : 1=BOOT, 0=no boot*/</span><br><span class="line">        0x00,                    /*nInterfaceProtocol : 0=none, 1=keyboard, 2=mouse*/</span><br><span class="line">        0,                       /*iInterface: Index of string descriptor*/</span><br><span class="line">        /******************** Descriptor of Custom HID ********************/</span><br><span class="line">        /* 18 */</span><br><span class="line">        0x09,                       /*bLength: HID Descriptor size*/</span><br><span class="line">        CUSTOM_HID_DESCRIPTOR_TYPE, /*bDescriptorType: HID*/</span><br><span class="line">        0x11,                       /*bcdHID: HID Class Spec release number*/</span><br><span class="line">        0x01,</span><br><span class="line">        0x00,                             /*bCountryCode: Hardware target country*/</span><br><span class="line">        0x01,                             /*bNumDescriptors: Number of HID class descriptors to follow*/</span><br><span class="line">        0x22,                             /*bDescriptorType*/</span><br><span class="line">        USBD_CUSTOM_HID_REPORT_DESC_SIZE, /*wItemLength: Total length of Report descriptor*/</span><br><span class="line">        0x00,</span><br><span class="line">        </span><br><span class="line">        /* 27 */</span><br><span class="line">        0x07,                   /*bLength: Endpoint Descriptor size*/</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT, /*bDescriptorType:*/</span><br><span class="line"></span><br><span class="line">        CUSTOM_HID_EPIN_ADDR, /*bEndpointAddress: Endpoint Address (IN)*/</span><br><span class="line">        0x03,                 /*bmAttributes: Interrupt endpoint*/</span><br><span class="line">        CUSTOM_HID_EPIN_SIZE, /*wMaxPacketSize: 16 Byte max */</span><br><span class="line">        0x00,</span><br><span class="line">        CUSTOM_HID_FS_BINTERVAL, /*bInterval: Polling Interval */</span><br><span class="line">        /* 34 */</span><br><span class="line"></span><br><span class="line">        0x07,                   /* bLength: Endpoint Descriptor size */</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT, /* bDescriptorType: */</span><br><span class="line">        CUSTOM_HID_EPOUT_ADDR,  /*bEndpointAddress: Endpoint Address (OUT)*/</span><br><span class="line">        0x03,                   /* bmAttributes: Interrupt endpoint */</span><br><span class="line">        CUSTOM_HID_EPOUT_SIZE,  /* wMaxPacketSize: 2 Bytes max  */</span><br><span class="line">        0x00,</span><br><span class="line">        CUSTOM_HID_FS_BINTERVAL, /* bInterval: Polling Interval */</span><br><span class="line">        /* 41 */</span><br><span class="line"></span><br><span class="line">        /****************************CDC************************************/</span><br><span class="line">        /* IAD描述符 */</span><br><span class="line">        /* Interface Association Descriptor */</span><br><span class="line">        USBD_IAD_DESC_SIZE,       // bLength</span><br><span class="line">        USBD_IAD_DESCRIPTOR_TYPE, // bDescriptorType</span><br><span class="line">        0x01,                     // bFirstInterface 接口描述符是在总的配置描述符中的第几个从0开始数 1</span><br><span class="line">        0x02,                     // bInterfaceCount 接口描述符数量 2</span><br><span class="line">        0x02,                     // bFunctionClass     CDC Control</span><br><span class="line">        0x02,                     // bFunctionSubClass  Abstract Control Model</span><br><span class="line">        0x01,                     // bInterfaceProtocol  AT Commands: V.250 etc</span><br><span class="line">        0x00,                     // iFunction</span><br><span class="line"></span><br><span class="line">        /* CDC命令接口描述符 */</span><br><span class="line">        /*Interface Descriptor */</span><br><span class="line">        0x09,                    /* bLength: Interface Descriptor size 长度 */</span><br><span class="line">        USB_DESC_TYPE_INTERFACE, /* bDescriptorType: Interface 接口编号0x04 */</span><br><span class="line">        /* Interface descriptor type */</span><br><span class="line">        USBD_CDC_CMD_INTERFACE, /* bInterfaceNumber: Number of Interface 接口编号，第一个接口编号为1 */</span><br><span class="line">        0x00,                   /* bAlternateSetting: Alternate setting 接口备用编号 0 */</span><br><span class="line">        0x01,                   /* bNumEndpoints: One endpoints used 非0端点的数目 1 cdc接口只使用了一个中断输入端点 */</span><br><span class="line">        0x02,                   /* bInterfaceClass: Communication Interface Class 接口所使用的类0x02 */</span><br><span class="line">        0x02,                   /* bInterfaceSubClass: Abstract Control Model 接口所使用的子类0x02 */</span><br><span class="line">        0x01,                   /* bInterfaceProtocol: Common AT commands 使用AT命令协议 */</span><br><span class="line">        0x00,                   /* iInterface: 接口字符串索引值 0表示没有 */</span><br><span class="line"></span><br><span class="line">        /* 类特殊接口描述符--功能描述符 用来描述接口的功能 */</span><br><span class="line">        /*Header Functional Descriptor*/</span><br><span class="line">        0x05, /* bLength: Endpoint Descriptor size 描述符长度为5字节 */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x00, /* bDescriptorSubtype: Header Func Desc 子类为 Header Func Desc，编号0x00 */</span><br><span class="line">        0x10, /* bcdCDC: spec release number CDC版本 */</span><br><span class="line">        0x01,</span><br><span class="line"></span><br><span class="line">        /*Call Management Functional Descriptor*/</span><br><span class="line">        0x05, /* bFunctionLength */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x01, /* bDescriptorSubtype: Call Management Func Desc 子类为Call Management Func Desc 编号0x01*/</span><br><span class="line">        0x00, /* bmCapabilities: D0+D1 设备自己不管理call management */</span><br><span class="line">        0x01, /* bDataInterface: 1 有一个数据类接口用作call management */</span><br><span class="line"></span><br><span class="line">        /*ACM Functional Descriptor*/</span><br><span class="line">        0x04, /* bFunctionLength */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x02, /* bDescriptorSubtype: Abstract Control Management desc 子类为Abstract Control Management desc编号0x02*/</span><br><span class="line">        0x02, /* bmCapabilities 支持Set_Control_Line_State、Get_Line_Coding请求和Serial_State通知*/</span><br><span class="line"></span><br><span class="line">        /*Union Functional Descriptor*/</span><br><span class="line">        0x05,                    /* bFunctionLength */</span><br><span class="line">        0x24,                    /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE */</span><br><span class="line">        0x06,                    /* bDescriptorSubtype: Union func desc 子类为Union func desc 编号0x06*/</span><br><span class="line">        USBD_CDC_CMD_INTERFACE,  /* bMasterInterface: Communication class interface 编号为1的CDC接口 */</span><br><span class="line">        USBD_CDC_DATA_INTERFACE, /* bSlaveInterface0: Data Class Interface 编号为2的数据类接口 */</span><br><span class="line"></span><br><span class="line">        /*Endpoint 2 Descriptor*/</span><br><span class="line">        0x07,                        /* bLength: Endpoint Descriptor size */</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */</span><br><span class="line">        CDC_CMD_EP,                  /* bEndpointAddress */</span><br><span class="line">        0x03,                        /* bmAttributes: Interrupt */</span><br><span class="line">        LOBYTE(CDC_CMD_PACKET_SIZE), /* wMaxPacketSize: */</span><br><span class="line">        HIBYTE(CDC_CMD_PACKET_SIZE),</span><br><span class="line">        CDC_FS_BINTERVAL, /* bInterval: */</span><br><span class="line">        /*---------------------------------------------------------------------------*/</span><br><span class="line">        .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如何选择工作模式：取决于上位机</p>
<p>如果上位机发送CDC数据，就使能CDC处理；否则默认是USB-HID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">USBD_CDC_ItfTypeDef USBD_CDC_Interface_fops_FS =</span><br><span class="line">&#123;</span><br><span class="line">  CDC_Init_FS,</span><br><span class="line">  CDC_DeInit_FS,</span><br><span class="line">  CDC_Control_FS,</span><br><span class="line">  CDC_Receive_FS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8_t cdc_receive_flag = 0;</span><br><span class="line">static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 6 */</span><br><span class="line">  USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[0]);</span><br><span class="line">  USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);</span><br><span class="line">  cdc_receive_flag = 1;</span><br><span class="line">  // 注意这里是中断回调，串口函数有锁</span><br><span class="line">  HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;Buf[0],*Len,UART_TIMEOUT_TIME);</span><br><span class="line">  return (USBD_OK);</span><br><span class="line">  /* USER CODE END 6 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理USB下发的控制信号"><a href="#处理USB下发的控制信号" class="headerlink" title="处理USB下发的控制信号"></a>处理USB下发的控制信号</h2><p>USB HID下发信号的处理函数是CUSTOM_HID_OutEvent_FS：</p>
<p>USB中断传输方式中，每次PC机发送数据后USB设备都会产生中断，设备每完成一次从PC机的Out data的接收都会响应一次OutEvent，因此可以通过修改usbd_custom_hid_if.c中的static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)来实现对接收到数据做处理。实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">USBD_CUSTOM_HID_ItfTypeDef USBD_CustomHID_fops_FS =</span><br><span class="line">&#123;</span><br><span class="line">  CUSTOM_HID_ReportDesc_FS,</span><br><span class="line">  CUSTOM_HID_Init_FS,</span><br><span class="line">  CUSTOM_HID_DeInit_FS,</span><br><span class="line">  CUSTOM_HID_OutEvent_FS //接收数据回调</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)</span><br><span class="line">&#123;</span><br><span class="line">	uint16_t command ;</span><br><span class="line"></span><br><span class="line">    USB_Received_Count = USBD_GetRxCount( &amp;hUsbDeviceFS,CUSTOM_HID_EPOUT_ADDR );</span><br><span class="line">    </span><br><span class="line">    USBD_CUSTOM_HID_HandleTypeDef   *hhid; </span><br><span class="line">    hhid = pHIDData;</span><br><span class="line">    </span><br><span class="line">    //copy和解析</span><br><span class="line">	memcpy(usb_send_buf, hhid-&gt;Report_buf, USB_Received_Count);</span><br><span class="line">	command = usb_send_buf[0] &lt;&lt; 8 | usb_send_buf[1];</span><br><span class="line">	//这里做了个流程区分：如果是USB to UART则调用uart write流程；其他控制信号仅设置计数+1.</span><br><span class="line">	if(command ==WRITE_UART_FUNCITON)</span><br><span class="line">		write_uart_function();</span><br><span class="line">	else</span><br><span class="line">		usb_flag++;</span><br><span class="line">			</span><br><span class="line">  return (USBD_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MCU的while(1)处理usb_flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(1):</span><br><span class="line">	if (usb_flag)</span><br><span class="line">		&#123;</span><br><span class="line">			usb_flag--;</span><br><span class="line">			usb_handle_process();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>usb_handle_process就是对USB buffer的64byte解析并分发到各处理函数，基本实现IO control的机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void usb_handle_process(void)</span><br><span class="line">&#123;</span><br><span class="line">	command = usb_send_buf[0] &lt;&lt; 8 | usb_send_buf[1];</span><br><span class="line">	length = usb_send_buf[2] &lt;&lt; 8 | usb_send_buf[3];</span><br><span class="line"></span><br><span class="line">	switch (command)</span><br><span class="line">	&#123;</span><br><span class="line">	case UART_PARAMETER_SET:</span><br><span class="line">		uart_parameter_setting();</span><br><span class="line">		break;</span><br><span class="line">	case UART_PIN_LOW_SET:</span><br><span class="line">		uart_pin_low_set();</span><br><span class="line">		break;</span><br><span class="line">	case USB_TO_SPI_FUNCTION:</span><br><span class="line">		usb_to_spi_convert();</span><br><span class="line">		break;</span><br><span class="line">	case USB_TO_SPI_PARAMETER_SET:</span><br><span class="line">		spi_parameter_setting();</span><br><span class="line">		break;</span><br><span class="line">	....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不详细分析各switch case的内容，基本操作都是将usb_send_buf数据，通过SPI&#x2F;UART&#x2F;I2C….透传到MCU下游的芯片. </p>
<p>TODO：为什么UART write需要特殊处理，而不用usb_handle_process分发处理？</p>
<p>因为UART TX没有buffer，如果MCU收到UART write而不立即启动TX传输，上位机的USB 64bytes buffer可能被新的TX data覆盖掉？或者上位机有超时机制？</p>
<p>usb_handle_process只挑几个典型流程分析：</p>
<h3 id="jump-to-boot"><a href="#jump-to-boot" class="headerlink" title="jump_to_boot"></a>jump_to_boot</h3><p>这个用于MCU上直接升级Firmware（IAP）用到，目前开发阶段还没应用，以后用户升级可能用到。</p>
<p>使用函数指针，用调用函数的形式跳转到JumpAddress（0x08000004），即中断向量表的RESET入口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define BOOT_ADDR 0x08000000</span><br><span class="line">typedef void (*pFunction)(void);</span><br><span class="line"></span><br><span class="line">void jump_to_boot(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	uint32_t JumpAddress;</span><br><span class="line">	pFunction Jump_To_Application;</span><br><span class="line"></span><br><span class="line">	usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">	HAL_Delay(10);</span><br><span class="line">	__disable_irq();</span><br><span class="line"></span><br><span class="line">	JumpAddress = *(__IO uint32_t *)(BOOT_ADDR + 4);</span><br><span class="line">	Jump_To_Application = (pFunction)JumpAddress;</span><br><span class="line"></span><br><span class="line">	__HAL_RCC_SYSCFG_CLK_ENABLE();</span><br><span class="line">	__HAL_REMAPMEMORY_FLASH();</span><br><span class="line">	/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">	__set_MSP(*(__IO uint32_t *)BOOT_ADDR);</span><br><span class="line">	*(uint32_t *)RAM_FROM_APP_FLAG_ADDR = RAM_FROM_APP_FLAG_DATA; // jump</span><br><span class="line">	Jump_To_Application();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uart-pin-low"><a href="#uart-pin-low" class="headerlink" title="uart_pin_low"></a>uart_pin_low</h3><p>此功能是BMS业务的流程，BMS chip的wakeup操作使用RX pin，拉低UART TX为低并保持一段时间，再拉高TX，形成BMS chip的wakeup。</p>
<p>注意这里不是为了形成UART break frame（也是RX拉低，保持一个byte的周期，再拉高），所以UART RX pin需要先析构，在GPIO模式下才能无UART协议干扰的产生BMS wakeup信号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void jaguar_uart_pin_low_fun(uint32_t ustimer)</span><br><span class="line">&#123;</span><br><span class="line">	MX_TIM6_Init(TIME_BASE_1US); //timer 1us精度</span><br><span class="line">	UART2_DeInit(); //uart2析构</span><br><span class="line">	jaguar_uart_gpio_fun(); //设置PA2,PA3为高，即UART的RX/TX pin</span><br><span class="line"></span><br><span class="line">	HAL_TIM_Base_Start_IT(&amp;htim6); //开始计时</span><br><span class="line">	jaguar_wire_pin_low(); //设置PA2（TX）为低</span><br><span class="line">	while (one_wire_timer_counter_1US &lt; ustimer) //ustimer来自USB-HID数据</span><br><span class="line">	&#123;</span><br><span class="line">		// printf(&quot;sync low tim:%d \r\n&quot;,one_wire_timer_counter100US);</span><br><span class="line">	&#125;;</span><br><span class="line">	jaguar_wire_pin_high(); //设置PA2（TX）为高</span><br><span class="line">	HAL_TIM_Base_Stop_IT(&amp;htim6); //结束计时</span><br><span class="line">	//设置波特率，这里如果UART之前设置过，就保持原值；否则默认值1M波特率</span><br><span class="line">	if (saved_baudrate != 0)</span><br><span class="line">		MX_USART2_UART_Init(saved_baudrate); // keep the baudrate(set by USB-HID uart-config command).</span><br><span class="line">	else</span><br><span class="line">		MX_USART2_UART_Init(1000000); // reset baud rate.</span><br><span class="line">	Rx_buf_pos = 0;</span><br><span class="line">	MX_TIM6_Init(TIME_BASE_100US);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usb-to-spi"><a href="#usb-to-spi" class="headerlink" title="usb_to_spi"></a>usb_to_spi</h3><p>前面没有详细分析SPI的传输，此处分析。</p>
<p>o2link spec定义的USB to SPI数据包格式：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141701291.png" alt="image-20240514170141237"></p>
<p>SPI数据通信的原理：</p>
<p>SPI一般设置为全双工双向通信，利用移位register交换master&#x2F;slave两端的数据register(FIFO)里的数据。</p>
<p>全双工时，SPI不存在单向的发送或单向的接收，数据一定是“交换”的。firmware的关注点是用RX register发数据，还是从Tx register拿数据。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141715633.png" alt="image-20240514171557572"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141705044.png" alt="image-20240514170528006"></p>
<p>代码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void usb_to_spi_convert(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t recive_buf[SPI_MAX_DATA_NUM] = &#123;0&#125;;</span><br><span class="line">	uint8_t ret = 0;</span><br><span class="line"></span><br><span class="line">	if (usb_send_buf[SPI_LENGTH_SITE] &gt; 60)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = SPI_INVALID_PARAMETER;</span><br><span class="line">		usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//按o2link spec解析为SPI命令参数和数据，数据内容决定对下层DFE芯片register是读还是写</span><br><span class="line">	ret = usb_spi_convert_data(usb_send_buf[SPI_CHIPID_SITE], usb_send_buf[SPI_LENGTH_SITE], &amp;usb_send_buf[SPI_DATA_SITE], recive_buf);</span><br><span class="line">	if (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = ret;</span><br><span class="line">	&#125;</span><br><span class="line">	//按o2link spec解析出返回数据</span><br><span class="line">	memcpy(&amp;usb_send_buf[SPI_DATA_SITE], recive_buf, usb_send_buf[SPI_LENGTH_SITE]);</span><br><span class="line">	usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint8_t usb_spi_convert_data(uint8_t dev_id,uint8_t data_num,uint8_t * write_buf,uint8_t *read_buf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    uint8_t ret = 0;</span><br><span class="line">    </span><br><span class="line">    //拉低CS片选</span><br><span class="line">    HAL_GPIO_WritePin(spi_gpio_cs_pins[dev_id].gpio_base,spi_gpio_cs_pins[dev_id].gpio_pin,GPIO_PIN_RESET);</span><br><span class="line">	//启动SPI传输</span><br><span class="line">    ret = HAL_SPI_TransmitReceive(&amp;hspi1, write_buf, read_buf, data_num ,SPI_TIMEOUT_TIME);</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_WritePin(spi_gpio_cs_pins[dev_id].gpio_base,spi_gpio_cs_pins[dev_id].gpio_pin,GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPI传输的8bit模式具体内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_TransmitReceive():</span><br><span class="line"></span><br><span class="line">hspi-&gt;pRxBuffPtr  = (uint8_t *)pRxData; //RX buffer的指针</span><br><span class="line">hspi-&gt;RxXferCount = Size;</span><br><span class="line">hspi-&gt;RxXferSize  = Size;</span><br><span class="line">hspi-&gt;pTxBuffPtr  = (uint8_t *)pTxData; //TX buffer的指针</span><br><span class="line">hspi-&gt;TxXferCount = Size;</span><br><span class="line">hspi-&gt;TxXferSize  = Size;</span><br><span class="line"></span><br><span class="line">/* Enable SPI peripheral */</span><br><span class="line">__HAL_SPI_ENABLE(hspi);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">/* Transmit and Receive data in 8 Bit mode */</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    while ((hspi-&gt;TxXferCount &gt; 0U) || (hspi-&gt;RxXferCount &gt; 0U))</span><br><span class="line">    &#123;</span><br><span class="line">      /* Check TXE flag */</span><br><span class="line">      //SPI_FLAG_TXE: SPI status flag: Tx buffer empty flag, 表示当前TX FIFO数据为空，可能是首次启动还没填数据或上次已传完</span><br><span class="line">      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) &amp;&amp; (hspi-&gt;TxXferCount &gt; 0U) &amp;&amp; (txallowed == 1U))</span><br><span class="line">      &#123;</span><br><span class="line">       // DR: SPI data register, 按uint8（byte）填数据</span><br><span class="line">        *(__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR = (*hspi-&gt;pTxBuffPtr);</span><br><span class="line">        //更新数据指针(准备下次传输)</span><br><span class="line">        hspi-&gt;pTxBuffPtr++;</span><br><span class="line">        hspi-&gt;TxXferCount--;</span><br><span class="line">        /* Next Data is a reception (Rx). Tx not allowed */</span><br><span class="line">        //处理完TX，下面必须处理RX</span><br><span class="line">        txallowed = 0U;</span><br><span class="line">        </span><br><span class="line">        /* Wait until RXNE flag is reset */</span><br><span class="line">        //SPI_FLAG_RXNE: Rx buffer not empty flag, 有收到数据待处理</span><br><span class="line">          if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) &amp;&amp; (hspi-&gt;RxXferCount &gt; 0U))</span><br><span class="line">          &#123;</span><br><span class="line">          	//从DR register取数据到RX buffer</span><br><span class="line">            (*(uint8_t *)hspi-&gt;pRxBuffPtr) = *(__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR;</span><br><span class="line">            hspi-&gt;pRxBuffPtr++;</span><br><span class="line">            hspi-&gt;RxXferCount--;</span><br><span class="line">            /* Next Data is a Transmission (Tx). Tx is allowed */</span><br><span class="line">            //处理完RX，下一轮必须处理TX</span><br><span class="line">            txallowed = 1U;</span><br><span class="line">          &#125;</span><br><span class="line">          //超时判断</span><br><span class="line">          if ((((HAL_GetTick() - tickstart) &gt;=  Timeout) &amp;&amp; ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))</span><br><span class="line">          &#123;</span><br><span class="line">            errorcode = HAL_TIMEOUT;</span><br><span class="line">            goto error;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TX RX处理的判断标准是读SR register状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** @brief  Check whether the specified SPI flag is set or not.</span><br><span class="line">  * @param  __HANDLE__ specifies the SPI Handle.</span><br><span class="line">  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.</span><br><span class="line">  * @param  __FLAG__ specifies the flag to check.</span><br><span class="line">  *         This parameter can be one of the following values:</span><br><span class="line">  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag</span><br><span class="line">  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag</span><br><span class="line">  *            @arg SPI_FLAG_CRCERR: CRC error flag</span><br><span class="line">  *            @arg SPI_FLAG_MODF: Mode fault flag</span><br><span class="line">  *            @arg SPI_FLAG_OVR: Overrun flag</span><br><span class="line">  *            @arg SPI_FLAG_BSY: Busy flag</span><br><span class="line">  *            @arg SPI_FLAG_FRE: Frame format error flag</span><br><span class="line">  *            @arg SPI_FLAG_FTLVL: SPI fifo transmission level</span><br><span class="line">  *            @arg SPI_FLAG_FRLVL: SPI fifo reception level</span><br><span class="line">  * @retval The new state of __FLAG__ (TRUE or FALSE).</span><br><span class="line">  */</span><br><span class="line">#define __HAL_SPI_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)-&gt;Instance-&gt;SR) &amp; (__FLAG__)) == (__FLAG__))</span><br></pre></td></tr></table></figure>

<p>为什么SPI传输TX，RX是同时又交替的处理数据：</p>
<p>SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</p>
<p>因此HAL_SPI_TransmitReceive()同时处理RX和TX，和UART的RX&#x2F;TX单向传输不同。</p>
<p>​	</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89EDK2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89EDK2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">UEFI开发（一）EDK2环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:27:38" itemprop="dateModified" datetime="2025-11-04T17:27:38+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UEFI%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">UEFI开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UEFI开发（一）EDK2环境搭建"><a href="#UEFI开发（一）EDK2环境搭建" class="headerlink" title="UEFI开发（一）EDK2环境搭建"></a>UEFI开发（一）EDK2环境搭建</h1><p>官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-with-EDK-II">https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-with-EDK-II</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-User-Documentation">https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-User-Documentation</a></p>
<h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>参考：<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2?tab=readme-ov-file#submodules">edk2&#x2F;Submodules</a></p>
<p>在C盘根目录用git命令下载edk2并下载submodule：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tianocore/edk2.git</span><br><span class="line">cd edk2</span><br><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure>

<p>如果要切换到stable tag版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -l #列出tag， -l: list</span><br><span class="line">git checkout edk2-stable202X0X #切table tag</span><br><span class="line">git submodule update #更新submodule（对应stable tag）</span><br></pre></td></tr></table></figure>

<p>我的环境是VS2022，当前edk2 master主线支持VS2022，而最新的stable tag不支持，所以用master版本，没必要checkout到stable tag。</p>
<h2 id="编译EDK2"><a href="#编译EDK2" class="headerlink" title="编译EDK2"></a>编译EDK2</h2><h3 id="编译环境准备"><a href="#编译环境准备" class="headerlink" title="编译环境准备"></a>编译环境准备</h3><p>参考：<a target="_blank" rel="noopener" href="https://github.com/tianocore/tianocore.github.io/wiki/Windows-systems">https://github.com/tianocore/tianocore.github.io/wiki/Windows-systems</a></p>
<ol>
<li><p>按 <a href="edk2%5CBaseTools%5CBin"><strong>Build</strong></a> 下载NASM和ASL二进制包，放到C盘跟&#x3D;根目录（和edk2同路径）</p>
</li>
<li><p>运行edksetup.bat，编译edk2&#x2F;BaseTool</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">C:\edk2&gt;edksetup.bat</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">** Visual Studio 2022 Developer Command Prompt v17.13.6</span><br><span class="line">** Copyright (c) 2022 Microsoft Corporation</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">[vcvarsall.bat] Environment initialized for: &#x27;x86&#x27;</span><br><span class="line">Using EDK2 in-source Basetools</span><br><span class="line">          PATH      = C:\edk2\BaseTools\BinWrappers\WindowsLike;D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\HostX86\x86;D:\Program Files\Microsoft Visual .... Studio\2022\Community\Common7\IDE\VC\Linux\bin\ConnectionManagerExe;D:\Program Files\Microsoft Visual Studio\2022\Community\VC\vcpkg</span><br><span class="line"></span><br><span class="line">     WORKSPACE      = C:\edk2</span><br><span class="line"></span><br><span class="line">EDK_TOOLS_PATH      = C:\edk2\BaseTools</span><br><span class="line">BASE_TOOLS_PATH     = C:\edk2\BaseTools</span><br><span class="line"> EDK_TOOLS_BIN      = C:\edk2\BaseTools\Bin\Win32</span><br><span class="line">     CONF_PATH      = C:\edk2\Conf</span><br><span class="line">     PYTHON_COMMAND = py -3</span><br><span class="line">         PYTHONPATH = C:\edk2\BaseTools\Source\Python;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!!! WARNING !!! NASM_PREFIX environment variable is not set</span><br><span class="line">  Found nasm.exe, setting the environment variable to C:\nasm\</span><br><span class="line"></span><br><span class="line">!!! WARNING !!! CLANG_BIN environment variable is not set</span><br></pre></td></tr></table></figure>

<p>log中的一些信息含义：</p>
<p>（1）新版本edk2已经包含python包，无需自己再去下载和指定python路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYTHONPATH = C:\edk2\BaseTools\Source\Python;</span><br></pre></td></tr></table></figure>

<p>（2）已自动设置nasm路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found nasm.exe, setting the environment variable to C:\nasm\</span><br></pre></td></tr></table></figure>

<p>（3）用VS2022编译，CLANG_BIN不用设置</p>
<p>编译输出二进制在edk2\BaseTools\Bin</p>
<h3 id="编译目标模块"><a href="#编译目标模块" class="headerlink" title="编译目标模块"></a>编译目标模块</h3><p>运行edksetup后，再执行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build</span><br></pre></td></tr></table></figure>

<p>编译目标由edk2&#x2F;Conf&#x2F;target.txt的ACTIVE_PLATFORM和TARGET_ARCH指定</p>
<h3 id="终端乱码问题"><a href="#终端乱码问题" class="headerlink" title="终端乱码问题"></a>终端乱码问题</h3><p>在编译前可用以下命令将命令行的输出转成UTF8格式，防止输出乱码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure>

<p>下图说明从Conf&#x2F;target的产生到编译完成的全流程</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504141429251.png" alt="image-20250414142907112"></p>
<h2 id="搭建UEFI-shell启动盘"><a href="#搭建UEFI-shell启动盘" class="headerlink" title="搭建UEFI shell启动盘"></a>搭建UEFI shell启动盘</h2><h3 id="创建UEFI-shell盘"><a href="#创建UEFI-shell盘" class="headerlink" title="创建UEFI shell盘"></a>创建UEFI shell盘</h3><ol>
<li>找一个U盘，格式化成FAT32，然后在U盘根目录下建立&#x2F;efi&#x2F;boot目录。</li>
<li>自己编译UEFI shell.efi或者下载Shell.efi</li>
<li>把Shell.efi改名成BOOTX64.efi，然后把BOOTX64.efi拷贝到U盘&#x2F;efi&#x2F;boot&#x2F;目录下。</li>
<li>自己编译的其他UEFI程序，如MdeModulePkg Application efi或者DXE efi驱动，都可放到U盘根目录</li>
<li>U盘插入电脑，开机后按F12(不同厂商电脑可能有所不同)进入UEFI menu选择页面，选择从U盘启动</li>
</ol>
<p>(1) 如何自己编译UEFI shell.efi：</p>
<p>前面edk2编译环境ok后，改Conf&#x2F;target.txt为编译ShellPkg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACTIVE_PLATFORM       = ShellPkg/ShellPkg.dsc</span><br><span class="line">TARGET_ARCH           = X64</span><br><span class="line">TOOL_CHAIN_TAG        = VS2019</span><br></pre></td></tr></table></figure>

<p>编译完成后输出Shell.efi在Build&#x2F;Shell&#x2F;<TOOL_CHAIN_TAG>&#x2F;<TARGET_ARCH>&#x2F;ShellPkg&#x2F;Application&#x2F;Shell&#x2F;Shell&#x2F;OUTPUT&#x2F;目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Finished generating code</span><br><span class="line">        &quot;GenFw&quot; -e UEFI_APPLICATION -o C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\OUTPUT\Shell.efi C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\DEBUG\Shell.dll</span><br><span class="line">        copy /y C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\OUTPUT\Shell.efi </span><br><span class="line"></span><br><span class="line">- Done -</span><br></pre></td></tr></table></figure>

<p>(2)下载编译好的Shell.efi</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pbatard/UEFI-Shell/releases">https://github.com/pbatard/UEFI-Shell/releases</a></p>
<p>包含各平台的shell.efi</p>
<h3 id="startup-nsh脚本"><a href="#startup-nsh脚本" class="headerlink" title="startup.nsh脚本"></a>startup.nsh脚本</h3><p>UEFI Shell.efi启动时会查找根目录下有没有startup.nsh脚本，如果有的话会自动执行startup.nsh脚本</p>
<p>比如U盘在UEFI shell下的盘符为 FS0: ，想要启动自动执行根目录的myUefiApp.efi程序，startup.nsh脚本如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#切换到FS0盘符的根目录</span><br><span class="line">FS0:</span><br><span class="line">#执行程序（预先放在根目录）</span><br><span class="line">MyUefiApp.efi</span><br></pre></td></tr></table></figure>

<p>也可以用绝对路径执行MyUefiApp.efi，即 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FS0:\MyUefiApp.efi</span><br></pre></td></tr></table></figure>

<h3 id="进入UEFI-shell"><a href="#进入UEFI-shell" class="headerlink" title="进入UEFI shell"></a>进入UEFI shell</h3><p>如图是F12进入U盘UEFI shell环境，其中：</p>
<p>UEFI shell版本v2.7，可见来源信息</p>
<p>map -r显示可识别设备信息：</p>
<ol>
<li><p>FS是filesystem文件系统设备。FS0是USB设备，位于PCi bridge 0x14上；FS1是Sata硬盘，位于PCi bridge 0x17上</p>
</li>
<li><p>BLK是文件分区。BLK0是USB的分区，BLK2和4都是Sata硬盘的文件分区</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504161706334.png" alt="image-20250416170607057"></p>
<h3 id="copy-startup加快测试"><a href="#copy-startup加快测试" class="headerlink" title="copy+startup加快测试"></a>copy+startup加快测试</h3><p><a target="_blank" rel="noopener" href="https://ss64.com/nt/xcopy.html">https://ss64.com/nt/xcopy.html</a></p>
<p>调试efi经常要重新编译和拷贝efi到u盘，用copy命令自动化</p>
<p>build编译模块时，输出的efi已经拷贝过一次。这里再创建一个.bat拷到u盘（E盘根目录）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy /y C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\SdMmcPciHcDxe\OUTPUT\SdMmcPciHcDxe.efi C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\SdMmcPciHcDxe.efi</span><br><span class="line"></span><br><span class="line">copy /y C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\SdMmcPciHcDxe.efi E:\</span><br></pre></td></tr></table></figure>

<p>这样编译后自动拷贝到U盘，在UEFI测试机上创建startup.sh自动运行efi驱动加载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs0:</span><br><span class="line">load SdMmcPciHcDxe.efi</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">UEFI开发（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:49:11" itemprop="dateModified" datetime="2025-11-18T10:49:11+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UEFI%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">UEFI开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UEFI开发（二）"><a href="#UEFI开发（二）" class="headerlink" title="UEFI开发（二）"></a>UEFI开发（二）</h1><h2 id="Library库"><a href="#Library库" class="headerlink" title="Library库"></a>Library库</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45279063/article/details/115324601">https://blog.csdn.net/weixin_45279063/article/details/115324601</a></p>
<p>以后面要用到的DEBUG库为例：</p>
<p>库的调用方是MdeModulePkg下的某个INF模块，被调用方是MdePkg库（这个属于基础库很常用）</p>
<ol>
<li>调用方的INF中要导入库模块的dec和要用到的LibraryClasses</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Packages]</span><br><span class="line">  MdePkg/MdePkg.dec #这里包含了库模块MdePkg的dec声明，获取到MdePkg所有对外开放的库接口</span><br><span class="line">  MdeModulePkg/MdeModulePkg.dec #这是调用方模块</span><br><span class="line"></span><br><span class="line">[LibraryClasses]</span><br><span class="line">  DevicePathLib</span><br><span class="line">  UefiBootServicesTableLib</span><br><span class="line">  UefiRuntimeServicesTableLib</span><br><span class="line">  MemoryAllocationLib</span><br><span class="line">  BaseMemoryLib</span><br><span class="line">  UefiLib</span><br><span class="line">  BaseLib</span><br><span class="line">  UefiDriverEntryPoint</span><br><span class="line">  DebugLib #这里导入了MdePkg库的DebugLib类（头文件），类似其他语言的import或者include namespace</span><br><span class="line">  PcdLib</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用方的c代码中可以直接include库的头文件（不需要用相对地址包含头文件）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Library/DebugLib.h&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用方使用库的函数体DEBUG();</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG((DEBUG_INFO, &quot;Initializing XXX controller in slot %d\n&quot;, Slot));</span><br><span class="line"></span><br><span class="line">Status = InitController(PciIo, Slot);</span><br><span class="line">if (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG((DEBUG_ERROR, &quot;Failed to switch Host to PCIe mode: %r\n&quot;, Status));</span><br><span class="line">    return Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DEBUG打印"><a href="#DEBUG打印" class="headerlink" title="DEBUG打印"></a>DEBUG打印</h2><p><a target="_blank" rel="noopener" href="https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging">https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging</a></p>
<p>在使用DEBUG INFO的MdeModulePkg模块的dsc中，声明DEBUG库的全局变量PcdDebugPropertyMask和PcdDebugPrintErrorLevel，指定支持INFO级别打印，否则默认只会打印DEBUG(ERROR)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[PcdsFixedAtBuild]</span><br><span class="line"># refer to https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging</span><br><span class="line">  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x0f</span><br><span class="line">  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x80000040</span><br></pre></td></tr></table></figure>

<p>再编译MdeModulePkg inf，输出的efi可见INFO级别的打印生效。</p>
<h2 id="UTF8中文报错"><a href="#UTF8中文报错" class="headerlink" title="UTF8中文报错"></a>UTF8中文报错</h2><p>问题log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\edk2\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\BayhubHost.h(1): error C2220: the following warning is treated as an error</span><br><span class="line">C:\edk2\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\BayhubHost.h(1): warning C4819: The file contains a character that cannot be represented in the current code page (936). Save the file in Unicode format to prevent data loss</span><br></pre></td></tr></table></figure>

<p>错误信息指出：<br>警告C4819被当作错误处理<br>文件包含无法在当前代码页(936，即中文GBK编码)中表示的字符</p>
<p>解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用Notepad++重新保存文件:</span><br><span class="line">打开文件，编码选择&quot;UTF-8 with signature (UTF-8-BOM)&quot;或者&quot;UTF-8&quot;</span><br><span class="line">保存文件</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件有非ASCII字符（特别是在注释中）</span><br><span class="line">有时文件的首行可能有不可见的BOM（字节顺序标记）或其他特殊字符</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/Windows%20Driver%20-%20Visual%20Studio%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/Windows%20Driver%20-%20Visual%20Studio%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Windows Driver - Visual Studio配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:33:49" itemprop="dateModified" datetime="2025-11-18T10:33:49+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">windows驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Windows-Driver-Visual-Studio配置"><a href="#Windows-Driver-Visual-Studio配置" class="headerlink" title="Windows Driver - Visual Studio配置"></a>Windows Driver - Visual Studio配置</h1><h2 id="安装VisualStudio-SDK-WDK环境"><a href="#安装VisualStudio-SDK-WDK环境" class="headerlink" title="安装VisualStudio+SDK+WDK环境"></a>安装VisualStudio+SDK+WDK环境</h2><p>全部流程：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk</a></p>
<p>注意：WDK安装前要求先安装适配版本的SDK：</p>
<p><a target="_blank" rel="noopener" href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/">https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/</a></p>
<p>推荐按以上链接在VS安装程序中安装Windows 11 SDK (10.0.26100.0)，注意默认选中的不是这个版本，需要手动选择这个版本：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408121640199.png" alt="image-20240812164012107"></p>
<p>正常安装完SDK和WDK后，创建一个KMDF项目是像这样：如果缺少SDK和Driver Setting这些，说明SDK版本不匹配</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408121647174.png" alt="image-20240812164731134"></p>
<p>注意：如果在有问题的环境创建了项目编译会报错，在环境配好后该项目也不能用还是会编译报错，应该删除重新建。</p>
<h2 id="VS2019-SDK-WDK环境"><a href="#VS2019-SDK-WDK环境" class="headerlink" title="VS2019+SDK+WDK环境"></a>VS2019+SDK+WDK环境</h2><p>TODO</p>
<h2 id="搭建DVL环境（for-WHQL）"><a href="#搭建DVL环境（for-WHQL）" class="headerlink" title="搭建DVL环境（for WHQL）"></a>搭建DVL环境（for WHQL）</h2><p>前置环境：Visual Studio 2019 + SDK 22000 + WDK 22000 + 一些MSVC模块 </p>
<p>(Visual Studio 2022 + 24H2 WDK无法正常执行CodeQL(找不到x86\InfVerif.dll)，也没有自带SDV，暂时不用VS2022环境)</p>
<p>DVL：driver verification log</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/develop/creating-a-driver-verification-log">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/develop/creating-a-driver-verification-log</a></p>
<p>The <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/design/compatibility/">Windows Hardware Certification Program</a> requires a driver verification log (DVL) for driver submissions. The DVL contains a summary of the results from static analysis tools, <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql">CodeQL</a>. The DVL doesn’t contain any source code information. Before creating a DVL for your driver, run CodeQL, the code analysis tool, and static driver verifier. </p>
<p>使用VS2019+WDK，WHQL的DVL生成依赖于三项文件：<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271608916.png" alt="image-20241227160816886"></p>
<ol>
<li>Code Analysis（CA） log： VS2019 + WDK 环境可以生成</li>
<li>Static Driver Verifier（SDV） log：VS2019 + WDK 环境可以生成</li>
<li>CodeQL Sarif log：需要配置CodeQL环境</li>
</ol>
<p>根据微软的SDV文档（<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-driver-verifier%EF%BC%89%EF%BC%9ACodeQL">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-driver-verifier）：CodeQL</a> 和SDV似乎是并列关系，都是静态代码分析，因此VS 2022直接不支持SDV，只推荐CodeQL。但不确定WHQL logo driver是不是必须要SDV，因此还是用VS2019环境以确保DVL需要的三种log都能生成。</p>
<h3 id="配置CodeQL环境"><a href="#配置CodeQL环境" class="headerlink" title="配置CodeQL环境"></a>配置CodeQL环境</h3><p>详细步骤参考：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql#queries-and-suites">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql#queries-and-suites</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/Windows-Driver-Developer-Supplemental-Tools">https://github.com/microsoft/Windows-Driver-Developer-Supplemental-Tools</a></p>
<p>WHQL的OS版本对CodeQL版本的兼容矩阵表：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271036011.png" alt="image-20241227103629965"></p>
<p>假如要发布24H2的WHQL driver，需要选用红框的版本。按以下几步配置CodeQL环境：</p>
<p>创建CodeQL环境的home目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; mkdir C:\codeql-home</span><br></pre></td></tr></table></figure>

<ol>
<li>下载CodeQL 2.15.4 二进制包</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/github/codeql-cli-binaries/releases/tag/v2.15.4">https://github.com/github/codeql-cli-binaries/releases/tag/v2.15.4</a></p>
<ol start="2">
<li><p>下载Windows Driver Developer Supplemental Tools的WHCP_24H2分支；或者git clone，再checkout到WHCP_24H2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）下载Windows Driver Developer Supplemental Tools的WHCP_24H2分支：</span><br><span class="line">git clone https://github.com/microsoft/Windows-Driver-Developer-Supplemental-Tools.git</span><br><span class="line">git branch -a</span><br><span class="line">git checkout WHCP_24H2</span><br><span class="line">也可以在github页面切换到WHCP_24H2分支后下载压缩包</span><br><span class="line"></span><br><span class="line">（2）查看分支：</span><br><span class="line">C:\codeql-home\Windows-Driver-Developer-Supplemental-Tools&gt;git branch</span><br><span class="line">* WHCP_24H2</span><br><span class="line">  main</span><br></pre></td></tr></table></figure>

<p>注意，不同的分支可能对应不同的<a target="_blank" rel="noopener" href="https://github.com/microsoft/Windows-Driver-Developer-Supplemental-Tools/blob/main/suites/windows_driver_mustfix.qls">windows_driver_mustfix.qls</a></p>
</li>
<li><p>安装CodeQL query packages</p>
<p>如果不安装CodeQL query packages，直接执行codeql analyze会报package缺失，目前我是手动安装package：VS rebuild多次执行后处理脚本RunCodeQLRebuildQuery.bat，每次报错缺什么版本package就装什么，如下图，直到不再报错。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271547361.png" alt="image-20241227154734283"></p>
<p>安装单个query packages方法：在C:\codeql-home\codeql目录下（包含codeql.exe），执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql pack download &lt;package&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure>

<p>安装所有依赖的query packages过程如下（仅针对CodeQL 2.15.4）：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Package specifications to check for download: codeql/cpp-queries@0.9.0</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/cpp-queries@0.9.0</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;</span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download microsoft/windows-drivers@1.1.0</span><br><span class="line">Package specifications to check for download: microsoft/windows-drivers@1.1.0</span><br><span class="line">Did not need to download any packs.</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Nothing downloaded.</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/cpp-all@0.12.1</span><br><span class="line">Package specifications to check for download: codeql/cpp-all@0.12.1</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/cpp-all@0.12.1 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;</span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/dataflow@0.1.4</span><br><span class="line">Package specifications to check for download: codeql/dataflow@0.1.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/dataflow@0.1.4 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/rangeanalysis@0.0.3</span><br><span class="line">Package specifications to check for download: codeql/rangeanalysis@0.0.3</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/rangeanalysis@0.0.3 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/ssa@0.2.4</span><br><span class="line">Package specifications to check for download: codeql/ssa@0.2.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/ssa@0.2.4 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/tutorial@0.2.4</span><br><span class="line">Package specifications to check for download: codeql/tutorial@0.2.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/tutorial@0.2.4 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/util@0.2.4</span><br><span class="line">Package specifications to check for download: codeql/util@0.2.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/util@0.2.4 (library)</span><br><span class="line"></span><br><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/typetracking@0.2.4</span><br><span class="line">Package specifications to check for download: codeql/typetracking@0.2.4</span><br><span class="line">Package install location: C:\Users\thomas.hu.O2\.codeql\packages</span><br><span class="line">Installed fresh codeql/typetracking@0.2.4 (library)</span><br></pre></td></tr></table></figure>

<p>有时候网络不好下载失败，换个时间多次重试直到安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\codeql-home\codeql&gt;codeql pack download codeql/cpp-queries@0.9.0</span><br><span class="line">Package specifications to check for download: codeql/cpp-queries@0.9.0</span><br><span class="line">A fatal error occurred: Error downloading blob.</span><br><span class="line">(eventual cause: SocketTimeoutException &quot;Read timed out&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="CodeQL生成-sarif"><a href="#CodeQL生成-sarif" class="headerlink" title="CodeQL生成.sarif"></a>CodeQL生成.sarif</h3><p>(1) 使用.BAT（参考 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql#queries-and-suites">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql#queries-and-suites</a>  7. Visual Studio Post-Build Event (Optional)）</p>
<p>(2) RunCodeQLRebuildQuery.bat内容如下：</p>
<p>​    功能：在C:\codeql-home创建空目录databases，再执行codeql create database和codeql analyze database，其中codeql analyze database依赖于前面的CodeQL query packages和Windows Driver Developer Supplemental Tools。最后输出kmdf.sarif。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ECHO &quot;&gt;&gt;&gt; Running CodeQL Security Rule V 1.0 &lt;&lt;&lt;&quot;</span><br><span class="line">ECHO &quot;Current directory:&quot; %cd%</span><br><span class="line"></span><br><span class="line">set HOME=C:\codeql-home</span><br><span class="line">set SRC=%cd%</span><br><span class="line"></span><br><span class="line">ECHO &quot;&gt;&gt;&gt; Removing previously created rules database &lt;&lt;&lt;&quot;</span><br><span class="line">if exist %HOME%\databases (</span><br><span class="line">	rmdir /s/q %HOME%\databases</span><br><span class="line">)</span><br><span class="line">mkdir %HOME%\databases</span><br><span class="line"></span><br><span class="line">ECHO &quot;&gt;&gt;&gt; codeql create database &lt;&lt;&lt;&quot;</span><br><span class="line">%HOME%\codeql\codeql database create &quot;%HOME%\databases&quot; -l=cpp -s=%SRC% -c &quot;msbuild %SRC%\bhtpcr.sln /p:Configuration=Win8.1Release /p:Platform=ARM64 /t:rebuild /p:PostBuildEventUseInBuild=false&quot;</span><br><span class="line">::ECHO &quot;&gt;&gt;&gt; codeql analyze database &lt;&lt;&lt;&quot;</span><br><span class="line">::codeql database analyze &lt;path to database&gt; &lt;path to query suite .qls file&gt;</span><br><span class="line">CALL %HOME%\codeql\codeql database analyze --download &quot;%HOME%\databases&quot; &quot;%HOME%\Windows-Driver-Developer-Supplemental-Tools\suites\windows_driver_mustfix.qls&quot; --format=sarifv2.1.0 --output=%HOME%\databases\kmdf.sarif --rerun</span><br><span class="line"></span><br><span class="line">ECHO &quot;&gt;&gt;&gt; Loading SARIF Results in Visual Studio &lt;&lt;&lt;&quot;</span><br><span class="line">CALL devenv /Edit %HOME%\databases\kmdf.sarif</span><br><span class="line">SET ERRORLEVEL = 0</span><br></pre></td></tr></table></figure>

<p>(3) 设置项目后处理脚本为RunCodeQLRebuildQuery.bat，并使能，如下图：</p>
<p>这个示例RunCodeQLRebuildQuery.bat位置是.vcxproj的上级目录，也可以放同级目录，不需要加..\</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271529699.png" alt="image-20241227152914648"></p>
<p>(4)运行项目rebuild，编译后会运行RunCodeQLRebuildQuery.bat，正常结果显示success，并能看到kmdf.sarif文件，如下图。如果有错一般是前面的query依赖库没装好，或者VS+WDK版本不兼容。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271544290.png" alt="image-20241227154401168"></p>
<p>(5) 最后将C:\codeql-home\databases\kmdf.sarif拷贝到Driver的vcproj目录，后面的DVL生成会用到。</p>
<p>(6) RunCodeQLRebuildQuery.bat的调试经验：</p>
<p>如果找不到msbuild，需要将msbuild.exe的路径加到系统PATH，例如（D:\Program Files\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin）</p>
<p>中文系统上执行msbuild可能输出乱码，CMD中设置中文编码支持：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure>

<h3 id="运行SDV和Code-Analysis，生成DVL"><a href="#运行SDV和Code-Analysis，生成DVL" class="headerlink" title="运行SDV和Code Analysis，生成DVL"></a>运行SDV和Code Analysis，生成DVL</h3><p>（1）生成SDV：VS2019 + WDK 22000安装后自带SDV（Static Driver Verifier）</p>
<p>VS2019 -&gt; Extension -&gt; Driver -&gt; Launch Static Driver Verifier</p>
<p>默认选择must fix项，但WHQL的HLK并不需要测所有，也不要求测试项必须通过，因此也可以选择default，或者自定义只测一项nullcheck。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271607797.png" alt="image-20241227160707770"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271607341.png" alt="image-20241227160717317"></p>
<p>（2）生成CA：VS2019 -&gt; Analyze -&gt; Run code analysis -&gt; Run code analysis on bhtsddr</p>
<p>（3）生成kmdf.sarif：已在项目目录下</p>
<p>（4）生成DVL：VS2019 -&gt; Extension -&gt; Driver -&gt; Create driver verification log</p>
<p>显示三种依赖log都detected，Create有警告无所谓，在项目目录下有DriverName.DVL.XML文件生成</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202412271630847.png" alt="image-20241227163042814"></p>
<p>DVL示例内容如下（SDV和CA有fail，但不影响WHQL HLK）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;Data&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.XMLTimeStamp&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;12/27/2024 15:54:26&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.DriverBinary&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;bhtsdhubdr.sys&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.BinaryTimeStamp&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;01/01/1601 08:00:00&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.DriverType&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;generic&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.DriverSize&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;LOC&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.DriverVersion&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;0&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.Libs&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;Number of external libraries used&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.SDV.Version&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;sdv-2021-03-16&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.SDV.ActiveRuleTotal&quot; ScoreValue=&quot;4&quot; ScoreUnit=&quot;Total rules available&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.SDV.Rule.nullcheck&quot; ScoreValue=&quot;1&quot; ScoreUnit=&quot;SDV_FAILED&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.CodeAnalysis.Summary&quot; ScoreValue=&quot;2&quot; ScoreUnit=&quot;Types of defects seen&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.CodeAnalysis.Defect.6385&quot; ScoreValue=&quot;1&quot; ScoreUnit=&quot;CA_FAILED&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.CodeAnalysis.Defect.6001&quot; ScoreValue=&quot;1&quot; ScoreUnit=&quot;CA_MUSTFIX_FAILED&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.Semmle.Summary&quot; ScoreValue=&quot;1&quot; ScoreUnit=&quot;Types of defects seen&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.Semmle.Defect.cpp/comparison-with-wider-type&quot; ScoreValue=&quot;0&quot; ScoreUnit=&quot;SEMMLE_FAILED&quot;/&gt;</span><br><span class="line">&lt;AssessmentScore ScoreName=&quot;bhtsdhubdr.arm64.General.Checksum&quot; ScoreValue=&quot;4TYw1CLepWklxyssSBb7x9m/tAtAuZozCUvaOq7od2SAQZx6SRlBzEK1wIlqB34JiwSni1qyOrcXYr3C3mrXTA==&quot; ScoreUnit=&quot;DVL Checksum Value&quot;/&gt;</span><br><span class="line">&lt;/Data&gt;</span><br></pre></td></tr></table></figure>

<p>WHQL的HLK测试会用到此DVL文件。</p>
<h2 id="代码新项目相关的配置"><a href="#代码新项目相关的配置" class="headerlink" title="代码新项目相关的配置"></a>代码新项目相关的配置</h2><h3 id="VisualStudio新项目环境配置"><a href="#VisualStudio新项目环境配置" class="headerlink" title="VisualStudio新项目环境配置"></a>VisualStudio新项目环境配置</h3><h4 id="使用VSCode快捷键"><a href="#使用VSCode快捷键" class="headerlink" title="使用VSCode快捷键"></a>使用VSCode快捷键</h4><p>工具–&gt;选项-&gt;键盘-&gt;键盘映射方案选VSCode</p>
<h4 id="WDF项目找不到头文件问题"><a href="#WDF项目找不到头文件问题" class="headerlink" title="WDF项目找不到头文件问题"></a>WDF项目找不到头文件问题</h4><ol>
<li>找不到&lt;ntddk.h&gt;和&lt;wdf.h&gt;</li>
</ol>
<p>在项目配置-&gt; C&#x2F;C++ -&gt; General -&gt; Additional Include Directories -&gt; 加上WDK和WDF的include头文件路径</p>
<p>Ntddk.h contains core Windows kernel definitions for all drivers, while Wdf.h<br>contains definitions for drivers based on the Windows Driver Framework (WDF).  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408121042763.png" alt="image-20240812104158672"></p>
<p>注意WDF的版本，Win11选WDF 1.33，参考：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/wdf/kmdf-version-history">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/wdf/kmdf-version-history</a></p>
<ol start="2">
<li>找不到device.tmh</li>
</ol>
<p>项目设置 -&gt; WPP Tracing -&gt; 设置 “Run Wpp Tracing” 为 YES</p>
<h4 id="WDF项目找不到链接symbol"><a href="#WDF项目找不到链接symbol" class="headerlink" title="WDF项目找不到链接symbol"></a>WDF项目找不到链接symbol</h4><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/error-messages/tool-errors/linker-tools-error-lnk2019?view=msvc-170#third-party-library-issues-and-vcpkg">https://learn.microsoft.com/en-us/cpp/error-messages/tool-errors/linker-tools-error-lnk2019?view=msvc-170#third-party-library-issues-and-vcpkg</a></p>
<p>如果是调用第三方库API报此问题，基本上是项目配置没有链接这个库</p>
<p>The object file or library that contains the definition of the symbol isn’t linked</p>
<p>以SDBUS驱动为例，ntddsd.h定义的SdBusSubmitRequest只有declaration，其函数体实现其实是在SDBUS.lib里，用everything搜索此lib（WDK路径），加到项目配置的Link dependence lib（Link -&gt; Input -&gt; Additional Dependence），即可编译通过。</p>
<p>The <em>ntddsd.h</em> header file, which is provided in the Windows Driver Kit (WDK), declares the prototypes for the routines exposed by the SD bus library.</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/sd/sd-card-driver-stack">https://learn.microsoft.com/en-us/windows-hardware/drivers/sd/sd-card-driver-stack</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408221950345.png" alt="image-20240822195016239"></p>
<p>另外一个示例：</p>
<p>RtlStringCbVPrintfA打印函数属于ntstrsafe.h定义，其lib同名，位于WDK的km目录；一般WDF驱动把km和kmdf的.lib都加到项目的linker路径：（Link -&gt; Input -&gt; Additional Dependence）</p>
<p>注意需要指定到.lib文件名，一般是用到哪个lib才链接哪个lib；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\km\x64\ntstrsafe.lib</span><br></pre></td></tr></table></figure>

<p>也可以用*匹配所有lib：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\km\x64\*.lib</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\wdf\kmdf\x64\1.33\*.lib</span><br></pre></td></tr></table></figure>

<h4 id="VS-Code配置项目包含WDF-WDM头文件"><a href="#VS-Code配置项目包含WDF-WDM头文件" class="headerlink" title="VS Code配置项目包含WDF&#x2F;WDM头文件"></a>VS Code配置项目包含WDF&#x2F;WDM头文件</h4><p>在.vscode的c_cpp_properties.json添加WDF&#x2F;WDM所在的头文件定义（即前面VisualStudio添加的Additional Include Directories），在WDK目录，用everything搜索wdf.h和wdm.h所在的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Include\\wdf\\kmdf\\1.15&quot;,</span><br><span class="line">                &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\km&quot;,</span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>

<p>注意上图windows路径需要将单斜杠全局替换成双斜杠，空格不需要加反斜杠</p>
<p>替换完毕查看是否能跳转，例如单击WdfIoQueueCreate能跳转到wdfio.h的函数体定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_Must_inspect_result_</span><br><span class="line">_IRQL_requires_max_(DISPATCH_LEVEL)</span><br><span class="line">NTSTATUS</span><br><span class="line">FORCEINLINE</span><br><span class="line">WdfIoQueueCreate(</span><br><span class="line">    _In_</span><br><span class="line">    WDFDEVICE Device,</span><br><span class="line">    _In_</span><br><span class="line">    PWDF_IO_QUEUE_CONFIG Config,</span><br><span class="line">    _In_opt_</span><br><span class="line">    PWDF_OBJECT_ATTRIBUTES QueueAttributes,</span><br><span class="line">    _Out_opt_</span><br><span class="line">    WDFQUEUE* Queue</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    return ((PFN_WDFIOQUEUECREATE) WdfFunctions[WdfIoQueueCreateTableIndex])(WdfDriverGlobals, Device, Config, QueueAttributes, Queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码中支持中文编码"><a href="#代码中支持中文编码" class="headerlink" title="代码中支持中文编码"></a>代码中支持中文编码</h4><p>Warning C4819 The file contains a character that cannot be represented in the current code page (936). Save the file in Unicode format to prevent data loss</p>
<p>这个警告是关于代码页(code page)编码的问题。警告 C4819 表示文件中包含无法在当前代码页(936,即GBK编码)中表示的字符。</p>
<p>解决这个问题有以下几种方法:</p>
<ol>
<li>最推荐的方法是将文件保存为 UTF-8 with BOM 格式:</li>
</ol>
<ul>
<li>在 Visual Studio 中打开文件</li>
<li>点击”文件” -&gt; “高级保存选项”</li>
<li>在编码下拉框中选择”UTF-8 with signature (Codepage 65001)”</li>
<li>点击保存</li>
</ul>
<ol start="2">
<li>如果需要保持当前编码,可以在文件开头添加编码指示:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma code_page(65001)  // 使用 UTF-8 编码</span><br><span class="line">// ... 其余代码 ...</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>也可以在项目设置中修改:</li>
</ol>
<ul>
<li>右键项目 -&gt; 属性</li>
<li>C&#x2F;C++ -&gt; 命令行</li>
<li>在”其他选项”中添加 <code>/utf-8</code></li>
</ul>
<p>尝试过最有效的是方法3，但需要注意 Release和Debug的项目配置是独立的，需要配置两次&#x2F;utf-8</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/Windows%20Driver%20--%20INF%20Verifier%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/Windows%20Driver%20--%20INF%20Verifier%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Windows Driver -- INF Verifier使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:34:13" itemprop="dateModified" datetime="2025-11-18T10:34:13+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">windows驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Windows-Driver-–-INF-Verifier使用笔记"><a href="#Windows-Driver-–-INF-Verifier使用笔记" class="headerlink" title="Windows Driver – INF Verifier使用笔记"></a>Windows Driver – INF Verifier使用笔记</h1><p>WDK有INF verifier用于检测Driver安装包的INF信息文件的内容是否符合要求：如果INF不符合要求，可能在安装Driver报错或者Driver运行时功能报错。</p>
<h2 id="INF-verifier使用"><a href="#INF-verifier使用" class="headerlink" title="INF verifier使用"></a>INF verifier使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\infverif.exe /w /v C:\path\driver.inf</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/running-infverif-from-the-command-line">https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/running-infverif-from-the-command-line</a></p>
<h2 id="排错示例"><a href="#排错示例" class="headerlink" title="排错示例"></a>排错示例</h2><p>新建WDF驱动项目时产生默认的INF，但其中一些符号需要替换，否则安装driver时会直接报错安装失败</p>
<ol>
<li>DIRID 13问题</li>
</ol>
<p>driver.sys一般的路径符号 DIRID是12，较新的OS WDK要求DIRID使用13，用于实现driver package isolation：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/porting-inf-to-windows-driver">https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/porting-inf-to-windows-driver</a></p>
<p>错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Program Files (x86)\Windows Kits\10\Tools\10.0.26100.0\x64&gt;</span><br><span class="line">ARM64\Debug\O2SD\O2SD.inf</span><br><span class="line">ERROR(1322) in C:\Users\cursorhu\source\repos\O2SD\ARM64\Debug\O2SD\O2SD.inf, line 49: Destination file path &#x27;C:\Windows\System32\drivers&#x27; for file &#x27;O2SD.sys&#x27; is not isolated to DIRID 13.</span><br></pre></td></tr></table></figure>

<p>解决(git diff)：设置DestinationDirs &#x3D; 13，并设置SourceDisksNames的TargetOSVersion</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> [DestinationDirs]</span><br><span class="line">-DefaultDestDir = 12 ;DIRID_DRIVERS; </span><br><span class="line">+DefaultDestDir = 13 ;DIRID_DRIVERS; %13% only supported since OS build 16299</span><br><span class="line"></span><br><span class="line">[SourceDisksNames]</span><br><span class="line">...</span><br><span class="line">+%ManufacturerName% = Generic,NTarm64.10.0...26100 ; with TargetOSVersion</span><br><span class="line"></span><br><span class="line">+[Generic.NTarm64.10.0...26100]</span><br><span class="line"> ServiceType    = 1               ; SERVICE_KERNEL_DRIVER</span><br><span class="line"> StartType      = 3               ; SERVICE_DEMAND_START</span><br><span class="line"> ErrorControl   = 1               ; SERVICE_ERROR_NORMAL</span><br><span class="line">-ServiceBinary  = %12%\O2SD.sys</span><br><span class="line">+ServiceBinary  = %13%\O2SD.sys  ; DestinationDirs</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>变量未定义问题</li>
</ol>
<p>错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">报错1：Unresolved $ARCH$ token for section [generic.nt$arch$]. Must run stampinf tool to resolve case sensitive $ARCH$ tokens.</span><br><span class="line"></span><br><span class="line">报错2：KmdfLibraryVersion directive has invalid value &quot;$KmdfLibraryVersion&quot;</span><br></pre></td></tr></table></figure>

<p>解决(git diff)：根据平台环境指定变量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-%ManufacturerName% = Generic,NT$ARCH$</span><br><span class="line">+%ManufacturerName% = Generic,NTarm64.10.0...26100 </span><br><span class="line"></span><br><span class="line">-[Generic.NT$ARCH$]</span><br><span class="line">+[Generic.NTarm64.10.0...26100]</span><br><span class="line"></span><br><span class="line">-KmdfLibraryVersion = $KMDFVERSION$</span><br><span class="line">+KmdfLibraryVersion = 1.33</span><br></pre></td></tr></table></figure>

<p>全部错误修复后，显示如下：INF is VALID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.\infverif.exe /w /v C:\Users\cursorhu\source\repos\O2SD\O2SD.inf</span><br><span class="line">Running in Verbose</span><br><span class="line">Running Windows Driver INF check</span><br><span class="line"></span><br><span class="line">Validating O2SD.inf</span><br><span class="line">INF is VALID</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/Windows%20Driver%20--%20WDF%20PCIe-SD%20Host%20Controller%20Driver%20Analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/Windows%20Driver%20--%20WDF%20PCIe-SD%20Host%20Controller%20Driver%20Analysis/" class="post-title-link" itemprop="url">WDF PCIe-SD Host Controller Driver Analysis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:43:52" itemprop="dateModified" datetime="2025-11-18T10:43:52+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">windows驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Windows-WDF-PCIe-SD-Host-Controller-Driver-Analysis"><a href="#Windows-WDF-PCIe-SD-Host-Controller-Driver-Analysis" class="headerlink" title="Windows WDF PCIe-SD Host Controller Driver Analysis"></a>Windows WDF PCIe-SD Host Controller Driver Analysis</h1><h2 id="Current-Status-Analysis"><a href="#Current-Status-Analysis" class="headerlink" title="Current Status Analysis"></a>Current Status Analysis</h2><p>Based on the dumpfile information:</p>
<h3 id="1-Driver-Stack-Structure-Correct"><a href="#1-Driver-Stack-Structure-Correct" class="headerlink" title="1. Driver Stack Structure - Correct"></a>1. Driver Stack Structure - Correct</h3><ul>
<li><p>Device stack is properly established: partmgr → disk → sdhcstor</p>
</li>
<li><p>Upper layer device (disk.sys) successfully starts and attaches to your driver</p>
</li>
<li><p>ServiceName is “disk”, DeviceInst shows correct device path</p>
</li>
</ul>
<h3 id="2-Critical-Issue-ExtensionFlags-Inconsistency"><a href="#2-Critical-Issue-ExtensionFlags-Inconsistency" class="headerlink" title="2. Critical Issue: ExtensionFlags Inconsistency"></a>2. Critical Issue: ExtensionFlags Inconsistency</h3><p>Device object ffffc701663ddc80 (Upper device):</p>
<ul>
<li><p>⚠️ ExtensionFlags &#x3D; 0x0000000000 (Highlighted in orange - THIS IS THE PROBLEM)</p>
</li>
<li><p>This device object is missing necessary extension flags</p>
</li>
</ul>
<p>Device object ffffc70162a1aa0 (Driver object):</p>
<ul>
<li><p>✓ ExtensionFlags &#x3D; 0x00000800 (DOE_DEFAULT_SD_PRESENT)</p>
</li>
<li><p>This flag indicates SD card present - this is correct</p>
</li>
</ul>
<h3 id="3-BSOD-Root-Cause-Analysis"><a href="#3-BSOD-Root-Cause-Analysis" class="headerlink" title="3. BSOD Root Cause Analysis"></a>3. BSOD Root Cause Analysis</h3><p>ExtensionFlags being 0 indicates:</p>
<ul>
<li><p>Device extension object may not be properly initialized</p>
</li>
<li><p>I&#x2F;O buffer management related extension information is missing</p>
</li>
<li><p>Likely missing proper setup during IRP_MJ_CREATE or device creation</p>
</li>
</ul>
<h2 id="Solution-Correctness-Assessment"><a href="#Solution-Correctness-Assessment" class="headerlink" title="Solution Correctness Assessment"></a>Solution Correctness Assessment</h2><h3 id="✓-Correct-Aspects"><a href="#✓-Correct-Aspects" class="headerlink" title="✓ Correct Aspects:"></a>✓ Correct Aspects:</h3><ol>
<li><p>I&#x2F;O Queue Implementation - Sequential handling of Read&#x2F;Write requests is correct</p>
</li>
<li><p>Driver Stack Architecture - Functioning as port driver below disk.sys is standard architecture</p>
</li>
<li><p>Device Attachment - Upper device successfully attaching indicates AddDevice is fundamentally correct</p>
</li>
</ol>
<h3 id="Areas-Requiring-Correction"><a href="#Areas-Requiring-Correction" class="headerlink" title="Areas Requiring Correction:"></a>Areas Requiring Correction:</h3><ol>
<li>Device Extension Object Initialization</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Check your EvtDeviceAdd or device creation code</span><br><span class="line">// Ensure proper Device Extension setup</span><br><span class="line">WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&amp;attributes, DEVICE_CONTEXT);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ExtensionFlags Configuration</li>
</ol>
<ul>
<li><p>Verify proper call to WdfDeviceInitSetDeviceType()</p>
</li>
<li><p>Ensure device characteristics flags are correctly set:</p>
</li>
<li><p>FILE_AUTOGENERATED_DEVICE_NAME</p>
</li>
<li><p>FILE_DEVICE_SECURE_OPEN</p>
</li>
<li><p>FILE_PORTABLE_DEVICE</p>
</li>
</ul>
<ol start="3">
<li>I&#x2F;O Buffer Management Critical Points</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Set correct buffer method during device initialization</span><br><span class="line">WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoDirect); // or WdfDeviceIoBuffered</span><br><span class="line"></span><br><span class="line">// Ensure proper alignment requirements are set</span><br><span class="line">WdfDeviceInitSetIoInCallerContextCallback(DeviceInit, YourPreprocessCallback);</span><br></pre></td></tr></table></figure>

<h2 id="Recommended-Debugging-Steps"><a href="#Recommended-Debugging-Steps" class="headerlink" title="Recommended Debugging Steps"></a>Recommended Debugging Steps</h2><ol>
<li>Verify Device Extension Allocation</li>
</ol>
<ul>
<li><p>Confirm DEVICE_CONTEXT structure is properly allocated and initialized</p>
</li>
<li><p>Use !wdfkd.wdfdevice command to inspect WDF device object state</p>
</li>
</ul>
<ol start="2">
<li>Add Tracing</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Add DbgPrint or WPP tracing at critical points:</span><br><span class="line">- EvtDeviceAdd</span><br><span class="line">- EvtDevicePrepareHardware</span><br><span class="line">- I/O Queue callbacks</span><br><span class="line">- Buffer mapping/locking operations</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Validate DMA&#x2F;Buffer Operations</li>
</ol>
<ul>
<li><p>Check if DMA Enabler is properly created (if using DMA)</p>
</li>
<li><p>Verify MDL (Memory Descriptor List) handling</p>
</li>
<li><p>Ensure all buffer pointers are properly locked and mapped before use</p>
</li>
</ul>
<ol start="4">
<li>Inspect IRP Handling</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Ensure proper handling of these IRPs during mount:</span><br><span class="line">- IRP_MJ_CREATE</span><br><span class="line">- IRP_MJ_DEVICE_CONTROL (IOCTL_MOUNTDEV_*)</span><br><span class="line">- IRP_MJ_PNP (especially IRP_MN_QUERY_CAPABILITIES)</span><br></pre></td></tr></table></figure>

<h2 id="Specific-Code-Areas-to-Review"><a href="#Specific-Code-Areas-to-Review" class="headerlink" title="Specific Code Areas to Review"></a>Specific Code Areas to Review</h2><h3 id="Device-Initialization-Priority-1"><a href="#Device-Initialization-Priority-1" class="headerlink" title="Device Initialization (Priority #1)"></a>Device Initialization (Priority #1)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">YourEvtDeviceAdd(</span><br><span class="line">    WDFDRIVER Driver,</span><br><span class="line">    PWDFDEVICE_INIT DeviceInit</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    WDF_OBJECT_ATTRIBUTES deviceAttributes;</span><br><span class="line">    WDFDEVICE device;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    </span><br><span class="line">    // CRITICAL: Set device type</span><br><span class="line">    WdfDeviceInitSetDeviceType(DeviceInit, FILE_DEVICE_MASS_STORAGE);</span><br><span class="line">    </span><br><span class="line">    // CRITICAL: Set I/O type</span><br><span class="line">    WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoDirect);</span><br><span class="line">    </span><br><span class="line">    // CRITICAL: Set device characteristics</span><br><span class="line">    WdfDeviceInitSetCharacteristics(DeviceInit,</span><br><span class="line">        FILE_AUTOGENERATED_DEVICE_NAME |</span><br><span class="line">        FILE_DEVICE_SECURE_OPEN |</span><br><span class="line">        FILE_PORTABLE_DEVICE,</span><br><span class="line">        FALSE);</span><br><span class="line">    </span><br><span class="line">    // Initialize device context</span><br><span class="line">    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&amp;deviceAttributes, DEVICE_CONTEXT);</span><br><span class="line">    </span><br><span class="line">    status = WdfDeviceCreate(&amp;DeviceInit, &amp;deviceAttributes, &amp;device);</span><br><span class="line">    if (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Initialize device extension here</span><br><span class="line">    PDEVICE_CONTEXT context = GetDeviceContext(device);</span><br><span class="line">    // Ensure all fields are properly initialized</span><br><span class="line">    </span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Buffer-Handling-in-I-O-Queue"><a href="#Buffer-Handling-in-I-O-Queue" class="headerlink" title="Buffer Handling in I&#x2F;O Queue"></a>Buffer Handling in I&#x2F;O Queue</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">YourEvtIoRead(</span><br><span class="line">    WDFQUEUE Queue,</span><br><span class="line">    WDFREQUEST Request,</span><br><span class="line">    size_t Length</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    WDFMEMORY memory;</span><br><span class="line">    PVOID buffer;</span><br><span class="line">    </span><br><span class="line">    // CRITICAL: Proper buffer retrieval</span><br><span class="line">    status = WdfRequestRetrieveOutputMemory(Request, &amp;memory);</span><br><span class="line">    if (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        WdfRequestComplete(Request, status);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buffer = WdfMemoryGetBuffer(memory, NULL);</span><br><span class="line">    if (buffer == NULL) &#123;</span><br><span class="line">        WdfRequestComplete(Request, STATUS_INSUFFICIENT_RESOURCES);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Ensure buffer is locked/mapped before hardware access</span><br><span class="line">    // Your DMA or PIO operation here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><ol>
<li><p>Immediate Action: Review Device Extension initialization code, ensure all necessary flags are set during device creation</p>
</li>
<li><p>Set Breakpoints: On all I&#x2F;O request handlers before mount operation</p>
</li>
<li><p>Verify: WdfDeviceInitSetDeviceType() and related device characteristics configuration</p>
</li>
<li><p>Analyze: Specific bugcheck code and parameters from the BSOD (if complete minidump available)</p>
</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Overall Assessment: Your architecture is fundamentally correct. The issue is concentrated in device object initialization and extension flags configuration. This is a typical detail that’s easy to overlook in WDF driver development, but critical for proper I&#x2F;O buffer management.</p>
<p>The fact that:</p>
<ul>
<li><p>Device stack builds correctly</p>
</li>
<li><p>Upper device attaches successfully</p>
</li>
<li><p>Queue shows “not busy”</p>
</li>
</ul>
<p>…indicates the framework is mostly correct. The ExtensionFlags discrepancy is the smoking gun pointing to incomplete device initialization during the AddDevice routine.</p>
<p>Confidence Level: High - This is a common pattern in WDF driver issues related to mount failures and I&#x2F;O buffer management.</p>
<p>Would you like me to review your source code to provide more specific corrections?</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/Windows%20Driver%20--%20Windbg%E8%81%94%E8%B0%83%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/Windows%20Driver%20--%20Windbg%E8%81%94%E8%B0%83%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Windows Driver -- Windbg联调环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:34:16" itemprop="dateModified" datetime="2025-11-18T10:34:16+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">windows驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Windows-Driver-–-Windbg联调环境配置"><a href="#Windows-Driver-–-Windbg联调环境配置" class="headerlink" title="Windows Driver – Windbg联调环境配置"></a>Windows Driver – Windbg联调环境配置</h1><p>参考：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection-automatically">https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection-automatically</a></p>
<h2 id="Target-PC配置"><a href="#Target-PC配置" class="headerlink" title="Target PC配置"></a>Target PC配置</h2><p>注意：</p>
<p>Target PC要先开测试模式，且关闭系统所有网络防火墙。</p>
<p>Target PC要能Ping通Host PC，即Host PC和Target PC可以用同一局域网的路由器(Router)或交换机(Hub)的网口相连。</p>
<p>Target PC的kdnet创建一次以后再创建也不会变。</p>
<p>Kdnet配置完成后，设备管理器的网络设备会有Kernel Debug Network设备（KDNET），且网口设备（例如下面的Intel Ethernet）会有感叹号Code53是正常的，表示此网口正作为KDNET debug端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32&gt;</span><br><span class="line">C:\Windows\System32&gt;cd c:\kdnet</span><br><span class="line"></span><br><span class="line">c:\kdnet&gt;kdnet.exe</span><br><span class="line"></span><br><span class="line">Network debugging is supported on the following NICs:</span><br><span class="line">busparams=0.31.6, Intel(R) Ethernet Connection (7) I219-V, KDNET is running on this NIC.</span><br><span class="line"></span><br><span class="line">Network debugging is supported on the following USB controllers:</span><br><span class="line">busparams=0.20.0, Intel(R) USB 3.1 eXtensible Host Controller - 1.10 (Microsoft)</span><br><span class="line"></span><br><span class="line">This Microsoft hypervisor supports using KDNET in guest VMs.</span><br><span class="line"></span><br><span class="line">c:\kdnet&gt;</span><br><span class="line">c:\kdnet&gt;kdnet.exe 10.52.4.41 50000</span><br><span class="line"></span><br><span class="line">Enabling network debugging on Intel(R) Ethernet Connection (7) I219-V.</span><br><span class="line"></span><br><span class="line">To debug this machine, run the following command on your debugger host machine.</span><br><span class="line">windbg -k net:port=50000,key=3s1m4bjm7ihi7.3b8dig9hl019g.2fyvva9v1ie3a.38mfaw4eweiuo</span><br><span class="line"></span><br><span class="line">Then reboot this machine by running shutdown -r -t 0 from this command prompt.</span><br><span class="line"></span><br><span class="line">c:\kdnet&gt;ping 10.52.4.41</span><br><span class="line"></span><br><span class="line">Pinging 10.52.4.41 with 32 bytes of data:</span><br><span class="line">Reply from 10.52.4.41: bytes=32 time=4ms TTL=128</span><br><span class="line">Reply from 10.52.4.41: bytes=32 time=1ms TTL=128</span><br><span class="line">Reply from 10.52.4.41: bytes=32 time=1ms TTL=128</span><br><span class="line">Reply from 10.52.4.41: bytes=32 time=1ms TTL=128</span><br><span class="line"></span><br><span class="line">Ping statistics for 10.52.4.41:</span><br><span class="line">    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</span><br><span class="line">Approximate round trip times in milli-seconds:</span><br><span class="line">    Minimum = 1ms, Maximum = 4ms, Average = 1ms</span><br></pre></td></tr></table></figure>

<h2 id="Host-PC配置"><a href="#Host-PC配置" class="headerlink" title="Host PC配置"></a>Host PC配置</h2><p>Host PC也关闭系统网络防火墙。</p>
<p>用Microsoft Store安装的Windbg Preview，Attach to Kernel，填入Target PC生成的Port和Key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port=50000,key=3s1m4bjm7ihi7.3b8dig9hl019g.2fyvva9v1ie3a.38mfaw4eweiuo</span><br></pre></td></tr></table></figure>

<p>连接成功后显示Connected to target ….</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Using NET for debugging</span><br><span class="line">Opened WinSock 2.0</span><br><span class="line">Waiting to reconnect...</span><br><span class="line"></span><br><span class="line">Connected to target 10.52.5.0 on port 50000 on local IP 10.52.4.41.</span><br></pre></td></tr></table></figure>

<h2 id="Windbg联机观测DbgPrint"><a href="#Windbg联机观测DbgPrint" class="headerlink" title="Windbg联机观测DbgPrint"></a>Windbg联机观测DbgPrint</h2><h3 id="Windbg显示DbgPrint"><a href="#Windbg显示DbgPrint" class="headerlink" title="Windbg显示DbgPrint"></a>Windbg显示DbgPrint</h3><p>需要打开Target PC的“Enabling verbose kernel output”</p>
<p>可用方法：</p>
<p>（1）在Target PC安装DebugView( <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview">Sysinternals DebugView</a>)，需要运行DebugView，选项勾选“Enable Kernel Debug”和“Enabling verbose kernel output”，才可以在DebugView和Host PC的Windbg同时观测到DbgPrint的打印。</p>
<p>（2）或者在Target PC安装DebugLogger(<a target="_blank" rel="noopener" href="https://github.com/tandasat/DebugLogger">DebugLogger</a>, open source implementation of <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview">Sysinternals DebugView</a>)，安装后默认打开了“Enabling verbose kernel output”，无需运行DebugLogger就可以在Host PC的Windbg观测到DebugPrint打印。这种方式可以记录系统重启中的Kernel过程。</p>
<p>注意：以下方法只是在Target PC手动设置打开所有过滤级别，并不能在Host PC的Windbg观测到Target PC的DebugPrint打印：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/reading-and-filtering-debugging-messages">Reading and Filtering Debugging Messages</a></p>
<h3 id="Windbg记录DbgPrint到log文件："><a href="#Windbg记录DbgPrint到log文件：" class="headerlink" title="Windbg记录DbgPrint到log文件："></a>Windbg记录DbgPrint到log文件：</h3><p>Command -&gt; Save Window to File。使用Log中的特定关键字过滤，另存为Filtered log再查看</p>
<h2 id="Windbg的联机调试方法"><a href="#Windbg的联机调试方法" class="headerlink" title="Windbg的联机调试方法"></a>Windbg的联机调试方法</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debug-universal-drivers---step-by-step-lab--echo-kernel-mode-">Debug Windows drivers step-by-step lab (echo kernel mode)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/Windows%20Driver%20--%20%E9%80%9A%E8%BF%87IDA%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.sys/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/Windows%20Driver%20--%20%E9%80%9A%E8%BF%87IDA%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.sys/" class="post-title-link" itemprop="url">Windows Driver -- 通过IDA逆向分析.sys</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:34:10" itemprop="dateModified" datetime="2025-11-18T10:34:10+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">windows驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Windows-Driver-–-通过IDA逆向分析-sys"><a href="#Windows-Driver-–-通过IDA逆向分析-sys" class="headerlink" title="Windows Driver – 通过IDA逆向分析.sys"></a>Windows Driver – 通过IDA逆向分析.sys</h1><p>背景：因业务需要规划下一代PCIe SD host的Windows驱动，要支持Win11和以后的最新特性，因为现有的SD驱动是基于Storport-miniport架构，在Win11上有诸多限制严重影响业务，因此决定转型为WDF驱动。本文浅显分析Realtek的Win11 PCIe SD Card reader驱动是用什么架构，内部如何实现。</p>
<h2 id="IDA反汇编工具"><a href="#IDA反汇编工具" class="headerlink" title="IDA反汇编工具"></a>IDA反汇编工具</h2><p>IDA能将二进制文件反汇编(disassemble)成为汇编代码，还支持将汇编代码进一步显示成C代码(decompile)。</p>
<p>下载IDA free版本就够用</p>
<p><a target="_blank" rel="noopener" href="https://hex-rays.com/products/ida/support/%20download_freeware%20/">https://hex-rays.com/products/ida/support/%20download_freeware%20/</a></p>
<h2 id="IDA分析驱动-sys文件"><a href="#IDA分析驱动-sys文件" class="headerlink" title="IDA分析驱动.sys文件"></a>IDA分析驱动.sys文件</h2><h3 id="IDA常用快捷键"><a href="#IDA常用快捷键" class="headerlink" title="IDA常用快捷键"></a>IDA常用快捷键</h3><p>F5：汇编代码转C代码显示（IDA称为伪代码，因为不是纯C）</p>
<p>Shift + F12：显示所有符号的字符串。可以全览所有函数，弄清用的什么技术栈</p>
<p>x：查看函数和变量的交叉引用，即被谁调用</p>
<p>esc：返回上个页面位置</p>
<h3 id="驱动分析示例"><a href="#驱动分析示例" class="headerlink" title="驱动分析示例"></a>驱动分析示例</h3><h4 id="RtsPer-sys下载"><a href="#RtsPer-sys下载" class="headerlink" title="RtsPer.sys下载"></a>RtsPer.sys下载</h4><p><a target="_blank" rel="noopener" href="https://www.driverscloud.com/en/services/GetInformationDriver/75616-0/realtek-cardreader-win10-win11-1002262121361zip">https://www.driverscloud.com/en/services/GetInformationDriver/75616-0/realtek-cardreader-win10-win11-1002262121361zip</a></p>
<h4 id="INF分析"><a href="#INF分析" class="headerlink" title="INF分析"></a>INF分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[Version]</span><br><span class="line">Signature=&quot;$Windows NT$&quot;</span><br><span class="line">Class=MTD</span><br><span class="line">ClassGuid = &#123;4d36e970-e325-11ce-bfc1-08002be10318&#125;</span><br><span class="line">Provider=%RTS%</span><br><span class="line">CatalogFile = RtsPer64.cat</span><br><span class="line">DriverVer=11/14/2022,10.0.22621.21361</span><br><span class="line"></span><br><span class="line">... 以下以Rts5227CR为例</span><br><span class="line"></span><br><span class="line">[DestinationDirs]</span><br><span class="line">CopyFilesSYS = 12     ; should it be 10 to take care of 98 stuff</span><br><span class="line">CopyFilesDLL = 11     ; %SystemRoot%\system or system32 - 98 or Win2000</span><br><span class="line">CopyFilesDLL64 = 10,SysWOW64</span><br><span class="line"></span><br><span class="line">[Manufacturer]</span><br><span class="line">%VENDOR%=Vendor, NTamd64</span><br><span class="line"></span><br><span class="line">[Vendor.NTamd64]</span><br><span class="line">%Rts5227CR%=RTS5264.Inst, PCI\VEN_10EC&amp;DEV_5264&amp;CC_FF00</span><br><span class="line"></span><br><span class="line">[RTS5264.Inst.ntamd64]</span><br><span class="line">CopyFiles = CopyFilesSYS, CopyFilesDLL64</span><br><span class="line"></span><br><span class="line">[RTS5264.Inst.NTamd64.HW]</span><br><span class="line">AddReg=MsiEnable_addreg</span><br><span class="line"></span><br><span class="line">[RTS5264.Inst.ntamd64.Services]</span><br><span class="line">AddService = RTSPER, 0x00000002, RTS5264_Service_Inst</span><br><span class="line"></span><br><span class="line">[RTS5264_Service_Inst]</span><br><span class="line">DisplayName    = %Rts5227PER%</span><br><span class="line">ServiceType    = %SERVICE_KERNEL_DRIVER%</span><br><span class="line">StartType      = %SERVICE_DEMAND_START%</span><br><span class="line">ErrorControl   = %SERVICE_ERROR_IGNORE%</span><br><span class="line">ServiceBinary  = %12%\RtsPer.sys</span><br><span class="line">AddReg         = RTS5264.AddReg</span><br><span class="line"></span><br><span class="line">[RTS5264.AddReg]</span><br><span class="line">HKR,&quot;RTS5264&quot;,&quot;MSIEnable&quot;,0x10001,1</span><br><span class="line">HKR,&quot;RTS5264&quot;,&quot;FirstLoad&quot;,0x10001,1</span><br><span class="line">HKR,&quot;RTS5264&quot;,&quot;NonRemovable&quot;,0x10001,1</span><br><span class="line">HKR,&quot;RTS5264&quot;,&quot;SupportPoFx&quot;,0x10001,1</span><br><span class="line">HKR,&quot;Parameters&quot;,&quot;DmaRemappingCompatible&quot;,0x10001,1</span><br><span class="line"></span><br><span class="line">[Strings]</span><br><span class="line">;Localizable Strings needed for HBA naming in Windows UI</span><br><span class="line">;*******************************************</span><br><span class="line">;Non-Localizable strings</span><br><span class="line">RTS = &quot;Realtek Semiconductor Corp.&quot;</span><br><span class="line">VENDOR         = &quot;Realtek Semiconductor Corp.&quot;</span><br><span class="line">Rts5227CR      = &quot;Realtek PCIE CardReader&quot;</span><br><span class="line">Rts5227PER      = &quot;Realtek PCIE Card Reader - PER&quot;</span><br><span class="line">DiskDesc = &quot;Realtek PCIE Card Reader Source Disk&quot;</span><br><span class="line">DriverVersion = &quot;10.0.22621.21361&quot;</span><br><span class="line">SERVICE_ASSOCSERVICE = 0x00000002</span><br><span class="line">SERVICE_BOOT_START     = 0x0</span><br><span class="line">SERVICE_SYSTEM_START   = 0x1</span><br><span class="line">SERVICE_AUTO_START     = 0x2</span><br><span class="line">SERVICE_DEMAND_START   = 0x3</span><br><span class="line">SERVICE_DISABLED       = 0x4</span><br><span class="line">SERVICE_KERNEL_DRIVER  = 0x1</span><br><span class="line">SERVICE_ERROR_IGNORE   = 0x0</span><br><span class="line">SERVICE_ERROR_NORMAL   = 0x1</span><br><span class="line">SERVICE_ERROR_SEVERE   = 0x2</span><br><span class="line">SERVICE_ERROR_CRITICAL = 0x3</span><br><span class="line">REG_EXPAND_SZ          = 0x00020000</span><br><span class="line">REG_DWORD              = 0x00010001</span><br><span class="line">REG_MULTI_SZ           = 0x00010000</span><br><span class="line">REG_BINARY             = 0x00000001</span><br><span class="line">REG_SZ                 = 0x00000000</span><br></pre></td></tr></table></figure>

<p>设备类型是MTD：<strong>Memory Technology Driver</strong></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/system-defined-device-setup-classes-available-to-vendors">https://learn.microsoft.com/en-us/windows-hardware/drivers/install/system-defined-device-setup-classes-available-to-vendors</a></p>
<p>从INF可以推测：</p>
<p>（1）这是SD host设备的驱动，直连PCIe接口（没通过USB），作用是SD card的控制器。</p>
<p>（2）没有用WDF(KMDF)框架，因为KMDF的INF一般定义KmdfService字段，以上INF没有定义。</p>
<p>（3）结合Windows Driver Sample，MTD类属于SD BUS&#x2F;Device的设备驱动，但微软的SD框架不支持SD BUS只支持SD Device，因此该驱动应该是用WDM写的SD BUS驱动，不是依赖于微软的SD BUS框架。</p>
<p>INF详细WDK 文档：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/looking-at-an-inf-file">https://learn.microsoft.com/en-us/windows-hardware/drivers/install/looking-at-an-inf-file</a></p>
<h4 id="sys分析"><a href="#sys分析" class="headerlink" title=".sys分析"></a>.sys分析</h4><ol>
<li><p>IDA打开.sys (有pdb文件更好)，找到DriverEntry入口</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408161541633.png" alt="image-20240816154137481"></p>
</li>
<li><p>F5显示成C伪代码，可以双击函数跳转</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202408161542515.png" alt="image-20240816154235494"></p>
</li>
<li><p>详细分析一下Driver Entry做了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sub_1400DEE88(_QWORD *a1) //DriverEntry主功能在这里实现，所有叫sub_xxx函数都是没有符号表解析不出名字的函数，看函数体即可.</span><br><span class="line">&#123;</span><br><span class="line">  __int64 CurrentThreadId; // rax</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  __int64 v4; // rcx</span><br><span class="line">  __int64 v5; // rax</span><br><span class="line">  __int64 v7; // [rsp+30h] [rbp-148h]</span><br><span class="line">  struct _OSVERSIONINFOW VersionInformation; // [rsp+40h] [rbp-138h] BYREF</span><br><span class="line"></span><br><span class="line">  CurrentThreadId = PsGetCurrentThreadId(); //获取当前线程ID</span><br><span class="line">  sub_1400DE608( //根据函数体，这里只是个打印函数，打印当前时间和线程ID.</span><br><span class="line">    2LL,</span><br><span class="line">    &quot;%I64d (%d) %s : -&gt; DriverEntry built on %s at %s \n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    CurrentThreadId,</span><br><span class="line">    &quot;DriverEntry&quot;,</span><br><span class="line">    &quot;Nov 14 2022&quot;,</span><br><span class="line">    &quot;15:12:36&quot;);</span><br><span class="line">  v3 = PsGetCurrentThreadId();</span><br><span class="line">  sub_1400DE608(</span><br><span class="line">    2LL,</span><br><span class="line">    &quot;%I64d (%d) %s : -&gt; DriverEntry Driver version : %s \n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    v3,</span><br><span class="line">    &quot;DriverEntry&quot;,</span><br><span class="line">    &quot;10.0.22621.21361&quot;);</span><br><span class="line">  VersionInformation.dwOSVersionInfoSize = 276;</span><br><span class="line">  if ( RtlGetVersion(&amp;VersionInformation) &gt;= 0 //获取操作系统版本</span><br><span class="line">    &amp;&amp; (VersionInformation.dwMajorVersion &gt; 6</span><br><span class="line">     || VersionInformation.dwMajorVersion == 6 &amp;&amp; VersionInformation.dwMinorVersion &gt;= 2) )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_140140110 = 512;</span><br><span class="line">    dword_140140114 = 0x40000000;</span><br><span class="line">  &#125;</span><br><span class="line">  qword_140140278 = MEMORY[0xFFFFF78000000008];</span><br><span class="line">  sub_1400DEC80();</span><br><span class="line">  sub_1400109EC();</span><br><span class="line">  a1[28] = sub_140003340; //sub_xxx都是函数，所以这里是注册很多回调，根据WDM开发一般是PNP回调</span><br><span class="line">  a1[29] = sub_1400057A0;</span><br><span class="line">  a1[36] = sub_1400EFA30;</span><br><span class="line">  a1[13] = sub_1400E0670;</span><br><span class="line">  v4 = a1[6];</span><br><span class="line">  a1[41] = sub_1400E5480;</span><br><span class="line">  a1[14] = sub_140003000;</span><br><span class="line">  a1[16] = sub_140002DC0;</span><br><span class="line">  a1[32] = sub_140002910;</span><br><span class="line">  a1[30] = sub_140008B40;</span><br><span class="line">  a1[37] = sub_1401071C0;</span><br><span class="line">  a1[18] = sub_140006EA0;</span><br><span class="line">  a1[17] = sub_140006EA0;</span><br><span class="line">  *(_QWORD *)(v4 + 8) = sub_1400DF0F0;</span><br><span class="line">  sub_1400011E4();</span><br><span class="line">  sub_1400E0188();</span><br><span class="line">  v5 = PsGetCurrentThreadId();</span><br><span class="line">  LODWORD(v7) = 0;</span><br><span class="line">  sub_1400DE608(</span><br><span class="line">    0x2000LL,</span><br><span class="line">    &quot;%I64d (%d) %s : &lt;- %s, ret = 0x%x\n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    v5,</span><br><span class="line">    &quot;DriverEntry&quot;,</span><br><span class="line">    &quot;DriverEntry&quot;,</span><br><span class="line">    v7);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体看一下注册的回调函数的内容：在函数上按x找到所有引用，再F5查看C伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sub_1400057A0(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; // rdi</span><br><span class="line">  __int64 CurrentThreadId; // rax</span><br><span class="line">  unsigned int v5; // ebx</span><br><span class="line">  __int64 v6; // rax</span><br><span class="line">  int v8; // [rsp+30h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v2 = *(_QWORD *)(a1 + 64);</span><br><span class="line">  if ( *(_BYTE *)v2 != 1 )</span><br><span class="line">    return sub_1400058A0();</span><br><span class="line">  CurrentThreadId = PsGetCurrentThreadId();</span><br><span class="line">  sub_1400DE608(</span><br><span class="line">    0x2000,</span><br><span class="line">    &quot;%I64d (%d) %s : -&gt; %s\n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    CurrentThreadId,</span><br><span class="line">    &quot;rts_internalctrl&quot;,</span><br><span class="line">    &quot;rts_internalctrl&quot;);</span><br><span class="line">  ++*(_BYTE *)(a2 + 67);</span><br><span class="line">  *(_QWORD *)(a2 + 184) += 72LL;</span><br><span class="line">  </span><br><span class="line">  //注意这个IofCallDriver，用于转发IRP给设备的driver function.</span><br><span class="line">  //可以推测DriverEntry注册的那些回调函数就是注册PNP请求列表对应的处理函数</span><br><span class="line">  //这里仅转发，真正的处理逻辑还在下层函数</span><br><span class="line">  v5 = IofCallDriver(*(_QWORD *)(v2 + 16), a2);</span><br><span class="line">  v6 = PsGetCurrentThreadId();</span><br><span class="line">  v8 = v5;</span><br><span class="line">  sub_1400DE608(</span><br><span class="line">    0x2000,</span><br><span class="line">    &quot;%I64d (%d) %s : &lt;- %s, ret = 0x%x\n&quot;,</span><br><span class="line">    (MEMORY[0xFFFFF78000000008] - qword_140140278) / 0x2710uLL,</span><br><span class="line">    v6,</span><br><span class="line">    &quot;rts_internalctrl&quot;,</span><br><span class="line">    &quot;rts_internalctrl&quot;,</span><br><span class="line">    v8);</span><br><span class="line">  return v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PNP的回调函数参考：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/dispatchpnp-routines">https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/dispatchpnp-routines</a></p>
</li>
<li><p>全览.sys有哪些函数符号</p>
<p>用shift + F12打开strings页面，ctrl+F 搜索关键词，选中结果后删除搜索框去浏览上下文。</p>
<p>   以DriverEntry为例，符号字符上下文如下，符号的地址分布是连续的，不考虑跳转可视为调用顺序。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">.text:000000014012A550	0000000C	C	DriverEntry //入口</span><br><span class="line">.text:000000014012A560	00000033	C	%I64d (%d) %s : -&gt; DriverEntry built on %s at %s \n</span><br><span class="line">.text:000000014012A5A0	00000035	C	%I64d (%d) %s : -&gt; DriverEntry Driver version : %s \n</span><br><span class="line">.text:000000014012A5E0	0000000B	C	rts_unload</span><br><span class="line">.text:000000014012A5F0	00000031	C	%I64d (%d) %s : -&gt; Driver Unload, version : %s \n</span><br><span class="line">.text:000000014012A630	00000031	C	%I64d (%d) %s : &lt;- Driver Unload, version : %s \n</span><br><span class="line">.text:000000014012A670	0000000E	C	rts_adddevice</span><br><span class="line">.text:000000014012A6C0	00000031	C	%I64d (%d) %s : Failed to create device object \n</span><br><span class="line">.text:000000014012A700	00000031	C	%I64d (%d) %s : fdx is 0x%p, PAGE_SIZE is 0x%x \n</span><br><span class="line">.text:000000014012A740	00000035	C	%I64d (%d) %s : IoAttachDeviceToDeviceStack failed \n</span><br><span class="line"></span><br><span class="line">//操作系统判断，为了后面差异化配置</span><br><span class="line"></span><br><span class="line">.text:000000014012A780	0000001E	C	%I64d (%d) %s : OS is Win10 \n</span><br><span class="line">.text:000000014012A7A0	00000020	C	%I64d (%d) %s : OS is WinBlue \n</span><br><span class="line">.text:000000014012A7C0	0000001D	C	%I64d (%d) %s : OS is Win8 \n</span><br><span class="line">.text:000000014012A7E0	0000001D	C	%I64d (%d) %s : OS is Win7 \n</span><br><span class="line">.text:000000014012A800	00000024	C	%I64d (%d) %s : OS is Server 2008 \n</span><br><span class="line">.text:000000014012A830	0000001E	C	%I64d (%d) %s : OS is VISTA \n</span><br><span class="line">.text:000000014012A850	00000024	C	%I64d (%d) %s : OS is Server 2003 \n</span><br><span class="line">.text:000000014012A880	0000001E	C	%I64d (%d) %s : OS is WinXp \n</span><br><span class="line">.text:000000014012A8A0	0000001E	C	%I64d (%d) %s : OS is Win2k \n</span><br><span class="line">.text:000000014012A8C0	00000023	C	%I64d (%d) %s : OS is NotDefined \n</span><br><span class="line">.text:000000014012A8F0	0000001E	C	%I64d (%d) %s : OS is 64bit \n</span><br><span class="line">.text:000000014012A910	0000003A	C	%I64d (%d) %s : rts_pcie_init_bus_interface failed (%x) \n</span><br><span class="line">.text:000000014012A950	00000035	C	%I64d (%d) %s : rts_pcie_get_dev_info failed: 0x%x \n</span><br><span class="line">.text:000000014012A990	0000003B	C	%I64d (%d) %s : IoRegisterDeviceInterface failed with %x \n</span><br><span class="line">.text:000000014012A9D0	00000032	C	%I64d (%d) %s : GetMcfgEntryFromAuxKlib success \n</span><br><span class="line">.text:000000014012AA10	00000031	C	%I64d (%d) %s : GetMcfgEntryFromAuxKlib failed \n</span><br><span class="line">.text:000000014012AA50	0000002E	C	%I64d (%d) %s : GetMcfgEntryFromReg success \n</span><br><span class="line">.text:000000014012AA80	0000002D	C	%I64d (%d) %s : GetMcfgEntryFromReg failed \n</span><br><span class="line">.text:000000014012AAB0	00000027	C	%I64d (%d) %s : host_cfg_disable: %d \n</span><br><span class="line">.text:000000014012AAE0	00000034	C	%I64d (%d) %s : bMcfgEntry %d, BaseAddr is 0x%llx \n</span><br><span class="line"></span><br><span class="line">//初始化DPC，PDO; Rts自定义的PNP/POFX回调函数也初始化（估计是绑定到函数指针数组）</span><br><span class="line"></span><br><span class="line">.text:000000014012AB20	00000041	C	%I64d (%d) %s : initialize the DPC NoSSDpcWorkItemPendingEvent \n</span><br><span class="line">.text:000000014012AB70	00000039	C	%I64d (%d) %s : IoRegisterShutdownNotification success \n</span><br><span class="line">.text:000000014012ABB0	0000003B	C	%I64d (%d) %s : IoRegisterShutdownNotification fail 0x%x \n</span><br><span class="line">.text:000000014012ABF0	00000015	C	rts_create_child_pdo</span><br><span class="line">.text:000000014012AC10	0000005A	C	%I64d (%d) %s : Create Pdo %i successfully, status is 0x%x, Child-&gt;ReferenceCount is %i \n</span><br><span class="line">.text:000000014012AC70	00000035	C	%I64d (%d) %s : Create Pdo %i fail with status 0x%x\n</span><br><span class="line">.text:000000014012ACE0	00000017	C	rts_init_pofx_routines</span><br><span class="line">.text:000000014012AD00	0000002D	C	%I64d (%d) %s : pPoFxActivateComponent=0x%p\n</span><br><span class="line">.text:000000014012AD60	00000029	C	%I64d (%d) %s : pPoFxIdleComponent=0x%p\n</span><br><span class="line">.text:000000014012ADC0	0000002C	C	%I64d (%d) %s : pPoFxSetComponentWake=0x%p\n</span><br><span class="line">.text:000000014012AE20	0000002D	C	%I64d (%d) %s : pPoFxCompleteIdleState=0x%p\n</span><br><span class="line">.text:000000014012AE90	00000031	C	%I64d (%d) %s : pPoFxCompleteIdleCondition=0x%p\n</span><br><span class="line">.text:000000014012AF10	00000031	C	%I64d (%d) %s : pPoFxReportDevicePoweredOn=0x%p\n</span><br><span class="line">.text:000000014012AFA0	0000003A	C	%I64d (%d) %s : pPoFxCompleteDevicePowerNotRequired=0x%p\n</span><br><span class="line">.text:000000014012B010	0000002A	C	%I64d (%d) %s : pPoFxRegisterDevice=0x%p\n</span><br><span class="line">.text:000000014012B070	0000002C	C	%I64d (%d) %s : pPoFxUnregisterDevice=0x%p\n</span><br><span class="line">.text:000000014012B0E0	00000036	C	%I64d (%d) %s : pPoFxStartDevicePowerManagement=0x%p\n</span><br><span class="line">.text:000000014012B160	00000035	C	%I64d (%d) %s : pPoFxCompleteDirectedPowerDown=0x%p\n</span><br><span class="line"></span><br><span class="line">//从注册表拿到用户自定义的功能配置信息</span><br><span class="line"></span><br><span class="line">.text:000000014012B1B0	00000014	C	GetMcfgEntryFromReg</span><br><span class="line">.text:000000014012B220	00000028	C	%s : Get SubKey %ws, Update Key to %ws\n</span><br><span class="line">.text:000000014012B250	0000003F	C	%I64d (%d) %s : EnumOneSubValue return %d, pMcfgSdtTabke 0x%x\n</span><br><span class="line">.text:000000014012B290	00000023	C	%I64d (%d) %s : NULL == pMcfgAddr\n</span><br><span class="line">.text:000000014012B2C0	00000018	C	GetMcfgEntryFromAuxKlib</span><br><span class="line">.text:000000014012B2E0	00000030	C	%I64d (%d) %s : Enum firmware table return %#x\n</span><br><span class="line">.text:000000014012B310	00000041	C	%I64d (%d) %s : AuxKlibEnumerateSystemFirmwareTables return %#x\n</span><br><span class="line">.text:000000014012B360	00000023	C	%I64d (%d) %s : cannot find MCFG \n</span><br><span class="line">.text:000000014012B390	0000002C	C	%I64d (%d) %s : Get MCFG Table as follow: \n</span><br><span class="line">.text:000000014012B3C0	00000031	C	%I64d (%d) %s : Allocate for MCFG table failed \n</span><br><span class="line">.text:000000014012B400	0000000E	C	EnumOneSubKey</span><br><span class="line">.text:000000014012B410	00000029	C	%s : Open register key %ws failed, 0x%x\n</span><br><span class="line">.text:000000014012B440	00000010	C	EnumOneSubValue</span><br><span class="line">.text:000000014012B450	00000026	C	%I64d (%d) %s : Allocate pfi failed \n</span><br><span class="line">.text:000000014012B480	00000027	C	%I64d (%d) %s : Allocate pvfi failed \n</span><br><span class="line">.text:000000014012B4B0	00000024	C	%I64d (%d) %s : DataLength is 0x%x\n</span><br><span class="line">.text:000000014012B4E0	0000000E	C	ParseSdtTable</span><br><span class="line">.text:000000014012B4F0	0000002F	C	%I64d (%d) %s : Check physical address %#llx \n</span><br><span class="line">.text:000000014012B520	0000002D	C	%I64d (%d) %s : Check physical address %#x \n</span><br><span class="line"></span><br><span class="line">//从PCIe bridge拿到SD host设备信息，包括能力寄存器，电源ASPM等</span><br><span class="line"></span><br><span class="line">.text:000000014012B550	00000018	C	rts_get_pci_bridge_info</span><br><span class="line">.text:000000014012B570	00000048	C	%I64d (%d) %s : Single Function Device: bus = %#x, dev = %#x, func=%#x\n</span><br><span class="line">.text:000000014012B5C0	0000003C	C	%I64d (%d) %s : Find Device(%X:%X)  bus=%d dev=%d, func=%d\n</span><br><span class="line">.text:000000014012B600	00000031	C	%I64d (%d) %s : Save host configure space 0x%p \n</span><br><span class="line">.text:000000014012B640	00000033	C	%I64d (%d) %s : Cannot Find PciBridge for Device \n</span><br><span class="line">.text:000000014012B680	0000001B	C	rts_get_dev_link_ctl_field</span><br><span class="line">.text:000000014012B6A0	00000039	C	%I64d (%d) %s : Get PCI_COMMON_CONFIG fail, ulResult=%d\n</span><br><span class="line">.text:000000014012B6E0	00000033	C	%I64d (%d) %s : Get linkCtrlReg fail, ulResult=%d\n</span><br><span class="line">.text:000000014012B720	00000022	C	%I64d (%d) %s : linkCtrlReg 0x%x\n</span><br><span class="line">.text:000000014012B750	00000022	C	rts_get_bridge_link_control_field</span><br><span class="line">.text:000000014012B780	0000002E	C	%I64d (%d) %s : fail to find PCIe Capability\n</span><br><span class="line">.text:000000014012B7B0	0000003B	C	%I64d (%d) %s : CapabilityOffset - Config from MMCFG 0x%x\n</span><br><span class="line">.text:000000014012B7F0	00000038	C	%I64d (%d) %s : CapabilityOffset - Config from IO 0x%x\n</span><br><span class="line">.text:000000014012B830	00000038	C	%I64d (%d) %s : CapabilityHdr - Config from MMCFG 0x%x\n</span><br><span class="line">.text:000000014012B870	00000035	C	%I64d (%d) %s : CapabilityHdr - Config from IO 0x%x\n</span><br><span class="line">.text:000000014012B8B0	00000036	C	%I64d (%d) %s : LinkCtrlReg - Config from MMCFG 0x%x\n</span><br><span class="line">.text:000000014012B8F0	00000033	C	%I64d (%d) %s : LinkCtrlReg - Config from IO 0x%x\n</span><br><span class="line">.text:000000014012B930	00000048	C	%I64d (%d) %s : pciBridgePCIeHdrOffset 0x%x, pciBridgeLinkCtrlReg 0x%x\n</span><br><span class="line">.text:000000014012B980	0000002D	C	%I64d (%d) %s : Cannot Find PCIe Capability\n</span><br><span class="line">.text:000000014012B9B0	00000038	C	%I64d (%d) %s : cannot find the Bus of PCI,do nothing \n</span><br><span class="line">.text:000000014012B9F0	00000023	C	%I64d (%d) %s : MapPhyMem failed \n</span><br><span class="line">.text:000000014012BA20	0000005F	C	%I64d (%d) %s : PciBridge BusNumber[%x], DevNumbe[%x], FuncNumber[%x], Write reg[0x%x] = 0x%x\n</span><br><span class="line">.text:000000014012BA80	00000016	C	rts_disable_host_aspm</span><br><span class="line">.text:000000014012BAA0	0000004A	C	%I64d (%d) %s : recognize the Bus of PCI(Bridge) as UNKNOWN, do nothing \n</span><br><span class="line">.text:000000014012BAF0	0000001F	C	%I64d (%d) %s : PhyAddr 0x%x \n</span><br><span class="line">.text:000000014012BB10	0000002A	C	%I64d (%d) %s : Offset 0x%x, Value 0x%x \n</span><br><span class="line">.text:000000014012BB40	00000012	C	rts_set_host_aspm</span><br><span class="line">.text:000000014012BB60	0000002A	C	%I64d (%d) %s : Offset 0x%x, value 0x%x \n</span><br><span class="line">.text:000000014012BB90	00000012	C	rts_get_host_aspm</span><br><span class="line">.text:000000014012BBB0	0000001D	C	rts_pci_find_host_capability</span><br><span class="line">.text:000000014012BBD0	00000019	C	cr_read_host_config_byte</span><br><span class="line">.text:000000014012BBF0	0000001A	C	cr_write_host_config_byte</span><br><span class="line">.text:000000014012BC10	0000002F	C	%I64d (%d) %s : Write configure through MMIO \n</span><br><span class="line">.text:000000014012BC40	00000007	C	UNKNOW</span><br><span class="line"></span><br><span class="line">//以下是PNP的回调函数的注册（函数指针绑定），具体函数体实现在rts_pnp_fdo</span><br><span class="line"></span><br><span class="line">.text:000000014012BC70	00000011	C	DispatchPnP_Fdo </span><br><span class="line">.text:000000014012BC90	0000000C	C	rts_pnp_fdo</span><br><span class="line">.text:000000014012BCA0	0000001E	C	%I64d (%d) %s : -&gt; %s %s %s \n</span><br><span class="line">.text:000000014012BCC0	00000032	C	%I64d (%d) %s : rts_pnp_fdo: fdx DeviceState %i \n</span><br><span class="line">.text:000000014012BD00	00000052	C	%I64d (%d) %s : IRP_MN_REMOVE_DEVICE, NotStarted == fdx-&gt;DeviceState, do nothing\n</span><br><span class="line">.text:000000014012BD60	0000002D	C	%I64d (%d) %s : Removed == fdx-&gt;DeviceState\n</span><br><span class="line">.text:000000014012BD90	00000028	C	%I64d (%d) %s : call rts_ss_cancel_ss \n</span><br><span class="line">.text:000000014012BDD0	0000004F	C	%I64d (%d) %s : MSI not enable,IRP_MN_FILTER_RESOURCE_REQUIREMENTS to default\n</span><br><span class="line">.text:000000014012BE20	00000035	C	%I64d (%d) %s : Unprocessed pnp,to default process \n</span><br><span class="line">.text:000000014012BE60	00000011	C	DispatchPnP_Pdo </span><br><span class="line">.text:000000014012BE80	0000000C	C	rts_pnp_pdo</span><br><span class="line">.text:000000014012BE90	00000061	C	%I64d (%d) %s : NULL == Fdo, not IRP_MN_REMOVE_DEVICE,so return fail with STATUS_DELETE_PENDING\n</span><br><span class="line">.text:000000014012BF00	00000037	C	%I64d (%d) %s : Removed == fdx-&gt;DeviceState, so quit \n</span><br><span class="line">.text:000000014012BF40	00000027	C	%I64d (%d) %s : NULL == fdx, so quit \n</span><br><span class="line">.text:000000014012BF70	0000001F	C	%I64d (%d) %s : BusRelations \n</span><br><span class="line">.text:000000014012BF90	00000024	C	%I64d (%d) %s : EjectionRelations \n</span><br><span class="line">.text:000000014012BFC0	00000021	C	%I64d (%d) %s : PowerRelations \n</span><br><span class="line">.text:000000014012BFF0	00000023	C	%I64d (%d) %s : RemovalRelations \n</span><br><span class="line">.text:000000014012C020	00000027	C	%I64d (%d) %s : TargetDeviceRelation \n</span><br><span class="line">.text:000000014012C050	00000097	C	%I64d (%d) %s : deviceCapabilities-&gt;Removable is %i,deviceCapabilities-&gt;SurpriseRemovalOK is %i,deviceCapabilities-&gt;UniqueID is %i, ntStatus is 0x%x \n</span><br><span class="line">.text:000000014012C0F0	00000017	C	rts_tr_pcie_option_set</span><br><span class="line">.text:000000014012C110	00000024	C	%I64d (%d) %s : sd_capability=%#x \n</span><br><span class="line">.text:000000014012C140	00000023	C	%I64d (%d) %s : card_spt_map=%#x \n</span><br><span class="line">.text:000000014012C170	0000002D	C	%I64d (%d) %s : cr-&gt;option.dev_flags = %#x \n</span><br><span class="line">.text:000000014012C1A0	0000002F	C	%I64d (%d) %s : cr-&gt;option.patch_flags = %#x \n</span><br><span class="line"></span><br><span class="line">//以下是设备资源分配（xxx_alloc）和硬件寄存器值初始化（bios_setting/init_hw），由于是PCIe的SD host设备，主要分配SD host设备空间到PCIe bar地址</span><br><span class="line"></span><br><span class="line">.text:000000014012C1D0	00000045	C	%I64d (%d) %s : DriverFirstLoad, set delink_delay_max_cnt to %d ms \n</span><br><span class="line">.text:000000014012C220	00000026	C	%I64d (%d) %s : Clar firstload flag \n</span><br><span class="line">.text:000000014012C250	00000036	C	%I64d (%d) %s : fdx-&gt;cr-&gt;option.remote_wakeup_en=%#x\n</span><br><span class="line">.text:000000014012C290	00000038	C	%I64d (%d) %s : fdx-&gt;CurrentPara-&gt;remote_wakeup_en=%#x\n</span><br><span class="line">.text:000000014012C2D0	00000036	C	%I64d (%d) %s : fdx-&gt;cr-&gt;option.host_cfg_disable=%#x\n</span><br><span class="line">.text:000000014012C310	00000020	C	rts_tr_pcie_backup_bios_setting</span><br><span class="line">.text:000000014012C330	00000015	C	rts_cr_bind_together</span><br><span class="line">.text:000000014012C350	0000002F	C	%I64d (%d) %s : cr=%p, cm =%p, tr=%p, scsi=%p\n</span><br><span class="line">.text:000000014012C380	00000033	C	%I64d (%d) %s : cr-&gt;cm=%p, cr-&gt;tr=%p, cr-&gt;scsi=%p\n</span><br><span class="line">.text:000000014012C3C0	00000033	C	%I64d (%d) %s : cm-&gt;cr=%p, cm-&gt;tr=%p, scsi-&gt;cr=%p\n</span><br><span class="line">.text:000000014012C400	0000000B	C	scsi_alloc</span><br><span class="line">.text:000000014012C410	0000002E	C	%I64d (%d) %s : Unable to allocate the scsi \n</span><br><span class="line">.text:000000014012C440	0000000D	C	scsi_release</span><br><span class="line">.text:000000014012C450	0000001B	C	rts_option_set_bef_init_hw</span><br><span class="line">.text:000000014012C470	00000059	C	%I64d (%d) %s : read config addr 0x0E to judge multi function fail, bytesread(%i) != 1 \n</span><br><span class="line">.text:000000014012C4D0	00000036	C	%I64d (%d) %s : read config addr 0x0E success(0x%x) \n</span><br><span class="line">.text:000000014012C510	00000006	C	multi</span><br><span class="line">.text:000000014012C520	00000007	C	single</span><br><span class="line">.text:000000014012C530	00000029	C	%I64d (%d) %s : Device is %s-functioned\n</span><br><span class="line">.text:000000014012C560	0000002F	C	%I64d (%d) %s : fdx-&gt;cr-&gt;option.adma_mode %d \n</span><br><span class="line">.text:000000014012C590	0000001D	C	rts_option_set_after_init_hw</span><br><span class="line">.text:000000014012C5B0	0000002C	C	%I64d (%d) %s : option.cq_rand_enable = %d\n</span><br><span class="line">.text:000000014012C5E0	0000002B	C	%I64d (%d) %s : option.cq_seq_enable = %d\n</span><br><span class="line">.text:000000014012C610	00000030	C	%I64d (%d) %s : option.cq_ban_card_enable = %d\n</span><br><span class="line">.text:000000014012C640	00000020	C	Realtek PCIE Card Reader Driver</span><br><span class="line">.text:000000014012C660	00000011	C	rts_cr_init_comm</span><br><span class="line">.text:000000014012C680	0000001E	C	%I64d (%d) %s : %s detected \n</span><br><span class="line">.text:000000014012C6A0	00000023	C	%I64d (%d) %s : option-&gt;ss_en %d \n</span><br><span class="line">.text:000000014012C6D0	00000013	C	rts_cr_uninit_comm</span><br><span class="line"></span><br><span class="line">//以下是电源管理POFX的回调函数的注册（函数指针绑定），具体实现在rts_pofx/dfx</span><br><span class="line"></span><br><span class="line">.text:000000014012C6F0	00000018	C	ActiveConditionCallback</span><br><span class="line">.text:000000014012C710	0000003A	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx ActiveConditionCallback\n</span><br><span class="line">.text:000000014012C750	0000003A	C	%I64d (%d) %s : ===&gt;&lt;=== &lt;- PoFx ActiveConditionCallback\n</span><br><span class="line"></span><br><span class="line">.text:000000014012C790	00000016	C	IdleConditionCallback</span><br><span class="line">.text:000000014012C7B0	00000038	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx IdleConditionCallback\n</span><br><span class="line">.text:000000014012C7F0	00000038	C	%I64d (%d) %s : ===&gt;&lt;=== &lt;- PoFx IdleConditionCallback\n</span><br><span class="line">.text:000000014012C830	00000012	C	IdleStateCallback</span><br><span class="line">.text:000000014012C850	0000003E	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx IdleStateCallback, State=%d\n</span><br><span class="line">.text:000000014012C890	00000034	C	%I64d (%d) %s : ===&gt;&lt;=== &lt;- PoFx IdleStateCallback\n</span><br><span class="line"></span><br><span class="line">.text:000000014012C8D0	0000001C	C	DevicePowerRequiredCallback</span><br><span class="line">.text:000000014012C8F0	00000037	C	%I64d (%d) %s : ===&gt; PoFx DevicePowerRequiredCallback\n</span><br><span class="line">.text:000000014012C930	00000041	C	%I64d (%d) %s : PoFx DeviePowerRequiredCallback:queue work item\n</span><br><span class="line">.text:000000014012C980	00000053	C	%I64d (%d) %s : PoFx DeviePowerRequiredCallback:Cannot alloc memory for work item\n</span><br><span class="line">.text:000000014012C9E0	0000002A	C	%I64d (%d) %s :  fdx-&gt;PoFxActive = TRUE \n</span><br><span class="line">.text:000000014012CA10	0000003E	C	%I64d (%d) %s : ===&gt;&lt;=== &lt;- PoFx DevicePowerRequiredCallback\n</span><br><span class="line"></span><br><span class="line">.text:000000014012CA50	0000001F	C	DevicePowerNotRequiredCallback</span><br><span class="line">.text:000000014012CA70	0000003A	C	%I64d (%d) %s : ===&gt; PoFx DevicePowerNotRequiredCallback\n</span><br><span class="line">.text:000000014012CAB0	00000043	C	%I64d (%d) %s : ===&gt;&lt;=== PoFx pPoFxCompleteDevicePowerNotRequired\n</span><br><span class="line">.text:000000014012CB00	0000002B	C	%I64d (%d) %s :  fdx-&gt;PoFxActive = FALSE \n</span><br><span class="line">.text:000000014012CB30	0000003A	C	%I64d (%d) %s : &lt;=== PoFx DevicePowerNotRequiredCallback\n</span><br><span class="line"></span><br><span class="line">//以下是电源管理POFX的回调函数体实现，rts_xxx_pofx</span><br><span class="line"></span><br><span class="line">.text:000000014012CB70	00000025	C	rts_dev_pwr_completion_for_DFx_child</span><br><span class="line">.text:000000014012CBA0	0000004A	C	%I64d (%d) %s : powerContext-&gt;DeviceObject is 0x%p, DeviceObject is 0x%p\n</span><br><span class="line">.text:000000014012CBF0	00000027	C	%I64d (%d) %s : IoStatus-&gt;Status=%#x \n</span><br><span class="line"></span><br><span class="line">.text:000000014012CC20	0000001F	C	rts_dev_pwr_completion_for_DFx</span><br><span class="line">.text:000000014012CC40	00000079	C	%I64d (%d) %s : powerContext-&gt;DeviceObject is 0x%p, DeviceObject is 0x%p,deviceExtension-&gt;PhysicalDeviceObject is 0x%p \n</span><br><span class="line">.text:000000014012CCC0	00000030	C	%I64d (%d) %s : For power up, queue work item \n</span><br><span class="line">.text:000000014012CCF0	00000041	C	%I64d (%d) %s : For power up, cannot alloc memory for work item\n</span><br><span class="line">.text:000000014012CD40	00000038	C	%I64d (%d) %s : ===&gt;&lt;=== PoFxCompleteDirectedPowerDown\n</span><br><span class="line">.text:000000014012CD80	0000002D	C	%I64d (%d) %s : Set Power Failed, resume IO\n</span><br><span class="line"></span><br><span class="line">.text:000000014012CDB0	00000018	C	DirectedPowerUpCallback</span><br><span class="line">.text:000000014012CDD0	0000003A	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx DirectedPowerUpCallback\n</span><br><span class="line">.text:000000014012CE10	0000003A	C	%I64d (%d) %s : Failed to alloc memory for powerContext \n</span><br><span class="line">.text:000000014012CE50	0000003E	C	%I64d (%d) %s : DirectedPowerUpCallback SetPower to D0 fail \n</span><br><span class="line"></span><br><span class="line">.text:000000014012CE90	0000001A	C	DirectedPowerDownCallback</span><br><span class="line">.text:000000014012CEB0	0000003C	C	%I64d (%d) %s : ===&gt;&lt;=== -&gt; PoFx DirectedPowerDownCallback\n</span><br><span class="line">.text:000000014012CEF0	0000002E	C	%I64d (%d) %s : Set enter_rtd3 to 1 for DFx \n</span><br><span class="line">.text:000000014012CF20	00000040	C	%I64d (%d) %s : DirectedPowerDownCallback SetPower to D3 fail \n</span><br><span class="line"></span><br><span class="line">.text:000000014012CF60	00000012	C	rts_register_pofx</span><br><span class="line">.text:000000014012CF80	00000035	C	%I64d (%d) %s : supportPoFx=0, do not register PoFx\n</span><br><span class="line">.text:000000014012CFC0	00000033	C	%I64d (%d) %s : ===&gt;&lt;=== PoFx already registered!\n</span><br><span class="line">.text:000000014012D000	00000042	C	%I64d (%d) %s : ===&gt;&lt;=== Invalid PoFx routines, pls check again!\n</span><br><span class="line">.text:000000014012D050	00000037	C	%I64d (%d) %s : ===&gt;&lt;=== OS Ver: size %d, %d.%d.%d.%d\n</span><br><span class="line">.text:000000014012D090	00000033	C	%I64d (%d) %s : ===&gt;&lt;=== Register PO_FX_DEVICE_V3\n</span><br><span class="line">.text:000000014012D0D0	00000033	C	%I64d (%d) %s : ===&gt;&lt;=== Register PO_FX_DEVICE_V2\n</span><br><span class="line">.text:000000014012D110	00000038	C	%I64d (%d) %s : ===&gt;&lt;=== PoFxRegisterDevice return %#x\n</span><br><span class="line"></span><br><span class="line">.text:000000014012D150	00000014	C	rts_unregister_pofx</span><br><span class="line">.text:000000014012D170	0000002F	C	%I64d (%d) %s : ===&gt;&lt;=== PoFxUnregisterDevice\n</span><br><span class="line">.text:000000014012D1A0	00000020	C	rts_pnp_fdo_start_dev_delaywork</span><br><span class="line">.text:000000014012D1C0	0000002E	C	%I64d (%d) %s : rts_create_childen_pdos fail\n</span><br><span class="line">.text:000000014012D1F0	00000039	C	%I64d (%d) %s : Start after stop,so no need create pdos\n</span><br><span class="line">.text:000000014012D230	00000039	C	%I64d (%d) %s : IoSetDeviceInterfaceState:enable:failed\n</span><br><span class="line">.text:000000014012D270	00000039	C	%I64d (%d) %s : ===&gt;&lt;=== PoFxStartDevicePowerManagement\n</span><br><span class="line"></span><br><span class="line">//以下是PNP回调的函数体实现，rts_pnp_fdo_xxx</span><br><span class="line"></span><br><span class="line">//对应PNP: IRP_MN_START_DEVICE</span><br><span class="line">.text:000000014012D3E0	00000016	C	rts_pnp_fdo_start_dev</span><br><span class="line">.text:000000014012D400	0000001C	C	rts_pnp_fdo_cancel_stop_dev</span><br><span class="line">.text:000000014012D420	0000002F	C	%I64d (%d) %s : Cancel stop after query stop \n</span><br><span class="line">.text:000000014012D450	00000073	C	%I64d (%d) %s : spurious cancel-stop without query stop first,we still pass it down,Irp-&gt;IoStatus.Status is 0x%x \n</span><br><span class="line"></span><br><span class="line">//对应PNP: IRP_MN_WAIT_WAKE?</span><br><span class="line">.text:000000014012D4D0	00000019	C	rts_pnp_wait_d0_complete</span><br><span class="line">.text:000000014012D4F0	0000003F	C	%I64d (%d) %s : 0 == fdx-&gt;CancelSSIsCalling, return directly \n</span><br><span class="line">.text:000000014012D530	00000037	C	%I64d (%d) %s : Wait cancel ss finished for the %ith \n</span><br><span class="line"></span><br><span class="line">//对应PNP: IRP_MN_STOP_DEVICE</span><br><span class="line">.text:000000014012D570	00000015	C	rts_pnp_fdo_stop_dev</span><br><span class="line">.text:000000014012D590	00000044	C	%I64d (%d) %s : KeWaitForSingleObject NoSSDpcWorkItemPendingEvent \n</span><br><span class="line">.text:000000014012D5E0	0000003B	C	%I64d (%d) %s : IoSetDeviceInterfaceState::disable:failed\n</span><br><span class="line"></span><br><span class="line">.... //略</span><br></pre></td></tr></table></figure>

<p>Import页面查看导入的符号，都是WDM （NTOS kernel）的符号链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">Address	Ordinal	Name	Library</span><br><span class="line">			</span><br><span class="line">cng			</span><br><span class="line">0000000140138010		BCryptSetProperty	cng</span><br><span class="line">0000000140138018		BCryptCloseAlgorithmProvider	cng</span><br><span class="line">0000000140138020		BCryptGenerateSymmetricKey	cng</span><br><span class="line">0000000140138028		BCryptGenerateKeyPair	cng</span><br><span class="line">0000000140138030		BCryptEncrypt	cng</span><br><span class="line">0000000140138038		BCryptExportKey	cng</span><br><span class="line">0000000140138040		BCryptGetProperty	cng</span><br><span class="line">0000000140138048		BCryptFinalizeKeyPair	cng</span><br><span class="line">0000000140138050		BCryptDestroyKey	cng</span><br><span class="line">0000000140138058		BCryptDestroySecret	cng</span><br><span class="line">0000000140138060		BCryptSecretAgreement	cng</span><br><span class="line">0000000140138068		BCryptDeriveKey	cng</span><br><span class="line">0000000140138070		BCryptGenRandom	cng</span><br><span class="line">0000000140138078		BCryptImportKeyPair	cng</span><br><span class="line">0000000140138080		BCryptOpenAlgorithmProvider	cng</span><br><span class="line"></span><br><span class="line">ntoskrnl			</span><br><span class="line">0000000140138090		KeReadStateEvent	ntoskrnl</span><br><span class="line">0000000140138098		KeReleaseSemaphore	ntoskrnl</span><br><span class="line">00000001401380A0		KeWaitForMultipleObjects	ntoskrnl</span><br><span class="line">00000001401380A8		KeWaitForSingleObject	ntoskrnl</span><br><span class="line">00000001401380B0		ExAllocatePoolWithTag	ntoskrnl</span><br><span class="line">00000001401380B8		ExRaiseStatus	ntoskrnl</span><br><span class="line">00000001401380C0		ProbeForWrite	ntoskrnl</span><br><span class="line">00000001401380C8		MmProbeAndLockPages	ntoskrnl</span><br><span class="line">00000001401380D0		MmMapLockedPagesSpecifyCache	ntoskrnl</span><br><span class="line">00000001401380D8		IoAllocateMdl	ntoskrnl</span><br><span class="line">00000001401380E0		IofCallDriver	ntoskrnl</span><br><span class="line">00000001401380E8		IofCompleteRequest	ntoskrnl</span><br><span class="line">00000001401380F0		IoFreeMdl	ntoskrnl</span><br><span class="line">00000001401380F8		IoIs32bitProcess	ntoskrnl</span><br><span class="line">0000000140138100		IoCsqInsertIrp	ntoskrnl</span><br><span class="line">0000000140138108		IoCsqRemoveNextIrp	ntoskrnl</span><br><span class="line">0000000140138110		__C_specific_handler	ntoskrnl</span><br><span class="line">0000000140138118		wcscat_s	ntoskrnl</span><br><span class="line">0000000140138120		wcscpy_s	ntoskrnl</span><br><span class="line">0000000140138128		wcsncpy_s	ntoskrnl</span><br><span class="line">0000000140138130		RtlInitAnsiString	ntoskrnl</span><br><span class="line">0000000140138138		RtlInitUnicodeString	ntoskrnl</span><br><span class="line">0000000140138140		RtlQueryRegistryValues	ntoskrnl</span><br><span class="line">0000000140138148		MmGetSystemRoutineAddress	ntoskrnl</span><br><span class="line">0000000140138150		RtlAnsiStringToUnicodeString	ntoskrnl</span><br><span class="line">0000000140138158		RtlFreeUnicodeString	ntoskrnl</span><br><span class="line">0000000140138160		RtlCompareMemory	ntoskrnl</span><br><span class="line">0000000140138168		KeInsertQueueDpc	ntoskrnl</span><br><span class="line">0000000140138170		KeSetEvent	ntoskrnl</span><br><span class="line">0000000140138178		KeDelayExecutionThread	ntoskrnl</span><br><span class="line">0000000140138180		KeAcquireSpinLockRaiseToDpc	ntoskrnl</span><br><span class="line">0000000140138188		KeReleaseSpinLock	ntoskrnl</span><br><span class="line">0000000140138190		ExFreePoolWithTag	ntoskrnl</span><br><span class="line">0000000140138198		MmBuildMdlForNonPagedPool	ntoskrnl</span><br><span class="line">00000001401381A0		IoDeleteDevice	ntoskrnl</span><br><span class="line">00000001401381A8		IoAllocateWorkItem	ntoskrnl</span><br><span class="line">00000001401381B0		IoFreeWorkItem	ntoskrnl</span><br><span class="line">00000001401381B8		IoQueueWorkItem	ntoskrnl</span><br><span class="line">00000001401381C0		IoInvalidateDeviceRelations	ntoskrnl</span><br><span class="line">00000001401381C8		IoOpenDeviceRegistryKey	ntoskrnl</span><br><span class="line">00000001401381D0		ObReferenceObjectByHandle	ntoskrnl</span><br><span class="line">00000001401381D8		ObfDereferenceObject	ntoskrnl</span><br><span class="line">00000001401381E0		ZwCreateFile	ntoskrnl</span><br><span class="line">00000001401381E8		ZwClose	ntoskrnl</span><br><span class="line">00000001401381F0		ZwCreateKey	ntoskrnl</span><br><span class="line">00000001401381F8		ZwOpenKey	ntoskrnl</span><br><span class="line">0000000140138200		ZwDeleteKey	ntoskrnl</span><br><span class="line">0000000140138208		ZwEnumerateKey	ntoskrnl</span><br><span class="line">0000000140138210		ZwFlushKey	ntoskrnl</span><br><span class="line">0000000140138218		ZwQueryKey	ntoskrnl</span><br><span class="line">0000000140138220		ZwQueryValueKey	ntoskrnl</span><br><span class="line">0000000140138228		ZwSetValueKey	ntoskrnl</span><br><span class="line">0000000140138230		ZwPowerInformation	ntoskrnl</span><br><span class="line">0000000140138238		ObQueryNameString	ntoskrnl</span><br><span class="line">0000000140138240		swprintf_s	ntoskrnl</span><br><span class="line">0000000140138248		strncpy_s	ntoskrnl</span><br><span class="line">0000000140138250		DbgPrint	ntoskrnl</span><br><span class="line">0000000140138258		PsGetCurrentThreadId	ntoskrnl</span><br><span class="line">0000000140138260		KfRaiseIrql	ntoskrnl</span><br><span class="line">0000000140138268		IoBuildPartialMdl	ntoskrnl</span><br><span class="line">0000000140138270		RtlGetVersion	ntoskrnl</span><br><span class="line">0000000140138278		RtlIsNtDdiVersionAvailable	ntoskrnl</span><br><span class="line">0000000140138280		KeInitializeDpc	ntoskrnl</span><br><span class="line">0000000140138288		KeInitializeEvent	ntoskrnl</span><br><span class="line">0000000140138290		KeInitializeSemaphore	ntoskrnl</span><br><span class="line">0000000140138298		KeInitializeTimerEx	ntoskrnl</span><br><span class="line">00000001401382A0		IoAttachDeviceToDeviceStack	ntoskrnl</span><br><span class="line">00000001401382A8		IoDetachDevice	ntoskrnl</span><br><span class="line">00000001401382B0		IoRegisterShutdownNotification	ntoskrnl</span><br><span class="line">00000001401382B8		IoCsqInitialize	ntoskrnl</span><br><span class="line">00000001401382C0		IoRegisterDeviceInterface	ntoskrnl</span><br><span class="line">00000001401382C8		ExFreePool	ntoskrnl</span><br><span class="line">00000001401382D0		MmMapIoSpace	ntoskrnl</span><br><span class="line">00000001401382D8		MmUnmapIoSpace	ntoskrnl</span><br><span class="line">00000001401382E0		ZwEnumerateValueKey	ntoskrnl</span><br><span class="line">00000001401382E8		KeCancelTimer	ntoskrnl</span><br><span class="line">00000001401382F0		IoBuildDeviceIoControlRequest	ntoskrnl</span><br><span class="line">00000001401382F8		IoDisconnectInterrupt	ntoskrnl</span><br><span class="line">0000000140138300		IoGetAttachedDeviceReference	ntoskrnl</span><br><span class="line">0000000140138308		IoUnregisterShutdownNotification	ntoskrnl</span><br><span class="line">0000000140138310		IoSetDeviceInterfaceState	ntoskrnl</span><br><span class="line">0000000140138318		PoRequestPowerIrp	ntoskrnl</span><br><span class="line">0000000140138320		PoSetPowerState	ntoskrnl</span><br><span class="line">0000000140138328		ObfReferenceObject	ntoskrnl</span><br><span class="line">0000000140138330		ExUuidCreate	ntoskrnl</span><br><span class="line">0000000140138338		KeSetTimerEx	ntoskrnl</span><br><span class="line">0000000140138340		IoCancelIrp	ntoskrnl</span><br><span class="line">0000000140138348		PoCallDriver	ntoskrnl</span><br><span class="line">0000000140138350		PoStartNextPowerIrp	ntoskrnl</span><br><span class="line">0000000140138358		PsCreateSystemThread	ntoskrnl</span><br><span class="line">0000000140138360		PsTerminateSystemThread	ntoskrnl</span><br><span class="line">0000000140138368		KeAcquireSpinLockAtDpcLevel	ntoskrnl</span><br><span class="line">0000000140138370		KeReleaseSpinLockFromDpcLevel	ntoskrnl</span><br><span class="line">0000000140138378		MmUnlockPages	ntoskrnl</span><br><span class="line">0000000140138380		MmAllocateContiguousMemory	ntoskrnl</span><br><span class="line">0000000140138388		MmFreeContiguousMemory	ntoskrnl</span><br><span class="line">0000000140138390		IoAllocateIrp	ntoskrnl</span><br><span class="line">0000000140138398		IoBuildSynchronousFsdRequest	ntoskrnl</span><br><span class="line">00000001401383A0		IoConnectInterrupt	ntoskrnl</span><br><span class="line">00000001401383A8		IoFreeIrp	ntoskrnl</span><br><span class="line">00000001401383B0		IoGetDmaAdapter	ntoskrnl</span><br><span class="line">00000001401383B8		IoGetDeviceProperty	ntoskrnl</span><br><span class="line">00000001401383C0		MmGetPhysicalAddress	ntoskrnl</span><br><span class="line">00000001401383C8		RtlUnicodeToMultiByteN	ntoskrnl</span><br><span class="line">00000001401383D0		KeClearEvent	ntoskrnl</span><br><span class="line">00000001401383D8		KeQueryActiveProcessors	ntoskrnl</span><br><span class="line">00000001401383E0		KeBugCheckEx	ntoskrnl</span><br><span class="line">00000001401383E8		ZwSetSecurityObject	ntoskrnl</span><br><span class="line">00000001401383F0		IoDeviceObjectType	ntoskrnl</span><br><span class="line">00000001401383F8		IoCreateDevice	ntoskrnl</span><br><span class="line">0000000140138400		ObOpenObjectByPointer	ntoskrnl</span><br><span class="line">0000000140138408		RtlGetDaclSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138410		RtlGetGroupSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138418		RtlGetOwnerSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138420		RtlGetSaclSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138428		SeCaptureSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138430		_snwprintf	ntoskrnl</span><br><span class="line">0000000140138438		RtlLengthSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138440		SeExports	ntoskrnl</span><br><span class="line">0000000140138448		RtlCreateSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138450		_wcsnicmp	ntoskrnl</span><br><span class="line">0000000140138458		wcschr	ntoskrnl</span><br><span class="line">0000000140138460		RtlAbsoluteToSelfRelativeSD	ntoskrnl</span><br><span class="line">0000000140138468		RtlAddAccessAllowedAce	ntoskrnl</span><br><span class="line">0000000140138470		RtlLengthSid	ntoskrnl</span><br><span class="line">0000000140138478		IoIsWdmVersionAvailable	ntoskrnl</span><br><span class="line">0000000140138480		RtlSetDaclSecurityDescriptor	ntoskrnl</span><br><span class="line">0000000140138488		ExAllocatePoolWithQuotaTag	ntoskrnl</span><br><span class="line">0000000140138490		PsGetVersion	ntoskrnl</span><br><span class="line">0000000140138498		ZwQuerySystemInformation	ntoskrnl</span><br><span class="line">00000001401384A0		KeLowerIrql	ntoskrnl</span><br><span class="line"></span><br><span class="line">HAL			</span><br><span class="line">0000000140138000		KeStallExecutionProcessor	HAL</span><br></pre></td></tr></table></figure>

<p>结论：根据.sys的分析，此驱动是纯WDM实现的。因为内核接口全部调用WDM&#x2F;NT kernel接口， 完全没有调用微软的miniport框架例如Storport, SDHC，SDBUS框架封装后的接口。</p>
<p>但微软已不推荐WDM驱动开发，参考：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-wdm">Introduction to WDM</a> 。新驱动优先使用KMDF框架。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://voidsec.com/windows-drivers-reverse-engineering-methodology/#remote-kernel-debugging">https://voidsec.com/windows-drivers-reverse-engineering-methodology/#remote-kernel-debugging</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24481913/article/details/131643283">https://blog.csdn.net/qq_24481913/article/details/131643283</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/">https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/Windows%20Hardware%20driver%20submission%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/Windows%20Hardware%20driver%20submission%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Windows Hardware driver submission问题记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:43:16" itemprop="dateModified" datetime="2025-11-18T10:43:16+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">windows驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Windows-Hardware-driver-submission问题记录"><a href="#Windows-Hardware-driver-submission问题记录" class="headerlink" title="Windows Hardware driver submission问题记录"></a>Windows Hardware driver submission问题记录</h1><h2 id="Driver-Update-failure-rejected-问题分析"><a href="#Driver-Update-failure-rejected-问题分析" class="headerlink" title="Driver Update failure (rejected) 问题分析"></a>Driver Update failure (rejected) 问题分析</h2><h3 id="背景描述："><a href="#背景描述：" class="headerlink" title="背景描述："></a>背景描述：</h3><p>V10700 + Hardware ID：PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_389517aa</p>
<p>在windows hardware driver submission被reject，提交单和关键信息如下：</p>
<p><a target="_blank" rel="noopener" href="https://partner.microsoft.com/en-us/dashboard/hardware/driver/14391505706251263/submission/1152921505697924694/ShippingLabel/401531646">https://partner.microsoft.com/en-us/dashboard/hardware/driver/14391505706251263/submission/1152921505697924694/ShippingLabel/401531646</a></p>
<p>Rejection Theme: Measure Failure Rejection Reason: Systemic Measure Failure Provide Measure ID(s): 26387215 ADO bugId: 55312863: Bug ID(s) and Partner ID(s): Link to documentation: Link to reliability report (if applicable): Details: Rejected because Measure ID 26387215 (Percent of machines where the driver install process completes successfully) is failing. Please read more on “<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/pct-machines-where-driver-install-completes-successfully">https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/pct-machines-where-driver-install-completes-successfully</a>“ See the Plug and Play Extended Flight Report document for additional information on the failures. The “driver flight report” bug can be found by searching on Collaborate with the Submission ID. More info: <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/pnp-failure-report">https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/pnp-failure-report</a> and <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/collaborate/feedback-items-search#search">https://docs.microsoft.com/en-us/collaborate/feedback-items-search#search</a></p>
<h3 id="报告分析"><a href="#报告分析" class="headerlink" title="报告分析"></a>报告分析</h3><p>根据以上信息，在Microsoft partner center的feedback&#x2F;bugs页面找到提交单对应的failure报告：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031506203.png" alt="image-20250103150628028"></p>
<p>（1）RejectionReport中的关键信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031520135.png" alt="image-20250103152056064"></p>
<p>小结：微软测试了118个machine，其中在10台硬件平台ID PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA的机器上发生install failure. </p>
<p>错误码是ERROR_ACCESS_DENIED, 可能是微软环境问题或者硬件访问异常导致。</p>
<p>（2）report.html中的关键信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031513121.png" alt="image-20250103151330025"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031514877.png" alt="image-20250103151409828"></p>
<p>小结：Driver install failure基本都发生在硬件平台ID PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上，而且是不带Problem Code Description &amp; Problem Status 类型的安装错误，也就是说不是PNP error引起的install failure。</p>
<h3 id="Driver分析"><a href="#Driver分析" class="headerlink" title="Driver分析"></a>Driver分析</h3><p>为了确认此install error是driver相关还是硬件平台相关（PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA），做如下对比：</p>
<p>1.找到相同Driver installer V10700的其他提交单，和当前failure提交单的区别只在于支持的硬件平台ID不一样：</p>
<p><a target="_blank" rel="noopener" href="https://partner.microsoft.com/en-us/dashboard/hardware/driver/14391505706251263">https://partner.microsoft.com/en-us/dashboard/hardware/driver/14391505706251263</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031536917.png" alt="image-20250103153612882"></p>
<p>2.两个提交单只有Hardware ID有区别，系统都是Win11 24H2：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031534126.png" alt="image-20250103153449036"></p>
<p>3.两个提交单的微软反馈报告的区别：一个pass，一个failure（failure install发生在Bad hardware ID上）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202501031538765.png" alt="image-20250103153815661"></p>
<p><a target="_blank" rel="noopener" href="https://partner.microsoft.com/en-us/dashboard/collaborate/engagements/5133/feedback/wits/Bugs/1056149">https://partner.microsoft.com/en-us/dashboard/collaborate/engagements/5133/feedback/wits/Bugs/1056149</a></p>
<p><a target="_blank" rel="noopener" href="https://partner.microsoft.com/en-us/dashboard/collaborate/engagements/5133/feedback/wits/Bugs/1069371">https://partner.microsoft.com/en-us/dashboard/collaborate/engagements/5133/feedback/wits/Bugs/1069371</a></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>分析小结：</strong></p>
<p>微软的自动化测试流程发现V10700 installer在平台PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上有install failure，超出了允许的failure rate（&lt;5%）,所以reject driver提交单。</p>
<p>根据Driver提交单对比分析，这不是Driver installer的问题，因为相同的driver在其他平台的提交单是100% pass，此问题只发生在平台PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上。</p>
<p><strong>Debug方向：</strong></p>
<p>不确定微软是如何在平台PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上测试此driver install，有可能是物理机器或者虚拟机器上测试，也就是说，不排除是微软软件环境问题引起。</p>
<p>另外一方面，如果是物理机器确实有此问题，建议检查平台PCI\VEN_1217&amp;DEV_8621&amp;SUBSYS_38DF17AA上是否有特殊系统设置，或者PCIe bug，导致Bayhub SD Host硬件有时无法访问？</p>
<p><strong>当前解决办法：</strong></p>
<p>重新提交此driver，不需要做修改，以排除是微软软件环境引起的偶然性问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/Windows%20PC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/Windows%20PC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">windows PC开发环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:36:07" itemprop="dateModified" datetime="2025-11-18T10:36:07+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">windows系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="windows-PC开发环境配置"><a href="#windows-PC开发环境配置" class="headerlink" title="windows PC开发环境配置"></a>windows PC开发环境配置</h1><h2 id="多桌面和分屏"><a href="#多桌面和分屏" class="headerlink" title="多桌面和分屏"></a>多桌面和分屏</h2><p>Win+Ctrl+D， 新建桌面窗口</p>
<p>Win+Ctrl + ←&#x2F;→，切换桌面窗口</p>
<p>win+Tab， 任务视图，常用操作：拖动程序到指定窗口</p>
<p>win键+←&#x2F;→，快速分屏成两列</p>
<p>win键 + ←&#x2F;→ + ↑&#x2F;↓，快速4分屏</p>
<p>注意：多个桌面的相同应用是独立的，例如某桌面打开chrome很多页面，其他桌面打开chrome会是新网页</p>
<h2 id="区分Linux文件大小写"><a href="#区分Linux文件大小写" class="headerlink" title="区分Linux文件大小写"></a>区分Linux文件大小写</h2><p>需要4个条件：</p>
<p>Windows 10 1803以上版本<br>启用 Linux 子系统，即 Windows Subsystem for Linux<br>所在分区为 NTFS 格式<br>以管理员权限运行 PowerShell</p>
<p>必须启用WSL环境。powershell管理员运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure>

<p>再将指定目录启用大小写 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; fsutil.exe file setCaseSensitiveInfo C:\github enable</span><br><span class="line">已启用目录 C:\github 的区分大小写属性。</span><br></pre></td></tr></table></figure>

<p>之后解压linux kernel就不会报错同名大小写文件重复。</p>
<h2 id="未激活Windows去水印和关闭WindowsUpdate和桌面壁纸"><a href="#未激活Windows去水印和关闭WindowsUpdate和桌面壁纸" class="headerlink" title="未激活Windows去水印和关闭WindowsUpdate和桌面壁纸"></a>未激活Windows去水印和关闭WindowsUpdate和桌面壁纸</h2><p>win+R regedit设置Start值为4，去桌面水印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc -&gt; Start -&gt; 4</span><br></pre></td></tr></table></figure>

<p>永久关闭WindowsUpdate，否则下次Update之后又有水印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services.msc -&gt; Windows Update -&gt; </span><br><span class="line">(1)常规 -&gt; 禁用</span><br><span class="line">(2)恢复 -&gt; 第一次失败 -&gt; 无操作, 重置计数 -&gt; 9999</span><br></pre></td></tr></table></figure>

<p>更换壁纸：下载图片直接右键设置为壁纸</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cursorhu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cursorhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cursorhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cursorhu@outlook.com" title="E-Mail → mailto:cursorhu@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cursorhu</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
