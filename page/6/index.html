<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/6/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/archives/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">Linux Shell笔记：实现芯片固件的批量编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-12 14:58:37" itemprop="dateCreated datePublished" datetime="2020-08-12T14:58:37+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:00:41" itemprop="dateModified" datetime="2022-12-05T15:00:41+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某软件有不同的配置参数，实现不同功能版本的编译<br>批量测试需要批量编译各种版本，实现方式为：<br>1.将编译参数组合，生成大量配置文件<br>2.编译过程遍历这些配置文件，依次编译对应版本<br>3.有参数加入，修改，删除，只需要更新这些配置文件<br>如何实现这些配置文件的更新？</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某芯片的Firmware批量编译实现：<br>Firmware代码为C, 配置参数用宏实现，后缀为.def<br>目录结构如下</p>
<p>|–project_folder<br>　　|–config<br>　　　|–build.def<br>　　　|–defs<br>　　　　　|–1.def 2.def … n.def<br>　　|–src<br>　　|–Makefile<br>　　|–build_All.sh<br>　　|–update.sh</p>
<h2 id="批量编译脚本"><a href="#批量编译脚本" class="headerlink" title="批量编译脚本"></a>批量编译脚本</h2><p>批量编译脚本如下<br>基本过程：<br>1.依次拷贝def文件夹中的每个def，替换默认的build.def<br>2.编译，接受所有编译参数<br>3.拷贝编译输出的image到包含git tag, def名，时间等信息的文件夹</p>
<pre><code>#!/bin/bash

echo &quot;Batch build support args:&quot;
echo &quot;1. functin version:&quot;
echo &quot;verargs=mp_fpga&quot;
echo &quot;verargs=mpw_asic&quot;
echo &quot;2. boot debug:&quot;
echo &quot;bootargs=debug&quot;

OUTPUT=batch_build_$1$2

mkdir -p $&#123;OUTPUT&#125;
rm -rf ./batch_build_*

build_time=`date +%Y%m%d%H%M%S`

#commit_id=`git rev-parse HEAD`

tag_name=`git describe --exact-match --tags 2&gt;/dev/null`

if [ -z &quot;$&#123;tag_name&#125;&quot; ]; then
    tag_name=&quot;NO_TAG&quot;
fi

mv ./config/build.def ./config/build.def.bak 

for file in `ls ./config/defs/*.def`;
do
    file_name=$&#123;file##*/&#125;
    config_name=$&#123;file_name%.def&#125;
    
    cp -rf $&#123;file&#125; ./config/build.def
    make clean
    make -j4 $@
    #mv ./build/image ./batch_build/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;_cid_$&#123;commit_id&#125;
    mkdir -p ./$&#123;OUTPUT&#125;/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;
    mv ./build/image/* ./$&#123;OUTPUT&#125;/$&#123;tag_name&#125;_$&#123;config_name&#125;_time_$&#123;build_time&#125;
done

mv ./config/build.def.bak ./config/build.def
</code></pre>
<p>def文件内的.def文件即各种参数配置文件，.def文件名即参数功能的别名组合<br>例如：</p>
<pre><code>CQ_emmc_two_card_enhance_hs400_always_l0_MSIx_dllphase14_tuning_on.def
</code></pre>
<p>对应的内容是：</p>
<pre><code>/*0: Non-CQ mode 1:CQ mode enable*/
#define BB_CQ_MODE_ENABLE 1
/*the card number support emmc#0:0 emmc#1:1 two card:2*/
#define BB_CARD_NUMBER 2
/*0:legacy 1:High Speed 50MHz 2:HS200 3:HS400 4:Enhance HS400*/
#define BB_MAX_TRANSFER_MODE 4
/* power mode management: 0: Low Power 1:Balance 2:High Performance 3:Direct HP 4:Always L0*/
#define POWER_MANAGEMENT_MODE 4
/* INT_MODE: 0:MSI_X 1:INTx 2:MSI_MULTIPLE 3:MSI_SINGLE */
#define INT_MODE 0
/* The selection of DLL PHASE COUNT is 11 or 14 */
#define DLL_phase_cnt 14
/* 0: fixed output phase  1: auto output tuning */
#define AUTO_OUTPUT_TUNING 1
</code></pre>
<h2 id="批量编辑配置文件"><a href="#批量编辑配置文件" class="headerlink" title="批量编辑配置文件"></a>批量编辑配置文件</h2><p>配置文件def有两个属性<br>1.文件名每个词代表一个功能，各词用下划线“_”分隔<br>2.内部用宏定义实现功能配置，宏定义的值要和外部文件名匹配</p>
<p>基于以上属性，编辑脚本需求为：<br>1.新增：增加一个宏定义，并增加对应的功能缩写到文件名<br>2.修改：修改一个已存在的宏定义，并修改对应的功能缩写到文件名<br>3.删除：删除一个已存在的宏定义，并删除对应的功能缩写到文件名<br>4.其他功能，如直接删除含某缩写的文件，备份原配置文件</p>
<p>shell实现为update.sh,如下:</p>
<pre><code>#!/bin/bash

DEFS_PATH=&quot;./config/defs&quot;
DEFS_BACKUP_PATH=&quot;./config/defs_backup&quot;
DEFS_TEMP_PATH=&quot;./config/defs_temp&quot;

if [ $# -lt 1 ];then
        echo &quot;usage: ./update.sh [option] [args]&quot;

        echo &quot;example 0:&quot;
        echo &quot;        backup defs files:&quot;
        echo &quot;        ./update.sh -bf&quot;
        echo &quot;&quot;

        echo &quot;example 1:&quot;
        echo &quot;        add a macro name and macro value to defs, and add file postfix:&quot;
        echo &quot;        ./update.sh -b&quot;
        echo &quot;        ./update.sh -a balance POWER_MANAGEMENT_MODE 1 &quot;
        echo &quot;        ./update.sh -a high_performance POWER_MANAGEMENT_MODE 2 &quot;
        echo &quot;        add other values...&quot;
        echo &quot;&quot;

        echo &quot;example 2:&quot;
        echo &quot;        update a macro name and macro value to defs, and update file postfix:&quot;
        echo &quot;        ./update.sh -u balance lowpower POWER_MANAGEMENT_MODE 1 &quot;
        echo &quot;&quot;

        echo &quot;example 3:&quot;
        echo &quot;        delete a macro name and macro value of defs, and delete file postfix:&quot;
        echo &quot;        ./update.sh -d lowpower POWER_MANAGEMENT_MODE&quot;
        echo &quot;&quot;

        echo &quot;example 4:&quot;
        echo &quot;        delete target files:&quot;
        echo &quot;        ./update.sh -df lowpower&quot;
        echo &quot;&quot;

        echo &quot;example 5:&quot;
        echo &quot;        clean backup defs files:&quot;
        echo &quot;        ./update.sh -cf&quot;
        echo &quot;&quot;

        exit;
    fi

if [ $1 = &quot;-bf&quot; ];then #backup defs
    mkdir -p $DEFS_BACKUP_PATH
    mv $DEFS_PATH/*.def $DEFS_BACKUP_PATH

elif [ $1 = &quot;-cf&quot; ];then #clear backup defs
    rm -rf $DEFS_BACKUP_PATH
</code></pre>
<p>​<br>​    #add a macro name and macro value to defs, and add file postfix<br>​    elif [ $1 &#x3D; “-a” ];then<br>​<br>        if [ $# !&#x3D; 4 ];then<br>            echo “usage: .&#x2F;update.sh -a FILE_POSTFIX MACRO_NAME MACRO_VALUE”<br>            exit;<br>        fi</p>
<pre><code>    mkdir -p $DEFS_TEMP_PATH &amp;&amp; cp -rf $DEFS_BACKUP_PATH/*.def $DEFS_TEMP_PATH
    
    FILE_POSTFIX=$2
    MACRO_NAME=$3
    MACRO_VALUE=$4
    # sed -i makes change on original file, otherwise on stream
    # xargs transfer multiple output from stream to multiple args to sed
    find $&#123;DEFS_TEMP_PATH&#125; -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
    
    for file in `ls $&#123;DEFS_TEMP_PATH&#125;/*.def`
    do
     mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
    done
    
    cp -rf $DEFS_TEMP_PATH/*.def $DEFS_PATH
    rm -rf $DEFS_TEMP_PATH

#update a macro name and macro value to defs, and update file postfix
elif [ $1 = &quot;-u&quot; ];then

    if [ $# != 5 ];then
        echo &quot;usage: ./update.sh -u ORIGIN_POSTFIX UPDATED_POSTFIX MACRO_NAME MACRO_UPDATED_VALUE&quot;
        exit;
    fi

    ORIGIN_POSTFIX=$2
    UPDATED_POSTFIX=$3
    MACRO_NAME=$4
    MACRO_UPDATED_VALUE=$5

    #replace all lines that pattern matches $MACRO_NAME
    find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
    #update file postfix
    for file in `ls $&#123;DEFS_PATH&#125;/*$ORIGIN_POSTFIX*.def`
    do
         mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
    done
</code></pre>
<p>​<br>​    #delete a macro name and macro value of defs, and delete file postfix<br>​    elif [ $1 &#x3D; “-d” ];then<br>​<br>        if [ $# !&#x3D; 3 ];then<br>            echo “usage: .&#x2F;update.sh -d DELETE_POSTFIX MACRO_NAME”<br>            exit;<br>        fi</p>
<pre><code>    DELETE_POSTFIX=$2
    MACRO_NAME=$3
    #delete all lines that contain $MACRO_NAME
    find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
    #delete file postfix
    for file in `ls $&#123;DEFS_PATH&#125;/*.def`
    do
         mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
    done

#delete target file by postfix
elif [ $1 = &quot;-df&quot; ];then
    
    if [ $# != 2 ];then
        echo &quot;usage: ./update.sh -df DELETE_POSTFIX&quot;
        exit;
    fi

    DELETE_POSTFIX=$2
    rm -f $&#123;DEFS_PATH&#125;/*$DELETE_POSTFIX*.def

fi
</code></pre>
<p><strong>重点讲下其中的几个sed和文件操作</strong><br>1.多个文件，每个文件最后一行追加内容</p>
<pre><code>find $&#123;DEFS_TEMP_PATH&#125; -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
</code></pre>
<ul>
<li>xargs的作用： find <path> -name <string> 输出的是多个文件名，不能直接传给sed， <strong>xargs将多个文件名转化成多个参数</strong>，每个参数是一个文件名，sed可以接收</li>
<li>-i的作用：sed本身是在文件的拷贝上操作，不直接在文件本身修改，-i（insert）使sed的操作在文件上生效，<strong>如果不加-i，源文件不会被修改</strong></li>
<li>$：表示最后一行，sed ‘a\string’是基础格式</li>
<li>注意sed怎么用带空格和变量的字符串：<strong>空格用转义’\ ‘表示，变量是单引号内加双引号</strong>，即’”$ARG”‘</li>
</ul>
<p>2.找到包含字符串A的所有文件，替换内容：将字符串B替换为C</p>
<pre><code>#replace all lines that pattern matches $MACRO_NAME
find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
</code></pre>
<ul>
<li>find | grep 是常用套路，先找在过滤，注意find -name 可以使用*， grep不要用*，否则grep会把它当成要匹配的字符</li>
<li>sed ‘s&#x2F;stringB&#x2F;stringC’是基础格式，g表示全局，注意要-i</li>
</ul>
<p>3.找到包含字符串A的所有文件，删除内容：包含字符串B的行</p>
<pre><code>#delete all lines that contain $MACRO_NAME
find $&#123;DEFS_PATH&#125; -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
</code></pre>
<p>4.对多个文件的文件名，增加，修改，删除特定字符串</p>
<pre><code>#在原文件名最后，后缀之前，增加字符串“_$FILE_POSTFIX”
for file in `ls $&#123;DEFS_TEMP_PATH&#125;/*.def`
    do
     mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
    done

#替换文件名中匹配的字符
for file in `ls $&#123;DEFS_PATH&#125;/*$ORIGIN_POSTFIX*.def`
do
     mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
done

#删除文件名指定字符
for file in `ls $&#123;DEFS_PATH&#125;/*.def`
do
     mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
done
</code></pre>
<ul>
<li>for &lt; args &gt; in `ls &lt; path &gt;`是把多个文件名依次写入变量args的常用操作，类似于xargs，不过是用循环每次处理一个文件名变量</li>
<li>mv $file `echo $file | sed ‘s&#x2F;stringA&#x2F;stringB&#x2F;g’&#96;实际是两个步骤：先用echo把当前处理的文件名传给sed, sed处理完的输出文件名，作为mv的目标文件名，覆盖了原文件</li>
<li>注意，文件名xargs传给sed,处理的是文件内容，for-in-do一个个mv，才是处理文件名本身</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a target="_blank" rel="noopener" href="https://linux.cn/article-11367-1.html">使用 sed 命令查找和替换文件中的字符串的 16 个示例</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40572607/article/details/90812959">sed引入变量的几种方法</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/elong490/article/details/52587171">sed 批量替换文件内容</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/06/22/GCC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/22/GCC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">GCC使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-22 17:22:34" itemprop="dateCreated datePublished" datetime="2020-06-22T17:22:34+08:00">2020-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 17:28:18" itemprop="dateModified" datetime="2022-12-08T17:28:18+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GCC/" itemprop="url" rel="index"><span itemprop="name">GCC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gcc编译选项"><a href="#gcc编译选项" class="headerlink" title="gcc编译选项"></a>gcc编译选项</h1><p>gcc提供了大量的警告选项，对代码中可能存在的问题提出警告，通常可以使用-Wall来开启以下警告:</p>
<pre><code>   -Waddress -Warray-bounds (only with -O2) -Wc++0x-compat
   -Wchar-subscripts -Wimplicit-int -Wimplicit-function-declaration
   -Wcomment -Wformat -Wmain (only for C/ObjC and unless
   -ffreestanding) -Wmissing-braces -Wnonnull -Wparentheses
   -Wpointer-sign -Wreorder -Wreturn-type -Wsequence-point
   -Wsign-compare (only in C++) -Wstrict-aliasing -Wstrict-overflow=1
   -Wswitch -Wtrigraphs -Wuninitialized (only with -O1 and above)
   -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value
   -Wunused-variable

unused-function:警告声明但是没有定义的static函数;
unused- label:声明但是未使用的标签;
unused-parameter:警告未使用的函数参数;
unused-variable:声明但是未使用的本地变量;
unused-value:计算了但是未使用的值;
format:printf和scanf这样的函数中的格式字符串的使用不当;
implicit-int:未指定类型;
implicit-function:函数在声明前使用;
char- subscripts:使用char类作为数组下标(因为char可能是有符号数);
missingbraces:大括号不匹配;
parentheses: 圆括号不匹配;
return-type:函数有无返回值以及返回值类型不匹配;
sequence-point:违反顺序点的代码,比如 a[i] = c[i++];
switch:switch语句缺少default或者switch使用枚举变量为索引时缺少某个变量的case;
strict- aliasing=n:使用n设置对指针变量指向的对象类型产生警告的限制程度,默认n=3;只有在-fstrict-aliasing设置的情况下有效;
unknow-pragmas:使用未知的#pragma指令;
uninitialized:使用的变量为初始化,只在-O2时有效;
</code></pre>
<p>以下是在-Wall中不会激活的警告选项:</p>
<pre><code>cast-align:当指针进行类型转换后有内存对齐要求更严格时发出警告;
sign- compare:当使用signed和unsigned类型比较时;
missing-prototypes:当函数在使用前没有函数原型时;
packed:packed 是gcc的一个扩展,是使结构体各成员之间不留内存对齐所需的空间,有时候会造成内存对齐的问题;
padded:也是gcc的扩展,使结构体成员之间进行内存对齐的填充,会造成结构体体积增大.
unreachable-code:有不会执行的代码时.
inline:当inline函数不再保持inline时 (比如对inline函数取地址);
disable-optimization:当不能执行指定的优化时.(需要太多时间或系统资源).
可以使用 -Werror时所有的警告都变成错误,使出现警告时也停止编译.需要和指定警告的参数一起使用.
</code></pre>
<p>编译的优化级别:<br>gcc默认提供了5级优化选项的集合:</p>
<pre><code>-O0:无优化(默认)
-O和-O1:使用能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化.在编译大型程序的时候会显著增加编译时内存的使用.
-O2: 包含-O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化.编译器不执行循环展开以及函数内联.此选项将增加编译时间和目标文件的执行性能.
-Os:专门优化目标文件大小,执行所有的不增加目标文件大小的-O2优化选项.并且执行专门减小目标文件大小的优化选项.
-O3: 打开所有-O2的优化选项并且增加 -finline-functions, -funswitch-loops,-fpredictive-commoning, -fgcse-after-reload and -ftree-vectorize优化选项.
</code></pre>
<p>-O1包含的选项-O1通常可以安全的和调试的选项一起使用:</p>
<pre><code>   -fauto-inc-dec -fcprop-registers -fdce -fdefer-pop -fdelayed-branch
   -fdse -fguess-branch-probability -fif-conversion2 -fif-conversion
   -finline-small-functions -fipa-pure-const -fipa-reference
   -fmerge-constants -fsplit-wide-types -ftree-ccp -ftree-ch
   -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse
   -ftree-fre -ftree-sra -ftree-ter -funit-at-a-time
</code></pre>
<p>以下所有的优化选项需要在名字前加上-f,如果不需要此选项可以使用-fno-前缀</p>
<pre><code>defer-pop:延迟到只在必要时从函数参数栈中pop参数;
thread- jumps:使用跳转线程优化,避免跳转到另一个跳转;
branch-probabilities:分支优化;
cprop- registers:使用寄存器之间copy-propagation传值;
guess-branch-probability:分支预测;
omit- frame-pointer:可能的情况下不产生栈帧;
</code></pre>
<p>-O2:以下是-O2在-O1基础上增加的优化选项:</p>
<pre><code>    -falign-functions  -falign-jumps -falign-loops  -falign-labels
   -fcaller-saves -fcrossjumping -fcse-follow-jumps  -fcse-skip-blocks
   -fdelete-null-pointer-checks -fexpensive-optimizations -fgcse
   -fgcse-lm -foptimize-sibling-calls -fpeephole2 -fregmove
   -freorder-blocks  -freorder-functions -frerun-cse-after-loop
   -fsched-interblock  -fsched-spec -fschedule-insns
   -fschedule-insns2 -fstrict-aliasing -fstrict-overflow -ftree-pre
   -ftree-vrp
</code></pre>
<p>cpu架构的优化选项,通常是-mcpu(将被取消);-march,-mtune</p>
<p>Debug选项:</p>
<pre><code>在 gcc编译源代码时指定-g选项可以产生带有调试信息的目标代码,gcc可以为多个不同平台上帝不同调试器提供调试信息,默认gcc产生的调试信息是为 gdb使用的,可以使用-gformat 指定要生成的调试信息的格式以提供给其他平台的其他调试器使用.常用的格式有
-ggdb:生成gdb专用的调试信息,使用最适合的格式(DWARF 2,stabs等)会有一些gdb专用的扩展,可能造成其他调试器无法运行.
-gstabs:使用 stabs格式,不包含gdb扩展,stabs常用于BSD系统的DBX调试器.
-gcoff:产生COFF格式的调试信息,常用于System V下的SDB调试器;
-gxcoff:产生XCOFF格式的调试信息,用于IBM的RS/6000下的DBX调试器;
-gdwarf- 2:产生DWARF version2 的格式的调试信息,常用于IRIXX6上的DBX调试器.GCC会使用DWARF version3的一些特性.
</code></pre>
<p>可以指定调试信息的等级:在指定的调试格式后面加上等级:<br>如: -ggdb2 等,0代表不产生调试信息.在使用-gdwarf-2时因为最早的格式为-gdwarf2会造成混乱,所以要额外使用一个-glevel来指定调试信息的等级,其他格式选项也可以另外指定等级.<br>gcc可以使用-p选项指定生成信息以供porf使用.</p>
<h1 id="gcc配置选项"><a href="#gcc配置选项" class="headerlink" title="gcc配置选项"></a>gcc配置选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727329.png" alt="6"></p>
<h1 id="gcc常用选项"><a href="#gcc常用选项" class="headerlink" title="gcc常用选项"></a>gcc常用选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081725642.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726685.png" alt="2"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726022.png" alt="3"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726272.png" alt="4"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727091.png" alt="5"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/06/10/Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Makefile使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-10 17:20:09" itemprop="dateCreated datePublished" datetime="2020-06-10T17:20:09+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 17:30:53" itemprop="dateModified" datetime="2022-12-08T17:30:53+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/makefile/" itemprop="url" rel="index"><span itemprop="name">makefile</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件名替换"><a href="#文件名替换" class="headerlink" title="文件名替换"></a>文件名替换</h1><p>1.wildcard<br>展开多个文件为使用空格分开的、匹配此模式的列表参数<br>格式<br><code>$(wildcard PATTERN...)</code></p>
<p>示例：</p>
<pre><code>SRC=$(wildcard *.c)
</code></pre>
<p>2.patsubst<br>替换通配符<br>格式</p>
<pre><code>$(patsubst %.c,%.o,$(dir))
</code></pre>
<p>示例：</p>
<pre><code>obj := $(patsubst %.c,%.o,$(wildcard *.c))
</code></pre>
<p>3.替换引用<br>patsubst的示例等价于：</p>
<pre><code>obj=$(dir:%.c=%.o)
</code></pre>
<p>引用替换：</p>
<pre><code>$(var:a=b) 或 $&#123;var:a=b&#125;
</code></pre>
<p>含义是把变量var中的每一个值，用b替换掉a</p>
<h1 id="PHONY"><a href="#PHONY" class="headerlink" title="PHONY"></a>PHONY</h1><p>Makefile执行的规则是A:B，表示A依赖于B</p>
<ul>
<li>有B才能执行A对应的编译操</li>
<li>B有更新(检测文件时间)，则A会执行，若B没有更新，不执行A</li>
</ul>
<p>问题来了，clean: 不需要依赖任何对象，如何执行<br>PHONY定义伪目标,可以解决源文件不是最终目标直接依赖（即间接依赖）带来的不能自动检查更新规则, 示例如下</p>
<pre><code>.PHONY: clean
clean:
    rm -f *.o
</code></pre>
<p>PHONY不仅用于clean，对于间接依赖也有用，例如A:B， B:C ，有时C为空，就需要把B定义为PHONY</p>
<pre><code>OBJS = *.o
program:  $(OBJS)
        gcc *.o -o program
 
.PHONY : $(OBJS)
$(OBJS):
        make -C $(dir $@)
</code></pre>
<p>不过一般情况，obj依赖于%.c，总之，对于没有依赖项的对象，需要定义为PHONY</p>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>常见通配符</p>
<pre><code>$@, $^, $&lt;, $?

$@  表示目标文件
$^  表示所有的依赖文件
$&lt;  表示第一个依赖文件
$?  表示比目标还要新的依赖文件列表
</code></pre>
<p>示例：<br>编译Test目录下的.cpp文件，输出test可执行程序<br>直接指定依赖文件名的makefile写法：</p>
<pre><code>test: $(wildcard Test/*.cpp)
    $(CXX) $(CFLAGS) -o test $(wildcard Test/*.cpp) 
</code></pre>
<p>虽然wildcard实现了所有依赖的.cpp的通配，编译语句再用wildcard写一次依赖文件不优雅，而且test在依赖中已经写了，编译语句又写一遍 -o test。<br>编译语句使用通配, 称为通用格式：</p>
<pre><code>test: $(wildcard Test/*.cpp)
    $(CXX) $(CFLAGS) -o $@ $^
</code></pre>
<h1 id="多个源文件分别编译"><a href="#多个源文件分别编译" class="headerlink" title="多个源文件分别编译"></a>多个源文件分别编译</h1><p>目录下有很多源文件，每个单独编译和执行的，将每一个文件编译成可执行文件，不用单独命名如：gcc -c xxx.c -o xxx<br>(1)Makefile实现</p>
<pre><code>SRC=$(wildcard *.c)
OBJ=$(SRC:%.c=%.o)
BIN=$(OBJ:%.o=%)
 
CC=gcc
CFLAGS=-Wall -g -c
 
all:$(BIN)

$(BIN):%:%.o
        $(CC) $^ -o $@
$(OBJ):%.o:%.c
        $(CC) $(CFLAGS) $^ -o $@

.PHONY: clean
clean:
        rm -rf $(OBJ) $(BIN)
</code></pre>
<p>(2)Shell实现</p>
<pre><code>#! /bin/bash
for file in ./*.c
do
if [ -f $file ]
then
file=$&#123;file#./&#125;
target=$&#123;file%.c&#125;
gcc -o $target $file
echo $target
fi
if [ -d $file ]
then
echo $file is mu lu
fi
done
</code></pre>
<p>(2)Makefile编译指定目录<br>Makefile可以输入参数，直接在make命令的后面加上参数，如:</p>
<pre><code>make BUILD_DIR=./foldername/
</code></pre>
<p>传入的变量将会覆盖相应Makefile中的<code>BUILD_DIR</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/" class="post-title-link" itemprop="url">Linux Shell笔记：文本编辑利器sed+awk+grep</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 14:50:22" itemprop="dateCreated datePublished" datetime="2020-05-30T14:50:22+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:00:29" itemprop="dateModified" datetime="2022-12-05T15:00:29+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shell增删改查概述"><a href="#shell增删改查概述" class="headerlink" title="shell增删改查概述"></a>shell增删改查概述</h1><p>Linux Shell环境对文本增删改查，可以通过sed，awk和grep命令完成。</p>
<ul>
<li>sed: 支持特定模式匹配的增加、插入、删除、替换、提取等操作</li>
<li>awk: 支持特定模式匹配的过滤查找，如提取某行列的字符串</li>
<li>grep: 支持包含特定字符串的结果提取，可配合find和awk实现过滤查找</li>
</ul>
<p>这几种命令都支持流输入和文本输入，支持管道传递参数，也可以命令行传参。对于多个步骤的处理，可以几个命令串行使用。</p>
<h1 id="shell的输入参数概述"><a href="#shell的输入参数概述" class="headerlink" title="shell的输入参数概述"></a>shell的输入参数概述</h1><p>Shell的命令，如<code>cat, echo, sed, awk, grep</code>, 管道命令<code>|</code>等，都要有输入参数，即待处理的数据。<br>输入参数有两种类型：</p>
<ul>
<li>标准输入：本质是stdin文件，即读取该文件的内容作为命令的输入参数，该文件内容可由其他命令的输出，或者用户输入来产生</li>
<li>命令行输入：直接接受用户在命令行输入的字符串，一次性使用,不存储在stdin</li>
</ul>
<p>支持标准输入作为参数的命令：<code>cat, sed, awk, grep, |</code> 等<br>只支持命令行输入字符串的命令：<code>echo, ls</code>等<br>标准输入示例：</p>
<pre><code>cat /etc/passwd | grep root
</code></pre>
<p>上面的代码使用了管道命令<code>|</code>，管道命令的作用是将左侧命令<code>cat /etc/passwd</code>的标准输出转换为标准输入，提供给右侧命令<code>grep root</code>作为参数。<br>以上命令也可以写成命令行输入形式：</p>
<pre><code>grep root /etc/passwd
</code></pre>
<p>不支持标准输入的示例：</p>
<pre><code>echo &quot;hello world&quot; | echo
</code></pre>
<p>输出为空，管道右侧的echo不接受管道传来的标准输入作为参数。<br>xargs的作用：将标准输入转为命令行参数</p>
<pre><code>echo &quot;hello world&quot; | xargs echo
</code></pre>
<p>输出“hello world”，xargs和管道配合使用，能使管道也支持非标准输入命令。<br>xargs支持一些选项做进一步细化处理，如-p(打印), -d(分割) 等。</p>
<h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><h2 id="sed命令概述"><a href="#sed命令概述" class="headerlink" title="sed命令概述"></a>sed命令概述</h2><p>sed支持文本编辑，实现增、删、改的功能。<br>sed命令格式：</p>
<pre><code>sed [options] &#39;command&#39; filename
</code></pre>
<p>sed的输入参数可以用命令行，管道和xargs传入：</p>
<pre><code>//命令行传入文件名参数
sed [options] &#39;command&#39; filename 
//管道传入文件名参数
cat filename | sed [options] &#39;command&#39;
//xargs传入文件名参数
cat filename | xargs sed [options] &#39;command&#39;
</code></pre>
<p>sed对文件的编辑在缓冲区，不直接修改文本。要直接修改文本有以下方法：</p>
<ul>
<li>重定向覆盖文本， <code>sed - x &#39;XXX&#39; file.txt &gt; file.txt</code></li>
<li>特定的sed命令支持直接修改文本，如<code>sed -i &#39;XXX&#39; file.txt</code></li>
</ul>
<p>sed的常用选项：</p>
<pre><code>-n ：关闭默认输出,只显示匹配的行
-i ：直接修改读取的文件内容，而不是输出到终端。
-e ：直接在命令列模式上进行sed的动作编辑；
-f ：直接将sed的动作写在一个文件内，-f filename 则可以运行filename内的sed动作；
-r ：启用扩展的正则表达式
</code></pre>
<p>sed的常用命令：</p>
<pre><code>a ：新增行，在指定行的后面附加一行，[address]a\新文本内容
i ：插入行，在指定行的前面插入一行，[address]i\新文本内容
s ：替换特定模式匹配的字符串, [address]s/pattern/replacement/flags
c ：将指定行中的所有内容，替换成该选项后面的字符串, [address]c\用于替换的新文本
d ：删除行，[address]d
p ：打印， 通常与参数 -n 一起用，[address]p
w : 将文本中指定行的内容写入文件, [address]w filename
</code></pre>
<h2 id="sed命令详解"><a href="#sed命令详解" class="headerlink" title="sed命令详解"></a>sed命令详解</h2><p>本节从sed文本操作的“增删改查”举例说明其具体命令用法</p>
<h3 id="新增和插入：a和i"><a href="#新增和插入：a和i" class="headerlink" title="新增和插入：a和i"></a>新增和插入：a和i</h3><p>sed的命令a和i都能实现新增行，其区别在于：</p>
<ul>
<li>a ：append, 指定行后面新增一行</li>
<li>i : insert, 表示在指定行前面插入一行</li>
</ul>
<p>注意区分i命令和i选项<br>a和i命令的基本格式完全相同：</p>
<pre><code>[address]a（或 i）\新文本内容
</code></pre>
<p>将一个新行插入到数据流第三行前：</p>
<pre><code>sed &#39;3i\This is an inserted line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is an inserted line.
This is line number 3.
This is line number 4.
</code></pre>
<p>将一个新行附加到数据流中第三行后:</p>
<pre><code>sed &#39;3a\This is an appended line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is line number 3.
This is an appended line.
This is line number 4.
</code></pre>
<p>将一个多行数据添加到数据流中，只需对要行末尾添加反斜线即可，类似C语言的代码换行</p>
<pre><code>sed &#39;1i\
This is one line of new text.\
This is another line of new text.&#39; data6.txt

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
</code></pre>
<h3 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h3><ul>
<li>d: delete, 删除行</li>
</ul>
<p>格式：</p>
<pre><code>[address]d
</code></pre>
<p>删除第三行：</p>
<pre><code>[root@localhost ~]# cat data6.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
[root@localhost ~]# sed &#39;3d&#39; data6.txt
This is line number 1.
This is line number 2.
This is line number 4.
</code></pre>
<p>删除二、三行：</p>
<pre><code>sed &#39;2,3d&#39; data6.txt
This is line number 1.
This is line number 4.
</code></pre>
<p>删除第三行开始的后续所有行：</p>
<pre><code>[root@localhost ~]# sed &#39;3,$d&#39; data6.txt
This is line number 1.
This is line number 2.
</code></pre>
<p>注意：sed d 命令并不会修改原始文件，这里被删除的行只是从 sed 的缓冲区中消失了，原始文件没做任何改变，若要修改源文件，可重定向sed的输出到源文件，覆盖原内容使修改生效。</p>
<h3 id="匹配定位：-x2F-pattern-x2F"><a href="#匹配定位：-x2F-pattern-x2F" class="headerlink" title="匹配定位：&#x2F;pattern&#x2F;"></a>匹配定位：&#x2F;pattern&#x2F;</h3><p>sed的增删操作，可以针对包含匹配字符串的行进行操作，其原理是活用[address], 支持匹配字符串的定位，以插入命令’i’为例，匹配格式如下：</p>
<pre><code>sed [option] &#39;/匹配字符串/i \插入字符串&#39;
[option] 通常为 -i, 修改直接在源文件生效
</code></pre>
<p>原文件：</p>
<pre><code>cat testfile 
hello
</code></pre>
<p>在包含”hello”的一行的上一行，插入”upline”:</p>
<pre><code>sed -i &#39;/hello/i\upline&#39; testfile
</code></pre>
<p>“hello”下一行插入”upline”:</p>
<pre><code>sed -i &#39;/hello/a\down&#39; testfile
</code></pre>
<p>修改后的文件：</p>
<pre><code>cat testfile 
up
hello
down
</code></pre>
<p>删除匹配到”hello”的行：</p>
<pre><code>sed -i &#39;/hello/d&#39; testfile
</code></pre>
<p>如果匹配字符串有“&#x2F;”，为了和sed命令的分隔符“&#x2F;”，使用“\”转义。<br>例如删除匹配某个路径字符串的行：</p>
<pre><code>匹配&quot;\etc\install.sh&quot;
set -i &#39;/\/etc\/install.sh/d&#39; test.txt
</code></pre>
<p>sed 命令包含一些预定义特殊符号，代表行尾，行首等。<br>删除以A开头的行：</p>
<pre><code>sed -i &#39;/^A.*/d&#39; test.txt
^A表示开头是A, .*表示后跟任意字符串
</code></pre>
<p>在行尾追加一行内容:</p>
<pre><code>sed -i &#39;$a\added-content&#39; test.txt
$表示定位到行尾，a是追加命令，added-content是追加内容
</code></pre>
<h3 id="替换修改-s"><a href="#替换修改-s" class="headerlink" title="替换修改: s"></a>替换修改: s</h3><p>s替换命令内部格式为：</p>
<pre><code>[address]s/pattern/replacement/flags
</code></pre>
<ul>
<li>address 指定要操作的具体行</li>
<li>pattern 指定需要替换的内容</li>
<li>replacement 指定替换的新内容</li>
<li>flags 指定特殊功能</li>
</ul>
<p>常用的flags:</p>
<ul>
<li>n    1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换</li>
<li>g    对数据中所有匹配到的内容进行替换，否则只会在第一次匹配成功时做替换操作</li>
<li>p    会打印与替换命令中指定的模式匹配的行。此标记通常与 -n    选项一起使用</li>
<li>\    转义（转义替换部分包含：&amp;、\ 等）。</li>
</ul>
<p>替换每行第二个匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/2&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the trial script
This is second test of the trial script
</code></pre>
<p>只替换第二行的匹配字符串：</p>
<pre><code>sed &#39;2s/test/trial/&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the test script
This is second test of the trial script
</code></pre>
<p>全局替换所有匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/g&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first trial of the trial script
This is second trial of the trial script
</code></pre>
<h3 id="提取：p"><a href="#提取：p" class="headerlink" title="提取：p"></a>提取：p</h3><p>sed p命令配合字符串匹配，可以输出包含指定字符串的行内容。</p>
<pre><code>sed -n &#39;/string/p&#39; filename
提取filename文件中,所有包含string的行的内容，并打印到标准输出
-n是只打印匹配命中的内容
</code></pre>
<p>sed p和grep都能提取内容，其区别在于：</p>
<ul>
<li><code>sed &#39;/string/p&#39;</code>是提取指定文件的行内容，重点在内容提取</li>
<li><code>grep &quot;string&quot; path</code>是输出包含指定内容的所有文件路径，重点在查找文件位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452182.png" alt="image-20221205145238133"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452191.png" alt="image-20221205145248149"></p>
<h2 id="sed进阶与实战"><a href="#sed进阶与实战" class="headerlink" title="sed进阶与实战"></a>sed进阶与实战</h2><h3 id="多文件批量追加和删除"><a href="#多文件批量追加和删除" class="headerlink" title="多文件批量追加和删除"></a>多文件批量追加和删除</h3><p>背景介绍：<br>底层固件代码有一些功能由宏定义控制，不同功能需要不同的宏定义组合，因此有不同的宏定义文件，命名为.def后缀。批量编译不同版本，编译脚本依次提取def文件夹内的.def文件和源代码一起编译。单个def内容如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453765.png" alt="image-20221205145321718"></p>
<p>每一个宏都有多个取值，因此组合起来，需要生成一堆.def文件，批量编译才能覆盖各自功能。<br>每新增一个宏，都要修改所有.def文件，如果这个宏有两个取值，.def文件数量将翻倍。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453942.png" alt="image-20221205145327892"></p>
<p>人工修改过于低效，使用sed可解决此问题。</p>
<p>查找指定文件，并批量追加一行内容：</p>
<pre><code>find . -name &#39;*.def*&#39; | xargs sed -i &#39;$a\added-content&#39;
</code></pre>
<p>各命令含义：</p>
<pre><code>find [path] -name &quot;*.def&quot;
查找path路径下，以.def结尾的所有文件，结果存储在stdout
|
管道，将查找结果转存到标准输入stdin
xargs
查找结果有很多个，用xargs转成命令行输入，sed才能批量处理
sed -i &#39;$a\added-content&#39;
    -i 直接修改文件，&#39;$a\added-content&#39; 最后一行追加added-content
</code></pre>
<p>查找指定文件，并批量删除匹配某字符串的行：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/deleteString/d&quot;
</code></pre>
<p>查找指定文件，并批量替换匹配某字符串：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/oldString/newString/&quot;
</code></pre>
<p>在实际shell脚本中，通常由用户输入变量，<code>$1, $2, $@</code> 解析变量。a、i、d和s能否在命令中使用双引号解析变量，实现动态编辑？<br>实验如下：</p>
<pre><code>ARGS=&quot;AA BB&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$a\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$i\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/$&#123;ARGS&#125;/d&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/aabb/$ARGS/&quot;
</code></pre>
<ul>
<li>i 和 a 命令不能解析变量，实际追加的就是是${ARGS}</li>
<li>d命令可以解析变量，实际删除的是有”AA BB”的行</li>
<li>s命令可以解析变量，实际替换后的结果是”AA BB”</li>
</ul>
<p>结论：将命令中的单引号改成双引号，理论上可以解析$包含的变量，实际上有的命令支持，有的命令不支持。</p>
<h3 id="提取文件中的关键内容"><a href="#提取文件中的关键内容" class="headerlink" title="提取文件中的关键内容"></a>提取文件中的关键内容</h3><p>背景介绍：<br>底层固件需要将代码段、数据段等关键信息存储在固件头部，编译过程中用编译器的size命令可以获取这些信息，并存储到文本，但是固件头部需要按自己的格式存储起始地址和大小信息，因此需要用sed提取并编辑该文本。</p>
<p>原文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453983.png" alt="image-20221205145348933"></p>
<p>提取后文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453414.png"></p>
<p>sed命令：</p>
<pre><code>sed -n &#39;/string/p&#39; oldFile | awk &#39;&#123;print $3&#125;&#39; &gt;&gt; newFile
提取oldFile内包含string的行，并用awk提取第三列，再写入newFile
</code></pre>
<p>该命令在Makefile实现，需要根据Makefile和shell特性做修改：</p>
<ul>
<li>@：编译过程隐藏命令输出，类似于后台执行</li>
<li>$(shell xxxx): Makefile执行shell命令</li>
<li>$$: Makefile不能直接用shell的“$”解析变量，用“$$”</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051454928.png" alt="image-20221205145409877"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">NodeJs笔记：使用pm2部署项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 14:25:24" itemprop="dateCreated datePublished" datetime="2020-05-20T14:25:24+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 14:29:50" itemprop="dateModified" datetime="2022-12-06T14:29:50+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJs/" itemprop="url" rel="index"><span itemprop="name">NodeJs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>nodejs服务可以用<code>nohup node xxx.js &amp;</code>后台启动，但是实际使用发现不太稳定，使用专门的node后台服务管理工具：pm2解决此问题</p>
<h1 id="pm2特性"><a href="#pm2特性" class="headerlink" title="pm2特性"></a>pm2特性</h1><p>1、内建负载均衡（使用Node cluster 集群模块）<br>2、后台运行<br>3、0秒停机重载<br>4、具有Ubuntu和CentOS 的启动脚本<br>5、停止不稳定的进程（避免无限循环）<br>6、控制台检测<br>7、提供 HTTP API<br>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p>
<h1 id="pm2安装"><a href="#pm2安装" class="headerlink" title="pm2安装"></a>pm2安装</h1><pre><code>npm install -g pm2
</code></pre>
<h1 id="pm2用法"><a href="#pm2用法" class="headerlink" title="pm2用法"></a>pm2用法</h1><pre><code>pm2 start app.js        //启动进程
pm2 start app.js -i 4   // 后台运行pm2，启动4个app.js
pm2 start app.js -i max //启动，使用所有CPU核心
pm2 start app.js --name my-api // 命名进程
pm2 list               // 显示所有进程状态
pm2 monit              // 监视所有进程
pm2 logs               //  显示所有进程日志
pm2 stop all           // 停止所有进程
pm2 restart all        // 重启所有进程
pm2 reload all         // 0秒停机重载进程 (用于 NETWORKED 进程)
pm2 stop 0             // 停止指定的进程
pm2 restart 0          // 重启指定的进程
pm2 startup            // 产生 init 脚本 保持进程活着
pm2 web                // 运行健壮的 computer API endpoint 
pm2 delete 0           // 杀死指定的进程
pm2 delete all         // 杀死全部进程
</code></pre>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>部署Github项目NodeMail，每天给指定邮箱发邮件。</p>
<p>后台启动main.js并监测状态：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427417.png" alt="image-20221206142729375"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427110.png" alt="image-20221206142743066"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427682.png" alt="image-20221206142752627"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061428280.png" alt="image-20221206142800236"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/" class="post-title-link" itemprop="url">Linux Shell笔记：判断语句if-then-else-fi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-05 14:46:30" itemprop="dateCreated datePublished" datetime="2020-05-05T14:46:30+08:00">2020-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:00:22" itemprop="dateModified" datetime="2022-12-05T15:00:22+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>shell中if-then-else-fi判断语句如下：</p>
<pre><code>a=&quot;abc&quot;

if [ $a = &quot;abc&quot; ]
then
   echo &quot;$a = $b&quot;
else
   echo &quot;$a != $b&quot;
fi
</code></pre>
<p>注意以下几点：</p>
<ul>
<li>shell中的等号：<code>=</code>可用于赋值，也可以用于判断；<code>==</code>只用于判断，更规范</li>
<li>shell中的if语句各符号间都要空格分隔：<code>if</code>和<code>[ ]</code>之间要空格；<code>[ ]</code>和<code>“ ”</code>之间要空格； <code>&quot;</code>和<code>=</code>之间要空格。否则if语句中的符号会解析失败。</li>
<li>shell变量没有数据类型的区分，把任何存储在变量中的值，皆视为“字符串”</li>
<li>对于变量可能为空的情况，需要用双括号<code>[[ $a = &quot;abc&quot; ]]</code></li>
<li>if-then可以写在同一行，用;分隔两个语句：<code>if [ $a = &quot;abc&quot; ];then</code></li>
</ul>
<h1 id="不同类型的判断语句"><a href="#不同类型的判断语句" class="headerlink" title="不同类型的判断语句"></a>不同类型的判断语句</h1><h2 id="关系运算符判断"><a href="#关系运算符判断" class="headerlink" title="关系运算符判断"></a>关系运算符判断</h2><p>-eq    检测两个数是否相等，相等返回 true。    [ $a -eq $b ] 返回 false。</p>
<p>-ne    检测两个数是否不相等，不相等返回 true。    [ $a -ne $b ] 返回 true。</p>
<p>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ] 返回 false。</p>
<p>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ] 返回 true。</p>
<p>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。    [ $a -ge $b ] 返回 false。</p>
<p>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。    [ $a -le $b ] 返回 true。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>
<h2 id="布尔和逻辑运算符判断"><a href="#布尔和逻辑运算符判断" class="headerlink" title="布尔和逻辑运算符判断"></a>布尔和逻辑运算符判断</h2><p>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ] 返回 true。</p>
<p>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ] 返回 true。</p>
<p>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a == $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>
<p>&amp;&amp;    逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</p>
<p>||    逻辑的 OR    [[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<pre><code>#!/bin/bash

a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>
<h2 id="字符串运算符判断"><a href="#字符串运算符判断" class="headerlink" title="字符串运算符判断"></a>字符串运算符判断</h2><p>&#x3D;    检测两个字符串是否相等，相等返回 true。    [ $a &#x3D; $b ] 返回 false。</p>
<p>!&#x3D;    检测两个字符串是否相等，不相等返回 true。    [ $a !&#x3D; $b ] 返回 true。</p>
<p>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。  </p>
<p>-n    检测字符串长度是否不为 0，不为 0 返回 true。    [ -n “$a” ] 返回 true。</p>
<p><code>$</code> 检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。</p>
<pre><code>#!/bin/bash

a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a != $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a = $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n &quot;$a&quot; ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>
<h2 id="文件检查运算符判断"><a href="#文件检查运算符判断" class="headerlink" title="文件检查运算符判断"></a>文件检查运算符判断</h2><p>b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ] 返回 false。</p>
<p>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -c $file ] 返回 false。</p>
<p>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ] 返回 false。</p>
<p>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。</p>
<p>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] 返回 false。</p>
<p>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。</p>
<p>-p file    检测文件是否是有名管道，如果是，则返回 true。    [ -p $file ] 返回 false。</p>
<p>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。</p>
<p>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。</p>
<p>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。</p>
<p>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。</p>
<p>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。</p>
<p>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。</p>
<p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。</p>
<pre><code>#!/bin/bash

file=&quot;/root/test.sh&quot;

if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>
<h1 id="判断语句报错：”unary-operator-expected”"><a href="#判断语句报错：”unary-operator-expected”" class="headerlink" title="判断语句报错：”unary operator expected”"></a>判断语句报错：”unary operator expected”</h1><p>在匹配字符串相等时，用了类似这样的语句：</p>
<pre><code>if [ $STATUS == &quot;OK&quot; ]; then     
echo &quot;OK&quot;
fi
</code></pre>
<p>在运行时出现了 <code>[: =: unary operator expected</code> 的错误</p>
<pre><code>if [[ $STATUS == &quot;OK&quot; ]]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>究其原因，是因为如果变量STATUS值为空，那么就成了 [ &#x3D; “OK”] ，显然 [ 和 “OK” 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。<br>或者用下面的方法也能避免这种错误：</p>
<pre><code>if [ &quot;$STATUS&quot;x == &quot;OK&quot;x ]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>当然，x也可以是其他字符。shell中有没有双引号在很多情况下是一致的,因此x可以不加引号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">Gitlab笔记：CentOS7部署Gitlab服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 14:39:02" itemprop="dateCreated datePublished" datetime="2020-04-30T14:39:02+08:00">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 14:52:58" itemprop="dateModified" datetime="2022-12-06T14:52:58+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>阿里云ECS, CentOS7, RAM 4G</p>
<h1 id="安装Gitlab"><a href="#安装Gitlab" class="headerlink" title="安装Gitlab"></a>安装Gitlab</h1><p>1.安装ssh并配置</p>
<pre><code>#安装
sudo yum install -y curl policycoreutils-python openssh-server
#配置开机启动
sudo systemctl enable sshd
#启动服务
sudo systemctl start sshd
</code></pre>
<p>2.配置防火墙</p>
<pre><code>#启动防火墙
service firewalld start
#添加http服务到firewalld,pemmanent表示永久生效
sudo firewall-cmd --permanent --add-service=http
#重启防火墙
sudo systemctl reload firewalld
</code></pre>
<p>3.安装gitlab</p>
<pre><code>#下载安装脚本
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash
#安装
yum install -y gitlab-ee
</code></pre>
<p>4.配置gitlab</p>
<pre><code>#gitlab配置文件
vim /etc/gitlab/gitlab.rb
#修改以下内容为主机ip和未使用的端口，否则使用默认端口8080
external_url &#39;http://47.100.221.149:9030&#39;
</code></pre>
<p>5.配置生效并重启gitlab</p>
<pre><code>#配置生效，改了配置需要运行
gitlab-ctl reconfigure
#重启服务，没改配置直接重启
gitlab-ctl restart
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061444445.png" alt="image-20221206144455394"><br>似乎服务都正常启动了，实际上可能有各种问题，参考问题记录</p>
<h1 id="问题Debug记录"><a href="#问题Debug记录" class="headerlink" title="问题Debug记录"></a>问题Debug记录</h1><p>按以上步骤配置好后，访问主机ip:端口，直接弹出502服务端错误<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061445877.png" alt="image-20221206144542817"></p>
<h2 id="配置文件权限问题"><a href="#配置文件权限问题" class="headerlink" title="配置文件权限问题?"></a>配置文件权限问题?</h2><p>配置文件生效命令<code>gitlab-ctl reconfigure</code>做了以下事情：</p>
<ul>
<li>配置设置写到gitlab服务直接调用的文件</li>
</ul>
<p>实际生效的配置文件：</p>
<pre><code>vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446719.png" alt="image-20221206144606669"><br>可见配置被自动拷贝到此处，gitlab相关服务读取的是这里的配置项</p>
<ul>
<li>生成服务相关临时文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446110.png" alt="image-20221206144619066"></p>
<p>原因：gitlab服务的配置文件在reconfigure时生成于&#x2F;var&#x2F;log&#x2F;gitlab，这个文件目录默认权限不够，有些子服务不能正常运行。</p>
<p>解决方法：</p>
<pre><code>chmod -R 777 /var/log/gitlab
</code></pre>
<p>restart服务，网页即可正常访问gitlab，如果恢复该目录755权限，重启服务会502</p>
<p>每次重新配置，<code>gitlab-ctl reconfigure</code>似乎会删除该目录再重新写入<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446151.png" alt="image-20221206144636079"></p>
<p>因此每次gitlab-ctl reconfigure之后都要<code>chmod 777</code>改此目录权限</p>
<h2 id="还有502问题"><a href="#还有502问题" class="headerlink" title="还有502问题?"></a>还有502问题?</h2><h3 id="检查阿里云端口"><a href="#检查阿里云端口" class="headerlink" title="检查阿里云端口"></a>检查阿里云端口</h3><p>首先确保主机ip是公网能访问的，不是内网ip<br>其次看端口是否禁用。在阿里云ECS的安全组策略中查看端口是否允许TCP输入输出<br>我把所有端口（1~65535）全部打开了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446454.png" alt="image-20221206144656411"></p>
<h3 id="检查前向端口冲突"><a href="#检查前向端口冲突" class="headerlink" title="检查前向端口冲突"></a>检查前向端口冲突</h3><p>gitlab配置文件的external_url就包含前向端口</p>
<pre><code>netstat -nlp | grep 9030 (我的gitlab前向端口)
</code></pre>
<p>显示的是nginx服务端口，因为gitlab默认被nginx反向代理了，说明gitlab的代理服务确实占用9030。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449545.png" alt="image-20221206144927508"></p>
<h3 id="检查子服务的端口"><a href="#检查子服务的端口" class="headerlink" title="检查子服务的端口"></a>检查子服务的端口</h3><p>注意gitlab不只有一个服务，默认配置只设置了前向端口（nginx代理端口），而子服务都没配置端口，默认用了8080，如果有其他服务已经占用8080，可能子服务起不来<br>例如unicorn子服务：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449220.png" alt="image-20221206144946178"></p>
<p>查看子服务状态</p>
<pre><code>gitlab-ctl status
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449573.png" alt="image-20221206144958510"></p>
<p>如果本地已有8080的服务，最好杀掉或换其他端口，否则要手动配置gitlab子服务端口</p>
<pre><code>unicorn[&#39;port&#39;] = 9032 （随便一个未使用端口）
gitlab_workhorse[&#39;auth_backend&#39;] = &quot;http://localhost:9032&quot;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450285.png" alt="image-20221206145014236"></p>
<h3 id="检查内存资源不足"><a href="#检查内存资源不足" class="headerlink" title="检查内存资源不足"></a>检查内存资源不足</h3><p>阿里云2G以下RAM可能会有因内存不足，导致服务不能正常启动。<br>使用swap交换分区，避免内存不足的可能性。swap分区可以把部分内存分页存储到磁盘，变相“扩大”内存</p>
<pre><code>#查看现有swap分区，若未分配大小为0
cat /proc/swaps
#创建swap文件，大小4G，挂载到/mnt。交换分区可以使用真正的分区，或者以文件形式的分区
dd if=/dev/zero of=/mnt/swap bs=512 count=8388616
#使之成为swap分区
mkswap /mnt/swap
#修改swap分区配置
cat /proc/sys/vm/swappiness
sysctl -w vm.swappiness=60
#swap分区配置永久生效
vim /etc/sysctl.conf
修改vm.swappiness=60
#启动分区
swapon /mnt/swap
echo “/mnt/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab
#停用分区
swapoff /mnt/swap
swapoff -a &gt; /dev/null
</code></pre>
<p>启用分区后运行gitlab，发现已经有一部分数据转移到了swap文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450437.png" alt="image-20221206145023389"></p>
<h1 id="ssh访问配置"><a href="#ssh访问配置" class="headerlink" title="ssh访问配置"></a>ssh访问配置</h1><p>通过ssh上传下载，需要建立ssh key</p>
<pre><code>ssh-keygen   #一路回车
</code></pre>
<p>若创建成功，查看生成的公钥：</p>
<pre><code>cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yXXXXXXXX
</code></pre>
<p>添加公钥至gitlab</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450049.png" alt="image-20221206145031977"></p>
<h1 id="初始化git项目"><a href="#初始化git项目" class="headerlink" title="初始化git项目"></a>初始化git项目</h1><p>配置git全局用户名，邮箱</p>
<pre><code>git config --global user.name &quot;YOUR NAME&quot;
git config --global user.email &quot;YOUR EMAIL@xxx.com&quot;
</code></pre>
<p>初始化git仓库<br>可以通过xftp上传项目文件夹到gitlab服务器，再到目录内初始化.git仓库。</p>
<pre><code>cd project_folder (项目文件夹)
git init
git remote add origin git@YOUR_IP:YOUR_NAME/project_folder.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
</code></pre>
<p>这样在网页上可看到gitlab有首次commit的文件，后续也可以顺利提交和下载。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">浅谈C的宏函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-16 15:07:37" itemprop="dateCreated datePublished" datetime="2020-04-16T15:07:37+08:00">2020-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 15:18:54" itemprop="dateModified" datetime="2022-12-06T15:18:54+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-连接操作符"><a href="#1-连接操作符" class="headerlink" title="1. 连接操作符:##"></a>1. 连接操作符:##</h1><pre><code>#define Conn(x,y) x##y
</code></pre>
<p><code>##</code> 表示连接 , <code>x##y</code> 表示x连接y</p>
<p>示例：</p>
<pre><code>int n = Conn(123,456);
     ==&gt; int n=123456;
char* str = Conn(&quot;asdf&quot;, &quot;adf&quot;);
     ==&gt; char* str = &quot;asdfadf&quot;;
</code></pre>
<p><code>##</code> 的左右符号必须能够组成一个有意义的符号，否则预处理器会报错</p>
<h1 id="2-字符串化和字符化"><a href="#2-字符串化和字符化" class="headerlink" title="2.字符串化和字符化: #, #@"></a>2.字符串化和字符化: #, #@</h1><p>(1) # 把任意类型的宏入参转化成字符串：</p>
<pre><code>#define ToString(x) #x
</code></pre>
<p>符号 # 表示字符串化操作符（stringification）。<br>其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。<br>其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</p>
<p>示例：</p>
<pre><code> char* str = ToString(123132);
 ==&gt; char* str=&quot;123132&quot;;
</code></pre>
<p>如果要对展开后的宏参数进行字符串化，则需要使用两层宏。</p>
<pre><code>#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
     ==&gt; &quot;foo&quot;
xstr (foo)
     ==&gt; xstr (4)
     ==&gt; str (4)
     ==&gt; &quot;4&quot;
</code></pre>
<p>(2) #@ 把任意类型的宏入参转化成单字符：</p>
<pre><code>#define ToChar(x) #@x
</code></pre>
<p>示例：</p>
<pre><code>char a = ToChar(1);
     ==&gt; char a=&#39;1&#39;
</code></pre>
<h1 id="3-不定参数宏-VA-ARGS"><a href="#3-不定参数宏-VA-ARGS" class="headerlink" title="3. 不定参数宏: __VA_ARGS__"></a>3. 不定参数宏: <code>__VA_ARGS__</code></h1><p><code>__VA_ARGS__</code>宏用来接受不定数量的参数。例如：</p>
<pre><code>#define eprintf(...) fprintf (stderr, __VA_ARGS__)

eprintf (&quot;%s:%d: &quot;, input_file, lineno)
==&gt;  fprintf (stderr, &quot;%s:%d: &quot;, input_file, lineno)
</code></pre>
<p>当<code>__VA_ARGS__</code>宏前面加 <code>##</code> 时，可以省略参数输入。<br>例如：</p>
<pre><code>#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

eprintf (&quot;success!\n&quot;)
==&gt; fprintf(stderr, &quot;success!\n&quot;);
</code></pre>
<h1 id="4-宏函数定义-do-while-0-与换行"><a href="#4-宏函数定义-do-while-0-与换行" class="headerlink" title="4. 宏函数定义: do-while(0)与换行"></a>4. 宏函数定义: do-while(0)与换行</h1><p>(1) 用 do{}while(0) 定义宏函数</p>
<pre><code>#define foo() do&#123;...&#125;while(0)
</code></pre>
<p>宏函数可能在任意地方被调用，如果在if-else语句中，为了确保宏函数作为整体单元被编译器替换后不产生歧义，一般用do-while(0)包起来定义<br>这种定义有点像其他语言的“闭包函数”，纯粹是C语言中为了避免语法歧义的可靠性定义。</p>
<p>(2) 用显式换行符</p>
<p>宏函数定义不能直接回车换行，需要在回车换行前，用\（反斜线）表示下一行继续此宏的定义<br>预处理器在编译之前会自动将\与换行回车去掉。</p>
<p>例如：</p>
<pre><code>#define PRINT_INT(a)    \
do&#123;                     \
    printf(&quot;%d \n&quot;, a); \
&#125;while(0)
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">浅谈C的函数指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 12:30:00" itemprop="dateCreated datePublished" datetime="2020-04-01T12:30:00+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 15:18:49" itemprop="dateModified" datetime="2022-12-06T15:18:49+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-函数指针基本概念"><a href="#1-函数指针基本概念" class="headerlink" title="1. 函数指针基本概念"></a>1. 函数指针基本概念</h2><p>C语言调用函数的本质是什么？</p>
<ol>
<li>CPU PC指针(program counter)跳转到函数的入口地址，传入参数，传入返回位置</li>
<li>在函数栈内生成临时变量并执行函数内容指令，执行完毕后返回参数</li>
<li>CPU返回原调用处执行</li>
</ol>
<p>这里，函数的入口地址实际上就存储在函数名中，也就是说，C代码中的函数名就是函数的入口地址。<br>既然是地址，就可以用来初始化一个指针，使指针指向该地址。<br>函数指针，就是存放函数首地址的指针。</p>
<h3 id="1-2-函数指针变量"><a href="#1-2-函数指针变量" class="headerlink" title="1.2 函数指针变量"></a>1.2 函数指针变量</h3><p>首先声明普通函数是如下格式：<br><code>void Func(int);</code><br>定义一个同类型函数的函数指针变量，只需要用<code>*p</code>表示函数名即可：<br><code>void (*p)(int);</code><br>注意，上面是定义了函数指针变量，而不是声明函数指针类型。</p>
<p>函数指针变量的定义，和普通变量格式不一样。</p>
<ul>
<li>普通变量： &lt;类型&gt; &lt;变量名&gt;</li>
<li>函数指针：&lt;函数类型 变量名&gt;，按函数声明的格式定义，变量是包含在类型内部</li>
</ul>
<p>那么此函数指针的类型是什么：<br><code>void (*)(int);</code></p>
<p>怎么使用此函数指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Func(int x) // 声明一个函数*/</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line">void (*p)(int); // 定义一个函数指针*/</span><br><span class="line">p = Func; // 将Func函数的首地址赋给函数指针变量p*/</span><br><span class="line">(*p)(100);  // 通过函数指针调用Func函数</span><br></pre></td></tr></table></figure>

<h3 id="1-3-函数指针类型"><a href="#1-3-函数指针类型" class="headerlink" title="1.3 函数指针类型"></a>1.3 函数指针类型</h3><p>typedef可以定义某种类型的别名，例如将unsigned char定义为u8<br><code>typedef unsigned char u8;</code><br>可见其格式是：typedef &lt;原类型&gt; &lt;别名类型&gt;</p>
<p>那么如何定义函数指针类型：<br>只需要在函数指针声明的格式前加typedef, p就定义为函数指针类型而不是变量:<br><code>typedef void (*p)(int);</code></p>
<p>这里定义了<code>void (*)(int)</code>类型的函数指针类型，其别名为p</p>
<p>怎么使用此函数指针类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义类型</span><br><span class="line">typedef void (*pFuncType)(int); </span><br><span class="line">//定义变量  </span><br><span class="line">pFuncType p;   </span><br><span class="line"></span><br><span class="line">void Func(int x)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%d&quot;,x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main()   </span><br><span class="line">&#123;   </span><br><span class="line">    p = Func; //初始化变量   </span><br><span class="line">    (*p)(100);   //使用变量</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-函数指针的应用"><a href="#2-函数指针的应用" class="headerlink" title="2. 函数指针的应用"></a>2. 函数指针的应用</h2><h3 id="2-1-Linux驱动软件设计的分层"><a href="#2-1-Linux驱动软件设计的分层" class="headerlink" title="2.1 Linux驱动软件设计的分层"></a>2.1 Linux驱动软件设计的分层</h3><p>C++中有多态的概念，父类定义某种函数类型，子类实现具体的函数内容，之后父类对象就可以调用子类的实现内容。<br>这样实现“父类定义格式，子类实现细节”的软件分层设计。</p>
<p>Linux驱动中也大量使用这种分层设计，C使用结构体和函数指针，分别对应C++的类和方法。<br>例如某驱动模块，顶层框架定义open, read, write, 而底层驱动根据具体硬件，实现xxx_open, xxx_read, xxx_write，然后按结构体成员赋值实现上下层联通：</p>
<p>以s3c的SDHCI驱动为例：<br>sdhci_ops即父类框架结构体，sdhci_s3c_ops为s3c芯片的具体实现结构体。<br><code>.set_clock = sdhci_s3c_set_clock</code>就实现了父类的set_clock方法被子类sdhci_s3c_set_clock实现的效果。<br>其本质是函数指针的赋值，父类和子类的函数名都指向同一个函数地址，所以父类可以通过调用set_clock来实现调用sdhci_s3c_set_clock的效果。<br>这样，父类设计者根本不关心底层用什么函数名实现set_clock的功能，只需要调用set_clock这个函数名即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct sdhci_ops sdhci_s3c_ops = &#123;</span><br><span class="line">	.get_max_clock		= sdhci_s3c_get_max_clk,</span><br><span class="line">	.set_clock		= sdhci_s3c_set_clock,</span><br><span class="line">	.get_min_clock		= sdhci_s3c_get_min_clock,</span><br><span class="line">	.set_bus_width		= sdhci_set_bus_width,</span><br><span class="line">	.reset			= sdhci_reset,</span><br><span class="line">	.set_uhs_signaling	= sdhci_set_uhs_signaling,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数指针实现指令跳转"><a href="#2-2-函数指针实现指令跳转" class="headerlink" title="2.2 函数指针实现指令跳转"></a>2.2 函数指针实现指令跳转</h3><p>调用一个函数，其内部就包含跳转操作(jump指令)<br>那么，如何用C语言实现跳转到某个绝对地址去执行？具体场景：<br>在Bootloader过程中，加载完kernel到RAM后，要跳转到kernel首地址开始执行，如何实现？</p>
<p>方案一：C嵌入汇编<br>以下是基于SPARC CPU的汇编，跳转到0x40000000, 即RAM首地址执行firmware.<br>对于其他CPU，汇编实现也不同，因此此方法不能跨平台。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void boot_exit()</span><br><span class="line">&#123;</span><br><span class="line">    /* jump to RAM entry to execute firmware. */</span><br><span class="line"></span><br><span class="line">    asm(</span><br><span class="line">        &quot;set 0x40000000, %g2\n&quot;</span><br><span class="line">        &quot;jmp %g2\n&quot;</span><br><span class="line">        &quot;nop&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：函数指针<br>Bootloader中很常用的一种跳转方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*pFuncType)(); //定义无入参无返回类型的函数指针类型</span><br><span class="line">pFuncType Reset = (pFuncType)0xF000FFF0; //函数指针指向待跳转地址</span><br><span class="line">Reset(); //调用函数，实际上执行了跳转</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/" class="post-title-link" itemprop="url">C++面向对象笔记：模板、泛型与STL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 16:53:38" itemprop="dateCreated datePublished" datetime="2020-03-21T16:53:38+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 16:55:43" itemprop="dateModified" datetime="2022-12-08T16:55:43+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++除了支持面向对象，也支持函数的扩展和重用。继承类和多态充分支持了扩展，即基类进行概括抽象的设计，派生类实现具体的设计。那么重用呢，如何写一个函数，能在多种情况不加修改的套用？<br>考虑以下问题：</p>
<pre><code>交换两个整型变量的值的Swap函数：
void Swap(int &amp; x,int &amp; y)
&#123;
    int tmp = x;
    x = y;
    y = tmp;
&#125;
交换两个double型变量的值的Swap函数:
void Swap(double &amp; x,double &amp; y)
&#123;
    double tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>这两个函数除了入参类型不同，函数名，参数个数，返回类型都相同。函数体的处理流程也完全一样。能否只写一个Swap，就能交换各种类型的变量？<br>模板（template）将解决这种问题。</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="函数模板的概念"><a href="#函数模板的概念" class="headerlink" title="函数模板的概念"></a>函数模板的概念</h2><p>用函数模板，设计仅数据类型不同的一组函数的通用模板：</p>
<pre><code>template &lt;class 类型参数1，class 类型参数2,……&gt;
返回值类型 模板名 (形参表)
&#123;
    函数体
&#125;;

template &lt;class T&gt; //在函数前声明模板，参数类型（class）是T
void Swap(T &amp; x,T &amp; y)
&#123;
    T tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>在普通函数前，先用template&lt; class T &gt;声明参数类型T，就可以在函数体使用T，就像使用普通变量一样。在运行时，T传入的类型不同，函数处理的数据类型也不同。<br>函数模板是如何实现的？它是一种函数吗？</p>
<pre><code>int main()
&#123;
    int n = 1,m = 2;
    Swap(n,m); //编译器自动生成 void Swap(int &amp; ,int &amp; )函数
    double f = 1.2,g = 2.3;
    Swap(f,g); //编译器自动生成 void Swap(double &amp; ,double &amp; )函数
    return 0;
&#125;
</code></pre>
<p>函数模板只是个模子，编译器通过模板和具体参数类型产生不同的函数。编译器会进行两次编译，第一次检测模板代码，第二次检测加参数后的具体函数代码。<br>在调用以上函数模板时，实际会生成两个具体函数：</p>
<pre><code>void Swap(int &amp; x,int &amp; y)
&#123;
    int tmp = x;
    x = y;
    y = tmp;
&#125;
void Swap(double &amp; x,double &amp; y)
&#123;
    double tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>函数模板，可以理解为一种函数的宏，编译期在宏被调用的地方，全部替换成宏所对应的具体值。<br>函数模板和运行时函数，也类似于类和对象的关系，类只是类型，对象是给类分配了内存的实例。函数模板只是通用的类型，函数实例是函数模板的实例化对象。</p>
<h2 id="函数模板的特性"><a href="#函数模板的特性" class="headerlink" title="函数模板的特性"></a>函数模板的特性</h2><p>函数模板中可以有不止一个类型参数</p>
<pre><code>template &lt;class T1, class T2&gt;
T2 print(T1 arg1, T2 arg2)
&#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
    return arg2;
&#125;
</code></pre>
<p>不通过参数也能实例化函数模板</p>
<pre><code>template &lt;class T&gt;
T Inc(T n)
&#123;
    return 1 + n;
&#125;
int main()
&#123;
    cout &lt;&lt; Inc&lt;double&gt;(4)/2; //显式实例化模板，输出 2.5
    return 0;
&#125;
</code></pre>
<h2 id="函数模板与重载"><a href="#函数模板与重载" class="headerlink" title="函数模板与重载"></a>函数模板与重载</h2><p>函数模板和函数重载，在写法上很接近，都是一组参数不同的同名函数。它们有什么联系和区别？</p>
<ul>
<li>函数重载，关键在参数个数</li>
<li>函数模板，关键在参数类型</li>
</ul>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<pre><code>template&lt;class T1, class T2&gt;
void print(T1 arg1, T2 arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
template&lt;class T&gt;
void print(T arg1, T arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
template&lt;class T,class T2&gt;
void print(T arg1, T arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
</code></pre>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一条函数调用语句:</p>
<ol>
<li><p>先找参数完全匹配的普通函数(非由模板实例化而得的函数)</p>
</li>
<li><p>再找参数完全匹配的模板函数。</p>
</li>
<li><p>再找实参数经过自动类型转换后能够匹配的普通函数。</p>
</li>
</ol>
<ol start="4">
<li><p>上面的都找不到，则报错<br>如果有函数重载，在第（1）步就找到，如果没有，才找（2）的函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"> T Max( T a, T b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> template &lt;class T,class T2&gt;</span><br><span class="line"> T Max( T a, T2 b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax2&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> double Max(double a, double b)&#123;</span><br><span class="line">     cout &lt;&lt; &quot;MyMax&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main() &#123;</span><br><span class="line">     int i=4, j=5;</span><br><span class="line">     Max( 1.2,3.4); // 输出MyMax</span><br><span class="line">     Max(i, j); //输出TemplateMax</span><br><span class="line">     Max( 1.2, 3); //输出TemplateMax2</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意上文的步骤（2）（3）是分开的，匹配模板函数时，是不进行类型自动转换的，不匹配就是不匹配。输入参数有二义性时。编译器不会为开发者做决定</p>
<pre><code>template&lt;class T&gt;
T myFunction( T arg1, T arg2)
&#123; cout&lt;&lt;arg1&lt;&lt;&quot; &quot;&lt;&lt;arg2&lt;&lt;&quot;\n&quot;; return arg1;&#125;
……
myFunction( 5, 7); //ok： replace T with int
myFunction( 5.8, 8.4); //ok： replace T with double
myFunction( 5, 8.4); //error， no matching function for call to &#39;myFunction(int, double)&#39;
</code></pre>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="类模板的概念"><a href="#类模板的概念" class="headerlink" title="类模板的概念"></a>类模板的概念</h2><p>类也能使用模板，来生成不同成员类型的类<br>类模板：在定义类的时候，加上一个&#x2F;多个类型参数。在使用类模板时，指定类型参数应该如何替换成具体类型，编译器据此生成相应的模板类</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
class 类模板名
&#123;
    成员函数和成员变量
&#125;;
</code></pre>
<p>类模板的成员函数的定义写法：</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名（ 参数表）
&#123;
    ……
&#125;
</code></pre>
<p>用类模板实例化对象的写法：</p>
<pre><code>类模板名 &lt;真实类型参数表&gt; 对象名(构造函数实参表);
</code></pre>
<p>一个例子：map类型中的pair类的实现：</p>
<pre><code>template &lt;class T1,class T2&gt;    //pair是类模板
class Pair
&#123;
public:
    T1 key; //关键字
    T2 value; //值
    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;; //构造函数
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const; //运算符重载函数
&#125;;

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
//Pair的运算符重载函数的定义
&#123;
    return key &lt; p.key;
&#125;

 int main()
&#123;
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,19); //实例化出一个类 Pair&lt;string,int&gt;
    cout &lt;&lt; student.key &lt;&lt; &quot; &quot; &lt;&lt; student.value;
    return 0;
&#125;
</code></pre>
<p>输出：Tom 19<br>编译器由类模板生成类的过程叫类模板的实例化。 由类模板实例化得到的类， 叫模板类<br>同一个类模板的两个模板类是不兼容的，即两个不同的类</p>
<pre><code>Pair&lt;string,int&gt; * p;
Pair&lt;string,double&gt; a;
p = &amp; a; //错误，不是同类也不是继承类，不能赋值
</code></pre>
<p>函数模版可以作为类模板成员</p>
<pre><code>template &lt;class T&gt;
class A
&#123;
public:
    template&lt;class T2&gt;
    void Func( T2 t) &#123; cout &lt;&lt; t; &#125; //成员函数模板
&#125;;
int main()
&#123;
    A&lt;int&gt; a;
    a.Func(&#39;K&#39;); //成员函数模板 Func被实例化
    a.Func(&quot;hello&quot;); //成员函数模板 Func再次被实例化
    return 0;
&#125; //输出： KHello
</code></pre>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数：</p>
<pre><code>template &lt;class T, int size&gt;
class CArray&#123;
    T array[size];
    public:
    void Print( )
    &#123;
        for( int i = 0;i &lt; size; ++i)
        cout &lt;&lt; array[i] &lt;&lt; endl;
    &#125;
&#125;;

CArray&lt;double,40&gt; a2;
CArray&lt;int,50&gt; a3;
</code></pre>
<h2 id="类模板的派生"><a href="#类模板的派生" class="headerlink" title="类模板的派生"></a>类模板的派生</h2><p>类模板也支持类的派生：<br>• 类模板从类模板派生<br>• 类模板从模板类派生<br>• 类模板从普通类派生<br>• 普通类从模板类派生</p>
<p>(1)类模板从类模板派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A &#123;
    T1 v1; T2 v2;
&#125;;

template &lt;class T1,class T2&gt;
class B:public A&lt;T2,T1&gt; &#123;
    T1 v3; T2 v4;
&#125;;

template &lt;class T&gt;
class C:public B&lt;T,T&gt; &#123;
    T v5;
&#125;;

int main() &#123;
    B&lt;int,double&gt; obj1;
    C&lt;int&gt; obj2;
    return 0;
&#125;
</code></pre>
<p>(2)类模板从模板类派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A &#123;
    T1 v1; T2 v2;
&#125;;

template &lt;class T&gt;
class B:public A&lt;int,double&gt; &#123;
    T v;
&#125;;

int main() &#123;
    B&lt;char&gt; obj1; //自动生成两个模板类：A&lt;int,double&gt; 和 B&lt;char&gt;
    return 0;
&#125;
</code></pre>
<p>(3)类模板从普通类派生</p>
<pre><code>class A &#123;
    int v1;
&#125;;

template &lt;class T&gt;
class B:public A &#123; //所有从B实例化得到的类， 都以A为基类
    T v;
&#125;;

int main() &#123;
    B&lt;char&gt; obj1;
    return 0;
&#125;
</code></pre>
<p>(4)普通类从模板类派生</p>
<pre><code>template &lt;class T&gt;
class A &#123;
    T v1;
    int n;
&#125;;

class B:public A&lt;int&gt; &#123;
    double v;
&#125;;
int main() &#123;
    B obj1;
    return 0;
&#125;
</code></pre>
<h2 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h2><p>• 函数、类、类的成员函数作为类模板的友元<br>• 函数模板作为类模板的友元<br>• 函数模板作为类的友元<br>• 类模板作为类模板的友元</p>
<p>(1)函数、类、类的成员函数作为类模板的友元</p>
<pre><code>void Func1() &#123; &#125;
class A &#123; &#125;;
class B
&#123;
    public:
    void Func() &#123; &#125;
&#125;;

template &lt;class T&gt;
class Tmpl
&#123;
    friend void Func1();
    friend class A;
    friend void B::Func();
&#125;; //任何从Tmp1实例化来的类， 都有以上三个友元
</code></pre>
<p>(2)函数模板作为类模板的友元</p>
<pre><code>template &lt;class T1,class T2&gt;
class Pair
&#123;
private:
    T1 key; //关键字
    T2 value; //值
public:
    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;;
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const;
    template &lt;class T3,class T4&gt;
    friend ostream &amp; operator&lt;&lt; ( ostream &amp; o,
    const Pair&lt;T3,T4&gt; &amp; p);
&#125;;

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
&#123; //&quot;小&quot;的意思就是关键字小
    return key &lt; p.key;
&#125;
template &lt;class T1,class T2&gt;
ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)
&#123;
    o &lt;&lt; &quot;(&quot; &lt;&lt; p.key &lt;&lt; &quot;,&quot; &lt;&lt; p.value &lt;&lt; &quot;)&quot; ;
    return o;
&#125;

int main()
&#123;
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,29);
    Pair&lt;int,double&gt; obj(12,3.14);
    cout &lt;&lt; student &lt;&lt; &quot; &quot; &lt;&lt; obj;
    return 0;
&#125;

输出：
(Tom,29) (12,3.14)
</code></pre>
<p>任意从 <code>template &lt;class T1,class T2&gt; ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)</code>生成的函数，都是任意Pair摸板类的友元</p>
<p>(3)函数模板作为类的友元</p>
<pre><code>class A
&#123;
    int v;
    public:
    A(int n):v(n) &#123; &#125;
    template &lt;class T&gt;
    friend void Print(const T &amp; p);
&#125;;
template &lt;class T&gt;
void Print(const T &amp; p)
&#123;
    cout &lt;&lt; p.v;
&#125;

int main() &#123;
    A a(4);
    Print(a);
    return 0;
&#125;

输出：
4
</code></pre>
<p>所有从 <code>template &lt;class T&gt; void Print(const T &amp; p)</code><br>生成的函数，都成为 A 的友元</p>
<p>(4)类模板作为类模板的友元</p>
<pre><code>template &lt;class T&gt;
class B &#123;
    T v;
    public:
    B(T n):v(n) &#123; &#125;
    template &lt;class T2&gt;
    friend class A;
&#125;;

template &lt;class T&gt;
class A &#123;
public:
    void Func( ) &#123;
        B&lt;int&gt; o(10);
        cout &lt;&lt; o.v &lt;&lt; endl;
    &#125;
&#125;;

int main()
&#123;
    A&lt; double &gt; a;
    a.Func ();
    return 0;
&#125;

输出：
10
</code></pre>
<p>A&lt; double&gt;类，成了B<int>类的友元。任何从A模版实例化出来的类，都是任何B实例化出来的类的友元</p>
<h2 id="类模板与静态成员"><a href="#类模板与静态成员" class="headerlink" title="类模板与静态成员"></a>类模板与静态成员</h2><p>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员</p>
<pre><code>template &lt;class T&gt;
class A
&#123;
private:
    static int count;
    public:
    A() &#123; count ++; &#125;
    ~A() &#123; count -- ; &#125;;
    A( A &amp; ) &#123; count ++ ; &#125;
    static void PrintCount() &#123; cout &lt;&lt; count &lt;&lt; endl; &#125;
&#125;;

template&lt;&gt; int A&lt;int&gt;::count = 0;
template&lt;&gt; int A&lt;double&gt;::count = 0;
int main()
&#123;
    A&lt;int&gt; ia;
    A&lt;double&gt; da;
    ia.PrintCount();
    da.PrintCount();
    return 0;
&#125;

输出：
1 1
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
