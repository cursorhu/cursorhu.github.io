<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/my_icon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/my_icon/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/my_icon/manifest.json">
  <meta name="msapplication-config" content="/images/my_icon/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/6/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy | 化繁为简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/07/24/windows-coredump%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/24/windows-coredump%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">windows coredump的配置和测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-24 15:42:43" itemprop="dateCreated datePublished" datetime="2023-07-24T15:42:43+08:00">2023-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows/" itemprop="url" rel="index"><span itemprop="name">windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在存储设备的windows系统环境下调试时，因为存储设备本身的问题，有时候coredump不能成功生成到系统目录，本文记录如何修改coredump路径，以及用键盘测试coredump生成符合预期。</p>
<h2 id="使能windows的coredump"><a href="#使能windows的coredump" class="headerlink" title="使能windows的coredump"></a>使能windows的coredump</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/debugger/enabling-a-kernel-mode-dump-file">Enabling a Kernel-Mode Dump File</a></p>
<h2 id="修改coredump路径"><a href="#修改coredump路径" class="headerlink" title="修改coredump路径"></a>修改coredump路径</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/troubleshoot/windows-server/performance/memory-dump-file-options">Windows 的内存转储文件选项概述</a></p>
<p>可以修改注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\CrashControl</code>的DumpFile键值对，默认路径%SystemRoot%在cmd echo出来是”C:&quot;, 修改为指定路径例如”E:\Memory.dmp”。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241555783.png" alt="image-20230724155525547"></p>
<p>此操作也可以在控制面板完成，两者等效。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241555568.PNG" alt="crashcontrol2"></p>
<h2 id="使用键盘手动生成coredump"><a href="#使用键盘手动生成coredump" class="headerlink" title="使用键盘手动生成coredump"></a>使用键盘手动生成coredump</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/debugger/forcing-a-system-crash-from-the-keyboard">Forcing a system crash from the keyboard</a></p>
<p>以USB keyboards为例：</p>
<p>修改注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\kbdhid\Parameters</code>，创建CrashOnCtrlScroll &#x3D; 0x01，重启后“Hold down the rightmost CTRL key, and press the SCROLL LOCK key twice.”系统会直接蓝屏，重启即可查看coredump文件。如果用windbg查看KeBugCheck查看错误码是0xE2: MANUALLY_INITIATED_CRASH。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307241554830.png" alt="image-20230724155442525"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/07/12/Arch%20Linux%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/12/Arch%20Linux%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Arch Linux安装和配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-12 15:50:54" itemprop="dateCreated datePublished" datetime="2023-07-12T15:50:54+08:00">2023-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近Debian12发布，尝鲜在移动硬盘装了Debian12+KDE，但不习惯Debian繁琐的包管理和Ubuntu越来越商业化的行为，最终切换到ArchLinux，进入Pacman和AUR的包管理和滚动更新风格。此文记录ArchLinux安装配置过程。</p>
<h2 id="构建多系统的U盘启动盘"><a href="#构建多系统的U盘启动盘" class="headerlink" title="构建多系统的U盘启动盘"></a>构建多系统的U盘启动盘</h2><p>使用<a target="_blank" rel="noopener" href="https://www.ventoy.net/en/doc_start.html">ventoy&#x2F;Start to use Ventoy</a>，将各系统镜像放到Ventoy目录即可，不需要用传统的UltraISO那种一个系统ISO要占用整个U盘。<br>Arch Linux的ISO<a target="_blank" rel="noopener" href="https://archlinux.org/download/">在此下载</a></p>
<h2 id="使用archinstall安装ArchLinux"><a href="#使用archinstall安装ArchLinux" class="headerlink" title="使用archinstall安装ArchLinux"></a>使用archinstall安装ArchLinux</h2><p><a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Installation_guide">传统的ArchLinux安装方式</a>过于繁琐，现在Arch Linux安装包提供一个类GUI的脚本<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Archinstall">archinstall</a>，按需求配置即可，可以一键处理包括KDE&#x2F;GNOME&#x2F;I3W等桌面在内的全部安装过程。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.linuxmi.com/archinstall-auto-arch-linux.html">使用 archinstall 自动化脚本安装 Arch Linux 完整指南</a>，<a target="_blank" rel="noopener" href="https://u.sb/archlinux-archinstall/">使用 archinstall 安装 Arch Linux 和 KDE 桌面环境</a>。</p>
<p>我的配置如下。Profile选择安装desktop Kde, Network选择Use NetworkManager后，Kde Plasma被自动安装，不需要按参考文章手动安装桌面：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202307121642425.png" alt="image-20230712164243209"></p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>kde主题应用直接安装主题基本会失败，需要去<a target="_blank" rel="noopener" href="https://store.kde.org/browse/">KDE store</a>下载主题并按主题的README配置</p>
<p>一个风格统一的主题包含几个部分：Global theme，包括桌面(desktop)，图标(icon)，鼠标(cursor)，壁纸(wallpaper)，也可以包含登录界面(sddm)和启动界面(GRUB)</p>
<p>(1)配置桌面</p>
<p>下面配置MacOS风格的 <a target="_blank" rel="noopener" href="https://store.kde.org/p/1400424/">WhiteSur Dark</a>，建议在Github下载完整主题:<a target="_blank" rel="noopener" href="https://github.com/vinceliuice/WhiteSur-kde">WhiteSur-kde</a></p>
<p>使用<code>./install.sh</code>安装主题，其内部操作就是拷贝各部分配置文件到系统配置目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp -r $&#123;SRC_DIR&#125;/aurorae/normal/$&#123;name&#125;$&#123;color&#125;* $&#123;AURORAE_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/Kvantum/$&#123;name&#125; $&#123;KVANTUM_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/wallpaper/$&#123;name&#125;* $&#123;WALLPAPER_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/latte-dock/* $&#123;LATTE_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/color-schemes/* $&#123;SCHEMES_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/plasma/desktoptheme/$&#123;name&#125;$&#123;pcolor&#125; $&#123;PLASMA_DIR&#125;</span><br><span class="line">cp -r $&#123;SRC_DIR&#125;/plasma/desktoptheme/icons $&#123;PLASMA_DIR&#125;/$&#123;name&#125;$&#123;pcolor&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中的latte-dock只是配置文件，需要先安装latte-dock</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S latte-dock</span><br></pre></td></tr></table></figure>

<p>主题安装完毕后，在系统System Setting -&gt; Appearance -&gt; Global Theme的子目录apply各模块</p>
<p>(2)配置登录界面</p>
<p>登录界面SDDM需要独立安装，在WhiteSur-kde的sddm目录运行<code>install.sh</code>安装sddm，之后可在系统System Setting -&gt; Startup and Shutdown中设置sddm为WhiteSur。</p>
<p>(3)配置启动界面</p>
<p>Arch linux默认没有GRUB，需要<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/GRUB">安装GRUB</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S grub efibootmgr</span><br><span class="line">sudo grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br></pre></td></tr></table></figure>

<p>以 <a target="_blank" rel="noopener" href="https://store.kde.org/p/1603282">Dark Matter GRUB Theme</a>为例，按github的install guide安装即可。</p>
<p>GRUB配置文件位于&#x2F;etc&#x2F;default&#x2F;grub，修改后使用update-grub生效。</p>
<h2 id="中文显示和中文输入法"><a href="#中文显示和中文输入法" class="headerlink" title="中文显示和中文输入法"></a>中文显示和中文输入法</h2><p>打开网页有中文乱码（方框），需要安装noto-fonts相关字体包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br></pre></td></tr></table></figure>

<p>安装中文输入法框架（包含pinyin输入法）并配置fcitx5，具体含义参考 <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Input_method">Input method</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im fcitx5-chinese-addons  fcitx5-rime</span><br></pre></td></tr></table></figure>
<p>在desktop environment配置fcitx:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/environment</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>

<p>重启，按 <code>Win</code> 键搜索 <code>Input Method</code>, 点击 <code>Add Input Method...</code>搜索 <code>pinyin</code> 然后添加，按 <code>Ctrl</code> + <code>空格</code>可切换输入法</p>
<h2 id="安装yay以使用AUR"><a href="#安装yay以使用AUR" class="headerlink" title="安装yay以使用AUR"></a>安装yay以使用AUR</h2><p><a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/yay">yay</a>: Yet another yogurt. Pacman wrapper and AUR helper written in go.</p>
<p>yay的安装参考: <a target="_blank" rel="noopener" href="https://www.debugpoint.com/install-yay-arch/">How to Install yay AUR Helper in Arch Linux [Beginner’s Guide]</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S base-devel git</span><br><span class="line">cd /opt</span><br><span class="line">sudo git clone https://aur.archlinux.org/yay.git</span><br><span class="line">cd yay</span><br><span class="line">sudo chown -R 用户名:users .   #必须修改yay目录的owner, yay不能被sudo编译</span><br><span class="line">makepkg -si  #编译yay</span><br></pre></td></tr></table></figure>

<h2 id="Go语言包换源"><a href="#Go语言包换源" class="headerlink" title="Go语言包换源"></a>Go语言包换源</h2><p>安装yay时makepkg会显示go包安装timeout, 需要换国内源 <a target="_blank" rel="noopener" href="https://goproxy.cn/">goprixy.cn</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#临时生效</span><br><span class="line">$ export GO111MODULE=on</span><br><span class="line">$ export GOPROXY=https://goproxy.cn</span><br><span class="line"></span><br><span class="line">#永久生效</span><br><span class="line">$ echo &quot;export GO111MODULE=on&quot; &gt;&gt; ~/.profile</span><br><span class="line">$ echo &quot;export GOPROXY=https://goproxy.cn&quot; &gt;&gt; ~/.profile</span><br><span class="line">$ source ~/.profile</span><br></pre></td></tr></table></figure>

<h2 id="pacman-yay换源"><a href="#pacman-yay换源" class="headerlink" title="pacman&#x2F;yay换源"></a>pacman&#x2F;yay换源</h2><p>在archinstall时如果Mirror region选择China，则默认使用官方提供的China源，见&#x2F;etc&#x2F;pacman.conf的[core&#x2F;extra]字段都版本了&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist. </p>
<p>但官方源速度有时很慢，建议手动添加<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/archlinuxcn/">archlinuxcn源</a>，如果包在国内源有的话，yay速度直接起飞</p>
<p>有网上建议生成aur配置文件换国内源：<code>yay --aururl “https://aur.tuna.tsinghua.edu.cn” --save</code> 此处不建议，如果国内源没有的包将无法下载；换回官方源：<code>yay --aururl &quot;https://aur.archlinux.org&quot; --save</code>，并删除yay源配置文件<code>~/.config/yay/config.json</code></p>
<h2 id="yay常用命令"><a href="#yay常用命令" class="headerlink" title="yay常用命令"></a>yay常用命令</h2><p>从仓库和 AUR 中交互式搜索和安装软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay &#123;&#123;软件包|搜索词&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>同步并更新所有来自仓库和 AUR 的软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay</span><br></pre></td></tr></table></figure>

<p>从仓库和 AUR 中安装一个新的软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S &#123;&#123;软件包&#125;&#125;</span><br><span class="line">yay -Sy &#123;&#123;软件包&#125;&#125; #默认yes</span><br></pre></td></tr></table></figure>

<p>从仓库和 AUR 中搜索软件包数据库中的关键词：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Ss &#123;&#123;关键词&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>显示已安装软件包和系统健康状况的统计数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Ps</span><br></pre></td></tr></table></figure>
<p>卸载包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -R </span><br></pre></td></tr></table></figure>

<h2 id="pacman更新系统"><a href="#pacman更新系统" class="headerlink" title="pacman更新系统"></a>pacman更新系统</h2><p>更新所有安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu #仅更新</span><br><span class="line">sudo pacman -Syyu #如果系统有损坏包，能覆盖下载</span><br></pre></td></tr></table></figure>

<h2 id="Host-DNS设置"><a href="#Host-DNS设置" class="headerlink" title="Host DNS设置"></a>Host DNS设置</h2><p>NetworkManager会自动配置DNS域名解析文件&#x2F;etc&#x2F;resolv.conf，且手动修改的内容每次重启会被NetworkManager覆盖。</p>
<p>如果要手动配置，参考 <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/NetworkManager">&#x2F;etc&#x2F;resolv.conf</a>，设置dns.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/NetworkManager/conf.d/dns.conf</span><br><span class="line">[main]</span><br><span class="line">dns=none</span><br></pre></td></tr></table></figure>

<h2 id="KDE-Discover显示unable-to-load-applications"><a href="#KDE-Discover显示unable-to-load-applications" class="headerlink" title="KDE Discover显示unable to load applications"></a>KDE Discover显示unable to load applications</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S packagekit-qt5</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/29/VSCode+Clangd%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BBLinux-Kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/29/VSCode+Clangd%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BBLinux-Kernel/" class="post-title-link" itemprop="url">VSCode+Clangd高效阅读Linux Kernel.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-29 11:59:26" itemprop="dateCreated datePublished" datetime="2023-05-29T11:59:26+08:00">2023-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>安装kernel编译环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>

<p>安装bear</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bear</span><br></pre></td></tr></table></figure>

<p>使用bear编译kernel，生成compile_commands.json，参考：<a target="_blank" rel="noopener" href="https://forums.100ask.net/t/topic/1656/2">Ubuntu22 直接 make 内核成功，但不能使用 bear 命令</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bear -- make -j4</span><br></pre></td></tr></table></figure>

<p>在编译Kernel的源代码环境安装clangd服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clangd</span><br></pre></td></tr></table></figure>

<p>在查看代码的VSCode环境安装clangd客户端(即VSCode的clangd插件)：一般通过windows机器的VSCode SSH连接Linux的clangd服务，因此需要将VSCode的remote SSH登陆到Linux机器（注意不要同时使用Xshell等其他SSH工具，否则VSCode remote SSH连不上）</p>
<p>VSCode remote SSH中打开代码后，clangd自动indexing(完成Kernel index需要相当长时间)，CTRL+鼠标左键查看定义，ALT+左键头返回跳转</p>
<p>clangd方式可以很方便找到C函数指针的实现，而VSCode的C++ intellisense跳转不到</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/558286384">使用VSCode进行linux内核代码阅读和开发</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/17/xv6-annotated-xv6%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/17/xv6-annotated-xv6%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/" class="post-title-link" itemprop="url">xv6-annotated:xv6完全注释</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-17 10:34:55" itemprop="dateCreated datePublished" datetime="2023-05-17T10:34:55+08:00">2023-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xv6/" itemprop="url" rel="index"><span itemprop="name">xv6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>xv6是mit6.828操作系统课程的基于unix v6重新实现的教学操作系统。</p>
<p>本文英文部分是x86版本的xv6(mit6.828 2018及以前的版本)完全注释，github：<a target="_blank" rel="noopener" href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p>本文中文部分是我学习xv6过程中添加了部分中文注解</p>
<h1 id="DAS-BOOT"><a href="#DAS-BOOT" class="headerlink" title="DAS BOOT"></a>DAS BOOT</h1><p>First things first: in order for a computer to run xv6, we need to load it from<br>disk into memory and tell the processor to start running it. So how does this<br>all happen?</p>
<h2 id="The-Boot-Process"><a href="#The-Boot-Process" class="headerlink" title="The Boot Process"></a>The Boot Process</h2><p>When you press the power button, the hardware gets initialized by a piece of<br>firmware called the BIOS (Basic Input&#x2F;Output System) that comes pre-installed on<br>the motherboard on a ROM chip. Nowadays, your computer probably uses UEFI loaded<br>from flash memory, but xv6 pretends like it’s 1995 and sticks with BIOS. Since<br>xv6 runs on x86 hardware, we’re gonna have to satisfy all the janky requirements<br>that come with that architecture, in addition to the BIOS’s requirements.</p>
<p>Now the BIOS has to load some <em>other</em> code called the boot loader from disk;<br>then it’s the boot loader’s job to load the OS and get it running. The boot<br>loader has to act as a middle-man because the BIOS has no idea where on the disk<br>you decided to put the OS.</p>
<p>The BIOS will look for the boot loader in the very first sector (512 bytes) of<br>whatever mass storage device you told it to boot from, which we’ll call the boot<br>disk. The processor will execute the instructions it finds there. This means<br>you have to make a choice: either your boot loader has to be less than 512 bytes<br>or you can split it up into smaller parts and have each part load the next one.<br>xv6 takes the first approach.</p>
<p>The BIOS loads the boot loader into memory at address 0x7C00, then sets the<br>processor’s <code>%ip</code> register to that address and jumps to it. Remember that <code>%eip</code><br>is the instruction pointer on x86? Okay cool. But why did I write <code>%ip</code> instead<br>of <code>%eip</code>? Well, the BIOS assumes we’re gonna be using 16 bits because of the<br>hellscape known as backwards-compatibility, so we’ve gotta pretend like it’s<br>1975 before we can pretend it’s 1995. The irony here is that this initial 16-bit<br>mode is called “real mode”. So on top of loading the OS, the boot loader will<br>also have to shepherd the processor from real mode to 32-bit “protected mode”.</p>
<p>One last detail: we’ll look at the Makefile and linker script later on, but for<br>now just keep in mind that the boot loader will be compiled separately from the<br>kernel, which will be compiled separately from all the user-space programs. This<br>makes it easier to make sure that the entire boot loader will fit in the first<br>512 bytes on disk. Eventually, the boot loader and the kernel will be stored on<br>the same boot disk together, and the user-space programs will be on a separate<br>disk that holds the file system.</p>
<h2 id="bootasm-S"><a href="#bootasm-S" class="headerlink" title="bootasm.S"></a>bootasm.S</h2><p>Boot loader space is tight, and we want to make sure our instructions are exact,<br>so we’re gonna start off in assembly. The “.S” file extension means it’s gonna<br>be assembled by the GNU assembler <code>as</code>, and we’re allowed to use C preprocessor<br>directives like <code>#include</code> or <code>#define</code> or whatever in the assembly code. Also,<br>xv6 uses AT&amp;T syntax, so if you read CS:APP or took the online course then it’ll<br>be familiar; if you don’t know what that means, then don’t worry about it.</p>
<h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>First we include some header files to use some constants; I’ll point them out<br>later. Next up, we gotta tell the assembler to generate 16-bit code, and set a<br>global label to tell the BIOS where to start executing code.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.code16         # Tell compiler to generate 16-bit code</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br></pre></td></tr></table></figure>

<p>Next up: you know how sometimes you can press a special key to tell the BIOS to<br>stop what it’s doing and let you pick a disk to boot from? Or you move your<br>mouse around in the BIOS menu and you see the pointer moving? Yeah, that needs<br>hardware interrupts in order to work, but right now, we don’t have the faintest<br>clue how to handle those if they happen, so let’s go ahead and turn those off.<br>There’s an x86 instruction to disable them by clearing the interrupt flag in<br>the CPU’s flags register.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli</span><br></pre></td></tr></table></figure>

<p>Now we’ve gotta handle some of x86’s quirks. First off, we’re gonna need 20-bit<br>memory addresses, but we only have 16 bits to work with. x86 uses six segment<br>registers <code>%cs</code> (code segment), <code>%ds</code> (data segment), <code>%ss</code> (stack segment),<br><code>%es</code> (extra segment), <code>%fs</code> and <code>%gs</code> (general-purpose segments) to create 20-<br>bit addresses from 16-bit ones; we’re gonna need the first four. The BIOS<br>guarantees that <code>%cs</code> will be set to zero, but it doesn’t make any promises<br>about the others, so we have to clear them ourselves. We’re not using <code>%eax</code> for<br>anything yet, so we’ll use that to clear the others. The <code>w</code> at the end of <code>xorw</code><br>and <code>movw</code> means we’re operating on 16-bit words.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xorw    %ax,%ax</span><br><span class="line">movw    %ax,%ds     # Data segment</span><br><span class="line">movw    %ax,%es     # Extra segment</span><br><span class="line">movw    %ax,%ss     # Stack segment</span><br></pre></td></tr></table></figure>

<p>This next part is a total hack for backwards-compatibility: sometimes a virtual<br>address might get converted to a 21-bit physical address, and oh no, what are we<br>gonna do? Well, some hardware can’t deal with 21 bits, so it just ignores it,<br>but it’s 1995, so we’ve got fancy hardware that can use that extra bit. Wow, you<br>really know we’re in the future when you’ve got a whole 2 MB of RAM to work<br>with! So we have to tell the processor not to throw away that 21st bit. The way<br>we do that is by setting the second bit of the keyboard controller’s output port<br>to line high. I don’t know. Don’t ask me why. The output ports are 0x64 and<br>0x60, so we’re gonna wait until they’re not busy, then set the magic values that<br>will make this all work.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb     $0x64,%al   # Wait for not busy</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.1</span><br><span class="line"></span><br><span class="line">    movb    $0xd1,%al   # 0xD1 -&gt; port 0x64</span><br><span class="line">    outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb     $0x64,%al   # Wait for not busy</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.2</span><br><span class="line"></span><br><span class="line">    movb    $0xdf,%al   # 0xDF -&gt; port 0x60</span><br><span class="line">    outb    %al,$0x60</span><br></pre></td></tr></table></figure>

<h3 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h3><p>Now it’s time to switch to 32-bit “protected mode”. Up until now, the processor<br>has been converting virtual addresses to physical ones using those segment<br>registers which we cleared, so the mapping has been an identity map. But let’s<br>talk about how x86 converts 32-bit virtual addresses to physical ones; this is<br>important for the rest of the boot loader code as well as the OS, so you’re<br>gonna have to bear with me for this maelstrom of x86-specific details.</p>
<p>The x86 architecture does the conversion in two steps: first segmentation, then<br>paging. A virtual address starts off life as a <em>logical address</em>. Segmentation<br>converts that to a <em>linear address</em>, and paging converts that to a physical one.</p>
<p>A logical address consists of a 20-bit <em>segment selector</em> and a 12-bit offset,<br>with the segment bits before the offset bits, like <code>segment:offset</code>. The CPU’s<br>segmentation hardware uses those segment bits to pick one of those four segment<br>registers we cleared earlier, which acts as an index into a <em>Global Descriptor<br>Table</em> or GDT. Each entry of this GDT tells you where that segment is found in<br>memory using a base physical address and a virtual address for the maximum or<br>limit.</p>
<p>The GDT entry also has some permission bits for that segment; the segmentation<br>hardware will check whether each address can be written to and whether the<br>process generating the virtual address has the right permissions to access it.<br>These checks compare the GDT entry’s <em>Descriptor Privilege Levels</em>, also known<br>as <em>ring levels</em>, against the <em>Current Privilege Level</em>. x86 has four privilege<br>levels (0-3), so if you’ve ever heard of the kernel operating in ring 0 or user<br>code in ring 3, this is where it comes from.</p>
<p>Okay, so the GDT entry will give us the first 20 bits of the new linear address;<br>the offset bits stay the same. After that, the linear address is ready to be<br>converted to a physical address by the paging hardware. We’ll go over this<br>second half of the story in the virtual memory section. For now, the point is<br>this: xv6 is mostly gonna say no thank you to segmentation and stick to paging<br>alone for memory virtualization.</p>
<p>So we’re gonna set up our GDT to map all segments the exact same way: with a<br>base of zero and the maximum possible limit (with 32 bits, that works out to a<br>grand total of 4 GB, wow so much RAM, I can’t imagine ever needing more). We<br>have to stick this GDT somewhere in our code so we can point the CPU to it, so<br>we’ll put it at the end and throw a <code>gdtdesc</code> label on it. Now we can tell the<br>CPU to load it up with a special x86 instruction for that.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt    gdtdesc</span><br></pre></td></tr></table></figure>

<h3 id="Protected-Mode"><a href="#Protected-Mode" class="headerlink" title="Protected Mode"></a>Protected Mode</h3><p>Good news, everyone! We’re finally ready to turn on protected mode, which we do<br>by setting the zero bit of the <code>%cr0</code> control register. Note that the <code>l</code> at the<br>end of the instructions here means we’re now using long words, i.e. 32 bits;<br><code>CR0_PE</code> is defined in the <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a><br>header file as 0x1.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    %cr0, %eax      # Copy %cr0 into %eax</span><br><span class="line">orl     $CR0_PE, %eax   # Set bit 0</span><br><span class="line">movl    %ax, %cr0       # Copy it back</span><br></pre></td></tr></table></figure>

<p>Oh wait, I lied. Enabling protection mode like we just did doesn’t change how<br>the processor translates addresses. We have to load a new value into a segment<br>register to make the CPU read the GDT and change its internal segmentation<br>settings. We can do that by using a long jump instruction, which lets us specify<br>a code segment selector. We’re just gonna jump to the very next line anyway, but<br>in doing so we’ll force the CPU to start using the GDT, which describes a 32-bit<br>code segment, so <em>now</em> we’re finally in 32-bit mode! Here, <code>SEG_KCODE</code> is a<br>constant defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as segment 1, for <code>%cs</code>; we bitshift it left by 3.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ljmp    $(SEG_KCODE&lt;&lt;3), $start32</span><br></pre></td></tr></table></figure>

<p>First we signal the compiler to start generating 32-bit code. Then we initialize<br>the data, extra, and stack segment registers to point to the <code>SEG_KDATA</code> entry<br>of the GDT; that constant is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as the segment for the kernel<br>data and stack. We’re not required to set up <code>%fs</code> and <code>%gs</code>, so we’ll just zero<br>them.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.code 32    # Tell assembler to generate 32-bit code now</span><br><span class="line">start32:</span><br><span class="line">    movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector</span><br><span class="line">    movw    %ax, %ds    # Data segment</span><br><span class="line">    movw    %ax, %es    # Extra segment</span><br><span class="line">    movw    %ax, %ss    # Stack segment</span><br><span class="line">    movw    $0, %ax     # Zero the segments not ready for use</span><br><span class="line">    movw    %ax, %fs</span><br><span class="line">    movw    %ax, %gs</span><br></pre></td></tr></table></figure>

<h3 id="The-Kernel-Stack"><a href="#The-Kernel-Stack" class="headerlink" title="The Kernel Stack"></a>The Kernel Stack</h3><p>Okay, last step in the assembly code now: we have to set up a stack in an unused<br>part of memory. In x86, the stack grows downwards, so the “top” of the stack–<br>that is, the most-recently-added byte–is actually at the bottom of the stack in<br>physical memory. It’s annoying, but we’re gonna have to keep track of that. The<br><code>%ebp</code> register points to the base of the stack (i.e., the first byte we pushed<br>onto the stack), and the <code>%esp</code> register holds the address of the top of the<br>stack (most-recently-pushed byte).</p>
<p>But where should we put the stack? The memory from 0xA_0000 to 0x10_0000 is<br>littered with a memory regions that I&#x2F;O devices are gonna be checking, so that’s<br>out. The boot loader starts at 0x7C00 and takes up 512 bytes, so that means it<br>ends at 0x7E00. So xv6 is gonna start the stack at 0x7C00 and have it grow down<br>from there, toward 0x0000 and away from the boot loader. Remember how back in<br>the beginning, we started off the assembly code with a <code>start</code> label? That means<br>that <code>start</code> is conveniently located at 0x7C00.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    $start, %esp</span><br></pre></td></tr></table></figure>

<p>And we’re done with assembly! Time to move on to C code for the rest of the boot<br>loader. We’ll take over with a C function called <code>bootmain()</code>, which should<br>never return. The linker will take care of connecting the call here to its<br>definition in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">bootmain.c</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    bootmain</span><br></pre></td></tr></table></figure>

<h3 id="Handling-Errors"><a href="#Handling-Errors" class="headerlink" title="Handling Errors"></a>Handling Errors</h3><p>Wait, what? There’s more assembly code after this? Why?</p>
<p>Well, if something goes wrong in <code>bootmain()</code>, then the function will return, so<br>we have to handle that here. Since we usually run OSes we’re developing in an<br>emulator like Bochs or QEMU, we’ll trigger a breakpoint and loop. Bochs listens<br>on port 0x8A00, so we can transfer control back to it there; this wouldn’t do<br>anything on real hardware.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    movw    $0x8a00, %ax    # 0x8a00 -&gt; port 0x8a00</span><br><span class="line">    movw    %ax, %dx</span><br><span class="line">    outw    %ax, %dx</span><br><span class="line">    movw    $0x8ae0, %ax    # 0x8ae0 -&gt; port 0x8a00</span><br><span class="line">    outw    %ax, %dx</span><br><span class="line">spin:</span><br><span class="line">    jmp     spin            # loop forever</span><br></pre></td></tr></table></figure>

<h3 id="The-Global-Descriptor-Table"><a href="#The-Global-Descriptor-Table" class="headerlink" title="The Global Descriptor Table"></a>The Global Descriptor Table</h3><p>Oh, and remember when we promised the hardware that we were gonna give it a GDT?<br>We even told it to load it from address <code>gdtdesc</code>, remember? Well, we have to<br>deliver on that promise now by defining the GDT here.</p>
<p>x86 expects that the GDT will be aligned on a 32-bit boundary, so we tell the<br>assembler to do that. Then we use the macros <code>SEG_NULLASM</code> and <code>SEG_ASM</code> defined<br>in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/asm.h">asm.h</a> to create three segments: a null segment, a segment for executable<br>code, and another for writeable data. The null segment has all zeroes; the first<br>argument to <code>SEG_ASM</code> has the permission bits, the second is the physical base<br>address, and the third is the maximum virtual address. As we said before, xv6<br>relies mostly on paging, so we set the segments to go from 0 to 4 GB so they<br>identity-map all the memory.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.p2align 2      # force 4-byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                             # null segment</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code segment</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)         # data segment</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word   (gdtdesc - gdt - 1)     # sizeof(gdt) - 1</span><br><span class="line">    .long   gdt                     # address of gdt</span><br></pre></td></tr></table></figure>

<h2 id="bootmain-c"><a href="#bootmain-c" class="headerlink" title="bootmain.c"></a>bootmain.c</h2><p>Okay, the rest of the boot loader is in C now! Most of the code here is just to<br>interact with the disk in order to read the kernel from disk and load it into<br>memory. Let’s start off by looking at <code>waitdisk()</code>.</p>
<h3 id="waitdisk"><a href="#waitdisk" class="headerlink" title="waitdisk"></a>waitdisk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HEAD. DESK. Why all the magic numbers? At least we’re lucky that the name makes<br>it obvious what this function does; this won’t always be true in xv6. Okay, so<br>this function does only one thing: it loops until the disk is ready. Disk specs<br>are boring as all hell, so feel free to skip to the next section if you don’t<br>care about the particulars (I don’t blame you).</p>
<p>The usual way to talk to the disk is with Direct Memory Access (DMA), in which<br>devices are hooked up directly to RAM for easy communication. But we haven’t<br>initialized the disk at all or set up any drivers for it; that’s the OS’s<br>responsibility, not the boot loader’s. Even if we could ask the disk to give us<br>some data through memory-mapped I&#x2F;O, we disabled all interrupts, so we wouldn’t<br>know when it’s ready. So instead, we have to go back to assembly code (ugh, I<br>know) to access the disk directly.</p>
<p>Storage disks have all kinds of standardized specifications, among them IDE<br>(Integrated Drive Electronics) and ATA (Advanced Technology Attachment). The<br>ATA specs include a Programmed I&#x2F;O mode where data can be transferred between<br>the disk and CPU through I&#x2F;O ports. This is usually a huge waste of resources<br>because every byte has to be transferred through a port and the CPU is busy the<br>entire time, but right now beggars can’t be choosers.</p>
<p>Each disk controller chip has two buses (primary and secondary) for use with ATA<br>PIO mode; the primary bus sends data on port 0x1F0 and has control registers on<br>ports 0x1F1 through 0x1F7. In particular, port 0x1F7 is the status port, which<br>will have some flags to let us know what it’s up to. The sixth bit (or 0x40 in<br>hex) is the RDY bit, which is set when it’s ready to receive more commands. The<br>seventh bit (i.e., 0x80) is the BSY bit, which if set says the disk is busy.</p>
<p>Since interrupts are disabled, we’ll have to manually poll the status port in an<br>infinite loop until the BSY bit is not set but the RDY bit is: <code>inb()</code> is a C<br>wrapper (defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">x86.h</a>) for the x86 assembly instruction <code>inb</code>, which reads<br>from a port. We don’t care about any of the other status flags, so we’ll get rid<br>of them by bitwise-ANDing the result with 0xC0 &#x3D; 0x40 + 0x80. If the result of<br>that is 0x40, then only the RDY bit is set and we’re good to go.</p>
<p>Phew. That was a lot for just one line of code.</p>
<h3 id="readsect"><a href="#readsect" class="headerlink" title="readsect"></a>readsect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Issue command</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);</span><br><span class="line">    outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read data</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you skipped the last section: this function reads a sector (which in the<br>current-year-according-to-xv6 of 1995 is 512 bytes) from disk. Good to see you<br>again, on to the next section for you!</p>
<p>If you powered through the pain and read about ATA PIO mode above, some of the<br>magic numbers here might be familiar. First we call <code>waitdisk()</code> to wait for the<br>RDY bit, then we send some stuff over ports 0x1F2 through 0x1F7, which we know<br>are the command registers for the primary ATA bus.</p>
<p>Note that <code>uint</code> is just a type alias for C’s <code>unsigned int</code>, defined in the<br>header file <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/bootmain.c">types.h</a>. The <code>offset</code> argument is in bytes, and determines which<br>sector we’re gonna read; sector 0 has to hold the boot loader so the BIOS can<br>find it, and in xv6 the kernel will start on disk at sector 1.</p>
<p><code>outb()</code> is another C wrapper for an x86 instruction from <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>; this one’s<br>the opposite of <code>inb()</code> because it sends data out to a port. The disk controller<br>register at port 0x1F2 determines how many sectors we’re gonna read. Ports 0x1F3<br>through 0x1F6 are where the sector’s address goes. If you <em>really</em> must know<br>(why?) they’re the sector number register, the cylinder low and high registers,<br>and the drive&#x2F;head register, in order. Port 0x1F7 was the status port above, but<br>it also doubles as the command register; we send it command 0x20, aka READ<br>SECTORS.</p>
<p>Then we wait for the RDY bit again before reading from the bus’s data register<br>at port 0x1F0, into the address pointed to by <code>dst</code>. Once again, <code>insl()</code> is a<br>C wrapper for the x86 instruction <code>insl</code>, which reads from a port into a string.<br>The <code>l</code> at the end means it reads one long-word (32 bits) at a time.</p>
<h3 id="readseg"><a href="#readseg" class="headerlink" title="readseg"></a>readseg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(uchar *pa, uint count, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar *epa = pa + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round down to sector boundary</span></span><br><span class="line">    pa -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time. We&#x27;d write</span></span><br><span class="line">    <span class="comment">// more to memory than asked, but it doesn&#x27;t matter -- we load in increasing</span></span><br><span class="line">    <span class="comment">// order.</span></span><br><span class="line">    <span class="keyword">for</span> (; pa &lt; epa; pa += SECTSIZE, offset++) &#123;</span><br><span class="line">        readsect(pa, offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Okay, finally, we’re done with assembly and disk specs. We’re gonna read <code>count</code><br>bytes starting from <code>offset</code> into physical address <code>pa</code>. Note that <code>uchar</code> is<br>another type alias for <code>unsigned char</code> from <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>; this means that <code>pa</code> is a<br>pointer (which is 32 bits in x86) to some data where each piece is 1 byte.</p>
<p><code>epa</code> will point to the end of the part we want to read. Now, <code>count</code> might not<br>be sector-aligned, so we fix that. Declaring <code>pa</code> as a <code>uchar *</code> lets us do this<br>pointer arithmetic easily because we know that adding 1 to <code>pa</code> makes it point<br>at the next byte; if it were a <code>void *</code> like in <code>readsect()</code>, pointer arithmetic<br>would be undefined. (Actually, GCC lets you do it anyway, but GCC lets you get<br>away with a lot of crazy stuff, so let’s not go there.)</p>
<p>Now that we’ve got everything set up, we just call <code>readsect()</code> in a for loop to<br>read one sector at a time, and that’s it!</p>
<p>Some people have asked about the structure of some of the for loops in xv6,<br>because they don’t always use obvious index variables like <code>int i</code>. There are<br>plenty of reasons to hate C, but I think the way it structures for loops is by<br>far one of its most powerful features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test condition; update statements) &#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When evaluating the for loop, C first executes anything in the initialization.<br>Then it checks whether the test condition is true; if so, it executes the code<br>inside the loop. Then it carries out the update statements before checking the<br>test condition again and runnning the code if it’s still true.</p>
<p>In the for loop above, the initialization is just an empty statement; all the<br>variables we want to use have already been set up, so we don’t need it and C<br>will just move on to the next step. The test condition is simple enough. But the<br>update statement actually increments both <code>pa</code> and <code>offset</code> at once before going<br>through the loop again.</p>
<p>Okay great, so now we can read from the disk into memory, so we’re all set up to<br>load the kernel and start running it!</p>
<h3 id="ELF-Files"><a href="#ELF-Files" class="headerlink" title="ELF Files"></a>ELF Files</h3><p>Before we move on to the star of the show, <code>bootmain()</code>, we need to talk about<br>how a computer can actually recognize a file as executable. When you compile<br>some code, the result gets spit out in a format that your machine can recognize,<br>load into memory, and run; it’s usually the linker’s job to do this. Most Unix<br>and Unix-like systems use the standardized Executable and Linkable Format, or<br>ELF, for this purpose.</p>
<p>ELF divides the executable file into sections: <code>text</code> (the code’s instructions),<br><code>data</code> (initialized global variables), <code>bss</code> (statically-allocated variables<br>that have been declared but not initialized), <code>stab</code> and <code>stabstr</code> (debugging<br>symbols and similar info), <code>rodata</code> (read-only data, usually stuff like string<br>literals).</p>
<p>An ELF file starts with a header which has a magic number: 0x7F followed by the<br>letters “ELF” represented as ASCII bytes; an OS can use this to recognize an ELF<br>file. The header also tells you the file’s type: it could be an executable, or a<br>library to be linked with executables, or something else. There’s a whole bunch<br>of other info in the header, like the architecture it’s made to run on, version,<br>etc., but we’re gonna ignore most of that.</p>
<p>The most important parts of the header are the part where it tells us where in<br>the file the processor should start executing instructions and the part that<br>describes the number of entries, on-disk offset, and size of the program header<br>table.</p>
<p>The program header table is an array that has one entry for each of the file<br>sections above that’s found in this program. It describes the offset in the file<br>where each section can be found along with the physical and virtual address at<br>which that section should be loaded into memory and the size of the section,<br>both in the file and in memory; these might differ if, e.g. the program contains<br>some uninitialized variables which don’t need to be stored in the file but do<br>need to have space in memory.</p>
<p>The kernel (along with all the user-space programs) will be compiled and linked<br>as ELF files, so <code>bootmain()</code> will have to parse the ELF header to find the<br>program header table, then parse that to load each section into memory at the<br>right address. xv6 uses a <code>struct elfhdr</code> and a <code>struct proghdr</code>, both defined<br>in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/elf.h">elf.h</a>, for this purpose.</p>
<p>Okay, back to the boot loader to finish up now!</p>
<h3 id="bootmain"><a href="#bootmain" class="headerlink" title="bootmain"></a>bootmain</h3><p>This is the C function that gets called by the first part of the boot loader<br>written in assembly. Its job will be to load the kernel into memory and start<br>running it at its entry point, a program called <code>entry()</code>.</p>
<p>Next up, we’re gonna use <code>readseg()</code> to load the kernel’s ELF header into memory<br>at physical address 0x1_0000; the number isn’t too important because the header<br>won’t be used for long; we just need some scratch space in some unused memory<br>away from the boot loader’s code, the stack, and the device memory-mapped I&#x2F;O<br>region. We’ll read 4096 bytes first at offset 0; <code>readseg()</code> turns that offset<br>into sector 1. Remember that we have to convert <code>elf</code> into a <code>uchar *</code> so that<br>the pointer arithmetic in <code>readseg()</code> works out the way we want it to.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> elfhdr *) <span class="number">0x10000</span>;</span><br><span class="line">    readseg((uchar *) elf, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>While we’re at it, let’s go ahead and make sure that what we’re loading really<br>is an ELF file and not some random other garbage because any of a million things<br>went wrong during the compilation process, or we got some rootkit that totally<br>corrupted the kernel or something. It’s not really the most robust of checks,<br>but <em>eh</em>. If something went wrong we’ll just return, since we know that the code<br>in <code>bootasm.S</code> is ready to handle that with some Bochs breakpoints.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have to look at the program header table to know where to find each of<br>the kernel’s segments. The <code>elf-&gt;phoff</code> field tells us the program header<br>table’s offset from the start of the ELF header, so we’ll set <code>ph</code> to point to<br>that and <code>eph</code> to point to the end of the table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (<span class="keyword">struct</span> proghdr *) ((uchar *) elf + elf-&gt;phoff);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">eph</span> =</span> ph + elf-&gt;phnum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each entry in the program header table tells us where to find a segment, so<br>we’ll iterate over the entries, reading each one from disk and loading it up. In<br>this for loop, note that <code>ph</code> is a <code>struct proghdr *</code>, so incrementing it with<br><code>ph++</code> increments it by the size of a <code>struct proghdr</code> and not by one byte; this<br>makes it automatically point at the next entry in the table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">        uchar *pa = (uchar *) ph-&gt;paddr;    <span class="comment">// address to load section into</span></span><br><span class="line">        readseg(pa, ph-&gt;filesz, ph-&gt;off);   <span class="comment">// read section from disk</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the segment&#x27;s size in memory is larger than the file image</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;memsz &gt; ph-&gt;filesz) &#123;</span><br><span class="line">            stosb(pa + ph-&gt;filesz, <span class="number">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That if statement at the end checks if the section’s size in memory should be<br>larger than its size in the file, in which case it calls <code>stosb()</code>, which is yet<br>another C wrapper from <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a> for the x86 instruction <code>rep stosb</code>, which block<br>loads bytes into a string. It’s used here to zero the rest of the memory space<br>for that section. Okay, but why would we want to do that? Well, if the reason<br>it’s larger is because it has some uninitialized static variables, then we want<br>to make sure those start off holding zero (as the C standard requires) and not<br>whatever garbage value may have been there before.</p>
<p>Last part of the bootloader: let’s call the kernel’s entry point, <code>entry()</code>, and<br>get it running! But remember how the boot loader is compiled and linked<br>separately from the kernel? Yeah, that means we can’t just call <code>entry()</code> as a<br>function, because then the linker would go “Huh? What entry function? I don’t<br>have any <code>entry</code> function here in your symbol table. REJECTED.” And then it<br>would throw a huge error.</p>
<p>Luckily, the ELF header tells us where to find the entry point in memory, so we<br>could get a pointer to that address. That means… function pointers! If you’ve<br>never used function pointers in C before, then this won’t be the last time<br>you’ll see them in xv6, so check it out.</p>
<p>A C function is just a bunch of code to be executed in order, right? That means<br>it shows up in the ELF file’s <code>text</code> section, which will end up in memory. When<br>you call a regular old C function, the compiler just adds some extra assembly<br>instructions to throw a return address on the stack and update the registers<br><code>%ebp</code> and <code>%esp</code> to point to the new function’s stack on top of the old one. If<br>the function getting called has any arguments or local variables, they’ll get<br>pushed onto the stack too. Then the instruction register <code>%eip</code> gets updated to<br>point to the new function section, and that’s it. After the compiler is done,<br>the linker will replace the function’s name with its memory address in the<br><code>text</code> section, and voila, a function call.</p>
<p>The point of all this is that in C we can use pointers to functions; they just<br>point to the beginning of that function’s instructions in memory, where the<br><code>%eip</code> register would end up pointing if the function gets called. So in this<br>case, even though we’re not linking with the kernel, we can still call into the<br>entry point by getting its address from the ELF header, creating a function<br>pointer to that address, then calling the function pointer. The compiler will<br>still add all the usual stack magic, but instead of the linker determining where<br><code>%eip</code> should point, we’ll do that ourselves.</p>
<p>The first line below declares <code>entry</code> as a pointer to a function with argument<br>type <code>void</code> and return type <code>void</code>. Then we set <code>entry</code> to the address from the<br>ELF header, then we call it.</p>
<p>Again, this shouldn’t return, but if it does then it’s the last part of this<br>function, so this function will return back into the assembly boot loader code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">void</span> (*entry)(<span class="type">void</span>);</span><br><span class="line">    entry = (<span class="type">void</span>(*) (<span class="type">void</span>)) (elf-&gt;entry);</span><br><span class="line">    entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s it! Starting from <code>entry()</code>, we’re officially out of the boot loader and<br>into the kernel.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, the assembly part of the boot loader (1) disabled interrupts, (2)<br>set up the GDT and segment registers so the segmentation hardware is happy and<br>we can ignore it later, (3) set up a stack, and (4) got us from 16-bit real mode<br>to 32-bit protected mode.</p>
<p>Then the C part of the boot loader just loaded the kernel from disk and called<br>into its entry point.</p>
<p>ELF headers will continue to haunt us in the kernel’s linker script and when we<br>load user programs from disk in <code>exec()</code>, and function pointers will make<br>another appearance when we get around to handling interrupts. The good news: the<br>boot loader is one of the most opaque parts of the xv6 code, full of boring<br>hardware specs and backwards-compatibility requirements, so if you made it this<br>far, it does get better!</p>
<p>(But it also gets worse… looking at you, <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mp.c">mp.c</a> and <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kb.c">kbd.c</a>…)</p>
<h1 id="The-Beginning-Entry-and-Paging"><a href="#The-Beginning-Entry-and-Paging" class="headerlink" title="The Beginning: Entry and Paging"></a>The Beginning: Entry and Paging</h1><h2 id="xv6’s-Memory-Layout"><a href="#xv6’s-Memory-Layout" class="headerlink" title="xv6’s Memory Layout"></a>xv6’s Memory Layout</h2><p>The whole point of virtualizing memory is to give users the illusion that they<br>can roam freely across a limitless field of memory without worrying their pretty<br>little heads about such boring details as how much physical memory their machine<br>actually has, or where kernel code is stored, or the fact that their seemingly-<br>continuous heap space is actually shattered into tons of tiny pages spread out<br>in possibly random parts of physical memory. As long as user code is well-<br>behaved, that illusion should hold up; if they do a no-no we’ll just smack them<br>with a segmentation fault.</p>
<p>One downside is that the kernel also has to use virtual memory, so we’re faced<br>with the potentially-complicated challenge of setting things up in physical<br>memory without knowing where anything is actually located in physical memory! So<br>xv6 does something that a lot of OSes do: it sets itself up as a higher-half<br>kernel. That means that in the virtual address space (from 0 to 4 GB), the<br>kernel will reside in the upper half starting at 2 GB, i.e. address 0x8000_0000<br>and up; user code will start at 0 and end at 2 GB. Because of this, <code>KERNBASE</code><br>is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a> as 0x8000_0000.</p>
<p>Then it sets up paging so that all of physical memory is identity-mapped to<br>virtual memory starting at 0x8000_0000. This makes it really convenient for the<br>kernel to figure out the physical address of a virtual address it’s using; just<br>subtract <code>KERNBASE</code> and you’re done. The <code>V2P</code> and <code>V2P_WO</code> macros defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a> do just that, and the <code>P2V</code> and <code>P2V_WO</code> add <code>KERNBASE</code> to a<br>physical address to get the kernel virtual address.</p>
<p>Note that I said “kernel virtual address”, not just any old virtual address.<br>Users don’t get these kinds of fancy privileges, because they shouldn’t be<br>worrying about where anything is in physical memory. They’re running through a<br>limitless field of virtual memory, remember? So user virtual addresses between 0<br>and 2 GB will get mapped to totally arbitrary locations in physical memory.</p>
<p>One consequence of this is that xv6 is limited to no more than 2 GB of physical<br>memory (instead of the 4 GB that 32-bit addresses allow for) in order to map it<br>all into the top 2 GB of virtual memory. In reality, it’s even less, for two<br>reasons: (1) we also need to map device I&#x2F;O regions into virtual memory, so<br>it’ll be a little less than 2 GB, and (2) it’s hard and annoying to figure out<br>how much physical memory is actually present on any given machine, so xv6 just<br>says to hell with all that and picks the totally arbitrary value of a puny 224<br>MB as the amount of available physical memory (that’s <code>PHYSTOP</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/memlayout.h">memlayout.h</a>).</p>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>Remember when we talked about segmentation, and how we said we’d come back to<br>paging later? Guess what? It’s later.</p>
<p>So all virtual addresses are really “logical addresses”, and segmentation turns<br>those into “linear addresses”. In xv6, the boot loader set up the segmentation<br>hardware to use an identity map, so virtual addresses are the same as logical<br>addresses are the same as linear addresses. Now paging has to turn those linear<br>addresses into physical addresses. Just like segmentation uses a GDT and the<br>segment registers for its mapping, paging uses a page directory, page tables,<br>and the <code>%cr3</code> register.</p>
<p>First, imagine a world where every single time some user code throws up an<br>address (maybe it looks up a variable, or it calls a function, or it simply<br>needs to execute the next instruction), the CPU has to stop what it’s doing,<br>save all the user’s register contents, load up some kernel code, restore its<br>register contents, find out where its stack is, get it running, and then ask the<br>OS where that virtual address is actually located in physical memory. That would<br>be <em>so</em> slow. We don’t want that. We want the hardware to do all the address<br>conversions by itself, and involve the OS only minimally to set up a new page<br>directory when it starts a new process.</p>
<p>Instead, the x86 hardware uses one of its control registers, <code>%cr3</code>, to store a<br>pointer to a page directory in memory. Then every time it needs to map a linear<br>address to a physical one, it goes to that page directory and grabs the relevant<br>entry. That entry is a pointer to a page <em>table</em> somewhere else in memory, so<br>the processor grabs the right entry from there, which points to a 4096-byte page<br>in some other location.</p>
<p>A linear address has a three-part structure: the 10 most significant bits are an<br>index that picks an entry from the page directory, the next 10 bits are an index<br>to pick an entry from whatever page table we’ve been directed to, and the last<br>12 bits are an offset that determines where to look in the page that the page<br>table entry pointed to.</p>
<p>For example, let’s say we have a virtual address like 0x9C4A_02BF. If we convert<br>to binary, split it up, and convert back to hex, we can see that the 10 most<br>significant bits are 0x271, the next 10 are 0x0A0, and the last 12 are 0x2BF. So<br>the paging hardware would look at wherever <code>%cr3</code> is pointing to find the page<br>directory; let’s just call it <code>pgdir</code>. Then it would take entry <code>pgdir[0x271]</code><br>and go look wherever that’s pointing to find the right page table; let’s call<br>that <code>pgtab271</code>. Then it would take entry <code>pgtab271[0x0A0]</code> and look wherever<br>that’s pointing to find the right page, <code>pg</code>. <em>Then</em> it would finally<br>know that the corresponding physical address is <code>pg + 0x2BF</code>. Whew.</p>
<p>This still sounds super slow, so the paging hardware uses a cache called the<br>Translation Lookaside Buffer (TLB) to store recently-used mappings and make them<br>faster in the future. Since pages are 4096 bytes, it only needs to map a new<br>page if the addresses some code is asking for crosses a page boundary.</p>
<p>xv6 provides two macros, <code>PDX</code> and <code>PTX</code> defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>, to recover just the<br>page directory index bits or the page table index bits, respectively, from a<br>virtual address.</p>
<p>Finally: an important aspect of virtual memory is that each process should be<br>isolated from the others, and the kernel should be isolated from user processes.<br>So each process will get its own page directory, and each entry of that page<br>directory will say whether it’s present (i.e., mapped) or not. If it’s present,<br>then it points to a page table for that process; if it’s not present and we try<br>to access it, we’ll get a page fault or a general protection fault. Each entry<br>in a page table will also say whether that page is present and what kinds of<br>permissions it has. The bit flags for the permissions are (in order from least<br>to most significant bit):</p>
<ul>
<li>Bit 0: present.</li>
<li>Bit 1: read&#x2F;write.</li>
<li>Bit 2: user (otherwise only the kernel can access it).</li>
<li>Bit 3: write-through.</li>
<li>Bit 4: cache disabled.</li>
<li>Bit 5: accessed (for the TLB).</li>
<li>Bit 6: page size (we’ll talk about this later).</li>
<li>Bit 7: (unused).</li>
</ul>
<p>This way, since each process has its own page directory, page tables, and pages,<br>and each level has specific permissions set, they should never be able to<br>interfere with each other.</p>
<p>Again, most of the time, the kernel will just happily ignore all this and use<br>the mapping in the higher half of virtual memory for simplicity. Each user<br>process’s page directory will have the same mapping in the higher half so that<br>the kernel can keep doing what it’s doing no matter which user process is<br>currently running.</p>
<p>Anyway, back to the code! We left off after the boot loader had finished loading<br>the kernel into memory; it ended by calling an <code>entry()</code> function in the kernel.<br>We haven’t set up paging yet, so that’s next on our to-do list. But first, the<br>kernel is compiled and linked using a <em>linker script</em>, so we’ll have to look at<br>that to understand how that sets up memory the way we want it.</p>
<h2 id="kernel-ld"><a href="#kernel-ld" class="headerlink" title="kernel.ld"></a>kernel.ld</h2><p>The gory details of linker scripts as a whole are outside the scope of these<br>posts, so I’m gonna gloss over a lot of the parts of this file and focus on<br>the important pieces.</p>
<p>It’s important to understand what a linker does in a rough sense, so I’ll just<br>generalize and wave my hands around and say that a compiler takes code in a<br>high-level language and converts it to assembly, an assembler takes that<br>assembly code and turns it into machine code, and a linker takes a whole bunch<br>of machine code files (including any code for library functions) and links them<br>all together into a single executable file.</p>
<p>注释: compiler -&gt; assembler -&gt; linker, high-level language -&gt; asm code -&gt; machine code</p>
<p>Linking involves three steps that are important for us here: first, the linker<br>has to assign each piece of code a location in memory, so that different<br>variables, functions, etc. don’t end up colliding; then it replaces references<br>to that object with its address. Second, it has to resolve any outstanding<br>symbols (variables, functions, etc.) in each file by looking them up in all the<br>other files and replacing them with those addresses; the linker can define its<br>own symbols too. Third, it has to create an output file in a format that the OS<br>can use, like ELF.</p>
<p>注释: 链接的本质是将符号(symbol)替换为地址值(address)，symbol主要指函数；链接输出二进制程序例如elf</p>
<p>xv6 has decided that command-line flags are too basic for it, so instead it’ll<br>use a linker script <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a> for the GNU linker.</p>
<p>We start off by specifying the output format (32-bit ELF), the architecture<br>(x86, also known as i386), and the entry point to start executing code. The<br>convention is to call the entry point <code>_start</code>; the ELF header will include its<br>address, which is how we were able to call it from the boot loader.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure>

<p>Next up come the sections. Remember the ELF sections <code>text</code>, <code>rodata</code>, <code>data</code>,<br><code>bss</code>, and <code>stab</code>? Well we’ve gotta tell the linker where to set them up in<br>memory, using commands like <code>. = address</code>. These are virtual addresses, so since<br>we want to set up our kernel in the higher half of virtual memory, we’ll tell it<br>to link the code start at 0x8010_0000. Again, we use that address instead of<br>0x8000_0000 (which maps to physical address 0) because we have to avoid the<br>address spaces of the boot loader and the memory-mapped I&#x2F;O devices.</p>
<p>We can also tell the linker where in physical memory the code should be placed<br>(in linker script lingo, its “load address”) using the <code>AT(address)</code> command.<br>We’ll use the physical address 0x0010_0000, since that maps to virtual address<br>0x8010_0000.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x80100000;</span><br><span class="line"></span><br><span class="line">    .text : AT(0x100000) &#123;</span><br><span class="line">        /* this part tells the linker which files to include in this section */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* more sections here... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s one other detail we should check out: the linker can create its own<br>symbols using the <code>PROVIDE(symbol = .)</code> command. If the code happens to declare<br>its own variable <code>symbol</code>, then the linker will just throw away its own version<br>of it, but if the code uses <code>symbol</code> without defining it, then the linker will<br>replace those references with the contents of that memory location.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* virtual address and text sections are defined as above */</span><br><span class="line"></span><br><span class="line">    PROVIDE(etext = .);     /* etext will be at the address right after the end</span><br><span class="line">                            of the text section */</span><br><span class="line"></span><br><span class="line">    /* rodata, stab, and stabstr sections defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(data = .);      /* data will be at the address at the very beginning</span><br><span class="line">                            of the data section */</span><br><span class="line"></span><br><span class="line">    /* data section defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(edata = .);     /* edata will be at the address right after the end</span><br><span class="line">                            of the data section */</span><br><span class="line"></span><br><span class="line">    /* bss section defined here */</span><br><span class="line"></span><br><span class="line">    PROVIDE(end = .);       /* end will be at the very last address at the end</span><br><span class="line">                            of the entire kernel code */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Those variables will be used later in the kernel code; not so much for their<br>contents but for their addresses, as pointers to the virtual addresses of<br>specific parts of the kernel’s code in memory. On to the kernel!</p>
<h2 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h2><p>I have bad news. That <code>entry()</code> function that the boot loader called? It’s in<br>assembly again. :(</p>
<h3 id="Multiboot-Header"><a href="#Multiboot-Header" class="headerlink" title="Multiboot Header"></a>Multiboot Header</h3><p>Okay, so first off, we’ve got some more hideous specs to deal with for a bit in<br>the form of a multiboot header. Multiboot is a specification that lets boot<br>loaders load up kernel code in a standardized way; the GNU boot loader GRUB uses<br>it. So this part is mostly here in case you want to run xv6 on real hardware<br>using GRUB; feel free to skip to <code>entry()</code> below.</p>
<p>The original Multiboot specification has since been replaced with Multiboot 2,<br>but again, it’s 1995, so we don’t know about that yet.</p>
<p>Multiboot helps compliant kernels and boot loaders identify each other using a<br>special header. The header must be completely contained in the first 8192 bytes<br>of the kernel’s image, and it must be 32-bit aligned. The header contains three<br>things: (1) a magic number used for mutual identification and recognition<br>(0x1BADB002 for kernels, 0x2BADB002 for boot loaders), (2) some flags for the<br>kernel to inform the boot loader what the kernel requires in order to run<br>successfully, and (3) a 32-bit unsigned checksum which when added to the other<br>two fields must have a 32-bit unsigned sum of zero. Depending on the flags that<br>are set, there may be other components to the Multiboot header.</p>
<p>So we’ll start by creating a <code>multiboot_header</code> label at the beginning of the<br>file (and thus, the beginning of the kernel image) and making sure it’s aligned<br>to 32 bits.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.p2align 2      # Force 4-byte alignment</span><br><span class="line">.text</span><br><span class="line">.globl multiboot_header</span><br><span class="line">multiboot_header:</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Now we’ll just add the magic number, set the flags to 0 to indicate no special<br>requirements, and add the checksum.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define magic 0x1badboo2</span><br><span class="line">#define flags 0</span><br><span class="line">.long magic</span><br><span class="line">.long flags</span><br><span class="line">.long (-magic-flags)</span><br></pre></td></tr></table></figure>

<p>And that’s it!</p>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>Back in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, we said that the linker would set up the kernel’s ELF<br>header to specify the kernel’s entry point using <code>_start</code>, but <code>_start</code> itself<br>wasn’t actually defined there, so we have to do that first. We don’t know where<br>this code will end up in memory, so we’ll define an <code>entry</code> label and set<br><code>_start</code> to the address of <code>entry</code>. Note that the linker script used virtual<br>addresses in the higher half, but we haven’t set up paging yet, so we’ll have to<br>convert it to a physical address using one of the macros we mentioned earlier.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start = V2P_WO(entry)</span><br><span class="line">.globl entry</span><br></pre></td></tr></table></figure>

<p>Next up we want to finish setting up virtual memory by enabling paging, but<br>that’s all kinds of complicated, so we’re gonna start off with a super simple<br>version of paging. Part of that difficulty is that there’s a bootstrap problem:<br>we need to allocate pages to hold the page tables themselves, but we can’t use<br>pages without page tables… uhh…</p>
<p>We’ll solve that by starting off with a basic, super-simple page directory where<br>only two entries are mapped: the first entry maps virtual addresses 0 to 4 MB to<br>physical addresses 0 to 4 MB, and the second entry maps virtual addresses<br><code>KERNBASE</code> to <code>KERNBASE</code> + 4MB to physical addresses 0 to 4 MB. One consequence<br>is that the entire kernel code and data has to fit in 4 MB.</p>
<p>Why the two entries pointing to the same place? It’s to solve another bootstrap<br>problem. The kernel is currently running in physical addresses close to 0. Once<br>we enable paging and start using virtual addresses in the higher half, the stack<br>pointer <code>%esp</code>, instruction pointer <code>%eip</code>, even the pointer in <code>%cr3</code> to the<br>page directory itself will all still point to low addresses until we update<br>them. But updating them requires executing instructions, which would require<br>accessing low addresses a few more times. If we left out the low addresses, we’d<br>get a page fault, and since we don’t have exception handlers set up yet, that<br>would cause a double fault, which would turn into the dreaded <strong>TRIPLE FAULT</strong>,<br>in which the processor enters an infinite reboot loop. So yeah, point is, we<br>need both the low and high mappings for now; we’ll get rid of the low mappings<br>once we’re done setting up.</p>
<p>But wait! Aren’t page directory entries supposed to point to page tables? How<br>can they point directly to pages here? It turns out that x86 can skip that<br>second layer altogether if we use so-called “huge” pages of 4 MB in size instead<br>of the usual 4 KB. In the long run, this could lead to internal fragmentation,<br>but it does cut down on the overhead and allows a faster set-up. Plus we’re only<br>gonna use them for a minute while we get ready for the full paging ordeal.</p>
<p>To use 4 MB pages, we have to enable x86’s Page Size Extension (PSE) by setting<br>the fourth bit in the <code>%cr4</code> register. <code>CR4_PSE</code> is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as 0x10,<br>or 00010000 in binary.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">    movl    %cr4, %eax</span><br><span class="line">    orl     $(CR4_PSE), %eax</span><br><span class="line">    movl    %eax, %cr4</span><br></pre></td></tr></table></figure>

<p>We need a page directory before we can set up paging; again, basic version now,<br>full glorious page directory later. We’re gonna do the same thing we did in the<br>boot loader where we tell the processor to load the page directory now but then<br>procrastinate actually writing it; this time, we’ll write it in C and call it<br><code>entrypgdir</code>. Then we’ll load its physical address into register <code>%cr3</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class="line">movl    %eax, %cr3</span><br></pre></td></tr></table></figure>

<p>Now we can enable (a basic version of) paging! We tell the CPU to start using<br>the page directory in <code>%cr3</code> by setting bit 31 (paging) of register <code>%cr0</code>; we<br>can also set bit 16 (write protect) of the same register to prevent writing to<br>any pages that the page directory and page tables have marked as read-only.<br><code>CR0_PG</code> and <code>CR0_WP</code> are defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> to set these bits.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $(CR0_PG|CR0_WP), %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>

<p>Now remember how the processor is still running at low addresses? Yeah, let’s<br>fix that. First we’ll make a new kernel stack in the higher half that will still<br>be valid even after we get rid of the lower address mappings. We’ll have the<br>linker save some space for us under the symbol <code>stack</code> and set it up there;<br><code>KSTACKSIZE</code> is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 4096 bytes. So we just set the stack<br>pointer register <code>%esp</code> to the top of that section in order to let the stack<br>grow down toward the address of <code>stack</code>. Again, we’ll procrastinate actually<br>defining <code>stack</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    $(stack + KSTACKSIZE), %esp</span><br></pre></td></tr></table></figure>

<p>Now we want to call into the <code>main()</code> function, but we don’t just want to do<br>that the usual assembly way of <code>call main</code>. That would generate a jump relative<br>to the current value of <code>%eip</code>, which is still in low addresses. We’ll use an<br>indirect jump instead.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     $main, %eax</span><br><span class="line">jmp     *%eax</span><br></pre></td></tr></table></figure>

<p>Finally, we need to get around to reserving space for the stack. We can do that<br>with the assembler instruction <code>.comm symbol, size</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.comm stack, KSTACKSIZE</span><br></pre></td></tr></table></figure>

<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>Awesome, back to C code now! Remember how we procrastinated actually defining<br><code>entrypgdir</code>? Let’s do that now; it’s at the bottom of <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/main.c">main.c</a>.</p>
<h3 id="entrypgdir"><a href="#entrypgdir" class="headerlink" title="entrypgdir"></a>entrypgdir</h3><p>What in the world is this?!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entrypgdir[NPDENTRIES] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = (<span class="number">0</span>) | PTE_P | PTE_W | PTE_PS,</span><br><span class="line">    [KERNBASE&gt;&gt;PDXSHIFT] = (<span class="number">0</span>) | PTE_P | PTE_W | PTE_PS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Okay, bear with me; I promise it’s not too bad.</p>
<p>First, the <code>__attribute__</code> tells the compiler and linker that the page directory<br>should be placed in memory at an address that’s a multiple of <code>PGSIZE</code> (4096<br>bytes); that’s just a requirement of the paging hardware.</p>
<p>Next, we define <code>entrypgdir</code> as an array of <code>NPDENTRIES</code> (1024, according to<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>), each of type <code>pde_t</code> (a type alias for <code>unsigned int</code>, according to<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>).</p>
<p>Then we initialize the entries: in C, you’re allowed to initialize an array by<br>specifying the values of specific enties; all other enties become zero. You<br>specify an entry by putting its index in square brackets before its value, so<br><code>[2] 5</code> will set the entry with index 2 to be 5. Here we initialize the entries<br>with indices 0 and <code>KERNBASE &gt;&gt; PDXSHIFT</code>, which is the same thing as<br><code>PDX(KERNBASE)</code>, AKA the page directory index corresponding to the virtual<br>address <code>KERNBASE</code>, AKA 0x8000_0000. So basically, we’ve initialized the page<br>directory entries corresponding to the low virtual address 0 and the high<br>virtual address <code>KERNBASE</code>.</p>
<p>We set their value to 0, because we want them to map to physical addresses from<br>0 up to 4 MB. Oh, and remember how page directories and page tables can also<br>hold permission flags? We want to set flags to say that these pages are present<br>(so that accessing them doesn’t cause a page fault), writeable, and 4 MB in<br>size; those are defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as <code>PTE_P</code>, <code>PTE_W</code>, and <code>PTE_PS</code>. We can<br>combine them all together by bitwise-ORing them.</p>
<p>And we’re done!</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>The code in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/entry.S">entry.S</a> finished up by calling into the C function <code>main()</code>, which<br>is where the core set-up happens before we can start running processes. It calls<br>into basically every single part of the xv6 kernel, so we can’t go through all<br>the functions line-by-line yet; instead I’ll just give you an overview of what<br>they do.</p>
<ul>
<li><code>kinit1()</code> solves another bootstrap problem around paging: we need to allocate<br>  pages in order to use the rest of memory, but we can’t allocate those pages<br>  without first freeing the rest of memory, which requires allocating them…<br>  You see what I mean. This function will free the rest of memory between the<br>  <code>end</code> of the kernel code (defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, remember?) and 4 MB.</li>
<li><code>kvmalloc()</code> allocates a page of memory to hold the fancy full-fledged page<br>  directory, sets it up with mappings for the kernel’s instructions and data,<br>  all of physical memory, and I&#x2F;O space, then switches to that page directory<br>  (leaving poor old <code>entrypgdir</code> in the trash).</li>
<li><code>mpinit()</code> detects hardware components like additional CPUs, buses, interrupt<br>  controllers, etc. Then it determines whether this machine supports this<br>  crazy new idea where you can have multiple CPU cores. Wow, 1995 is crazy.</li>
<li><code>lapicinit()</code> programs this CPU’s local interrupt controller so that it’ll<br>  deliver timer interrupts, exceptions, etc. when we’re ready for them later.</li>
<li><code>seginit()</code> sets up this CPU’s kernel segment descriptors in its GDT; we still<br>  won’t really use segmentation, but we’ll at least use the permission bits.</li>
<li><code>picinit()</code> disables the <em>ancient</em> PIC interrupt controller that literally no<br>  one has ever used since the APIC was introduced in 1989. I don’t even know<br>  what to say. I guess I was mistaken when I assumed it was 1995; I don’t<br>  know.</li>
<li><code>ioapicinit()</code> programs the I&#x2F;O interrupt controller to forward interrupts<br>  from the disk, keyboard, serial port, etc., when we’re ready for them later.<br>  Each device will have to be set up to send its interrupts to the I&#x2F;O APIC.</li>
<li><code>consoleinit()</code> initializes the console (display screen) by adding it to a<br>  table that maps device numbers to device functions, with entries for reading<br>  and writing to the console. It also sets up the keyboard to send interrupts<br>  to the I&#x2F;O APIC.</li>
<li><code>uartinit()</code> initializes the serial port to send an interrupt if we ever<br>  receive any data over it. xv6 uses the serial port to communicate with<br>  emulators like QEMU and Bochs.</li>
<li><code>pinit()</code> initializes an empty process table so that we can start allocating<br>  slots in it to processes as we spin them up.</li>
<li><code>tvinit()</code> sets up and interrupt descriptor table (IDT) so that the CPU can<br>  find interrupt handler functions to deal with exceptions and interrupts when<br>  they come.</li>
<li><code>binit()</code> initializes the buffer cache, a linked list of buffers holding<br>  cached copies of disk data for more efficient reading and writing.</li>
<li><code>fileinit()</code> sets up the file table, a global array of all the open files in<br>  the system. There are other parts of the file system that need to be<br>  initialized like the logging layer and inode layer, but those might require<br>  sleeping, which we can only do from user mode, so we’ll do that in the first<br>  user process we set up.</li>
<li><code>ideinit()</code> initializes the disk controller, checks whether the file system<br>  disk is present (because both the kernel and boot loader are on the boot<br>  disk, which is separate from the disk with user programs), and sets up disk<br>  interrupts.</li>
<li><code>startothers()</code> loads the entry code for all other CPUs (in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/entryothers.S">entryothers.S</a>)<br>  into memory, then runs the whole setup process again for each new CPU.</li>
<li><code>kinit2()</code> finishes initializing the page allocator by freeing memory between<br>  4 MB and <code>PHYSTOP</code>.</li>
<li><code>userinit()</code> creates the first user process, which will run the initialization<br>  steps that have to be done in user space before spinning up a shell.</li>
<li><code>mpmain()</code> loads the interrupt descriptor table into the CPU so that we’re<br>  finally completely ready to receive interrupts, then calls the <code>scheduler()</code><br>  function in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a>, which enables interrupts on this CPU and starts<br>  scheduling processes to run. <code>scheduler()</code> never returns, so at that point<br>  we’re completely done with setup and we’re running the OS proper.</li>
</ul>
<h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>The entry code in the xv6 kernel had one job: to set up paging. It kind of<br>failed at that job, but not for lack of trying! There are just all kinds of<br>Catch-22s when it comes to paging, so at least it got us partway there by making<br>a temporary page directory to tide us over until we can throw it away and never<br>look back.</p>
<p>We also took a sneak peek at all the setup code in <code>main()</code>; we’re gonna end up<br>going through it all, but at least now you should have enough of an idea of<br>what’s going on that you can more or less skip around and look at what you need.</p>
<h1 id="Detour-Spin-Locks"><a href="#Detour-Spin-Locks" class="headerlink" title="Detour: Spin-Locks"></a>Detour: Spin-Locks</h1><p>So I know I said I wasn’t expecting you to have finished the OSTEP section on<br>concurrency, but xv6 uses locks all over the place, so we’re gonna have to get<br>comfortable with them right away. Luckily, xv6 primarily uses spin-locks, which<br>are super simple and work on bare metal; a lot of the more complex&#x2F;more awesome<br>locks that OSTEP talks about require an OS beneath them.</p>
<p>I’ll give a brief intro to concurrency first in case you haven’t made it to that<br>part in OSTEP; then we’ll turn to the spin-lock implementation in xv6.</p>
<h2 id="A-Very-Brief-Poor-Man’s-Intro-to-Concurrency"><a href="#A-Very-Brief-Poor-Man’s-Intro-to-Concurrency" class="headerlink" title="A Very Brief, Poor-Man’s Intro to Concurrency"></a>A Very Brief, Poor-Man’s Intro to Concurrency</h2><p>TL;DR: Concurrency is your worst nightmare. It’ll cause bugs in the places where<br>you least expect it, and they won’t even be consistent: your code might work 95%<br>of the time, but every once in a while it’ll randomly fail and you’ll have no<br>idea why. The good news: xv6 handles it in a super-simple way, so we’ll get to<br>appreciate it as we go along. If you’re like me, you might also see the code use<br>locks when you wouldn’t have thought they were needed, and then you’ll come to<br>appreciate just how clever the xv6 authors are.</p>
<p>First off, stop reading this and go watch the discussion of data races and locks<br>in <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=LzElj46saa8&t=8762s">the last few minutes of the CS 50 2021 lecture on SQL</a>.<br>I’m serious, go watch it right now; this post will still be here.</p>
<p>Okay, I’m gonna assume you’ve seen it now; you should have a decent sense of the<br>main issues with data races and how locks solve them. But the CS 50 lecture<br>skipped some details about locks: (1) what Brian (the TA) does when he finds a<br>locked fridge, (2) how locks are implemented in code, and (3) deadlocks.</p>
<h3 id="What-Does-Brian-Do"><a href="#What-Does-Brian-Do" class="headerlink" title="What Does Brian Do?"></a>What Does Brian Do?</h3><p>Let’s say process <code>david</code> is running on one thread, and it needs to use some<br>resource (a global variable maybe, or an I&#x2F;O device like the disk or console)<br>that other threads might want to use too, so <code>david</code> acquires the lock for that<br>resource. Then process <code>brian</code> comes along and wants to use the same resource at<br>the same time. This could cause a data race, but luckily we’ve thought ahead and<br>used a lock, so <code>brian</code> can’t access it until <code>david</code> is done with it and<br>releases the lock.</p>
<p>First of all, we better hope <code>david</code> remembers to release the lock; otherwise<br><code>brian</code> (and all other processes, even the kernel) will <em>never</em> be able to use<br>that resource. But assuming we’re smart and remembered to release it, what does<br>the <code>brian</code> process do in the meantime?</p>
<p>Well, maybe <code>brian</code> has some other work to do that he can get started on in the<br>meantime. But what would that mean for an OS? How would we know, in general,<br>whether the lines of code that follow the use of a shared resource can be safely<br>executed if we haven’t used that resource yet? That sounds impossible to figure<br>out without knowing ahead of time what the resource is and how it’s used, so<br>let’s just go ahead and skip that idea.</p>
<p>Another option that’s actually used often in the real world is for <code>brian</code> to<br>stop trying and go to sleep. Maybe he can put a note on himself asking <code>david</code><br>to wake him up when he gets back with the milk. So in code, that might look like<br><code>brian</code> signaling the OS and letting it run a different process until the lock<br>is released. That sounds nice and all, but at this early stage in our kernel, we<br>don’t even have processes or a scheduler yet, let alone a notion of sleeping.</p>
<p>Okay, another option: what if <code>brian</code> just spins around in circles, or twiddles<br>his thumbs, or does jumping jacks or whatever until <code>david</code> releases the lock?<br>In code, that means looping over and over forever until the lock is released.<br>That would be horribly inefficient; think of all the CPU time wasted when one<br>process just loops over and over again while another process does something slow<br>while holding a lock! But it’s also the approach that xv6 is gonna take, because<br>at the end of the day, our kernel is still in baby stages and beggars can’t be<br>choosers. So xv6 uses <em>spin-locks</em> with loops that only stop when we acquire a<br>lock.</p>
<p>This means we should be careful when using locks to acquire them only at the<br>last possible moment when they’re absolutely needed, and release them as soon as<br>they’re no longer required, in order to limit the amount of wasted CPU cycles.</p>
<h3 id="Implementing-Locks"><a href="#Implementing-Locks" class="headerlink" title="Implementing Locks"></a>Implementing Locks</h3><p>We can implement locks as a simple boolean variable: if it’s true, then someone<br>else is using the resource behind the lock. If it’s false, then it’s unused and<br>you can go ahead and take it. So an <code>acquire()</code> function sets the lock to <code>true</code><br>and a <code>release()</code> function sets it back to <code>false</code>. Done!</p>
<p>But it’s not so simple: there’s actually a race condition hidden in the very<br>idea of a lock. Think about it for a second: a lock protects some shared<br>resource, right? And a shared resource is something that more than one process<br>wants to use? But a lock is itself a thing that more than one process wants to<br>use… so we haven’t actually gotten rid of the race condition. (FLIPS TABLE.)</p>
<p>We have another Catch-22 on our hands, but this time we can’t get rid of it with<br>a clever software trick like we did with the <code>entrypgdir</code>. The issue is that no<br>matter how well we write our code, it will always require more than one step:<br>first we have to check whether the lock is <code>true</code>, then we have to set it to<br><code>true</code>. But if someone else is doing the same thing at the same time, our<br>instructions might get executed in parallel and then we’d both acquire the lock<br>at the same time -&gt; RACE CONDITION.</p>
<p>The solution will require hardware support, using <em>atomic</em> instructions – these<br>are hardware instructions that are indivisible; no other code can execute in<br>between ours. One example is the x86 instruction <code>xchg</code>, which atomically reads<br>a value from memory, updates it to a new value, and returns the old value.</p>
<p>Now we’re good! A lock can still be a boolean variable but now <code>acquire</code> has to<br>use <code>xchg</code>: it should get the old value while simultaneously updating it to<br><code>true</code>.</p>
<p>Atomic instructions have more overhead than regular ones, so we should only use<br>them when they’re required, like in locks, but otherwise we can stick to the<br>regular instructions we’ve always used.</p>
<p>There’s one other detail we should be careful about: a lot of the locks in xv6<br>protect resources that are needed by both interrupt handlers and kernel or user<br>code. For example, we might use a process table lock to protect the list of all<br>currently running processes; suppose some kernel code has acquired the lock in<br>order to run a new process. What happens if a timer interrupt goes off at that<br>moment? The timer interrupt handler function might need to acquire the lock in<br>order to switch processes, but it’s already being held by the kernel thread. But<br>the timer interrupt might take priority over the kernel thread and refuse to<br>return to the kernel until it finishes executing. The result: that CPU comes to<br>a total halt as the timer interrupt handler function spins forever, never to get<br>the lock it so desperately needs to move on. So sad. :(</p>
<p>xv6 avoids this issue in a really simple way: every time we acquire a lock,<br>we’ll just disable interrupts altogether. Problem solved: now a thread can’t get<br>interrupted until it’s done using the lock and releases it. This does mean that<br>a process which grabs locks often might stick around longer than it should,<br>since we won’t have timer interrupts to tell the scheduler to swap it out with<br>another process, but we’re just gonna cross our fingers and hope that doesn’t<br>happen too often.</p>
<h3 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h3><p>The last concurrency issue we need to be aware of is the problem of deadlocks.<br>Suppose two threads each need locks A and B; this happens often, e.g. when<br>loading a user program the kernel will need to hold a lock for the disk and<br>another for the process table, or a process might be reading from disk and<br>printing to the console at the same time.</p>
<p>Suppose they’re running at the same time, and one process acquires lock A while<br>the other one acquires lock B. If they each need the other lock to keep going,<br>they’d spin forever waiting for it. This is a deadlock.</p>
<p>The way to avoid these is to make sure that, if we use more than one lock, we<br><em>always</em> acquire them in the same order. That way, one process would acquire<br>lock A, the second one would be unable to acquire it and would spin, then the<br>first process acquires lock B with no issues. When it’s done, it releases both<br>locks and the second process can continue.</p>
<p>This can get complicated though: if we ever acquire a lock in a function, we’d<br>have to check any functions that that function calls to see whether they use any<br>locks, and so on. If they do, and if the order conflicts with another chain of<br>function calls, we’d have to refactor the code until the orders match. xv6 has<br>been carefully written so that the lock acquisition order is always consistent.</p>
<h2 id="spinlock-c"><a href="#spinlock-c" class="headerlink" title="spinlock.c"></a>spinlock.c</h2><p>xv6’s spin-locks are set up as a <code>struct spinlock</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/spinlock.h">spinlock.h</a>. The<br><code>locked</code> field acts as the boolean variable to determine whether the lock is<br>held; the other fields are for debugging, since we can expect concurrency issues<br>to be the one of the most common causes of bugs in the kernel code because,<br>again, concurrency is your worst nightmare.</p>
<p>Note that <code>locked</code> is an <code>unsigned int</code> instead of a <code>bool</code>; C requires the<br>standard library header <em>stdbool.h</em> in order to use the <code>bool</code> type, but on<br>bare metal we can’t assume we have a standard library to use.</p>
<h3 id="initlock"><a href="#initlock" class="headerlink" title="initlock"></a>initlock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function is pretty straightforward; it just stores the string <code>name</code> in<br>the lock and starts it off as unlocked; the <code>cpu</code> field is 0 because no CPU is<br>holding it yet. Next.</p>
<h3 id="pushcli-and-popcli"><a href="#pushcli-and-popcli" class="headerlink" title="pushcli and popcli"></a>pushcli and popcli</h3><p>For reasons mentioned above, we need to disable interrupts whenever we’re using<br>a lock and re-enable them when we release a lock. But if we’re not careful, we<br>could end up enabling interrupts too early when we release one lock while still<br>holding another; or if interrupts were already disabled when we acquired a lock,<br>we could unintentionally re-enable them upon releasing it.</p>
<p>xv6 uses paired functions <code>pushcli()</code> and <code>popcli()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushcli</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> eflags = readeflags();</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli == <span class="number">0</span>) &#123;</span><br><span class="line">        mycpu()-&gt;intena = eflags &amp; FL_IF;</span><br><span class="line">    &#125;</span><br><span class="line">    mycpu()-&gt;ncli += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readeflags()</code> is a C wrapper for some x86 assembly code that reads from the<br><code>eflags</code> register; the 9th bit is the interrupt flag, which is set whenever<br>interrupts are enabled. <code>cli</code> is another x86 instruction that clears that flag,<br>thus disabling interrupts.</p>
<p><code>mycpu()</code> returns a pointer to a <code>struct cpu</code> with information about the CPU<br>running this code; we’ll go over these when we talk about processes; here we<br>increment the <code>ncli</code> field in every call to <code>pushcli()</code>. If this is the first<br>call, we save the value of the interrupt flag in the <code>intena</code> field.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">popcli</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;popcli - interruptible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--mycpu()-&gt;ncli &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;popcli&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli == <span class="number">0</span> &amp;&amp; mycpu()-&gt;intena) &#123;</span><br><span class="line">        sti();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>popcli()</code> first checks to make sure interrupts aren’t already enabled and we’re<br>not popping without having pushed. Then it decrements the <code>ncli</code> field of the<br><code>struct cpu</code> for this CPU. If this is the last call to <code>popcli()</code>, it checks the<br><code>intena</code> field; if it was set (i.e., interrupts were enabled before the first<br><code>popcli()</code>), then it enables interrupts again.</p>
<p>Check out how these two functions are carefully written so that they’re matched:<br>it takes two calls to <code>popcli()</code> to undo two calls to <code>pushcli()</code>. Also, if<br>interrupts were already off before the first call to <code>pushcli()</code>, they’ll stay<br>off after the last <code>popcli()</code>. Pretty neat, right?</p>
<h3 id="holding"><a href="#holding" class="headerlink" title="holding"></a>holding</h3><p>This function checks whether this CPU is holding the lock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line">    <span class="type">int</span> r = lock-&gt;locked &amp;&amp; lock-&gt;cpu == mycpu();</span><br><span class="line">    popcli();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not much to talk about here; it just checks (inside calls to <code>pushcli()</code> and<br><code>popcli()</code>) whether the lock is being held and this is the CPU holding it. If<br>both conditions are true it’ll return 1; otherwise 0.</p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>The first step in this function is to disable interrupts to avoid deadlocks. We<br>also make sure we’re not already holding the lock; otherwise we’d deadlock<br>ourselves.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holding(lk)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next up, we’ve gotta acquire the lock using the atomic <code>xchg</code> instruction,<br>defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>.<br>Like we said before, the trick is to atomically set <code>locked</code><br>to 1 while returning the old value. If the returned old value is 1, that<br>means it was already 1 before we got to it, so it’s currently being held and we<br>can’t acquire it yet – gotta spin. But if the returned old value is 0, that<br>means the lock was free before we got to it, and our <code>xchg</code> just updated it to<br>1, so we’ve successfully acquired it. No other instruction can occur between<br>checking the old value and updating it to the new one, so we can be confident<br>that no one else will be holding the lock at the same time.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We do have to be careful about one other thing: compiler optimizations can get<br>pretty wild nowadays, so the order of code on the page isn’t necessarily the<br>order it’ll get compiled to or executed in. This is a critical section of code,<br>so we need to make sure acquiring the lock forms a barrier between the code that<br>comes before it and the code after it so any reordering doesn’t cross the lock<br>acquisition point. We can do that with a special compiler instruction:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll record some info about the CPU and process holding the lock for<br>debugging purposes. Don’t worry about <code>mycpu()</code> for now, but we’ll talk about<br><code>getcallerpcs()</code> below.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lk-&gt;cpu = mycpu();</span><br><span class="line">    getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>Releasing a lock is a little easier than acquiring it: to acquire it, we need to<br>check whether it’s already held and update its value, with both steps together<br>as an atomic instruction. To release it, we only have to set the value to false.<br>That’s only one instruction, so it’s automatically atomic!</p>
<p>Well, almost, but not quite. The compiler works some serious magic behind the<br>scenes, so there’s no guarantee that a single C operation like <code>lk-&gt;locked = 0</code><br>will actually get compiled down to a single assembly instruction. So we’re gonna<br>have to make sure it does by writing it directly in assembly.</p>
<p>We start off by making sure we are already holding the lock before releasing a<br>lock held by someone else. Then we clear the debug info stored in the lock, and<br>tell the compiler and processor not to reorder code past the lock release.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holding(lk)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to release the lock, i.e. an assembly instruction equivalent to<br><code>lk-&gt;locked = 0</code> in C. C allows in-line assembly code using the <code>asm</code> keyword.<br>We mark it as <code>volatile</code>, which prevents the compiler from optimizing the write<br>away and ensures it’ll get written to memory. Finally, we call <code>popcli()</code> to<br>enable interrupts again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl $0, %0&quot;</span> : <span class="string">&quot;+m&quot;</span> (lk-&gt;locked) : )</span>;</span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getcallerpcs"><a href="#getcallerpcs" class="headerlink" title="getcallerpcs"></a>getcallerpcs</h3><p>This function exists to store information about the current process in the lock<br>for use in debugging. In particular, we want to record the program counters of<br>the last 10 functions on the call stack so we can try to figure out which<br>functions were called in which order when concurrency issues inevitably bring<br>our world crashing down with data races, or to a grinding halt with deadlocks.</p>
<p>In order to get the program counters, we’re gonna have to know a bit about how<br>x86 handles function calls. The <code>%eip</code> register (or instruction pointer) holds<br>the program counter, which tracks the next instruction to be executed. The<br><code>%ebp</code> register (or base pointer) holds the address of the base of the stack<br>(i.e., its highest address, since it grows down).</p>
<p>When a function gets called all its arguments are pushed on the stack in reverse<br>order, so that the first argument is at the top (lowest address) of the stack.<br>Then the previous function’s <code>%eip</code> is pushed on the stack, followed by its<br><code>%ebp</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;- low addresses                                               high addresses -&gt;</span><br><span class="line">...  [new function&#x27;s data]  [old %ebp]  [old %eip]  [new arg1]  [new arg2]  ...</span><br><span class="line">&lt;- top of stack                                               bottom of stack -&gt;</span><br></pre></td></tr></table></figure>

<p>Anyway, the point is that if we have the address of the first argument to the<br>current function, then we can recover the contents of the previous function’s<br><code>%ebp</code> and <code>%eip</code> registers: <code>%eip</code> is one spot below it on the stack and <code>%ebp</code><br>is two spots below it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    uint *ebp = (uint *) v - <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note the type casts here – <code>v</code> is a pointer to the first argument, which can be<br>of any type and size, so we use a <code>void *</code>. But both of the <code>%eip</code> and <code>%ebp</code><br>registers hold 32-bit pointers, so <code>ebp</code> is declared as a pointer to a <code>uint</code><br>(a type alias for <code>unsigned int</code>, remember?), which makes the pointer arithmetic<br>work out nicely so that subtracting 2 returns a pointer to the right spot on the<br>stack.</p>
<p>Now, what we really want is the program counter <code>%eip</code>, not the pointer to the<br>stack base <code>%ebp</code>. But we can use the address of <code>%ebp</code> to make sure we haven’t<br>gone too far back in the function call history. Remember, we wanna get the<br>program counters for the last 10 functions in the call stack, then save them in<br>the <code>pcs</code> array.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// Stop if the %ebp pointer is null or out of range</span></span><br><span class="line">        <span class="keyword">if</span> (ebp == <span class="number">0</span> || ebp &lt; (uint *) KERNBASE || ebp == (uint *) <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pcs[i] = ebp[<span class="number">1</span>];</span><br><span class="line">        ebp = (uint *) ebp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s talk about those last two lines: the <code>ebp</code> pointer in the code holds the<br>location of the saved <code>%ebp</code> register, so <code>ebp[0]</code> is the value at that address<br>(i.e., the actual value of the saved <code>%ebp</code> register) and <code>ebp[1]</code> is the value<br>stored one spot above that, i.e. the value of the saved <code>%eip</code> register. So<br>each iteration of the loop will get one <code>%eip</code> and store it in a <code>pcs</code> entry.</p>
<p>Then we update <code>ebp</code> to the actual value at the address it points to, which<br>means <code>ebp</code> will now point to the address of the saved <code>%ebp</code> register for the<br>function one step further back in the call chain. Okay sorry, I know that’s<br>confusing, but basically each iteration of the for loop moves us back to the<br>function that called this function, then the function that called that one, and<br>so on.</p>
<p>Okay, whew. So what happens if we break out of the for loop early because we<br>went all the way back in the call stack? The other entries of <code>pcs</code> might hold<br>some garbage values, so let’s just make them null pointers so we know to ignore<br>them when debugging.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getcallerpcs</span><span class="params">(<span class="type">void</span> *v, uint pcs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        pcs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One last little trick: the previous for loop declared the loop variable <code>i</code><br>before the loop – this means <code>i</code> will be in scope for the rest of the function<br>body. If it had been declare inside the for loop like <code>for (int i = 0; ...)</code>, it<br>would fall out of scope at the end of the loop. So we can keep using the same<br><code>i</code> in this second for loop (without an initialization statement) and know it’ll<br>hold the value it had after finishing the first for loop. If we finished all the<br>iterations, that value will be 10; otherwise it’ll be less. So we use that to<br>clear any remaining entries of <code>pcs</code>.</p>
<h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>You’ll learn to hate concurrency issues in C; newer languages like Rust make<br>data races a thing of the past, though deadlocks can still rear their ugly<br>heads. But for now, the xv6 authors have done all the dirty work for us, so we<br>can just sit back and watch. Note, though, that even the xv6 authors say it’s<br>totally possible that something has slipped past them and the thousands of other<br>students and instructors that have looked at xv6, so it’s probable that xv6<br>still has some lingering race conditions. See, even the masters struggle with<br>it. -_-</p>
<p>Anyway, we saw that locks have to be implemented with hardware support using<br>atomic instructions. C and most languages provide high-level atomics that real-<br>world operating systems use, but the point of xv6 is elegance in simplicity, not<br>being a total show-off, so the xv6 spin-locks just use the basic <code>xchg</code>.</p>
<p>We took this detour into spin-locks to make sure we all understand some basic<br>details because we’re gonna be seeing a lot of them in the rest of the kernel<br>code. They’re inefficient (because the processor just spins around waiting for<br>the lock to be released, WHEEEEE), but we gotta make do with the machinery we’ve<br>built up so far. xv6 will also use some fancier locks called sleep-locks, but<br>we’ll cross that bridge when we get to it.</p>
<h1 id="Page-Allocation"><a href="#Page-Allocation" class="headerlink" title="Page Allocation"></a>Page Allocation</h1><p>When we left off before the lock detour, the boot loader had set up a GDT to<br>ignore segmentation, and the entry code set up some barebones paging with an<br><code>entrypgdir</code>. But that initial page directory is too limiting to keep for long;<br>it only mapped the first 4 MB of physical memory. So we want a new one, but we<br>have to set it up and allocate pages in it before we can actually use it. And<br>until we switch to it, everything has to happen in those first 4 MB.</p>
<h2 id="kalloc-c"><a href="#kalloc-c" class="headerlink" title="kalloc.c"></a>kalloc.c</h2><p>We start off in this file by declaring the function <code>freerange()</code>, which will be<br>defined below. We have to do this in C in order to call a function in the code<br>before the compiler has actually seen the function’s definition, which comes<br>below, or maybe in another file. A <em>declaration</em> tells the C compiler “I know I<br>haven’t shown you this symbol before, but don’t worry; it’s just a function that<br>takes this number of arguments with these types and has a return value of this<br>type.” That lets the compiler keep calm and carry on with its usual type-checks<br>(weak as they may be in C). A <em>definition</em> tells the compiler that this is the<br>function (or variable) we were talking about, so it’ll reserve some space in<br>memory for it; it also tells the compiler how to evaluate that function whenever<br>it’s called (for variables, an <em>initialization</em> will have to tell the compiler<br>what the value the variable should hold). The linker will take care of matching<br>function calls (and variable uses) to their definitions, possibly across files.</p>
<p>Usually you’d stick declarations in a C header file and tell the preprocessor to<br>copy-paste the header into your code with an <code>#include</code> directive; then other<br>files could <code>#include</code> that header too. So header files should really be more of<br>an API kind of thing, for functions that you want other code to be able to call.<br>This one is just a local helper function, so we’ll declare it here instead of in<br>a header so other code can’t use it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span>;</span><br></pre></td></tr></table></figure>

<p>Okay okay, I know function declarations are like 101-level C, but I wanted to<br>mention them because we’re about to see something similar but a little off next<br>when we declare <code>end</code> as a global array of characters.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[];</span><br></pre></td></tr></table></figure>
<p>The C keyword <code>extern</code> lets you define a global variable or function in one file<br>and use it in another, so in that sense it’s similar to the function declaration<br>above. In fact, the compiler implicitly assumes there’s an <code>extern</code> before each<br>function declaration. The difference is that an explicit <code>extern</code> lets us do the<br>same thing for global variables: we tell the compiler and linker “hey, I’m gonna<br>use a variable of this type with symbol <code>end</code>, but don’t worry about reserving a<br>spot in memory for it; that already happened elsewhere.”</p>
<p>The really cool thing about <code>extern</code> is that the function or variable might not<br>even be defined in C – it could come from any other language! We just pass the<br>compiled object files from the other language together with the C object files<br>to the linker and it’ll match up the definitions and calls.</p>
<p>In this case if you try looking for the place where <code>end</code> is defined in the C or<br>assembly code, you’re gonna be disappointed. Turns out it’s actually defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>, remember? Back then, we said it was gonna be located at the very<br>first memory address right after the end of the kernel code and data in memory.<br>We’re about to see why it’s needed.</p>
<p>Next up, we define a new <code>struct</code> type:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Hmm, the only member of this <code>struct run</code> is a pointer to another <code>struct run</code>.<br>Hopefully, you’ve seen some singly-linked lists before so you can recognize it<br>as one of those. Usually it would have another member to hold the data in the<br>list, but we won’t need any extra data here; we’ll find out why soon enough.</p>
<p>Last thing before we get to the functions: we define another <code>struct</code> type and<br>declare the global variable <code>kmem</code> to be of that type.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> use_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<p>The syntax here is the usual C thing where we say the type of a variable, then<br>an identifier, like <code>int i</code>; it just looks more confusing because we’re also<br>defining the type at the same time. This <code>struct</code> type doesn’t get a name like<br><code>struct run</code> did because we’re only gonna need it this one time. The fields are<br>a spin-lock (hence the detour before coming here), a <code>use_lock</code> variable that<br>we’ll treat as a boolean, and a pointer to a <code>struct run</code> called <code>freelist</code>.</p>
<p>I’m just gonna go ahead and spoil the next two functions for you: we want to use<br>a better page directory than <code>entrypgdir</code>, right? Well then we need to assign<br>a page of memory for it, plus a page for each of its page tables, plus a page<br>for each entry in those page tables that’s mapped. That means we’ll need some<br>bookkeeping to track which pages have already been assigned. We’re gonna use a<br>linked list of free pages (that’s what <code>struct run</code> is for); we’ll allocate a<br>page by popping one off the free list, and we’ll free a page by pushing it onto<br>the top of the list.</p>
<p>Note that <code>kfree()</code> here is <em>not</em> supposed to be a kernel version of the usual C<br>standard library function <code>free()</code>, nor is <code>kalloc()</code> supposed to be a kernel<br>version of <code>malloc()</code>. We have no concept of a heap yet, so heap allocation<br>wouldn’t make sense. These functions allocate and free <em>whole physical pages</em> to<br>be added to the current page directory and its page tables.</p>
<h3 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h3><p>This function will free a single page (4096 bytes, or <code>PGSIZE</code>) of memory by<br>adding it to the front of the free list. It takes an argument <code>char *v</code> which is<br>a virtual address; we’re using <code>char *</code> here instead of <code>uint *</code> or <code>void *</code> or<br>whatever so that the pointer arithmetic increments by a single byte instead of<br>4 bytes for <code>uint</code> or whatever.</p>
<p>First, some sanity checks: <code>v</code> should be page-aligned (because we’re freeing a<br>whole page), it should be above <code>end</code> (because we don’t want to accidentally<br>overwrite the kernel code), and its corresponding physical address should be<br>below <code>PHYSTOP</code> (because the only addresses we’ll use above the top of physical<br>memory are for memory-mapped I&#x2F;O devices and we shouldn’t be freeing those pages<br>anyway).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((uint) v % PGSIZE || v &lt; end || V2P(v) &gt;= PHYSTOP) &#123;</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if you’ve programmed in C, you might have come across the dreaded (but oh-<br>so-common) bug known as a <em>use-after-free</em>. This means you called <code>free()</code> on<br>some variable (hopefully one you had <code>malloc()</code>-ed before), and then used it<br>again. Hmm, very naughty! The problem is that that memory might have been re-<br>allocated to some other variable or even another process, so you might read the<br>wrong values or overwrite something important. This is a <em>very</em> common cause of<br>security vulnerabilities in C and C++ to this day; it’s also not always easy to<br>spot because huge projects might have you call <code>malloc()</code> in one file, then use<br>the variable somewhere else thousands of lines of code later in some other file,<br>then call <code>free()</code> in yet another file – plus it’s unlikely that all of these<br>pieces were written by the same person. So let’s make this a little easier on<br>ourselves by filling the freed page with junk (a bunch of 1s everywhere) in the<br>hope that a use-after-free leads to a crash (and thus debugging and detection)<br>sooner than it would otherwise.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">1</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might be familiar with <code>memset()</code> from the C standard library in <em>string.h</em>,<br>but we can’t risk using standard library functions here because they assume the<br>code will be provided by the OS, and the implementation might require any of a<br>million features we haven’t implemented yet. So we have to make our own version<br>for the kernel in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>. We’ll get around to looking at that code later on<br>in an optional detour, but for now just know that it sets the memory starting at<br><code>v</code> and continuing for <code>PGSIZE</code> bytes to hold a bunch of repeated 1s.</p>
<p>Now let’s talk concurrency. At any time, multiple threads might want to allocate<br>or free pages simultaneously; if we’re not careful we might accidentally use the<br>same page twice, which would cause bugs in addition to security vulnerabilities,<br>because all the per-process isolation that paging gets us would be lost. So much<br>work down the drain! This is why <code>kmem</code> has a lock, which we should use any time<br>we push to or pop from the free list.</p>
<p>But in the early stages of the kernel we only use a single CPU and interrupts<br>are disabled, so there’s nothing to fear. Plus, locks add overhead, and the<br><code>acquire()</code> function needs to call <code>mycpu()</code>, which we haven’t even defined yet,<br>so let’s just go ahead and skip them in the beginning. So <code>kmem.use_lock</code> is a<br>boolean that will tell us whether we need a lock right now or not.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        acquire(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, we’re finally at the point where we can free the page. We’ll make a<br><code>struct run *r</code> that points to virtual address <code>v</code>, then make its <code>next</code> point<br>to the first entry of the free list. Then we’ll update the head of the list to<br>point at the newly-freed page. This is the standard C idiom to add to the front<br>of a singly-linked list.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> (<span class="keyword">struct</span> run *) v;</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s something interesting here: where are we storing this entry for the free<br>list? Why, in the free page itself! So each unused page will hold the address of<br>the next one in its first few bytes.</p>
<p>Finally, we’re out of the critical section where we updated the free list, so we<br>can release the lock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">char</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h3><p>Allocating a page means popping off the head of the free list. We acquire the<br>lock first, if we need one.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        acquire(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we get a pointer to the first free page in the list and update the head to<br>point to the next one in the list. But what if the list is empty? In that case,<br>the head would be a null pointer, and dereferencing a null pointer (like we do<br>here in <code>r-&gt;next</code>) is undefined behavior in C, which means BAD THINGS HAPPEN.<br>I’m serious – there are absolutely no restrictions on what might happen, so the<br>compiler could literally set your computer on fire if it wanted to. In the real<br>world, that usually means either a segmentation fault or security vulnerability,<br>or both if you’re unlucky. So we should check whether <code>r</code> is null (i.e. zero).<br>if it’s nonzero then we can update <code>r-&gt;next</code>; otherwise we should just return<br><code>r</code> and hope whoever called us checks whether it’s null. Moral of the story:<br>any call to <code>kalloc()</code>, just like any call to <code>malloc()</code> in regular C code,<br>should always be followed by checking whether the returned pointer is null.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        kmem.freelist = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now we just release the lock, and we’re done!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (kmem.use_lock) &#123;</span><br><span class="line">        release(&amp;kmem.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freerange"><a href="#freerange" class="headerlink" title="freerange"></a>freerange</h3><p><code>kalloc()</code> and <code>kfree()</code> both handle only one page at a time, which can get<br>annoying if we’re trying to free tons of pages at once; also, they can only use<br>page-aligned virtual addresses, which have to be typecast to <code>char *</code>. Let’s<br>simplify our lives with a simple wrapper function to free multiple pages between<br>two virtual memory addresses <code>vstart</code> and <code>vend</code> that may not be page-aligned.</p>
<p>Let’s assume that <code>vstart</code> is the first address after some other data in an<br>already-allocated page; we don’t want to free that page, but the next one, so we<br>align it to a page boundary by rounding up, then cast that to a <code>char *</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *) PGROUNDUP((uint) vstart);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can iterate over the pages, starting at <code>p</code> and incrementing by <code>PGSIZE</code><br>until we reach or pass <code>vend</code>, freeing pages as we go.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; p + PGSIZE &lt;= (<span class="type">char</span> *) vend; p += PGSIZE) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Done, next.</p>
<h3 id="kinit1-and-kinit2"><a href="#kinit1-and-kinit2" class="headerlink" title="kinit1 and kinit2"></a>kinit1 and kinit2</h3><p>Both of these functions get called by the kernel’s <code>main()</code>. Quick reminder:<br>we’ve got an <code>entrypgdir</code> that maps two virtual address ranges (0 to 4 MB and<br><code>KERNBASE</code> to <code>KERNBASE</code> + 4 MB) to the physical addresses range from 0 to 4 MB.<br>We want to leave this baby page directory behind for a grown-up page directory<br>that maps all of physical memory, but first we needed to figure out how to<br>allocate pages.</p>
<p>Okay cool, we already did that. But allocation needs a free list, which for now<br>is just sitting around chilling as an empty list. But we can’t free pages if<br>they’re not already allocated, right? Ahh, bootstrap problems! This one’s not an<br>issue; we’ll just cheat this one time and free all the memory between <code>end</code> (the<br>end of the kernel code and data in memory) and <code>PHYSTOP</code>, even though we didn’t<br>get it from a call to <code>kalloc()</code>. Sounds good, right?</p>
<p>I hate to burst your bubble, but kernel development <em>loves</em> bursting bubbles.<br>Turns out there’s yet another bootstrap problem: each page has to store the<br>pointer to the next free page, which means we have to write to that page, which<br>means that page must already be mapped… but we can’t map all of memory until<br>we initialize the free list by freeing all of memory…</p>
<p>HEAD. DESK. We’re screwed.</p>
<p>Okay, obviously the xv6 authors figured this out already. The trick is that we<br>do have <em>some</em> physical memory we can write to: everything between <code>end</code> and 4<br>MB. So we can free that part for now, allocate some of those pages for a fresh<br>page directory and some pages, then use those pages to map the rest of physical<br>memory, then come back later and free those pages.</p>
<p>So we’ll have to split up the work of setting up the new page directory into two<br>very similar functions, <code>kinit1()</code> and <code>kinit2()</code>. The first one will initialize<br>the lock for the free list but make <code>kmem.use_lock</code> false so we don’t use a lock<br>in the early stages of kernel setup. The second one will set it to true so we<br>start using a lock to allocate and free pages once we have multiple CPUs, a<br>scheduler, interrupts, etc.</p>
<p>Both of them will use <code>freerange()</code> to free the pages in a section of physical<br>memory. <code>main()</code> calls <code>kinit1()</code> with arguments to free the range from <code>end</code> to<br>4 MB, and calls <code>kinit2()</code> with arguments for the range from 4 MB to <code>PHYSTOP</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit1</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    kmem.use_lock = <span class="number">0</span>;</span><br><span class="line">    freerange(vstart, vend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kinit2</span><span class="params">(<span class="type">void</span> *vstart, <span class="type">void</span> *vend)</span></span><br><span class="line">&#123;</span><br><span class="line">    freerange(vstart, vend);</span><br><span class="line">    kmem.use_lock = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>This whole file was just to set up page allocation for the new page directory<br>we’re gonna replace <code>entrypgdir</code> with. It uses a free list in <code>kmem</code>; freeing a<br>page adds it to the front of the list and allocation pops a page off the front.<br>We have to populate the free list will pages for all of physical memory, but we<br>do that in two steps to avoid some bootstrap issues.</p>
<p>Again, this is a <em>page</em> allocator, not a <em>heap</em> allocator like <code>malloc()</code>, but<br>many heap allocator implementations use linked lists of free heap regions in the<br>same way. We talked about use-after-free bugs above, but now we can also see why<br><em>double-frees</em> (in which you free the same memory region more than once) can<br>cause bugs and security vulnerabilities: they add the same region to it twice,<br>which then might get allocated to two different variables or processes, which<br>might ruin the per-process isolation that virtualization is supposed to provide.<br>In addition, our page allocator handles fixed-size regions, but a heap allocator<br>needs to use variable regions, so when a memory region gets allocated twice<br>after a double-free, it might get split up into differently-sized pieces, of<br>which some parts get allocated to other processes, etc… It’s just a nightmare.</p>
<p>Next up, we’ll see the full story of virtual memory.</p>
<h1 id="More-Paging-The-Kernel-Side"><a href="#More-Paging-The-Kernel-Side" class="headerlink" title="More Paging: The Kernel Side"></a>More Paging: The Kernel Side</h1><p>We’ve already talked <em>plenty</em> about virtual memory, and I bet you’re probably so<br>over <code>entrypgdir</code> by now; let’s wrap up its story and get rid of it!</p>
<p>The <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/vm.c">vm.c</a> file is HUGE; only <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a> and <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/sysfile.c">sysfile.c</a> match its length. Some<br>parts deal with the general paging implementation; we’ll look at those here. The<br>rest handles the details of paging for processes and user code, we’ll need to<br>know a bit more about processes in xv6 for that.</p>
<h2 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h2><p>After the include directives for the preprocessor, we have a declaraction for<br>an external symbol defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>. This one is the beginning of the<br>data section for the kernel.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> data[];</span><br></pre></td></tr></table></figure>

<p>Next we have a definition for a pointer to a global page directory: this is the<br>fancy new one that’s gonna replace <code>entrypgdir</code>. Note that <code>pde_t</code> is a type for<br>page directory entries defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">types.h</a>; it’s just a type alias for <code>int</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *kpgdir;</span><br></pre></td></tr></table></figure>

<h3 id="seginit"><a href="#seginit" class="headerlink" title="seginit"></a>seginit</h3><p>This first function gets called directly by the kernel’s <code>main()</code>; it sets up<br>the segment descriptors in the GDT as identity maps to all of memory so that we<br>can ignore them from now on. Wait, didn’t we already do that in the boot loader?</p>
<p>Yes, kind of, but that was before the kernel took over, so back then we had no<br>notion of kernel space versus user space. Now that we do, we want to set the<br>permission flags for each segment so that we can use the privilege ring levels,<br>with the kernel in ring 0 and user code in ring 3. That way any misbehaving user<br>code will get slapped with a segmentation fault the way we’ve all come to know<br>and love in C.</p>
<p>We also have some permission flags for protection in the page directory and page<br>table entries, so maybe we could get away without it? I mean, both kernel code<br>and user code are read-only anyway, so maybe they could both have a Descriptor<br>Privilege Level of 3. But no, x86 is gonna shut that right down by forbidding<br>interrupts that take you from ring level 0 to ring level 3, so all the interrupt<br>handler functions have to be in kernel space with a kernel code segment selector<br>at ring level 0.</p>
<p>So we’re just gonna have to do it all over again. Great. Well, maybe it’s not<br>too bad, let’s take a look… oh god, it’s awful. Okay, deep breath.</p>
<p>Each processor has its own GDT, so we’re gonna need to call this function once<br>per CPU. First we figure out which CPU we’re on with with the <code>cpuid()</code> function<br>that we’ll see later on; for now it… (drumroll)… gets the CPU’s ID. Then we<br>look that up in a global table of CPUs (there’s an <code>extern</code> declaration for this<br>in the included <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.h">proc.h</a>) and store it in a <code>struct cpu</code>; we saw that before in<br>the spin-lock code, but we’ll get around to talking about it more later.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[cpuid()];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That <code>struct cpu</code> has a field to hold the GDT, so we’re gonna add entries for<br>the kernel code, kernel data, user code, and user data segment descriptors;<br>those entries are <code>SEG_KCODE</code>, <code>SEG_KDATA</code>, <code>SEG_UCODE</code>, and <code>SEG_UDATA</code>,<br>respectively. Recall that the permission bits are <code>STA_X</code> (executable), <code>STA_R</code><br>(readable), and <code>STA_W</code> (writeable); now we’re gonna pile on the descriptor<br>privilege levels for the kernel (0) and user (3, or <code>DPL_USER</code>) on top. Besides<br>those ring levels, we want to ignore segmentation, so each segment should be an<br>identity map for all virtual memory from 0 to 4 GB (0xffff_ffff).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c-&gt;gdt[SEG_KCODE] = SEG(STA_X|STA_R, <span class="number">0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;gdt[SEG_KDATA] = SEG(STA_W, <span class="number">0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;gdt[SEG_UCODE] = SEG(STA_X|STA_R, <span class="number">0</span>, <span class="number">0xffffffff</span>, DPL_USER);</span><br><span class="line">    c-&gt;gdt[SEG_UDATA] = SEG(STA_W, <span class="number">0</span>, <span class="number">0xffffffff</span>, DPL_USER);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The only difference between the <code>SEG</code> macro used here and the <code>SEG_ASM</code> one from<br>the boot loader is that this one is for C code and the other is for assembly.</p>
<p>Finally, we load up the new GDT into the processor with a C wrapper for the<br>x86 instruction <code>lgdt</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lgdt(c-&gt;gdt, <span class="keyword">sizeof</span>(c-&gt;gdt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done with segmentation, now on to more paging.</p>
<h3 id="walkpgdir"><a href="#walkpgdir" class="headerlink" title="walkpgdir"></a>walkpgdir</h3><p>A page directory lets the paging hardware convert virtual addresses to physical<br>ones, but we’re gonna need those mappings in the kernel too while we set up the<br>page directory, so this function does the conversion manually. Wait, but aren’t<br>we setting up paging so that all of physical memory is mapped in the higher half<br>of the virtual address space? Can’t we just add or subtract <code>KERNBASE</code> to do the<br>conversion? Well, that would work for kernel virtual addresses, but user virtual<br>addresses actually will use page directories and page tables in a non-obvious<br>way, so if we want to figure out where those go, we’ll need a function for it.</p>
<p>In C, using the <code>static</code> keyword before a function limits its scope and makes it<br>visible only within its own file. The function returns a <code>pte_t *</code>, a pointer to<br>a page table entry (the type is defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> as a type alias for <code>uint</code>).</p>
<p>Its arguments are a pointer to a page directory, a virtual address, and <code>alloc</code><br>(a boolean variable, but as an <code>int</code> instead of <code>bool</code>). This <code>alloc</code> lets the<br>function play a dual role: if it’s set, the function will allocate a page table<br>if needed; otherwise it reports failure if the page table doesn’t exist. The<br><code>const</code> keyword lets the compiler know a variable shouldn’t be mutated so it’ll<br>throw an error if we do. Here, <code>const void *va</code> is a pointer to a constant value<br>of any type; the address the pointer holds might change, but we can never write<br>to that address. The opposite is a <code>void *const va</code>: the address being pointed<br>to will never change, but we can overwrite the contents of that address all we<br>want. You can combine the two with <code>const void *const va</code>. What’s that I hear? C<br>syntax is the worst? No, never…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember way back when, when we talked about how “linear” addresses are set up<br>and converted to physical ones? The first 10 bits are an index for the page<br>directory to pick a page directory entry, which points to a page table; the next<br>10 bits pick a page table entry that points to a page, and the last 12 bits are<br>an offset within that page; the <code>PDX()</code> and <code>PTX()</code> macros get first 10 bits and<br>the next 10 bits from a linear address, respectively. So we start by getting the<br>page directory index and using that to get the page directory entry.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *pde = &amp;pgdir[PDX(va)];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now <code>pde</code> points to a page directory entry which has two parts: a<br>pointer to the physical address of a page table, and some flags. But who knows<br>if this page table even exists; most page directory (and page table) entries<br>aren’t mapped in order to save space. So we have to check whether <code>*pde</code> has the<br><code>PTE_P</code> (present) flag set.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the page table exists, we should get rid of the flags and recover the pointer<br>to the page table using the <code>PTE_ADDR()</code> macro. But the hardware uses physical<br>addresses for these pointers, so we need to convert it to a virtual address<br>first, which is what this function does… recursion? Bootstrap problem? No,<br>it’s actually easy because we can access the page table from within the kernel’s<br>virtual address space in the higher half by adding <code>KERNBASE</code> to the physical<br>address with the <code>P2V()</code> macro.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        pgtab = (<span class="type">pte_t</span> *) P2V(PTE_ADDR(*pde));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now for the else clause, which happens if the page directory entry doesn’t have<br>the <code>PTE_P</code> bit set. Well, if the boolean <code>alloc</code> is false (zero), then we’re<br>done and we should just report failure by returning a null pointer. On the other<br>hand, if it’s true, we just allocate a page for the page table. But wait,<br>remember how page allocation might fail and return a null pointer if we’re out<br>of free pages in the free list? And remember how I said we should always check<br>for that? Okay well let’s check for that; if allocation fails, we also return a<br>null pointer. Oh, and because this is C, we’re gonna do a jillion things at once<br>in a single line: check if <code>alloc</code> is false, try to allocate a page table, and<br>check if that allocation failed. C lets us assign to a variable and then test<br>that variable’s value in a single statement.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!alloc || (pgtab = (<span class="type">pte_t</span> *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now suppose: (1) the page table wasn’t present, (2) alloc was set, and<br>(3) we successfully allocated a page. Now what? Remember how we filled all free<br>pages with garbage in <code>kfree()</code> using <code>memset()</code>? Let’s undo that now by zeroing<br>it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">memset</span>(pgtab, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll update the page directory entry to point to this new page table and<br>add the <code>PTE_P</code> flag so it knows it’s present. Wait, while we’re at it, what<br>other permissions will it need? Is it writeable? Can users access it? Hmm, we’d<br>have to know whether we’re looking up a user virtual address or a kernel one,<br>and whether it’s gonna be used for code or data. Ah, screw it, we’ll just throw<br>all the flags on there at once. Either way, the page table entries will have<br>their own flags too, so we can restrict the page’s permissions there instead of<br>here at the page directory entry.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This probably isn’t the safest thing ever, because we’re saying that only the<br>page table will restrict permissions, so we’re throwing all that responsibility<br>over there, but hey, xv6 is supposed to be simple, not ultra-secure. Just don’t<br>do this at home, kids.</p>
<p>Finally, we return the address of the corresponding page table entry using the<br>index from the middle bits of <code>va</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pte_t</span> *<span class="title function_">walkpgdir</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pgtab[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mappages"><a href="#mappages" class="headerlink" title="mappages"></a>mappages</h3><p>Okay, so <code>walkpgdir()</code> returns a pointer to a page table entry and can even<br>crate a page table if if it doesn’t exist. That’s not quite enough to add new<br>mappings for pages though; the page itself might not be mapped, and if we just<br>created a new page table, then certainly none of the pages are mapped yet.<br><code>mappages()</code> will finish the job by installing mappings in page tables (possibly<br>newly-allocated ones) for a range of virtual addresses.</p>
<p>The arguments are a page directory, a virtual address for the beginning of the<br>range, the size of the range, a physical address to map it to, and the flags for<br>permissions we want to set. We start off by rounding the virtual address down to<br>the nearest page boundary and getting a pointer to the end of the range, also<br>page-aligned.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span> *) PGROUNDDOWN((uint) va);</span><br><span class="line">    <span class="type">char</span> *last = (<span class="type">char</span> *) PGROUNDDOWN(((uint) va) + size - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’re gonna iterate over the pages in that range; <code>for (;;)</code> is a common C<br>idiom for an infinite loop. In this case, we need to increment <code>a</code> and <code>pa</code> by<br><code>PGSIZE</code> each time, and we’ll break out of the loop when <code>a</code> reaches <code>last</code>. To<br>be completely honest, I’m not really sure why the authors chose to write this as<br>an infinite loop with the condition&#x2F;break statement and update statements inside<br>the loop rather than as a regular old for loop; I think the latter would be more<br>clear, but oh well, I didn’t write this.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (a == last) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inside the for loop, we’ll start each iteration by looking up the right page<br>table entry with <code>walkpgdir()</code>, with <code>alloc</code> set to true. Remember how that<br>function called <code>kalloc()</code>, which might fail, in which case it returns a null<br>pointer? Well that means we’ve gotta check for a null pointer here too. This<br>time however, we’ll return -1 for failure and 0 for success, because why not?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, a, <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re supposed to be allocating brand-new pages for this range of addresses, so<br>if a page has already been allocated, we’ll just flip out in rage and panic.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_P) &#123;</span><br><span class="line">            panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last thing before checking the loop condition and updating <code>a</code> and <code>pa</code> is<br>to install the mapping to the right physical address with the right permissions<br>in the page table. Then we’re done!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, uint size, uint pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *pte = pa | perm | PTE_P;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cool, now we have a way to map new pages into a page directory. We’re well on<br>our way to leaving poor old <code>entrypgdir</code> behind for the shiny new <code>kpgdir</code>.</p>
<h3 id="kmap"><a href="#kmap" class="headerlink" title="kmap"></a>kmap</h3><p>Each process is gonna have its own page directory, so its mappings in the lower<br>half of the virtual address space might be totally different from those of<br>another process. But the mappings in the higher half (where the kernel lives)<br>will always be the same – that way, the kernel can always use the existing page<br>directory for whatever process it happens to be running. We’ll only use <code>kpgdir</code><br>when the kernel isn’t currently running a process, e.g. while it’s running the<br>scheduler.</p>
<p>So when we create a new process, we’ll need to copy in all the mappings that the<br>kernel expects to find into a fresh page directory for that process. Those are:<br>memory-mapped I&#x2F;O device space from physical address 0 to 0x10_0000 (the boot<br>loader is also here, but we don’t need it any more), kernel code and read-only<br>data from 0x10_0000 to the physical address of <code>data</code> (one of the symbols<br>defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/kernel.ld">kernel.ld</a>), kernel data the rest of physical memory from there to<br><code>PHYSTOP</code>, and more I&#x2F;O devices from 0xFE00_0000 and up. Each of these ranges<br>needs its own permissions too.</p>
<p>We’ll represent each of these mappings with a <code>struct kmap</code>, which has fields<br>for the starting virtual address, the starting and ending physical addresses,<br>and the permissions; then the mappings will get stored in a static global<br>variable <code>kmap</code>… oh come on, what fresh hell is THIS?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *virt;</span><br><span class="line">    uint phys_start;</span><br><span class="line">    uint phys_end;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line">&#125; kmap[] = &#123;</span><br><span class="line">    &#123; (<span class="type">void</span> *)KERNBASE, <span class="number">0</span>, EXTMEM, PTE_W &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)KERNLINK, V2P(KERNLINK), V2P(data), <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)data, V2P(data), PHYSTOP, PTE_W &#125;,</span><br><span class="line">    &#123; (<span class="type">void</span> *)DEVSPACE, DEVSPACE, <span class="number">0</span>, PTE_W &#125;.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Okay, there are a few things going on here. First, the <code>static</code> keyword for a<br>variable means that variable has a single fixed location in memory that it’s<br>never gonna move out of.</p>
<p>Then it does that thing again where we simultaneously define a <code>struct</code> type and<br>define a variable of that type. So the type is</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *virt;</span><br><span class="line">    uint phys_start;</span><br><span class="line">    uint phys_end;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>So then the static global variable <code>kmap</code> is an array of <code>struct kmap</code>s. I guess<br>we ran out of names or something. The array has four entries, and since each one<br>is a <code>struct</code>, it needs curly braces around it.</p>
<p>The first entry (for the lower of the two memory-mapped I&#x2F;O device regions) has<br>a <code>virt</code> field of <code>KERNBASE</code>, a <code>phys_start</code> field of 0, a <code>phys_end</code> field of<br><code>EXTMEM</code> (defined as 0x10_0000), and permission flag <code>PTE_W</code>. So it maps a<br>virtual address range starting at <code>KERNBASE</code> to the physical address range from<br>0x0 to 0x10_0000 and makes it writeable so we can communicate with the devices<br>there. The next two entries are similar, except that the kernel code isn’t<br>writeable.</p>
<p>The last entry has <code>phys_start</code> of 0xFE00_0000 and a <code>phys_end</code> of 0. That’s a<br>little strange, but it’s because we want to map all the way up to the end of the<br>virtual address space at 0xFFFF_FFFF. The end should be one byte past that, but<br>it’s impossible to represent 0x1_0000_0000 with 32 bits. Setting the end to 0<br>makes the size calculation (<code>phys_end - phys_start</code>) work out nicely: it’ll just<br>overflow to the right number. This is okay since we’re using unsigned integers,<br>but note that <em>signed</em> integer overflow is undefined behavior and thus VERY BAD<br>and the cause of many security vulnerabilities.</p>
<p>Okay, back to getting rid of <code>entrypgdir</code>!</p>
<h3 id="setupkvm"><a href="#setupkvm" class="headerlink" title="setupkvm"></a>setupkvm</h3><p>This function sets up a fresh new page directory with all the mappings in <code>kmap</code><br>in order to please the kernel when it encounters the page directory. So needy,<br>right?</p>
<p>It takes no arguments and returns a pointer to the new page directory. First,<br>let’s allocate a page of memory to hold the new directory. We’ll be good and<br>remember to check for null (in which case we return null too) and clear the page<br>of the garbage values we wrote when we freed it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *pgdir;</span><br><span class="line">    <span class="keyword">if</span> ((pgdir = (<span class="type">pde_t</span> *) kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The upper end of virtual memory after <code>DEVSPACE</code> has I&#x2F;O devices, so <code>PHYSTOP</code><br>should be below that; this is as good a place as any to make sure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (P2V(PHYSTOP) &gt; (<span class="type">void</span> *) DEVSPACE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;PHYSTOP too high&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll add all the mappings in <code>kmap</code> above into this page directory so<br>the kernel is happy. We’ll use <code>mappages()</code>, which returns -1 if it fails, so<br>we should check for that. The <code>freevm()</code> function is defined below, and we’ll<br>get to it soon, but for now just know that it gets rid of all the mappings we<br>just made, in case any of them fails.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">setupkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> *<span class="title">k</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (k = kmap; k &lt; &amp;kmap[NELEM(kmap)]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappages(pgdir,</span><br><span class="line">                k-&gt;virt,</span><br><span class="line">                k-&gt;phys_end - k-&gt;phys_start,</span><br><span class="line">                (uint) k-&gt;phys_start,</span><br><span class="line">                k-&gt;perm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            freevm(pgdir);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pgdir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s check out that for loop: <code>k</code> is a pointer to a <code>struct kmap</code>, and <code>kmap</code><br>is an array of <code>struct kmap</code>s; in C, arrays decay to pointers, so they have the<br>same type. <code>k</code> starts off pointing to the first (zero) entry of <code>kmap</code>. Then<br>incrementing it with <code>k++</code> shifts its value by the size of a <code>struct kmap</code>, so<br>it’ll point to the next entry. The loop stops when <code>k</code> points beyond the last<br>entry of <code>kmap</code>, as determined by the <code>NELEM()</code> macro which counts the number of<br>entries in an array. Note that array element-counting only works in C if the<br>array is defined in the same function or as a global variable in the same file,<br>which is why it’s so easy to do an out-of-bounds read or write in C (yet another<br>common security vulnerability).</p>
<p>Finally, if everything worked out okay, we return a pointer to the new page<br>directory.</p>
<h3 id="switchkvm"><a href="#switchkvm" class="headerlink" title="switchkvm"></a>switchkvm</h3><p>We said above that the kernel would usually just use the page directory of the<br>currently-running process, but it’ll use <code>kpgdir</code> when no process is running,<br>i.e. during the kernel setup and while it’s scheduling a new process. So we need<br>a way to tell the paging hardware to load <code>kpgdir</code> into register <code>%cr3</code>, which<br>holds a pointer to the page directory. That’s this function.</p>
<p>It’s a one-liner: get the physical address of <code>kpgdir</code> and stick it in <code>%cr3</code><br>with the assembly instruction <code>lcr3</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchkvm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcr3(V2P(kpgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvmalloc"><a href="#kvmalloc" class="headerlink" title="kvmalloc"></a>kvmalloc</h3><p>FINALLY, we’re here! We’re gonna get rid of <code>entrypgdir</code>! The kernel’s <code>main()</code><br>calls this function right after <code>kinit1()</code>.</p>
<p>We already did all the hard work, so this one’s a breeze: we call <code>setupkvm()</code><br>to allocate a new page directory and fill it with the kernel’s mappings, then<br>call <code>switchkvm()</code> to load it into the paging hardware.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kvmalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    kpgdir = setupkvm();</span><br><span class="line">    switchkvm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And we’re DONE! Take that, <code>entrypgdir</code>, we don’t need you anymore. We’re big<br>kids now.</p>
<h2 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h2><p>So far, it’s been a serious odyssey just to move from no paging in the boot<br>loader, to super basic paging with <code>entrypgdir</code> in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/entry.S">entry.S</a>, to <code>kpgdir</code> now.<br>Along the way, we’ve looked at code to allocate and free pages and install new<br>mappings in page directories and page tables. That’ll come in handy when we look<br>at processes next; the virtual memory story still isn’t over.</p>
<p>Also, note that <code>kpgdir</code> still isn’t at the height of its powers: at the point<br>when <code>main()</code> calls <code>kvmalloc()</code>, the free list only contains pages for physical<br>memory between 0 and 4 MB. The rest will have to wait until <code>kinit2()</code> unleashes<br>its full potential. (Maybe some self-actualization seminars would help…)</p>
<h1 id="More-Paging-The-User-Side"><a href="#More-Paging-The-User-Side" class="headerlink" title="More Paging: The User Side"></a>More Paging: The User Side</h1><p>It’s almost time to turn to interrupts and processes so we can figure out how to<br>work that sweet multiprocessing magic, but unfortunately we have some last<br>pieces of paging to wrap up before we can get there.</p>
<p>I know, we’ve been talking about virtual memory for what feels like a century<br>now, but so far everything we’ve done has been on the kernel side, allocating<br>pages and creating new page directories with the same kernel mapping. But what<br>about the lower half of the virtual address space, where user processes live?</p>
<p>This post will go through the rest of<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/vm.c">vm.c</a><br>and set up the paging-related machinery we’ll need to run processes later on.</p>
<h2 id="Detour-Starting-a-New-Process"><a href="#Detour-Starting-a-New-Process" class="headerlink" title="Detour: Starting a New Process"></a>Detour: Starting a New Process</h2><p>When xv6 runs a new process, it will create a brand new virtual memory space for<br>it with a fresh page directory. We haven’t talked about processes in xv6 yet, so<br>you might wonder how a process gets started up in the first place.</p>
<p>Let’s forget all about xv6 for a second and think about another Unix-like OS:<br>Linux. How do we start a process there? Okay, we also have to forget about GUI<br>applications there. Let’s just say you want to run some C code (xv6 maybe?) that<br>you’ve just compiled; what happens when you run it from the terminal?</p>
<p>Hopefully, you’ve done the OSTEP project called <a target="_blank" rel="noopener" href="https://github.com/remzi-arpacidusseau/ostep-projects/tree/master/processes-shell">processes-shell</a><br>by now, so you know the answer; if you haven’t, I recommend doing that one right<br>now before I give it away. (It’s not strictly required, but are you really the<br>kind of person who loves getting movies spoiled for them?)</p>
<p>Okay, are you done?</p>
<p>The answer: it’s just an <code>exec()</code> system call! The shell finds the executable<br>file in the file system, calls <code>fork()</code> to create a new child process, which<br>then calls <code>exec()</code> to transform itself into the program you want to run.</p>
<p>We’ll get to these system calls later, so for now let’s just go over the broad<br>strokes as they relate to virtual memory. <code>fork()</code> works by taking the parent<br>process’s virtual memory space and making a copy of it for the child process.</p>
<p><code>exec()</code> allocates a new page directory, figures out how much memory the new<br>program will need when it runs, then grows the virtual memory space allocated in<br>that new page directory to the required size. Then it loads the program into<br>memory in the new page directory.</p>
<p>Next, <code>exec()</code> skips a page, leaving it mapped but user-inaccessible; then the<br>next page becomes the process’s stack. Why that empty page? It’s an important<br>one for protection: that way, user programs that blow their stack will trigger a<br>page fault or a general protection fault instead of possibly overwriting random<br>code.</p>
<p>Then <code>exec()</code> copies some arguments into the stack before it switches to using<br>the new page directory and gets rid of the old one it had before.</p>
<p>Whew, okay, that’s a lot of code to go over later, and that’s only the virtual<br>memory part of the story. So let’s just make it easier by doing all the work we<br>can right now. According to the above, we have to understand how xv6 does all of<br>the following:</p>
<ul>
<li>Makes a copy of a whole page directory,</li>
<li>Creates a new page directory,</li>
<li>Grows (or shrinks) the virtual memory space of a page directory,</li>
<li>Loads program code into a page directory,</li>
<li>Makes a page inaccessible to users,</li>
<li>Copies stuff into a page in a page directory,</li>
<li>Switches to a new process page directory, and</li>
<li>Gets rid of an unused page directory.</li>
</ul>
<p>Finally, there’s one edge case to think about: running the very first process.<br>We obviously need to start running a shell at some point, so we need a special<br>way to get that started too, so it can in turn run other processes.</p>
<h2 id="vm-c-Again"><a href="#vm-c-Again" class="headerlink" title="vm.c, Again"></a>vm.c, Again</h2><p>We’re gonna need some new functions! Actually, we already finished one of the<br>requirements – <code>setupkvm()</code> can allocate a new page directory and set up the<br>kernel portion too. <code>switchkvm()</code> lets us switch to using <code>kpgdir</code> as a page<br>directory, but now we need to switch <em>away</em> from that to a page directory for a<br>process, so that’ll be <code>switchuvm()</code>.</p>
<p><code>copyuvm()</code> creates a copy of an entire page directory for a child process.<br><code>allocuvm()</code> and <code>deallocuvm()</code> grow and shrink the virtual memory space that’s<br>allocated in a page directory, and <code>freevm()</code> clears a page directory we no<br>longer need.</p>
<p><code>loaduvm()</code> will load program code into a page directory; <code>clearpteu</code> makes a<br>page inaccessible to users, and <code>copyout()</code> copies data into a page in a page<br>directory. <code>inituvm()</code> handles the special case of setting up the page directory<br>for the very first process that xv6 will run.</p>
<p>The rest of this post will go over those functions one by one so we can be done<br>with virtual memory, but I know it’s a little strange to go through a million<br>helper functions when we haven’t seen the code that’s gonna use them yet, so if<br>you’d prefer, you can come back to this after reading about processes and system<br>calls.</p>
<h3 id="deallocuvm"><a href="#deallocuvm" class="headerlink" title="deallocuvm"></a>deallocuvm</h3><p>The arguments for this function are a page directory, the process’s old size,<br>and the new size we want to shrink it down to; it’ll return the process’s new<br>size. By “shrinking” a virtual memory space, we really mean making sure that the<br>page directory only allocates up to <code>newsz</code> worth of pages. So if we think of<br>the sizes as virtual addresses, then the page directory currently maps the<br>virtual space from 0 to <code>oldsz</code>, so we should free everything between <code>newsz</code><br>and <code>oldsz</code>, leaving behind the space from 0 to <code>newsz</code>.</p>
<p>First, we should make sure the new size is actually smaller than the old one;<br>otherwise trying to “shrink” down to the new size might cause integer overflow.<br>There; the sizes are both unsigned integers here, so at least it wouldn’t be<br>that scary boogeyman of undefined behavior, but it could still be bad: 0 would<br>wrap around to 2^32 - 1, so “shrinking” to the new size would actually grow the<br>process way beyond what physical memory could handle.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newsz &gt;= oldsz) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re gonna shrink the physical memory allocated to this page directory by<br>freeing pages until we reach the new size. Let’s start with the first page above<br><code>newsz</code>; we can get its virtual address by rounding up <code>newsz</code> to a page<br>boundary.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint a = PGROUNDUP(newsz);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll just iterate over the pages between <code>a</code> and <code>oldsz</code> one at a time and<br>free them. This is a little tricky: <code>kfree()</code> takes a virtual address (cast to a<br><code>char *</code>), but it should be a <em>kernel</em> virtual address in the higher half, not a<br>user virtual address. Luckily, we already have <code>walkpgdir()</code>, which can take an<br>arbitrary virtual address and return its page table entry, so that’s a good<br>start.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walkpgdir(pgdir, (<span class="type">char</span> *) a, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The page table entry contains the page’s physical address, plus some flags to<br>determine whether it’s mapped and what permissions are set for it.</p>
<p>Now, a virtual address space isn’t laid out contiguously. Think about it: if you<br>sit back and imagine a user process hanging out in memory, what does that<br>address space look like? You’re probably imagining the stack at one end of<br>memory and the heap at the other, with each growing toward the center, right?<br>so there will be some pages in the center that aren’t mapped; some of the page<br>tables might not exist either, in which case <code>walkpgdir()</code> would return a null<br>pointer.</p>
<p>Remember we agreed to never dereference null pointers? Yeah, so we’ll have to<br>skip all those unmapped pages. If we got a null pointer, then that means the<br>entire page table doesn’t exist, so we need to skip forward to the next page<br>directory entry (and thus the next page table). We’ll have to move <code>a</code> to the<br>virtual address that corresponds to that next page directory entry.</p>
<p>We can get the page directory index from <code>a</code> with the <code>PDX()</code> macro we’ve seen<br>seen before, and then just add 1 to get the next entry in the page directory.<br>Now we need to turn that back into a virtual address. We’ll use a new macro,<br><code>PGADDR()</code> (also from <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>),<br>to do that. So then we’ll continue to the next loop iteration, which will get<br>the page table entry for this new virtual address.</p>
<p>Wait wait wait, one last thing! After all that, <code>a</code> should now be the first<br>virtual address in the page table for the new page directory entry… except<br>it’s get <code>PGSIZE</code> added to it because of the for loop’s update statement.</p>
<p>Ugh, okay, fine, this is annoying. Let’s just fix it with a hack: subtract<br><code>PGSIZE</code> from it now, so that it gets incremented to the right value in the next<br>iteration. Okay, that’s it, I swear!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walkpgdir(pgdir, (<span class="type">char</span> *) a, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            a = PGADDR(PDX(a) + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) - PGSIZE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now the else branch: if we don’t get a null pointer then at least the page<br>table exists, but that doesn’t mean the page itself is mapped. If it’s not, then<br>we don’t need to do anything else, but if it is mapped, then we need to free it.<br>We can get the page’s physical address out of the page table entry with the<br><code>PTE_ADDR</code> macro then make sure it’s not null.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            uint pa = PTE_ADDR(*pte);</span><br><span class="line">            <span class="keyword">if</span> (pa == <span class="number">0</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The whole point of this was to be able to call <code>kfree()</code>, remember? So let’s<br>convert <code>pa</code> to a kernel virtual address as a <code>char *</code> and free it. Then after<br>the loop is done, we’ll return the new size.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deallocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; oldsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="type">char</span> *v = P2V(pa);</span><br><span class="line">            kfree(v);</span><br><span class="line">            *pte = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocuvm"><a href="#allocuvm" class="headerlink" title="allocuvm"></a>allocuvm</h3><p>This is the reverse of <code>deallocuvm()</code>: instead of freeing pages with <code>kfree()</code>,<br>we’ll allocate them with <code>kalloc()</code>. Here too, we start by checking for integer<br>overflow by making sure <code>newsz</code> really is larger than <code>oldsz</code>. But now we also<br>have to check that we’re not gonna grow the process’s size into the region where<br>it could access kernel memory; otherwise it might read or modify arbitrary<br>physical memory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newsz &gt;= KERNBASE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newsz &lt; oldsz) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldsz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re gonna start adding new pages right after <code>oldsz</code>, so we have to align that<br>to a page boundary:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uint a = PGROUNDUP(oldsz);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The for loop is easier this time around because we already know that the pages<br>aren’t mapped. First we allocate a new page. Any call to <code>kalloc()</code> needs two<br>things after, remember? We have to check for null, in which case we print an<br>error message to the console (that’s <code>cprintf()</code>; we’ll get to that in the<br>devices section), then undo any allocations we made and return 0. Then we have<br>to zero the page because we filled it with 1s when it was freed.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="type">char</span> *mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;allocuvm out of memory\n&quot;</span>);</span><br><span class="line">            deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We have a page now, but it’s not yet mapped in the page directory. We can do<br>that with <code>mappages()</code>; that might fail too (because it needs to allocate more<br>pages for the page tables), in which case we do the same as before. Then after<br>the for loop is done, we return the new size.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span>, uint oldsz, uint newsz) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (; a &lt; newsz; a += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappages(pgdir, (<span class="type">char</span> *) a, PGSIZE, V2P(mem), PTE_W | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;allocuvm out of memory (2)\n&quot;</span>);</span><br><span class="line">            deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freevm"><a href="#freevm" class="headerlink" title="freevm"></a>freevm</h3><p>This function will get rid of a user page directory that we no longer need. Now<br>that we have <code>deallocuvm()</code>, it’s easy: we just “shrink” the process to a size<br>of zero. Oh and we’ll remember the lessons our ancestors have taught us and make<br>sure the pointer to the page directory isn’t null before dereferencing it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pgdir == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;freevm: no pgdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    deallocuvm(pgdir, KERNBASE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Great, so all pages are freed, and we’re done!</p>
<p>Now hang on a sec… The page directory itself resides in memory; so do the page<br>tables. We have to free those too. We’ll start with the page tables; freeing the<br>page directory first would be a use-after-free vulnerability because we’d need<br>to use it to get to the page tables.</p>
<p>We’ll iterate over the page directory’s entries, checking whether each one has<br>the “present” flag set (<code>NPDENTRIES</code> is defined as 1024 in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/types.h">mmu.h</a>).<br>If it does, we’ll get the page table’s physical address from it with the<br><code>PTE_ADDR()</code> macro, then convert that to a virtual address as a <code>char *</code> to make<br><code>kfree()</code> happy. We don’t have to worry about clearing the “present” flag in the<br>page directory because it’s about to be freed anyway.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; NPDENTRIES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pgdir[i] &amp; PTE_P) &#123;</span><br><span class="line">            <span class="type">char</span> *v = P2V(PTE_ADDR(pgdir[i]));</span><br><span class="line">            kfree(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We wrap up by freeing the page directory itself.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freevm</span><span class="params">(<span class="type">pde_t</span> *pgdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    kfree((<span class="type">char</span> *) pgdir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copyuvm"><a href="#copyuvm" class="headerlink" title="copyuvm"></a>copyuvm</h3><p>The <code>fork()</code> system call will need to “clone” a process, which includes its<br>virtual address space. This function takes a pointer to the parent process’s<br>page directory and the size of the parent process’s address space and returns a<br>pointer to a fresh new page directory with everything set up exactly the same.</p>
<p>We start by creating a new page directory and taking care of the kernel’s half<br>of the address space with <code>setupkvm()</code>. That might fail if it can’t allocate a<br>new page, so we have to check for null. Sigh. C code is approximately 40%<br>checking for null return values.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pde_t</span> *d;</span><br><span class="line">    <span class="keyword">if</span> ((d = setupkvm()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll iterate over the user portion of the parent process’s address space<br>from 0 to <code>sz</code>, copying everything over as we go. Say we want to copy a page<br>from the parent’s virtual address <code>i</code> to the child’s address <code>i</code> (note that<br>they’ll map to different physical addresses). We’ll have to figure out the<br>corresponding kernel virtual address for the parent’s <code>i</code> in order to do that,<br>so we use <code>walkpgdir()</code> to get the page table entry, then get the page’s<br>physical address.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, (<span class="type">void</span> *) i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;copyuvm: pte should exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; PTE_P)) &#123;</span><br><span class="line">            panic(<span class="string">&quot;copyuvm: page not present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint pa = PTE_ADDR(*pte);</span><br><span class="line">        uint flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case we know the parent process is already set up, so we don’t really<br>have to worry about <code>walkpgdir()</code> failing and returning null, but it’s bad C<br>juju to ignore a possibly-null return value, so we just panic if it does fail or<br>if the page isn’t present.</p>
<p>Next we allocate a page for the child process (checking for null again…) and<br>copy everything from the parent’s page to the new child page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">char</span> *mem;</span><br><span class="line">        <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">        memmove(mem, (<span class="type">char</span> *) P2V(pa), PGSIZE);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might recognize <code>memmove()</code> as a C standard library function that copies the<br>contents of one memory address into another, but we can’t use those, remember?<br>So xv6 provides its own implementation of it in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>.</p>
<p>If you haven’t seen a <code>goto</code> statement before, it’s basically a holdover from ye<br>olde days before Edsger Dijkstra preached the gospel of structured programming<br>to the world and invented the if statement. It does exactly what it sounds like:<br>you make a label somewhere in code and it takes you there.</p>
<p>Next we stick that new page into the child’s page directory, checking for null<br>again. If <code>mappages()</code> fails, then the new page won’t be in the page directory,<br>so we have to free it here or else we’ll never be able to find it again: a<br>memory leak.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (mappages(d, (<span class="type">void</span> *) i, PGSIZE, V2P(mem), flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If none of the allocations failed, we just return a pointer to the new page<br>directory. But if something went wrong, then one of those <code>goto</code> statements will<br>send us to the time out corner of <code>bad</code>, where we undo all our work by freeing<br>the page directory and returning a null pointer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *<span class="title function_">copyuvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    freevm(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Great, another function we’ll have to check for null.</p>
<h3 id="switchuvm"><a href="#switchuvm" class="headerlink" title="switchuvm"></a>switchuvm</h3><p>Okay, we’ve got a way to create a new process page directory. We also have a way<br>to switch to using the kernel page directory <code>kpgdir</code> with <code>switchkvm()</code>. But we<br>need a way to switch to using the process page directory too. Enter <code>switchuvm()</code>.</p>
<p>I’ll warn you – <code>switchkvm()</code> was nice and short, but <code>switchuvm()</code> is an ugly<br>one for sure.</p>
<p>The argument to this function is a pointer to a <code>struct proc</code>, which represents<br>a process. We’ll talk about that more when we get to processes; two fields are<br>important now: <code>p-&gt;kstack</code> which holds a pointer to the kernel stack for that<br>process, and <code>p-&gt;pgdir</code>, which points to that process’s page directory.</p>
<p>Okay, well let’s start with some sanity checks to make sure that the process <code>p</code><br>actually exists (the pointer is non-null) and its kernel stack and page directory<br>pointers are non-null too.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no process&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kstack == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kstack == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The main function of loading the process’s page directory will be the same as in<br><code>switchkvm()</code>: just an <code>lcr3</code> instruction. But the difference now is that the<br>x86 architecture requires some additional bookkeeping for processes.</p>
<p>See, when the kernel runs a new process, the CPU will start executing different<br>instructions. But it needs a way to keep track of where it left off in the<br>kernel code so that it can pick the thread back up after the process is done<br>executing. Similarly, interrupts and system calls might change the running<br>process, so the CPU needs to record some metadata about the process’s state too<br>before switching to another one. x86 does that by means of a structure called a<br><em>Task State Segment</em>, or TSS.</p>
<p>The TSS holds information like the current state of certain registers (e.g.,<br><code>%esp</code>, <code>%eip</code>, <code>%cr3</code>, etc.), segment descriptors (<code>%cs</code>, <code>%ss</code>, <code>%ds</code>, etc.),<br>the current privilege leve, and I&#x2F;O privilege levels – in other words, the<br>process’s <em>context</em>. It can be located anywhere in memory, but the processor<br>needs to find it, so it uses an entry in the GDT called the TSS segment<br>descriptor that points to the TSS. Remember the GDT from way back when we were<br>talking about segmentation? Good times. The CPU holds a pointer to the GDT’s TSS<br>entry in a special register called the task register.</p>
<p>Back in the segmentation days of our youth, we stored the GDT in a <code>struct cpu</code><br>that held information about the current processor. We got that <code>struct cpu</code> by<br>calling a <code>mycpu()</code> function. We’re gonna do the same thing here in order to<br>update the GDT with a segment for the TSS. Getting interrupted in the middle of<br>this might be disastrous: the TSS would be half-updated, so who knows what would<br>happen when the CPU tried to resume execution where it last left off. So we’ll<br>use the <code>pushcli()</code> and <code>popcli()</code> functions we saw with spin-locks to temporarily<br>disable interrupts.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    mycpu()-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;mycpu()-&gt;ts, <span class="keyword">sizeof</span>(mycpu()-&gt;ts)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    mycpu()-&gt;gdt[SEG_TSS].s = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whoa okay what is this?</p>
<p>We’ve seen the <code>SEG()</code> and <code>SEG_ASM()</code> macros before; they created GDT segments.<br><code>SEG16()</code> does the same with 16 bits (it’s defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>). <code>STS_T32A</code><br>is a flag that sets the segment’s type as an available 32-bit TSS. Then we pass<br>in a pointer to the task state with <code>&amp;mycpu()-&gt;ts</code>, its size, and a descriptor<br>privilege level of 0 (which means ring 0, the kernel level). The GDT’s <code>.s</code><br>field is a one-bit flag to determine whether this is a system or application<br>segment, so we set it to system.</p>
<p>Okay, so now the GDT points to the task state. Next we need to update the task<br>state, then load it into the CPU. We’ll start by storing a segment selector and<br>the stack pointer in the task state; these should look familiar from the boot<br>loader and <code>seginit()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mycpu()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    mycpu()-&gt;ts.esp0 = (uint) p-&gt;kstack + KSTACKSIZE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The TSS can also specify permissions for accessing I&#x2F;O ports: for example,<br>setting the I&#x2F;O privilege level to 0 in the <code>eflags</code> register <em>and</em> setting a<br>part of the TSS called the I&#x2F;O map base address to an address beyond the TSS<br>segment forbids I&#x2F;O instructions like <code>inb</code> and <code>outb</code> from user space. So we’ll<br>set the I&#x2F;O map base address next.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mycpu()-&gt;ts.iomb = (ushort) <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So now we have a GDT entry pointing to the TSS, which is now updated. Now we<br>just load it into the task register with the x86 instruction <code>ltr</code>; here we use<br>a C wrapper for that assembly instruction, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ltr(SEG_TSS &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, the last thing we do before re-enabling interrupts is to load the<br>process’s page directory into the <code>%cr3</code> register so we can start using it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lcr3(V2P(p-&gt;pgdir));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loaduvm"><a href="#loaduvm" class="headerlink" title="loaduvm"></a>loaduvm</h3><p>Okay, this is another function that’s gonna require extra info we haven’t seen<br>yet, but I’m gonna make it a bit easier by waving my hands around and glossing<br>over the details. It’s gonna read a program from a file into memory at virtual<br>address <code>addr</code> using page directory <code>pgdir</code>. The part we want to read has size<br><code>sz</code> and is located at position <code>offset</code> within the file.</p>
<p>Now, what about the file? We’ll talk more when we get to the file system code,<br>but for now let’s just say that files are represented in xv6 as <code>struct inode</code>s,<br>and we can read from them with the function <code>readi()</code>.</p>
<p>We’re gonna run the program from this code, so the address it’s stored in needs<br>to be page-aligned.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((uint) addr % PGSIZE != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;loaduvm: addr must be page aligned&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’re gonna iterate over pages starting from <code>addr</code>, reading from the file<br>in <code>ip</code> into that page. As usual, we’ll need to get the kernel virtual address<br>from the user address <code>addr</code>, so we start by getting the page table entry via<br><code>walkpgdir()</code>, checking for a null pointer if the corresponding page table<br>doesn’t exist. Then we can turn that into a physical address.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// Get the page table entry</span></span><br><span class="line">        <span class="type">pte_t</span> *pte;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walkpgdir(pgdir, addr + i, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;loaduvm: address should exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get the page&#x27;s physical address</span></span><br><span class="line">        uint pa = PTE_ADDR(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we want to read from the file one page at a time using <code>readi()</code>, which<br>takes a pointer to an inode (here, <code>ip</code>), a kernel virtual address (<code>P2V(pa)</code>),<br>the location within the file of the segment we want to read (<code>offset + i</code>), and<br>the segment’s size.</p>
<p>Now we want to read from the file one page at a time using <code>readi()</code>. We have to<br>specify a size in bytes to read; if the remaining unread part of the segment is<br>larger than a page, then the size we pass to <code>readi()</code> should be <code>PGSIZE</code>, but<br>otherwise it’ll be less. So we’ll compare <code>sz</code> to <code>i</code> and define define <code>n</code><br>accordingly.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        uint n;</span><br><span class="line">        <span class="keyword">if</span> (sz - i &lt; PGSIZE) &#123;</span><br><span class="line">            n = sz - i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n = PGSIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The other arguments to <code>readi()</code> are a pointer to an inode (<code>ip</code>), a kernel<br>virtual address (<code>P2V(pa)</code>), and the location within the file of the segment we<br>want to read (<code>offset + i</code>). It returns the number of bytes read, so if it’s not<br><code>n</code> we’ll report an error by returning -1. Otherwise we return 0 after the for<br>loop is done.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">loaduvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (readi(ip, P2V(pa), offset + i, n) != n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inituvm"><a href="#inituvm" class="headerlink" title="inituvm"></a>inituvm</h3><p>Okay, the next three are nice and easy! This next one is pretty similar to<br><code>loaduvm()</code>, except instead of loading program code from disk, it copies it in<br>from memory. We’ll take <code>sz</code> bytes from a source address of <code>init</code> and stick it<br>in address 0 of the process’s page directory <code>pgdir</code>.</p>
<p>This function is also easier because we’re only gonna call it for programs that<br>are less than one page in size, so we don’t have to worry about looping over<br>pages or anything like that. I like it when xv6 keeps things simple.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sz &gt;= PGSIZE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we allocate a fresh page of memory, zero it to clear the garbage values,<br>and stick it into <code>pgdir</code> at address 0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> *mem = kalloc();</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    mappages(pgdir, <span class="number">0</span>, PGSIZE, V2P(mem), PTE_W | PTE_U);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And we wrap up by actually loading the code from <code>init</code> into the new page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inituvm</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *init, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    memmove(mem, init, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clearpteu"><a href="#clearpteu" class="headerlink" title="clearpteu"></a>clearpteu</h3><p>This function takes a page directory and a user virtual address and clears the<br>“user-accessible” flag so that the process can’t touch it. It’s used to create<br>an inaccessible page below a new process’s stack to guard against stack<br>overflows; this way, a stack overflow will cause a page fault instead of<br>silently overwriting memory.</p>
<p>The <code>PTE_U</code> flag is in the page table entry, so we’ll have to get that, then set<br>the flag.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearpteu</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *uva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the page table entry</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = walkpgdir(pgdir, uva, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;clearpteu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Clear the user permission flag</span></span><br><span class="line">    *pte &amp;= ~PTE_U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here <code>&amp;</code> is a bitwise-AND and <code>~</code> is a bitwise-NOT; for reference, <code>|</code> is<br>bitwise-OR and <code>^</code> is bitwise-XOR. Contrast these with their logical versions,<br><code>&amp;&amp;</code>, <code>!</code>, and <code>||</code> (XOR has no logical version). C also has corresponding<br>assignment operators (similar to <code>+=</code>, <code>-=</code>, <code>*=</code>, etc.) for each of them. So<br>the last line of code is equivalent to <code>*pte = *pte &amp; (~PTE_U)</code>.</p>
<h3 id="uva2ka"><a href="#uva2ka" class="headerlink" title="uva2ka"></a>uva2ka</h3><p>We often need to convert user virtual addresses to kernel ones; <code>uva2ka()</code> is a<br>short helper function that does that while checking that the page is actually<br>present and has the user permission flag set.</p>
<p>We’ll call walkpgdir to get the page table entry, then check both permission<br>bits before recovering the page address with <code>PTE_ADDR()</code> and converting it to a<br>kernel virtual address. We’ll return the kernel virtual address as a <code>char *</code>,<br>or null if either flag is not set.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">uva2ka</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">char</span> *uva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walkpgdir(pgdir, uva, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_P) == <span class="number">0</span>) &#123;  <span class="comment">// check that it&#x27;s present</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span>) &#123;  <span class="comment">// check that it&#x27;s user-accessible</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> *) P2V(PTE_ADDR(*pte));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let me ask you a weird question: how are you feeling right now?</p>
<p>Okay, that was a test of your C coding practices, because if you took those null<br>checks to heart, you should be <em>really</em> uncomfortable right about now.</p>
<p>Check it out: <code>walkpgdir()</code> returns a pointer to the page table entry. <em>Any</em><br>time a function returns a pointer, you should immediately ask yourself whether<br>that function can return a null pointer. Tons of C functions report an error by<br>returning null. In this case, we <em>know</em> <code>walkpgdir()</code> can fail and report null<br>if the page table doesn’t exist, so we <em>know</em> we might get a null pointer out of<br>it – it’ll happen whenever a page table doesn’t exist. So what do we do with<br>that knowledge?</p>
<p>Why, we go right ahead and dereference that pointer. WKBW;NQ39Q2A4T8YHMFGRW!!!</p>
<p>Dereferencing a null pointer is undefined behavior. There’s literally no telling<br>what might happen. It can cause all kinds of bugs from segmentation faults to<br>security vulnerabilities.</p>
<p>All those null checks in the other functions serve a purpose: if something goes<br>wrong and a function returns a null pointer, they catch it before it gets<br>dereferenced, then either handle it gracefully or simply propagate the error by<br>returning null (or some other error code) and let the caller figure out what to<br>do with it.</p>
<p>Omitting a check for a null pointer like <code>uva2ka()</code> does is bad practice in C<br>because it means the programmer has to <em>guarantee</em> – by manually checking –<br>that no call to this function could <em>ever possibly</em> cause a null return value.<br>Except humans are dumb, dumb creatures who make mistakes all the time, especially<br>in big projects: there’s no way you’d be able to remember that tiny little<br>detail two years later when you decide to refactor your code or add a new<br>feature or something.</p>
<p>But maybe you can note that in the comments? Okay yeah, but think about it: how<br>often do you go and look up the source code for every single function you call?<br>Yeah, I thought so.</p>
<p>This is why C is so dangerous: there are hundreds of such problems that you need<br>to be aware of and remember to add stuff like null pointer checks to your code.<br>If you don’t because you’re a normal human who forgets things sometimes, then<br>you’ll need to remember that you forgot to do it before and manually check every<br>single call to your code and think about every possible edge case that a<br>malicious adversary might exploit.</p>
<p>Good thing no one ever makes these mistakes in C, or we’d see enormous security<br>vulnerabilities being reported every single day in all kinds of critical<br>software. Oh wait…</p>
<p>So if you ever find yourself looking at C during code review and you come across<br>a function that returns a pointer, you should stop what you’re doing and look up<br>the documentation for that function. If that function has any chance of<br>returning a null pointer, then you should yell and kick and scream until somebody<br>adds a null check and figures out how they want to handle it if it’s null. Is<br>this annoying? Yes. Hard to remember? Yes. But that’s C. <em>(cough cough use Rust<br>instead cough cough…)</em></p>
<p>Now, the xv6 authors are so awesome that I’m gonna give them the benefit of the<br>doubt and assume they left it off because they hand-checked every call to make<br>sure it would never be an issue. But you and me? Nah.</p>
<p>The point of my rant is this: if you’re reading this, then you’re probably gonna<br>find yourself hacking away at xv6 for a project sooner or later. When you do<br>that, you should treat this function as VERBOTEN. You’re not allowed to touch<br>it or call it, at least until you add a null check to it yourself.</p>
<p>The same goes for any functions that call this one, because maybe all the<br>existing calls to <code>uva2ka()</code> are fine right now, but then you make some tiny<br>change and now it’s no longer guaranteed to never be null. For reference, this<br>function currently only gets called by <code>copyout()</code>, and that one only gets<br>called by <code>exec()</code>. <code>exec()</code> gets called by <code>sys_exec()</code>, the shell, and the<br>initial user-space program <code>init</code>. So be careful if you touch any of those.</p>
<p>Whew, okay, &#x2F;rant.</p>
<h3 id="copyout"><a href="#copyout" class="headerlink" title="copyout"></a>copyout</h3><p>This function copies <code>len</code> bytes of data from a kernel virtual address <code>p</code> to a<br>user virtual address <code>va</code> using page directory <code>pgdir</code>. <code>exec()</code> will use this<br>to copy command-line arguments to the stack for a program it’s about to run.</p>
<p>You might be wondering why it’s needed – doesn’t <code>memmove()</code> do the same thing?<br>Almost, but the difficulty is that <code>pgdir</code> may not be the current page<br>directory, so we’ll have to manually translate the virtual address <code>va</code>. That’s<br>where <code>uva2ka()</code> comes in, plus it ensures that the page for <code>va</code> has the right<br>flags set. <em>Then</em> we can use <code>memmove()</code>.</p>
<p>First, <code>p</code> will be the source address, but <code>memmove()</code> requires a <code>char *</code> in<br>order to copy data byte-by-byte, so let’s convert it now:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to get the kernel virtual address corresponding to <code>va</code>, but<br>there’s a challenge: what if the data crosses a page table boundary? It might be<br>spread across separate locations in physical memory (and thus in kernel virtual<br>memory too). So we’ll need a loop in which each iteration gets the next kernel<br>virtual address and copies whatever part of the data is in this page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        len -= n;</span><br><span class="line">        buf += n;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So we’ll start each iteration by making <code>va0</code> the base address of the page <code>va</code><br>is on and <code>pa0</code> the kernel address of <code>va0</code>, converted with <code>uva2ka()</code>. I…<br>honestly don’t know why they used <code>pa0</code> as an identifier here. It makes it look<br>like it should be a physical address, but it’s not; it’s a kernel virtual<br>address. Sigh. Anyway, the call to <code>uva2ka()</code> might fail if the page isn’t<br>present or it doesn’t have a user permission bit, so we have to check for a null<br>pointer and return -1 if we find one.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        uint va0 = (uint) PGROUNDDOWN(va);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *pa0 = uva2ka(pgdir, (<span class="type">char</span> *) va0);</span><br><span class="line">        <span class="keyword">if</span> (pa0 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        va = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now <code>va</code> is in between <code>va0</code> and the next page, so the length of the data within<br>this page is <code>PGSIZE - (va - va0)</code>, unless it’s the last page, in which case we<br>should pick the lesser of this value and <code>len</code> (since <code>len</code> gets decremented on<br>each iteration through the loop).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        uint n = PGSIZE - (va - va0);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we copy the data from <code>buf</code> into the target kernel virtual address for<br><code>va</code>. Hmm, we don’t have that yet. Oh wait, <code>pa0</code> is the kernel virtual address<br>for <code>va0</code>, and <code>va</code> is just <code>va-va0</code> bytes after that, so we’ll use it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint va, <span class="type">void</span> *p, uint len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        memmove(pa0 + (va - va0), buf, n);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We return 0 if everything went okay.</p>
<h2 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h2><p>Okay, that was a lot of helper functions, but we’re ALL DONE with virtual<br>memory! From now on, we have all the tools we’ll need to manage memory and set<br>up virtual address spaces for new processes.</p>
<h1 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h1><p>It’s time to turn our attention to processes in xv6!<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.c">proc.c</a> is another<br>huge file, so I’m gonna split it up into a few posts. This one will focus on the<br>basic functions we’ll need in order to create new processes; later posts will<br>go over scheduling and system calls.</p>
<h2 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a>proc.h</h2><p>I haven’t spent much time on the header files in xv6, but<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/proc.h">proc.h</a> defines some<br>important structures we’re gonna be using often, so let’s just get those out of<br>the way first.</p>
<p>Let’s start off with the definition for <code>struct context</code>. The processor will<br>have to switch between different processes during interrupts, system calls,<br>exceptions, etc.; these <em>context switches</em> will require saving the contents of<br>some of the CPU registers so that it can reload them when it switches back and<br>resume execution where it left off. It’ll save the process’s context by pushing<br>those register contents on the stack; that way the stack pointer is effectively<br>a pointer to the context. So the fields of a <code>struct context</code> will just list all<br>the registers that were saved on the stack.</p>
<p>Now, which registers do we need to save? Let’s look at the full list on the<br><a target="_blank" rel="noopener" href="https://wiki.osdev.org/CPU_Registers_x86">OSDev Wiki</a>. We’ve got some general-<br>purpose registers, the instruction pointer register <code>%eip</code>, segment registers,<br>a flags register, control registers, and the GDT and IDT registers (x86 doesn’t<br>use the debug, test, or LDT registers).</p>
<p>The flags register, control registers, and GDT&#x2F;IDT registers shouldn’t change<br>between processes, so we don’t need to save those. What about the segment<br>registers like <code>%cs</code>? Back when we set up segmentation, we made the segments be<br>identity maps that would always stay the same for all processes. There are<br>separate segments for user mode and kernel mode, but context switches will<br>always occur in kernel mode, so the segment registers shouldn’t change, and we<br>don’t need to save them either.</p>
<p>We should definitely save the program counter (AKA instruction pointer <code>%eip</code>),<br>since that will point to the place in the code where we should resume execution.</p>
<p>The only ones left now are the general-purpose registers: the stack base pointer<br><code>%ebp</code> and stack pointer <code>%esp</code>, along with <code>%eax</code>, <code>%ebx</code>, <code>%ecx</code>, <code>%edx</code>,<br><code>%esi</code>, and <code>%edi</code>. We said above that the stack pointer <code>%esp</code> would tell us<br>where to find the context, so that must mean we’ll already have it through some<br>other means in order to find the rest of the context, so we don’t need to save<br>it again (we’ll see how we end up getting it later on). But we do need to save<br><code>%ebp</code>.</p>
<p>There’s an x86 convention that the caller of a function has to save <code>%eax</code>,<br><code>%ecx</code>, and <code>%edx</code>, so those are already taken care of. So we’ll just save the<br>others: <code>%edi</code>, <code>%esi</code>, and <code>%ebx</code>.</p>
<p>We end up with this list of saved registers as the fields for <code>struct context</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    uint edi;</span><br><span class="line">    uint esi;</span><br><span class="line">    uint ebx;</span><br><span class="line">    uint ebp;</span><br><span class="line">    uip eip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Next up: we might end up with a bunch of processes, some of which are currently<br>running while others aren’t. Let’s set up some labels to note that. We’ll<br>definitely need a <code>RUNNING</code> label; we’ll also use one called <code>RUNNABLE</code> for<br>processes that are ready to be run the next time there’s a free CPU. We also<br>need a label for processes that are blocked waiting for something else to happen<br>(e.g., I&#x2F;O); xv6 calls this <code>SLEEPING</code>. Processes that don’t exist yet will be<br>called <code>UNUSED</code>.</p>
<p>There are two special moments in a process’s lifecycle that we should be careful<br>with: birth and death. When we create a new process, we’ll have to do a bunch of<br>setup before it’s <code>RUNNABLE</code>; killing a process requires clean-up before it goes<br>back to <code>UNUSED</code>. We’ll call those <code>EMBRYO</code> and <code>ZOMBIE</code>, respectively.</p>
<p>We could use bit flags for these states or just regular integers, except then<br>we’d have to do annoying bit arithmetic or keep track of which number represents<br>which state. And yes, we could use a bunch of <code>#define</code> directives for the<br>preprocessor for that, but there’s a better way to do it. C lets us create data<br>types for labels using <code>enum</code>s. These don’t have fields like <code>struct</code>s do;<br>they’re basically just a mapping between integers and what the labels those<br>integers represent. So it’s pretty similar to using a bunch of <code>#define</code><br>directives, except that they’re all defined neatly in a single place, so it<br>helps us remember they’re all representing the same idea. So we’ll use an <code>enum</code><br>like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Now it’s time to look at how we’ll represent processes themselves together with<br>their metadata. Let’s see… what kind of unique data does each process have?<br>We just talked about <code>struct context</code>s and <code>enum procstate</code>s; each process will<br>have both of those.</p>
<p>We also talked about virtual memory for processes in a previous post, so it<br>should also have its own page directory and stack for the kernel to use, plus a<br>way to track the size of its virtual address space. We said then that processes<br>are created using <code>fork()</code>, so let’s add a field to point to the parent process.</p>
<p>We’ll need a way for the kernel to refer to a process, so let’s give it a unique<br>process ID. That’s not super helpful when it comes to debugging, so let’s also<br>add a name for it as a string.</p>
<p>The rest of the fields are for aspects we haven’t seen yet but will talk about<br>soon: a <em>trap frame</em> for interrupts and system calls, a boolean to track whether<br>a process should be killed soon, a <em>channel</em> to be able to wake up a sleeping<br>process, an array of open files, and a current working directory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    uint sz;                    <span class="comment">// size (in bytes) of virtual address space</span></span><br><span class="line">    <span class="type">pde_t</span> *pgdir;               <span class="comment">// page directory</span></span><br><span class="line">    <span class="type">char</span> *kstack;               <span class="comment">// kernel stack for this process</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>       <span class="comment">// process state</span></span><br><span class="line">    <span class="type">int</span> pid;                    <span class="comment">// process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>        <span class="comment">// parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// trap frame for current system call</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span>    <span class="comment">// saved register contents for context switches</span></span><br><span class="line">    <span class="type">void</span> *chan;                 <span class="comment">// channel that process is sleeping on, if any</span></span><br><span class="line">    <span class="type">int</span> killed;                 <span class="comment">// boolean: should process be killed soon?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// array of open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>          <span class="comment">// current working directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];              <span class="comment">// process name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Okay, next we’ll add another structure for metadata representing each CPU.</p>
<p>If you read the previous post, then you know each CPU has its own local<br>interrupt controller with a unique ID, so we’ll write that down. The post about<br>process paging talked about the TSS, so we’ll need one of those per CPU, plus a<br>GDT too.</p>
<p>At any point in time, a processor will be running one of: its own initialization<br>routine (only once while the kernel is setting up), a user process (or any<br>interrupts or system calls that come up), or a scheduler routine to run the next<br>process. So let’s add a pointer to a <code>struct proc</code>, which will be null if it’s<br>not running a process; a boolean <code>started</code> will be false until the CPU finishes<br>its own set-up. The scheduler isn’t itself a process; it uses the <code>kpgdir</code> page<br>directory and has its own context, so we’ll store that context in a field here.</p>
<p>Finally: remember how the spin-lock post talked about nested calls to <code>pushcli()</code><br>and <code>popcli()</code> tracking whether interrupts were enabled before the first call to<br><code>pushcli()</code>, and only enabling interrupts after the last call to <code>popcli()</code> if<br>they were enabled before? Those were tracked with per-CPU fields <code>ncli</code> and<br><code>intena</code>, so we need those too.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">    uchar apicid;               <span class="comment">// ID of this CPU&#x27;s local interrupt controller</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">scheduler</span>;</span>  <span class="comment">// scheduler&#x27;s context</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span>;</span>        <span class="comment">// task state segment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[<span class="title">NSEGS</span>];</span>  <span class="comment">// global descriptor table</span></span><br><span class="line">    <span class="keyword">volatile</span> uint started;      <span class="comment">// boolean: has this CPU been initialized yet?</span></span><br><span class="line">    <span class="type">int</span> ncli;                   <span class="comment">// depth of pushcli() nesting</span></span><br><span class="line">    <span class="type">int</span> intena;                 <span class="comment">// were interrupts enabled before pushcli()?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// currently running process</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Last but not least, we’ll add declarations for the global array of CPUs and the<br>number of CPUs actually present on this machine; these were defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mp.c">mp.c</a></p>
<p>Okay, on to the functions now!</p>
<h2 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a>proc.c</h2><p>xv6 uses a global process table with an array of processes to store all the<br><code>struct proc</code>s in; this means we’ll never be able to create more processes than<br>the number of entries in the array, <code>NPROC</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 64.<br>We’ll need a lock too to prevent data races while accessing the process table.<br>The process table’s definition does that thing again where you simultaneously<br>define a <code>struct type</code> and define a variable using that type in a single<br>statement.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line">&#125; ptable;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Then we define a global static variable to point to the first process that gets<br>run on xv6, so that other files can set it up.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">initproc</span>;</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Finally, we’re gonna need to assign unique process IDs, so we’ll use a global<br>counter to know which one we should use next.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="pinit"><a href="#pinit" class="headerlink" title="pinit"></a>pinit</h3><p>This function only does one thing: initializes the lock in the process table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;ptable.lock, <span class="string">&quot;ptable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mycpu"><a href="#mycpu" class="headerlink" title="mycpu"></a>mycpu</h3><p>This function will return a pointer to the <code>struct cpu</code> for the current CPU.<br>There’s a potential concurrency bug with this function: if it gets interrupted<br>before it returns, then it might get rescheduled on a different CPU, and end up<br>returning an incorrect <code>struct cpu</code>. So we need to make sure that interrupts are<br>disabled when we call it. Normally we’d do that with <code>pushcli()</code> and <code>popcli()</code>,<br>but those functions actually call this one, so we’d get an infinite recursion.<br>So instead we’re just gonna have to remember to disable interrupts <em>before</em><br>calling this function.</p>
<p>If you’re reading this because you’re gonna do some xv6 kernel hacking for an<br>OSTEP project or something, you should read that as “DANGER DANGER DANGER!”. If<br>your code calls this function, or calls any other functions that in turn call<br>this one, you <em>have</em> to make sure you’ve disabled interrupts first.</p>
<p>Concurrency bugs are a nightmare because they’re not deterministic: for example,<br>if you forget to disable interrupts before calling this function, it might work<br>just fine most of the time until the one unlucky moment when it gets interrupted<br>and rescheduled on a different CPU. So let’s make this easier to debug by<br>starting off with a check that interrupts are disabled and panic if they’re not.<br>We can check whether the interrupt flag <code>FL_IF</code> is set in the <code>eflags</code> register.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *<span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;mycpu called with interrupts enabled\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay so how do we figure out which CPU we’re on? Well, the previous post talked<br>about interrupt controllers; each CPU has a local interrupt controller with a<br>unique ID which we can get with <code>lapicid()</code>. Once we have that, we can iterate<br>over the CPU array <code>cpus</code> until we find an entry with a matching <code>apicid</code>; we’ll<br>just panic if none of them match.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cpu *<span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> apicid = lapicid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ncpu; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpus[i].apidid == apicid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;cpus[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;unknown apicid\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cpuid"><a href="#cpuid" class="headerlink" title="cpuid"></a>cpuid</h3><p>Those local interrupt controller IDs aren’t guaranteed to start from 0, so we’ll<br>need another way to identify CPUs. We can just use its entry number in the<br>global <code>cpus</code> array for that; <code>cpus</code> is an array of <code>struct cpu</code>s, which in C<br>means it’s really a pointer to the entry with index 0. <code>mycpu()</code> returns a<br>pointer to the entry for the current CPU, so we can just subtract those pointers<br>to get the index.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cpuid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mycpu() - cpus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="myproc"><a href="#myproc" class="headerlink" title="myproc"></a>myproc</h3><p>This function returns a pointer to the <code>struct proc</code> running on this CPU. We’re<br>gonna call <code>mycpu()</code> here, so we’ll be good and remember to dsable interrupts<br>first with <code>pushcli()</code> and reenable them at the end with <code>popcli()</code>. Then we’ll<br>get the current process from the <code>struct cpu</code>‘s field.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc *<span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pushcli();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line"></span><br><span class="line">    popcli();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocproc"><a href="#allocproc" class="headerlink" title="allocproc"></a>allocproc</h3><p>Okay, we’re finally at the code to create a new process! Whew, it’s been a long<br>journey.</p>
<p>This is a <code>static</code> function, which means it can only be called by functions<br>defined in this same file. Creating a new process will require modifying the<br>process table, so we need to grab the lock so that other threads can’t mess with<br>it while we’re using it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to look through the table and find a slot that’s <code>UNUSED</code>; if we<br>find on, then great, we’ll assign that slot to the new process after the <code>found</code><br>label below. But if none of them are free, we’ll have to return a null pointer<br>to indicate that. You know what that means, right? Yup, we’re gonna have to add<br>null checks every time we call this function! Wooooo!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look through process table looking for an UNUSED slot</span></span><br><span class="line">    <span class="keyword">for</span> (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If none is found, return null pointer</span></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Check out that for loop too: <code>p</code> is a pointer to a <code>struct proc</code> that starts off<br>pointing to <code>ptable.proc</code>; that means it points to the entry and index 0. Then<br>it gets incremented by 1 each iteration; since it’s a <code>struct proc</code>, the pointer<br>arithmetic will work out so that it points to the next entry in the process<br>table.</p>
<p>Okay now let’s check out the <code>found</code> label and see what happens if we did find<br>an unused slot. First we set its state to <code>EMBRYO</code> (instead of <code>RUNNABLE</code>, since<br>we’re not done setting it up) and give it a PID. That state means it’s neither<br><code>UNUSED</code> nor <code>RUNNABLE</code>, so we can be confident that any other threads wouldn’t<br>try messing with it right now; they can’t allocate the slot to another process,<br>and they can’t try to run it yet. So we can stop hogging the process table now<br>and let other threads take a turn.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    p-&gt;state = EMBRYO;</span><br><span class="line">    p-&gt;pid = nextpid++;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to allocate a page for this process’s kernel thread to use as a<br>stack. Remember, <code>kalloc()</code> can return null, so we need a null check here.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;kstack = kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;state = UNUSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we’re not gonna set up its page directory yet; that’ll happen in <code>fork()</code>,<br>which we’ll see later on. But we do need to set up the process so that it’ll<br>start executing code somewhere. It needs to start off in kernel mode, then it’ll<br>context-switch back into user mode and start running its code.</p>
<p>We haven’t looked at the mechanics of context switches yet, so I’ll spoil it a<br>little now (I know, I’m sorry). When a process is already running, it can send a<br>system call to ask for the kernel’s attention to do whatever it needs, like a<br>baby crying until it gets fed or changed or burped or whatever. Then it’ll<br>switch into kernel mode to run the system call, then switch back to where it<br>left off and pick up from there.</p>
<p>Well, xv6 is all about simplicity, right? And what’s more simple and elegant<br>than treating a special case (creating a new process and starting it off running<br>some code) the same as the general case (returning from a system call)? So xv6<br>will set up every new process to start off by “returning” from a (non-existent)<br>system call. That way the context switch code can be reused for new processes<br>too.</p>
<p>New processes are created via <code>fork()</code>, so we’ll return into a function called<br><code>forkret()</code>. Then that has to return into the function <code>trapret()</code>, which<br>closes out a <em>trap</em> (interrupt, system call, or exception) by restoring saved<br>registers and switching into user mode. We’ll get to <code>forkret()</code> and <code>trapret()</code><br>soon.</p>
<p>But first, the challenge: how do we “return” into a function that never called<br>us in the first place? We talked about function calls in x86 in the post on<br>spin-locks with the <code>getcallerpcs()</code> function, so make sure to read that now if<br>you need a refresher.</p>
<p>To summarize: when a function <code>f()</code> calls another function <code>g()</code>, it pushes the<br>arguments of <code>g()</code> on the top of its stack. Then it pushes a return address to<br>know where it should continue running the code of <code>f()</code> after <code>g()</code> returns;<br>that’s just the <code>%eip</code> register. Then it pushes the base address of the stack<br>for <code>f()</code>, i.e. the current <code>%ebp</code> register. That’s where <code>g()</code>‘s stack will<br>start off.</p>
<p>When the scheduler first runs the new process, it’ll check its context via<br><code>p-&gt;context</code> to get its register contents, including the instruction pointer<br><code>%eip</code>. So if we want it to start executing the code in <code>forkret()</code>, the <code>eip</code><br>field of its context should point to the beginning of <code>forkret()</code>. Then we can<br>trick it into thinking that the previous caller was <code>trapret()</code> by setting up<br>arguments and a return address in its stack.</p>
<p>Let’s start off by getting a pointer to the bottom of the stack. We had just<br>allocated a new stack page at <code>p-&gt;kstack</code>, but the stack grows from high to low<br>addresses, so the base of the stack is really at <code>p-&gt;kstack + KSTACKSIZE</code>. We’ll<br>make it a <code>char *</code> so we can move around one byte at a time using pointer<br>arithmetic.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> *sp = p-&gt;<span class="built_in">stack</span> + KSTACKSIZE;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we should push any arguments for <code>trapret()</code> on the stack; it takes a<br><code>struct trapframe</code> (which we’ll go over later), so we’ll leave some room for it<br>and make the process point to it with <code>p-&gt;tf</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="keyword">sizeof</span>(*p-&gt;tf);</span><br><span class="line">    p-&gt;tf = (<span class="keyword">struct</span> trapframe *) sp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we add a “return address” to the beginning of <code>trapret()</code> after that.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="number">4</span>;</span><br><span class="line">    *((uint *) sp) = (uint) trapret;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last thing we need is to save some space for the process’s context on the<br>stack and point <code>p-&gt;context</code> to it. Then we’ll zero it all out, except for the<br><code>eip</code> field, which will point to the beginning of <code>forkret()</code>. And that’s it!<br>We just return the pointer to the process now.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc *<span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp -= <span class="keyword">sizeof</span>(*p-&gt;context);</span><br><span class="line">    p-&gt;context = (<span class="keyword">struct</span> context *) sp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(*p-&gt;context));</span><br><span class="line">    p-&gt;context-&gt;eip = (uint) forkret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can create new processes now!</p>
<h3 id="growproc"><a href="#growproc" class="headerlink" title="growproc"></a>growproc</h3><p>What about growing or shrinking the size of a process’s address space? We<br>already did most of the hard work with <code>allocuvm()</code> and <code>deallocuvm()</code> from the<br>post on process paging, so let’s take a beat to thank past us for that.</p>
<p>Okay, so first we have to get the current process’s size.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    uint sz = curproc-&gt;sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Depending on the size of <code>n</code>, we’ll either grow the process or shrink it by <code>n</code><br>bytes. Both <code>allocuvm()</code> and <code>deallocuvm()</code> can fail and return zero, so let’s<br>add some checks for those and return -1 if they fail.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sz = allocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sz = deallocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curproc-&gt;sz = sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we need to tell the hardware that there’s a new page directory in town<br>with a different size than the old one, so we’ll use <code>switchuvm()</code> to update<br>the page directory and TSS stored by the hardware to reflect the changes. Then<br>we return 0 to indicate everything went okay.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    switchuvm(curproc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="procdump"><a href="#procdump" class="headerlink" title="procdump"></a>procdump</h3><p>This function is for debugging purposes: it’ll print a complete listing of any<br>processes in the process table. Quick spoiler: the keyboard interrupt handler<br>function will set things up so that pressing <code>^P</code> runs this function. Go ahead,<br>load up xv6 and try it out!</p>
<p>We want to print out the state for each process, but the states in <code>enum procstate</code> are just integers, which isn’t very debug-friendly. So let’s map them<br>all to strings first with a static array of strings.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *states[] = &#123;</span><br><span class="line">        [UNUSED]    <span class="string">&quot;unused&quot;</span>,</span><br><span class="line">        [EMBRYO]    <span class="string">&quot;embryo&quot;</span>,</span><br><span class="line">        [SLEEPING]  <span class="string">&quot;sleep &quot;</span>,</span><br><span class="line">        [RUNNABLE]  <span class="string">&quot;runble&quot;</span>,</span><br><span class="line">        [RUNNING]   <span class="string">&quot;run   &quot;</span>,</span><br><span class="line">        [ZOMBIE]    <span class="string">&quot;sombie&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This array notation might be a little unusual if you haven’t seen it before: C<br>lets you initialize arrays by specifying the value of each entry. If you leave<br>any entries out, then they’ll get initialized to zero. You can even write the<br>entries out of order by adding their index before them in square brackets. So<br><code>{ [1] 5, [0] 2 }</code> is the same thing as <code>{2, 5}</code>. The <code>enum</code> turns the states<br>into integers, so they work as indices here.</p>
<p>Now we’ll just iterate over the process table to get all the processes, skipping<br>over any <code>UNUSED</code> ones.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == UNUSED) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll get the process’s state (or just use <code>&quot;???&quot;</code> if something went wrong<br>and the state isn’t recognized).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">char</span> *state;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state &gt;= <span class="number">0</span> &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state]) &#123;</span><br><span class="line">            state = states[p-&gt;state];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we can print out its PID, state, and name to the console.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        cprintf(<span class="string">&quot;%d %s %s&quot;</span>, p-&gt;pid, state, p-&gt;name);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll see later on that the <code>sleep()</code> and <code>wakeup()</code> system calls<br>involve some lock trickery, so sleeping processes could be a common cause of<br>concurrency issues like deadlocks. So if a process is sleeping, we’ll print out<br>its call stack using the <code>getcallerpcs()</code> function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">            uint pc[<span class="number">10</span>];</span><br><span class="line">            getcallerpcs((uint *) p-&gt;context-&gt;ebp + <span class="number">2</span>, pc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; pc[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">                cprintf(<span class="string">&quot; %p&quot;</span>, pc[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h2><p>Whew, we’re making good progress. The most important part of this code was how<br>xv6 creates new processes and sets them up to start running: basically, it uses<br>some stack and function call trickery to make the scheduler start running a new<br>process with the code in <code>forkret()</code>, then <code>trapret()</code>, before switching context<br>into user mode.</p>
<p>We haven’t talked about those two functions yet; we’ll hold off on that until we<br>do traps and system calls. Next up is scheduling processes!</p>
<h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><p>We’ve done a lot of talking about context switching and scheduling, but we’ve<br>procrastinated looking at the code for those. It’s time to fix that.</p>
<p>There are all kinds of advanced schedulers out there, but as we’ve said before,<br>the name of the game in xv6 is simplicity, so xv6 just uses a round-robin<br>scheduling algorithm in which in loops through the exisitng processes in order.<br>Each timer interrupt will force the current process to yield the processor and<br>perform a context switch back into the scheduler so it can run the next<br>available process.</p>
<h2 id="swtch-S"><a href="#swtch-S" class="headerlink" title="swtch.S"></a>swtch.S</h2><p>The <code>struct context</code> we talked about in the last post is gonna be key here, so<br>let’s just look at its fields again:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    uint edi;</span><br><span class="line">    uint esi;</span><br><span class="line">    uint ebx;</span><br><span class="line">    uint ebp;</span><br><span class="line">    uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The context switch function is <code>swtch()</code>; it’s gonna need to save and restore<br>processor registers, so that means it’s gonna have to be written in assembly.<br>But let’s pretend it’s just a C function for a second and talk about what it’s<br>going to do.</p>
<p>This function will save the contents of the registers on the stack as a <code>struct context</code>, then save that location as the old context. Then it’ll load a new<br>context, switch to the new stack, and restore the registers of the new context.<br>Its declaration would look like this in C:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context **old, <span class="keyword">struct</span> context *new)</span>;</span><br></pre></td></tr></table></figure>
<p>The first argument is a pointer <em>to a pointer</em> to a <code>struct context</code>. That<br>double indirection might be confusing, but there’s a method to this madness: C<br>passes arguments by value, so if we used <code>struct context *old</code> and changed <code>old</code><br>to point to the saved context, it would be lost as soon as we returned from this<br>function. So instead we have to use this kind of double pointer so we can set<br><code>*old</code> to point to the saved context. This way <code>old</code> will be lost anyway, but<br><code>*old</code> was changed and will persist beyond this function’s return.</p>
<p>Note that, as we’ve said before, those arguments will be pushed on the stack<br>before <code>swtch()</code> is called. So at the beginning of <code>swtch()</code>, the stack pointer<br><code>%esp</code> points to a return address; the argument <code>old</code> is one space (4 bytes)<br>above that in the stack, and <code>new</code> is one space higher than that.</p>
<p>Okay, let’s check out the assembly code now. We’re gonna start by saving those<br>arguments into registers. We can’t just use any old registers here, or we might<br>overwrite some of the data we’re trying to save. But in the last post, I said<br>x86 has a convention that the caller has to save the contents of the <code>%eax</code>,<br><code>%ecx</code>, and <code>%edx</code> registers, so that means we’re free to overwrite them all we<br>want since they’ve already been saved.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">    movl    4(%esp), %eax</span><br><span class="line">    movl    8(%esp), %edx</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>
<p>We haven’t seen this number-parenthesis notation in assembly yet, so in case<br>you’re not familiar with x86 assembly, it’s just a way to add a number to the<br>contents of a register, then treating it as a pointer and dereferencing it. So<br><code>4(%esp)</code> in assembly is the same as <code>*(esp + 4)</code> in C. So at this point, <code>%eax</code><br>holds the <code>struct context **old</code> pointer, and <code>%edx</code> holds the<br><code>struct context *new</code> pointer.</p>
<p>Now it’s time to save all the fields in a <code>struct context</code> on the stack. The<br>stack grows from high addresses to low ones, but C <code>structs</code> expect their fields<br>to be from low to high, so we’ll save them in reverse order. Oh, and hang on –<br>remember what’s at the bottom of the stack right now, after the arguments?<br>That’s right, a return address. That’s just a saved <code>%eip</code>, so that one’s<br>already done for us! We just need to save the others.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    pushl   %ebp</span><br><span class="line">    pushl   %ebx</span><br><span class="line">    pushl   %esi</span><br><span class="line">    pushl   %edi</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Next we have to save a pointer to this old <code>struct context</code> into <code>*old</code>. Well,<br>we pushed them on the stack in reverse order, right? So <code>%esp</code> already <em>is</em><br>pointing to it, so that’s our pointer; we’ll just copy it into <code>*old</code> (remember<br>it’s stored in <code>%eax</code>, and we dereference it in assembly with parentheses).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    movl    %esp, (%eax)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Now it’s time to switch stacks to the <code>new</code> context, which we saved in <code>%edx</code>.<br>That context must have been saved by a previous call to <code>swtch()</code>, so it also<br>happens to be a stack pointer as well.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    movl    %edx, %esp</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>At this point, we’re using the stack from <code>new</code>, which will already have its<br>saved context at the top. So we can load the new context by popping it off the<br>stack in reverse order into the corresponding registers. And again, just like<br>the <code>call</code> instruction had already saved <code>%eip</code> on the stack as the return<br>address, the <code>ret</code> (return) instruction will pop it off and restore it into<br><code>%eip</code> for us.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swtch:</span><br><span class="line">    # ...</span><br><span class="line">    popl    %edi</span><br><span class="line">    popl    %esi</span><br><span class="line">    popl    %ebx</span><br><span class="line">    popl    %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>And that’s it! That’s a context switch in xv6.</p>
<h2 id="proc-c-1"><a href="#proc-c-1" class="headerlink" title="proc.c"></a>proc.c</h2><p>And now, finally, we can look at the scheduling code. Once the kernel is done<br>setting itself up, initializing all the devices and drivers, etc., the very last<br>function that <code>main()</code> calls is <code>scheduler()</code>. Interrupts were disabled in the<br>boot loader and haven’t been enabled yet, so it’s also the scheduler’s job to<br>enable them for the first time in xv6.</p>
<p><code>scheduler()</code> never returns; it’s an infinite loop that just keeps searching<br>through the process table for a <code>RUNNABLE</code> process, then runs it. So from that<br>point on, with the exception of interrupts and system calls, the kernel will<br>only ever do one thing: schedule processes to run.</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>A CPU that’s running the scheduler isn’t running its own process. So we’ll start<br>off by setting this CPU’s process pointer to null. Note that <code>mycpu()</code> requires<br>interrupts to be disabled before it’s called, but that’s okay here because<br>interrupts were disabled in the boot loader and haven’t been re-enabled before<br>the scheduler is called.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">    c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The order of the next few steps is tricky, and the authors of xv6 had to be<br>extremely careful to do them in the right order to avoid concurrency problems.<br>We need to (1) re-enable interrupts, (2) acquire the process table’s lock, and<br>(3) create an infinite loop to iterate over the process table forever, scheduling<br>processes along the way. To see why this is nontrivial, let’s check out some<br>different orders (with a <code>fake_scheduler()</code> function) and see what problems we<br>get.</p>
<p>ATTEMPT #1: interrupts -&gt; lock -&gt; loop. Let’s try it out.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fake_scheduler1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sti();                  <span class="comment">// enable interrupts</span></span><br><span class="line">    acquire(&amp;ptable.lock);  <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              <span class="comment">// infinite scheduling loop</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interrupts have been disabled since the boot loader used <code>cli</code>, so when we call<br><code>sti()</code> here they’ll be turned on for the first time in the kernel. At that<br>point we’ll find out if there were any interrupts waiting to be acknowledged,<br>and possibly jump into some handler function to take care of it. Then when<br>that’s done, we’ll come back here and acquire the process table’s lock. Acquiring<br>a lock disables interrupts, remember? So they’re disabled again in the infinite<br>scheduling loop (but not forever; we’ll release the lock before switching to a<br>user process). That sounds okay, right?</p>
<p>Not so fast! There’s a hidden problem: suppose we had a situation in which none<br>of the current processes are <code>RUNNABLE</code> – maybe they’re all blocked (or<br><code>SLEEPING</code>) waiting for I&#x2F;O or something, which is not unlikely. In that case,<br>the scheduler would just keep idly looping through the process table until one<br>of them becomes <code>RUNNABLE</code> again. But if interrupts are always disabled in the<br>loop, then this processor will never find out about, e.g., a disk interrupt<br>saying it’s done reading data which would allow a blocked process to become<br><code>RUNNABLE</code>. That means the process will never find out the condition it’s<br>waiting for has already happened, which means the scheduler will never find any<br><code>RUNNABLE</code> processes. It’ll just get stuck in an infinite loop, repeatedly and<br>desperately searching every entry of the process table. So basically, the<br>system would freeze while the CPU pointlessly spins at top speed.</p>
<p>Okay okay, so that doesn’t work. We’ll have to periodically re-enable interrupts<br>before disabling them again. So let’s try moving the call to <code>sti()</code> inside the<br>infinite loop so interrupts get re-enabled every once in a while.</p>
<p>ATTEMPT #2: lock -&gt; loop -&gt; interrupts.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fake_scheduler2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;ptable.lock);  <span class="comment">// acquire lock</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              <span class="comment">// infinite scheduling loop</span></span><br><span class="line">        sti();              <span class="comment">// temporarily enable interrupts</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Problem solved, right? Actually… this one turns out to be just as bad. The<br>call to <code>acquire()</code> disables interrupts, only for <code>sti()</code> to enable them again.<br>There’s a reason that locks disable interrupts, remember? If an interrupt occurs<br>that switches away from <code>scheduler()</code>, then it might call a handler function<br>that needs to access the process table lock, which is already held by<br><code>scheduler()</code>, so that function would spin forever in a deadlock.</p>
<p>So now we arrive at the correct order: we’ll call <em>both</em> <code>sti()</code> and <code>acquire()</code><br>inside the loop, in that order. That means we’ll also need a call to <code>release()</code><br>at the end of the loop before we try to <code>acquire()</code> again in the next iteration.<br>We had already said we’d have to release the lock before running a process; now<br>we’ll have to acquire it again before context-switching back into the loop.</p>
<p>ATTEMPT #3 (the right one): loop -&gt; interrupts -&gt; lock. This will give us a<br>chance to detect any outstanding interrupts in each iteration of the for loop,<br>but before we’ve acquired the lock again and thus, before doing so could cause a<br>deadlock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        sti();</span><br><span class="line">        acquire(&amp;ptable.lock);</span><br><span class="line">        <span class="comment">// ... pick a process and run it ...</span></span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Whew, okay. Basically, we’ve learned that concurrency bugs can be hard to predict<br>and can turn seemingly-fine code into impossible-to-diagnose system crashes or<br>freezes.</p>
<p>Okay, so now let’s fill in the part of the loop where the scheduling algorithm<br>goes. We’ll add an inner for loop to iterate over the process table entries<br>and stop when we find a <code>RUNNABLE</code> process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state != RUNNABLE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... run that process ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, if we found a process, then we need to switch to that process’s virtual<br>address space; that is, we need to start using its page directory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            c-&gt;proc = p;</span><br><span class="line">            switchuvm(p);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if we just switched to an arbitrary page directory in the middle of running<br>other code, we might cause a bunch of problems: all the virtual addresses we’re<br>currently using for variables, functions, instructions, etc. might suddenly<br>become invalid and point to random other places in memory. But this is where can<br>see some of the earlier design decisions in xv6 start to pay off: remember how<br><code>setupkvm()</code> made sure every single process would have the exact same mappings<br>for the upper half of the address space, starting at <code>KERNBASE</code>? That means that<br>if we’re running in kernel mode, we can arbitrarily switch to any process’s page<br>directory and know that all of our mappings will be exactly the same. The user<br>mappings in the lower half might be different, but the kernel side will never<br>change. Nice!</p>
<p>Now we can run the process using <code>swtch()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            p-&gt;state = RUNNING;</span><br><span class="line">            swtch(&amp;(c-&gt;scheduler), p-&gt;context);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swtch()</code> will <em>not</em> return here immediately; instead, it’ll pick up execution<br>wherever the process last left off, which will be in kernel mode – if it<br>stopped running before, it must have been due to a system call, interrupt, or<br>exception, which would have been handled in kernel mode before calling the<br>scheduler.</p>
<p>Note that this process will still be holding the process table lock when it<br>starts running again. For example, that’s the main reason for the existence of<br>the <code>forkret()</code> function we mentioned before. This is another dangerous detail<br>we’ll have to remember, so I’m just gonna go ahead and hope you remember THIS<br>BIG GIANT GLARING WARNING FLAG RIGHT HERE: if you do any xv6 kernel hacking, and<br>you want to add a new system call that will let go of the CPU, then your code<br><em>must</em> release the process table lock at the point at which it starts executing<br>after switching to it from the scheduler.</p>
<p>This is pretty dangerous; if xv6 were a big project, it would be really easy to<br>forget that when adding more features later on. But in this case, there’s no<br>easy way to get around it; for example, we can’t just release the process table<br>lock before calling <code>swtch()</code> and reacquire it after. The problem becomes<br>apparent if you think of locks as protecting some invariant; that invariant<br>might be temporarily violated while you hold the lock, but it should be restored<br>before the lock is released.</p>
<p>The process table protects invariants related to the process’s <code>p-&gt;state</code> and<br><code>p-&gt;context</code> fields, e.g. that the CPU registers must hold the process’s<br>register values, that a <code>RUNNABLE</code> process must be able to be run by any idle<br>CPU’s scheduler, etc. These don’t hold true while executing in <code>swtch()</code>, so we<br>need to hold the lock then; otherwise another CPU might decide to run the<br>process before <code>swtch()</code> is done executing.</p>
<p>Now, at some point that process will be done running and will give up the CPU<br>again. Before it switches back into the scheduler, it has to acquire the process<br>table lock again. So here’s ONE MORE GIANT WARNING for good measure: you should<br>make sure to do that too if you add your own scheduling-related system call.</p>
<p>Eventually, it’ll switch back here with a call with the arguments in reverse,<br>like <code>swtch(&amp;(p-&gt;context), c-&gt;scheduler)</code>. At the point, execution of the<br>scheduler will resume right here, so we need to switch back to using the kernel<br>page directory <code>kpgdir</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            switchkvm();</span><br><span class="line">            c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After that, the outer for loop just releases the lock before looping to the top<br>again to temporarily re-enable interrupts, then acquire the lock again and check<br>for another process to run.</p>
<h3 id="forkret"><a href="#forkret" class="headerlink" title="forkret"></a>forkret</h3><p>Let’s take a quick look at one example of where a process might start to execute<br>after being scheduled. All processes (whether the very first process, or any<br>others created later through calls to <code>fork()</code>) will start running code in<br><code>forkret()</code>, then return from here into <code>trapret()</code>.</p>
<p>Most of the time, this function does just one thing: it releases the process<br>table lock. However, there are two kernel initialization functions that have to<br>be run from user mode, so we can’t just call them from <code>main()</code> and be done with<br>it. We need a place for a process to call them, and <code>forkret()</code> is as good a<br>place as any. So the very first call to <code>forkret()</code> will run these two start-up<br>functions, and the rest will ignore them.</p>
<p>The two functions are <code>iinit()</code> and <code>initlog()</code>, which are part of xv6’s file<br>system code; we’ll get to them later on. For now, we’ll just use a <code>static int</code><br>as a boolean and set it to false after we’ve run those functions once on our<br>first pass through <code>forkret()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only gets run once, on the first call</span></span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        iinit(ROOTDEV);</span><br><span class="line">        initlog(ROOTDEV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Returns into `trapret()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Any other kernel code that switches into the scheduler (e.g., <code>sleep()</code> and<br><code>yield()</code>) will have a similar lock release right after returning from<br>the scheduler.</p>
<h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>We saw one example of code that runs after switching <em>away</em> from the scheduler,<br>but what about code that runs before switching <em>to</em> the scheduler? Any functions<br>that need to call into the scheduler can’t just call <code>scheduler()</code>, since the<br>scheduler probably left off last time halfway through the loop and should resume<br>in the same place. So <code>sched()</code> handles the task of picking up the scheduler<br>wherever it last left off.</p>
<p><code>sched()</code> should be called <em>after</em> acquiring the process table lock and without<br>holding any other locks (lest we cause a deadlock somewhere). Also, the process<br>should not be in the <code>RUNNING</code> state anymore since we’re about to stop running<br>it. So we’ll start off by checking that those are all true and that interrupts<br>are disabled.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!holding(&amp;ptable.lock)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched ptable.lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mycpu()-&gt;ncli != <span class="number">1</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state == RUNNING) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (readeflags() &amp; FL_IF) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, remember when the <code>pushcli()</code> and <code>popcli()</code> functions checked whether<br>interrupts were enabled before turning them off while holding a lock? That’s<br>really a property of this kernel thread, not of this CPU, so we need to save<br>that now. Then we can call <code>swtch()</code> to pick up where the scheduler left off<br>(the line right after its own call to <code>swtch()</code>). This process will resume<br>executing after that line eventually, at which point we’ll restore the data<br>about whether interrupts were enabled and let it run again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save whether interrupts were enabled before acquiring the lock</span></span><br><span class="line">    <span class="type">int</span> intena = mycpu()-&gt;intena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform context switch into the scheduler</span></span><br><span class="line">    swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler);</span><br><span class="line">    <span class="comment">// Execution will eventually resume here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore whether interrupts were enabled before</span></span><br><span class="line">    mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>Okay, let’s see an example of how this all comes together now! The <code>yield()</code><br>function forces a process to give up the CPU for one scheduling round. For<br>example, this will be used to handle timer interrupts later on. Now that we know<br>how scheduling works in xv6, <code>yield()</code> is easy. We just acquire the process<br>table lock, set the current process’s state to <code>RUNNABLE</code> so it can get picked<br>up again in the next scheduling round, and call <code>sched()</code> to switch into the<br>scheduler. When we eventually return here, we’ll just release the lock again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    myproc()-&gt;state = RUNNABLE;</span><br><span class="line">    sched();</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h2><p>We’ve now seen how xv6 handles process scheduling with a super-simple round-<br>robin algorithm. The <code>scheduler()</code> function had plenty of concurrency pitfalls,<br>but luckily the xv6 authors took care of all the careful coding for us, so we<br>just get to sit back and admire their work.</p>
<p>We also saw how context switches occur in xv6, so now we can understand how, in<br>the previous post, <code>allocproc()</code> set up a new process with a context that would<br>result in it starting execution in <code>forkret()</code>.</p>
<p>Next up, we’ll look at the way xv6 handles interrupts, system calls, and software<br>exceptions.</p>
<h1 id="It’s-a-Trap"><a href="#It’s-a-Trap" class="headerlink" title="It’s a Trap!"></a>It’s a Trap!</h1><p>The last post introduced the mechanisms that xv6 uses for scheduling and context<br>switches. User processes can transfer control to kernel code with system calls,<br>potentially switching into the scheduler with <code>sleep()</code> or <code>exit()</code> to find<br>another process to run. But there are many other system calls besides those two<br>Kernel code can also be invoked during hardware interrupts or software<br>exceptions; these three together are collectively referred to as traps.</p>
<p>We’ll go over traps now to understand them more generally. First, about the<br>terminology: depending on the source, interrupts might mean hardware interrupts<br>specifically or any trap generally; similarly, exceptions might mean errors<br>arising from the code, or traps in general. It’s super frustrating because it<br>makes it really hard to know what’s meant by a word like “interrupt” or<br>“exception” in whatever specification or source you happen to be reading. So I’m<br>gonna try my best to save you that kind of pain in this post by sticking to<br>“interrupt” for the hardware interrupts only, “exception” for software errors,<br>and “trap” for those two combined with system calls.</p>
<h2 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h2><p>Imagine if, after every single time some user code carried out a division, the<br>processor stopped, context switched into the kernel, and asked the kernel to<br>check if there was a division by zero and handle it if necessary. Or every time<br>a hardware interrupt happened, the kernel had to start polling all the devices<br>to figure out which one just yelled. No. Just no. Running kernel code for all<br>this would be way too slow.</p>
<p>So it’s the processor that will have to detect traps and decide how to handle<br>them. But what exactly it should do for a specific trap depends on all kinds of<br>of particulars about that OS, e.g. a disk saying it’s done reading from a file<br>might require updating some file system data or storing the disk data in a<br>specific buffer or something. That’s too much responsibility for the processor.</p>
<p>Okay, so the kernel will set up a bunch of handler functions for every possible<br>type of trap. Then it tells the hardware, “Okay, so if you get a disk interrupt,<br>here are my instructions to handle that. For timer interrupts, use these<br>instructions. If a process tries to access an invalid page, do this…”<br>From then on, the processor can handle the traps without further input from the<br>kernel by looking up the interrupt number in a big table to get the trap handler<br>function that the kernel set up, then just running it.</p>
<p>In the x86 architecture, that table is called the <em>interrupt descriptor table</em><br>or IDT. I know, I’m sorry, I promised I’d say “trap” for the general case, but<br>the x86 specs give it the official name of IDT even though it handles all the<br>traps. Sigh. It has 256 entries (so that’s the maximum number of distinct traps<br>we can define); each one specifies a segment descriptor (ugh segmentation again,<br>you know what that means: opaque code) and an instruction pointer (<code>%eip</code>) that<br>tell the processor where it can find the corresponding trap handler<br>function.</p>
<p>xv6 won’t use all 256 entries; it’ll mostly use trap numbers 0-31 (software<br>exceptions), 32-63 (hardware interrupts), and 64 (system calls), all defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/traps.h">traps.h</a>.<br>But we do have to stick all 256 in the IDT anway, so we’re the unlucky fools who<br>get to write 256 functions’ worth of assembly code by hand. Nah, just kidding:<br>xv6 uses a script in a high-level language to do that for us and spit out the<br>entries into an assembly file.</p>
<p>Unfortunately for us, that high-level language is Perl. Sigh. Perl is infamous<br>as a “write-only” language, so I guess instead we’re just the unlucky fools who<br>get to try reading Perl.</p>
<h2 id="vectors-pl"><a href="#vectors-pl" class="headerlink" title="vectors.pl"></a>vectors.pl</h2><p>Okay, I’m not gonna assume you know Perl, and either way I really don’t wanna go<br>over every single line of this file. The syntax is similar enough to C’s (except<br>that somehow they managed to make it even <em>worse</em> than C), so you can read it on<br>your own if you want.</p>
<p>Now, no script will be able to generate 256 completely unique assembly functions<br>with enough detail to handle each trap correctly, so each function in the script<br>has to be pretty generic. They’re all gonna call the same assembly helper<br>function, which will call a C function where we can more comfortably code up<br>how to handle each interrupt.</p>
<p>The gist of this Perl script is that it prints a bunch of stuff using a for loop<br>with 256 iterations. The xv6<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a><br>will run it from the command line with <code>./vectors.pl &gt; vectors.S</code> so that the<br>output gets saved in an assembly file, which will then get assembled together<br>with all the other kernel code in <code>OBJS</code>.</p>
<p>The resulting assembly file will look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line"></span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $0</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line">.globl vector1</span><br><span class="line">vector1:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $1</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line">.globl vector2</span><br><span class="line">vector2:</span><br><span class="line">    pushl   $0</span><br><span class="line">    pushl   $2</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Except that a handful of entries (8, 10 through 14, and 17) will skip one line<br>(I’ll explain why below):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.globl vector8</span><br><span class="line">vector8:</span><br><span class="line">    pushl   $8</span><br><span class="line">    jmp     alltraps</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Then at the end, it defines an array <code>vectors</code> with each of those entries above:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.globl vectors</span><br><span class="line"></span><br><span class="line">vectors:</span><br><span class="line">    .long vector0</span><br><span class="line">    .long vector1</span><br><span class="line">    .long vector2</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Okay, so those are all the handler functions; the <code>vectors</code> array holds a<br>pointer to each one. They’re all more or less the same: most of them push zero<br>onto the stack, then all they push a <em>trap number</em> to indicate which trap<br>just happened, and then they jump to a point in the code called <code>alltraps</code>;<br>that’s the assembly helper function I mentioned earlier.</p>
<p>A handful of the entries don’t push zero on the stack: these are trap numbers<br>8 (a double fault, which happens when the processor encounters an error while<br>handling another trap), 10 (an invalid task state segment), 11 (segment<br>not present), 12 (a stack exception), 13 (a general protection fault), 14 (a<br>page fault), and 17 (an alignment check). These are special because the<br>processor will actually push an error code on the stack before calling into the<br>corresponding handler function in <code>vectors</code>. It doesn’t push any error codes on<br>the stack for the others, so we just push 0 ourselves to make them all match up.</p>
<h2 id="trapasm-S"><a href="#trapasm-S" class="headerlink" title="trapasm.S"></a>trapasm.S</h2><h3 id="alltraps"><a href="#alltraps" class="headerlink" title="alltraps"></a>alltraps</h3><p>The processor needs to run the trap handler in kernel mode, which means we have<br>to save some state for the process that’s currently running so we can return to<br>it later (similar to the <code>struct context</code> we saw before), then set things up to<br>run in kernel mode. The <code>alltraps</code> routine does just that.</p>
<p>Remember how we said the IDT holds segment selectors for <code>%cs</code> and <code>%ss</code>, plus<br>and instruction pointer <code>%eip</code>? (I know we haven’t seen the code to create the<br>IDT and store the entries of <code>vectors</code> in it yet; we’ll get to that below.) The<br>processor will start using those segments (and save the old ones) before running<br>the trap handler function. Each trap handler function in <code>vectors</code> above pushed<br>an error code (or 0) followed by a trap number. Now we have to push all the<br>other segment selectors on the stack one at a time, then push all the general-<br>purpose registers at once with the x86 instruction <code>pushal</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line">alltraps:</span><br><span class="line">    pushl   %ds</span><br><span class="line">    pushl   %es</span><br><span class="line">    pushl   %fs</span><br><span class="line">    pushl   %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>Cool, all the registers are saved now. So now we’ll set up the <code>%ds</code> and <code>%es</code><br>registers for kernel mode (<code>%cs</code> and <code>%ss</code> were already done by the processor).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">movw    $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class="line">movw    %ax, %ds</span><br><span class="line">movw    %ax, %es</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>Now we’re ready to call the C function <code>trap()</code> that’s gonna do most of the<br>work. That function expects a single argument: a pointer to the process’s saved<br>register contents. Well, we just pushed them all on the stack, so we can just<br>use <code>%esp</code> as that pointer.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">pushl   %esp</span><br><span class="line">call    trap</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>That function will return back here when it’s done, so let’s ignore the return<br>value by moving the stack pointer just above it (essentially popping it off the<br>stack).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">addl    $4, %esp</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<h3 id="trapret"><a href="#trapret" class="headerlink" title="trapret"></a>trapret</h3><p>We’ve talked about this function before; when we create a new process, it starts<br>executing in <code>forkret()</code>, which then returns into <code>trapret()</code>. More generally,<br>any call to <code>trap()</code> will return here as well.</p>
<p>This function just restores everything back to where it was before, popping<br>stored registers off the stack in reverse order. We can skip the trap number and<br>error code; we won’t need them anymore. Then we use the <code>iret</code> or “interrupt<br>return” (though you should read that as “trap return”) instruction to close out,<br>return to user mode, and start executing the process’s instructions again.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl trapret</span><br><span class="line">trapret:</span><br><span class="line">    popal</span><br><span class="line">    popl    %gs</span><br><span class="line">    popl    %fs</span><br><span class="line">    popl    %es</span><br><span class="line">    popl    %ds</span><br><span class="line">    addl    $0x8, %esp  # skip the trap number and error code</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>

<h2 id="trap-c"><a href="#trap-c" class="headerlink" title="trap.c"></a>trap.c</h2><p>Okay, on to the main part of the code! We have to do two things here: stick the<br>trap handler functions in <code>vectors</code> into an IDT, and figure out what to do with<br>each interrupt type.</p>
<p>At the top, we’ve got four global variables. The IDT is represented as an array<br>of <code>struct gatedesc</code>s, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a>. It’s worth<br>taking a look at because it uses an obscure C feature (bit fields); we’ll do that<br>in the next section.</p>
<p>Then we declare the <code>vectors</code> array of trap handler (with an <code>extern</code> keyword,<br>since it’s defined in an assembly file), a global counter <code>ticks</code> that tracks<br>the number of timer interrupts so far (basically a rough timer), and a lock to<br>use with <code>ticks</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256];</span></span><br><span class="line"><span class="keyword">extern</span> uint vectors[];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">tickslock</span>;</span></span><br><span class="line">uint ticks;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="Bit-Fields"><a href="#Bit-Fields" class="headerlink" title="Bit Fields"></a>Bit Fields</h3><p>This section will get <em>deep</em> into the weeds, so feel free to skip it if you’re<br>having a nice day and don’t want to spoil it by reading about a bunch of C<br>standards.</p>
<p>So far, we’ve used bit flags with regular integers by manually doing some bit<br>arithmetic to set one bit at a time. For example, the flags for page table and<br>page directory entries are defined as powers of 2 (e.g., <code>PTE_P</code> is 0x1, <code>PTE_W</code><br>is 0x2, <code>PTE_U</code> is 0x4, etc.) so that we can set a specific bit using a bitwise-<br>OR like <code>pte |= PTE_U</code> or test whether it’s set with a bitwise-AND like<br><code>pte &amp; PTE_P</code>.</p>
<p>But sometimes that can get annoying and hard to keep track of; wouldn’t it be<br>nice if we could just have variables that represent a single bit? Or two bits,<br>or any number of bits we want?</p>
<p>The trouble is that most computer architectures don’t work with a single bit at<br>a time; they operate on bytes, words (2 bytes), long&#x2F;double words (4 bytes), or<br>quad words (8 bytes), so it would be nontrivial to compile a line of C like<br><code>a = 1</code> if <code>a</code> is a nonstandard size.</p>
<p>In fact, accessing variables that aren’t aligned to a standard size (4 bytes on<br>x86 or 8 bytes on x86_64) is much slower than when they are aligned. Compilers<br>often optimize code to correct for this by padding <code>struct</code>s so that they’ll<br>line up along those standard sizes. For example, one like</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nopadding</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>is probably left the same on x86, but one like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>is probably converted by the compiler into this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">padding</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> pad0[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">char</span> pad1[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>WARNING: We’re entering the dark arts of C’s unspecified and implementation-<br>defined behavior here. Note that these are different from <em>undefined</em> behavior:<br>undefined behavior means you did something BAD BAD BAD like dereferencing a null<br>pointer, freeing a memory region twice, using a variable after freeing it,<br>accessing an out-of-bounds index in a buffer, or overflowing a signed data type.<br>Implementation-defined and unspecified behavior aren’t as dangerous as undefined<br>behavior is, but they can cause portability issues.</p>
<p>The C standard is a huge document with a bunch of legalese rules about what<br>makes C, well, C. People who write C compilers need to know exactly how C code<br>should behave under all kinds of different circumstances, so the C standard<br>spells most of it out. But there are some parts it intentionally leaves out.</p>
<p><em>Implementation-defined</em> behavior means the C standard doesn’t set any fixed<br>requirements about how a compiler should handle some behavior or feature; the<br>developers of a C compiler get to decide how to write that part of the code with<br>total freedom. One example is the number of bits in a byte; we’ve been assuming<br>it’s 8, but there are some (dumb) architectures where it’s different.</p>
<p><em>Unspecified behavior</em>, on the other hand, means that the C Standard provides<br>some specific options, and compiler developers have to choose from those options<br>for <em>each instance</em> of the behavior in the code they’re compiling (that means,<br>don’t assume it’s always gonna be the same, even with the same compiler).</p>
<p>Structure padding is implementation-defined, and there are often implementation-<br>defined ways to modify it or disable it altogether (i.e., to <em>pack</em> the <code>struct</code><br>instead of <em>padding</em> it), usually with stuff like <code>__attribute__</code>s or <code>#pragma</code><br>directives for the preprocessor.</p>
<p>Wait weren’t we gonna talk about bit manipulation? Why are we talking about<br><code>struct</code>s? Well, C does have a workaround to make bit manipulation a little<br>easier by avoiding that slightly-annoying bit arithmetic you have to do to set<br>or clear flags in an <code>int</code> or <code>unsigned int</code>: it’s called a <em>bit field</em>, and it<br>takes advantage of <code>struct</code> padding.</p>
<p>You can specify the number of bits that a field of a <code>struct</code> should occupy by<br>adding a colon and a size after the field name:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfield_example</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This way, you can set the single-bit flag <code>a</code> with simple variable assignments<br>like <code>var.a = 1</code>, and the compiler will figure out any necessary magic similar<br>to structure padding to make that happen. Awesome, right? So why haven’t we been<br>using it all the time instead of all that opaque bit arithmetic with arcane<br>operators like <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>|</code>, and <code>&amp;</code>?</p>
<p>Well, there are some big downsides to bit fields. First, the C standard sets<br>some strict rules on their use to make sure that compilers can figure out how to<br>handle them. Bit fields are only allowed inside of structures. You’re not<br>allowed to create arrays of bit fields or pointers to bit fields. Functions<br>aren’t allowed to return a bit field. You’re not allowed to get the address of a<br>bit field with the <code>&amp;</code> operator. You can only operate on a single bit field at a<br>time in any statement; that means you can’t set one bit field to equal another,<br>and you can’t compare the values of two bit fields.</p>
<p>Second, they’re <em>extremely</em> implementation-defined. Each implementation (read:<br>compiler + architecture combo) determines what data types and sizes are allowed<br>to be used in bit fields. The data types you <em>can</em> use might have different<br>signedness rules from the usual ones for signed and unsigned types. How they’re<br>laid out, ordered, and padded in memory can differ. In short: the low-level<br>details are a total black box that you can probably only figure out by reading<br><em>deep</em> into the compiler’s specifications.</p>
<p>Now imagine trying to do something that requires specific protocols like sending<br>data over a network, and you come across a bit field. Lolwut. Who knows what<br>you’d have to do. Bit fields make it impossible to port your code.</p>
<p>BUT! Bit arithmetic is annoying, so let’s use bit fields anyway!</p>
<p>Okay, so back to <code>struct gatedesc</code>. IDT entries have to contain a 16-bit code<br>segment selector (<code>%cs</code>), 16 low bits and 16 high bits for an offset in that<br>segment, the number of arguments for the handler function, a type, a system&#x2F;<br>application flag, a descriptor privilege level (0 for kernel, 3 for user), and a<br>“present” flag. And x86 is very particular about how it’s all laid out, so we<br>have to set up <code>struct gatedesc</code> in the exact right order.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    uint off_15_0 : <span class="number">16</span>;</span><br><span class="line">    uint cs : <span class="number">16</span>;</span><br><span class="line">    uint args : <span class="number">5</span>;</span><br><span class="line">    uint rsv1 : <span class="number">3</span>;</span><br><span class="line">    uint type : <span class="number">4</span>;</span><br><span class="line">    uint s : <span class="number">1</span>;</span><br><span class="line">    uint dpl : <span class="number">2</span>;</span><br><span class="line">    uint p : <span class="number">1</span>;</span><br><span class="line">    uint off_31_16 : <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Well, okay, that’s it for now.</p>
<h3 id="tvinit"><a href="#tvinit" class="headerlink" title="tvinit"></a>tvinit</h3><p>This function loads all the assembly trap handler functions in <code>vectors</code> into<br>the IDT. The <code>SETGATE()</code> macro in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/mmu.h">mmu.h</a> will organize<br>each entry correctly. We said before that the IDT needs a code segment selector,<br>an instruction pointer (from <code>vectors</code>), and a privilege level (0 for kernel<br>mode), so we’ll stick those in.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, SEG_KCODE &lt;&lt; <span class="number">3</span>, vectors[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re basically done now, but there’s one last hiccup: user code needs to be<br>able to generate system calls, but we just set all the privilege levels so only<br>the kernel and processor can generate traps. So we’ll fix the entry for system<br>calls as a special case.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, SEG_KCODE &lt;&lt; <span class="number">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oh and while we’re at it, let’s just go ahead and initialize the lock for the<br>tick counter.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="idtinit"><a href="#idtinit" class="headerlink" title="idtinit"></a>idtinit</h3><p>The last function stored all the trap vectors in the IDT, so now we need to tell<br>the processor where to find the IDT. There’s a special assembly instruction for<br>that in x86 called <code>lidt</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idtinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lidt(idt, <span class="keyword">sizeof</span>(idt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h3><p>This last function is the one that gets called by the assembly code in <code>alltraps</code>;<br>it’s responsible for figuring out what to do based on the trap number we pushed<br>on the stack before. Heads up: it’s gonna do that by calling a bunch of other<br>functions, many of which we haven’t seen yet. I’ll just give a quick summary<br>when we come across them, and we’ll get to them later on.</p>
<p>The only argument is a pointer to a <code>struct trapframe</code>. Wait, hang on. Up above<br>in the assembly code, the argument we pushed on the stack was <code>%esp</code>, the stack<br>pointer, not a pointer to any <code>struct trapframe</code>. What’s up with that? Did we<br>pass the wrong kind of argument in?</p>
<p>Let’s check out the definition for <code>struct trapframe</code>, found in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/x86.h">x86.h</a>. It’s got a<br>bunch of fields, starting off with the general purpose registers (those are the<br>fields from <code>%edi</code> to <code>%eax</code>). Then it has four segment registers (fields <code>%gs</code><br>through <code>%ds</code>), plus some unused padding bits in between them to round the 16-<br>bit segment registers up to 32 bits. The next two fields are a trap number and<br>an error code.</p>
<p>All that should sound familiar. Take another look at<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/trapasm.S">trapasm.S</a>: so<br>far, those are the exact same things we pushed on the stack! The other fields<br>are what the processor pushed on the stack before calling the handler function<br>in the IDT. So basically, we’re never gonna construct a <code>struct trapframe</code> in C<br>code; we already constructed it manually in assembly. It just describes<br>everything that’s already on the stack by the time this <code>trap()</code> function gets<br>called. In that sense, the <code>%esp</code> we pushed as an argument really <em>is</em> a pointer<br>to a <code>struct trapframe</code>. It’s a clever way to read values off the stack.</p>
<p>So we said we’re gonna check the trap number and decide which kernel function to<br>call based on that, right? Let’s start by checking if the trap number indicates<br>this is a system call (trap number 64, or <code>T_SYSCALL</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;trapno == T_SYSCALL) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Well how should we handle system calls? xv6 will have several, and we don’t even<br>know what they all are yet. So let’s procrastinate again and just call some<br>other function <code>syscall()</code> to handle the work of figuring out which system call<br>to execute. Now we’ll store the pointer to the <code>struct trapframe</code> in that<br>process’s <code>struct proc</code>, obtained with a call to <code>myproc()</code>. Also, processes<br>need to be killed once they’re done, or if they cause an exception; that happens<br>by setting a <code>killed</code> flag in the <code>struct proc</code>. So we’ll check for that before<br>and after carrying out the system call and close the process out with <code>exit()</code><br>if it’s due to be killed.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;trapno == T_SYSCALL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        myproc()-&gt;tf = tf;</span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now we have all the other trap numbers to think about. We could do them<br>with a ton of <code>if</code> statements, but that would be a pain; we’ll use a <code>switch</code><br>statement instead. If you haven’t seen <code>switch</code> statements, they replace big<br><code>if-else</code> blocks with cases instead. The cases can only be indexed by integers,<br>and you have to stick a <code>break</code> statement at the end or else you’ll fall through<br>to the next case and execute the code found there as well. (To be honest, I<br>don’t see a reason why the system call case wasn’t just included in this same<br>switch statement; if you see a reason for that, let me know.)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// cases go here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First up is the trap number for timer interrupts; the main function of timer<br>interrupts is to schedule a new process, but that will come further down in this<br>function. For now, we’ll just increment the <code>ticks</code> counter then call <code>wakeup()</code>,<br>which checks if any processes went to sleep until the next tick; it’ll switch to<br>running any process it finds. There’s one detail to deal with here: the system<br>may have multiple processors, each with their own timer and interrupts. We want<br>to use the <code>ticks</code> counter as a rough timer, but we don’t know whether all the<br>CPU timers will be synchronized, so we’ll only update <code>ticks</code> using the first<br>CPU to avoid those issues.</p>
<p>If you read the post on interrupt controllers then you’ll be familiar with<br><code>lapiceoi()</code>; if you didn’t (or you forgot), it just tells the local interrupt<br>controller that we’ve read and acknowledged the current interrupt so it can<br>clear it and get ready for more interrupts.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">            <span class="keyword">if</span> (cpuid() == <span class="number">0</span>) &#123;</span><br><span class="line">                acquire(&amp;tickslock);</span><br><span class="line">                ticks++;</span><br><span class="line">                wakeup(&amp;ticks);</span><br><span class="line">                release(&amp;tickslock);</span><br><span class="line">            &#125;</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Later on, we’ll see some interrupt handler functions for various devices:<br><code>ideintr()</code> handles disk interrupts, <code>kbdintr()</code> for key presses and releases,<br>and <code>uartintr()</code> for serial port data. We’ll direct the corresponding interrupts<br>to those functions, then acknowledge and clear them with <code>lapiceoi()</code>. Also,<br>devices occasionally generate spurious interrupts due to hardware malfunctions;<br>we’ll either ignore them (if they’re coming from the Bochs emulator) or print a<br>message about it to the console.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_IDE:      <span class="comment">// disk interrupt</span></span><br><span class="line">            ideintr();</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_IDE + <span class="number">1</span>:  <span class="comment">// spurious Bochs disk interrupt</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ0 + IRQ_KBD:      <span class="comment">// keyboard interrupt</span></span><br><span class="line">            kbdintr();</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_IRQ + <span class="number">7</span>:             <span class="comment">// spurious interrupt-no break, FALL THROUGH</span></span><br><span class="line">        <span class="keyword">case</span> T_IRQ + IRQ_SPURIOUS:  <span class="comment">// spurious interrupt</span></span><br><span class="line">            cprintf(<span class="string">&quot;cpu%d: spurious interrupt at %x:%x\n&quot;</span>,</span><br><span class="line">                    cpuid(), tf-&gt;cs, tf-&gt;eip);</span><br><span class="line">            lapiceoi();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, so now we’ve dealt with system calls and hardware interrupts, so any other<br>trap must be a software exception. <code>switch</code> statements allow a catch-all case<br>with <code>default</code>, so we’ll use that to catch the rest of the trap numbers. Now,<br>this may have come from a kernel error or a misbehaving user process. We can<br>check with <code>myproc()</code>, which returns a null pointer if we were running kernel<br>code or a pointer to a <code>struct proc</code> if we were in user space, or by checking<br>the current privilege level in the code segment selector. Depending on the<br>source, we’ll print out an appropriate error message and either panic (if in the<br>kernel) or mark the process so it gets killed soon.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;trapno) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (myproc() == <span class="number">0</span> || (tf-&gt;cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Kernel code exception</span></span><br><span class="line">                cprintf(<span class="string">&quot;unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n&quot;</span>,</span><br><span class="line">                        tf-&gt;trapno, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">                panic(<span class="string">&quot;trap&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// User process exception</span></span><br><span class="line">            cprintf(<span class="string">&quot;pid %d %s: trap %d err %d on cpu %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;eip 0x%x addr 0x%x--kill proc\n&quot;</span>,</span><br><span class="line">                    myproc()-&gt;pid, myproc()-&gt;name, tf-&gt;trapno,</span><br><span class="line">                    tf-&gt;err, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">            myproc()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The reason we don’t kill it immediately is because the process might be executing<br>some kernel code right now; for example, system calls allow other interrupts and<br>exceptions to occur while they’re being handled. Killing it now might corrupt<br>whatever it’s doing. So instead we just give it the kiss of death for now and<br>come back to finish the job later.</p>
<p>So next up, we’ll check if this trap was generated by a user process that’s due<br>to be killed, and that process is running in ring 3. If so, we finally do<br>the deed with <code>exit()</code>; otherwise if it’s running in ring 0, it’ll live for now<br>and get killed the next time it generates a trap instead.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;killed &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == DPL_USER) &#123;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Up above, the only thing a timer interrupt did was increment <code>ticks</code>. But we<br>know a really important function of timer interrupts is to force a process to<br>let go of the CPU and let someone else run. It’s time to do that. We’ll check if<br>the process’s state is <code>RUNNING</code> and the trap was a timer interrupt; if so, we<br>call <code>yield()</code> to let another process get scheduled on this CPU.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;state == RUNNING &amp;&amp;</span><br><span class="line">            tf-&gt;trapno == T_IRQ0 + IRQ_TIMER) &#123;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have one last check: a process that yielded, then got picked up again<br>later might have been marked as killed in the meantime, so if it was, we need to<br>finish it off now. So we do the exact same check as above again, and then we’re<br>done.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (myproc() &amp;&amp; myproc()-&gt;killed &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == DPL_USER) &#123;</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that this function will return into <code>trapret</code> in the assembly code, which<br>will then send it back to user mode.</p>
<h2 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h2><p>Let’s take a moment to assess how much of xv6 we’ve already covered. Remember,<br>the xv6 kernel has four main functions: (1) finishing the boot process that the<br>boot loader started, (2) virtualizing resources in order to isolate processes<br>from each other, (3) scheduling processes to run, and (4) interfacing<br>between user processes and hardware devices. Let’s take that as a checklist and<br>go through those items now.</p>
<p>We’ve already seen some of the initialization routines that get run on boot in<br><code>main()</code>; most of the code there sets up virtual memory and all the hardware<br>devices. We still have a few more devices to talk about: the keyboard, serial<br>port, console, and disk; each of those has its own boot function that we’ll need<br>to go over in order to wrap up point (1).</p>
<p>On the other hand, we’re already done with (2) and (3): we spent a lot of time<br>going over virtual memory and paging, and the last post on scheduling showed us<br>how xv6 virtualizes the CPU as well as it runs processes.</p>
<p>The code we saw in this post was our introduction to point (4). Traps are the<br>primary mechanism for user processes to communicate with the hardware; the<br>kernel coordinates that communication by setting up trap handler functions. The<br>code we’ve seen here basically acts like an usher, directing traps to the<br>right trap handler function depending on its type.</p>
<p>When a trap occurs (x86 instruction <code>int</code>), the processor will stop executing<br>code, find the IDT, and looks up the entry for that trap number. The script that<br>xv6 uses to generate the IDT entries just makes them all point to the same<br>function <code>alltraps()</code>, which saves all the process’s registers, switches into<br>kernel mode, and calls <code>trap()</code>. Then that function uses the trap number to<br>figure out how the kernel wants it to respond to this particular trap. So any<br>hardware interrupt, software exception, or user system call will get funneled<br>into the functions here before getting dispatched to some other appropriate<br>kernel code that will know what to do with it.</p>
<p>We haven’t finished point (4) yet, though: we have to actually see what each of<br>those trap handler functions does. But we did see some of them: for example, we<br>saw that a software exception either kills the process that caused it or panics<br>if it occurred in kernel code. That already takes care of one of the three types<br>of traps, so we’re left with hardware interrupts and system calls. All the<br>system calls got redirected to a <code>syscall()</code> function which we haven’t seen yet.</p>
<p>We have seen how some of the hardware interrupts are dealt with: a timer<br>interrupt increments a <code>ticks</code> counter (if it’s on CPU 0), then calls <code>yield()</code><br>to force a process to give up the CPU until the next scheduling round. Spurious<br>interrupts either get ignored or print a message to the console. But we’ve<br>procrastinated some of the others: disk interrupts call an <code>ideintr()</code> function<br>to handle them, keyboard interrupts call <code>kdbintr()</code>, and serial port interrupts<br>call <code>uartintr()</code>, none of which we’ve gone over.</p>
<p>So in order to wrap up the xv6 kernel, we still have to understand how system<br>calls are routed in general, as well as how devices are initialized at boot and<br>how the kernel responds to specific system calls that require use of those<br>devices. The general system call routing mechanism is up next.</p>
<h1 id="System-Calls-Routing"><a href="#System-Calls-Routing" class="headerlink" title="System Calls: Routing"></a>System Calls: Routing</h1><p>We said in the last post that system calls are the primary means for user<br>processes to request some action by the kernel; system calls mediate processes’<br>access to hardware resources.</p>
<p>If a user process wants to generate a system call, it starts a trap with the<br>trap number for system calls. Then it identifies which of the various xv6 system<br>calls it wants to do and passes any required arguments. The processor will then<br>handle the trap instruction using the code we saw in the last post. Eventually,<br>it’ll get to the <code>trap()</code> function, which will recognize the trap number as a<br>system call and pass it on to the <code>syscall()</code> function.</p>
<p><code>syscall()</code> is itself a routing function like <code>trap()</code>; it’ll figure out which<br>system call the process created and redirect it again to the appropriate kernel<br>code.</p>
<h2 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h2><p>All system calls use the same trap number: 64, or <code>T_SYSCALL</code>, but xv6 has<br>multiple system calls, so we need another number for a process to identify which<br>system call it wants to run. The convention on x86 is to use a system call<br>number which the calling process should put in the <code>%eax</code> register, which<br>usually holds return values. Then the kernel’s handler function (here,<br><code>syscall()</code>) can just check <code>%eax</code> to figure out which system call to run. The<br>system call numbers are defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/syscall.h">syscall.h</a>. There<br>you can see that, e.g. <code>SYS_fork</code> is defined as 1, <code>SYS_exit</code> is 2, and so on.</p>
<p>All the system call functions are defined in other files, so we’ll have to<br>import their declarations with the <code>extern</code> keyword:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Now we’ve got the numbers and the functions. Note that the numbers start with<br>uppercase <code>SYS_</code> and the functions start with lowercase <code>sys_</code>, so make sure<br>your kernel hacking adventures don’t do anything like <code>SYS_fork()</code>; use<br><code>sys_fork()</code> instead.</p>
<p>We’ll also need a way to map the numbers to those system call functions so that<br><code>syscall()</code> can call the right one depending on the number. We could use another<br><code>switch</code> statement like we did in <code>trap()</code>, but there are 21 system calls here,<br>so that would get pretty long; also, each number will just call the specific<br>function, unlike the different trap numbers which required different responses<br>(e.g., the timer interrupt trap number didn’t call any function at all). xv6<br>does something else this time that’s much simpler and more elegant, but it uses<br>some slightly-obscure C features, so we’ll go over it carefully.</p>
<p>Remember function pointers from way back in the boot loader? Functions are just<br>a set of instructions in order, loaded somewhere in the kernel’s code segment,<br>so C lets us use the function’s name as a pointer to the beginning of its code<br>in memory. So if we have a C function like <code>int func(char c)</code>, then <code>func</code> is<br>its function pointer. We could even assign it to a variable; that variable’s<br>type would be a pointer to a function of argument type <code>char</code> and return type<br><code>int</code>; then we could call the function using the new pointer too. Here’s an<br>example that would print “Match!” to the screen:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = func(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*func_ptr)(<span class="type">char</span>) = &amp;func;</span><br><span class="line"><span class="type">int</span> n = (*func_ptr)(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So instead of a big old <code>switch</code> statement, the <code>syscall()</code> function will use a<br>static, global array of pointers to all the system call functions we just<br>imported above. (Remember that the <code>static</code> keyword in front of a variable means<br>it always occupies the same fixed place in memory.) It’ll work because all the<br>functions have the same argument type (<code>void</code>) and return type (<code>int</code>), so their<br>pointers all have the same type and can fit inside a single array. Then we can<br>get the right function by just using the system call number to index into the<br>array of function pointers.</p>
<p>Now, we’d have to be super careful to add the function pointers into the array<br>in the right order so that the indices match up. Even worse, there is no system<br>call with number zero, so we’d have to skip that entry of the array. This could<br>get complicated. Luckily, even though humans are bad at this kind of thing,<br>computers are <em>really</em> good at it. So instead of trying to line them up by hand,<br>we can use the array notation from <code>procdump()</code> in the post on processes where<br>we specified the value of each entry of an array like this with the index in<br>square brackets, like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; [<span class="number">2</span>] <span class="number">5</span>, [<span class="number">0</span>] <span class="number">1</span>, [<span class="number">4</span>] <span class="number">-2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>The C compiler will use the indices we wrote there to figure out that the array<br>needs 5 entries (indices 0 to 4), and entry 0 is 1, entry 2 is 5, and entry 4 is<br>-2. Entries 1 and 3 will just be initialized to zero.</p>
<p>So at the end of the day, our array of pointers to system call functions looks<br>like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork]      sys_fork,</span><br><span class="line">    [SYS_exit]      sys_exit,</span><br><span class="line">    [SYS_wait]      sys_wait,</span><br><span class="line">    [SYS_pipe]      sys_pipe,</span><br><span class="line">    [SYS_read]      sys_read,</span><br><span class="line">    [SYS_kill]      sys_kill,</span><br><span class="line">    [SYS_exec]      sys_exec,</span><br><span class="line">    [SYS_fstat]     sys_fstat,</span><br><span class="line">    [SYS_chdir]     sys_chdir,</span><br><span class="line">    [SYS_dup]       sys_dup,</span><br><span class="line">    [SYS_getpid]    sys_getpid,</span><br><span class="line">    [SYS_sbrk]      sys_sbrk,</span><br><span class="line">    [SYS_sleep]     sys_sleep,</span><br><span class="line">    [SYS_uptime]    sys_uptime,</span><br><span class="line">    [SYS_open]      sys_open,</span><br><span class="line">    [SYS_write]     sys_write,</span><br><span class="line">    [SYS_mknod]     sys_mknod,</span><br><span class="line">    [SYS_unlink]    sys_unlink,</span><br><span class="line">    [SYS_link]      sys_link,</span><br><span class="line">    [SYS_mkdir]     sys_mkdir,</span><br><span class="line">    [SYS_close]     sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Okay great, now we’re ready to route system calls to the right function.</p>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>The first thing we need to do is get the system call number so we can figure out<br>which function to call. We said above that the x86 convention is to store it in<br>the <code>%eax</code> register, but we might have a problem: by the time we get to<br><code>syscall()</code>, the processor has already executed the code in the trap handler<br>function for trap number <code>T_SYSCALL</code>, which sent it to <code>alltraps()</code>, which<br>replaced all the register contents with those of <code>trap()</code>, so the system call<br>number is probably long gone from <code>%eax</code>.</p>
<p>But wait, all is not lost! <code>alltraps()</code> saved all the registers in a<br><code>struct trapframe</code> for the current process. So we can just read the value of<br><code>%eax</code> from there. Whew, that was some good forward-thinking.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> num = curproc-&gt;tf-&gt;eax;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we just need to do one more thing: call the function that corresponds to<br>that number. We’re gonna use the array of function pointers above, but we have<br>to be careful: this number was given to us by a user process. A malicious user<br>process might pass in an invalid number in the hopes of getting the kernel to<br>carry out some undefined behavior which might lead to an easy exploit. So in<br>order to keep up good security practices, the kernel should <em>always</em> distrust<br>anything originating from user code and handle it carefully, preferably with<br>three-inch-thick lead-lined gloves. So let’s think about it: what might go<br>wrong?</p>
<p>First of all, any entries that weren’t explicitly initialized above (including<br>the 0 entry) will have been automatically initialized to zero, i.e. a null<br>pointer. Also, a number that’s bigger than the highest system call number will<br>make us do an out-of-bounds read from the array, thus possibly executing some<br>arbitrary kernel code that’s stored after the array in memory. So we should<br>check that (1) the number is greater than 0, (2) it’s smaller than the number of<br>elements in the array, and (3) the entry it points to is not a null pointer.</p>
<p>Finally, the <code>%eax</code> register is usually used in x86 to store return values, so<br>we’ll put the return value of the system call function there. If any of the<br>above checks failed, we’ll just print a message to the console and return -1 to<br>indicate failure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invalid system call number</span></span><br><span class="line">        cprintf(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>, curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">        curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The system call handler function will store its return value in <code>%eax</code>; after<br>that, <code>syscall()</code> will return to the line below where it was called in <code>trap()</code>.<br>After executing the rest of the code there, <code>trap()</code> will return into <code>trapret()</code>,<br>which ends with an <code>iret</code> (interrupt return) instruction to tell the processor<br>to switch to user mode and resume executing the process’s code.</p>
<h3 id="fetchint"><a href="#fetchint" class="headerlink" title="fetchint"></a>fetchint</h3><p>Take a look at the <code>sys_</code> functions we imported above: they all have argument<br>type <code>void</code>. But if you think about it, many system calls need an argument: for<br>example, <code>open()</code> needs to know which file to open, <code>chdir()</code> needs to know<br>which directory to open, <code>kill()</code> needs a PID to know which process to kill,<br>etc. So why did we make them all have argument type <code>void</code>?</p>
<p>The trouble is that until we get the system call number in <code>syscall()</code> above, we<br>have no way of knowing which function we’ll need. And each function takes<br>arguments with different types, e.g. <code>open()</code> might need a string for the file<br>to open but <code>kill()</code> might need an integer for the PID. So there’s no way for<br>the kernel to know which arguments to expect in <code>syscall()</code>, even though the<br>arguments were already pushed on the stack. The task of recovering the arguments<br>from the stack will have to fall to each of the <code>sys_</code> functions. But let’s go<br>ahead and make their lives a little easier by setting up some nice helper<br>functions now.</p>
<p>The system call functions might take integers, strings, or pointers, so we’ll<br>need functions to fetch each of those types. <code>fetchint()</code> is one example; it<br>takes a user virtual address (an integer argument’s location in memory) and a<br>pointer to an integer where we can store the integer we find. Then it returns 0<br>if it was able to find it, or -1 if it failed.</p>
<p>Just like <code>syscall()</code> above, we need to treat anything passed from user space<br>with extreme caution. A user process that tries to read or write memory outside<br>its address space will cause a segmentation fault or page fault and be killed,<br>but the kernel has free reign over memory, so a malicious process might try to<br>trick the kernel into doing that <em>for</em> it by putting its “argument” outside of<br>the user’s address space. So we have to start by checking that the entire 4<br>bytes of the integer is inside the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchint</span><span class="params">(uint addr, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt;= curproc-&gt;sz || addr + <span class="number">4</span> &gt; curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can just cast the address to a pointer, dereference it, and store the<br>value in <code>*ip</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchint</span><span class="params">(uint addr, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *ip = *(<span class="type">int</span> *)(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we can use an address like <code>addr</code> which will be in the lower half of<br>memory because traps don’t perform a full context switch, so we’re still using<br>the process’s page directory even though we’re in kernel mode (ring 0). If we<br>had switched to a kernel page directory, we’d have to call <code>walkpgdir()</code> or<br><code>uva2ka()</code> to figure out the corresponding kernel virtual address for <code>addr</code>.</p>
<p>Now hopefully, if you’ve taken anything away from my past rants about undefined<br>behavior in C, you noticed something wrong with this function. If you didn’t,<br>take another look; I’ll wait.</p>
<p>Did you see it? We’re dereferencing <code>addr</code> without checking that it’s not null,<br>so if the user passed in a null address, we’d dereference a null pointer! We<br>also dereference <code>ip</code> without a similar check, but at the very least <code>ip</code> is<br>passed in by the kernel.</p>
<p>This could be very dangerous – in general, it’s undefined behavior in C, but<br>now that we’ve seen the code for handling traps, we’re actually at a point where<br>we can figure out what would happen in xv6 if a null pointer gets dereferenced,<br>so let’s take the opportunity to think about it for a bit.</p>
<p>First, what would happen if the kernel dereferenced a null pointer? Well, if the<br>kernel is currently using <code>kpgdir</code> as a page directory, the address 0 isn’t<br>mapped to anything, so when the paging hardware goes to figure out which physical<br>address corresponds to the kernel virtual address 0, it would fail and generate<br>a “General Protection Fault” (trap number 13, or <code>T_GPFLT</code>). That would start<br>running the trap handler code, which would eventually get to the <code>switch</code><br>statement in <code>trap()</code> (see the last post). Trap number 13 would fall under the<br><code>default</code> case, and the if statement there would recognize that it originated in<br>the kernel. So it would print an error message to the console, then panic.</p>
<p>Okay, what if we’re using a process’s page directory, e.g. during a system call?<br>Address 0 is in the lower half of memory, so it’s a user virtual address. The<br>result will depend on whether that page and its page table are mapped in the<br>process’s page directory. If they are, then dereferencing a null pointer might<br>be fine after all. But if they’re not mapped, dereferencing a null pointer will<br>cause a General Protection Fault. This time, <code>trap()</code> would print an error<br>message to the console, then mark the process to be killed.</p>
<p>Now, killing a process or causing a kernel panic might not sound like a huge<br>deal. In fact, xv6 does a great job here by killing a process that might have<br>dereferenced a null pointer or caused the kernel to do so. A kernel panic would<br>be much worse – think about how annoying it would be if that PDF you downloaded<br>from that one sketchy website installed some malware that made your kernel panic<br>all the time – the OS would become unusable. In fact, this is an example of a<br>“denial of service” vulnerability – a malicious process might not be able to<br>read or write arbitrary memory or execute arbitrary code, but it can still keep<br>you from using your machine the way you expect to.</p>
<p>Just like <code>uva2ka()</code>, this function will only get called by one other function<br>(we’ll see it soon), so it just so happens that under the current xv6 code,<br>it’ll all be okay because it should never get passed a null pointer. But<br>everything from my rant about <code>uva2ka()</code> applies here: if you add any kernel<br>code that calls this function, be <em>VERY</em> careful and add your own null checks.</p>
<p>Okay, deep breath now. &#x2F;rant.</p>
<h3 id="fetchstr"><a href="#fetchstr" class="headerlink" title="fetchstr"></a>fetchstr</h3><p>Fetching a string argument is tricky too; strings in C are just pointers to an<br>array of characters that ends in nul, i.e. <code>&#39;\0&#39;</code>, so this time we have to make<br>sure that both the pointer <em>and</em> the entire string are in the user’s address<br>space; otherwise, we could unwittingly read from some arbitrary memory location<br>and pass the data back to the user process.</p>
<p>So we’ll start by making sure the pointer itself is in a valid address:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt;= curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we’ll store the string pointer in <code>*pp</code>. We’ll also get a pointer to the end<br>of the process’s virtual address space so we can make sure the entire string is<br>inside its bounds.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pp = (<span class="type">char</span> *) addr;</span><br><span class="line">    <span class="type">char</span> *ep = (<span class="type">char</span> *) curproc-&gt;sz;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>How can we check if the entire string is inside user memory? Well, a string ends<br>with a nul byte, <code>&#39;\0&#39;</code>, so we just have to start scanning the memory starting<br>from <code>*pp</code> up to <code>ep</code> until we find a zero byte. If we find one in that range,<br>then the entire string is in user memory and we can return its length to<br>indicate success; otherwise the string overflows past the end of the process’s<br>virtual address space, so we should return -1 to indicate failure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint addr, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for a nul byte inside process&#x27;s address space</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> *s = *pp; s &lt; ep; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If nul byte found, return the length</span></span><br><span class="line">            <span class="keyword">return</span> s - *pp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// String is not nul-terminated inside process&#x27;s memory, so report failure</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that again, we’re dereferencing <code>pp</code> and <code>addr</code> without any null checks<br>(where <code>addr</code> is definitely the bigger concern, since it’s user-generated), and<br>again, it’s gonna work out okay (a misbehaving process will just get killed),<br>but once more: be careful if you use this function for your own kernel hacks.</p>
<h3 id="argint"><a href="#argint" class="headerlink" title="argint"></a>argint</h3><p>This is the main function that the <code>sys_</code> system call functions will use to<br>recover an integer argument; it’s basically just a wrapper for <code>fetchint()</code>. The<br>arguments are an integer <code>n</code> to say we want the nth integer argument, and a<br>pointer <code>ip</code> to store the recovered argument in. We have to call <code>fetchint()</code><br>with an address argument, so the main task now is to figure out where in memory<br>the nth integer argument should be.</p>
<p>We’re gonna have to use the x86 function call conventions again. Remember how<br>whenever we call a function in x86, its arguments get pushed onto the stack in<br>reverse order (i.e., from right to left), so that the first argument is at the<br>top of the stack (i.e., lowest memory address)? Then we push a return address<br>(<code>%eip</code>) and the old stack base pointer <code>%ebp</code>. Normally, the stack pointer<br>would just keep going on to the next slot on the callee’s stack, but in this<br>case the code in <code>alltraps()</code> saved all the registers (including the stack<br>pointer <code>%esp</code>) in a <code>struct trapframe</code> before calling <code>trap()</code> or <code>syscall()</code>.</p>
<p>That means we can recover the old value of <code>%esp</code> from the trap frame and look<br>one spots below that on the stack (i.e., 4 bytes higher in memory, since <code>int</code>s<br>are 4 bytes) to get the first (<code>n = 0</code>) argument. The second argument (<code>n = 1</code>)<br>would be 8 bytes higher than <code>%esp</code>, and so on. Pretty neat.</p>
<p>Okay, now that we’ve got that down, the code for this function is pretty<br>straightforward.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fetchint((myproc()-&gt;tf-&gt;esp) + <span class="number">4</span> + <span class="number">4</span>*n, ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="argptr"><a href="#argptr" class="headerlink" title="argptr"></a>argptr</h3><p>Some of the system call functions will have pointer arguments, so this function<br>recovers them. Pointers are 4 bytes in x86, so we can use <code>argint()</code> to get the<br>pointer itself before performing some additional checks to make sure the pointer<br>and the address it points to are valid.</p>
<p>The arguments are <code>n</code> (to retrieve the nth function argument), a pointer <code>pp</code> to<br>an address where we can store the retrieved pointer, and the size of the block<br>of memory that the retrieved pointer points to.</p>
<p>Let’s start off by just retrieving the value of the pointer as an integer using<br><code>argint()</code>; that’ll make sure that the number <code>n</code> is valid.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (argint(n, &amp;i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have to make sure that the pointer we just retrieved is itself valid,<br>i.e. that the size is nonnegative and the beginning and end of the memory block<br>it points to are both within the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (uint) i &gt;= curproc-&gt;sz || (uint) i + size &gt; curproc-&gt;sz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we can store the pointer in <code>*pp</code> and return 0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argptr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *pp = (<span class="type">char</span> *) i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="argstr"><a href="#argstr" class="headerlink" title="argstr"></a>argstr</h3><p>A string is just a pointer in C, so we can recover the pointer’s value using<br><code>argint()</code> again, then pass it to <code>fetchstr()</code>. The former will make sure <code>n</code> is<br>valid, and the latter will make sure the string is nul-terminated and resides<br>entirely in the process’s address space.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (argint(n, &amp;addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchstr(addr, pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sysproc-c"><a href="#sysproc-c" class="headerlink" title="sysproc.c"></a>sysproc.c</h2><p>So now we know how <code>syscall()</code> will route a system call trap to the right <code>sys_</code><br>function, and we’ve seen how those functions can recover arguments from the<br>process’s stack. Let’s see some examples in action; most of these will be simple<br>wrapper functions.</p>
<h3 id="sys-fork"><a href="#sys-fork" class="headerlink" title="sys_fork"></a>sys_fork</h3><p>All the hard work here is gonna be done by <code>fork()</code>, which will create a new<br>child process by cloning the parent process’s virtual address space. We don’t<br>need any arguments for this, so we’ll just call <code>fork()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-exit"><a href="#sys-exit" class="headerlink" title="sys_exit"></a>sys_exit</h3><p><code>exit()</code> closes out a process, but it puts it in the <code>ZOMBIE</code> state so that the<br>parent process can call <code>wait()</code> to find out it’s done running. <code>exit()</code> should<br>never return, so we’ll add a return value here to make the compiler happy, but<br>it should never get executed.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-wait"><a href="#sys-wait" class="headerlink" title="sys_wait"></a>sys_wait</h3><p>This system call is the parent process’s counterpart to <code>exit()</code>; it’ll do as<br>its name says and wait until the child process exits.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-kill"><a href="#sys-kill" class="headerlink" title="sys_kill"></a>sys_kill</h3><p>The <code>kill()</code> system call sounds like a more aggressive version of <code>exit()</code>:<br>after all, we’re killing another process against its will, right? But in reality<br>it would be way too complicated to do that: the process might be running on<br>another CPU, midway through updating some kernel data structure, or about to<br>wake up another process that’s asleep. Killing it by force might screw up a lot<br>of other things.</p>
<p>So instead <code>kill()</code> just tags it with the <code>killed</code> field in its <code>struct proc</code>;<br>eventually either the process will call <code>exit()</code> on its own, or it’ll generate<br>another trap, at which point the code in <code>trap()</code> will call <code>exit()</code> on it.</p>
<p><code>kill()</code> needs an integer argument: the process ID for the process we wish to<br>kill. So now we can see the payoff of writing those functions above.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;pid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kill(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-getpid"><a href="#sys-getpid" class="headerlink" title="sys_getpid"></a>sys_getpid</h3><p>The <code>getpid()</code> system call is so simple that it doesn’t even have another<br>function for this <code>sys_getpid()</code> to call. We’ll just return the PID for the<br>current process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> myproc()-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-sbrk"><a href="#sys-sbrk" class="headerlink" title="sys_sbrk"></a>sys_sbrk</h3><p>If you’re not familiar with system calls like <code>brk()</code> and <code>sbrk()</code> on Unix<br>systems, here’s what they do: they grow or shrink the virtual address space of a<br>process. <code>brk()</code> sets its new size to a specific maximum address; <code>sbrk()</code> grows<br>or shrinks the process by a certain size in bytes and returns its old size.<br>They’re mostly used to implement higher-level memory management functions like<br><code>malloc()</code>. Heh, “high-level” probably isn’t high on your mind when you think of<br>adjectives for <code>malloc()</code>, right? Anyway, xv6 only has <code>sbrk()</code>, so let’s check<br>out its <code>sys_</code> wrapper function.</p>
<p>We’ll need an integer argument (the number of bytes to grow or shrink by), so<br>let’s grab that.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can use <code>growproc()</code> from our posts on paging to grow the process by <code>n</code><br>bytes. But we want to return the old size, so we’ll have to grab that before we<br>change it with the call to <code>growproc()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> addr = myproc()-&gt;sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (growproc(n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-sleep"><a href="#sys-sleep" class="headerlink" title="sys_sleep"></a>sys_sleep</h3><p>The <code>sleep()</code> function is pretty interesting; we’ll get to the implementation<br>details later, but let’s talk about the broad strokes now. You might be familiar<br>with the <code>sleep()</code> system call in Unix systems; you pass it an integer (usually<br>in milliseconds) and it puts your process to sleep (i.e., leaves it inactive or<br>not running) for that amount of time.</p>
<p>However, <code>sleep()</code> plays a dual role in xv6: the kernel will call <code>sleep()</code> for<br>processes that need to wait while something else happens, e.g. waiting for a<br>disk to read or write data. That way the processes don’t end up idly spinning in<br>a loop or something and wasting valuable CPU time.</p>
<p>Implementing that is tricky; there’s no way to know how long it would take for<br>whatever condition the process is waiting on to be satisfied, so it’s not like<br>we can just stick in a random amount of time in the call to <code>sleep()</code> and hope<br>the condition is satisfied by then. So instead the <code>sleep()</code> function will just<br>“put a process to sleep” (read: make its state <code>SLEEPING</code> so it can’t be run by<br>the scheduler) on a <em>channel</em>, which is just an arbitrary integer. Then later on<br>the kernel can wake up any processes sleeping on that channel. So for example,<br>the kernel can put a process waiting on the disk to sleep using a specific<br>channel that’s assigned to the disk; then when the next disk interrupt occurs it<br>can wake up any processes that might be sleeping on the disk channel.</p>
<p>Okay so that’s all well and good for the kernel’s use of <code>sleep()</code>. But what<br>about the regular old <code>sleep()</code> system call? The argument is an integer that<br>represents the number of ticks to sleep for; how are we gonna turn that into a<br>channel to sleep on?</p>
<p>The answer is pretty neat (at least I think so): we’ll set the channel to the<br>address of the <code>ticks</code> counter. Remember, <code>ticks</code> is a global variable that gets<br>incremented with every timer interrupt. Go check out the code in <code>trap()</code> again:<br>each timer interrupt sends a wakeup call to any processes that might be sleeping<br>on the <code>&amp;ticks</code> channel. That should wake the process at every timer interrupt.<br>Then we’ll just stick that inside a for loop so it keeps sleeping forever until<br>the right amount of ticks have passed.</p>
<p>Let’s start by retrieving the integer argument, which is the number of ticks to<br>sleep for.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That argument <code>n</code> is a relative count, since a user process won’t necessarily<br>know how many ticks have already gone by. So let’s get the current tick count<br>before we put the process to sleep.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    uint ticks0 = ticks;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we just have to write that while loop I mentioned above to put the process<br>to sleep until <code>n</code> ticks have passed. Since we started counting at <code>ticks0</code>, the<br>condition should be satisfied when <code>ticks - ticks0 == n</code>.</p>
<p>Two more details: first, we’ll add a check inside the while loop to see if the<br>current process has been tagged to be killed; if so, we’ll just return -1 so we<br>can hasten the process’s actual death by letting it run more code so the kernel<br>will call <code>exit()</code> on it at the next trap. Second, the function <code>sleep()</code> takes<br>another argument in addition to the channel: a lock. It’ll release the lock for<br>us and reacquire it before waking up so that a sleeping process doesn’t hog a<br>lock when it doesn’t need it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (ticks - ticks0 &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myproc()-&gt;killed) &#123;</span><br><span class="line">            release(&amp;tickslock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sys-uptime"><a href="#sys-uptime" class="headerlink" title="sys_uptime"></a>sys_uptime</h3><p>The <code>uptime()</code> system call just returns the amount of ticks that have passed<br>since the system started. This is another one that’s so simple it doesn’t need<br>another function, so we’ll take care of it all here.</p>
<p>We just acquire the lock for <code>ticks</code>, get its current value, release the lock,<br>and return the value we got.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    uint xticks = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> xticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Running-System-Calls-from-User-Code"><a href="#Running-System-Calls-from-User-Code" class="headerlink" title="Running System Calls from User Code"></a>Running System Calls from User Code</h2><p>We have system calls now! Well, not quite – we still have to check out the<br>actual functions like <code>exit()</code>, <code>sleep()</code>, <code>kill()</code>, etc. Plus, we only saw the<br><code>sys_</code> wrapper functions for <em>some</em> of the system calls here; the rest are in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/sysfile.c">sysfile.c</a>, which<br>we’ll get to after we understand the xv6 file system.</p>
<p>But let’s pause for a second and think about how a user process will send a<br>system call. Like let’s say you’re writing some C code for a user program that<br>will run on xv6 and you want to create a child process with <code>fork()</code>. What<br>should you do?</p>
<p>Well, if you were coding for a Unix system like Linux or macOS, you’d just write<br>a call to <code>fork()</code> in your code. But that can’t be right in xv6, can it? After<br>all, <code>fork()</code> is a kernel function, to be run in kernel mode with a current<br>privilege level of 0. Plus, isn’t it supposed to be called by <code>sys_fork()</code>? So<br>should we call that?</p>
<p>None of these options will work. Well, yes, you do end up just calling <code>fork()</code>,<br>but it’s <em>not</em> the kernel function <code>fork()</code>, so if you’re expecting that one,<br>you’ll be surprised when it doesn’t behave the way you want it to. You won’t be<br>able to use any kernel code at all in your user program for xv6. This is a<br>mistake I’ve seen a <em>lot</em> of people make in their xv6 OSTEP projects, so bear<br>with me for a second while I explain why you can’t do it; feel free to skip the<br>next section on the Makefile if you already know why.</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>To see why, let’s check out the xv6<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a> to see<br>how xv6 is actually compiled, built, and run. There’s a ton of stuff in there,<br>but take a second to think about this: how do you usually run xv6? I bet it’s<br>a command like <code>make qemu</code> or <code>make qemu-nox</code>, right?</p>
<p>If you’re not familiar with Makefiles, here’s a quick primer: each command like<br><code>make qemu</code>, <code>make clean</code>, etc. is specified in the Makefile with a rule that<br>looks like this:</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mycmd: dependency1 dependency2 ...</span></span><br><span class="line">    build_cmd1</span><br><span class="line">    build_cmd2</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>So if I run <code>make mycmd</code>, the <code>make</code> program will check that <code>dependency1</code>,<br><code>dependency2</code>, etc. are up to date; if they’re not, it’ll update them by looking<br>up <em>their</em> rules and executing those to update them. Then it’ll execute<br><code>build_cmd1</code> on the shell, followed by <code>build_cmd2</code>, etc.</p>
<p>Okay, I know that might be confusing, so let me simply the <code>make qemu</code> command a<br>bit to make it more readable (note that I cut a lot of stuff out here, so don’t<br>try to run xv6 with what I wrote below).</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">qemu: fs.img xv6.img</span></span><br><span class="line">    qemu -drive file=fs.img,index=1 -drive file=xv6.img,index=0</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>This just says that in order to run <code>make qemu</code> when you type it on the<br>terminal, the <code>make</code> program first has to make sure that both <code>fs.img</code> and<br><code>xv6.img</code> are fully up to date. Then once they are, it can just run the shell<br>command <code>qemu</code> with the options <code>-drive file=fs.img,index=1</code> and<br><code>-drive file=xv6.img,index=0</code>. Those options are just regular flags like the<br>ones you’re probably used to with stuff like <code>ls -a</code> or <code>rm -rf</code>. In this case,<br>they tell <code>qemu</code> to use the files <code>fs.img</code> and <code>xv6.img</code> as virtual hard drives,<br>with <code>xv6.img</code> as disk number 0 and <code>fs.img</code> as disk number 1.</p>
<p>Okay, let’s check out the <code>make</code> command for <code>xv6.img</code> next.</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">xv6.img: bootblock kernel</span></span><br><span class="line">    <span class="comment"># some dd commands here</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Hey, that’s interesting, we already saw <code>bootblock</code> in a prior post. That’s the<br>one we get when we compile the boot loader. <code>kernel</code> is, well, all the kernel<br>code. The <code>dd</code> command is often used in Unix systems to format and set up disks;<br>the details aren’t important here, so I left them out for now. The point is that<br>the boot loader got compiled separately from the kernel code, remember? But<br>their machine code files get smushed into the same (virtual) disk together as<br><code>xv6.img</code>, which will be disk 0 when we run in <code>qemu</code>.</p>
<p>Not let’s check out the (slightly simplified) <code>make</code> command for <code>fs.img</code>.</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">UPROGS = cat echo forktest grep init kill ln ls <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="section">fs.img: mkfs README <span class="variable">$(UPROGS)</span></span></span><br><span class="line">    ./mkfs fs.img README <span class="variable">$(UPROGS)</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>Okay, so <code>UPROGS</code> is just a list of all the user programs. Each of those gets<br>compiled separately; e.g. if you look in their source code, you’ll see each one<br>has its own <code>main()</code> function. Then the shell command says to run <code>mkfs</code> to<br>create a file system called <code>fs.img</code> with <code>README</code> and all the user programs as<br>files.</p>
<p>The point of this detour is this: the boot loader gets compiled as a single<br>unit, as does the entire kernel code. But the user programs are compiled one at<br>a time. So if you write a user program for xv6, you should add it to the list in<br><code>UPROGS</code> (as well as in <code>EXTRA</code>) and expect it to get compiled individually and<br>stuck onto the <code>fs.img</code> disk.</p>
<p>That means there’s no way for a user program to call into any kernel code; the<br>linker wouldn’t even be able to match up the call to the right function. So no<br>user program will ever be able to call functions like (the kernel’s) <code>fork()</code>.<br>Think about it: if you write a program in C and compile it to run on Linux, do<br>you expect to have to recompile the entire Linux kernel just to run your one<br>little program? No, right?</p>
<p>But certainly we can’t just expect every single program ever to be totally self-<br>contained. You also don’t have to rewrite and recompile all of <code>malloc()</code> every<br>time you write a C program. So operating systems provide libraries for users to<br>include and call in their programs. Aha! So all we need to do in order for<br>user processes to execute system calls is to provide a library. That library is<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/usys.S">usys.S</a>.</p>
<h3 id="usys-S"><a href="#usys-S" class="headerlink" title="usys.S"></a>usys.S</h3><p>Let’s trace back to the beginning of a trap. In order to execute a system call,<br>we’re supposed to send the processor an <code>int</code> instruction with a specific trap<br>number; that would be <code>int 64</code> for system calls on xv6. We’re also supposed to<br>stick the system call number in the <code>%eax</code> register. Let’s say we want to call<br><code>fork()</code>. According to<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/syscall.h">syscall.h</a>, the<br>system call number for fork is <code>SYS_fork</code>, or 1. In order to send a specific x86<br>instruction and manipulate individual registers, we’ll have to write our system<br>call library in assembly. Here’s what it would look like for the <code>fork()</code> system<br>call:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.globl fork</span><br><span class="line">fork:</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>Okay, that’s easy enough, but we have 21 of these to write, and it would be<br>pretty easy to make a mistake or write the wrong system call number. Let’s<br>automate it instead with a C preprocessor macro. We’ve seen plenty of examples<br>of defining simple constants with <code>#define</code> directives for the preprocessor, but<br>we haven’t looked at them too closely until now.</p>
<p>The C preprocessor is a piece of software that edits C (or assembly) code before<br>it’s compiled. Preprocessor directives like <code>#define A 5</code> create macros that are<br>expanded to replace every instance of <code>A</code> in the code with the number 5;<br>directives like <code>#include &quot;header.h&quot;</code> expand such that they essentially copy-<br>paste all the code in the file <code>header.h</code>. We can also create function-like<br>macros like the <code>P2V()</code> and <code>V2P()</code> macros we’ve used often by adding a<br>parameter inside parentheses; unlike functions, these will be expanded <em>before</em><br>compilation to paste the code into every instance of its use, thus avoiding the<br>usual overhead associated with a function call. Function-like macros are also<br>generic, in a sense, since they don’t require specifying parameter types or<br>return types (as long as it works within the places where the macro will be<br>used). Note that there are some drawbacks: macros aren’t type-checked, they can<br>evaluate their arguments more than once, we can’t use pointers to them like we<br>can with functions, and they can result in larger code.</p>
<p>We’re gonna use a function-like macro here to create the assembly code for each<br>system call function so that it gets expanded before the code is assembled.<br>We’ll use <code>T_SYSCALL</code> instead of 64 in the code above, and <code>SYS_fork</code> (or its<br>equivalent for each system call) for the system call number. We’ll have to<br>replace the part after the underscore in <code>SYS_</code> with the name of the system call<br>function; we can do that with the token-pasting operator <code>##</code>, which glues two<br>tokens together to form a single token. Also, macros must be defined on a single<br>line, so we’ll escape the newline characters with <code>\</code> and end each assembly line<br>with a semicolon.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line">#include &quot;traps.h&quot;</span><br><span class="line"></span><br><span class="line">#define SYSCALL(name) \</span><br><span class="line">    .globl name; \</span><br><span class="line">    name: \</span><br><span class="line">        movl    $SYS_##name, %eax; \</span><br><span class="line">        int $T_SYSCALL; \</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>Now we can just invoke the macro on the name of each function we want to create:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line">SYSCALL(fork)</span><br><span class="line">SYSCALL(exit)</span><br><span class="line">SYSCALL(wait)</span><br><span class="line"># and so on ...</span><br></pre></td></tr></table></figure>

<p>After the preprocessor runs on the file, the result will look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.globl fork</span><br><span class="line">fork:</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl exit</span><br><span class="line">exit:</span><br><span class="line">    movl    $2, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl wait</span><br><span class="line">wait:</span><br><span class="line">    movl    $3, %eax</span><br><span class="line">    int     $64</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"># and so on...</span><br></pre></td></tr></table></figure>

<p>Great! Now we have 21 functions for the system calls, all written in assembly.<br>All user programs for xv6 will be compiled together with the code for these<br>functions: see <code>ULIB</code> in the Makefile. So now, a user program can execute a<br>system call by calling these functions, e.g. <code>fork()</code>.</p>
<h2 id="Summary-9"><a href="#Summary-9" class="headerlink" title="Summary"></a>Summary</h2><p>After all the preparations are handled by the trap handler functions in the IDT,<br><code>alltraps()</code>, and <code>trap()</code>, system calls get routed to the <code>syscall()</code> function,<br>which uses a system call number to pick the right function out of an array. That<br>function will have to recover any arguments to the system call before passing it<br>on to the real system call function later on.</p>
<p>Next up, we’ll take a look at some of those system calls; we’ll leave the rest<br>until after we go over xv6’s file system.</p>
<h1 id="System-Calls-Processes"><a href="#System-Calls-Processes" class="headerlink" title="System Calls: Processes"></a>System Calls: Processes</h1><p>In a previous post, I pointed out some of the most important functions a kernel<br>has to fulfill. System calls take care of two of these: virtualizing resources<br>via virtual memory and processes, and mediating communication between user-mode<br>processes and the hardware. We’ll wrap up the former now by looking at the<br>system call functions relating to processes and scheduling.</p>
<h2 id="proc-c-2"><a href="#proc-c-2" class="headerlink" title="proc.c"></a>proc.c</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>Unlike some of the other functions we’ll talk about in this post, <code>fork()</code> is<br>used almost exclusively by user code as a system call; the kernel never calls<br>it. That said, it has an extremely important role: after the first process has<br>started, it’s the only way to create more processes. It does that by copying the<br>parent process’s virtual address space into a new page directory. We haven’t<br>talked about the file system yet, but hopefully you’re familiar with file I&#x2F;O in<br>Linux, so you know each process has its own list of open files and a current<br>working directory; <code>fork()</code> will clone those as well for the child process.</p>
<p>Let’s start off by getting a pointer to the parent process and creating a slot<br>in the process table for the child process with <code>allocproc()</code>. Remember, that<br>function returns a pointer to the new process’s <code>struct proc</code>, but it can fail<br>and return null (e.g., if there is no available slot in the process table, or if<br>its call to <code>kalloc()</code> fails), so we’ll need to check for that.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate process table slot for child process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((np = allocproc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allocproc()</code> also sets up the new process’s stack so that it’ll return into<br><code>forkret()</code>, then <code>trapret()</code>, before context switching into user mode, and sets<br>the process’s state to <code>EMBRYO</code>.</p>
<p>Next we need a page directory for the new child process; it should be a copy of<br>the parent process’s page directory. Luckily, we already did the hard work for<br>this back in the virtual memory posts, so we can just use <code>copyuvm()</code> now. That<br>function can also fail, in which case we’ll free the stack that <code>allocproc()</code><br>created and set the child process’s state back to <code>UNUSED</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((np-&gt;pgdir = copyuvm(curproc-&gt;pgdir, curproc-&gt;sz)) == <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(np-&gt;kstack);</span><br><span class="line">        np-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        np-&gt;state = UNUSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll copy the parent process’s size and trap frame; the latter will make<br>sure the child starts executing after <code>trapret()</code> with the same register<br>contents as the parent. We’ll set the child process’s parent to, well, its<br>parent (the current process).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    np-&gt;sz = curproc-&gt;sz;</span><br><span class="line">    np-&gt;parent = curproc;</span><br><span class="line">    *np-&gt;tf = *curproc-&gt;tf;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The two processes will be nearly identical, so we need a way to distiguish them<br>from user space so that a user program can give different instructions to each.<br>xv6 follows the Unix convention that <code>fork()</code> should return the child process’s<br>PID to the parent and return 0 for the child. The parent’s return value is easy;<br>we’ll just literally return the child’s PID at the end. But the child didn’t<br>actually call <code>fork()</code>, so how can we set a return value that it will see?</p>
<p>Well, the x86 convention is for return values to be passed in the <code>%eax</code><br>register, right? And that register will be restored from the trap frame before<br>switching into user mode. So we’ll just store the value 0 there.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    np-&gt;tf-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll copy all the parent process’s open files and its current working<br>current working directory. The files are stored in a per-process file array<br><code>curproc-&gt;ofile</code> of size <code>NOFILE</code>, so we can copy them over with the function<br><code>filedup()</code> (which we’ll see later). The current working directory is in<br><code>curproc-&gt;cwd</code> and can be copied with <code>idup()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NOFILE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> curproc-&gt;ofile[i]) &#123;</span><br><span class="line">            np-&gt;ofile[i] = filedup(curproc-&gt;ofile[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    np-&gt;cwd = idup(curproc-&gt;cwd);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we’ll copy the parent process’s name with <code>safestrcpy()</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/string.c">string.c</a>. You<br>might be familiar with the C standard library funtion <code>strncpy()</code>; this function<br>is almost identical, except that unlike <code>strncpy()</code> it’s guaranteed to nul-<br>terminate the string it copies. If you haven’t seen this kind of thing before,<br>it’s a fairly common practice to write your own safe wrappers for some of the C<br>standard library functions, especially the ones in <code>string.h</code> which are so often<br>error-prone and dangerous.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    safestrcpy(np-&gt;name, curproc-&gt;name, <span class="keyword">sizeof</span>(curproc-&gt;name));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll set the child process’s state to <code>RUNNABLE</code> and return its PID<br>for the parent.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    np-&gt;state = RUNNABLE;</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>This is one of the functions that can get called both by the kernel and as a<br>system call. The kernel will use it to terminate malicious or buggy processes,<br>and user code can use it as a system call to kill another process too.</p>
<p>We said before that killing a process immediately would present all kinds of<br>risks (e.g. corrupting any kernel data structures it might be updating, etc.),<br>so all we’re gonna do is give it the ominous mark of death with the <code>p-&gt;killed</code><br>field. Then the code in <code>trap()</code> will handle the actual murder the next time the<br>process passes through there.</p>
<p>The argument is a process ID number, so let’s just iterate over the process<br>table until we find a process with a matching PID; we’ll return -1 if we don’t<br>find any.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we do find a matching process, then we’ll set <code>p-&gt;killed</code>. Also, some of the<br>calls to <code>sleep()</code> will occur inside a while loop that checks if <code>p-&gt;killed</code> has<br>been set since the process started sleeping, so let’s hasten the process’s death<br>a little by setting its state to <code>RUNNABLE</code> so it’ll wake up and encounter those<br>checks faster. There’s no risk of screwing up by waking up a process too early,<br>since each call to <code>sleep()</code> should be in a loop that will just put it back to<br>sleep if it’s not ready to wake up yet.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;pid == pid) &#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == SLEEPING) &#123;</span><br><span class="line">                p-&gt;state = RUNNABLE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            release(&amp;ptable.lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>The last post went over the basics of <code>sleep()</code> and <code>wakeup()</code>; they act as<br>mechanisms for <em>sequence coordination</em> or <em>conditional synchronization</em>, which<br>allows processes to communicate with each other by sleeping while waiting for<br>conditions to be fulfilled and waking up other processes when those conditions<br>are satisfied.</p>
<p>Processes can go to sleep on a channel or wake up other processes sleeping on a<br>channel. In many operating systems, this is achieved via channel queues or even<br>more complex data structures, but xv6 makes it as simple as possible by simply<br>using pointers (or equivalently, integers) as channels; the kernel can just use<br>any convenient address as a pointer for one process to sleep on while other<br>processes send a wakeup call using the same pointer.</p>
<p>This does mean that multiple processes might be sleeping on the same channel,<br>either because they are waiting for the same condition before resuming execution<br>or because two different <code>sleep()</code>&#x2F;<code>wakeup()</code> pairs accidentally used the same<br>channel. The result would be that a process might be woken up before the<br>condition it’s waiting for has been fulfilled. We can solve that problem by<br>requiring every call to <code>sleep()</code> to occur inside a loop that checks the<br>condition; that way, if a process receives a spurious wakeup call before it<br>really should have been woken up, the loop will put it right back to sleep<br>anyway. We saw one example of this in the <code>sys_sleep()</code> function, in which the<br>while loop checked if the right number of ticks had passed.</p>
<p>A common concurrency danger with conditional synchronization in any operating<br>system is the problem of missed wakeup calls: if the process that’s supposed to<br>send the wakeup call runs <em>before</em> the process that’s supposed to sleep, it’s<br>possible that the sleeping process will never be woken up again. The problem is<br>more general than just processes; it applies to devices too.</p>
<p>Imagine this scenario: a process tries to read from the disk; it’ll check<br>whether the data is ready yet and go to sleep (inside a while loop) until it is.<br>If the disk gets to run first, then the process will just find the data ready<br>and waiting for it, so it can continue on to use the data. If the process runs<br>before the disk does, then it’ll see the data isn’t ready yet and sleep in a<br>loop until it is; the disk will wake the process up once the data is ready.</p>
<p>But suppose they run at the same time, or in between each other. The process<br>does its check and finds the data isn’t ready, but before it can go to sleep, a<br>timer interrupt or some other trap goes off and the kernel switches processes.<br><em>Then</em> the disk finishes reading and starts a disk interrupt that sends a wakeup<br>call to any sleeping processes, but the process isn’t sleeping yet. When the<br>process starts running again later on, it’ll go to sleep – having already<br>missed its wakeup call.</p>
<p>The problem is that the process can get interrupted between checking the<br>condition and going to sleep, right? So why don’t we just disable interrupts<br>there with <code>pushcli()</code> and <code>popcli()</code>? add a lock there? Ah, but there’s another<br>problem: what if the disk driver is running simultaneously on another CPU?<br>Disabling interrupts on the process’s CPU wouldn’t stop the other CPU from<br>sending the disk’s wakeup call too early.</p>
<p>Okay fine, so let’s use a lock instead. The process will hold the lock while it<br>checks the condition and sleeps, and the disk driver will have to acquire the<br>lock before it can send its wakeup call… Can you see the problem here? If the<br>process holds the lock while it’s sleeping, the disk driver will never be able<br>to acquire the lock in order to wake it up. That’s a deadlock.</p>
<p>HEAD. DESK.</p>
<p>Ugh, okay, fine, you got me. So let’s use a lock, but let’s have <code>sleep()</code><br>release it right away, then reacquire it before waking up; that way the lock<br>will be free while the process is sleeping so the disk driver can acquire it.<br>Done, right? Everybody’s happy?</p>
<p>Nope. Now we’re back to the original problem: if the lock gets released inside<br><code>sleep()</code> before the process is actually sleeping, then the wakeup call might<br>happen in between those and get missed.</p>
<p>@*#&amp;@#$**&amp;@#%$!!!</p>
<p>So we need a lock. And we can’t hold the lock while sleeping, or we’d get a<br>deadlock. But we also can’t release it before sleeping, or we might miss a<br>wakeup call. So… ???</p>
<p>See, I told you: concurrency is your worst nightmare. Ever since we decided we’d<br>like our operating systems to do more than run a single basic process at a time,<br>we introduced all <em>kinds</em> of problems we have to reason through. Let’s check out<br>how xv6 actually writes the <code>sleep()</code> function and think through it ourselves<br>and try to understand if it manages to solve this problem.</p>
<p>We’ll start by making sure of two things: (1) this CPU is currently running a<br>process and not the scheduler (which can’t ever go to sleep), and (2) the caller<br>passed in a lock (which can be any arbitrary lock).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lk == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sleep without lk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to release the lock and put the process to sleep. That will require<br>modifying its state, so we should now acquire the lock for the process table.<br>But if the lock that the process is already holding <em>is</em> the process table lock,<br>then trying to acquire it again would cause a panic, so let’s add a check for<br>that; if we’re already holding it then we’ll keep using it and we don’t need to<br>release it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (lk != &amp;ptable.lock) &#123;</span><br><span class="line">        acquire(&amp;ptable.lock);</span><br><span class="line">        release(lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s nap time for this process. We just update its channel to <code>chan</code><br>and its state to <code>SLEEPING</code>, then call <code>sched()</code> to perform a context switch<br>into the scheduler so it can run a new process. We <em>have</em> to be holding the<br>process table lock before calling <code>sched()</code>, remember?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;chan = chan;</span><br><span class="line">    p-&gt;state = SLEEPING;</span><br><span class="line">    sched();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the process wakes up later on (if indeed it turns out that the code here<br>works and doesn’t miss any wakeup calls), it’ll eventually be run by the<br>scheduler, at which point it will context switch back here. So at that point<br>we’ll reset its channel and reacquire the original lock before returning.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lk != &amp;ptable.lock) &#123;</span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">        acquire(lk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, well I don’t know about you, but I’m still not convinced that this<br>implementation won’t miss any wakeup calls. After all, we release the original<br>lock before putting the process to sleep, right? We’re holding the process table<br>lock at that point, which at least means that interrupts are disabled, but the<br>process that will wake this one up might already be running on another CPU and<br>might send the wakeup signal in between releasing the original lock and<br>updating this process’s channel and state. Hmm… Well, as always, xv6 is<br>brilliant, so we’ll see how this gets solved in the code for <code>wakeup()</code>.</p>
<p>But wait! Before we move on, I have a warning for you about using this function<br>in your own code when you start hacking away at xv6. Remember that when we first<br>talked about deadlocks, we saw we can cause a deadlock if two processes acquire<br>two locks in opposite orders? If process 1 tries to acquire lock A, then lock B,<br>and process 2 simultaneously tries to acquire lock B, then lock A, then the end<br>result is that process 1 will acquire lock A and process 2 will acquire lock B,<br>but neither will be able to acquire the other lock since it’s already being held.</p>
<p>If you look at the code above, the process that called <code>sleep()</code> must have<br>already been holding a lock <code>lk</code>, then <code>sleep()</code> acquires <code>ptable.lock</code> before<br>releasing <code>lk</code>. You know what that means: there’s potential for a deadlock. So<br>in order to avoid that, you should make sure that <em>any</em> lock you pass in to<br><code>sleep()</code> must <em>always</em> get acquired before <code>ptable.lock</code>. If any other function<br>(or chain of function calls) could potentially acquire <code>ptable.lock</code> before <code>lk</code>,<br>then you might end up with a deadlock. As always, the xv6 authors have been<br>extremely careful to make sure that that never happens in the existing code, so<br>you’ll have to do the same thing for any code you add.</p>
<h3 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup"></a>wakeup</h3><p>This function is short and sweet because it procrastinates all the work it has<br>to do by pushing it off to a helper function, <code>wakeup1()</code>. It just acquires the<br>process table lock, calls <code>wakeup1()</code>, then releases the process table lock. It<br>has to grab that lock since it’s gonna modify the process’s state in the process<br>table.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    wakeup1(chan);</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xv6 has to use this kind of a wrapper function for the real wakeup function<br><code>wakeup1()</code> in order to let processes that are already holding the process table<br>lock send wakeup calls too.</p>
<p>Okay, now before we go look at <code>wakeup1()</code>, let’s get back to figuring out<br>whether xv6’s implementation of <code>sleep()</code> and <code>wakeup()</code> can lead to missed<br>wakeup calls. Take a look at the code in <code>sleep()</code> again where the original lock<br>gets released – we have to acquire the process table lock <em>before</em> we can<br>release the other lock. So now there are always two locks in play whenever we<br>use <code>sleep()</code> and <code>wakeup()</code>.</p>
<p>Let’s go back to the example of a process waiting on a disk read. The process<br>acquires some disk-related lock first, then checks to see if the disk is done<br>reading; if not, it’ll call <code>sleep()</code> inside a while loop. If the disk driver<br>runs now before the process gets to call <code>sleep()</code>, that’s okay: the disk driver<br>also has to acquire the same lock before calling <code>wakeup()</code>, so the disk would<br>just end up spinning idly. Eventually, the process runs again and gets to<br>call <code>sleep()</code>; there, it will first acquire the process table lock before<br>releasing the original disk-related lock.</p>
<p>So what happens if the disk driver’s code runs now? Now the disk would be able<br>to acquire the original lock, so there’s nothing stopping it from calling<br><code>wakeup()</code>. But the very first thing it has to do there is acquire the process<br>table lock, which the process is already holding, so it just spins idly again!<br>There’s no way the disk driver could ever beat the process to acquiring this<br>second lock, because the process already held the first (disk-related) lock<br>before acquiring the second one (the process table lock). Now the process can<br>finish going to sleep and switch into the scheduler, which will eventually<br>release the process table lock. So then the disk driver can acquire it, release<br>the first lock, and finally send its wakeup call.</p>
<p>Moral of the story? There’s no way for xv6 to ever have any missed wakeup calls!<br>The trick was to use two locks, and acquire the second before releasing the<br>first. But coming up with that solution isn’t as easy as saying “oh, just use<br>two locks!” The solution only works because of the way the process table lock is<br>already being handled by so many other parts of the kernel code. For example, if<br>the context switch into the scheduler wasn’t guaranteed to release the process<br>table lock, then the disk driver in the example would never be able to acquire<br>it after the process goes to sleep, resulting in a deadlock. The solution works<br>because of all the design decisions in xv6 up to this point.</p>
<h3 id="wakeup1"><a href="#wakeup1" class="headerlink" title="wakeup1"></a>wakeup1</h3><p>Okay, I’ll stop fawning over the intricacies of xv6 concurrency management now<br>so we can look at how wakeup calls actually happen. Remember, this is a separate<br>function from <code>wakeup()</code> because sometimes the scheduler needs to send a wakeup<br>call while it’s already holding the process table lock. So we’re gonna assume<br>that every function that ever calls this is already holding it.</p>
<p>The implementation here is actually pretty simple now: we’ll just iterate over<br>the process table and set every single process that’s sleeping on channel<br><code>chan</code> to <code>RUNNABLE</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wakeup1</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">            p-&gt;state = RUNNABLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, there might be multiple processes sleeping on this channel, so this will<br>wake them all up. For some of those processes, this might be a spurious wakeup,<br>so again, we should always make sure to call <code>sleep()</code> in a loop that checks for<br>some condition to be satisfied. Even if multiple processes do have their<br>sleep conditions satisfied, they’ll have to reacquire their original lock before<br>returning out of <code>sleep()</code>, so only one of them will do so and the others will<br>spin until the first one is done.</p>
<p>Why not just wake up the first process we find that’s sleeping on <code>chan</code>? Then<br>we could avoid the extra overhead of a bunch of processes waking up, checking a<br>condition, and going back to sleep, or even spinning idly waiting to reacquire<br>the lock before returning. The issue is that the channels may not be unique, so<br>there’s no way to know which of all the sleeping processes is the one whose<br>sleep condition has just been fulfilled. If we wake up the wrong process, it’ll<br>just go back to sleep, but the right process didn’t wake up, so that means we’ve<br>lost a wakeup call.</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>Okay, so we saw above that <code>kill()</code> doesn’t really kill a process immediately;<br>it shirks that responsibility and lets <code>exit()</code> handle it instead… except<br>even <code>exit()</code> won’t really fully kill a process. Whew, a process’s death just<br>keeps getting dragged out forever, doesn’t it? It’s starting to feel like a<br>cheesy death scene in a tragedy; I bet the process is tired of suffering the<br>slings and arrows of outrageous fortune by now.</p>
<p>But it does make sense. Think about what we have to do in order to wrap up a<br>process and recycle its slot in the process table: we have to close out any open<br>files and reset its current working directory, free its kernel stack and its<br>entire page directory, then notify the parent that it’s done running.</p>
<p>The trouble comes with freeing the kernel stack and process page directory. This<br>function runs in kernel mode, so while the user stack in the lower half of<br>memory will be unused now, the kernel stack is still needed in order to keep<br>executing the instructions for <code>exit()</code>. Also, with the exception of the times<br>when it’s running the scheduling algorithm, the kernel uses the page directory<br>of the current process. The moment we free that page directory, the very next<br>memory access will be to an invalid page; the CPU would trigger an exception<br>then. That exception would eventually get routed to <code>exit()</code> again, except, oh<br>wait, we can’t even run any instructions without generating another exception,<br>because the entire page directory and stack have been freed; that’s a double<br>fault. So then the CPU would try to handle <em>that</em> exception, which would cause<br>the dreaded boogeyman of OS devs around the world: a triple fault. After a fault<br>triggers a second exception, which itself triggers a third exception, the CPU<br>just decides that the kernel in its current state doesn’t have its shit together<br>enough to keep running, so it takes over and reboots the whole system. Oops.</p>
<p>Okay, so let’s not do that. That means we can’t free the kernel stack nor the<br>page directory until we’re running on a different stack&#x2F;page directory combo.<br>That could happen in <code>scheduler()</code> while we’re using the page directory <code>kpgdir</code>,<br>or it could happen while we’re running another process. xv6 does it while it’s<br>running the parent process, in the <code>wait()</code> system call. If you haven’t used<br>that in Linux before, <code>wait()</code> lets a parent process sleep until a child process<br>is done running. xv6 will use <code>wait()</code> to finish cleaning up after an exited<br>child process too.</p>
<p>Now, the very first process that starts running in xv6 (<code>initproc</code>, which loads<br>and runs the shell) obviously has no parent process, but that’s okay because<br>that one should never exit as long as the system is up. So let’s start this<br>function off by making sure that the process that’s exiting isn’t the initial<br>process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (curproc == initproc) &#123;</span><br><span class="line">        panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we’ll close all open files and clear the current working directory; again,<br>we haven’t seen the file system functions used here, but we’ll get to them soon.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all open files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curproc-&gt;ofile[fd]) &#123;</span><br><span class="line">            fileclose(curproc-&gt;ofile[fd]);</span><br><span class="line">            curproc-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the current working directory</span></span><br><span class="line">    begin_op();</span><br><span class="line">    iput(curproc-&gt;cwd);</span><br><span class="line">    end_op();</span><br><span class="line">    curproc-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we only have one thing left to do: notify the parent process that this<br>process has exited. If the parent process is currently sleeping in <code>wait()</code>,<br>then we’ll need to wake it up. But maybe the parent process is currently in the<br>middle of executing other code before it gets to <code>wait()</code>; we don’t want it to<br>miss the wakeup call… oh wait, but that’s okay, remember? The implementations<br>of <code>sleep()</code> and <code>wakeup()</code>&#x2F;<code>wakeup1()</code> guarantee that we can’t miss a wakeup<br>call as long as we’re holding the right lock; <code>wait()</code> will use the process<br>table lock for that. So let’s acquire it now and send a wakeup call.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    wakeup1(curproc-&gt;parent);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, remember that a sleeping process needs to check some condition in a loop;<br>how can the parent process know that the child has exited? Hmm, okay, let’s set<br>the child’s state to <code>ZOMBIE</code>. That’ll also prevent the scheduler from trying to<br>run it again.</p>
<p>Ah, but hang on a sec… what if the parent process has itself been killed, i.e.<br>the current process has been orphaned? (Again with the melodrama…) A process<br>can’t run any more user code after <code>exit()</code>, so an undead parent process would<br>never get to call <code>wait()</code> to clean up after its children. In that case, we’d<br>have to find another process that could adopt a child.</p>
<p>So let’s just solve that problem now: this process is about to shuffle off its<br>mortal coil, so let’s figure out if it has any children and pass them off to<br>another process that can keep raising them as its own. But which process is<br>guaranteed to live long enough to clean up after those children once they die?<br>Ah, <code>initproc</code>, of course! That first process is immortal, so it should be able<br>to look after any children that this process might leave behind after it makes<br>its quietus with a bare bodkin.</p>
<p>So we’ll iterate over the process table, looking for any processes with parent<br>process equal to <code>curproc</code>; if we find any, we’ll have <code>initproc</code> adopt them.<br>If any of our now-abandoned children has already exited before we did, we’ll<br>send a wakeup signal to <code>initproc</code> too in case it’s sleeping in <code>wait()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parent == curproc) &#123;</span><br><span class="line">            p-&gt;parent = initproc;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == ZOMBIE) &#123;</span><br><span class="line">                wakeup1(initproc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s finally time for this process to find out what dreams may come in<br>that sleep of death. We’ll set its state to <code>ZOMBIE</code> and context-switch into the<br>scheduler, never to return; if something goes wrong and the scheduler <em>does</em><br>return, we’ll panic in order to keep this function from returning into user code<br>again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    curproc-&gt;state = ZOMBIE;</span><br><span class="line">    sched();</span><br><span class="line"></span><br><span class="line">    panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>Like we said above, this system call lets a parent process wait for a child<br>process to exit; it also cleans up after the child process has exited.</p>
<p>First, we don’t even know if this process has any children, so we’ll have to<br>check by iterating through the process table and checking each process’s parent<br>to see if it matches the current process. If it does, then we’ll check if it’s a<br>zombie, in which case we can clean it up and return its process ID.</p>
<p>We should also deal with two edge cases: first, if the process has no children<br>at all, and second, if the process does have children but none of them are dead<br>yet. In the first case, we’ll just return -1 to report failure; in the second<br>case we’ll put the current process to sleep until one of its children exits. The<br><code>sleep()</code> call means we’ll have to do these checks inside an infinite loop.</p>
<p>Alright, let’s get started by getting the current process and acquiring the<br>process table lock, then starting an infinite loop.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inside the loop, we’ll use a variable <code>havekids</code> as a boolean to track whether<br>we’ve found any child processes. Then we can iterate over the process table,<br>skipping any processes for which the current process is not the parent. If we<br>find any children, we’ll set <code>havekids</code> to 1.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> havekids = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent != curproc) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            havekids = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we did find a child process, we should check if it’s a zombie, in which case<br>it’s time to finish its clean-up. That means freeing its kernel stack and its<br>page directory and recycling its <code>struct proc</code> so that it can be reallocated to<br>another process later on.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == ZOMBIE) &#123;</span><br><span class="line">                <span class="type">int</span> pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Free child&#x27;s kernel stack</span></span><br><span class="line">                kfree(p-&gt;kstack);</span><br><span class="line">                p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Free child&#x27;s page directory</span></span><br><span class="line">                freevm(p-&gt;pgdir);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Recycle child&#x27;s struct proc</span></span><br><span class="line">                p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">                p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">                p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">                p-&gt;state = UNUSED;</span><br><span class="line"></span><br><span class="line">                release(&amp;ptable.lock);</span><br><span class="line">                <span class="keyword">return</span> pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if <code>havekids</code> is still zero by the time we finish the for loop, that means<br>the process doesn’t have any children, so we should report failure. We’ll also<br>check if the process has been marked as killed in the meantime.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!havekids || curproc-&gt;killed) &#123;</span><br><span class="line">            release(&amp;ptable.lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, if it <em>does</em> have children, but none of them have exited yet, we’ll put<br>the process to sleep. It’ll get woken up when a child exits, at which point<br>it’ll restart the outer for loop at the top and start looking through the<br>process table again.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        sleep(curproc, &amp;ptable.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-10"><a href="#Summary-10" class="headerlink" title="Summary"></a>Summary</h2><p>By now, we’ve looked at a good chunk of the system calls available in xv6. These<br>system calls wrap up the mechanisms that xv6 uses to create and exit processes<br>with <code>fork()</code>, <code>kill()</code>, <code>exit()</code>, and <code>wait()</code>, and introduced <code>sleep()</code> and<br><code>wakeup()</code> as a means for (limited) inter-process communication.</p>
<p>So what’s left now? The rest of the kernel code we’re gonna look at will just<br>focus on communicating with various hardware devices like the serial port,<br>console, and keyboard. Those drivers are relatively short, but there’s one<br>device that will require a lot more work: the disk. Storing files on disk and<br>making sure they persist across reboots require careful planning, and making<br>files conveniently accessible to users requires an entire system of abstractions<br>layered on top of each other, along with a whole host of file-related system<br>calls.</p>
<h1 id="Sleep-Locks"><a href="#Sleep-Locks" class="headerlink" title="Sleep Locks"></a>Sleep Locks</h1><p>We’ve used plenty of spin-locks, and a previous post looked at their<br>implementation in xv6. Spin-locks have pretty harsh performance costs: a process<br>that’s waiting to acquire a lock will just spin idly in a while loop, wasting<br>valuable CPU time that could be used to run other processes. So far, we’ve only<br>seen locks for kernel resources like the process table, page allocator, and<br>console, for which all operations should be relatively fast, on the order of a<br>few dozen CPU cycles at most.</p>
<p>Now it’s time to look at the disk driver and file system implementation, and<br>we’ll need some locks there too. But disk operations are <em>slow</em> – reading from<br>and writing to disk might take milliseconds, which is a literal eternity for a<br>CPU. Imagine a process hogging a spin-lock for the disk while other processes<br>spin around and around waiting <em>forever</em> for the disk to finish writing. It<br>would be an enormous waste!</p>
<p>Spin-locks were the best we could do at the time, since we didn’t have any<br>infrastructure to support more complex locks, but now we really do need a better<br>alternative. We also have some more kernel building blocks in place relating to<br>processes, including a bunch of system calls.</p>
<p>For example, we’ve seen the <code>sleep()</code> and <code>wakeup()</code> system calls, which let a<br>process give up the CPU until some condition is met. Well, hang on a second –<br>what if that condition is that a lock is free to acquire? Then a process could<br>sleep while another process holds the lock, and wake up when it’s ready to be<br>acquired; that would let other processes run instead of forcing a process to<br>spin and spin. xv6 calls these <em>sleep-locks</em>, and it’s time to find out how they<br>work.</p>
<h2 id="sleeplock-h"><a href="#sleeplock-h" class="headerlink" title="sleeplock.h"></a>sleeplock.h</h2><p>If we want a process holding a sleep-lock to give up the processor in the middle<br>of a critical section, then sleep-locks have to work well when held across<br>context switches. They also have to leave interrupts enabled. This couldn’t<br>happen with spin-locks: it was important that they disable interrupts to prevent<br>deadlocks and ensure a kernel thread can’t get rescheduled in the middle of<br>updating some important data structure.</p>
<p>Leaving interrupts on adds some extra challenges. First, we have to make sure<br>the lock can still be acquired atomically; second, we have to make sure that any<br>operations in the critical section can safely resume after being interrupted.</p>
<p>Let’s solve the first problem: how can we make sure a sleep-lock will always be<br>acquired atomically? Well, if we want to do something atomically, we already<br>have a solution: spin-locks! So rather than reinventing the wheel, we’ll just<br>make each sleep-lock a two-tiered deal with a spin-lock to protect its<br>acquisition.</p>
<p>We’ll use a <code>locked</code> field just like the one all spin-locks have, but then we’ll<br>add a spin-lock to protect it. We’ll also make debugging a little easier by<br>adding a name for the lock and a field for a PID to identify which process is<br>holding it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">    uint locked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="sleeplock-c"><a href="#sleeplock-c" class="headerlink" title="sleeplock.c"></a>sleeplock.c</h2><h3 id="initsleeplock"><a href="#initsleeplock" class="headerlink" title="initsleeplock"></a>initsleeplock</h3><p>We can initialize a sleep-lock by initializing its guard spin-lock, then adding<br>a name for it, setting <code>locked</code> to false, and the <code>pid</code> field to zero.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initsleeplock</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;lk-&gt;lk, <span class="string">&quot;sleep lock&quot;</span>);</span><br><span class="line">    lk-&gt;name = name;</span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acquiresleep"><a href="#acquiresleep" class="headerlink" title="acquiresleep"></a>acquiresleep</h3><p>In order to make sure sleep-lock acquisition is atomic, we’ll bookend this<br>function by acquiring and releasing a spin-lock. This will also make sure that<br>interrupts are disabled during this function but re-enabled when it’s done. It<br>does add some overheard in the form of spinning until this lock is free, but the<br>code here should be relatively short and fast to execute. What we really want is<br>to avoid spinning once the sleep-lock is acquired, i.e. spinning <em>after</em> this<br>function is done. So we’ll tolerate a little waste here.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now we have to do the actual acquisition. We said above that we’d use the<br><code>sleep()</code> function to avoid wasting processor time. Hopefully you remember one<br>important detail about <code>sleep()</code>: it must always be called inside a while loop<br>in order to make sure that we don’t miss any wakeup calls. So let’s check if the<br>sleep-lock is already being held and go to sleep if it is. We’ll need a channel<br>and a lock for <code>sleep()</code> to release, so let’s use the pointer to this lock <code>lk</code><br>as the channel, and the outer spin-lock <code>lk-&gt;lk</code> as the lock to be released.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">        sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s important to keep the two locks separate in your head right now: <code>lk</code> is<br>the sleep-lock, and <code>lk-&gt;lk</code> is the spin-lock it uses to protect the sleep-lock’s<br>acquisition. Note that we’re checking <code>lk-&gt;locked</code> here, <em>not</em> the spin-lock<br><code>lk-&gt;lk</code> – this process is already holding <code>lk-&gt;lk</code>, but we need to acquire<br><code>lk</code> itself by updating <code>lk-&gt;locked</code>. Phew, try saying that ten times fast.</p>
<p>Now the process will go to sleep and yield the CPU until the sleep-lock is free.<br>If multiple processes are sleeping waiting on the same sleep-lock, they will all<br>wake up at the same time, but all of them have to reacquire <code>lk-&gt;lk</code> before<br>returning from sleep, so only one will get to return here and complete the<br>sleep-lock acquisition. The others will spin a bit longer, then return here only<br>to find that <code>lk-&gt;locked</code> is already being held by another process, so the while<br>loop will put them to sleep again.</p>
<p>Once the sleep-lock is free, the process can exit the while loop and claim the<br>sleep-lock for itself.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">    lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We don’t need fancy atomic operations like <code>xchg</code> anymore, since the guarding<br>spin-lock has already made sure that interrupts are disabled and all operations<br>are effectively atomic. So that’s all we need! Now we just release the spin-lock<br>and return.</p>
<h3 id="releasesleep"><a href="#releasesleep" class="headerlink" title="releasesleep"></a>releasesleep</h3><p>Now that we’ve seen how a process acquires a sleep-lock, releasing it is easy,<br>we just do the opposite. We’ll set <code>lk-&gt;locked</code> to zero and clear the <code>lk-&gt;pid</code><br>field. And what’s the opposite of <code>sleep()</code>? Well, <code>wakeup()</code>, of course! That<br>will check whether there are any processes sleeping on this channel and let them<br>know they can attempt to acquire the sleep-lock now.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line"></span><br><span class="line">    lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    wakeup(lk);</span><br><span class="line"></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="holdingsleep"><a href="#holdingsleep" class="headerlink" title="holdingsleep"></a>holdingsleep</h3><p>This function is even more simple: it just checks whether a sleep-lock is being<br>held, and if so, whether it’s being held by the current process. The first is<br>done by just checking <code>lk-&gt;locked</code>; the second is done by checking that <code>lk-&gt;pid</code><br>matches the current process’s PID. The result is a boolean stored in a temporary<br>variable so we can release the guarding spin-lock before returning the result.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holdingsleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);</span><br><span class="line"></span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-11"><a href="#Summary-11" class="headerlink" title="Summary"></a>Summary</h2><p>Okay, that wasn’t too bad! It makes sense why we couldn’t use sleep-locks in a<br>kernel without system calls like <code>sleep()</code> and <code>wakeup()</code>. But xv6 already has<br>those, so why not use them everywhere? If sleep-locks really do cut down on the<br>wasted CPU time, can we just go back and replace all the spin-locks with<br>sleep-locks? Then the only use for spin-locks would be as a guard for the more-<br>sophisticated sleep-locks.</p>
<p>Hold your horses! It’s not that easy. Sleep-locks leave interrupts enabled, so<br>they can’t be used in interrupt handler functions, or inside a critical section<br>where a spin-lock is being used, since interrupts will be disabled (though spin-<br>locks can be used inside sleep-lock critical sections). They also can’t be used<br>by kernel threads like the scheduler, since those aren’t processes and thus<br>can’t be put to sleep.</p>
<p>Finally, there are some situations in which a sleep-lock might actually add<br><em>more</em> overhead than a spin-lock: it takes some time to put a process to sleep,<br>schedule another process, send a wakeup call, schedule the first process again,<br>and so on, and the process will hold the sleep-lock the entire time. If another<br>process is waiting on the sleep-lock, it might actually end up waiting longer<br>than with a spin-lock, although it’ll wait in a sleeping state instead of a<br>running state where it just spins in a loop.</p>
<p>Additionally, sleep-locks can only be used when it’s safe to interrupt a process<br>in the middle of a critical section and wake it up later. Sure, no other process<br>can acquire the sleep-lock in the meantime, but it’s still not great for time-<br>sensitive operations like getting the current number of <code>ticks</code>.</p>
<p>So sleep-locks are great, but their applications are more limited than spin-<br>locks. The perfect use for them is when a process needs to complete an operation<br>atomically, but that operation itself might take a very long time. A great<br>example of that is disk I&#x2F;O, and we’ll see next how xv6 puts them to use in its<br>file system implementation.</p>
<h1 id="Devices-Disk-Driver"><a href="#Devices-Disk-Driver" class="headerlink" title="Devices: Disk Driver"></a>Devices: Disk Driver</h1><p>At this point, we’ve seen how xv6 virtualizes memory and the processor to give<br>each user process the illusion of a contiguous, near-infinite memory space and a<br>dedicated CPU to run it; we’ve also seen how xv6 mediates interactions between<br>most of a computer’s hardware components and user processes via system calls.<br>But there’s one more piece of hardware that’s critically important for an OS<br>that we haven’t looked at yet: the disk. All that’s left in the kernel code for<br>us to look at is how xv6 manages data storage on the disk and how it presents<br>that data to users in a simplified way.</p>
<p>The function of a disk is to provide <em>persistence</em> for an operating system. RAM<br>is volatile memory: it gets erased when the machine is turned off, so any data<br>stored there is fleeting. A disk allows an OS to store and retrieve data across<br>shut-offs. The disk driver we’ll go over in this post allows the xv6 kernel<br>direct access to that device so it can read and write data to it.</p>
<p>But unlike other devices, a simple driver isn’t enough here. We don’t just need<br>to be able to read and write data; we’d like to present users with a simplified,<br>accessible framework to navigate that data. Imagine using a computer where you<br>had to specify which byte of the disk to read or write, then remember that<br>yourself in order to access it again later. It’s madness! Enter file systems;<br>“files” don’t really exist in any real sense on a disk, but the OS can provide<br>the illusion of discrete, individual files in order to simplify access to data.</p>
<p>We also need to make sure concurrent accesses of the same file don’t risk<br>corrupting the file (or even the entire file system). We need to separate out<br>kernel data (like the kernel code itself) from user data on the disk, so that a<br>malicious user process can’t just overwrite arbitrary kernel code. Finally,<br>there’s that oh-so-famous line about Unix systems, “everything is a file”. We’ll<br>need a way to present “everything” in the elegant abstraction of a file.</p>
<p>All of these abstractions and security checks will require far more code than a<br>simple driver to implement them, so before we go on to the driver, let’s check<br>out how xv6 will organize its file system to get a preview of what’s ahead.</p>
<h2 id="File-System-Organization"><a href="#File-System-Organization" class="headerlink" title="File System Organization"></a>File System Organization</h2><p>Laying the abstraction of a complete file system on top of a physical disk will<br>require several steps. xv6 does this using seven layers. From bottom (direct<br>hardware interaction) to top (user-facing code), they are:</p>
<ul>
<li>Disk driver: reads and writes blocks on an IDE hard drive.</li>
<li>Buffer cache: caches disk blocks in memory and synchronizes access to them.</li>
<li>Logging: provides atomic disk writes to mitigate the risk of a crash.</li>
<li>Inodes: turns disk blocks into individual files that the OS can manipulate.</li>
<li>Directories: creates a tree of named directories that contain other files.</li>
<li>Path names: provides hierarchical, human-readable path names in the directory tree structure.</li>
<li>File descriptors: abstracts OS resources like pipes and devices as files to provide a unified API for user programs.</li>
</ul>
<p>That’s a lot of work to do now, but it’ll pay off! The kernel will do all this<br>labor so that users are free to be lazy later on and can live in blissful<br>ignorance of the fact that their precious little files actually exist as nothing<br>but ones and zeroes in totally arbitrary locations on the disk.</p>
<p>Note that hard drives are usually divided into <em>sectors</em>, which are physical<br>divisions (originally referring to literal geometric sectors), traditionally of<br>512 bytes. Operating systems can then collect these into larger <em>blocks</em> which<br>are multiples of the sector size. xv6 uses 512-byte blocks for simplicity so<br>that the sector and block sizes match up; I’ll use the two terms interchangeably.</p>
<p>On the disk, block 0 usually contains the boot sector, so it’s not used by xv6<br>(but remember the Makefile – xv6 actually stores the boot loader and kernel<br>code on an entirely separate physical disk). Block 1 is called the <em>superblock</em><br>because it contains metadata about the file system like its total size, the size<br>of the log, the number of files, and their location on the disk. Then the log<br>starts at block 2 and on.</p>
<h2 id="buf-h"><a href="#buf-h" class="headerlink" title="buf.h"></a>buf.h</h2><p>If you’ve read any of the previous optional posts on device drivers, you know<br>that interacting directly with the hardware means all kinds of opaque code with<br>seemingly-arbitrary port I&#x2F;O and cryptic magic numbers. Drivers are also specific<br>to the actual (or virtual) hardware in the machine that xv6 will run on, so it<br>tends to be less useful for showing general OS concepts – hence why all the<br>other device driver posts were optional. That being said, the disk driver nicely<br>rounds out the rest of the file system code, so I recommend checking it out, but<br>if you’re short on time or bored with all the talk about hardware specs, feel<br>free to skip to the summary section below.</p>
<p>Reading and writing disk data is super slow, so the second layer in the file<br>system is the buffer cache, which will store copies of disk blocks in memory for<br>faster access. But we still have to read from the disk to create that buffer,<br>and we still have to write any modified data to the disk once we’re done, so<br>we still need a layer below the buffer cache to do that. That layer is the disk<br>driver; its purpose is to copy data from the disk to the in-memory cache and<br>vice versa. A single block is represented in the cache as a <code>struct buf</code>, defined<br>in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/buf.h">buf.h</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    uint dev;               <span class="comment">// device number</span></span><br><span class="line">    uint blockno;           <span class="comment">// block number (same as sector number)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span>  <span class="comment">// sleep-lock to protect buffer reads and writes</span></span><br><span class="line">    uint refcnt;            <span class="comment">// how many processes are using this buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span>       <span class="comment">// for use with buffer cache doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span>       <span class="comment">// for use with buffer cache doubly-linked list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span>      <span class="comment">// for use with disk driver queue</span></span><br><span class="line">    uchar data[BSIZE];      <span class="comment">// data stored in the buffer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_VALID 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_DIRTY 0x4</span></span><br></pre></td></tr></table></figure>

<p>The two constants defined at the bottom are used in the <code>flags</code> field; <code>B_VALID</code><br>indicates that a buffer has been read from disk and should accurately reflect<br>the sector’s contents on the disk, and <code>B_DIRTY</code> says we’ve modified the buffer<br>but haven’t yet updated the on-disk version of a file, so we need to write the<br>buffer to disk soon.</p>
<p>We’ll see later on that the buffer cache uses a doubly-linked list of buffers;<br>the <code>prev</code> and <code>next</code> fields are used there. However, the disk driver also<br>maintains its own queue of buffers that are waiting to be read from or written<br>to the disk; that’s implemented as a singly-linked list using the <code>qnext</code> field.</p>
<h2 id="ide-c"><a href="#ide-c" class="headerlink" title="ide.c"></a>ide.c</h2><p>We’ve already seen some code to read and write disk data in the <a href="boot.md">boot loader</a>;<br>I know it’s been a while, so you can check that out again if you want. We can’t<br>reuse the code there for a few reasons, though: (1) the boot loader has to be<br>compiled separately from the kernel, so we can’t access any of the functions<br>there, and (2) we need to store data in the buffer cache, so we can’t even copy-<br>paste the code we used before since the boot loader barely even knows what<br>memory is, let alone a buffer cache.</p>
<h3 id="ATA-Programmed-I-O-Mode"><a href="#ATA-Programmed-I-O-Mode" class="headerlink" title="ATA Programmed I&#x2F;O Mode"></a>ATA Programmed I&#x2F;O Mode</h3><p>Modern disk drivers usually talk to the disk via direct memory access (DMA), but<br>to keep things simple xv6 is just gonna talk to it with port I&#x2F;O. That’s much,<br>much slower, and it requires active participation by the CPU (which means it<br>can’t do anything else at the same time), but hey, xv6 thinks it’s 1995,<br>remember? So PIO mode is still (relatively) cutting edge. Either way, extreme<br>performance isn’t the goal here, so we’ll just have to suck it up.</p>
<p>Okay, let’s do a super-quick summary. <code>inb</code> is a C wrapper for an x86 assembly<br>instruction that reads a single byte of data from a port; <code>outb</code> writes a byte<br>to a port. The disk controller chip has primary and secondary buses; the primary<br>bus sends data on port 0x1F0 and has control registers on ports 0x1F1 through<br>0x1F7. Port 0x1F7 doubles as a command register and a status port with some<br>useful flags we can check in order to know what the disk is up to; we saw some<br>of those before, but I’ll give you the full list now.</p>
<ul>
<li>Bit 0 (0x01) - ERR (indicates an error occurred)</li>
<li>Bit 1 (0x02) - IDX (index; always set to zero)</li>
<li>Bit 2 (0x04) - CORR (corrected data; always set to zero)</li>
<li>Bit 3 (0x08) - DRQ (drive has data to transfer or is ready to receive data)</li>
<li>Bit 4 (0x10) - SRV (service request)</li>
<li>Bit 5 (0x20) - DF (drive fault error)</li>
<li>Bit 6 (0x40) - RDY (ready; clear when drive isn’t running or after an error and set otherwise)</li>
<li>Bit 7 (0x80) - BSY (busy; drive is in the middle of sending&#x2F;receiving data)</li>
</ul>
<p>The disk driver defines some of these with preprocessor macros at the top of the<br>file.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECTOR_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_BSY     0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_DRDY    0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_DF      0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_ERR     0x01</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>We also saw one command example in the boot loader: sending 0x20 to port 0x1F7<br>tells the disk to read a sector and send it to us through data port 0x1F0. Now<br>we’ll also use commands to write a sector, as well as to read or write multiple<br>sectors at once.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_READ    0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_WRITE   0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_RDMUL   0xc4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_CMD_WRMUL   0xc5</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>If, for some reason beyond mortal comprehension, you decide you want to know<br>more about the eldritch secrets of ancient hard drives, you can read <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/ATA-d1410r3a.pdf">this<br>resource on ATA disks</a>.</p>
<p>After those constants, we find three static global variables: a spin-lock for<br>accessing the disk, the queue of buffers waiting to be synchronized with their<br>on-disk counterparts, and a boolean to track whether xv6 is running with only<br>disk 0 (boot loader and kernel) or with disk 1 (user file system) as well.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">idelock</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">idequeue</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> havedisk1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="idewait"><a href="#idewait" class="headerlink" title="idewait"></a>idewait</h3><p>This function takes an integer <code>checkerr</code> argument that should be a boolean and<br>waits for the disk to be ready to receive more commands. If <code>checkerr</code> is true,<br>it’ll also check whether the status port includes any error flags.</p>
<p>It starts by reading from the disk’s status port and looping until the busy<br>flag is not set but the ready flag is. The bitwise-OR <code>IDE_BSY | IDE_DRDY</code><br>combines both flags, and the bitwise-AND tests whether either one is set in <code>r</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">idewait</span><span class="params">(<span class="type">int</span> checkerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (((r = inb(<span class="number">0x1f7</span>)) &amp; (IDE_BSY | IDE_DRDY)) != IDE_DRDY)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now if <code>checkerr</code> is nonzero we have to check that neither the error nor the<br>drive failure flag is set in the status port. If either one is set, we’ll return<br>-1; we’ll return 0 otherwise.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">idewait</span><span class="params">(<span class="type">int</span> checkerr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (checkerr &amp;&amp; (r &amp; (IDE_DF | IDE_ERR)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ideinit"><a href="#ideinit" class="headerlink" title="ideinit"></a>ideinit</h3><p>This function is called by the kernel’s <code>main()</code> during set-up to initialize the<br>disk. We start by initializing the disk lock, then tell the I&#x2F;O interrupt<br>controller to forward all disk interrupts to the last CPU. We talked about the<br><code>ioapicenable()</code> function in detail in the post on interrupt controllers.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    initlock(&amp;idelock, <span class="string">&quot;ide&quot;</span>);</span><br><span class="line">    ioapicenable(IRQ_IDE, ncpu - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we wait for the disk to be ready to accept commands (ignoring any error<br>flags that may be present).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    idewait(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We said above that disk 0 should contain the boot loader and kernel, so we can<br>assume any machine running xv6 should have that present. However, we need to<br>make sure disk 1 is present; the<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/Makefile">Makefile</a> includes<br>some configurations like <code>make qemu-memfs</code> under which xv6 can run without a<br>dedicated disk for the file system, storing files in memory instead.</p>
<p>Port 0x1F6 is used to select a drive. Bits 5 and 7 should always be set, and bit<br>6 picks the right mode we need to indicate a disk. Bit 4 determines whether we<br>want to select disk 0 or disk 1. So we can select drive 1 by setting bits 5-7<br>(0xE0 when combined), then bit 4 (<code>1 &lt;&lt; 4</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to wait for disk 1 to be ready; we need to handle this as a special<br>case since <code>waitdisk()</code> can’t check a specific disk for us, and because an<br>absent disk 1 would make the while loop there continue forever. So we’ll check<br>the status register 1000 times; if it ever reports that it’s ready, we’ll set<br><code>havedisk1</code> to true and break, but otherwise we’ll assume disk 1 isn’t present<br>and leave <code>havedisk1</code> as zero (i.e., false).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inb(<span class="number">0x1f7</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            havedisk1 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll switch back to using disk 0 by changing the fourth bit of the<br>register at port 0x1F6.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">0</span> &lt;&lt; <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="idestart"><a href="#idestart" class="headerlink" title="idestart"></a>idestart</h3><p>This is the core function that will read or write a buffer to or from the disk.<br>It’s a <code>static</code> function, so it can only be called by other functions in this<br>file; <code>ideintr()</code> and <code>iderw()</code> will both use it as a helper function. It takes<br>a pointer to a buffer, so the first thing to do is make sure that pointer isn’t<br>null. We’ll also make sure the buffer’s block number is within the maximum limit<br>set by <code>FSSIZE</code>, defined in<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/param.h">param.h</a> as 1000.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;blockno &gt;= FSSIZE) &#123;</span><br><span class="line">        panic(<span class="string">&quot;incorrect blockno&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next we need to figure out which disk sector to read from or write to. Since xv6<br>uses blocks that are the same size as a sector, this should just be <code>b-&gt;blockno</code>,<br>but we’ll add a conversion here in case that gets changed later on (especially<br>if we want higher disk throughput).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> sector_per_block = BSIZE / SECTOR_SIZE;</span><br><span class="line">    <span class="type">int</span> sector = b-&gt;blockno * sector_per_block;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If each block fits exactly one sector, then we’ll need to use the single-sector<br>read and write commands; otherwise we should use the multi-sector versions of<br>those commands. We’ll set <code>read_cmd</code> and <code>write_cmd</code> to the right versions.<br>We’ll also make sure that there are no more than 7 sectors per block.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> read_cmd = (sector_per_block == <span class="number">1</span>) ? IDE_CMD_READ : IDE_CMD_RDMUL;</span><br><span class="line">    <span class="type">int</span> write_cmd = (sector_per_block == <span class="number">1</span>) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;</span><br><span class="line">    <span class="keyword">if</span> (sector_per_block &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idestart&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s wait for the disk to be ready, ignoring any error flags.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    idewait(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, now it’s time to brace yourself, because this next part is a hot mess of<br>port I&#x2F;O operations with lots of magic numbers. First we’ll tell the disk<br>controller to generate an interrupt once it’s done reading or writing by setting<br>the device control register at 0x3F6 to zero. Then we’ll tell it how many total<br>sectors we want to read or write by writing that number (AKA <code>sector_per_block</code>)<br>to port 0x1F2.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x3f6</span>, <span class="number">0</span>);                 <span class="comment">// generate interrupt when done</span></span><br><span class="line">    outb(<span class="number">0x1f2</span>, sector_per_block);  <span class="comment">// number of sectors to read/write</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Before sending the read or write command, we have to tell the disk which sector<br>to read from, using our <code>sector</code> variable from above. Let’s take a second to<br>talk about hard drive geometry. A hard drive consists of a bunch of stacked<br>circular surfaces, where each surface has a corresponding <em>head</em> that changes<br>its position to read or write from the right place on the disk. Each surface has<br>a number of <em>tracks</em>: concentric circles that contain data. If you pick a track<br>number (i.e. pick a distance from the center of the surfaces) and collect all<br>those tracks from all the surfaces, you get a <em>cylinder</em>.</p>
<p>A sector number acts as a kind of address with each part specifying a different<br>geometric component, similar to how linear addresses contain a page directory<br>index, page table index, and offset. The eight most significant bits (24 through<br>31) identify the drive and&#x2F;or head that the sector is located on (plus some<br>flags); bits 8 through 23 identify the cylinder, and bits 0 through 7 pick a<br>sector within that cylinder. Altogether, these define a 3D coordinate system<br>that uniquely identifies all sectors on a machine’s disks.</p>
<p>Port 0x1F3 is the sector number register, ports 0x1F4 and 0x1F5 are the cylinder<br>low and high registers, and port 0x1F6 is the drive&#x2F;head register. We can write<br>the sector number as <code>sector &amp; 0xFF</code>; the cylinder low and high numbers can be<br>recovered by bitshifting <code>sector</code> down by 8 and 16, respectively.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f3</span>, sector &amp; <span class="number">0xff</span>);             <span class="comment">// sector number</span></span><br><span class="line">    outb(<span class="number">0x1f4</span>, (sector &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);      <span class="comment">// cylinder low</span></span><br><span class="line">    outb(<span class="number">0x1f5</span>, (sector &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);     <span class="comment">// cylinder high</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now for the drive&#x2F;head register, we’ll use <code>b-&gt;dev</code> to get the block’s device<br>and <code>(sector &gt;&gt; 24)</code> to get the head it’s on. Finally, we’ll set bits 5-7 as<br>required (and as mentioned above in <code>ideinit()</code>) with 0xE0. Then we can<br>bitwise-OR all of these together and write them to port 0x1F6.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | ((b-&gt;dev &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>) | ((sector &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0f</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Okay, that was the worst of it! Deep breath now. The last part is just sending<br>the actual read or write command. But how do we know which one we’re supposed to<br>do? The only argument is a pointer to a buffer <code>b</code>, not any sort of boolean that<br>might tell us which to carry out. Well, remember the buffer flag <code>B_DIRTY</code>? That<br>one indicates that a buffer has been modified and needs to be written to disk.<br>If that flag is set, reading from the disk would overwrite any changes, which<br>probably isn’t what we want. So let’s just assume that the <code>B_DIRTY</code> flag means<br>we should write to disk, and the absence of that flag means we should read from<br>disk.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idestart</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;flags &amp; B_DIRTY) &#123;</span><br><span class="line">        outb(<span class="number">0x1f7</span>, write_cmd);</span><br><span class="line">        outsl(<span class="number">0x1f0</span>, b-&gt;data, BSIZE / <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outb(<span class="number">0x1f7</span>, read_cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here <code>outsl()</code> is another C wrapper for an x86 instruction; this one writes data<br>from a string, four bytes at a time.</p>
<p>That’s it! This is by far the most cryptic function in the disk driver; the last<br>two are relatively easy now.</p>
<h3 id="ideintr"><a href="#ideintr" class="headerlink" title="ideintr"></a>ideintr</h3><p>We saw in <code>idestart()</code> that we set up the disk to send an interrupt whenever<br>it’s done reading or writing data. Back when we looked at<br><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/trap.c">trap.c</a>, we saw that<br>the <code>trap()</code> function directs all disk interrupts to the handler function<br><code>ideintr()</code>. It’s time to check that one out now.</p>
<p>We’ll start by acquiring the disk’s spin-lock; note that we don’t use a sleep-<br>lock because this is an interrupt handler function, so interrupts should be<br>disabled while it runs.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;idelock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we got an interrupt, then it usually means the disk is done with the most<br>recent request. Those requests are stored in the global <code>idequeue</code> linked list,<br>with the current request at the front of the queue. So we’ll get the head of the<br>queue as <code>b</code>, then set <code>idequeue</code> to point to the next buffer in the queue. If<br>the head is null, then we’ll just return early.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((b = idequeue) == <span class="number">0</span>) &#123;</span><br><span class="line">        release(&amp;idelock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idequeue = b-&gt;next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The read command in <code>idestart()</code> didn’t specify where to read the data to, so we<br>do that now. We’ll check if the <code>B_DIRTY</code> flag was set; if it wasn’t (i.e. the<br>operation was a disk read), then we’ll wait for the disk to be ready (without<br>any errors, using <code>idewait(1)</code> instead of <code>idewait(0)</code> as we have before) and<br>read the data into <code>b-&gt;data</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(b-&gt;flags &amp; B_DIRTY) &amp;&amp; idewait(<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        insl(<span class="number">0x1f0</span>, b-&gt;data, BSIZE / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we set the <code>B_VALID</code> flag with a bitwise-OR and clear any <code>B_DIRTY</code> flag<br>with a bitwise-AND and a bitwise-NOT. Then we’ll wake up any user process that<br>went to sleep on a channel for this buffer after requesting a disk I&#x2F;O operation.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b-&gt;flags |= B_VALID;</span><br><span class="line">    b-&gt;flags &amp;= ~B_DIRTY;</span><br><span class="line">    wakeup(b);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, we’ll get the disk started on the next operation, for the next buffer<br>in the queue.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ideintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (idequeue != <span class="number">0</span>) &#123;</span><br><span class="line">        idestart(idequeue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iderw"><a href="#iderw" class="headerlink" title="iderw"></a>iderw</h3><p>The <code>idestart()</code> function is <code>static</code>, so it can’t be called by anything outside<br>of this file; we need to provide a mechanism for both kernel and user threads to<br>read and write disk data. That’s what <code>iderw()</code> does. Note that processes should<br>never call this function directly; it only gets called by the code for the<br>buffer cache layer of the file system. In other words, processes will use system<br>calls like <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>, etc., which in turn will<br>use functions from higher layers of abstraction, which in turn call functions<br>from lower layers, and so on, until they reach the buffer cache, which calls<br><code>iderw()</code> to finally read&#x2F;write directly from&#x2F;to the disk.</p>
<p>By the time a process gets to <code>iderw()</code>, it should already be holding a sleep-<br>lock <code>b-&gt;lock</code> for the buffer <code>b</code> it wants to read or write, and either the<br><code>B_DIRTY</code> flag should be set (to write to disk) or the <code>B_VALID</code> flag should be<br>absent (to read from disk). We’ll start off with some sanity checks for those,<br>and make sure that we’re not trying to read from disk 1 if it’s not present on<br>this machine. Then we’ll acquire the disk’s spin-lock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock)) &#123;</span><br><span class="line">        panic(<span class="string">&quot;iderw: buf not locked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((b-&gt;flags &amp; (B_VALID | B_DIRTY)) == B_VALID) &#123;</span><br><span class="line">        <span class="comment">// B_VALID is set, so we don&#x27;t need to read it; B_DIRTY is not set, so</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to write it</span></span><br><span class="line">        panic(<span class="string">&quot;iderw: nothing to do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev != <span class="number">0</span> &amp;&amp; !havedisk1) &#123;</span><br><span class="line">        panic(<span class="string">&quot;iderw: ide disk 1 not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;idelock);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There may be other buffers waiting in line in the disk queue, so we have to<br>append this buffer <code>b</code> to the end of <code>idequeue</code>. We can do that by setting<br><code>b-&gt;qnext</code> to null, then creating a variable <code>pp</code> to traverse the entire queue.<br>When <code>pp</code> points to the last element, we’ll set its <code>qnext</code> field to point to<br><code>b</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b-&gt;qnext = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse the queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> **<span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (pp = &amp;idequeue; *pp; pp = &amp;(*pp)-&gt;qnext)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append b to end of queue</span></span><br><span class="line">    *pp = b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That traversal might look confusing as all hell, so let’s take a closer look.<br>It defines <code>pp</code> as a double pointer: a pointer to a pointer to a <code>struct buf</code>.<br>(If you’ve seen the interview of Linus Torvalds where he talks about good style<br>with linked lists, it’s similar to the code there; there’s a nice summary<br><a target="_blank" rel="noopener" href="https://github.com/mkirchner/linked-list-good-taste">here</a>.) <code>pp</code> starts off<br>equal pointing to <code>idequeue</code>, i.e. the head of the linked list. Each iteration<br>checks that <code>pp</code> points to a valid (non-null) pointer, i.e. the loop will end<br>when we reach the end of the list. The body of the loop is empty, so none of the<br>iterations actually do anything; the purpose of the for loop is just to update<br><code>pp</code> several times. At the end of each iteration, <code>pp</code> is updated to point to a<br>pointer to the next buffer in the queue.</p>
<p>Suppose the last buffer in the queue is <code>end</code>. At the end of the for loop, <code>pp</code><br>will hold the address of <code>end-&gt;qnext</code>, so <code>*pp = b</code> sets <code>end-&gt;qnext = b</code>. The<br>double indirection makes it easy to update the last buffer in the queue; without<br>it, we would have to stop the loop one step earlier when <code>pp</code> points to <code>end</code><br>instead of <code>end-&gt;qnext</code> then be careful to update the actual buffer at the end<br>of the queue instead of just updating the local variable <code>pp</code>. All in all, it’s<br>just an elegant way to write a linked list traversal in a single line.</p>
<p>Okay, so now our buffer <code>b</code> is at the end of the queue. If there are others in<br>front of it, then <code>ideintr()</code> will make sure that each disk interrupt starts the<br>disk on the next operation. But what if <code>b</code> is actually the only buffer in the<br>queue? In that case, the disk isn’t running yet, so we need to get it started<br>ourselves.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (idequeue == b) &#123;</span><br><span class="line">        idestart(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At this point, we can be confident that the disk will either start our request<br>now or get to it eventually (if there are other requests in the queue). This<br>process just has to wait for the disk to finish, so we’ll put it to sleep until<br>the buffer has been synchronized with the disk. We’ll check that by making sure<br>the <code>B_VALID</code> flag is present but <code>B_DIRTY</code> is not set. The call to <code>sleep()</code><br>will release <code>idelock</code> and reacquire it before returning.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iderw</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> ((b-&gt;flags &amp; (B_VALID | B_DIRTY)) != B_VALID) &#123;</span><br><span class="line">        sleep(b, &amp;idelock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Summary-12"><a href="#Summary-12" class="headerlink" title="Summary"></a>Summary</h2><p>The disk driver handles direct communication with the hard drive, issuing orders<br>to read or write sectors. It exposes two API functions, <code>ideintr()</code> and<br><code>iderw()</code>. The former is called by <code>trap()</code> to handle disk interrupts, while the<br>latter is called by the code for the buffer cache layer of the file system to<br>update blocks in the buffer cache with their corresponding sectors on disk. Next<br>up we’ll look at the buffer cache itself, as well as the logging layer, which<br>provides crash recovery.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/06/xv6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/06/xv6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">xv6笔记之环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-06 17:37:22" itemprop="dateCreated datePublished" datetime="2023-05-06T17:37:22+08:00">2023-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xv6/" itemprop="url" rel="index"><span itemprop="name">xv6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文在Ubuntu22.04上搭建xv6(x86版本)的开发环境，用于编译、调试xv6源码。</p>
<ul>
<li>xv6 x86版本参考<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/overview.html">MIT6.828&#x2F;2018</a></li>
<li>xv6 riscv版本参考<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/">MIT6.S081</a> ，MIT6.828从2019年以后以RISCV指令集实现，并拆分了课程</li>
</ul>
<p>两者的课程内容区别：</p>
<p>6.828 and 6.S081 will be offered as two separate classes. 6.S081 (Introduction to Operating Systems) will be taught as a stand-alone AUS subject for undergraduates, and will provide an introduction to operating systems. 6.828 will be offered as a graduate-level seminar-style class focused on research in operating systems. 6.828 will assume you have taken 6.S081 or an equivalent class.</p>
<p>为什么选用x86版本：</p>
<p>x86版本有更完善的资料和更细节的代码讲解，参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/palladian1/xv6-annotated">xv6-annotated</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/woai3c/MIT6.828">woai3c&#x2F;MIT6.828</a></p>
<p>学完x86版本再学riscv版本，只需要关注指令集差异即可</p>
<h2 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h2><p>主流程参考：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/tools.html">Tools Used in 6.828</a></p>
<p>这里只记录我操作过程中和该wiki的差异点</p>
<p>1.下载包有的连接失败，bing搜索到合适的下载源后，最终成功下载的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br></pre></td></tr></table></figure>

<p>2.编译Toolchain中的问题：</p>
<p>(0)<strong>注意!!!</strong> 在编译Toolchain完成以后要恢复默认的LD_LIBRARY_PATH，不要在toolchain配置了LD_LIBRARY_PATH的情况下去完成后续的安装qemu等其他任何操作，否则可能系统损害无法进入桌面且不能recovery，报错如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libgnutls.so.30 undefined symbol: __gmpz_limbs_write</span><br></pre></td></tr></table></figure>

<p>问题原因和解决办法参考：<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined"><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1065651/apt-get-wants-an-older-gnutls-version-to-be-defined">apt-get wants an older GNUTLS version to be defined</a></a></p>
<p><strong>LIB PATH导致系统损坏的经验：搭建开发环境配置的LD_LIBRARY_PATH不要随便export；在使用时export, 使用完毕后恢复</strong></p>
<p>(1)如果安装在&#x2F;usr&#x2F;local，所有make install都要sudo；安装在home不需要sudo</p>
<p>(2)编译gcc时报错：<code>configure: error: cannot compute suffix of object files: cannot compile</code></p>
<p>需要export PATH，由于所有编译包都安装在&#x2F;usr&#x2F;local&#x2F;，所以export PATH也为&#x2F;usr&#x2F;local&#x2F;，保存为export-path.sh方便重启后使用，也可以加到~&#x2F;.bashrc：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>(3)编译gdb时报错：<code>error: no termcap library found</code></p>
<p>要手动下载termcap包并编译，操作过程和toolchain一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>完整的编译脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export PFX=~/xv6/toolchain #这里编译到home,也可以用/usr/local</span><br><span class="line">mkdir -p $PFX</span><br><span class="line">cd $PFX</span><br><span class="line"></span><br><span class="line">#install a development environment.</span><br><span class="line">sudo apt-get install -y build-essential gdb</span><br><span class="line">sudo apt-get install gcc-multilib</span><br><span class="line"></span><br><span class="line">#Building Your Own Compiler Toolchain</span><br><span class="line">#wget容易失败，因此这部分最好手动执行，确保全部下载成功</span><br><span class="line">wget https://www.mirrorservice.org/pub/gnu/gmp/gmp-5.0.2.tar.bz2</span><br><span class="line">wget https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</span><br><span class="line">wget http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</span><br><span class="line">wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</span><br><span class="line">wget http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</span><br><span class="line"></span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">tar xjf gmp-5.0.2.tar.bz2</span><br><span class="line">cd gmp-5.0.2</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf mpfr-3.1.2.tar.bz2</span><br><span class="line">cd mpfr-3.1.2</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xzf mpc-0.9.tar.gz</span><br><span class="line">cd mpc-0.9</span><br><span class="line">./configure --prefix=$PFX --with-gmp=$PFX #这里指定gmp.h的path</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf binutils-2.21.1.tar.bz2</span><br><span class="line">cd binutils-2.21.1</span><br><span class="line">./configure --prefix=$PFX --target=i386-jos-elf --disable-werror</span><br><span class="line">make</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gcc-core-4.6.4.tar.bz2</span><br><span class="line">cd gcc-4.6.4</span><br><span class="line">mkdir build              # GCC will not compile correctly unless you build in a separate directory</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=$PFX \ </span><br><span class="line">    --with-gmp=$PFX --with-mpfr=$PFX --with-mpc=$PFX \ #指定gmp, mpfr, mpc位置</span><br><span class="line">    --target=i386-jos-elf --disable-werror \</span><br><span class="line">    --disable-libssp --disable-libmudflap --with-newlib \</span><br><span class="line">    --without-headers --enable-languages=c MAKEINFO=missing</span><br><span class="line">make all-gcc</span><br><span class="line">make install-gcc         # This step may require privilege (sudo make install-gcc)</span><br><span class="line">make all-target-libgcc</span><br><span class="line">make install-target-libgcc     # This step may require privilege (sudo make install-target-libgcc)</span><br><span class="line">cd ../..</span><br><span class="line"></span><br><span class="line">wget https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span><br><span class="line">tar xzf termcap-1.3.1.tar.gz</span><br><span class="line">cd termcap-1.3.1/</span><br><span class="line">./configure --prefix=$PFX</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar xjf gdb-7.3.1.tar.bz2</span><br><span class="line">cd gdb-7.3.1</span><br><span class="line">./configure --prefix=$PFX \</span><br><span class="line">    --target=i386-jos-elf --program-prefix=i386-jos-elf- \</span><br><span class="line">    --disable-werror</span><br><span class="line">make all</span><br><span class="line">make install             # This step may require privilege (sudo make install)</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">i386-jos-elf-objdump -i</span><br><span class="line"># Should produce output like:</span><br><span class="line"># BFD header file version (GNU Binutils) 2.21.1</span><br><span class="line"># elf32-i386</span><br><span class="line">#  (header little endian, data little endian)</span><br><span class="line">#   i386...</span><br><span class="line"></span><br><span class="line">i386-jos-elf-gcc -v</span><br><span class="line"># Should produce output like:</span><br><span class="line"># Using built-in specs.</span><br><span class="line"># COLLECT_GCC=i386-jos-elf-gcc</span><br><span class="line"># COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/i386-jos-elf/4.6.4/lto-wrapper</span><br><span class="line"># Target: i386-jos-elf</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=&quot;&quot; #恢复系统本身的libpath(默认空)，避免装其他软件有lib冲突造成系统损坏</span><br></pre></td></tr></table></figure>

<h2 id="交叉编译的参数"><a href="#交叉编译的参数" class="headerlink" title="交叉编译的参数"></a>交叉编译的参数</h2><p>在交叉编译configure时，通常会需要设置–build、–host和–target选项。各个选项的含义如下：</p>
<ul>
<li>–build：编译所用的机器的平台。</li>
<li>–host：编译出的代码运行的平台。</li>
<li>–target：编译出来的工具链生成的代码的运行平台。这个选项不常用，一般只在编译gcc、ld等工具链的过程中用到。</li>
</ul>
<p>在不涉及到交叉编译的时候，–build、–host、–target缺省值都是本机平台，不需要特别设置。</p>
<p>在交叉编译的时候，比如需要在x86平台编译arm程序，就需要设置–build和–host选项；其中host的内容为目标平台名称，通常编译器的名字前缀就是目标平台名称，例如用arm-unknown-linux-gnueabi-gcc编译，–host设置为arm-unknown-linux-gnueabi；–build可以缺省不设置就是使用当前平台名称</p>
<h2 id="编译QEMU"><a href="#编译QEMU" class="headerlink" title="编译QEMU"></a>编译QEMU</h2><p>xv6使用的QEMU是patched version，要手动编译，过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mit-pdos/6.828-qemu.git qemu</span><br><span class="line"></span><br><span class="line">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span><br><span class="line"></span><br><span class="line">#此qemu版本需要python2 (2.7), 由于python2和3不兼容, 且系统只有Python3, 因此需要安装</span><br><span class="line">sudo apt install python2</span><br><span class="line">python2 -V</span><br><span class="line">cd qemu</span><br><span class="line"></span><br><span class="line">./configure --disable-kvm --disable-werror --prefix=$PFX --target-list=&quot;i386-softmmu x86_64-softmmu&quot; --python=/usr/bin/python2</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>qemu编译错误的解决办法：<a target="_blank" rel="noopener" href="https://github.com/woai3c/MIT6.828/blob/master/docs/install.md">MIT6.828 实验环境安装教程</a></p>
<p>其中以下错误的解决方法： 在 <code>qga/commands-posix.c</code> 文件中加 <code>#include &lt;sys/sysmacros.h&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: In function ‘dev_major_minor’:</span><br><span class="line">qga/commands-posix.c:633:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;.</span><br></pre></td></tr></table></figure>

<h2 id="运行xv6"><a href="#运行xv6" class="headerlink" title="运行xv6"></a>运行xv6</h2><p>下载6.828的jos lab，make产生kernel.img</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></pre></td></tr></table></figure>

<p>运行qemu的xv6之前，需要export PATH和LD_LIBRARY_PATH；运行之后要清掉LD_LIBRARY_PATH为空(重启或手动清除)</p>
<p>写export_xv6.sh如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PFX=~/xv6/toolchain</span><br><span class="line">export PATH=$PFX/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$PFX/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>建议给调用export_xv6.sh的命令加别名(alias)到.bashrc，可以用get-xv6命令一键export：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias get_xv6=&#x27;. $HOME/xv6/export_xv6.sh&#x27;</span><br></pre></td></tr></table></figure>

<p>如果是本地执行qemu(带GUI)用<code>make qemu</code>; 如果是远程终端执行用<code>make qemu-nox</code>。qemu内容如下表示qemu环境搭建OK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit</span><br><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log </span><br><span class="line">VNC server running on `127.0.0.1:5900&#x27;</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/05/esp32%E7%AC%94%E8%AE%B0%E4%B9%8BPWM%E5%AE%9E%E7%8E%B0LED%E5%91%BC%E5%90%B8%E7%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/esp32%E7%AC%94%E8%AE%B0%E4%B9%8BPWM%E5%AE%9E%E7%8E%B0LED%E5%91%BC%E5%90%B8%E7%81%AF/" class="post-title-link" itemprop="url">esp32笔记之PWM实现LED呼吸灯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 16:50:16" itemprop="dateCreated datePublished" datetime="2023-05-05T16:50:16+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/esp32/" itemprop="url" rel="index"><span itemprop="name">esp32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h2><p>先从应用上讲讲PWM：</p>
<p>有一盏日光灯，一般我们只能打开它或者关闭它，不存在中间状态；</p>
<p>有另一个LED灯，支持在一秒以内极快速的速度开关开关，其变化超过人眼识别的24帧率，LED灯看上去就像一直开着，但亮度比常开暗一些；如果控制灯快速开关过程中的打开时间和关闭时间的比例，就可以调节人眼看到的灯亮度。</p>
<p>以上就是PWM的大概应用原理：用高频率的开关信号，控制输出信号的平均强度，使输出信号能在0%到100%强度间任意调节。</p>
<p>用电路语句讲PWM原理：用数字信号的占空比来调制模拟信号的幅度(电压)。</p>
<p>PWM详细介绍参考：<a target="_blank" rel="noopener" href="https://circuitdigest.com/tutorial/what-is-pwm-pulse-width-modulation">What is PWM: Pulse Width Modulation</a></p>
<p>脉冲宽度(pulse width)是指单位时间的高电平的持续时间，脉冲宽度越大被调制的模拟信号电压越大。</p>
<ul>
<li>在一定的频率下，通过不同的(高电平)占空比即可得到不同脉冲宽度，进而调节输出的模拟电压信号</li>
<li>在一定的占空比下，通过不同的频率实现不同的调节速度；频率要适配不同设备，不能任意设置，例如电机频率50HZ，MCU外设1000Hz。频率不决定被调制电压的幅度。</li>
</ul>
<p>PWM的调制信号如下：</p>
<p><img src="https://circuitdigest.com/sites/default/files/inlineimages/pulse-width-modulation-duty-cycle.gif" alt="img"></p>
<p>PWM调制电路通常用RC filter实现：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051659127.jpg" alt="Converting-PWM-signals-into-Analog"></p>
<p>PWM一般对具体设备使用固定频率，再调整高电平的占空比决定模拟信号的幅度。</p>
<p>如下图，占空比从0%调节到100%，对应输出电压为0V~5V</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305061100234.jpg" alt="Pulse-Width-Modulation"></p>
<p>从原理上讲就是开关控制，在一个周期内调制信号的高电平时间越长，RC电荷积分更多，输出电压越大：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051657299.png" alt="image-20230505165748199"></p>
<h2 id="MicroPython控制PWM"><a href="#MicroPython控制PWM" class="headerlink" title="MicroPython控制PWM"></a>MicroPython控制PWM</h2><p>官方tutorial参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.micropython.org/en/latest/esp32/quickref.html">Quick reference for the ESP32</a> PWM (pulse width modulation)</p>
<p><a target="_blank" rel="noopener" href="https://docs.micropython.org/en/latest/esp32/tutorial/pwm.html#esp32-pwm">Pulse Width Modulation</a> 其中有调整频率和占空比的sample code:</p>
<ul>
<li><p>Example of a smooth frequency change:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">F_MIN = 500</span><br><span class="line">F_MAX = 1000</span><br><span class="line"></span><br><span class="line">f = F_MIN</span><br><span class="line">delta_f = 1</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), f)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.freq(f)</span><br><span class="line"></span><br><span class="line">    sleep(10 / F_MIN)</span><br><span class="line"></span><br><span class="line">    f += delta_f</span><br><span class="line">    if f &gt;= F_MAX or f &lt;= F_MIN:</span><br><span class="line">        delta_f = -delta_f</span><br></pre></td></tr></table></figure>
</li>
<li><p>Example of a smooth duty change:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from utime import sleep</span><br><span class="line">from machine import Pin, PWM</span><br><span class="line"></span><br><span class="line">DUTY_MAX = 2**16 - 1</span><br><span class="line"></span><br><span class="line">duty_u16 = 0</span><br><span class="line">delta_d = 16</span><br><span class="line"></span><br><span class="line">p = PWM(Pin(5), 1000, duty_u16=duty_u16)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    p.duty_u16(duty_u16)</span><br><span class="line"></span><br><span class="line">    sleep(1 / 1000)</span><br><span class="line"></span><br><span class="line">    duty_u16 += delta_d</span><br><span class="line">    if duty_u16 &gt;= DUTY_MAX:</span><br><span class="line">        duty_u16 = DUTY_MAX</span><br><span class="line">        delta_d = -delta_d</span><br><span class="line">    elif duty_u16 &lt;= 0:</span><br><span class="line">        duty_u16 = 0</span><br><span class="line">        delta_d = -delta_d</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="呼吸灯示例"><a href="#呼吸灯示例" class="headerlink" title="呼吸灯示例"></a>呼吸灯示例</h2><p>参考：<a target="_blank" rel="noopener" href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/03.PWMhuxideng">itproject.cn&#x2F;Python+ESP32快速上手&#x2F;3.PWM呼吸灯</a></p>
<p>esp32的micropython代码以script形式执行，主程序必须命名为main.py(参考 <a target="_blank" rel="noopener" href="https://docs.micropython.org/en/v1.9.3/pyboard/pyboard/tutorial/script.html">Running your first script</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from machine import Pin, PWM</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">led2 = PWM(Pin(2))</span><br><span class="line">led2.freq(1000)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    for i in range(0, 1024):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br><span class="line">        </span><br><span class="line">    for i in range(1023, -1, -1):</span><br><span class="line">        led2.duty(i)</span><br><span class="line">        time.sleep_ms(1)</span><br></pre></td></tr></table></figure>

<p>LED渐变呼吸闪烁：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305052003803.gif" alt="mmexport1683287925729"></p>
<p>如果将led duty调整为512，最大亮度会变小，验证了最大占空比决定最大电压</p>
<p>如果将led freq调整为50，最大亮度不变，但led渐变过程中会闪烁，也就是说开关调节频率太低，导致人眼都可以观察到led的开关电，看上去就是led闪烁</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/05/04/esp32%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/04/esp32%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">esp32笔记之环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-04 13:07:23" itemprop="dateCreated datePublished" datetime="2023-05-04T13:07:23+08:00">2023-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/esp32/" itemprop="url" rel="index"><span itemprop="name">esp32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>esp32是乐鑫的SOC，支持Wifi, BLE等IOT功能；官方教程：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html">ESP-IDF编程指南</a></p>
<h1 id="ESP-IDF环境搭建"><a href="#ESP-IDF环境搭建" class="headerlink" title="ESP-IDF环境搭建"></a>ESP-IDF环境搭建</h1><p>按官方教程在Linux ubuntu搭建ESP-IDF开发环境，有clone idf一直失败的问题</p>
<p>本节记录不用翻墙搭建ESP-ID环境的过程，视频参考：<a target="_blank" rel="noopener" href="https://b23.tv/VCYbC2m">Linux 如何安装 ESP-IDF ESP32 开发环境搭建</a></p>
<h2 id="版本发布、下载"><a href="#版本发布、下载" class="headerlink" title="版本发布、下载"></a>版本发布、下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/releases">https://github.com/espressif/esp-idf/releases</a></p>
<p>手动下载release版本的idf压缩包，例如下载esp-idf-v5.0.1.zip</p>
<p>解压到 ~&#x2F;esp&#x2F;esp-idf (<code>mv esp-idf-v5.0.1 esp-idf</code>)</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git wget flex bison gperf python3 python3-venv python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0</span><br></pre></td></tr></table></figure>

<h2 id="安装-ESP-IDF"><a href="#安装-ESP-IDF" class="headerlink" title="安装 ESP-IDF"></a>安装 ESP-IDF</h2><p>安装 ESP-IDF 使用的各种工具，比如编译器、调试器、Python 包等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">./install.sh esp32 #esp32 chip,用此命令即可</span><br><span class="line">./install.sh all #所有esp chips</span><br></pre></td></tr></table></figure>

<p>如果安装遇到网络问题，需要设置下载服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/esp/esp-idf</span><br><span class="line">export IDF_GITHUB_ASSETS=&quot;dl.espressif.com/github_assets&quot;</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>如果遇到 Python 包安装问题则需要设置 Python 源</p>
<h2 id="设置环境变量："><a href="#设置环境变量：" class="headerlink" title="设置环境变量："></a>设置环境变量：</h2><p>每次运行都export环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. $HOME/esp/esp-idf/export.sh</span><br></pre></td></tr></table></figure>

<p>或把将以下语句加入 ~&#x2F;.bashrc，每次执行只需要 <code>get_idf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias get_idf=&#x27;. $HOME/esp/esp-idf/export.sh&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="串口相关设置"><a href="#串口相关设置" class="headerlink" title="串口相关设置"></a>串口相关设置</h2><p><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/establish-serial-connection.html">与 ESP32 创建串口连接</a></p>
<p>查看串口: ls &#x2F;dev&#x2F;tty* (esp32应该是ttyUSB0)</p>
<p>必须将将用户添加到 <code>dialout</code> 组，从而获许串口读写权限，否则串口无法连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br></pre></td></tr></table></figure>

<h2 id="编译和烧录"><a href="#编译和烧录" class="headerlink" title="编译和烧录"></a>编译和烧录</h2><ul>
<li>设置：idf.py menuconfig</li>
<li>编译：idf.py build</li>
<li>烧录：idf.py -p PORT 【-b BAUD】 flash</li>
<li>监视：idf.py -p PORT monitor，使用快捷键 <code>Ctrl+]</code>，退出 IDF 监视器</li>
<li>一次性执行构建、烧录和监视过程：idf.py -p PORT flash monitor</li>
</ul>
<h1 id="MicroPython环境搭建"><a href="#MicroPython环境搭建" class="headerlink" title="MicroPython环境搭建"></a>MicroPython环境搭建</h1><p>分为esp32侧的Firmware和PC侧的IDE两部分。</p>
<p>本文是Linux环境，windows环境参考：<a target="_blank" rel="noopener" href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/01.dajianhuanjing">Thonny+MicroPython+ESP32开发环境搭建</a></p>
<h2 id="ESP32安装MicroPython"><a href="#ESP32安装MicroPython" class="headerlink" title="ESP32安装MicroPython"></a>ESP32安装MicroPython</h2><p>Micropython是在嵌入式平台上运行Python的基础库，参考：<a target="_blank" rel="noopener" href="https://docs.micropython.org/en/latest/">https://docs.micropython.org/en/latest/</a></p>
<p>下载和安装esp32的Micropython，参考：<a target="_blank" rel="noopener" href="https://micropython.org/download/esp32/">Installation instructions</a></p>
<p>先擦除flash, 其中esptool.py已经被esp-idf&#x2F;export.sh导出到环境变量；如果ls &#x2F;dev&#x2F;tty*显示有ttyUSB0，但esptool.py还找不到ttyUSB0，需要重启并用<code>get_idf</code>重新export idf，再插拔esp32就可以找到.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash</span><br></pre></td></tr></table></figure>

<p>烧写支持micropython的 &lt;esp32-firmware.bin&gt;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 &lt;esp32-firmware.bin&gt;</span><br></pre></td></tr></table></figure>

<p>例如我的Firmware使用的是：</p>
<p><strong><a target="_blank" rel="noopener" href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.bin">v1.20.0 (2023-04-26) .bin</a></strong> [<a target="_blank" rel="noopener" href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.elf">.elf]</a> [<a target="_blank" rel="noopener" href="https://micropython.org/resources/firmware/esp32-20230426-v1.20.0.map">.map]</a> [<a target="_blank" rel="noopener" href="https://github.com/micropython/micropython/releases/tag/v1.20.0">Release notes]</a> (latest)</p>
<h2 id="使用VScode-Pymakr搭建Micropython开发环境"><a href="#使用VScode-Pymakr搭建Micropython开发环境" class="headerlink" title="使用VScode+Pymakr搭建Micropython开发环境"></a>使用VScode+Pymakr搭建Micropython开发环境</h2><p>总体的安装流程参考：<a target="_blank" rel="noopener" href="https://randomnerdtutorials.com/micropython-esp32-esp8266-vs-code-pymakr/">MicroPython: Program ESP32&#x2F;ESP8266 using VS Code and Pymakr</a></p>
<p>Pymakr如何使用，参考<a target="_blank" rel="noopener" href="https://github.com/pycom/pymakr-vsc/blob/next/GET_STARTED.md">Pymakr Getting Started</a></p>
<p>写一个LED闪烁的sample code验证开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from machine import Pin</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">led = Pin(2, Pin.OUT) #GPIO2, output mode</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">  led.value(not led.value())</span><br><span class="line">  sleep(0.5)</span><br></pre></td></tr></table></figure>

<p>LED如何控制，要根据esp32具体开发板的电路图找到LED相关的GPIO，以及配什么输入&#x2F;输出模式使GPIO导通&#x2F;关闭。</p>
<p>如下图，我的esp32 LED连接到GPIO2(IO2)，并且GPIO2输出高电平时LED导通</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042003091.png" alt="image-20230504200335998"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305042004848.png" alt="image-20230504200411499"></p>
<p>选择VSCode的Pymakr Project -&gt; connect device -&gt; ’sync project to device‘，上传该LED python代码到esp32上运行；右键Pymakr Project的Hard reset device以后执行python代码</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051116409.png" alt="image-20230505111655320"></p>
<p>esp32 GPIO2的LED不停闪烁</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051156061.gif" alt="mmexport1683202673677"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/04/26/Ubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/26/Ubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Ubuntu使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 11:08:09" itemprop="dateCreated datePublished" datetime="2023-04-26T11:08:09+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文基于Ubuntu 22.04 LTS</p>
<h2 id="软件下载源"><a href="#软件下载源" class="headerlink" title="软件下载源"></a>软件下载源</h2><p>使用国内软件源下载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">software&amp;updates -&gt; Ubuntu Software -&gt; download from -&gt; cn99.com或aliyun.com</span><br></pre></td></tr></table></figure>

<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>安装中文输入法(pinyin)的步骤：</p>
<p>安装中文支持：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Install/Remove Languages -&gt; 安装chinese simplified</span><br></pre></td></tr></table></figure>

<p>设置系统语言为中文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成Chinese</span><br></pre></td></tr></table></figure>

<p>安装Fcitx框架和中文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx-bin #安装fcitx框架</span><br><span class="line">sudo apt-get install fcitx-table #安装输入法栏，其中自动安装拼音输入法</span><br><span class="line">fcitx --version</span><br></pre></td></tr></table></figure>

<p>使用Fcitx框架，重启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Keyboard input method system 选择Fcitx 4</span><br></pre></td></tr></table></figure>

<p>添加输入法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu右上角的小键盘图标 -&gt; configure -&gt; 添加pinyin（只有系统语言为中文时才能添加中文输入法）</span><br></pre></td></tr></table></figure>

<p>切换中英文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + space</span><br></pre></td></tr></table></figure>

<p>设置系统语言改回英文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成English</span><br></pre></td></tr></table></figure>

<h2 id="snap包管理工具"><a href="#snap包管理工具" class="headerlink" title="snap包管理工具"></a>snap包管理工具</h2><p><a target="_blank" rel="noopener" href="https://snapcraft.io/store">Snap</a>是Canonical开发的Linux包管理和软件部署工具。 </p>
<p>安装和使用参考 <a target="_blank" rel="noopener" href="https://phoenixnap.com/kb/install-snap-ubuntu#:~:text=1%20Start%20by%20updating%20packages%3A%0Asudo%20apt,update%202%20Enter%20the%20following%20command%3A"><strong>How to Install Snap on Ubuntu</strong></a></p>
<p>特点：丰富的第三方工具库，包括开源工具和闭源工具；二进制安装，不是源码编译</p>
<p>相比apt，其查找工具和安装极为简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo snap find &lt;keyword&gt; #查找keyword相关的工具，显示可安装的列表</span><br><span class="line">sudo snap install &lt;package&gt; #安装列表中的工具</span><br></pre></td></tr></table></figure>

<p>查看和卸载snap安装的包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">snap list</span><br><span class="line">sudo snap remove &lt;package&gt;</span><br></pre></td></tr></table></figure>

<p>示例：安装VSCode和Chrome</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo snap find vscode #找到&lt;package&gt;为code</span><br><span class="line">sudo snap install code --classic</span><br><span class="line">sudo snap find chrome #找到&lt;package&gt;为chromium</span><br><span class="line">sudo snap install chromium</span><br></pre></td></tr></table></figure>

<h2 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h2><p>setting -&gt; keyboard -&gt; shortcuts -&gt; custom shortcut -&gt; 为应用程序添加快捷键</p>
<p>以截图工具flameshot为例，设置快捷键的command为调用flameshot的命令，截图默认保存到~&#x2F;Pictures</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051055723.png" alt="image-20230505105544618"></p>
<p>要配置其他flameshot命令的快捷键，用 <code>man flameshot</code> 查看，参考 <a target="_blank" rel="noopener" href="https://flameshot.org/docs/guide/key-bindings/">Keyboard shortcuts for Flameshot</a></p>
<h2 id="Timeshift备份系统"><a href="#Timeshift备份系统" class="headerlink" title="Timeshift备份系统"></a>Timeshift备份系统</h2><p>22.04系统似乎比较容易挂，进不了系统显示”Oh no… system can’t recover…”，比如：</p>
<p>Nvdia驱动选择开源版本xserver就挂了一次, recovery模式看&#x2F;var&#x2F;log&#x2F;message有nouveau和nvidia module相关问题</p>
<p>学习xv6时安装编译环境时也挂了一次(不能安装到&#x2F;usr&#x2F;local，应该安装到&#x2F;home)，recovery模式dpkg report显示failure log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbol lookup error: /lib/x86_64-linux-gnu/libgnutls.so.30: undefined symbol: __gmpz_limbs_write </span><br></pre></td></tr></table></figure>

<p>都是找遍办法都修复不了，只能重装…</p>
<p>为了解决此问题，使用Timeshift将系统备份，参考: <a target="_blank" rel="noopener" href="https://itsfoss.com/backup-restore-linux-timeshift/">How to Backup and Restore Linux System Settings With Timeshift</a></p>
<p>安装timeshift：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install timeshift</span><br></pre></td></tr></table></figure>

<p>备份整个系统，包括&#x2F;root和&#x2F;home&#x2F;user，设置定时备份</p>
<p>如何恢复：</p>
<p>情景一：系统无法进入桌面，但是可以进入recovery模式root操作：</p>
<p>如下图，用<code>timeshift --help</code>查看各种命令，使用<code>timeshift --restore</code>恢复指定snapshot</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305081931009.png" alt="image-20230508193100794"></p>
<p>情景二：系统无法进入recovery模式，但是备份的snapshot数据还在</p>
<p>使用<a target="_blank" rel="noopener" href="https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows?ref=itsfoss.com">Ubuntu Live USB</a> ，即装系统的USB进入try ubuntu环境，联网换国内源安装timeshift，再恢复系统盘中的snapshot数据</p>
<p>情景三：磁盘中的snapshot数据损害：只能重装系统，为了避免此情况发生，应该将系统备份到其他硬盘而不仅仅在当前系统盘</p>
<h2 id="Clonezilla克隆系统"><a href="#Clonezilla克隆系统" class="headerlink" title="Clonezilla克隆系统"></a>Clonezilla克隆系统</h2><p>类似windows ghost的整盘克隆：</p>
<p><a target="_blank" rel="noopener" href="https://www.linuxbabe.com/backup/how-to-use-clonezilla-live">https://www.linuxbabe.com/backup/how-to-use-clonezilla-live</a></p>
<p>至少需要三个盘：</p>
<p>在U盘写入Clonezilla的live usb iso生成Clonezilla live USB，再以Clonezilla live USB启动，对待备份的SSD盘做系统备份，到另一个SSD或者大USB盘；</p>
<p>恢复也是需要Clonezilla live USB + 有系统备份的盘 + 目标写入盘</p>
<h2 id="关于系统目录"><a href="#关于系统目录" class="headerlink" title="关于系统目录"></a>关于系统目录</h2><p>&#x2F;usr：系统级的目录，可以理解为C:&#x2F;Windows&#x2F;，apt安装的一般在&#x2F;usr&#x2F;bin和&#x2F;usr&#x2F;lib</p>
<p>&#x2F;usr&#x2F;lib：理解为C:&#x2F;Windows&#x2F;System32</p>
<p>&#x2F;usr&#x2F;local：用户级的程序目录，可以理解为C:&#x2F;Progrem Files&#x2F;，用户自己编译的软件默认安装到这个目录下</p>
<p>&#x2F;opt是用户级的目录用来安装大型的第三方附加软件包，可以理解为D:&#x2F;Software</p>
<p>开发过程中为了避免lib冲突，自己编译的包建议放在&#x2F;home&#x2F;&lt;具体的项目目录&gt;，此外注意自己编译基础库设置的LD_LIBRARY_PATH造成系统库链接冲突</p>
<h2 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></p>
<h2 id="VNC远程桌面"><a href="#VNC远程桌面" class="headerlink" title="VNC远程桌面"></a>VNC远程桌面</h2><p>Ubuntu安装vino作为VNC server, windows端使用VNC Viewer作为client.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install vino</span><br><span class="line">setting -&gt; Sharing -&gt; Remote Desktop -&gt; On</span><br></pre></td></tr></table></figure>

<p>参考 <a target="_blank" rel="noopener" href="https://www.answertopia.com/ubuntu/ubuntu-remote-desktop-access-with-vino/">Ubuntu 22.04 Remote Desktop Access with Vino</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/04/10/%E6%B5%85%E8%B0%88%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8CReDriver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/10/%E6%B5%85%E8%B0%88%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8CReDriver/" class="post-title-link" itemprop="url">浅谈信号完整性和ReDriver</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-10 10:51:25" itemprop="dateCreated datePublished" datetime="2023-04-10T10:51:25+08:00">2023-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IC/" itemprop="url" rel="index"><span itemprop="name">IC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="信号完整性"><a href="#信号完整性" class="headerlink" title="信号完整性"></a>信号完整性</h2><p>在讨论ReDriver之前，先说明信号完整性（Signal Integrity, SI）的相关背景。<br>电子信号在传输过程中(无线或有线)都会受到环境噪声干扰，信号功率也会随着传输距离衰减(signal attenuation)。<br>通信系统中用信噪比表达的信号的好坏:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">信噪比(dB)=10*log（信号/噪音）</span><br></pre></td></tr></table></figure>

<ul>
<li>当信噪比大于设备接收灵敏度时，信号能被正常接收和解析（成逻辑0&#x2F;1）</li>
<li>当信噪比小于设备接收灵敏度时，信号被错误解析（错误的逻辑0&#x2F;1）或者是根本解析不出信号(噪声完全淹没信号，接收端恒为0或1，没有信号变化)。</li>
</ul>
<p>信号完整性（Signal Integrity, SI）一般指PCB电路中的电压信号的信噪比好坏。如果电路中信号能够以要求的时序、持续时间和电压幅度到达接收器，则该电路具有较好的信号完整性。反之当信号不能正常响应时，就出现了信号完整性问题。一般通过眼图观测信号完整性好坏。</p>
<p>信号完整性在高速电路更容易出问题，表现为信号有传输延迟和时序错误、电路串扰（电容性、电感性串扰）等。</p>
<p>高速信号的PCB电路设计和信号完整性密切相关，例如下图是PCB使用FR4材料和Megtron6材料，信号-频率函数显示衰减度不同。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101118830.png" alt="Attenuation versus Frequency as a function of PCB material"></p>
<h2 id="ReDriver"><a href="#ReDriver" class="headerlink" title="ReDriver"></a>ReDriver</h2><p>Redriver能减弱信号在远距离、高噪声环境的传输中的信号完整性问题对接收端的影响。</p>
<p>Redriver类似通信系统中的基站，其接收传输线路中的信号，重新生成原始信号，再转发给远端设备；其输出信号基本和原始信号完全一致以保证接收端能正常解析信号。</p>
<p>(1)PCIe redriver</p>
<p>以典型的高速信号PCIe接口为例，其使用Redriver和Retimer提高信号完整性，参考：<a target="_blank" rel="noopener" href="https://www.allaboutcircuits.com/industry-articles/choosing-the-right-redriver-or-retimer-device-to-extend-pcie-protocol-signal-range/">Choosing the Right Redriver or Retimer Device to Extend PCIe Protocol Signal Range</a></p>
<p>其RX, EQ接收PCIe信号源的TX, EQ信号，redrive生成原始信号后再从TX, EQ发送给接收端。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101126665.png" alt="Single lane redriver block diagram"></p>
<p>(2)USB redriver</p>
<p>以多层子设备结构的USB接口为例，其使用Redriver提高子USB host的驱动能力，参考 <a target="_blank" rel="noopener" href="https://www.diodes.com/zh/products/connectivity-and-timing/redrivers-repeaters/">信号完整性 - ReDriver&#x2F; 信号中继器 &#x2F; 调节器</a></p>
<p><img src="https://www.diodes.com/assets/Uploads/redrivers-application2__ResizedImageWzYwMCwzNTFd.png" alt="redrivers application2"></p>
<p>(3)SD redriver</p>
<p>即使是较低速的SD接口(MB&#x2F;s级别)也有PCB设计和传输距离引起的信号完整性问题，也需要redriver解决。</p>
<p>如下SD redriver接收SD host的几个信号并重新生成：SD clock, SD cmd, SD data, Vdd power。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101130119.png" alt="image-20230410113046013"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/03/28/Github%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9Alinked-list-good-taste/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/28/Github%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9Alinked-list-good-taste/" class="post-title-link" itemprop="url">Github项目学习：linked-list-good-taste</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-28 10:30:15" itemprop="dateCreated datePublished" datetime="2023-03-28T10:30:15+08:00">2023-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/github%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">github项目学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转载自 <a target="_blank" rel="noopener" href="https://github.com/mkirchner/linked-list-good-taste">linked-list-good-taste</a>，添加了个人理解的注释</p>
<h1 id="Linked-lists-pointer-tricks-and-good-taste"><a href="#Linked-lists-pointer-tricks-and-good-taste" class="headerlink" title="Linked lists, pointer tricks and good taste"></a>Linked lists, pointer tricks and good taste</h1><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-code">The code</a><ul>
<li><a href="#the-cs101-version">The CS101 version</a></li>
<li><a href="#a-more-elegant-solution">A more elegant solution</a></li>
</ul>
</li>
<li><a href="#how-does-it-work">How does it work?</a><ul>
<li><a href="#integrating-the-head-pointer">Integrating the head pointer</a></li>
<li><a href="#maintaining-a-handle">Maintaining a handle</a></li>
</ul>
</li>
<li><a href="#going-beyond">Going beyond</a><ul>
<li><a href="#inserting-before-existing-items">Inserting before existing items</a></li>
<li><a href="#quick-refactor">Quick refactor</a></li>
<li><a href="#implementing-insert_before">Implementing insert_before()</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In a 2016 <a target="_blank" rel="noopener" href="https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux">TED interview</a> (14:10) Linus Torvalds speaks about what he considers <em>good taste</em> in coding. As an example, he presents two implementations of item removal in singly linked lists (reproduced below).  In order to remove the first item from a list, one of the implementations requires a special case, the other one does not.  Linus, obviously, prefers the latter.</p>
<p>His comment is:</p>
<blockquote>
<p>[…] I don’t want you to understand why it doesn’t have the if statement.<br>But I want you to understand that sometimes you can see a problem in a<br>different way and rewrite it so that a special case goes away and becomes the<br>normal case, and that’s <em>good code</em>. […] – L. Torvalds</p>
</blockquote>
<p>The code snippets he presents are C-style pseudocode and are simple enough to follow. However, as Linus mentions in the comment, the snippets lack a conceptual explanation and it is not immediately evident how the more elegant solution actually works.</p>
<p>The next two sections look at the technical approach in detail and demonstrate how and why the indirect addressing approach is so neat. The last section extends the solution from item deletion to insertion.</p>
<h2 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h2><p>The basic data structure for a singly linked list of integers is shown in Figure 1.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281032617.png" alt="linked list"></p>
<p>Numbers are arbitrarily chosen integer values and arrows indicate pointers. <code>head</code> is a pointer of type <code>list_item *</code> and each of the boxes is an instance of an <code>list_item</code> struct, each with a member variable (called <code>next</code> in the code) of type <code>list_item *</code> that points to the next item.</p>
<p>The C implementation of the data structure is:</p>
<p><strong>注释：list的item包含两个成员：值和指针变量；list本身是用head指针表示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> <span class="title">list_item</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We also include a (minimal) API:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The textbook version */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br><span class="line"><span class="comment">/* A more elegant solution */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br></pre></td></tr></table></figure>

<p>With that in place, let’s have a look at the implementations of <code>remove_cs101()</code> and <code>remove_elegant()</code>. The code of these examples is true to the pseudocode from Linus’ example and also compiles and runs.</p>
<h3 id="The-CS101-version"><a href="#The-CS101-version" class="headerlink" title="The CS101 version"></a>The CS101 version</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281919267.png" alt="image-20230328191958119"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item *cur = l-&gt;head, *prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != target) &#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev)</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                l-&gt;head = cur-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释：如果将list理解为(值+指针变量)成员组成的一串数据，那么访问一个成员的前置成员就得用经典的双指针法，因为单链表没有”记忆性”，要额外的前置指针保存前置位置。</strong></p>
<p><strong>考虑边界条件：1.遍历完了都找不到目标成员；2.前置指针在使用前要判空，如果为空，表明第一个节点就是目标节点，这两种情况都属于上述代码的else case处理</strong></p>
<p>The standard CS101 approach makes use of two traversal pointers <code>cur</code> and <code>prev</code>, marking the current and previous traversal position in the list, respectively.  <code>cur</code> starts at the list head <code>head</code>, and advances until the target is found.  <code>prev</code> starts at <code>NULL</code> and is subsequently updated with the previous value of <code>cur</code> every time <code>cur</code> advances. After the target is found, the algorithm tests if <code>prev</code> is non-<code>NULL</code>. If yes, the item is not at the beginning of the list and the removal consists of re-routing the linked list around <code>cur</code>. If <code>prev</code> is <code>NULL</code>, <code>cur</code> is pointing to the first element in the list, in which case, removal means moving the list head forward.</p>
<h3 id="A-more-elegant-solution"><a href="#A-more-elegant-solution" class="headerlink" title="A more elegant solution"></a>A more elegant solution</h3><p>The more elegant version has less code and does not require a separate branch to deal with deletion of the first element in a list.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code uses an indirect pointer <code>p</code> that holds the address of a pointer to a list item, starting with the address of <code>head</code>.  In every iteration, that pointer is advanced to hold the address of the pointer to the next list item, i.e. the address of the <code>next</code> element in the current <code>list_item</code>.<br>When the pointer to the list item <code>*p</code> equals <code>target</code>, we exit the search loop and remove the item from the list.</p>
<h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h2><p>The key insight is that using an indirect pointer <code>p</code> has two conceptual benefits:</p>
<ol>
<li>It allows us to interpret the linked list in a way that makes the <code>head</code> pointer an integral part the data structure. This eliminates the need for a special case to remove the first item.</li>
<li>It also allows us to evaluate the condition of the <code>while</code> loop without having to let go of the pointer that points to <code>target</code>. This allows us to modify the pointer that points to <code>target</code> and to get away with a single iterator as opposed to <code>prev</code> and <code>cur</code>.</li>
</ol>
<p>Let’s look each of these points in turn.</p>
<h3 id="Integrating-the-head-pointer"><a href="#Integrating-the-head-pointer" class="headerlink" title="Integrating the head pointer"></a>Integrating the <code>head</code> pointer</h3><p>The standard model interprets the linked list as a sequence of <code>list_item</code> instances. The beginning of the sequence can be accessed through a <code>head</code> pointer. This leads to the conceptual model illustrated in Figure 2 above. The <code>head</code> pointer is merely considered as a handle to access the start of the list. <code>prev</code> and <code>cur</code> are pointers of type <code>list_item *</code> and always point to an item or <code>NULL</code>.</p>
<p>The elegant implementation uses indirect addressing scheme that yields a different view on the data structure:</p>
<p><strong>注释：核心就是改变对链表数据结构的理解，将链表的最小单元理解为：前置指针 + (值+指针变量)成员，这样需要一个二级指针指向成员内的指针变量，链表也没有特殊性，每个成员一定有非空的前置指针和(值+指针变量)，如下图的蓝色框。</strong></p>
<p><strong>这个方法本质上是双指针的优化，只用一个二级指针就可以同时访问目标节点和前置的节点的指针变量，解决了单链表遍历过程中，找到目标节点后无法反向获得前置节点的指针变量的问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281920824.png" alt="image-20230328192017690"></p>
<p>Here, <code>p</code> is of type <code>list_item **</code> and holds the address of the pointer to the current list item. When we advance the pointer, we forward to the address of the pointer to the next list item.</p>
<p>In code, this translates to <code>p = &amp;(*p)-&gt;next</code>, meaning we</p>
<ol>
<li><code>(*p)</code>: dereference the address to the pointer to the current list item</li>
<li><code>-&gt;next</code>: dereference that pointer again and select the field that holds the address of the next list item</li>
<li><code>&amp;</code>: take the address of that address field (i.e. get a pointer to it)</li>
</ol>
<p>This corresponds to an interpretation of the data structure where the list is a a sequence of pointers to <code>list_item</code>s (cf. Figure 3).</p>
<h3 id="Maintaining-a-handle"><a href="#Maintaining-a-handle" class="headerlink" title="Maintaining a handle"></a>Maintaining a handle</h3><p>An additional benefit of that particular interpretation is that it supports editing the <code>next</code> pointer of the predecessor of the current item throughout the entire traversal.</p>
<p>With <code>p</code> holding the address of a pointer to a list item, the comparison in the search loop becomes</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (*p != target)</span><br></pre></td></tr></table></figure>

<p>The search loop will exit if <code>*p</code> equals <code>target</code>, and once it does, we are still able to modify <code>*p</code> since we hold its address <code>p</code>. Thus, despite iterating the loop until we hit <code>target</code>, we still maintain a handle (the address of the <code>next</code> field or the <code>head</code> pointer) that can be used to directly modify the pointer that points <em>to</em> the item.</p>
<p>This is the reason why we can modify the incoming pointer to an item to point to a different location using <code>*p = target-&gt;next</code> and why we do not need <code>prev</code> and <code>cur</code> pointers to traverse the list for item removal.</p>
<h2 id="Going-beyond"><a href="#Going-beyond" class="headerlink" title="Going beyond"></a>Going beyond</h2><p>It turns out that the idea behind <code>remove_elegant()</code> can be applied to yield a particularly concise implementation of another function in the list API:<code>insert_before()</code>, i.e. inserting a given item before another one.</p>
<h3 id="Inserting-before-existing-items"><a href="#Inserting-before-existing-items" class="headerlink" title="Inserting before existing items"></a>Inserting before existing items</h3><p>First, let’s add the following declaration to the list API in <code>list.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span>;</span><br></pre></td></tr></table></figure>

<p>The function will take a pointer to a list <code>l</code>, a pointer <code>before</code> to an item in that list and a pointer to a new list item <code>item</code> that the function will insert before <code>before</code>.</p>
<h3 id="Quick-refactor"><a href="#Quick-refactor" class="headerlink" title="Quick refactor"></a>Quick refactor</h3><p><strong>注释：单链表的删除节点和前向插入节点有共同的痛点：找到目标节点后无法反向获得前置节点的指针变量，此二级指针方法完美解决这类问题。</strong></p>
<p>Before we move on, we refactor the search loop into a separate function</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> list_item **<span class="title function_">find_indirect</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>and use that function in <code>remove_elegant()</code> like so</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, target);</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Implementing-insert-before"><a href="#Implementing-insert-before" class="headerlink" title="Implementing insert_before()"></a>Implementing <code>insert_before()</code></h3><p>Using <code>find_indirect()</code>, it is straightforward to implement <code>insert_before()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, before);</span><br><span class="line">        *p = item;</span><br><span class="line">        item-&gt;next = before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A particularly beautiful outcome is that the implementation has consistent semantics for the edge cases: if <code>before</code> points to the list head, the new item will be inserted at the beginning of the list, if <code>before</code> is <code>NULL</code> or invalid (i.e. the item does not exist in <code>l</code>), the new item will be appended at the end.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The premise of the more elegant solution for item deletion is a single, simple change: using an indirect <code>list_item **</code> pointer to iterate over the pointers to the list items.  Everything else flows from there: there is no need for a special case or branching and a single iterator is sufficient to find and remove the target item.<br>It also turns out that the same approach provides an elegant solution for item insertion in general and for insertion <em>before</em> an existing item in particular.</p>
<p>So, going back to Linus’ initial comment: is it good taste? Hard to say, but it’s certainly a different, creative and very elegant solution to a well-known CS task.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cursorhu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cursorhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cursorhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2449055512@qq.com" title="E-Mail → mailto:2449055512@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cursorhu</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
