<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/6/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/06/10/Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Makefile使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-10 17:20:09" itemprop="dateCreated datePublished" datetime="2020-06-10T17:20:09+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 17:30:53" itemprop="dateModified" datetime="2022-12-08T17:30:53+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/makefile/" itemprop="url" rel="index"><span itemprop="name">makefile</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件名替换"><a href="#文件名替换" class="headerlink" title="文件名替换"></a>文件名替换</h1><p>1.wildcard<br>展开多个文件为使用空格分开的、匹配此模式的列表参数<br>格式<br><code>$(wildcard PATTERN...)</code></p>
<p>示例：</p>
<pre><code>SRC=$(wildcard *.c)
</code></pre>
<p>2.patsubst<br>替换通配符<br>格式</p>
<pre><code>$(patsubst %.c,%.o,$(dir))
</code></pre>
<p>示例：</p>
<pre><code>obj := $(patsubst %.c,%.o,$(wildcard *.c))
</code></pre>
<p>3.替换引用<br>patsubst的示例等价于：</p>
<pre><code>obj=$(dir:%.c=%.o)
</code></pre>
<p>引用替换：</p>
<pre><code>$(var:a=b) 或 $&#123;var:a=b&#125;
</code></pre>
<p>含义是把变量var中的每一个值，用b替换掉a</p>
<h1 id="PHONY"><a href="#PHONY" class="headerlink" title="PHONY"></a>PHONY</h1><p>Makefile执行的规则是A:B，表示A依赖于B</p>
<ul>
<li>有B才能执行A对应的编译操</li>
<li>B有更新(检测文件时间)，则A会执行，若B没有更新，不执行A</li>
</ul>
<p>问题来了，clean: 不需要依赖任何对象，如何执行<br>PHONY定义伪目标,可以解决源文件不是最终目标直接依赖（即间接依赖）带来的不能自动检查更新规则, 示例如下</p>
<pre><code>.PHONY: clean
clean:
    rm -f *.o
</code></pre>
<p>PHONY不仅用于clean，对于间接依赖也有用，例如A:B， B:C ，有时C为空，就需要把B定义为PHONY</p>
<pre><code>OBJS = *.o
program:  $(OBJS)
        gcc *.o -o program
 
.PHONY : $(OBJS)
$(OBJS):
        make -C $(dir $@)
</code></pre>
<p>不过一般情况，obj依赖于%.c，总之，对于没有依赖项的对象，需要定义为PHONY</p>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>常见通配符</p>
<pre><code>$@, $^, $&lt;, $?

$@  表示目标文件
$^  表示所有的依赖文件
$&lt;  表示第一个依赖文件
$?  表示比目标还要新的依赖文件列表
</code></pre>
<p>示例：<br>编译Test目录下的.cpp文件，输出test可执行程序<br>直接指定依赖文件名的makefile写法：</p>
<pre><code>test: $(wildcard Test/*.cpp)
    $(CXX) $(CFLAGS) -o test $(wildcard Test/*.cpp) 
</code></pre>
<p>虽然wildcard实现了所有依赖的.cpp的通配，编译语句再用wildcard写一次依赖文件不优雅，而且test在依赖中已经写了，编译语句又写一遍 -o test。<br>编译语句使用通配, 称为通用格式：</p>
<pre><code>test: $(wildcard Test/*.cpp)
    $(CXX) $(CFLAGS) -o $@ $^
</code></pre>
<h1 id="多个源文件分别编译"><a href="#多个源文件分别编译" class="headerlink" title="多个源文件分别编译"></a>多个源文件分别编译</h1><p>目录下有很多源文件，每个单独编译和执行的，将每一个文件编译成可执行文件，不用单独命名如：gcc -c xxx.c -o xxx<br>(1)Makefile实现</p>
<pre><code>SRC=$(wildcard *.c)
OBJ=$(SRC:%.c=%.o)
BIN=$(OBJ:%.o=%)
 
CC=gcc
CFLAGS=-Wall -g -c
 
all:$(BIN)

$(BIN):%:%.o
        $(CC) $^ -o $@
$(OBJ):%.o:%.c
        $(CC) $(CFLAGS) $^ -o $@

.PHONY: clean
clean:
        rm -rf $(OBJ) $(BIN)
</code></pre>
<p>(2)Shell实现</p>
<pre><code>#! /bin/bash
for file in ./*.c
do
if [ -f $file ]
then
file=$&#123;file#./&#125;
target=$&#123;file%.c&#125;
gcc -o $target $file
echo $target
fi
if [ -d $file ]
then
echo $file is mu lu
fi
done
</code></pre>
<p>(2)Makefile编译指定目录<br>Makefile可以输入参数，直接在make命令的后面加上参数，如:</p>
<pre><code>make BUILD_DIR=./foldername/
</code></pre>
<p>传入的变量将会覆盖相应Makefile中的<code>BUILD_DIR</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/" class="post-title-link" itemprop="url">Linux Shell笔记：文本编辑利器sed+awk+grep</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 14:50:22" itemprop="dateCreated datePublished" datetime="2020-05-30T14:50:22+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:00:29" itemprop="dateModified" datetime="2022-12-05T15:00:29+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shell增删改查概述"><a href="#shell增删改查概述" class="headerlink" title="shell增删改查概述"></a>shell增删改查概述</h1><p>Linux Shell环境对文本增删改查，可以通过sed，awk和grep命令完成。</p>
<ul>
<li>sed: 支持特定模式匹配的增加、插入、删除、替换、提取等操作</li>
<li>awk: 支持特定模式匹配的过滤查找，如提取某行列的字符串</li>
<li>grep: 支持包含特定字符串的结果提取，可配合find和awk实现过滤查找</li>
</ul>
<p>这几种命令都支持流输入和文本输入，支持管道传递参数，也可以命令行传参。对于多个步骤的处理，可以几个命令串行使用。</p>
<h1 id="shell的输入参数概述"><a href="#shell的输入参数概述" class="headerlink" title="shell的输入参数概述"></a>shell的输入参数概述</h1><p>Shell的命令，如<code>cat, echo, sed, awk, grep</code>, 管道命令<code>|</code>等，都要有输入参数，即待处理的数据。<br>输入参数有两种类型：</p>
<ul>
<li>标准输入：本质是stdin文件，即读取该文件的内容作为命令的输入参数，该文件内容可由其他命令的输出，或者用户输入来产生</li>
<li>命令行输入：直接接受用户在命令行输入的字符串，一次性使用,不存储在stdin</li>
</ul>
<p>支持标准输入作为参数的命令：<code>cat, sed, awk, grep, |</code> 等<br>只支持命令行输入字符串的命令：<code>echo, ls</code>等<br>标准输入示例：</p>
<pre><code>cat /etc/passwd | grep root
</code></pre>
<p>上面的代码使用了管道命令<code>|</code>，管道命令的作用是将左侧命令<code>cat /etc/passwd</code>的标准输出转换为标准输入，提供给右侧命令<code>grep root</code>作为参数。<br>以上命令也可以写成命令行输入形式：</p>
<pre><code>grep root /etc/passwd
</code></pre>
<p>不支持标准输入的示例：</p>
<pre><code>echo &quot;hello world&quot; | echo
</code></pre>
<p>输出为空，管道右侧的echo不接受管道传来的标准输入作为参数。<br>xargs的作用：将标准输入转为命令行参数</p>
<pre><code>echo &quot;hello world&quot; | xargs echo
</code></pre>
<p>输出“hello world”，xargs和管道配合使用，能使管道也支持非标准输入命令。<br>xargs支持一些选项做进一步细化处理，如-p(打印), -d(分割) 等。</p>
<h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><h2 id="sed命令概述"><a href="#sed命令概述" class="headerlink" title="sed命令概述"></a>sed命令概述</h2><p>sed支持文本编辑，实现增、删、改的功能。<br>sed命令格式：</p>
<pre><code>sed [options] &#39;command&#39; filename
</code></pre>
<p>sed的输入参数可以用命令行，管道和xargs传入：</p>
<pre><code>//命令行传入文件名参数
sed [options] &#39;command&#39; filename 
//管道传入文件名参数
cat filename | sed [options] &#39;command&#39;
//xargs传入文件名参数
cat filename | xargs sed [options] &#39;command&#39;
</code></pre>
<p>sed对文件的编辑在缓冲区，不直接修改文本。要直接修改文本有以下方法：</p>
<ul>
<li>重定向覆盖文本， <code>sed - x &#39;XXX&#39; file.txt &gt; file.txt</code></li>
<li>特定的sed命令支持直接修改文本，如<code>sed -i &#39;XXX&#39; file.txt</code></li>
</ul>
<p>sed的常用选项：</p>
<pre><code>-n ：关闭默认输出,只显示匹配的行
-i ：直接修改读取的文件内容，而不是输出到终端。
-e ：直接在命令列模式上进行sed的动作编辑；
-f ：直接将sed的动作写在一个文件内，-f filename 则可以运行filename内的sed动作；
-r ：启用扩展的正则表达式
</code></pre>
<p>sed的常用命令：</p>
<pre><code>a ：新增行，在指定行的后面附加一行，[address]a\新文本内容
i ：插入行，在指定行的前面插入一行，[address]i\新文本内容
s ：替换特定模式匹配的字符串, [address]s/pattern/replacement/flags
c ：将指定行中的所有内容，替换成该选项后面的字符串, [address]c\用于替换的新文本
d ：删除行，[address]d
p ：打印， 通常与参数 -n 一起用，[address]p
w : 将文本中指定行的内容写入文件, [address]w filename
</code></pre>
<h2 id="sed命令详解"><a href="#sed命令详解" class="headerlink" title="sed命令详解"></a>sed命令详解</h2><p>本节从sed文本操作的“增删改查”举例说明其具体命令用法</p>
<h3 id="新增和插入：a和i"><a href="#新增和插入：a和i" class="headerlink" title="新增和插入：a和i"></a>新增和插入：a和i</h3><p>sed的命令a和i都能实现新增行，其区别在于：</p>
<ul>
<li>a ：append, 指定行后面新增一行</li>
<li>i : insert, 表示在指定行前面插入一行</li>
</ul>
<p>注意区分i命令和i选项<br>a和i命令的基本格式完全相同：</p>
<pre><code>[address]a（或 i）\新文本内容
</code></pre>
<p>将一个新行插入到数据流第三行前：</p>
<pre><code>sed &#39;3i\This is an inserted line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is an inserted line.
This is line number 3.
This is line number 4.
</code></pre>
<p>将一个新行附加到数据流中第三行后:</p>
<pre><code>sed &#39;3a\This is an appended line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is line number 3.
This is an appended line.
This is line number 4.
</code></pre>
<p>将一个多行数据添加到数据流中，只需对要行末尾添加反斜线即可，类似C语言的代码换行</p>
<pre><code>sed &#39;1i\
This is one line of new text.\
This is another line of new text.&#39; data6.txt

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
</code></pre>
<h3 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h3><ul>
<li>d: delete, 删除行</li>
</ul>
<p>格式：</p>
<pre><code>[address]d
</code></pre>
<p>删除第三行：</p>
<pre><code>[root@localhost ~]# cat data6.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
[root@localhost ~]# sed &#39;3d&#39; data6.txt
This is line number 1.
This is line number 2.
This is line number 4.
</code></pre>
<p>删除二、三行：</p>
<pre><code>sed &#39;2,3d&#39; data6.txt
This is line number 1.
This is line number 4.
</code></pre>
<p>删除第三行开始的后续所有行：</p>
<pre><code>[root@localhost ~]# sed &#39;3,$d&#39; data6.txt
This is line number 1.
This is line number 2.
</code></pre>
<p>注意：sed d 命令并不会修改原始文件，这里被删除的行只是从 sed 的缓冲区中消失了，原始文件没做任何改变，若要修改源文件，可重定向sed的输出到源文件，覆盖原内容使修改生效。</p>
<h3 id="匹配定位：-x2F-pattern-x2F"><a href="#匹配定位：-x2F-pattern-x2F" class="headerlink" title="匹配定位：&#x2F;pattern&#x2F;"></a>匹配定位：&#x2F;pattern&#x2F;</h3><p>sed的增删操作，可以针对包含匹配字符串的行进行操作，其原理是活用[address], 支持匹配字符串的定位，以插入命令’i’为例，匹配格式如下：</p>
<pre><code>sed [option] &#39;/匹配字符串/i \插入字符串&#39;
[option] 通常为 -i, 修改直接在源文件生效
</code></pre>
<p>原文件：</p>
<pre><code>cat testfile 
hello
</code></pre>
<p>在包含”hello”的一行的上一行，插入”upline”:</p>
<pre><code>sed -i &#39;/hello/i\upline&#39; testfile
</code></pre>
<p>“hello”下一行插入”upline”:</p>
<pre><code>sed -i &#39;/hello/a\down&#39; testfile
</code></pre>
<p>修改后的文件：</p>
<pre><code>cat testfile 
up
hello
down
</code></pre>
<p>删除匹配到”hello”的行：</p>
<pre><code>sed -i &#39;/hello/d&#39; testfile
</code></pre>
<p>如果匹配字符串有“&#x2F;”，为了和sed命令的分隔符“&#x2F;”，使用“\”转义。<br>例如删除匹配某个路径字符串的行：</p>
<pre><code>匹配&quot;\etc\install.sh&quot;
set -i &#39;/\/etc\/install.sh/d&#39; test.txt
</code></pre>
<p>sed 命令包含一些预定义特殊符号，代表行尾，行首等。<br>删除以A开头的行：</p>
<pre><code>sed -i &#39;/^A.*/d&#39; test.txt
^A表示开头是A, .*表示后跟任意字符串
</code></pre>
<p>在行尾追加一行内容:</p>
<pre><code>sed -i &#39;$a\added-content&#39; test.txt
$表示定位到行尾，a是追加命令，added-content是追加内容
</code></pre>
<h3 id="替换修改-s"><a href="#替换修改-s" class="headerlink" title="替换修改: s"></a>替换修改: s</h3><p>s替换命令内部格式为：</p>
<pre><code>[address]s/pattern/replacement/flags
</code></pre>
<ul>
<li>address 指定要操作的具体行</li>
<li>pattern 指定需要替换的内容</li>
<li>replacement 指定替换的新内容</li>
<li>flags 指定特殊功能</li>
</ul>
<p>常用的flags:</p>
<ul>
<li>n    1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换</li>
<li>g    对数据中所有匹配到的内容进行替换，否则只会在第一次匹配成功时做替换操作</li>
<li>p    会打印与替换命令中指定的模式匹配的行。此标记通常与 -n    选项一起使用</li>
<li>\    转义（转义替换部分包含：&amp;、\ 等）。</li>
</ul>
<p>替换每行第二个匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/2&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the trial script
This is second test of the trial script
</code></pre>
<p>只替换第二行的匹配字符串：</p>
<pre><code>sed &#39;2s/test/trial/&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the test script
This is second test of the trial script
</code></pre>
<p>全局替换所有匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/g&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first trial of the trial script
This is second trial of the trial script
</code></pre>
<h3 id="提取：p"><a href="#提取：p" class="headerlink" title="提取：p"></a>提取：p</h3><p>sed p命令配合字符串匹配，可以输出包含指定字符串的行内容。</p>
<pre><code>sed -n &#39;/string/p&#39; filename
提取filename文件中,所有包含string的行的内容，并打印到标准输出
-n是只打印匹配命中的内容
</code></pre>
<p>sed p和grep都能提取内容，其区别在于：</p>
<ul>
<li><code>sed &#39;/string/p&#39;</code>是提取指定文件的行内容，重点在内容提取</li>
<li><code>grep &quot;string&quot; path</code>是输出包含指定内容的所有文件路径，重点在查找文件位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452182.png" alt="image-20221205145238133"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452191.png" alt="image-20221205145248149"></p>
<h2 id="sed进阶与实战"><a href="#sed进阶与实战" class="headerlink" title="sed进阶与实战"></a>sed进阶与实战</h2><h3 id="多文件批量追加和删除"><a href="#多文件批量追加和删除" class="headerlink" title="多文件批量追加和删除"></a>多文件批量追加和删除</h3><p>背景介绍：<br>底层固件代码有一些功能由宏定义控制，不同功能需要不同的宏定义组合，因此有不同的宏定义文件，命名为.def后缀。批量编译不同版本，编译脚本依次提取def文件夹内的.def文件和源代码一起编译。单个def内容如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453765.png" alt="image-20221205145321718"></p>
<p>每一个宏都有多个取值，因此组合起来，需要生成一堆.def文件，批量编译才能覆盖各自功能。<br>每新增一个宏，都要修改所有.def文件，如果这个宏有两个取值，.def文件数量将翻倍。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453942.png" alt="image-20221205145327892"></p>
<p>人工修改过于低效，使用sed可解决此问题。</p>
<p>查找指定文件，并批量追加一行内容：</p>
<pre><code>find . -name &#39;*.def*&#39; | xargs sed -i &#39;$a\added-content&#39;
</code></pre>
<p>各命令含义：</p>
<pre><code>find [path] -name &quot;*.def&quot;
查找path路径下，以.def结尾的所有文件，结果存储在stdout
|
管道，将查找结果转存到标准输入stdin
xargs
查找结果有很多个，用xargs转成命令行输入，sed才能批量处理
sed -i &#39;$a\added-content&#39;
    -i 直接修改文件，&#39;$a\added-content&#39; 最后一行追加added-content
</code></pre>
<p>查找指定文件，并批量删除匹配某字符串的行：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/deleteString/d&quot;
</code></pre>
<p>查找指定文件，并批量替换匹配某字符串：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/oldString/newString/&quot;
</code></pre>
<p>在实际shell脚本中，通常由用户输入变量，<code>$1, $2, $@</code> 解析变量。a、i、d和s能否在命令中使用双引号解析变量，实现动态编辑？<br>实验如下：</p>
<pre><code>ARGS=&quot;AA BB&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$a\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$i\$&#123;ARGS&#125;&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/$&#123;ARGS&#125;/d&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/aabb/$ARGS/&quot;
</code></pre>
<ul>
<li>i 和 a 命令不能解析变量，实际追加的就是是${ARGS}</li>
<li>d命令可以解析变量，实际删除的是有”AA BB”的行</li>
<li>s命令可以解析变量，实际替换后的结果是”AA BB”</li>
</ul>
<p>结论：将命令中的单引号改成双引号，理论上可以解析$包含的变量，实际上有的命令支持，有的命令不支持。</p>
<h3 id="提取文件中的关键内容"><a href="#提取文件中的关键内容" class="headerlink" title="提取文件中的关键内容"></a>提取文件中的关键内容</h3><p>背景介绍：<br>底层固件需要将代码段、数据段等关键信息存储在固件头部，编译过程中用编译器的size命令可以获取这些信息，并存储到文本，但是固件头部需要按自己的格式存储起始地址和大小信息，因此需要用sed提取并编辑该文本。</p>
<p>原文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453983.png" alt="image-20221205145348933"></p>
<p>提取后文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453414.png"></p>
<p>sed命令：</p>
<pre><code>sed -n &#39;/string/p&#39; oldFile | awk &#39;&#123;print $3&#125;&#39; &gt;&gt; newFile
提取oldFile内包含string的行，并用awk提取第三列，再写入newFile
</code></pre>
<p>该命令在Makefile实现，需要根据Makefile和shell特性做修改：</p>
<ul>
<li>@：编译过程隐藏命令输出，类似于后台执行</li>
<li>$(shell xxxx): Makefile执行shell命令</li>
<li>$$: Makefile不能直接用shell的“$”解析变量，用“$$”</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051454928.png" alt="image-20221205145409877"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">NodeJs笔记：使用pm2部署项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 14:25:24" itemprop="dateCreated datePublished" datetime="2020-05-20T14:25:24+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 14:29:50" itemprop="dateModified" datetime="2022-12-06T14:29:50+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJs/" itemprop="url" rel="index"><span itemprop="name">NodeJs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>nodejs服务可以用<code>nohup node xxx.js &amp;</code>后台启动，但是实际使用发现不太稳定，使用专门的node后台服务管理工具：pm2解决此问题</p>
<h1 id="pm2特性"><a href="#pm2特性" class="headerlink" title="pm2特性"></a>pm2特性</h1><p>1、内建负载均衡（使用Node cluster 集群模块）<br>2、后台运行<br>3、0秒停机重载<br>4、具有Ubuntu和CentOS 的启动脚本<br>5、停止不稳定的进程（避免无限循环）<br>6、控制台检测<br>7、提供 HTTP API<br>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p>
<h1 id="pm2安装"><a href="#pm2安装" class="headerlink" title="pm2安装"></a>pm2安装</h1><pre><code>npm install -g pm2
</code></pre>
<h1 id="pm2用法"><a href="#pm2用法" class="headerlink" title="pm2用法"></a>pm2用法</h1><pre><code>pm2 start app.js        //启动进程
pm2 start app.js -i 4   // 后台运行pm2，启动4个app.js
pm2 start app.js -i max //启动，使用所有CPU核心
pm2 start app.js --name my-api // 命名进程
pm2 list               // 显示所有进程状态
pm2 monit              // 监视所有进程
pm2 logs               //  显示所有进程日志
pm2 stop all           // 停止所有进程
pm2 restart all        // 重启所有进程
pm2 reload all         // 0秒停机重载进程 (用于 NETWORKED 进程)
pm2 stop 0             // 停止指定的进程
pm2 restart 0          // 重启指定的进程
pm2 startup            // 产生 init 脚本 保持进程活着
pm2 web                // 运行健壮的 computer API endpoint 
pm2 delete 0           // 杀死指定的进程
pm2 delete all         // 杀死全部进程
</code></pre>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>部署Github项目NodeMail，每天给指定邮箱发邮件。</p>
<p>后台启动main.js并监测状态：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427417.png" alt="image-20221206142729375"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427110.png" alt="image-20221206142743066"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427682.png" alt="image-20221206142752627"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061428280.png" alt="image-20221206142800236"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/" class="post-title-link" itemprop="url">Linux Shell笔记：判断语句if-then-else-fi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-05 14:46:30" itemprop="dateCreated datePublished" datetime="2020-05-05T14:46:30+08:00">2020-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 15:00:22" itemprop="dateModified" datetime="2022-12-05T15:00:22+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>shell中if-then-else-fi判断语句如下：</p>
<pre><code>a=&quot;abc&quot;

if [ $a = &quot;abc&quot; ]
then
   echo &quot;$a = $b&quot;
else
   echo &quot;$a != $b&quot;
fi
</code></pre>
<p>注意以下几点：</p>
<ul>
<li>shell中的等号：<code>=</code>可用于赋值，也可以用于判断；<code>==</code>只用于判断，更规范</li>
<li>shell中的if语句各符号间都要空格分隔：<code>if</code>和<code>[ ]</code>之间要空格；<code>[ ]</code>和<code>“ ”</code>之间要空格； <code>&quot;</code>和<code>=</code>之间要空格。否则if语句中的符号会解析失败。</li>
<li>shell变量没有数据类型的区分，把任何存储在变量中的值，皆视为“字符串”</li>
<li>对于变量可能为空的情况，需要用双括号<code>[[ $a = &quot;abc&quot; ]]</code></li>
<li>if-then可以写在同一行，用;分隔两个语句：<code>if [ $a = &quot;abc&quot; ];then</code></li>
</ul>
<h1 id="不同类型的判断语句"><a href="#不同类型的判断语句" class="headerlink" title="不同类型的判断语句"></a>不同类型的判断语句</h1><h2 id="关系运算符判断"><a href="#关系运算符判断" class="headerlink" title="关系运算符判断"></a>关系运算符判断</h2><p>-eq    检测两个数是否相等，相等返回 true。    [ $a -eq $b ] 返回 false。</p>
<p>-ne    检测两个数是否不相等，不相等返回 true。    [ $a -ne $b ] 返回 true。</p>
<p>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ] 返回 false。</p>
<p>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ] 返回 true。</p>
<p>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。    [ $a -ge $b ] 返回 false。</p>
<p>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。    [ $a -le $b ] 返回 true。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>
<h2 id="布尔和逻辑运算符判断"><a href="#布尔和逻辑运算符判断" class="headerlink" title="布尔和逻辑运算符判断"></a>布尔和逻辑运算符判断</h2><p>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ] 返回 true。</p>
<p>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ] 返回 true。</p>
<p>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a == $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>
<p>&amp;&amp;    逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</p>
<p>||    逻辑的 OR    [[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<pre><code>#!/bin/bash

a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>
<h2 id="字符串运算符判断"><a href="#字符串运算符判断" class="headerlink" title="字符串运算符判断"></a>字符串运算符判断</h2><p>&#x3D;    检测两个字符串是否相等，相等返回 true。    [ $a &#x3D; $b ] 返回 false。</p>
<p>!&#x3D;    检测两个字符串是否相等，不相等返回 true。    [ $a !&#x3D; $b ] 返回 true。</p>
<p>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。  </p>
<p>-n    检测字符串长度是否不为 0，不为 0 返回 true。    [ -n “$a” ] 返回 true。</p>
<p><code>$</code> 检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。</p>
<pre><code>#!/bin/bash

a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a != $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a = $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n &quot;$a&quot; ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>
<h2 id="文件检查运算符判断"><a href="#文件检查运算符判断" class="headerlink" title="文件检查运算符判断"></a>文件检查运算符判断</h2><p>b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ] 返回 false。</p>
<p>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -c $file ] 返回 false。</p>
<p>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ] 返回 false。</p>
<p>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。</p>
<p>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] 返回 false。</p>
<p>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。</p>
<p>-p file    检测文件是否是有名管道，如果是，则返回 true。    [ -p $file ] 返回 false。</p>
<p>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。</p>
<p>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。</p>
<p>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。</p>
<p>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。</p>
<p>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。</p>
<p>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。</p>
<p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。</p>
<pre><code>#!/bin/bash

file=&quot;/root/test.sh&quot;

if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>
<h1 id="判断语句报错：”unary-operator-expected”"><a href="#判断语句报错：”unary-operator-expected”" class="headerlink" title="判断语句报错：”unary operator expected”"></a>判断语句报错：”unary operator expected”</h1><p>在匹配字符串相等时，用了类似这样的语句：</p>
<pre><code>if [ $STATUS == &quot;OK&quot; ]; then     
echo &quot;OK&quot;
fi
</code></pre>
<p>在运行时出现了 <code>[: =: unary operator expected</code> 的错误</p>
<pre><code>if [[ $STATUS == &quot;OK&quot; ]]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>究其原因，是因为如果变量STATUS值为空，那么就成了 [ &#x3D; “OK”] ，显然 [ 和 “OK” 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。<br>或者用下面的方法也能避免这种错误：</p>
<pre><code>if [ &quot;$STATUS&quot;x == &quot;OK&quot;x ]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>当然，x也可以是其他字符。shell中有没有双引号在很多情况下是一致的,因此x可以不加引号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">Gitlab笔记：CentOS7部署Gitlab服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 14:39:02" itemprop="dateCreated datePublished" datetime="2020-04-30T14:39:02+08:00">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 14:52:58" itemprop="dateModified" datetime="2022-12-06T14:52:58+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>阿里云ECS, CentOS7, RAM 4G</p>
<h1 id="安装Gitlab"><a href="#安装Gitlab" class="headerlink" title="安装Gitlab"></a>安装Gitlab</h1><p>1.安装ssh并配置</p>
<pre><code>#安装
sudo yum install -y curl policycoreutils-python openssh-server
#配置开机启动
sudo systemctl enable sshd
#启动服务
sudo systemctl start sshd
</code></pre>
<p>2.配置防火墙</p>
<pre><code>#启动防火墙
service firewalld start
#添加http服务到firewalld,pemmanent表示永久生效
sudo firewall-cmd --permanent --add-service=http
#重启防火墙
sudo systemctl reload firewalld
</code></pre>
<p>3.安装gitlab</p>
<pre><code>#下载安装脚本
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash
#安装
yum install -y gitlab-ee
</code></pre>
<p>4.配置gitlab</p>
<pre><code>#gitlab配置文件
vim /etc/gitlab/gitlab.rb
#修改以下内容为主机ip和未使用的端口，否则使用默认端口8080
external_url &#39;http://47.100.221.149:9030&#39;
</code></pre>
<p>5.配置生效并重启gitlab</p>
<pre><code>#配置生效，改了配置需要运行
gitlab-ctl reconfigure
#重启服务，没改配置直接重启
gitlab-ctl restart
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061444445.png" alt="image-20221206144455394"><br>似乎服务都正常启动了，实际上可能有各种问题，参考问题记录</p>
<h1 id="问题Debug记录"><a href="#问题Debug记录" class="headerlink" title="问题Debug记录"></a>问题Debug记录</h1><p>按以上步骤配置好后，访问主机ip:端口，直接弹出502服务端错误<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061445877.png" alt="image-20221206144542817"></p>
<h2 id="配置文件权限问题"><a href="#配置文件权限问题" class="headerlink" title="配置文件权限问题?"></a>配置文件权限问题?</h2><p>配置文件生效命令<code>gitlab-ctl reconfigure</code>做了以下事情：</p>
<ul>
<li>配置设置写到gitlab服务直接调用的文件</li>
</ul>
<p>实际生效的配置文件：</p>
<pre><code>vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446719.png" alt="image-20221206144606669"><br>可见配置被自动拷贝到此处，gitlab相关服务读取的是这里的配置项</p>
<ul>
<li>生成服务相关临时文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446110.png" alt="image-20221206144619066"></p>
<p>原因：gitlab服务的配置文件在reconfigure时生成于&#x2F;var&#x2F;log&#x2F;gitlab，这个文件目录默认权限不够，有些子服务不能正常运行。</p>
<p>解决方法：</p>
<pre><code>chmod -R 777 /var/log/gitlab
</code></pre>
<p>restart服务，网页即可正常访问gitlab，如果恢复该目录755权限，重启服务会502</p>
<p>每次重新配置，<code>gitlab-ctl reconfigure</code>似乎会删除该目录再重新写入<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446151.png" alt="image-20221206144636079"></p>
<p>因此每次gitlab-ctl reconfigure之后都要<code>chmod 777</code>改此目录权限</p>
<h2 id="还有502问题"><a href="#还有502问题" class="headerlink" title="还有502问题?"></a>还有502问题?</h2><h3 id="检查阿里云端口"><a href="#检查阿里云端口" class="headerlink" title="检查阿里云端口"></a>检查阿里云端口</h3><p>首先确保主机ip是公网能访问的，不是内网ip<br>其次看端口是否禁用。在阿里云ECS的安全组策略中查看端口是否允许TCP输入输出<br>我把所有端口（1~65535）全部打开了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446454.png" alt="image-20221206144656411"></p>
<h3 id="检查前向端口冲突"><a href="#检查前向端口冲突" class="headerlink" title="检查前向端口冲突"></a>检查前向端口冲突</h3><p>gitlab配置文件的external_url就包含前向端口</p>
<pre><code>netstat -nlp | grep 9030 (我的gitlab前向端口)
</code></pre>
<p>显示的是nginx服务端口，因为gitlab默认被nginx反向代理了，说明gitlab的代理服务确实占用9030。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449545.png" alt="image-20221206144927508"></p>
<h3 id="检查子服务的端口"><a href="#检查子服务的端口" class="headerlink" title="检查子服务的端口"></a>检查子服务的端口</h3><p>注意gitlab不只有一个服务，默认配置只设置了前向端口（nginx代理端口），而子服务都没配置端口，默认用了8080，如果有其他服务已经占用8080，可能子服务起不来<br>例如unicorn子服务：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449220.png" alt="image-20221206144946178"></p>
<p>查看子服务状态</p>
<pre><code>gitlab-ctl status
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449573.png" alt="image-20221206144958510"></p>
<p>如果本地已有8080的服务，最好杀掉或换其他端口，否则要手动配置gitlab子服务端口</p>
<pre><code>unicorn[&#39;port&#39;] = 9032 （随便一个未使用端口）
gitlab_workhorse[&#39;auth_backend&#39;] = &quot;http://localhost:9032&quot;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450285.png" alt="image-20221206145014236"></p>
<h3 id="检查内存资源不足"><a href="#检查内存资源不足" class="headerlink" title="检查内存资源不足"></a>检查内存资源不足</h3><p>阿里云2G以下RAM可能会有因内存不足，导致服务不能正常启动。<br>使用swap交换分区，避免内存不足的可能性。swap分区可以把部分内存分页存储到磁盘，变相“扩大”内存</p>
<pre><code>#查看现有swap分区，若未分配大小为0
cat /proc/swaps
#创建swap文件，大小4G，挂载到/mnt。交换分区可以使用真正的分区，或者以文件形式的分区
dd if=/dev/zero of=/mnt/swap bs=512 count=8388616
#使之成为swap分区
mkswap /mnt/swap
#修改swap分区配置
cat /proc/sys/vm/swappiness
sysctl -w vm.swappiness=60
#swap分区配置永久生效
vim /etc/sysctl.conf
修改vm.swappiness=60
#启动分区
swapon /mnt/swap
echo “/mnt/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab
#停用分区
swapoff /mnt/swap
swapoff -a &gt; /dev/null
</code></pre>
<p>启用分区后运行gitlab，发现已经有一部分数据转移到了swap文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450437.png" alt="image-20221206145023389"></p>
<h1 id="ssh访问配置"><a href="#ssh访问配置" class="headerlink" title="ssh访问配置"></a>ssh访问配置</h1><p>通过ssh上传下载，需要建立ssh key</p>
<pre><code>ssh-keygen   #一路回车
</code></pre>
<p>若创建成功，查看生成的公钥：</p>
<pre><code>cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yXXXXXXXX
</code></pre>
<p>添加公钥至gitlab</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450049.png" alt="image-20221206145031977"></p>
<h1 id="初始化git项目"><a href="#初始化git项目" class="headerlink" title="初始化git项目"></a>初始化git项目</h1><p>配置git全局用户名，邮箱</p>
<pre><code>git config --global user.name &quot;YOUR NAME&quot;
git config --global user.email &quot;YOUR EMAIL@xxx.com&quot;
</code></pre>
<p>初始化git仓库<br>可以通过xftp上传项目文件夹到gitlab服务器，再到目录内初始化.git仓库。</p>
<pre><code>cd project_folder (项目文件夹)
git init
git remote add origin git@YOUR_IP:YOUR_NAME/project_folder.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
</code></pre>
<p>这样在网页上可看到gitlab有首次commit的文件，后续也可以顺利提交和下载。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">浅谈C的宏函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-16 15:07:37" itemprop="dateCreated datePublished" datetime="2020-04-16T15:07:37+08:00">2020-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 15:18:54" itemprop="dateModified" datetime="2022-12-06T15:18:54+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-连接操作符"><a href="#1-连接操作符" class="headerlink" title="1. 连接操作符:##"></a>1. 连接操作符:##</h1><pre><code>#define Conn(x,y) x##y
</code></pre>
<p><code>##</code> 表示连接 , <code>x##y</code> 表示x连接y</p>
<p>示例：</p>
<pre><code>int n = Conn(123,456);
     ==&gt; int n=123456;
char* str = Conn(&quot;asdf&quot;, &quot;adf&quot;);
     ==&gt; char* str = &quot;asdfadf&quot;;
</code></pre>
<p><code>##</code> 的左右符号必须能够组成一个有意义的符号，否则预处理器会报错</p>
<h1 id="2-字符串化和字符化"><a href="#2-字符串化和字符化" class="headerlink" title="2.字符串化和字符化: #, #@"></a>2.字符串化和字符化: #, #@</h1><p>(1) # 把任意类型的宏入参转化成字符串：</p>
<pre><code>#define ToString(x) #x
</code></pre>
<p>符号 # 表示字符串化操作符（stringification）。<br>其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。<br>其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</p>
<p>示例：</p>
<pre><code> char* str = ToString(123132);
 ==&gt; char* str=&quot;123132&quot;;
</code></pre>
<p>如果要对展开后的宏参数进行字符串化，则需要使用两层宏。</p>
<pre><code>#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
     ==&gt; &quot;foo&quot;
xstr (foo)
     ==&gt; xstr (4)
     ==&gt; str (4)
     ==&gt; &quot;4&quot;
</code></pre>
<p>(2) #@ 把任意类型的宏入参转化成单字符：</p>
<pre><code>#define ToChar(x) #@x
</code></pre>
<p>示例：</p>
<pre><code>char a = ToChar(1);
     ==&gt; char a=&#39;1&#39;
</code></pre>
<h1 id="3-不定参数宏-VA-ARGS"><a href="#3-不定参数宏-VA-ARGS" class="headerlink" title="3. 不定参数宏: __VA_ARGS__"></a>3. 不定参数宏: <code>__VA_ARGS__</code></h1><p><code>__VA_ARGS__</code>宏用来接受不定数量的参数。例如：</p>
<pre><code>#define eprintf(...) fprintf (stderr, __VA_ARGS__)

eprintf (&quot;%s:%d: &quot;, input_file, lineno)
==&gt;  fprintf (stderr, &quot;%s:%d: &quot;, input_file, lineno)
</code></pre>
<p>当<code>__VA_ARGS__</code>宏前面加 <code>##</code> 时，可以省略参数输入。<br>例如：</p>
<pre><code>#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

eprintf (&quot;success!\n&quot;)
==&gt; fprintf(stderr, &quot;success!\n&quot;);
</code></pre>
<h1 id="4-宏函数定义-do-while-0-与换行"><a href="#4-宏函数定义-do-while-0-与换行" class="headerlink" title="4. 宏函数定义: do-while(0)与换行"></a>4. 宏函数定义: do-while(0)与换行</h1><p>(1) 用 do{}while(0) 定义宏函数</p>
<pre><code>#define foo() do&#123;...&#125;while(0)
</code></pre>
<p>宏函数可能在任意地方被调用，如果在if-else语句中，为了确保宏函数作为整体单元被编译器替换后不产生歧义，一般用do-while(0)包起来定义<br>这种定义有点像其他语言的“闭包函数”，纯粹是C语言中为了避免语法歧义的可靠性定义。</p>
<p>(2) 用显式换行符</p>
<p>宏函数定义不能直接回车换行，需要在回车换行前，用\（反斜线）表示下一行继续此宏的定义<br>预处理器在编译之前会自动将\与换行回车去掉。</p>
<p>例如：</p>
<pre><code>#define PRINT_INT(a)    \
do&#123;                     \
    printf(&quot;%d \n&quot;, a); \
&#125;while(0)
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">浅谈C的函数指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 12:30:00" itemprop="dateCreated datePublished" datetime="2020-04-01T12:30:00+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 15:18:49" itemprop="dateModified" datetime="2022-12-06T15:18:49+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-函数指针基本概念"><a href="#1-函数指针基本概念" class="headerlink" title="1. 函数指针基本概念"></a>1. 函数指针基本概念</h2><p>C语言调用函数的本质是什么？</p>
<ol>
<li>CPU PC指针(program counter)跳转到函数的入口地址，传入参数，传入返回位置</li>
<li>在函数栈内生成临时变量并执行函数内容指令，执行完毕后返回参数</li>
<li>CPU返回原调用处执行</li>
</ol>
<p>这里，函数的入口地址实际上就存储在函数名中，也就是说，C代码中的函数名就是函数的入口地址。<br>既然是地址，就可以用来初始化一个指针，使指针指向该地址。<br>函数指针，就是存放函数首地址的指针。</p>
<h3 id="1-2-函数指针变量"><a href="#1-2-函数指针变量" class="headerlink" title="1.2 函数指针变量"></a>1.2 函数指针变量</h3><p>首先声明普通函数是如下格式：<br><code>void Func(int);</code><br>定义一个同类型函数的函数指针变量，只需要用<code>*p</code>表示函数名即可：<br><code>void (*p)(int);</code><br>注意，上面是定义了函数指针变量，而不是声明函数指针类型。</p>
<p>函数指针变量的定义，和普通变量格式不一样。</p>
<ul>
<li>普通变量： &lt;类型&gt; &lt;变量名&gt;</li>
<li>函数指针：&lt;函数类型 变量名&gt;，按函数声明的格式定义，变量是包含在类型内部</li>
</ul>
<p>那么此函数指针的类型是什么：<br><code>void (*)(int);</code></p>
<p>怎么使用此函数指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Func(int x) // 声明一个函数*/</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line">void (*p)(int); // 定义一个函数指针*/</span><br><span class="line">p = Func; // 将Func函数的首地址赋给函数指针变量p*/</span><br><span class="line">(*p)(100);  // 通过函数指针调用Func函数</span><br></pre></td></tr></table></figure>

<h3 id="1-3-函数指针类型"><a href="#1-3-函数指针类型" class="headerlink" title="1.3 函数指针类型"></a>1.3 函数指针类型</h3><p>typedef可以定义某种类型的别名，例如将unsigned char定义为u8<br><code>typedef unsigned char u8;</code><br>可见其格式是：typedef &lt;原类型&gt; &lt;别名类型&gt;</p>
<p>那么如何定义函数指针类型：<br>只需要在函数指针声明的格式前加typedef, p就定义为函数指针类型而不是变量:<br><code>typedef void (*p)(int);</code></p>
<p>这里定义了<code>void (*)(int)</code>类型的函数指针类型，其别名为p</p>
<p>怎么使用此函数指针类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义类型</span><br><span class="line">typedef void (*pFuncType)(int); </span><br><span class="line">//定义变量  </span><br><span class="line">pFuncType p;   </span><br><span class="line"></span><br><span class="line">void Func(int x)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%d&quot;,x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main()   </span><br><span class="line">&#123;   </span><br><span class="line">    p = Func; //初始化变量   </span><br><span class="line">    (*p)(100);   //使用变量</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-函数指针的应用"><a href="#2-函数指针的应用" class="headerlink" title="2. 函数指针的应用"></a>2. 函数指针的应用</h2><h3 id="2-1-Linux驱动软件设计的分层"><a href="#2-1-Linux驱动软件设计的分层" class="headerlink" title="2.1 Linux驱动软件设计的分层"></a>2.1 Linux驱动软件设计的分层</h3><p>C++中有多态的概念，父类定义某种函数类型，子类实现具体的函数内容，之后父类对象就可以调用子类的实现内容。<br>这样实现“父类定义格式，子类实现细节”的软件分层设计。</p>
<p>Linux驱动中也大量使用这种分层设计，C使用结构体和函数指针，分别对应C++的类和方法。<br>例如某驱动模块，顶层框架定义open, read, write, 而底层驱动根据具体硬件，实现xxx_open, xxx_read, xxx_write，然后按结构体成员赋值实现上下层联通：</p>
<p>以s3c的SDHCI驱动为例：<br>sdhci_ops即父类框架结构体，sdhci_s3c_ops为s3c芯片的具体实现结构体。<br><code>.set_clock = sdhci_s3c_set_clock</code>就实现了父类的set_clock方法被子类sdhci_s3c_set_clock实现的效果。<br>其本质是函数指针的赋值，父类和子类的函数名都指向同一个函数地址，所以父类可以通过调用set_clock来实现调用sdhci_s3c_set_clock的效果。<br>这样，父类设计者根本不关心底层用什么函数名实现set_clock的功能，只需要调用set_clock这个函数名即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct sdhci_ops sdhci_s3c_ops = &#123;</span><br><span class="line">	.get_max_clock		= sdhci_s3c_get_max_clk,</span><br><span class="line">	.set_clock		= sdhci_s3c_set_clock,</span><br><span class="line">	.get_min_clock		= sdhci_s3c_get_min_clock,</span><br><span class="line">	.set_bus_width		= sdhci_set_bus_width,</span><br><span class="line">	.reset			= sdhci_reset,</span><br><span class="line">	.set_uhs_signaling	= sdhci_set_uhs_signaling,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数指针实现指令跳转"><a href="#2-2-函数指针实现指令跳转" class="headerlink" title="2.2 函数指针实现指令跳转"></a>2.2 函数指针实现指令跳转</h3><p>调用一个函数，其内部就包含跳转操作(jump指令)<br>那么，如何用C语言实现跳转到某个绝对地址去执行？具体场景：<br>在Bootloader过程中，加载完kernel到RAM后，要跳转到kernel首地址开始执行，如何实现？</p>
<p>方案一：C嵌入汇编<br>以下是基于SPARC CPU的汇编，跳转到0x40000000, 即RAM首地址执行firmware.<br>对于其他CPU，汇编实现也不同，因此此方法不能跨平台。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void boot_exit()</span><br><span class="line">&#123;</span><br><span class="line">    /* jump to RAM entry to execute firmware. */</span><br><span class="line"></span><br><span class="line">    asm(</span><br><span class="line">        &quot;set 0x40000000, %g2\n&quot;</span><br><span class="line">        &quot;jmp %g2\n&quot;</span><br><span class="line">        &quot;nop&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：函数指针<br>Bootloader中很常用的一种跳转方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*pFuncType)(); //定义无入参无返回类型的函数指针类型</span><br><span class="line">pFuncType Reset = (pFuncType)0xF000FFF0; //函数指针指向待跳转地址</span><br><span class="line">Reset(); //调用函数，实际上执行了跳转</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/" class="post-title-link" itemprop="url">C++面向对象笔记：模板、泛型与STL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 16:53:38" itemprop="dateCreated datePublished" datetime="2020-03-21T16:53:38+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 16:55:43" itemprop="dateModified" datetime="2022-12-08T16:55:43+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++除了支持面向对象，也支持函数的扩展和重用。继承类和多态充分支持了扩展，即基类进行概括抽象的设计，派生类实现具体的设计。那么重用呢，如何写一个函数，能在多种情况不加修改的套用？<br>考虑以下问题：</p>
<pre><code>交换两个整型变量的值的Swap函数：
void Swap(int &amp; x,int &amp; y)
&#123;
    int tmp = x;
    x = y;
    y = tmp;
&#125;
交换两个double型变量的值的Swap函数:
void Swap(double &amp; x,double &amp; y)
&#123;
    double tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>这两个函数除了入参类型不同，函数名，参数个数，返回类型都相同。函数体的处理流程也完全一样。能否只写一个Swap，就能交换各种类型的变量？<br>模板（template）将解决这种问题。</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="函数模板的概念"><a href="#函数模板的概念" class="headerlink" title="函数模板的概念"></a>函数模板的概念</h2><p>用函数模板，设计仅数据类型不同的一组函数的通用模板：</p>
<pre><code>template &lt;class 类型参数1，class 类型参数2,……&gt;
返回值类型 模板名 (形参表)
&#123;
    函数体
&#125;;

template &lt;class T&gt; //在函数前声明模板，参数类型（class）是T
void Swap(T &amp; x,T &amp; y)
&#123;
    T tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>在普通函数前，先用template&lt; class T &gt;声明参数类型T，就可以在函数体使用T，就像使用普通变量一样。在运行时，T传入的类型不同，函数处理的数据类型也不同。<br>函数模板是如何实现的？它是一种函数吗？</p>
<pre><code>int main()
&#123;
    int n = 1,m = 2;
    Swap(n,m); //编译器自动生成 void Swap(int &amp; ,int &amp; )函数
    double f = 1.2,g = 2.3;
    Swap(f,g); //编译器自动生成 void Swap(double &amp; ,double &amp; )函数
    return 0;
&#125;
</code></pre>
<p>函数模板只是个模子，编译器通过模板和具体参数类型产生不同的函数。编译器会进行两次编译，第一次检测模板代码，第二次检测加参数后的具体函数代码。<br>在调用以上函数模板时，实际会生成两个具体函数：</p>
<pre><code>void Swap(int &amp; x,int &amp; y)
&#123;
    int tmp = x;
    x = y;
    y = tmp;
&#125;
void Swap(double &amp; x,double &amp; y)
&#123;
    double tmp = x;
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>函数模板，可以理解为一种函数的宏，编译期在宏被调用的地方，全部替换成宏所对应的具体值。<br>函数模板和运行时函数，也类似于类和对象的关系，类只是类型，对象是给类分配了内存的实例。函数模板只是通用的类型，函数实例是函数模板的实例化对象。</p>
<h2 id="函数模板的特性"><a href="#函数模板的特性" class="headerlink" title="函数模板的特性"></a>函数模板的特性</h2><p>函数模板中可以有不止一个类型参数</p>
<pre><code>template &lt;class T1, class T2&gt;
T2 print(T1 arg1, T2 arg2)
&#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
    return arg2;
&#125;
</code></pre>
<p>不通过参数也能实例化函数模板</p>
<pre><code>template &lt;class T&gt;
T Inc(T n)
&#123;
    return 1 + n;
&#125;
int main()
&#123;
    cout &lt;&lt; Inc&lt;double&gt;(4)/2; //显式实例化模板，输出 2.5
    return 0;
&#125;
</code></pre>
<h2 id="函数模板与重载"><a href="#函数模板与重载" class="headerlink" title="函数模板与重载"></a>函数模板与重载</h2><p>函数模板和函数重载，在写法上很接近，都是一组参数不同的同名函数。它们有什么联系和区别？</p>
<ul>
<li>函数重载，关键在参数个数</li>
<li>函数模板，关键在参数类型</li>
</ul>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<pre><code>template&lt;class T1, class T2&gt;
void print(T1 arg1, T2 arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
template&lt;class T&gt;
void print(T arg1, T arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
template&lt;class T,class T2&gt;
void print(T arg1, T arg2) &#123;
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
&#125;
</code></pre>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一条函数调用语句:</p>
<ol>
<li><p>先找参数完全匹配的普通函数(非由模板实例化而得的函数)</p>
</li>
<li><p>再找参数完全匹配的模板函数。</p>
</li>
<li><p>再找实参数经过自动类型转换后能够匹配的普通函数。</p>
</li>
</ol>
<ol start="4">
<li><p>上面的都找不到，则报错<br>如果有函数重载，在第（1）步就找到，如果没有，才找（2）的函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"> T Max( T a, T b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> template &lt;class T,class T2&gt;</span><br><span class="line"> T Max( T a, T2 b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax2&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> double Max(double a, double b)&#123;</span><br><span class="line">     cout &lt;&lt; &quot;MyMax&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main() &#123;</span><br><span class="line">     int i=4, j=5;</span><br><span class="line">     Max( 1.2,3.4); // 输出MyMax</span><br><span class="line">     Max(i, j); //输出TemplateMax</span><br><span class="line">     Max( 1.2, 3); //输出TemplateMax2</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意上文的步骤（2）（3）是分开的，匹配模板函数时，是不进行类型自动转换的，不匹配就是不匹配。输入参数有二义性时。编译器不会为开发者做决定</p>
<pre><code>template&lt;class T&gt;
T myFunction( T arg1, T arg2)
&#123; cout&lt;&lt;arg1&lt;&lt;&quot; &quot;&lt;&lt;arg2&lt;&lt;&quot;\n&quot;; return arg1;&#125;
……
myFunction( 5, 7); //ok： replace T with int
myFunction( 5.8, 8.4); //ok： replace T with double
myFunction( 5, 8.4); //error， no matching function for call to &#39;myFunction(int, double)&#39;
</code></pre>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="类模板的概念"><a href="#类模板的概念" class="headerlink" title="类模板的概念"></a>类模板的概念</h2><p>类也能使用模板，来生成不同成员类型的类<br>类模板：在定义类的时候，加上一个&#x2F;多个类型参数。在使用类模板时，指定类型参数应该如何替换成具体类型，编译器据此生成相应的模板类</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
class 类模板名
&#123;
    成员函数和成员变量
&#125;;
</code></pre>
<p>类模板的成员函数的定义写法：</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名（ 参数表）
&#123;
    ……
&#125;
</code></pre>
<p>用类模板实例化对象的写法：</p>
<pre><code>类模板名 &lt;真实类型参数表&gt; 对象名(构造函数实参表);
</code></pre>
<p>一个例子：map类型中的pair类的实现：</p>
<pre><code>template &lt;class T1,class T2&gt;    //pair是类模板
class Pair
&#123;
public:
    T1 key; //关键字
    T2 value; //值
    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;; //构造函数
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const; //运算符重载函数
&#125;;

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
//Pair的运算符重载函数的定义
&#123;
    return key &lt; p.key;
&#125;

 int main()
&#123;
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,19); //实例化出一个类 Pair&lt;string,int&gt;
    cout &lt;&lt; student.key &lt;&lt; &quot; &quot; &lt;&lt; student.value;
    return 0;
&#125;
</code></pre>
<p>输出：Tom 19<br>编译器由类模板生成类的过程叫类模板的实例化。 由类模板实例化得到的类， 叫模板类<br>同一个类模板的两个模板类是不兼容的，即两个不同的类</p>
<pre><code>Pair&lt;string,int&gt; * p;
Pair&lt;string,double&gt; a;
p = &amp; a; //错误，不是同类也不是继承类，不能赋值
</code></pre>
<p>函数模版可以作为类模板成员</p>
<pre><code>template &lt;class T&gt;
class A
&#123;
public:
    template&lt;class T2&gt;
    void Func( T2 t) &#123; cout &lt;&lt; t; &#125; //成员函数模板
&#125;;
int main()
&#123;
    A&lt;int&gt; a;
    a.Func(&#39;K&#39;); //成员函数模板 Func被实例化
    a.Func(&quot;hello&quot;); //成员函数模板 Func再次被实例化
    return 0;
&#125; //输出： KHello
</code></pre>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数：</p>
<pre><code>template &lt;class T, int size&gt;
class CArray&#123;
    T array[size];
    public:
    void Print( )
    &#123;
        for( int i = 0;i &lt; size; ++i)
        cout &lt;&lt; array[i] &lt;&lt; endl;
    &#125;
&#125;;

CArray&lt;double,40&gt; a2;
CArray&lt;int,50&gt; a3;
</code></pre>
<h2 id="类模板的派生"><a href="#类模板的派生" class="headerlink" title="类模板的派生"></a>类模板的派生</h2><p>类模板也支持类的派生：<br>• 类模板从类模板派生<br>• 类模板从模板类派生<br>• 类模板从普通类派生<br>• 普通类从模板类派生</p>
<p>(1)类模板从类模板派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A &#123;
    T1 v1; T2 v2;
&#125;;

template &lt;class T1,class T2&gt;
class B:public A&lt;T2,T1&gt; &#123;
    T1 v3; T2 v4;
&#125;;

template &lt;class T&gt;
class C:public B&lt;T,T&gt; &#123;
    T v5;
&#125;;

int main() &#123;
    B&lt;int,double&gt; obj1;
    C&lt;int&gt; obj2;
    return 0;
&#125;
</code></pre>
<p>(2)类模板从模板类派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A &#123;
    T1 v1; T2 v2;
&#125;;

template &lt;class T&gt;
class B:public A&lt;int,double&gt; &#123;
    T v;
&#125;;

int main() &#123;
    B&lt;char&gt; obj1; //自动生成两个模板类：A&lt;int,double&gt; 和 B&lt;char&gt;
    return 0;
&#125;
</code></pre>
<p>(3)类模板从普通类派生</p>
<pre><code>class A &#123;
    int v1;
&#125;;

template &lt;class T&gt;
class B:public A &#123; //所有从B实例化得到的类， 都以A为基类
    T v;
&#125;;

int main() &#123;
    B&lt;char&gt; obj1;
    return 0;
&#125;
</code></pre>
<p>(4)普通类从模板类派生</p>
<pre><code>template &lt;class T&gt;
class A &#123;
    T v1;
    int n;
&#125;;

class B:public A&lt;int&gt; &#123;
    double v;
&#125;;
int main() &#123;
    B obj1;
    return 0;
&#125;
</code></pre>
<h2 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h2><p>• 函数、类、类的成员函数作为类模板的友元<br>• 函数模板作为类模板的友元<br>• 函数模板作为类的友元<br>• 类模板作为类模板的友元</p>
<p>(1)函数、类、类的成员函数作为类模板的友元</p>
<pre><code>void Func1() &#123; &#125;
class A &#123; &#125;;
class B
&#123;
    public:
    void Func() &#123; &#125;
&#125;;

template &lt;class T&gt;
class Tmpl
&#123;
    friend void Func1();
    friend class A;
    friend void B::Func();
&#125;; //任何从Tmp1实例化来的类， 都有以上三个友元
</code></pre>
<p>(2)函数模板作为类模板的友元</p>
<pre><code>template &lt;class T1,class T2&gt;
class Pair
&#123;
private:
    T1 key; //关键字
    T2 value; //值
public:
    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;;
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const;
    template &lt;class T3,class T4&gt;
    friend ostream &amp; operator&lt;&lt; ( ostream &amp; o,
    const Pair&lt;T3,T4&gt; &amp; p);
&#125;;

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
&#123; //&quot;小&quot;的意思就是关键字小
    return key &lt; p.key;
&#125;
template &lt;class T1,class T2&gt;
ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)
&#123;
    o &lt;&lt; &quot;(&quot; &lt;&lt; p.key &lt;&lt; &quot;,&quot; &lt;&lt; p.value &lt;&lt; &quot;)&quot; ;
    return o;
&#125;

int main()
&#123;
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,29);
    Pair&lt;int,double&gt; obj(12,3.14);
    cout &lt;&lt; student &lt;&lt; &quot; &quot; &lt;&lt; obj;
    return 0;
&#125;

输出：
(Tom,29) (12,3.14)
</code></pre>
<p>任意从 <code>template &lt;class T1,class T2&gt; ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)</code>生成的函数，都是任意Pair摸板类的友元</p>
<p>(3)函数模板作为类的友元</p>
<pre><code>class A
&#123;
    int v;
    public:
    A(int n):v(n) &#123; &#125;
    template &lt;class T&gt;
    friend void Print(const T &amp; p);
&#125;;
template &lt;class T&gt;
void Print(const T &amp; p)
&#123;
    cout &lt;&lt; p.v;
&#125;

int main() &#123;
    A a(4);
    Print(a);
    return 0;
&#125;

输出：
4
</code></pre>
<p>所有从 <code>template &lt;class T&gt; void Print(const T &amp; p)</code><br>生成的函数，都成为 A 的友元</p>
<p>(4)类模板作为类模板的友元</p>
<pre><code>template &lt;class T&gt;
class B &#123;
    T v;
    public:
    B(T n):v(n) &#123; &#125;
    template &lt;class T2&gt;
    friend class A;
&#125;;

template &lt;class T&gt;
class A &#123;
public:
    void Func( ) &#123;
        B&lt;int&gt; o(10);
        cout &lt;&lt; o.v &lt;&lt; endl;
    &#125;
&#125;;

int main()
&#123;
    A&lt; double &gt; a;
    a.Func ();
    return 0;
&#125;

输出：
10
</code></pre>
<p>A&lt; double&gt;类，成了B<int>类的友元。任何从A模版实例化出来的类，都是任何B实例化出来的类的友元</p>
<h2 id="类模板与静态成员"><a href="#类模板与静态成员" class="headerlink" title="类模板与静态成员"></a>类模板与静态成员</h2><p>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员</p>
<pre><code>template &lt;class T&gt;
class A
&#123;
private:
    static int count;
    public:
    A() &#123; count ++; &#125;
    ~A() &#123; count -- ; &#125;;
    A( A &amp; ) &#123; count ++ ; &#125;
    static void PrintCount() &#123; cout &lt;&lt; count &lt;&lt; endl; &#125;
&#125;;

template&lt;&gt; int A&lt;int&gt;::count = 0;
template&lt;&gt; int A&lt;double&gt;::count = 0;
int main()
&#123;
    A&lt;int&gt; ia;
    A&lt;double&gt; da;
    ia.PrintCount();
    da.PrintCount();
    return 0;
&#125;

输出：
1 1
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/" class="post-title-link" itemprop="url">C++面向对象笔记：继承与多态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 16:49:06" itemprop="dateCreated datePublished" datetime="2020-03-20T16:49:06+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 16:55:25" itemprop="dateModified" datetime="2022-12-08T16:55:25+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>前文分析了C++类内成员的关系，本文讨论类和类之间的关系。<br>考虑用C++对现实世界的交通工具进行描述。</p>
<ul>
<li>汽车可能包含各种类型，小汽车，公交车，但他们能抽象出四个轮子，烧油这些基本属性</li>
<li>飞机也有各种类型，但也能抽象出机翼，机身等基本属性</li>
<li>轮船…</li>
</ul>
<p>如果自顶向下设计，如何设计这些对象的类？</p>
<ul>
<li>提炼这些交通工具的共有属性，如材质，耗油量，价格，设计成一个交通工具基础类；然后设计一些操作方法，比如制造，启动，停止。</li>
<li>分别设计汽车、飞机、轮船等更具体的类的属性，比如轮子、排水量等，注意，他们也包含基础类的材质，耗油量，价格等基本属性；然后也设计一些方法，比如制造汽车、开汽车和造飞机、开飞机等</li>
<li>然后再设计更细节的类，作为汽车、飞机、轮船类的细化，比如A品牌的汽车，B品牌汽车，作为两个具体类。</li>
</ul>
<p>仔细考虑以上步骤，有以下问题：</p>
<ul>
<li>这些类的属性（成员变量）是相互独立的吗？</li>
<li>这些类的方法（成员函数）是相互独立的吗？</li>
</ul>
<p>C++用类的“继承”描述层层细化的类及其成员变量的关系，用“多态”描述各层方法的实现关系。</p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承关系的概念"><a href="#继承关系的概念" class="headerlink" title="继承关系的概念"></a>继承关系的概念</h2><p>继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个<strong>基类</strong>（也叫父类），而把B作为基类的一个<strong>派生类</strong>(也叫子类)。</p>
<ul>
<li>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数</li>
<li>派生类一经定义后，可以独立使用，不依赖于基类。</li>
<li>派生类拥有基类的全部成员函数和成员变量，不论是private、 protected、 public。但是派生类的成员函数不能访问基类中的private成员</li>
</ul>
<p>一个管理学生的类继承：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651314.png" alt="image-20221208165130260"><br>派生类语法:</p>
<pre><code>class 派生类名： public 基类名
&#123;
&#125;;
</code></pre>
<p>学生类的派生:</p>
<pre><code>class CStudent &#123;
    private:
    string sName;
    int nAge;
    public:
    bool IsThreeGood() &#123; &#125;;
    void SetName( const string &amp; name )
    &#123; sName = name; &#125;
        //......
&#125;;

class CUndergraduateStudent: public CStudent &#123;
    private:
    int nDepartment;
    public:
    bool IsThreeGood() &#123; ...... &#125;; //覆盖
    bool CanBaoYan() &#123; .... &#125;;
&#125;; // 派生类的写法是：类名: public 基类名
</code></pre>
<h2 id="类继承的存储空间"><a href="#类继承的存储空间" class="headerlink" title="类继承的存储空间"></a>类继承的存储空间</h2><p>在类与对象一文讲过，类对象的存储空间，实际就是成员变量的空间，成员函数不在对象空间内（虚函数包含一个虚函数表指针）。那么基类和派生类的对象空间有什么相关性？<br>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。 在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。<br>一个示例：</p>
<pre><code>class CBase
&#123;
    int v1, v2;
&#125;;
class CDerived:public CBase
&#123;
    int v3;
&#125;;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651715.png" alt="image-20221208165140659"></p>
<h2 id="类继承的覆盖"><a href="#类继承的覆盖" class="headerlink" title="类继承的覆盖"></a>类继承的覆盖</h2><p>类内的同名非同参的函数叫函数重载，那么基类与派生类的同名函数呢？<br>派生类可以定义和基类成员同名的成员，这叫<strong>覆盖</strong>。在派生类中访问这类成员时，默认访问派生类中定义的成员，基类的成员函数或变量被“覆盖”掉了。如果要在派生类中访问基类定义的同名成员时，要使用作用域符号::<br>一个例子：</p>
<pre><code>class base &#123;    //基类
    int j;  //默认private
    public:
    int i;
    void func();
&#125;;
class derived : public base&#123;    //派生类
    public:
    int i;  //覆盖基类i
    void access();
    void func(); //覆盖基类func()
&#125;;

void derived::access() &#123; //访问派生类成员
    j = 5; //error
    i = 5; //引用的是派生类的 i
    base::i = 5; //引用的是基类的 i
    func(); //派生类的
    base::func(); //基类的
&#125;
</code></pre>
<p>调用函数:</p>
<pre><code>derived obj;
obj.i = 1;  //访问派生类成员i
obj.base::i = 1; //访问基类成员i
</code></pre>
<p>内存分布:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651894.png" alt="image-20221208165150851"><br>以上只是示例，一般来说，基类和派生类不定义同名成员变量，但经常有同名成员函数，所以覆盖通常用于成员函数覆盖。</p>
<h2 id="类继承的成员访问控制"><a href="#类继承的成员访问控制" class="headerlink" title="类继承的成员访问控制"></a>类继承的成员访问控制</h2><ul>
<li>基类的private成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数</li>
<li>基类的public成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数<br>– 派生类的友元函数<br>– 其他的函数</li>
<li>基类的protected成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数可以访问当前对象的基类的保护成员</li>
</ul>
<p>一个示例：</p>
<pre><code>class Father &#123;
    private: int nPrivate; //私有成员
    public: int nPublic; //公有成员
    protected: int nProtected; // 保护成员
&#125;;
class Son :public Father&#123;
    void AccessFather () &#123;
        nPublic = 1; // ok;
        nPrivate = 1; // wrong
        nProtected = 1; // OK，访问从基类继承的protected成员
        Son f;
        f.nProtected = 1; //wrong ， f不是当前对象
    &#125;
&#125;;

int main()
&#123;
    Father f;
    Son s;
    f.nPublic = 1; // Ok
    s.nPublic = 1; // Ok
    f.nProtected = 1; // error
    f.nPrivate = 1; // error
    s.nProtected = 1; //error
    s.nPrivate = 1; // error
    return 0;
&#125;
</code></pre>
<h2 id="类继承的构造函数"><a href="#类继承的构造函数" class="headerlink" title="类继承的构造函数"></a>类继承的构造函数</h2><p>类似于嵌套类（封闭类）的构造函数，使用初始化列表来实现层层构造，基类和派生类只初始化他们能访问的成员</p>
<pre><code>class Bug &#123;
private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug ()&#123; &#125;;
&#125;;

class FlyBug: public Bug // FlyBug是Bug的派生类
&#123;
    int nWings;
    public:
    FlyBug( int legs,int color, int wings);
&#125;;

Bug::Bug( int legs, int color) //Bug类的构造函数
&#123;
    nLegs = legs;
    nColor = color;
&#125;

//错误的FlyBug构造函数！
FlyBug::FlyBug ( int legs,int color, int wings)
&#123;
    nLegs = legs; // 不能访问
    nColor = color; // 不能访问
    nType = 1; // ok
    nWings = wings;
&#125;

//正确的FlyBug构造函数：使用初始化列表
FlyBug::FlyBug ( int legs, int color, int wings):Bug( legs, color)
&#123;
    nWings = wings;
&#125;

int main() &#123;
    FlyBug fb ( 2,3,4);
    fb.PrintBug();
    fb.nType = 1;
    fb.nLegs = 2 ; // error. nLegs is private
    return 0;
&#125;
</code></pre>
<h2 id="类继承的构造析构时序"><a href="#类继承的构造析构时序" class="headerlink" title="类继承的构造析构时序"></a>类继承的构造析构时序</h2><p>在创建派生类的对象时，需要调用基类的构造函数：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。<br>调用基类构造函数的两种方式:</p>
<ul>
<li><p>显式方式：在派生类的构造函数中，为基类的构造函数提供参数.</p>
<p> derived::derived(arg_derived-list):base(arg_base-list)</p>
</li>
<li><p>隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数</p>
</li>
</ul>
<p>析构函数执行时序:<br>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。<br>一个例子：</p>
<pre><code>class Base &#123;
    public:
    int n;
    Base(int i):n(i)
    &#123; cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;&#125;
    ~Base()
    &#123; cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; destructed&quot; &lt;&lt; endl; &#125;
&#125;;
    
class Derived:public Base &#123;
    public:
    Derived(int i):Base(i)
    &#123; cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl; &#125;
    ~Derived()
    &#123; cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;&#125;
&#125;;
int main() &#123; Derived Obj(3); return 0; &#125;
</code></pre>
<p>输出结果:</p>
<pre><code>Base 3 constructed
Derived constructed
Derived destructed
Base 3 destructed
</code></pre>
<p>##封闭派生类的构造函数<br>封闭类的构造用初始化列表，派生类也用初始化列表，那么封闭派生类呢？<br>还是初始化列表</p>
<pre><code>class Bug &#123;
    private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug ()&#123; &#125;;
&#125;;

class Skill &#123;
    public:
    Skill(int n) &#123; &#125;
&#125;;
class FlyBug: public Bug &#123;
    int nWings;
    Skill sk1, sk2;
    public:
    FlyBug( int legs, int color, int wings);
&#125;;
FlyBug::FlyBug( int legs, int color, int wings):
    Bug(legs,color),sk1(5),sk2(color) ,nWings(wings) &#123; //初始化列表，不能访问的通通交给下层构造函数
&#125;
</code></pre>
<h2 id="封闭派生类的构造析构时序"><a href="#封闭派生类的构造析构时序" class="headerlink" title="封闭派生类的构造析构时序"></a>封闭派生类的构造析构时序</h2><p>在创建派生类的对象时:</p>
<ol>
<li>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员</li>
<li>再执行成员对象类的构造函数，用以初始化派生类对象中成员对象</li>
<li>最后执行派生类自己的构造函数<br>在派生类对象消亡时：</li>
<li>先执行派生类自己的析构函数</li>
<li>再依次执行各成员对象类的析构函数</li>
<li>最后执行基类的析构函数<br>析构函数的调用顺序与构造函数的调用顺序相反<h1 id="类的复合"><a href="#类的复合" class="headerlink" title="类的复合"></a>类的复合</h1>在数学上，两个集合有无关、相交和包含的关系。对于多个类来说，也应该有以上三种关系。无关类&#x3D;两个成员不相关的类；继承类&#x3D;类成员间有继承关系的类；那么相交的类呢？<h2 id="复合关系的概念"><a href="#复合关系的概念" class="headerlink" title="复合关系的概念"></a>复合关系的概念</h2>C++用“复合”表示类的相交关系。</li>
</ol>
<p>1)继承：“是”的关系<br>基类是A， B是基类A的派生类，逻辑上要求：“一个B对象也是一个A对象”<br>2)复合：“有”的关系<br>类C中“有” 成员变量k，k是类D的对象，则C和D是复合关系，逻辑上要求：“D对象是C对象的固有属性或组成部分</p>
<p>下面比较一下继承和复合在具体设计的实例：<br>继承关系顶层设计例子:</p>
<ul>
<li>写了一个 CMan 类代表男人</li>
<li>后来又发现需要一个CWoman类来代表女人</li>
<li>CWoman类和CMan类有共同之处,让CWoman类从CMan类派生而来，是否合适？</li>
<li>错！从一开始就应该设计CHuman类，代表“人” ,然后CMan和CWoman都从<br>CHuman派生</li>
</ul>
<p>继承逻辑关系：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652246.png" alt="image-20221208165210195"></p>
<p>复合关系顶层设计例子：</p>
<ul>
<li>几何形体程序中，需要写“点”类，也需要写“圆”类</li>
<li>每个圆都有圆心，那么点类应该从圆类派生出来吗？</li>
<li>错！”点“不仅在圆内有，在其他图形也有，不是圆独有，非继承关系</li>
<li>实际上，圆和点是复合关系，每一个“圆”对象里都包含(<strong>有</strong>)一个“点”对象</li>
<li>逻辑上，复合关系就是，我的一部分可以看成是你的，但是我的全部东西不都属于你</li>
</ul>
<p>复合关系的类通常用友元实现：</p>
<pre><code>class CPoint
&#123;
    double x,y;
    friend class CCircle;
    //便于Ccirle类操作其圆心
&#125;;

class CCircle
&#123;
    double r;
    CPoint center;
&#125;;
</code></pre>
<h2 id="复合关系的典型示例"><a href="#复合关系的典型示例" class="headerlink" title="复合关系的典型示例"></a>复合关系的典型示例</h2><p>如果要写一个小区养狗管理程序，需要写一个“业主”类，还需要写一个“狗” 类<br>狗是归宿于业主的，一个业主可以有多条狗，狗也可以随时脱离业主<br>考虑以下设计方法：<br>设计人和狗两个类，相互包含对方类</p>
<pre><code>class CDog;
class CMaster
&#123;
    CDog dogs[10];
&#125;;
class CDog
&#123;
    CMaster m;
&#125;;
</code></pre>
<p> 这样有循环定义错误！且逻辑上，狗和人并非相互包含关系<br> 这种关系上相互相关，对象本身又完全独立的情况，用对象指针表示</p>
<pre><code>class CMaster; //CMaster必须提前声明，不能先写CMaster类后写Cdog类
class CDog &#123;
    CMaster * pm;
&#125;;
class CMaster &#123;
    CDog * dogs[10];
&#125;;
</code></pre>
<p>逻辑关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652390.png" alt="image-20221208165220338"></p>
<h1 id="继承的不足"><a href="#继承的不足" class="headerlink" title="继承的不足"></a>继承的不足</h1><h2 id="继承方式的访问限制"><a href="#继承方式的访问限制" class="headerlink" title="继承方式的访问限制"></a>继承方式的访问限制</h2><p>基类和派生类是包含的关系，那么基类对象和派生类对象是什么关系？<br>对于类的public派生方式:</p>
<pre><code>class base &#123; &#125;;
class derived : public base &#123; &#125;;
base b;
derived d;
</code></pre>
<p>1）派生类的对象可以赋值给基类对象<br>b &#x3D; d;<br>2）派生类对象可以初始化基类引用<br>base &amp; br &#x3D; d;<br>3）派生类对象的地址可以赋值给基类指针<br>base * pb &#x3D; &amp; d;<br>如果派生方式是 private或protected，则上述三条不可行</p>
<p>对于类的protected和private派生方式:</p>
<pre><code>class base &#123;&#125;;
class derived : protected base &#123;&#125;;
base b;
derived d;
</code></pre>
<p>• protected继承时，基类的public成员和protected成员成为派生类的protected成员。<br>• private继承时，基类的public成员成为派生类的private成员，基类的protected成员成为派生类的不可访问成员。<br>• protected和private继承不是“是”的关系</p>
<h2 id="派生类的对象指针转换"><a href="#派生类的对象指针转换" class="headerlink" title="派生类的对象指针转换"></a>派生类的对象指针转换</h2><p>public派生的情况下,派生类对象的指针可以直接赋值给基类指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
//ptrBase指向的是一个Derived类的对象；
</code></pre>
<p>*ptrBase可以看作一个Base类的对象，访问它的public成员直接通过ptrBase即可，但不能通过ptrBase访问objDerived对象中属于Derived类而不属于Base类的成员<br>过强制指针类型转换，可以把ptrBase转换成Derived类的指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
Derived *ptrDerived = (Derived * ) ptrBase;
</code></pre>
<p>程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会错</p>
<p>派生类的指针赋值给基类后，基类指针也不能访问派生类的特有成员</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Base &#123;
    protected:
    int n;
    public:
    Base(int i):n(i)&#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; constructed&quot; &lt;&lt; endl; &#125;
    ~Base() &#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; destructed&quot; &lt;&lt; endl;&#125;
    void Print() &#123; cout &lt;&lt; &quot;Base:n=&quot; &lt;&lt; n &lt;&lt; endl;&#125;
&#125;;

class Derived:public Base &#123;
    public:
    int v;
    Derived(int i):Base(i),v(2 * i) &#123;
    cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl;
&#125;

~Derived() &#123;
    cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;
&#125;

void Func() &#123; &#125; ;
    void Print() &#123;
        cout &lt;&lt; &quot;Derived:v=&quot; &lt;&lt; v &lt;&lt; endl;
        cout &lt;&lt; &quot;Derived:n=&quot; &lt;&lt; n &lt;&lt; endl;
    &#125;
&#125;;

int main() &#123;
    Base objBase(5);
    Derived objDerived(3);
    Base * pBase = &amp; objDerived ;
    //pBase-&gt;Func(); //err;Base类没有Func()成员函数
    //pBase-&gt;v = 5; //err; Base类没有v成员变量
    pBase-&gt;Print();
    //Derived * pDerived = &amp; objBase; //error
    Derived * pDerived = (Derived *)(&amp; objBase);
    pDerived-&gt;Print(); //慎用，可能出现不可预期的错误
    pDerived-&gt;v = 128; //往别人的空间里写入数据，会有问题
    objDerived.Print();
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Base 5 constructed
Base 3 constructed
Derived constructed
Base:n=3
Derived:v=1245104 //pDerived-&gt;n 位于别人的空间里
Derived:n=5
Derived:v=6
Derived:n=3
Derived destructed
Base 3 destructed
Base 5 destructed
</code></pre>
<p>从逻辑上来说，派生类指针既然能被赋值给基类指针，那么通过基类指针，应该能调用派生类的成员函数，获取派生类的成员变量。在下一章，继承类的多态将实现这个目的。</p>
<h2 id="多级继承"><a href="#多级继承" class="headerlink" title="多级继承"></a>多级继承</h2><p>类A派生类B，类B派生类C，类C派生类D……<br>– 类A是类B的直接基类<br>– 类B是类C的直接基类，类A是类C的间接基类<br>– 类C是类D的直接基类，类A、 B是类D的间接基类<br>在声明派生类时， 只需要列出它的直接基类<br>– 派生类沿着类的层次自动向上继承它的间接基类<br>– 派生类的成员包括<br>• 派生类自己定义的成员<br>• 直接基类中的所有成员<br>• 所有间接基类的全部成员</p>
<h1 id="多态：在继承上更进一步"><a href="#多态：在继承上更进一步" class="headerlink" title="多态：在继承上更进一步"></a>多态：在继承上更进一步</h1><p>前面派生类的对象指针转换一节，基类指针强转后也不能访问派生类私有对象。考虑一下本文开始讲的交通工具顶层设计思路，在顶层设计时就要设计类的成员函数，在派生类也要设计成员函数，这些函数会有重合的情况吗？如果有重合，基类指针也不能访问派生类成员，这样基类和派生类不就失去联系了吗？多级继承这种情况不是更加严重？<br>为了解决这种问题，本节引入继承类的“多态”<br>多态能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少</p>
<h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><p>在类的定义中，前面有 virtual 关键字的成员函数就是虚函数</p>
<pre><code>class base &#123;
    virtual int get() ;
&#125;;
int base::get()&#123; &#125;
</code></pre>
<p>virtual关键字只用在类定义里的函数声明中使用，定义函数体时不用。<br>使用虚函数，来实现“多态”效果。多态有通过指针和引用两种表现形式:</p>
<ul>
<li>能通过基类的指针调用派生类虚函数，访问其特有成员变量</li>
</ul>
<p>派生类的指针可以赋给基类指针<br>通过基类指针调用基类和派生类中的同名虚函数时:<br>（1）若该指针指向一个基类的对象，那么被调用是<br>基类的虚函数；<br>（2）若该指针指向一个派生类的对象，那么被调用<br>的是派生类的虚函数</p>
<pre><code>class CBase &#123;
public:
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
class CDerived:public CBase &#123;
public :
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
int main() &#123;
    CDerived ODerived;
    CBase * p = &amp; ODerived;
    p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象
    return 0;
&#125; 
</code></pre>
<ul>
<li>能通过基类的引用调用派生类虚函数</li>
</ul>
<p>派生类的对象可以赋给基类引用<br>通过基类引用调用基类和派生类中的同名虚函数时:<br>（1）若该引用引用的是一个基类的对象，那么被调<br>用是基类的虚函数；<br>（2）若该引用引用的是一个派生类的对象，那么被<br>调用的是派生类的虚函数。</p>
<pre><code>class CBase &#123;
public:
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
class CDerived:public CBase &#123;
public :
    virtual void SomeVirtualFunction() &#123; &#125;
&#125;;
int main() &#123;
    CDerived ODerived;
    CBase &amp; r = ODerived;
    r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象
    return 0;
&#125; 
</code></pre>
<p>是不是所有成员函数加virtual都是多态？不是！</p>
<ul>
<li>在非构造或析构函数的成员函数中调用虚函数，是多态。在运行时才确定到底调用哪一层派生类函数</li>
<li>在构造函数和析构函数中调用虚函数，不是多态。调用的函数是当前类的函数，编译时即确定</li>
</ul>
<p>多层继承实现多态，每一层都要加virtual关键字吗？</p>
<ul>
<li>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</li>
</ul>
<h2 id="多态与对象指针"><a href="#多态与对象指针" class="headerlink" title="多态与对象指针"></a>多态与对象指针</h2><p>一个变量有两方面属性：类型、值<br>那么多态把derived类的地址值，赋值给base类的指针，访问对象成员时是什么效果？<br>以下例子的this指针指向什么？</p>
<pre><code>class Base &#123;
public:
    void fun1() &#123; this-&gt;fun2(); &#125; //this是基类指针， fun2是虚函数，所以是多态
    virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
class Derived:public Base &#123;
public:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
int main() &#123;
    Derived d;
    Base * pBase = &amp; d;
    pBase-&gt;fun1();
    return 0;
&#125;
</code></pre>
<p>pBase被Derived对象的地址赋值后，其值为Derived对象的地址，但类型还是Base的指针（多态指针赋值不会强转）。pBase-&gt;fun1()会先在Base类访问其fun1()，传入this指针（指向fun2）,而this-&gt;fun2()会调用Derived类的fun2()<br>输出： </p>
<pre><code>Derived:fun2()
</code></pre>
<p>虚函数也可以定义为private：</p>
<pre><code>class Base &#123;
private:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
class Derived:public Base &#123;
public:
    virtual void fun2() &#123; cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
Derived d;
Base * pBase = &amp; d;
pBase -&gt; fun2(); // 编译出错
</code></pre>
<p>pBase已经被赋值为指向derived d的指针，不能调用base类的private函数。</p>
<h2 id="多态的实例-游戏开发"><a href="#多态的实例-游戏开发" class="headerlink" title="多态的实例:游戏开发"></a>多态的实例:游戏开发</h2><p>游戏中有很多种怪物，每种怪物都有一个类与之对应。某个玩家创建的具体怪物就是对象<br>怪物的主要动作（成员函数）有：</p>
<ul>
<li>攻击（Attack），针对不同的被攻击者有不同的函数</li>
<li>反击（FightBack），被某个怪物攻击时做出的相应动作</li>
<li>掉血（Hurted），被攻击时会掉血，血量值不同有不同处理，如死亡</li>
</ul>
<p>现在的需求是：已经有CWolf、CGhost两种怪物，需要设计新的怪物CThunderBird，并能满足和其他怪物的交互<br>顶层设计:<br>设置基类 CCreature，并且使CDragon, CWolf等其他类都从CCreature派生而来<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652097.png" alt="image-20221208165241029"><br>非多态的派生类设计：<br>由于每个怪物对于其他怪物的攻击和反击都是不同的，每个怪物类都要设计一组Attack和FightBack：</p>
<pre><code>class class CCreature &#123;
    protected: int nPower ; //代表攻击力
    int nLifeValue ; //代表生命值
&#125;;
class CThunderBird : public CCreature &#123;
    public:
    void Attack(CWolf * pWolf) &#123;
        ．．．表现攻击动作的代码
        pWolf-&gt;Hurted( nPower);
        pWolf-&gt;FightBack( this);
    &#125;
    void Attack( CDragon * pDragon) &#123;
        ．．．表现攻击动作的代码
        pDragon-&gt;Hurted( nPower);
        pDragon-&gt;FightBack( this);
    &#125;
    void FightBack( CWolf * pWolf) &#123;
        ．．．．表现反击动作的代码
        pWolf -&gt;Hurted( nPower / 2);
    &#125;
    void FightBack( CDragon * pDragon) &#123;
        ．．．．表现反击动作的代码
        pDragon-&gt;Hurted( nPower / 2 );
    &#125;
    void Hurted ( int nPower) &#123;
        ．．．．表现受伤动作的代码
        nLifeValue -= nPower;
    &#125;
&#125;
</code></pre>
<p>现有n种怪物，CThunderBird类中就得有n个Attack 和n个FightBack成员函数，对于其他类也得新增针对CThunderBird的Attack和FightBack。这种设计工作量过于巨大。原因就在于要区分传入的对象指针。<br>那么能否传入基类的指针呢，这样就不存在为各种类型写几个函数。基类指针要访问派生类的成员，得用虚函数形成多态。多态实现如下：</p>
<pre><code>//基类 CCreature：
class CCreature &#123;
protected :
    int m_nLifeValue, m_nPower;
    public:
    virtual void Attack( CCreature * pCreature) &#123;&#125;
    virtual void Hurted( int nPower) &#123; &#125;
    virtual void FightBack( CCreature * pCreature) &#123;&#125;
&#125;;
//派生类 CDragon:
class CDragon : public CCreature &#123;
public:
    virtual void Attack( CCreature * pCreature);
    virtual void Hurted( int nPower);
    virtual void FightBack( CCreature * pCreature);
&#125;;

//派生类的成员函数实现具体操作
void CDragon::Attack(CCreature * p) //传入基类指针
&#123; …表现攻击动作的代码
    p-&gt;Hurted(m_nPower); //多态
    p-&gt;FightBack(this); //多态
&#125;
void CDragon::Hurted( int nPower)
&#123; …表现受伤动作的代码
    m_nLifeValue -= nPower;
&#125;
void CDragon::FightBack(CCreature * p)
&#123; …表现反击动作的代码
    p-&gt;Hurted(m_nPower/2); //多态
&#125;

//多态的调用
CDragon Dragon; CWolf Wolf; CGhost Ghost;
CThunderBird Bird；
Dragon.Attack( &amp; Wolf); //调用CWolf::Hurted
Dragon.Attack( &amp; Ghost); //调用CGhost::Hurted
Dragon.Attack( &amp; Bird); //调用CBird::Hurted
</code></pre>
<p>使用多态，新增某个派生类时，已有的类可以原封不动，因为传入基类指针，会“自动”调用正确的派生类函数，开发者只需要设计新增的派生类和其成员函数即可</p>
<h2 id="多态的原理：虚函数表指针"><a href="#多态的原理：虚函数表指针" class="headerlink" title="多态的原理：虚函数表指针"></a>多态的原理：虚函数表指针</h2><p>多态” 的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定，这叫“动态联编”<br>首先分析包含虚函数的类对象的内存分布：</p>
<pre><code>class Base &#123;
public:
int i;
    virtual void Print() &#123; cout &lt;&lt; &quot;Base:Print&quot; ; &#125;
&#125;;

class Derived : public Base&#123;
public:
int n;
    virtual void Print() &#123; cout &lt;&lt;&quot;Drived:Print&quot; &lt;&lt; endl; &#125;
&#125;;

int main() &#123;
    Derived d;
    cout &lt;&lt; sizeof( Base) &lt;&lt; &quot;,&quot;&lt;&lt; sizeof( Derived ) ;
    return 0;
&#125;
</code></pre>
<p>输出：8, 12<br>为什么类对象的size比成员变量int（4字节）还多4字节？<br>因为包含虚函数的基类，实例化的对象除了成员变量，还包含一个指针（一般4字节），指向虚函数的入口地址，如果有多个虚函数，这些地址连续排列形成虚函数表，指针指向首个虚函数地址。如果这个指针指向基类，就能找到基类的所有虚函数入口，如果指针指向派生类，就能找到派生类的的所有虚函数入口。基类和派生类对象的指针赋值，实际会导致虚函数表指针指向的虚函数入口地址不同，从而调用时不同。<br>如果当前指针指向基类，则调用基类自己的虚函数：</p>
<pre><code>Base b;
pBase = &amp;b;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652980.png" alt="image-20221208165259927"><br>如果当前指针指向派生类，则调用派生类的虚函数：</p>
<pre><code>Derived d;
pDerived = &amp;d;
pBase = pDerived;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081653211.png" alt="image-20221208165311145"><br>动态联编的实现：<br>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令<br>而普通函数是编译过程中确定了成员函数的入口地址，不存在运行时根据对象来改变某个函数的入口地址。</p>
<h2 id="虚函数与抽象类"><a href="#虚函数与抽象类" class="headerlink" title="虚函数与抽象类"></a>虚函数与抽象类</h2><p>可以想象得到，前文的游戏使用虚函数的例子是通用的，先设计基类，提炼对象属性，定义虚函数；再派生子类，在子类实现局函数的具体操作。那么问题来了，基类的虚函数有必要实现函数体吗？<br>很多情况，基类只是一个抽象，定义了函数的名称和参数，不需要在基类实现虚函数，全部交给派生类实现。</p>
<ul>
<li>纯虚函数：没有函数体的虚函数</li>
<li>抽象类：包含纯虚函数的类</li>
</ul>
<p>纯虚函数写法：没函数体{}，直接&#x3D;0</p>
<pre><code>class A &#123;
private: int a;
public:
    virtual void Print( ) = 0 ; //纯虚函数
    void fun() &#123; cout &lt;&lt; &quot;fun&quot;; &#125;
&#125;;
</code></pre>
<p>抽象类特点：</p>
<ul>
<li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li>
<li>可以创建抽象类的指针和引用，它们可以指向派生类的对象</li>
</ul>
<p>抽象类的指针：</p>
<pre><code>A a ; // 错， A 是抽象类，不能创建对象
A * pa ; // ok,可以定义抽象类的指针和引用
pa = new A ; //错误, A 是抽象类，不能创建对象
</code></pre>
<p>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类<br>抽象类的成员函数可以调用纯虚函数，但是构造函数或析构函数内不能调用纯虚函数</p>
<pre><code>class A &#123;
public:
    virtual void f() = 0; //纯虚函数
    void g( ) &#123; 
        this-&gt;f( ) ; //ok
    &#125;
    A( )&#123; 
        f( ); // 错误
    &#125;
&#125;;
class B:public A&#123;
public:
    void f()&#123;cout&lt;&lt;&quot;B:f()&quot;&lt;&lt;endl; &#125;
&#125;;
</code></pre>
<h2 id="虚函数与构造析构函数"><a href="#虚函数与构造析构函数" class="headerlink" title="虚函数与构造析构函数"></a>虚函数与构造析构函数</h2><p>前面考虑了普通成员函数加virtual，可以形成虚函数达到继承类的多态效果。那么构造函数和析构函数呢？</p>
<ul>
<li>不允许以虚函数作为构造函数</li>
<li>类继承需要把基类的析构函数设为虚函数</li>
</ul>
<p>对于常规析构函数，通过基类指针删除派生类对象时，只能调用基类的析构函数。但是合理的做法是，应该先调用派生类的析构函数，然后调用基类的析构函数。解决的方法：把析构函数定义为virtual，由于基类析构函数是虚函数，派生类的同名析构函数自然也是虚函数。<br>什么时候定义虚析构函数</p>
<ul>
<li>一个类只要定义了虚函数，则应该将析构函数也定义成虚函数</li>
<li>一个类打算作为基类使用，则应该将析构函数定义成虚函数</li>
</ul>
<p>虚析构函数用法：通过基类的指针删除派生类对象，会首先调用派生类的析构函数，然后调用基类的析构函数</p>
<pre><code>class son&#123;
public:
    virtual ~son() &#123;cout&lt;&lt;&quot;bye from son&quot;&lt;&lt;endl;&#125;;
&#125;;
class grandson:public son&#123;
public:
    ~grandson()&#123;cout&lt;&lt;&quot;bye from grandson&quot;&lt;&lt;endl;&#125;;
&#125;;
int main() &#123;
    son *pson;
    pson= new grandson(); //pson指向派生类grandson
    delete pson;
    return 0;
&#125;
</code></pre>
<p>输出： </p>
<pre><code>bye from grandson
bye from son
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/18/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/18/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">C++面向对象笔记：类和对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-18 16:44:59" itemprop="dateCreated datePublished" datetime="2020-03-18T16:44:59+08:00">2020-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 16:55:51" itemprop="dateModified" datetime="2022-12-08T16:55:51+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++，加的到底是什么？<br>除了基础语法的补充和优化，C++另外几个核心特点是：</p>
<ul>
<li><p>面向对象设计的支持：</p>
<p> 类和对象对变量和函数的封装<br> 类和类之间的继承<br> 继承关系的类之间的函数调用的多态</p>
</li>
<li><p>数据结构和算法的支持<br> STL和各种常用数据类型</p>
</li>
<li><p>高可复用、可拓展的支持<br> 类模板，函数模板<br> 函数、运算符的重载</p>
</li>
</ul>
<p>本文内容：</p>
<ul>
<li>面向对象设计的概念</li>
<li>类和对象的概念及使用</li>
<li>类的几种构造函数</li>
<li>类的析构函数</li>
<li>类对象的this指针</li>
<li>类的嵌套：封闭类</li>
<li>成员的属性：友元和常量成员</li>
</ul>
<h1 id="面向对象设计的概念"><a href="#面向对象设计的概念" class="headerlink" title="面向对象设计的概念"></a>面向对象设计的概念</h1><h2 id="面向过程设计的不足"><a href="#面向过程设计的不足" class="headerlink" title="面向过程设计的不足"></a>面向过程设计的不足</h2><p>程序 &#x3D; 数据结构 + 算法<br>程序由全局变量以及众多相互调用的函数组成，算法以函数的形式实现，用于对数据结构进行操作。<br>结构化程序设计风格中，变量和函数的关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081646566.png" alt="image-20221208164648489"><br>其缺陷在于：</p>
<ul>
<li>结构化程序设计中，函数和其所操作的数据结构，没有直观的联系</li>
<li>随着程序规模的增加，程序逐渐难以理解:<br> 某个数据结构到底有哪些函数可以对它进行操作?<br> 某个函数到底是用来操作哪些数据结构的?<br> 任何两个函数之间存在怎样的调用关系?</li>
<li>结构化程序设计难以维护:<br>由于没有“封装”和“隐藏”的概念，要访问某个数据结构中的某个变量，就可以直接访问，那么当该变量的定义有改动的时候，就要把所有访问该变量的语句找出来修改，不利于程序的维护、扩充。</li>
<li>结构化程序设计难以查错:<br>当某个数据结构的值不正确时，难以找出到底是那个函数导致的。</li>
<li>结构化程序设计难以重用：<br>在编写某个程序时，发现其需要的某项功能，在现有的某个程序里已经有了相同或类似的实现，那么自然希望能够将那部分代码抽取出来，在新程序中使用。在结构化程序设计中，随着程序规模的增大，由于程序大量函数、变量之间的关系错综复杂，要抽取这部分代码，会变得十分困难。<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2>面向对象的程序设计方法，能够较好解决上述问题<br>面向对象的程序 &#x3D; 类 + 类 + …+ 类<br>设计程序的过程，就是设计类（class）的过程<br>面向对象的程序设计方法:</li>
<li>将某类客观事物共同特点（<strong>属性</strong>）归纳出来，形成一个数据结构（可以用多个变量描述事物的属性）</li>
<li>将这类事物所能进行的<strong>行为</strong>也归纳出来，形成一个个函数，这些函数可以用来操作数据结构(这一步叫“ <strong>抽象</strong>”）</li>
<li>然后，通过某种语法形式，将数据结构和操作该数据结构的函数“捆绑”在一起，形成一个“ 类”，从而使得数据结构和操作该数据结构的算法呈现出显而易见的紧密关系，这就是“<strong>封装</strong>”</li>
<li>类与类直接又形成<strong>继承、多态</strong>等关系</li>
<li>面向对象的程序设计具有“抽象”，“封装”“继承”“多态”四个基本特点。</li>
</ul>
<p>面向对象设计风格中，变量和函数的关系;<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081647726.png" alt="image-20221208164703654"></p>
<h2 id="语言和风格的无关性"><a href="#语言和风格的无关性" class="headerlink" title="语言和风格的无关性"></a>语言和风格的无关性</h2><p>注意面向过程、面向对象以及其他的风格（如函数式编程等），只是编程风格，其本质都是组织数据结构（事物属性）和算法（对事物的操作）。<br>C++有原生的类的概念，更方便写出面向对象风格的程序<br>Q. C语言没有类，能不能写出面向对象？<br>可以，C的结构体就是对数据的封装，配合函数指针，也能包含函数成员。利用带函数指针的结构体能实现属性和方法的封装，在Linux内核和设备驱动程序中充满了这种面向对象设计风格。事实上，C++的class在编译器处理后就是类似于C的结构体。<br>Q. 什么时候应该面向对象？<br>面向对象对于人的抽象概括的能力要求较高，需要花较多精力在top-down的顶层设计中，通常用于大型的长期维护的程序设计。<br>面向对象的优势在于数据结构组织化，程序时间和空间的开销可能不如面向过程。例如一个对象里的各个数据的生命周期都是捆绑分配和释放的，而面向过程可以更精细管理。在极端资源紧缺的情况，如部分嵌入式开发，面向过程不论代码设计速度和性能都比面向对象好。</p>
<h1 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a>类和对象的概念</h1><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>设计一个程序，接受输入矩形的长和宽，输出面积和周长<br>如何用类来封装？</p>
<ul>
<li>矩形的属性就是长和宽。因此需要两个变量，分别代表长和宽</li>
<li>矩形的操作方法可以有设置长和宽，算面积，算周长。每个操作各用一个函数来实现，且函数都需要用到长和宽这两个属性</li>
<li>将以上属性和方法组合就能形成一个“矩形类”。长、宽变量成为该“矩形类”的“成员变量”，三个函数成为该类的“成员函数”。成员变量和成员函数统称为类的成员。“类”看上去就像“带函数的结构”</li>
</ul>
<p>类的声明：</p>
<pre><code>class CRectangle
&#123;
    public:
        int w, h;
        int Area() &#123;
        return w * h;
    &#125;
    int Perimeter()&#123;
        return 2 * ( w + h);
    &#125;
    void Init( int w_,int h_ ) &#123;
        w = w_; h = h_;
    &#125;
&#125;; //必须有分号
</code></pre>
<p>类的实例化：</p>
<pre><code>int main( )
&#123;
    int w,h;
    CRectangle r; //r是一个对象
    cin &gt;&gt; w &gt;&gt; h;
    r.Init( w,h);
    cout &lt;&lt; r.Area() &lt;&lt; endl &lt;&lt;
    r.Perimeter();
    return 0;
&#125;
</code></pre>
<p>通过类，可以定义变量。类定义出来的变量，也称为类的实例，就是“<strong>对象</strong>”，对象的本质是在内存中分配了一个存放类这个结构的空间。<br>C++中，类的名字就是用户自定义的类型的名字。可以像使用基本类型那样来使用。 CRectangle就是一种用户自定义的类型。</p>
<h2 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h2><ul>
<li><p>和结构变量一样，对象所占用的内存空间的大小，等于所有成员变量的大小之和（考虑内存对齐可能更大）。对于上面的CRectangle类，sizeof(CRectangle)<br>&#x3D; 8</p>
</li>
<li><p>每个对象各有自己的存储空间。一个对象的某个成员变量被改变了，不会影响到另一个对象</p>
</li>
<li><p>和结构变量一样，对象之间可以用 “&#x3D;”进行赋值，但是不能用 “&#x3D;&#x3D;”“!&#x3D;”“&gt;”“&lt;”“&gt;&#x3D;”“&lt;&#x3D;”进行比较，除非这些运算符经过了“重载”。</p>
</li>
</ul>
<p>Q.类分配内存产生对象后，成员变量占用空间，成员函数占不占用空间?<br>普通成员函数不在对象生成时分配函数空间，因为函数是静态绑定的，即函数体指令只占用代码段的一处空间，对象调用该函数之间跳到该空间入口地址，在对象分配时不会在堆或栈再开辟空间存放函数体。<br>但是当类中定义了虚函数，分配对象时要分配4字节（多个虚函数也是4个字节）的指针指向虚函数表。函数跳转地址依赖于运行时才产生的对象里的虚函数表，称为动态绑定，对象调用虚函数时不知道准确的跳转地址，只跳转到虚函数表查找跳转地址，再根据查找结果跳转。</p>
<h2 id="对象访问其成员"><a href="#对象访问其成员" class="headerlink" title="对象访问其成员"></a>对象访问其成员</h2><p>类似于C结构体实例访问其成员的方法，用实例.成员，实例指针-&gt;成员，除此之外C++特有的通过引用访问：实例引用.成员<br>用法1：对象名.成员名</p>
<pre><code>CRectangle r1,r2;
r1.w = 5;
r2.Init(5,4);
</code></pre>
<p>Init函数作用在 r2 上，即Init函数执行期间访问的w 和 h是属于r2 这个对象的, 执行r2.Init 不会影响到r1<br>用法2. 指针-&gt;成员名</p>
<pre><code>CRectangle r1,r2;
CRectangle * p1 = &amp; r1;
CRectangle * p2 = &amp; r2;
p1-&gt;w = 5;
p2-&gt;Init(5,4); //Init作用在p2指向的对象上
</code></pre>
<p>用法3：引用名.成员名</p>
<pre><code>CRectangle r2;
CRectangle &amp; rr = r2;
rr.w = 5;
rr.Init(5,4); //rr的值变了， r2的值也变
</code></pre>
<h1 id="类成员的访问方式"><a href="#类成员的访问方式" class="headerlink" title="类成员的访问方式"></a>类成员的访问方式</h1><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><p>Q. C++将数据和函数封装成类的成员，那么类内成员、内间成员的访问权限如何控制？<br>用下列访问范围关键字来说明类成员可被访问的范围：</p>
<ul>
<li>private: 私有成员，只能在成员函数内访问</li>
<li>public : 公有成员，可以在任何地方访问</li>
<li>protected: 保护成员，用于继承关系的类的成员访问控制</li>
</ul>
<p>定义一个带访问控制的类：</p>
<pre><code>class className &#123;
    private:
    私有属性和函数
    public:
    公有属性和函数
    protected:
    保护属性和函数
&#125;;
</code></pre>
<p>如过某个成员前面没有上述关键字，则缺省地被认为是private私有成员:</p>
<pre><code>class Man &#123;
    int nAge;       //私有成员
    char szName[20]; // 私有成员
public:
    void SetName(char * szName)&#123;
    strcpy( Man::szName,szName);
    &#125;
&#125;;
</code></pre>
<p>在类的成员函数内部，能够访问：</p>
<ul>
<li>当前对象的全部属性、 函数；</li>
<li>同类其它对象的全部属性、函数。</li>
</ul>
<p>在类的成员函数以外的地方，只能够访问该类对象的公有成员<br>注意：<br>通过对象的成员函数，可以访问同类其他对象的任意成员（即使是private）。private、public、protected真正的作用是限制成员变量的直接访问，而通过成员函数来访问成员变量是不受影响的。</p>
<h2 id="访问控制与隐藏"><a href="#访问控制与隐藏" class="headerlink" title="访问控制与隐藏"></a>访问控制与隐藏</h2><p>成员访问控制可以定义类的成员变量能否被任意访问、或通过成员函数访问、能否被继承的子类访问等。这种机制称为对成员变量的<strong>隐藏</strong><br>隐藏的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则所有直接访问成员变量的语句都需要修改<br>一个类成员变量隐藏的例子：</p>
<pre><code> //类定义
    class CEmployee &#123;
    private:
        char szName[30]; //名字
    public :
        int salary; //工资
        void setName(char * name);
        void getName(char * name);
        void averageSalary(CEmployee e1,CEmployee e2);
    &#125;;
    
    //成员函数定义
    void CEmployee::setName( char * name) &#123;
        strcpy( szName, name); //ok
    &#125;
    void CEmployee::getName( char * name) &#123;
        strcpy( name,szName); //ok
    &#125;
    void CEmployee::averageSalary(CEmployee e1,CEmployee e2)&#123;
        cout &lt;&lt; e1.szName; //ok，访问同类其他对象私有成员
        salary = (e1.salary + e2.salary )/2;
    &#125;
    
    //使用类和对象
    int main()
    &#123;
        CEmployee e;
        strcpy(e.szName,&quot;Tom1234567889&quot;); //编译错，不能访问私有成员
        e.setName( &quot;Tom&quot;);  // ok
        e.salary = 5000;    //ok
        return 0;
    &#125;
</code></pre>
<p>如果将上面的程序移植到内存空间紧张的设备上，希望将szName改为char szName[5]，若szName不是私有，就要找出所有类似strcpy(e.szName,”Tom1234567889”);这样的语句进行修改，以防止数组越界。如果将szName变为私有，那么程序中就不可能出现（除非在类的内部）strcpy(e.szName,”Tom1234567889”);这样的语句，所有对szName的访问都是通过成员函数来进行，比如：e.setName( “Tom12345678909887”);如果szName改短了，上面的语句也不需要找出来修改，只要改setName成员函数，在里面确保不越界就可以了<br>除了使用类和隐藏机制，C++兼容C的struct结构体，也称为类。和用”class”的唯一区别是未说明是公有还是私有的成员，struct类的所有成员都是公有的。</p>
<pre><code>struct CEmployee &#123;
    char szName[30]; //公有!!
    public :
    int salary; //工资
    void setName(char * name);
    void getName(char * name);
    void averageSalary(CEmployee
    e1,CEmployee e2);
&#125;;
</code></pre>
<h2 id="类成员函数的重载和缺省参数"><a href="#类成员函数的重载和缺省参数" class="headerlink" title="类成员函数的重载和缺省参数"></a>类成员函数的重载和缺省参数</h2><p>同普通函数一样，类封装后的成员函数可以重载，可以有缺省参数</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x=0 , int y = 0 );
    void valueX( int val ) &#123; x = val ;&#125;
    int valueX() &#123; return x; &#125;
&#125;;

void Location::init( int X, int Y)
&#123;
    x = X;
    y = Y;
&#125;

int main() &#123;
    Location A,B;
    A.init(5);  //使用init缺省y=0
    A.valueX(5);    //重载，使用valueX(int)
    cout &lt;&lt; A.valueX();     //重载，使用valueX()
    return 0;
&#125;
</code></pre>
<p>输出：5<br>注意：重载和缺省的函数在调用时可能冲突，存在二义性：</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x =0, int y = 0 );
    void valueX( int val = 0) &#123; x = val; &#125;
    int valueX() &#123; return x; &#125;
&#125;;

Location A;
A.valueX(); //错误，编译器无法判断调用哪个valueX
</code></pre>
<h1 id="类对象的创建与释放"><a href="#类对象的创建与释放" class="headerlink" title="类对象的创建与释放"></a>类对象的创建与释放</h1><h2 id="普通构造函数"><a href="#普通构造函数" class="headerlink" title="普通构造函数"></a>普通构造函数</h2><p>定义一个类只是定义一种数据结构类型，类实例化后在内存中才存在改类的对象。类实例化成对象可以在函数的栈中，或者动态分配在堆中</p>
<pre><code>ClassA a;   //该语句在函数内（如main）时，在main的堆栈中分配内存
ClassA *pa = new ClassA;    //在堆中分配，需要delete手动释放
</code></pre>
<p>那么问题来了，分配的内存里的内容是什么？<br>不知道是什么值，只知道这块内存是被其他进程释放过，当前程序可以读写，释放时不会把值清零。<br>在C语言创建一个结构体变量，可以顺便初始化为全0</p>
<pre><code>StructA a = &#123;0&#125;; //单层结构体
StructB b = &#123;&#123;0&#125;&#125;； //嵌套的结构体
</code></pre>
<p>C++也支持创建类时自动初始化，采用与类同名的成员函数的方法。这就是<strong>构造函数（constructor）</strong><br>构造函数：</p>
<ul>
<li>成员函数的一种，名字与类名相同，可以有参数，不能有返回值(void也不行)</li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作</li>
<li>如果定义了构造函数，则编译器不生成默认的无参数构造函数</li>
<li>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</li>
<li>一个类可以有多个构造函数，即构造函数也可以重载</li>
</ul>
<p>注意：构造函数不负责对象的内存分配，其关键作用是对象成员的值初始化。真正做对象分配的语句通常是new，new做两件事：给类分配内存形成对象，调用对象的构造函数。考虑一下也可知道，连对象都没有的情况，怎么能调用对象的构造函数分配内存呢？注意构造函数不给自身对象分配内存，但是构造函数可以做分配内存操作，比如对指针成员指向的空间分配内存。<br>使用默认构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i);
&#125;; //编译器自动生成默认构造函数
Complex c1; //默认构造函数被调用
Complex * pc = new Complex; //默认构造函数被调用
</code></pre>
<p>使用自定义的带参构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    Complex( double r, double i = 0);
&#125;;
    Complex::Complex( double r, double i) &#123;
    real = r; imag = i;
&#125;

Complex c1; // error, 缺少构造函数的参数
Complex * pc = new Complex; // error, 没有参数
Complex c1(2); // OK
Complex c1(2,4), c2(3,5);
Complex * pc = new Complex(3,4);
</code></pre>
<p>使用重载的构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i );
    Complex(double r, double i );
    Complex (double r );
    Complex (Complex c1, Complex c2);
&#125;;

Complex::Complex(double r, double i)
&#123;
    real = r; imag = i;
&#125;
Complex::Complex(double r)
&#123;
    real = r; imag = 0;
&#125;
Complex::Complex (Complex c1, Complex c2);
&#123;
    real = c1.real+c2.real;
    imag = c1.imag+c2.imag;
&#125;

Complex c1(3) , c2 (1,0), c3(c1,c2);
// c1 = &#123;3, 0&#125;, c2 = &#123;1, 0&#125;, c3 = &#123;4, 0&#125;;
</code></pre>
<p>构造函数应该是public的， private构造函数不能直接用来初始化对象</p>
<pre><code>class CSample&#123;
private:
    CSample() &#123;&#125;
&#125;;

int main()&#123;
    CSample Obj; //err. 唯一构造函数是private
    return 0;
&#125;
</code></pre>
<p>对于多个对象的实例化，可以用对象数组,构造函数的调用次数&#x3D;对象个数，重载哪一个构造函数取决于每个对象的初始化方式。</p>
<pre><code>class CSample &#123;
    int x;
    public:
    CSample() &#123;
        cout &lt;&lt; &quot;Constructor 1 Called&quot; &lt;&lt; endl;
    &#125;
    CSample(int n) &#123;
        x = n;
        cout &lt;&lt; &quot;Constructor 2 Called&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main()&#123;
    CSample array1[2];  //两次默认构造函数
    cout &lt;&lt; &quot;step1&quot;&lt;&lt;endl;
    CSample array2[2] = &#123;4,5&#125;;  //两次带参构造函数
    cout &lt;&lt; &quot;step2&quot;&lt;&lt;endl;
    CSample array3[2] = &#123;3&#125;;    //第一个带参构造，第二个默认构造
    cout &lt;&lt; &quot;step3&quot;&lt;&lt;endl;
    CSample * array4 = new CSample[2];  //两次默认构造
    delete []array4;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Constructor 1 Called
Constructor 1 Called
step1
Constructor 2 Called
Constructor 2 Called
step2
Constructor 2 Called
Constructor 1 Called
step3
Constructor 1 Called
Constructor 1 Called
</code></pre>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>定义：拷贝构造函数(copy constructor)是构造函数的一种，特点是：</p>
<ul>
<li>只有一个参数:对同类对象的引用</li>
<li>入参必须是对象的引用，形如 X::X( X&amp; ) 或 X::X(const X &amp;), 后者以常量对象作为参数</li>
<li>如果用户没有定义拷贝构造函数，编译器生成默认的拷贝构造函数，且它完成复制对象的功能。</li>
</ul>
<p>拷贝构造函数也称为复制构造函数<br>调用形式如下。默认（普通）构造函数和默认拷贝构造函数都是编译生成，且并存的</p>
<pre><code>class Complex &#123;
private :
    double real,imag;
&#125;;
Complex c1; //调用缺省无参构造函数
Complex c2(c1);//调用缺省的复制构造函数,将 c2 初始化成和c1一样
</code></pre>
<p>如果定义的自己的拷贝构造函数，则默认的拷贝构造函数不会生成<br>也就是说，自定义的带参拷贝构造函数和编译器生成的默认拷贝构造函数，不存在重载关系；而一个类有多个自定义的带参拷贝构造函数是允许的，可以重载。这一特点对于普通构造函数一样。</p>
<pre><code>class Complex &#123;
public :
    double real,imag;
    Complex()&#123; &#125;
    Complex( const Complex &amp; c ) &#123;
        real = c.real;
        imag = c.imag;
        cout &lt;&lt; “Copy Constructor called”;
    &#125;
&#125;;
Complex c1;
Complex c2(c1); //调用自己定义的复制构造函数，输出 Copy Constructor called
</code></pre>
<p>注意：拷贝构造函数传入的是同类的引用，而不是同类的对象<br>不允许有形如 X::X( X)的构造函数。因为成员函数入参由实参复制到形参实际会调用拷贝构造函数，拷贝构造函数作为成员函数也是一样，因此会有循环定义，即拷贝构造函数的执行需要调用拷贝构造函数的无限循环，用引用作为入参可以解决此问题。这点类似于C结构体允许有结构体指针成员，指向该结构体类型的实例，而不允许结构体有自身结构体的自接实例，这样会照成分配内存空间上的无限循环。</p>
<pre><code>class CSample &#123;
    CSample( CSample c ) &#123;&#125; //错，不允许这样的构造函数
&#125;
</code></pre>
<h3 id="拷贝构造函数的调用"><a href="#拷贝构造函数的调用" class="headerlink" title="拷贝构造函数的调用"></a>拷贝构造函数的调用</h3><p>以下三种情况会调用类对象的拷贝构造函数<br>1)用一个对象去初始化同类的另一个对象：</p>
<pre><code>Complex c2(c1);
Complex c2 = c1; //初始化语句，非赋值语句
</code></pre>
<p>2)类的对象作为函数入参：如果某函数有参数是类A的对象，那么该函数被调用时，类A的拷贝构造函数将被调用：</p>
<pre><code>class A
&#123;
public:
    A() &#123; &#125;;
    A( A &amp; a) &#123;
        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;
    &#125;
&#125;;

void Func(A a1)&#123; &#125;;
int main()&#123;
    A a2;
    Func(a2);  //传参是类A的对象
    return 0;
&#125;
</code></pre>
<p>输出: Copy constructor called<br>3) 类的对象作为函数返回值：如果函数的返回值是类A的对象，函数返回时，A的拷贝构造函数被调用：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int v;</span><br><span class="line">    A(int n) &#123; v = n; &#125;;</span><br><span class="line">    A( const A &amp; a) &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A Func() &#123;</span><br><span class="line">    A a(4);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; Func().v &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>输出：</p>
<pre><code>Copy constructor called
4
</code></pre>
<p>小结：对象作为入参和返回值会调用拷贝构造函数，对象初始化新对象也会调用。</p>
<h3 id="禁用拷贝构造函数"><a href="#禁用拷贝构造函数" class="headerlink" title="禁用拷贝构造函数"></a>禁用拷贝构造函数</h3><p>Q. 调用拷贝构造函数会形成对象的复制品，开销较大，如何禁用拷贝构造函数？<br>使用对象的引用，不自接把对象作为函数的入参出参。<br>Q.对象的引用会导致新问题：函数内修改了引用怎么办，原对象也会改<br>使用const引用，对象实参就不存在被函数修改的可能<br>使用对象的常引用，应用于对象作为函数入参出参，又不希望调用拷贝构造函数的情况</p>
<pre><code>void fun(const CMyclass &amp; obj) &#123;
//函数中任何试图改变 obj值的语句都将是变成非法
&#125;
</code></pre>
<h3 id="对象的赋值和复制"><a href="#对象的赋值和复制" class="headerlink" title="对象的赋值和复制"></a>对象的赋值和复制</h3><p>注意区分对象的赋值和复制：</p>
<ul>
<li><p>对象赋值是类的所有数据成员的一一对应赋值，其本质是对已分配内存的对象，进行数据成员的初始化</p>
</li>
<li><p>对象复制 &#x3D; 分配新对象对象空间 + 对新对象成员的赋值初始化。对象复制是要包含空间分配操作的</p>
</li>
</ul>
<p>两个已分配内存的对象间的赋值并不会导致拷贝构造函数被调用</p>
<pre><code>//声明及初始化，调用拷贝构造函数
Complex c2 = c1; 
//先声明对象，再赋值,不调用拷贝构造函数，调用默认构造函数然后赋值
Complex c2；
c2 = c1;    
</code></pre>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>当类对象有指针成员时，拷贝构造函数遇到一个问题，是只拷贝指针，还是连同指针指向的空间一起拷贝？</p>
<ul>
<li>浅拷贝：只拷贝指针成员</li>
<li>深拷贝：拷贝指针成员，并拷贝其指向的内存空间数据<br> 由于深拷贝的实现用到“&#x3D;”运算符重载，在运算符重载一节详述</li>
</ul>
<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>构造函数是能创建对象并初始化值的函数，将普通变量转换从类对象并分配内存空间的构造函数是转换构造函数。</p>
<ul>
<li>定义转换构造函数的目的是实现类型的自动转换（变量-&gt;对象）</li>
<li>只有一个参数，且不是拷贝构造函数的构造函数，就是转换构造函数</li>
<li>变量被赋值给对象时，编译器会自动调用转换构造函数，建立一个无名的临时对象</li>
</ul>
<p>隐式的转换构造函数：</p>
<pre><code>    class Complex &#123;
    public:
        double real, imag;
        Complex( int i) &#123;//类型转换构造函数
            cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
            real = i; imag = 0;
        &#125;
        Complex(double r,double i) &#123;real = r; imag = i; &#125;
    &#125;;
    
    int main ()
    &#123;
        Complex c1(7,8);
        Complex c2 = 12;
        c1 = 9;     // 9被自动转换成一个临时Complex对象
        cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
        return 0;
    &#125;
</code></pre>
<p>显式的转换构造函数：</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    explicit Complex( int i) &#123;  //显式类型转换构造函数
        cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
        real = i; imag = 0;
    &#125;
    Complex(double r,double i) &#123;real = r; imag = i; &#125;
&#125;;
int main () &#123;
    Complex c1(7,8);
    Complex c2 = Complex(12);
    c1 = 9;         // error, 9不能被自动转换成一个临时Complex对象
    c1 = Complex(9) //ok
    cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><h3 id="析构函数的概念"><a href="#析构函数的概念" class="headerlink" title="析构函数的概念"></a>析构函数的概念</h3><p>**析构函数(destructors)**用于对象生命周期结束前（如函数中的对象在函数返回时消失），释放对象的内存占用，以及其他的准备工作。<br>构造函数和析构函数在对象生命周期的角色从逻辑上讲是开始和结束的关系，但具体操作不一样：构造函数不为对象分配内存，只给成员赋初值；而析构函数一般要释放对象的内存<br>析构函数的特点：</p>
<ul>
<li>名字与类名相同，在前面加‘~’，没有参数和返回值，一个类最多只能有一个析构函数</li>
<li>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。</li>
<li>如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做</li>
<li>如果定义了析构函数，则编译器不生成缺省析构函数</li>
</ul>
<p>析构函数例子：</p>
<pre><code>class String&#123;
private :
    char * p;
    public:
    String () &#123;
        p = new char[10];
    &#125;
    ~ String () ;
&#125;;

String ::~ String()
&#123;
    delete [] p;
&#125;
</code></pre>
<p>对象数组的生命期结束时，每个对象的析构函数都会被调用。</p>
<pre><code>class Ctest &#123;
public:
    ~Ctest() &#123; cout&lt;&lt; &quot;destructor called&quot; &lt;&lt; endl; &#125;
&#125;;

int main () &#123;
    Ctest array[2];
    cout &lt;&lt; &quot;End Main&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>End Main
destructor called
destructor called
</code></pre>
<h3 id="析构函数的调用"><a href="#析构函数的调用" class="headerlink" title="析构函数的调用"></a>析构函数的调用</h3><p>析构函数被调用有以下几种情况<br>1)delete运算导致析构函数调用：</p>
<pre><code>Ctest * pTest;
pTest = new Ctest;  //构造函数调用
delete pTest;       //析构函数调用
---------------------------------------------------------
pTest = new Ctest[3];   //构造函数调用3次
delete [] pTest;        //析构函数调用3次
</code></pre>
<p>若new一个对象数组，那么用delete释放时应该写 []。否则只delete一个对<br>象(调用一次析构函数)<br>2)析构函数在对象作为函数返回值返回后被调用。其原理是，对象作为函数的入参，出参时，都是临时生成的对象，传完就调用析构函数销毁。</p>
<pre><code>class CMyclass &#123;
public:
    ~CMyclass() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125;
&#125;;
CMyclass obj;
CMyclass fun(CMyclass sobj ) &#123; //参数对象消亡也会导致析
                                //构函数被调用
    return sobj;                //函数调用返回时生成临时对象返回
&#125;
int main()&#123;
    obj = fun(obj); //函数调用的返回值（临时对象）被
    return 0;       //用过后，该临时对象析构函数被调用
&#125;
</code></pre>
<p>输出：</p>
<pre><code>destructor
destructor
destructor
</code></pre>
<h2 id="构造与析构的时序"><a href="#构造与析构的时序" class="headerlink" title="构造与析构的时序"></a>构造与析构的时序</h2><p>总体原则：类似堆栈的先入后出原则：先构造的后析构<br>几个关键分类：<br>临时对象：赋值时创建，赋完值就消亡，生命周期似乎就一条指令<br>局部对象：在{}范围内存在，{}结束时消亡<br>全局、静态对象：从创建开始，在程序整个运行期间存在，程序结束时消亡。<br>一个例子：</p>
<pre><code>class Demo &#123;
        int id;
    public:
        Demo(int i) &#123;
            id = i;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;
        &#125;
        ~Demo() &#123;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; destructed&quot; &lt;&lt; endl;
        &#125;
&#125;;

Demo d1(1);
void Func()
&#123;
    static Demo d2(2);
    Demo d3(3);
    cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;
&#125;

int main () &#123;
    Demo d4(4);
    d4 = 6;
    cout &lt;&lt; &quot;main&quot; &lt;&lt; endl;
    &#123; 
        Demo d5(5);
    &#125;
    Func();
    cout &lt;&lt; &quot;main ends&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出结果:</p>
<pre><code>id=1 constructed    //全局对象d1
id=4 constructed    //构造函数d4
id=6 constructed    //转换构造函数d4
id=6 destructed     //临时对象赋值完毕，消亡
main
id=5 constructed    //构造函数d5
id=5 destructed     //d5作用域结束，消亡
id=2 constructed    //Fun构造静态对象d2(等同全局对象)
id=3 constructed    //构造局部对象d3
func
id=3 destructed     //Fun返回，d3消亡
main ends       
id=6 destructed     //Main的局部对象d4消亡（id=6）
id=2 destructed     //整个程序结束，全局对象d2消亡
id=1 destructed     //整个程序结束，全局对象d1消亡
</code></pre>
<h1 id="类对象的指针：this指针"><a href="#类对象的指针：this指针" class="headerlink" title="类对象的指针：this指针"></a>类对象的指针：this指针</h1><p>this指针是在类成员函数内，指向当前类对象的指针。<br>注意：</p>
<ul>
<li>this指针是指向当前对象的，所谓当前，是指调用成员函数时，是通过所在的对象的指针来调用</li>
<li>this指针体现的是成员函数和对象的关系，如果是静态成员函数，没有this指针，因为静态成员函数不从属于对象</li>
</ul>
<p>为什么this指针如此特殊，需要单独命名？这涉及到C++的类的实现原理。</p>
<h2 id="C-的类与C的结构体"><a href="#C-的类与C的结构体" class="headerlink" title="C++的类与C的结构体"></a>C++的类与C的结构体</h2><p>在C++早期，C++代码被编译器翻译成C代码，再由C编译器编译<br>类的实现原理和C的结构体有密切关系，下面是类和结构体的转换：<br>1)C++的类：</p>
<pre><code>class CCar &#123;
    public:
        int price;
        void SetPrice(int p);
&#125;;

void CCar::SetPrice(int p)
&#123; price = p; &#125;

int main()
&#123;
    CCar car;
    car.SetPrice(20000);
    return 0;
&#125;
</code></pre>
<p>2)C的结构体实现类的功能</p>
<pre><code>struct CCar &#123;
    int price;
&#125;;

void SetPrice(struct CCar * this, int p)
&#123; this-&gt;price = p; &#125;

int main() &#123;
    struct CCar car;
    SetPrice( &amp; car,
    20000);
    return 0;
&#125;
</code></pre>
<p>用C实现面向对象(CCar结构体)，方法(SetPrice)传入的参数是结构体对象的指针(struct CCar * this)</p>
<h2 id="C-的this指针"><a href="#C-的this指针" class="headerlink" title="C++的this指针"></a>C++的this指针</h2><p>成员函数（非static）可以直接使用this来代表指向该函数作用的对象的指针</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    void Print() &#123; cout &lt;&lt; real &lt;&lt; &quot;,&quot; &lt;&lt; imag ; &#125;
    Complex(double r,double i):real(r),imag(i)&#123; &#125;   //初始化列表
    Complex AddOne() &#123;
        this-&gt;real ++;  //等价于 real++
        this-&gt;Print();  //等价于 Print()
        return * this;
    &#125;
&#125;;

int main() &#123;
    Complex c1(1,1),c2(0,0);
    c2 = c1.AddOne();
    return 0;
&#125; //输出 2,1
</code></pre>
<p>对象的this指针通常隐式存在：</p>
<ul>
<li>成员函数（非static）的入参实际隐式地有一个this指针参数</li>
<li>成员函数访问成员变量，也是隐式的通过this指针访问</li>
<li>通过对象的指针调用成员函数，本质也是传入this指针</li>
</ul>
<p>如果成员函数不访问成员变量，可以传入NULL的对象指针：</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  //等价于 void Hello(A * this ) &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p)
&#125; // 输出： hello
</code></pre>
<p>如果成员函数访问了成员变量，实际是通过成员函数传入的this指针来访问，此时指针不可为NULL</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  
//等价于void Hello(A * this ) &#123; cout &lt;&lt; this-&gt;i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
//this若为NULL，则出错！！
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p);
&#125; //出错
</code></pre>
<h2 id="静态成员的概念"><a href="#静态成员的概念" class="headerlink" title="静态成员的概念"></a>静态成员的概念</h2><p>静态成员：在定义前面加了static关键字的成员、</p>
<pre><code>class CRectangle
&#123;
    private:
    int w, h;
    static int nTotalArea; //静态成员变量
    static int nTotalNumber;
    public:
    CRectangle(int w_,int h_);
    ~CRectangle();
    static void PrintTotal(); //静态成员函数
&#125;;
</code></pre>
<ul>
<li>普通成员变量每个对象有各自的一份；而静态成员变量是全局共有的一份，为所有对象共享</li>
<li>同一个类的成员函数，不论静不静态都是一份代码段</li>
<li>普通成员函数必须具体作用于某个对象（也可以理解为绑定），而静态成员函数并不具体作用于某个对象</li>
<li>因此静态成员（变量或者函数），不需要通过对象就能访问</li>
</ul>
<p>sizeof求类大小，不会计算静态成员变量，因为不属于类的一部分（从空间占用上讲）。</p>
<pre><code>class CMyclass &#123;
int n;
static int s;
&#125;;  // sizeof(CMyclass) 等于 4
</code></pre>
<h2 id="访问静态成员"><a href="#访问静态成员" class="headerlink" title="访问静态成员"></a>访问静态成员</h2><p>一下几种方法访问,可以归纳为两种：通过类名访问，通过对象访问<br>1)类名::成员名</p>
<pre><code>CRectangle::PrintTotal();
</code></pre>
<p>2)对象名.成员名</p>
<pre><code>CRectangle r; 
r.PrintTotal();
</code></pre>
<p>3)指针-&gt;成员名</p>
<pre><code>CRectangle * p = &amp;r; 
p-&gt;PrintTotal();
</code></pre>
<p>4)引用.成员名</p>
<pre><code>CRectangle &amp; ref = r; 
int n = ref.nTotalNumber;
</code></pre>
<h2 id="静态成员函数与this指针"><a href="#静态成员函数与this指针" class="headerlink" title="静态成员函数与this指针"></a>静态成员函数与this指针</h2><ul>
<li>静态成员函数中不能使用 this 指针！</li>
<li>因为静态成员函数并不具体作用与某个对象!</li>
<li>因此静态成员函数的真实的参数的个数，就是程序中写出的参数个数！</li>
</ul>
<p>前面讲，C++的作用是封装数据，静态成员似乎破坏这一目的，那么静态成员有什么作用？<br>为了兼容C的全局变量与函数</p>
<ul>
<li>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在</li>
<li>静态成员函数本质上是全局函数</li>
<li>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解</li>
</ul>
<h2 id="静态成员函数的使用场景"><a href="#静态成员函数的使用场景" class="headerlink" title="静态成员函数的使用场景"></a>静态成员函数的使用场景</h2><p>对于需要全局维护的数据，可以使用静态成员变量，并通过静态成员函数访问。<br>考虑一个图形处理程序，需要随时知道矩形的总数和总面积</p>
<ul>
<li>每个矩形封装成类的对象</li>
<li>总数和总面积是类的静态成员（等价于全局变量）</li>
</ul>
<p>类定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CRectangle</span><br><span class="line">    &#123;</span><br><span class="line">    private:</span><br><span class="line">        int w, h;</span><br><span class="line">        static int nTotalArea;</span><br><span class="line">        static int nTotalNumber;</span><br><span class="line">    public:</span><br><span class="line">        CRectangle(int w_,int h_);</span><br><span class="line">        ~CRectangle();</span><br><span class="line">        static void PrintTotal();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数定义：</p>
<pre><code>CRectangle::CRectangle(int w_,int h_)
&#123;
    w = w_;
    h = h_;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
CRectangle::~CRectangle()
&#123;
    nTotalNumber --;
    nTotalArea -= w * h;
&#125;
void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl;
&#125;
</code></pre>
<p>类对象的调用：</p>
<pre><code>int CRectangle::nTotalNumber = 0;
int CRectangle::nTotalArea = 0;
// 必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。
int main()
&#123;
    CRectangle r1(3,3), r2(2,2);
    //cout &lt;&lt; CRectangle::nTotalNumber; 
    //错误 , 静态的私有变量也只能通过成员函数访问，静态不等于全局可访问
    CRectangle::PrintTotal();
    r1.PrintTotal();
    return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>2,13
2,13
</code></pre>
<p>注意两点：</p>
<ul>
<li>静态成员变量是全局共有的一份存储，但private的静态成员只能通过类的成员函数访问。注意区分全局存储和全局访问，静态成员只有全局存储特性，没有全局可访问特性。</li>
<li>静态成员函数，不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
<p>以下静态成员函数访问错误：</p>
<pre><code>void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; w &lt;&lt; &quot;,&quot; &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl; //错误
&#125;
CRetangle::PrintTotal(); //解释不通 w 到底是属于那个对象的
</code></pre>
<p> 以上例子还有缺陷：<br> 在使用静态成员时，特别是类的构造和析构会修改该静态成员，如前文的CRectangle类的构造函数有nTotalNumber++操作，析构有nTotalNumber–。这个时候要考虑构造和析构函数是否覆盖到所有类型（普通构造，拷贝构造，转换构造）<br> 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象：</p>
<ul>
<li>调用一个以CRectangle类对象作为参数的函数时</li>
<li>调用一个以CRectangle类对象作为返回值的函数时</li>
</ul>
<p>临时对象在消亡时会调用析构函数，减少nTotalNumber和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber和nTotalArea的值，因为设计类时漏掉了拷贝构造的情况<br>解决办法：为CRectangle类写一个拷贝构造函数：</p>
<pre><code>CRectangle :: CRectangle(CRectangle &amp; r )
&#123;
    w = r.w; h = r.h;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
</code></pre>
<p>这样nTotalNumber和nTotalArea全局计数就是准确的</p>
<h1 id="类的嵌套：封闭类"><a href="#类的嵌套：封闭类" class="headerlink" title="类的嵌套：封闭类"></a>类的嵌套：封闭类</h1><h2 id="封闭类的基本概念"><a href="#封闭类的基本概念" class="headerlink" title="封闭类的基本概念"></a>封闭类的基本概念</h2><p>再来把C++的类和C结构体对比下：</p>
<ul>
<li>C：结构体的成员可以是基础变量，基础变量的指针，结构体的指针，其他复合类型的指针</li>
<li>C++：类的成员变量可以是基础变量，及其指针、引用，可不可以是类对象？类对象的引用和指针？</li>
</ul>
<p>于是引入类嵌套类对象的情况：有成员对象的类叫封闭类（enclosing class)<br>一个示例：写一个汽车类，包含轮胎和引擎类对象<br>轮胎和引擎类：</p>
<pre><code>class CTyre //轮胎类
    &#123;
    private:
        int radius; //半径
        int width; //宽度
    public:
        CTyre(int r,int w):radius(r),width(w) &#123; &#125;   //用初始化列表构造
    &#125;;
    
class CEngine //引擎类
&#123;
&#125;;
</code></pre>
<p>汽车类：</p>
<pre><code>class CCar &#123; //汽车类
private:
    int price; //价格
    CTyre tyre;
    CEngine engine;
public:
    CCar(int p,int tr,int tw );
&#125;;
CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw) //用初始化列表构造
&#123;
&#125;;
</code></pre>
<p>汽车类的使用：</p>
<pre><code>int main()
&#123;
    CCar car(20000,17,225); //传入初始化列表
    return 0;
&#125;
</code></pre>
<h2 id="初始化列表构造封闭类"><a href="#初始化列表构造封闭类" class="headerlink" title="初始化列表构造封闭类"></a>初始化列表构造封闭类</h2><p>对于封闭类，有几个问题就凸显出来：</p>
<ul>
<li>构造一个封闭类，还要构造其嵌套的类</li>
<li>构造时序是怎样的</li>
<li>析构时序是怎样的</li>
</ul>
<p>上例中，如果 CCar类不定义构造函数，下面的语句会编译出错：CCar car;<br>因为CCar不传初始化值给嵌套类CTyre，编译器不知道该如何初始化car.tyre的成员变量<br>而car.engine的初始化没问题，因为不用初始化成员变量，用默认构造函数即可<br>为了解决封闭类的嵌套类成员的初始化问题，构造函数引入新的初始化方法：</p>
<ul>
<li>初始化列表：将成员初始化从构造函数体，移到函数名后面，只是换了形式，但是方便了封闭类各嵌套类的初始化，不用开发者自己到函数体写构造函数内容</li>
<li>成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。</li>
</ul>
<p>封闭类都是通过构造函数的初始化列表，层层传入嵌套类的构造函数：</p>
<pre><code>CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw)&#123;&#125;;
//p, tr, tw是传入的初始化值; price,tyre是CCar对象的两个成员
CCar car(20000,17,225);
//Car的price = 20000, Car的tyre的radius = 17，width = 225
</code></pre>
<p> 上例是普通构造函数，对于封闭类的拷贝构造函数：</p>
<ul>
<li>封闭类对象是用拷贝构造函数初始化的，其成员对象也用拷贝构造函数初始化</li>
</ul>
<p>测试用例：</p>
<pre><code>class A
&#123;
public:
    A() &#123; cout &lt;&lt; &quot;default&quot; &lt;&lt; endl; &#125;
    A(A &amp; a) &#123; cout &lt;&lt; &quot;copy&quot; &lt;&lt; endl;&#125;
&#125;;
class B &#123; A a; &#125;;

int main()
&#123;
    B b1,b2(b1);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>default
Copy
</code></pre>
<p>下面考虑封闭类构造和析构的时序</p>
<ul>
<li>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数、</li>
<li>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关</li>
<li>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反</li>
</ul>
<p>一个测试示例</p>
<pre><code>class CTyre &#123;
    public:
        CTyre() &#123; cout &lt;&lt; &quot;CTyre contructor&quot; &lt;&lt; endl; &#125;
        ~CTyre() &#123; cout &lt;&lt; &quot;CTyre destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CEngine &#123;
    public:
        CEngine() &#123; cout &lt;&lt; &quot;CEngine contructor&quot; &lt;&lt; endl; &#125;
        ~CEngine() &#123; cout &lt;&lt; &quot;CEngine destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CCar &#123;
    private:
        CEngine engine;
        CTyre tyre;
    public:
        CCar( ) &#123; cout &lt;&lt; “CCar contructor” &lt;&lt; endl; &#125;
        ~CCar() &#123; cout &lt;&lt; &quot;CCar destructor&quot; &lt;&lt; endl; &#125;
&#125;;

int main()&#123;
CCar car;
return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>CEngine contructor
CTyre contructor
CCar contructor
CCar destructor
CTyre destructor
CEngine destructor
</code></pre>
<h1 id="类的成员属性：友元和常量成员"><a href="#类的成员属性：友元和常量成员" class="headerlink" title="类的成员属性：友元和常量成员"></a>类的成员属性：友元和常量成员</h1><h2 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h2><p>友元(friend)分为友元函数和友元类两种<br>一个类的private成员，只能通过类自己的成员函数访问，那么其他类的成员函数想访问这个类的private成员怎么办？友元可以解决这种需求</p>
<ol>
<li><p>友元函数: 一个类的友元函数可以访问该类的私有成员<br>即类A内可以声明其他类B的成员函数或者全局函数，加前缀friend，这些以friends开头的函数就可访问类A的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class CCar ; //提前声明 CCar类，以便后面的CDriver类使用</span><br><span class="line"> class CDriver</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">         void ModifyCar( CCar * pCar) ; //改装汽车</span><br><span class="line"> &#125;;</span><br><span class="line"> class CCar</span><br><span class="line"> &#123;</span><br><span class="line">     private:</span><br><span class="line">         int price;</span><br><span class="line">         friend int MostExpensiveCar( CCar cars[], int total); //声明友元</span><br><span class="line">         friend void CDriver::ModifyCar(CCar * pCar); //声明友元</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> void CDriver::ModifyCar( CCar * pCar)</span><br><span class="line"> &#123;</span><br><span class="line">     pCar-&gt;price += 1000; //访问CCar成员，汽车改装后加价</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int MostExpensiveCar( CCar cars[],int total)//求最贵汽车的价格</span><br><span class="line"> &#123;</span><br><span class="line">     int tmpMax = -1;</span><br><span class="line">     for( int i = 0;i &lt; total; ++i )</span><br><span class="line">     if( cars[i].price &gt; tmpMax) //访问CCar成员</span><br><span class="line">     tmpMax = cars[i].price;</span><br><span class="line">     return tmpMax;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了普通成员函数，也可以将类构造、析构函数说明为另一个类的友元</p>
<p>2)友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员<br>如果是类的嵌套（封闭类），声明为friend的类A可以调用自己的成员函数访问与它为friend关系的类B的私有成员，而不必调用类B的成员函数。</p>
<pre><code>class CCar
&#123;
private:
    int price;
    friend class CDriver; //声明CDriver为友元类
&#125;;
class CDriver
&#123;
public:
    CCar myCar;
    void ModifyCar() &#123;  //改装汽车
    myCar.price += 1000;   //因CDriver是CCar的友元类，故此处可以访问其私有成员
    &#125;
&#125;;

int main()&#123; return 0; &#125;
</code></pre>
<p>友元类之间的关系不能传递，不能继承。就是说A和B是friend,B和C是friend,但A和C不一定是friend。父类之间的friend关系，子类不一定能传承。</p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>如果不希望某个对象的值被改变，定义该对象的时候可以在前面加 const关键字<br>在类的成员函数说明后面加const关键字，则该成员函数成为常量<br>成员函数。<br>常量成员函数内部不能改变属性的值，也不能调用非常量成员函数<br>在定义常量成员函数和声明常量成员函数时都应该使用const 关键字。</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void PrintValue() const;
&#125;;
void Sample::PrintValue() const &#123;             //此处不使用const会导致编译出错
    cout &lt;&lt; value;
&#125;
void Print(const Sample &amp; o) &#123;
    o.PrintValue(); 
&#125;//若 PrintValue非const则编译错
</code></pre>
<p>以下是错误示例：</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void func() &#123; &#125;;
    Sample() &#123; &#125;
    void SetValue() const &#123;
        value = 0; // wrong
        func(); //wrong
    &#125;
&#125;;
const Sample Obj;
Obj.SetValue (); //常量对象上可以使用常量成员函数
</code></pre>
<p>什么场景定义成常量成员函数？<br>如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，最好将其写成常量成员函数</p>
<p>常量成员函数的重载：<br>两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载关系，而非重定义。</p>
<h1 id="类的运算：运算符重载"><a href="#类的运算：运算符重载" class="headerlink" title="类的运算：运算符重载"></a>类的运算：运算符重载</h1><p>C++定义了类，可以像基本类型那样创建、销毁、初始化。那么类和类之间的运算呢？<br>+、 -、 *、 &#x2F;、 %、 ^、 &amp;、 ~、 !、 |、 &#x3D;、 &lt;&lt; 、&gt;&gt;、 !&#x3D;、<br>考虑以下方法实现类的运算：</p>
<ul>
<li>设计类的成员函数，支持类运算操作</li>
<li>设计某种机制，把运算符关联成函数操作，在函数内定义具体类运算方法。进行类的运算时，形式上可以像基本类型的运算一样</li>
</ul>
<p>例如complex_a和complex_b是两个复数对象；求两个复数的和, 希望能直接写：complex_a + complex_b<br>运算符重载将解决类和对象的运算需求</p>
<h2 id="运算符重载的概念"><a href="#运算符重载的概念" class="headerlink" title="运算符重载的概念"></a>运算符重载的概念</h2><p>运算符重载，就是对已有的运算符(C++中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为<br>运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象<br>期望效果:同一个运算符，对不同类型的操作数，所发生的行为不同</p>
<pre><code>complex_a + complex_b //生成新的复数对象
5 + 4 = 9 //基本运算符操作
</code></pre>
<p>从行为上看，运算符重载类似于把运算符进行了重定义成函数操作（类似C的typedef）<br>运算符重载写法：</p>
<pre><code>返回值类型 operator 运算符（形参表）
&#123;
……  //定义该运算符的运算规则
&#125;
</code></pre>
<p>示例：</p>
<pre><code>class Complex
&#123;
public:
    double real,imag;
    Complex( double r = 0.0, double i= 0.0):real(r),imag(i) &#123; &#125;
    Complex operator-(const Complex &amp; c);
&#125;;
Complex operator+( const Complex &amp; a, const Complex &amp; b)
&#123;
    return Complex( a.real+b.real,a.imag+b.imag); //返回一个临时对象
&#125;
Complex Complex::operator-(const Complex &amp; c)
&#123;
    return Complex(real - c.real, imag - c.imag); //返回一个临时对象
&#125;

int main()
&#123;
    Complex a(4,4),b(1,1),c;
    c = a + b; //等价于c=operator+(a,b);
    cout &lt;&lt; c.real &lt;&lt; &quot;,&quot; &lt;&lt; c.imag &lt;&lt; endl;
    cout &lt;&lt; (a-b).real &lt;&lt; &quot;,&quot; &lt;&lt; (a-b).imag &lt;&lt; endl;
    //a-b等价于a.operator-(b)
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>5,5
3,3
</code></pre>
<p>c &#x3D; a + b; 等价于c&#x3D;operator+(a,b);<br>a-b 等价于a.operator-(b)<br>运算符重载的实现还是成员函数，所以是依赖于对象的。也就是说，运算符重载看上去和类、对象没啥关系，但本质上，重载的运算符是归属于某个类的，因为a-b只是表象现象，真正定义对象运算的，是a.operator-(b)成员函数。<br>因为运算符重载依赖对象的，因此双目运算，如+，-，在运算符重载时只需要传入另一个对象，而不需要传运算符的当前对象。<br>重载为成员函数时， 参数个数为运算符目数减一。<br>重载为普通函数时， 参数个数为运算符目数</p>
<p>运算符重载概念小结：</p>
<ul>
<li>运算符重载的实质是函数重载</li>
<li>可以重载为普通函数，也可以重载为成员函数</li>
<li>把含运算符的表达式转换成对运算符函数的调用</li>
<li>把运算符的操作数转换成运算符函数的参数</li>
<li>运算符被多次重载时，根据实参的类型决定调用哪个运算符函数</li>
</ul>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><p>接下来的几节讲几个代表性的运算符重载。本节讲赋值运算符“&#x3D;”有时候希望赋值运算符两边的类型可以不匹配，比如，把一个int类型变量赋值给一个Complex对象，或把一个 char *类型的字符串赋值给一个字符串对象,此时就需要重载赋值运算符“&#x3D;”。<br>赋值运算符“ &#x3D;”只能重载为成员函数</p>
<p>示例：</p>
<pre><code>class String &#123;
private:
    char * str;
    public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s);
    String::~String( ) &#123; delete [] str; &#125;
&#125;;
String &amp; String::operator = (const char * s)
&#123; //重载“=”以使得 obj = “hello”能够成立
    delete [] str;
    str = new char[strlen(s)+1];
    strcpy( str, s);
    return * this;
&#125;

int main()
&#123;
    String s;
    s = &quot;Good Luck,&quot; ; //等价于 s.operator=(&quot;Good Luck,&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    // String s2 = &quot;hello!&quot;; //这条语句要是不注释掉就会出错
    s = &quot;Shenzhou 8!&quot;; //等价于 s.operator=(&quot;Shenzhou 8!&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Good Luck,
Shenzhou 8!
</code></pre>
<h2 id="赋值运算符与深拷贝"><a href="#赋值运算符与深拷贝" class="headerlink" title="赋值运算符与深拷贝"></a>赋值运算符与深拷贝</h2><p>在类与对象的拷贝构造函数一节讲了拷贝构造函数的作用：用一个已经初始化的对象，去初始化另一个对象，具体操作是讲成员变量一一赋值。<br>那么更深入考虑一下:对于各种类型的成员变量，能不能达到目的？</p>
<ul>
<li>对于基础类型的成员变量，如int,char，直接赋值即可</li>
<li>对于指针类型的成员变量，给指针赋值就Ok?需不需要给指针指向的空间也赋值？</li>
<li>对于引用类型的成员变量，直接赋值OK?</li>
<li>对于类对象类型的成员变量，怎么赋值？嵌套调用拷贝构造函数？</li>
</ul>
<p>引用只是标签，可以直接拷贝，等同变量拷贝。封闭类的构造函数会嵌套调用基础类型的拷贝，直到所有成员赋值完为止。<br>唯一需要考虑的是包含指针类型成员的类如何拷贝<br>如果直接赋值指针而不分配并初始化其指向空间，效果如下:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081648147.png" alt="image-20221208164831061"><br>如不定义自己的赋值运算符，那么S1&#x3D;S2实际上导致 S1.str和 S2.str<br>指向同一地方。<br>如果S1对象消亡，析构函数将释放 S1.str指向的空间，则S2消亡时还<br>要释放一次，就形成两次delete错误!<br>如果执行 S1 &#x3D; “other”；会导致S2.str指向的地方被delete</p>
<p>为了解决以上问题，类的拷贝构造不仅要拷贝指针，还有拷贝指针指向的空间（分配新内存+拷贝）。这种带内存分配的拷贝称为深拷贝</p>
<ul>
<li>浅拷贝：只拷贝成员，对于指针成员，也只拷贝指针变量</li>
<li>深拷贝：拷贝成员，对于指针成员，拷贝指针变量，且拷贝指针指向的内存空间</li>
</ul>
<p>为了实现深拷贝，需要重载“&#x3D;”运算符：</p>
<pre><code>String &amp; operator = (const String &amp; s) &#123;
    delete [] str;  //先释放指针原本指向的空间,因为新空间和原空间大小可能不一样
    str = new char[strlen( s.str)+1];   //分配指针指向的新空间
    strcpy( str,s.str); //新空间赋值初始化
    return * this;  //返回当前对象的指针
&#125;
</code></pre>
<p>还有可优化的，如果传入对象就是当前对象，没必要释放又分配，直接返回即可</p>
<pre><code>String &amp; operator = (const String &amp; s)&#123;
    if( this == &amp; s)
        return * this;
    delete [] str;
    str = new char[strlen(s.str)+1];
    strcpy( str,s.str);
    return * this;
&#125;
</code></pre>
<p>整个类设计如下：</p>
<pre><code>class String &#123;
private:
    char * str;
public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s)&#123;
        delete [] str;
        str = new char[strlen(s)+1];
        strcpy( str, s);
        return * this;
&#125;;
    ~String( ) &#123; delete [] str; &#125;
&#125;;
</code></pre>
<p>再考虑一下运算符重载函数的返回值<br>为什么返回String &amp;<br>原因：对运算符进行重载的时候，好的风格是尽量保留运算符原本的特性<br>例如运算符是可以多个连续运算的</p>
<pre><code>a = b = c;
(a=b)=c; //会修改a的值
</code></pre>
<p>分别等价于：</p>
<pre><code>a.operator=(b.operator=(c));
(a.operator=(b)).operator=(c);
</code></pre>
<p>对于拷贝构造函数，原指针未初始化，不指向任何空间，直接分配空间在拷贝即可，写法如下：</p>
<pre><code>String( String &amp; s)
&#123;
    str = new char[strlen(s.str)+1];
    strcpy(str,s.str);
&#125;
</code></pre>
<h2 id="流运算符的重载"><a href="#流运算符的重载" class="headerlink" title="流运算符的重载"></a>流运算符的重载</h2><p>C++常用的输入输出是怎么实现的？</p>
<pre><code>cout &lt;&lt; 5 &lt;&lt; “this”;
</code></pre>
<ul>
<li>cout是什么?</li>
<li>“&lt;&lt;”原本是位偏移运算，为什么能作用于cout?</li>
<li>“&lt;&lt;”怎么支持连续运算，且支持多种类型</li>
</ul>
<p>原因就是&lt;&lt;被流运算类重载了。</p>
<ul>
<li>cout是在iostream中定义的，ostream类的对象</li>
<li>“&lt;&lt;” 能用在cout上是因为，在iostream里对“ &lt;&lt;” 进行了重载</li>
<li>运算符重载函数返回对象的引用，实现连续运算；多个运算符重载函数的重载，支持多种类型</li>
</ul>
<p>实现方法：</p>
<pre><code>ostream &amp; ostream::operator&lt;&lt;(int n)
&#123;
    …… //输出n的代码
    return * this;
&#125;
ostream &amp; ostream::operator&lt;&lt;(const char * s )
&#123;
    …… //输出s的代码
    return * this;
&#125;
</code></pre>
<p>cout &lt;&lt; 5 &lt;&lt; “this”;<br>等价于： cout.operator&lt;&lt;(5).operator&lt;&lt;(“this”);<br>一个流运算符重载的示例：<br>假定c是Complex复数类的对象，现在希望写“ cout &lt;&lt; c;”，就能以“ a+bi”的形式输出c的值，写“ cin&gt;&gt;c;”，就能从键盘接受“ a+bi”形式的输入，并且使得c.real &#x3D; a,c.imag &#x3D; b</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
using namespace std;
class Complex &#123;
    double real,imag;
    public:
    Complex( double r=0, double i=0):real(r),imag(i)&#123; &#125;;
    friend ostream &amp; operator&lt;&lt;( ostream &amp; os, const Complex &amp; c);
    friend istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c);
&#125;;
ostream &amp; operator&lt;&lt;( ostream &amp; os,const Complex &amp; c)
&#123;
    os &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; //以&quot;a+bi&quot;的形式输出
    return os;
&#125;
   
istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c)
&#123;
    string s;
    is &gt;&gt; s; //将&quot;a+bi&quot;作为字符串读入, “a+bi”中间不能有空格
    int pos = s.find(&quot;+&quot;,0);
    string sTmp = s.substr(0,pos); //分离出代表实部的字符串
    c.real = atof(sTmp.c_str()); //atof库函数能将const char*指针指向的内容转换成 float
    sTmp = s.substr(pos+1, s.length()-pos-2); //分离出代表虚部的字符串
    c.imag = atof(sTmp.c_str());
    return is;
&#125;

int main()
&#123;
    Complex c;
    int n;
    cin &gt;&gt; c &gt;&gt; n;
    cout &lt;&lt; c &lt;&lt; &quot;,&quot; &lt;&lt; n;
    return 0;
&#125;
</code></pre>
<p>运行结果可以如下：</p>
<pre><code>13.2+133i 87    //输入
13.2+133i, 87   //输出
</code></pre>
<h2 id="其他运算符重载"><a href="#其他运算符重载" class="headerlink" title="其他运算符重载"></a>其他运算符重载</h2><p>类型转换运算符”()”重载：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
    double real,imag;
    public:
    Complex(double r=0,double i=0):real(r),imag(i) &#123; &#125;;
    operator double () &#123; return real; &#125;
    //重载强制类型转换运算符 double
&#125;;
int main()
&#123;
    Complex c(1.2,3.4);
    cout &lt;&lt; (double)c &lt;&lt; endl; //输出 1.2
    double n = 2 + c; //等价于 double n=2+c.operator double()
    cout &lt;&lt; n; //输出 3.2
&#125;
</code></pre>
<p>自增自减运算符”++,–”的重载：<br>自增运算符++、自减运算符–有前置&#x2F;后置之分，为了区分所重载的是前置运算符还是后置运算符， C++规定：</p>
<ul>
<li>前置运算符作为一元运算符重载</li>
<li>后置运算符作为二元运算符重载，多写一个没用的参数</li>
</ul>
<p>前置运算符重载形式：</p>
<pre><code>重载为成员函数：
T &amp; operator++();   //不用写入参，当前对象的成员++
T &amp; operator--();
重载为全局函数：
T1 &amp; operator++(T2);
T1 &amp; operator—(T2);
</code></pre>
<p>后置运算符重载形式：    </p>
<pre><code>重载为成员函数：
T operator++(int);  //多写一个入参，用于和前置重载区分
T operator--(int);
重载为全局函数：
T1 operator++(T2,int );
T1 operator—( T2,int);
</code></pre>
<p>调用示例：</p>
<pre><code>int main()
&#123;
    CDemo d(5);
    cout &lt;&lt; (d++ ) &lt;&lt; &quot;,&quot;; //等价于 d.operator++(0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (++d) &lt;&lt; &quot;,&quot;; //等价于 d.operator++();
    cout &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; (d-- ) &lt;&lt; &quot;,&quot;; //等价于 operator--(d,0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (--d) &lt;&lt; &quot;,&quot;; //等价于 operator--(d);
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
&#125;

class CDemo &#123;
private :
    int n;
    public:
    CDemo(int i=0):n(i) &#123; &#125;
    CDemo &amp; operator++(); //用于前置形式
    CDemo operator++( int ); //用于后置形式
    operator int ( ) &#123; return n; &#125;
    friend CDemo &amp; operator--(CDemo &amp; );
    friend CDemo operator--(CDemo &amp; ,int);
&#125;;
CDemo &amp; CDemo::operator++()
&#123; //前置 ++
    n ++;
    return * this;
&#125; // ++s即为: s.operator++();

CDemo CDemo::operator++( int k )
&#123; //后置 ++
    CDemo tmp(*this); //记录修改前的对象
    n ++;
    return tmp; //返回修改前的对象
&#125; // s++即为: s.operator++(0);
CDemo &amp; operator--(CDemo &amp; d)
&#123;//前置--
    d.n--;
    return d;
&#125; //--s即为: operator--(s);
CDemo operator--(CDemo &amp; d,int)
&#123;//后置--
    CDemo tmp(d);
    d.n --;
    return tmp;
&#125; //s--即为: operator--(s, 0);
</code></pre>
<h2 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h2><ul>
<li>C++不允许定义新的运算符</li>
<li>重载后运算符的含义应该符合日常习惯，即保留原运算符的使用风格</li>
<li>运算符重载不改变运算符的优先级</li>
<li>以下运算符不能被重载：“ .” “ .*” “ ::” “ ?:” “sizeof”</li>
<li>重载运算符()、[]、-&gt;、&#x3D;，运算符重载函数必须声明为<br>类的成员函数</li>
</ul>
<h2 id="运算符重载的综合示例"><a href="#运算符重载的综合示例" class="headerlink" title="运算符重载的综合示例"></a>运算符重载的综合示例</h2><p>实现一个可变长数组类型CArray，实现如下用例：</p>
<pre><code>int main() &#123; 
    CArray a; //开始里的数组是空的
    for( int i = 0;i &lt; 5;++i)
        a.push_back(i); //要用动态分配的内存来存放数组元素，需要一个指针成员变量
    CArray a2,a3;
    a2 = a; //要重载“=”
    for( int i = 0; i &lt; a.length(); ++i )
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot; ;  //要重载[]
    a2 = a3; //a2是空的
    for( int i = 0; i &lt; a2.length(); ++i )//a2.length()返回0
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    a[3] = 100;
    CArray a4(a);   //要自己写拷贝构造函数
    for( int i = 0; i &lt; a4.length(); ++i )
        cout &lt;&lt; a4[i] &lt;&lt; &quot; &quot;;
    return 0;
&#125;
</code></pre>
<p>CArray类的设计：</p>
<pre><code>class CArray &#123;
    int size; //数组元素的个数
    int *ptr; //指向动态分配的数组
    public:
    CArray(int s = 0); //s代表数组元素的个数
    CArray(CArray &amp; a);
    ~CArray();
    void push_back(int v); //用于在数组尾部添加一个元素v
    CArray &amp; operator=( const CArray &amp; a);
    //用于数组对象间的赋值
    int length() &#123; return size; &#125; //返回数组元素个数
    int &amp; CArray::operator[](int i) //返回值为 int 不行!不支持 a[i] = 4
    &#123;//用以支持根据下标访问数组元素，如n = a[i] 和a[i] = 4; 这样的语句
        return ptr[i];
    &#125;
&#125;;
</code></pre>
<p>成员函数的实现：</p>
<pre><code>CArray::CArray(int s):size(s)
&#123;
    if( s == 0)
    ptr = NULL;
    else
    ptr = new int[s];
&#125;
CArray::CArray(CArray &amp; a) &#123;
    if( !a.ptr) &#123;
    ptr = NULL;
    size = 0;
    return;
    &#125;
    ptr = new int[a.size];
    memcpy( ptr, a.ptr, sizeof(int ) * a.size);
    size = a.size;
&#125;

CArray::~CArray()
&#123;
    if( ptr) delete [] ptr;
&#125;
CArray &amp; CArray::operator=( const CArray &amp; a)
&#123; //赋值号的作用是使“=”左边对象里存放的数组，大小和内容都和右边的对象一样
    if( ptr == a.ptr) //防止a=a这样的赋值导致出错
    return * this;
    if( a.ptr == NULL) &#123; //如果a里面的数组是空的
    if( ptr ) delete [] ptr;
    ptr = NULL;
    size = 0;
    return * this;
    &#125;
    if( size &lt; a.size) &#123;         //如果原有空间够大，就不用分配新的空间
        if(ptr)
        delete [] ptr;
        ptr = new int[a.size];
    &#125;
    memcpy( ptr,a.ptr,sizeof(int)*a.size);
    size = a.size;
    return * this;
&#125; // CArray &amp; CArray::operator=( const CArray &amp; a)

void CArray::push_back(int v)
&#123; //在数组尾部添加一个元素
    if( ptr) &#123;
        int * tmpPtr = new int[size+1]; //重新分配空间
        memcpy(tmpPtr,ptr,sizeof(int)*size); //拷贝原数组
        内容
        delete [] ptr;
        ptr = tmpPtr;
    &#125;
    else //数组本来是空的
    ptr = new int[1];
    ptr[size++] = v; //加入新的数组元素
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
