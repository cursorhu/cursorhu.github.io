<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/6/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/14/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%8EC%E5%88%B0C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%8EC%E5%88%B0C/" class="post-title-link" itemprop="url">C++面向对象笔记：从C到C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 16:41:50" itemprop="dateCreated datePublished" datetime="2020-03-14T16:41:50+08:00">2020-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-08 16:44:39" itemprop="dateModified" datetime="2022-12-08T16:44:39+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>本章介绍C++语言和C语言相近的部分基础用法，包括</p>
<ul>
<li>引用: &amp;</li>
<li>常关键字: const</li>
<li>动态内存分配: new delete</li>
<li>函数内联: inline</li>
<li>函数重载</li>
</ul>
<h1 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h1><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。</p>
<pre><code>类型名 &amp; 引用名 = 某变量名;
</code></pre>
<p>某个变量的引用，等价于这个变量，相当于该变量起了一个别名。别名类似于操作系统的文件链接或快捷方式的概念，访问它变量本身的存储空间。</p>
<pre><code>int n = 4;
int &amp; r = n; // r引用了 n, r的类型是int &amp;
r = 4;
cout &lt;&lt; r; //输出 4
cout &lt;&lt; n; //输出 4
n = 5;
cout &lt;&lt; r; //输出5
</code></pre>
<p>注意：<br>1.定义引用时一定要将其初始化成引用某个变量。<br>2.初始化后，它就一直引用该变量，不会再引用别<br>的变量了。<br>3.引用只能引用变量，不能引用常量和表达式。</p>
<h2 id="引用的示例"><a href="#引用的示例" class="headerlink" title="引用的示例"></a>引用的示例</h2><p>引用常用于函数传参和返回值<br>1.引用作为函数入参<br>C语言写一个swap函数，交换两个变量的值，要传指针而不能传值，因为直接传值实际修改的是函数局部作用域的一份拷贝。</p>
<pre><code>void swap( int * a, int * b)
&#123;
    int tmp;
    tmp = * a; * a = * b; * b = tmp;
&#125;
int n1, n2;
swap(&amp; n1,&amp; n2) ; // n1,n2的值被交换
</code></pre>
<p>C++中，除了传指针，也可以传引用</p>
<pre><code>void swap( int &amp; a, int &amp; b)
&#123;
    int tmp;
    tmp = a; a = b; b = tmp;
&#125;
int n1, n2;
swap(n1,n2) ; // n1,n2的值被交换
</code></pre>
<p>2.引用作为函数返回值</p>
<pre><code>int n = 4;
int &amp; SetValue() &#123; return n; &#125;
int main()
&#123;
SetValue() = 40;
cout &lt;&lt; n;
return 0;
&#125; //输出： 40
</code></pre>
<h2 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h2><p>看上去引用和指针的功能相同，那区别在哪？<br>1.存储类型不同</p>
<ul>
<li>指针是一种变量，存储指向变量的地址值，通常占内存4字节（64位系统8字节）</li>
<li>引用只是变量的别名，它本身不另外占存储空间，对其求大小（sizeof）就是变量本身的大小</li>
</ul>
<p>指针是变量，因此可以为空（0x0）,而引用是标签（别名），不可为空，先有变量才能有其引用。<br>2.作用方式不同</p>
<ul>
<li>指针作为函数入参本质上还是是值传递，只不过传递的是变量的地址值，函数局部拷贝的也是地址。</li>
<li>引用作为函数入参，被调函数的形参作为局部变量在栈中开辟了内存空间，但存放的是主调函数的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。</li>
</ul>
<p>对于函数传参，形参都是用地址值达成对实参的修改，但传指针是显式的，而传引用是编译器隐式处理的。<br>指针和引用在内存中的示意图：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081643838.png" alt="image-20221208164349783"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081644997.png"></p>
<p>指针和引用的应用比较：<br>引用比指针使用起来形式上更为美观，使用引用指向的内容时可以之间用引用变量名，而不像指针一样要使用*；定义引用的时候也不用像指针一样使用&amp;取址。<br>引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针)。</p>
<h1 id="常量关键字const"><a href="#常量关键字const" class="headerlink" title="常量关键字const"></a>常量关键字const</h1><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>常量：不可被修改的内存单元<br>    const int MAX_VAL &#x3D; 23；<br>    const string SCHOOL_NAME &#x3D; “Peking University”；</p>
<h2 id="定义常引用"><a href="#定义常引用" class="headerlink" title="定义常引用"></a>定义常引用</h2><p>定义引用时，前面加const关键字，即为“常引用”。不能<strong>通过常引用修改</strong>其引用的变量，但可直接修改变量的值，引用本身也不能改变</p>
<pre><code>int n;
const int &amp; r = n;
r = 5; //error
n = 4; //ok
</code></pre>
<p><strong>const T &amp; 和T &amp; 是不同的数据类型!!!</strong><br>T &amp; 类型的引用或T类型的变量可以用来初始化const T &amp; 类型的引用，const T 类型的常变量和const T &amp; 类型的引用则不能用来初始化T &amp;类型的引用，除非进行强制类型转换<br>一句话，常指针和常引用不能出现在“&#x3D;”左边</p>
<h2 id="定义常指针"><a href="#定义常指针" class="headerlink" title="定义常指针"></a>定义常指针</h2><p>常指针也叫常量指针。但指针不是常量，指向的也不是常量，只是限制了改写方式：不可<strong>通过常量指针修改</strong>其指向变量的值，但可直接修改变量的值，也可以改变常量指针的指向地址值。</p>
<pre><code>int n,m;
const int * p = &amp; n;
* p = 5; //编译出错
n = 4; //ok
p = &amp;m; //ok, 常量指针的指向可以变化
</code></pre>
<p>不能把常量指针赋值给非常量指针，反过来可以</p>
<pre><code>const int * p1; int * p2;
p1 = p2; //ok
p2 = p1; //error
p2 = (int * ) p1; //ok,强制类型转换
</code></pre>
<p>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容</p>
<pre><code>void MyPrintf( const char * p )
&#123;
strcpy( p,&quot;this&quot;); //编译出错
printf(&quot;%s&quot;,p); //ok
&#125;
</code></pre>
<h2 id="定义指针常量"><a href="#定义指针常量" class="headerlink" title="定义指针常量"></a>定义指针常量</h2><p>定义：本质是一个不可修改指向地址的指针 </p>
<pre><code>int* const p;
</code></pre>
<h2 id="定义指向常量的常指针"><a href="#定义指向常量的常指针" class="headerlink" title="定义指向常量的常指针"></a>定义指向常量的常指针</h2><p>定义：指针指向的地址值不可修改，且该地址中的值也不可修改</p>
<pre><code>const int* const p;
</code></pre>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>动态内存分配是分配内存空间中堆（heap）的内存，实际上是程序内手动的内存分配与释放。并非堆栈中局部变量的入栈出栈，由操作系统控制的动态分配。</p>
<h2 id="new分配内存"><a href="#new分配内存" class="headerlink" title="new分配内存"></a>new分配内存</h2><p>分配一个变量:</p>
<pre><code>P = new T;
</code></pre>
<p>T是任意类型名， P是类型为T * 的指针。<br>动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P：</p>
<pre><code>int * pn = new int;
* pn = 5;
</code></pre>
<p>分配一个数组：</p>
<pre><code>P = new T[N];
</code></pre>
<p>T :任意类型名<br>P :类型为T * 的指针<br>N :要分配的数组元素的个数，可以是整型表达式<br>动态分配出一片大小为 sizeof(T)*N字节的内存空间，并且将该内存空间的起始地址赋值给P</p>
<pre><code>int * pn;
int i = 5;
pn = new int[i * 20];
pn[0] = 20;
pn[100] = 30; //编译没问题。运行时导致数组越界
</code></pre>
<h2 id="delete释放内存"><a href="#delete释放内存" class="headerlink" title="delete释放内存"></a>delete释放内存</h2><p>用“new”动态分配的内存空间用完后，一定要用“delete”运算符进行释放，否则操作系统无法再次使用这块内存，造成内存泄露<br>注意：不能对内存空间delete两次！</p>
<pre><code>#delete 指针； //该指针必须指向new出来的空间
int * p = new int;
* p = 5;
delete p;
delete p; //导致异常， 一片空间不能被delete多次
</code></pre>
<p>用“delete”释放动态分配的数组，要加“[]”</p>
<pre><code>#delete [] 指针； //该指针必须指向new出来的数组
int * p = new int[20];
p[0] = 1;
delete [] p;
</code></pre>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>普通函数：编译出来的可执行程序加载到内存后，代码段只有一份函数的指令序列，函数的调用处就用一个类似jump的语句跳转到函数指令序列的入口地址<br>内联函数：函数的每个调用处都存在整个函数指令序列的拷贝<br>简单讲就是增加编译出来的代码占用空间，换取运行时频繁入栈出栈的时间开销<br>使用场景：简单函数体且多次调用可以定义为内联<br>函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</p>
<pre><code>inline int Max(int a,int b)
&#123;
if( a &gt; b) return a;
return b;
&#125;
</code></pre>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="函数重载概念"><a href="#函数重载概念" class="headerlink" title="函数重载概念"></a>函数重载概念</h2><p>重载不是重新载入，更贴切的含义是重复定义，因为重定义是种错误，重载可以理解为编译器能理解的“重定义”，因此能正常加载。<br>C++重载主要有：</p>
<ul>
<li>函数重载</li>
<li>运算符重载</li>
</ul>
<p>C++的类没有重载一说，本节讲函数重载<br>函数重载：一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。</p>
<pre><code>int Max(double f1,double f2) &#123; &#125;
int Max(int n1,int n2) &#123; &#125;
int Max(int n1,int n2,int n3) &#123; &#125;
</code></pre>
<p>Q1.重载有什么用？<br>C语言定义以上几个函数，不能用同名，但是其功能都是相同的，仅参数类型和值不同。如果用MaxDouble(),MaxInt2(),MaxInt3()过于麻烦。<br>因此函数重载使得函数命名变得简单。<br>Q2.编译器怎么知道调用的是哪个？<br>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数，注意重载函数不会把入参自动类型转换，调用二义性会报错。</p>
<pre><code>Max(3.4,2.5); //调用 (1)
Max(2,4); //调用 (2)
Max(1,2,3); //调用 (3)
Max(3,2.4); //error,二义性
</code></pre>
<p>Q3.函数仅返回值类型不同是不是重载？<br>不是，函数重载的区分在于入参。但是有个例外，返回const T和非const T的两个函数是是重载的，其他情况的入参相同，返回类型不同的函数，视为重定义。</p>
<h2 id="缺省参数与可拓展性"><a href="#缺省参数与可拓展性" class="headerlink" title="缺省参数与可拓展性"></a>缺省参数与可拓展性</h2><p>C++函数支持缺省参数（默认参数值）。定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。</p>
<pre><code>void func( int x1, int x2 = 2, int x3 = 3)
&#123; &#125;
func(10 ) ; //等效于 func(10,2,3)
func(10,8) ; //等效于 func(10,8,3)
func(10, , 8) ; //不行,只能最右边的连续若干个参数缺省
</code></pre>
<p>函数参数可缺省的目的在于提高程序的可扩充性。<br>如果某个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，那么为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。<br>在C语言中，如果函数新增一个入参，所有调用该函数的地方都要传入该入参值；C++支持缺省参数，只需要改函数定义即可，调用处不需要动。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/02/29/%E6%B5%85%E8%B0%88C%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%E6%B5%85%E8%B0%88C%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">浅谈C的结构体与面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-29 15:13:18" itemprop="dateCreated datePublished" datetime="2020-02-29T15:13:18+08:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 15:17:40" itemprop="dateModified" datetime="2022-12-06T15:17:40+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>结构体（Struct）：存放一组不同类型的数据的数据结构。<br>数组（Array）：存放一组相同类型的数据的数据结构。<br>结构体和int,char，指针等基础数据类型一样，也是一种数据类型。格式定义如下：</p>
<pre><code>struct 结构体名&#123;
    成员类型1 成员名1;
    成员类型2 成员名2；
&#125;实例1，实例2;
</code></pre>
<p>结构体的成员（Member）可以为任意类型，如int,char，指针，甚至结构体类型。<br>结构体可以配合结构体数组、普通指针、函数指针、以及自身嵌套的使用方法，实现复杂数据结构，以及面向对象的代码风格。</p>
<h1 id="1-结构体声明"><a href="#1-结构体声明" class="headerlink" title="1.结构体声明"></a>1.结构体声明</h1><p>声明是告诉编译器某个数据结构的定义。一般在头文件对结构体、函数等类型声明。声明过程不分配内存。<br>一个结构体类型的声明：</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125;;
</code></pre>
<p>注意：<br>1.结构体声明类似于函数声明，是一个语句，末尾加；<br>2.结构体声明只声明了类型，不实例化变量，因此不分配内存。<br>3.结构体成员的变量只在实例结构体才分配内存。</p>
<h1 id="2-结构体实例"><a href="#2-结构体实例" class="headerlink" title="2.结构体实例"></a>2.结构体实例</h1><h2 id="2-1基础方法"><a href="#2-1基础方法" class="headerlink" title="2.1基础方法"></a>2.1基础方法</h2><p>结构体变量是结构体类型的实例，实例化就是在内存分配一个结构体类型的变量空间。<br>方法一：先声明结构体类型stu，再实例变量stu1,stu2。<br>该方法结构体类型声明和实例化分离。声明一次，到处实例化。注意实例变量要带struct关键字。</p>
<pre><code>struct stu stu1, stu2;
</code></pre>
<p>方法二：声明的时候也实例变量stu1,stu2。</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<p>方法三：不声明接头体名，直接实例变量。<br>适用于只需要 stu1、stu2两个变量，后面不需要再使用结构体名定义其他变量的情况</p>
<pre><code>struct&#123;             //没有写stu
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<h2 id="2-2重定义方法"><a href="#2-2重定义方法" class="headerlink" title="2.2重定义方法"></a>2.2重定义方法</h2><p>结构体类型通常配合typedef重定义后声明。<br>声明一次，到处实例化。不需要带struct关键字。</p>
<pre><code>    typedef struct stu&#123; //stu可省略
        char *name;     //姓名
        int num;        //学号
        int age;        //年龄
        char group;     //所在小组
        float score;    //成绩
    &#125;stu_t, *stu_p;    //声明stu_t为stu类型，stu_p为stu类型的指针
</code></pre>
<p>实例变量：</p>
<pre><code>stu_t stu1,stu2;    //实例两个stu结构体变量
stu_p *stu1_p, *stu2_p; //实例两个指向stu结构体指针
stu1_p = &amp;stu1; //指向实例stu1
stu2_p = &amp;stu2; //指向实例stu2
</code></pre>
<h1 id="3-结构体初始化"><a href="#3-结构体初始化" class="headerlink" title="3.结构体初始化"></a>3.结构体初始化</h1><p>初始化&#x3D;赋初始值。<br>结构体的实例只分配了内存，其成员的值要手动赋值后才能确定。否则直接拿来用会得到不确定的值（取决于分配到的内存原本的值）。<br>以重定义的结构体类型stu_t为例，实例变量时顺便初始化所有成员为0：</p>
<pre><code>stu_t stu1,stu2 = &#123;0&#125;;
</code></pre>
<p>有的编译器可能要求这种写法：</p>
<pre><code>stu_t stu1,stu2 = &#123;&#123;0&#125;&#125;;
</code></pre>
<p>如果各成员有默认初始值，初始化如下：</p>
<pre><code>stu_t stu1, stu2 = &#123; &quot;Tom&quot;, 9527, 18, &#39;A&#39;, 136.5 &#125;;
</code></pre>
<h1 id="4-结构体的赋值"><a href="#4-结构体的赋值" class="headerlink" title="4.结构体的赋值"></a>4.结构体的赋值</h1><p>结构体赋值是对结构体变量内的成员赋值。<br>两种方式访问成员：</p>
<pre><code>结构体变量.成员名;
stu1.name = &#39;Tom&#39;;
结构体指针-&gt;成员名
stu1_p-&gt;name = &#39;Tom&#39;;
</code></pre>
<p>这两种方法的选择取决于使用情况。如果结构体作为参数在函数之间频繁传递和赋值，建议使用传指针，而不是传结构体变量，这样减少函数为结构体频繁分配局部内存，但要注意结构体已被释放，形成空指针的判断。<br>注意是对实例的成员赋值（已分配内存），而不能对结构体类型的成员赋值（只是个标签）。例如如下操作是错误的：</p>
<pre><code>stu_t.name = &quot;Tom&quot;  //错，stu_t是类型
stu1_p = &amp;stu_t     //错，stu_t没地址
</code></pre>
<p>可以对结构体类型进行sizeof操作，而不需要分配内存。</p>
<pre><code>sizeof(stu_t);      //获取结构体（将）占用的内存空间
</code></pre>
<h1 id="5-结构体的内存分配"><a href="#5-结构体的内存分配" class="headerlink" title="5.结构体的内存分配"></a>5.结构体的内存分配</h1><p><strong>理论上</strong>结构体的内存占用是成员占用的和。各成员在内存中连续存储的，和数组非常类似，例如结构体变量 stu1、stu2的内存分布如下，共占用 4+4+4+1+4&#x3D;17字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061515193.jpeg" alt="1"><br>但实际上，编译器会遵循<strong>内存对齐</strong>规则。实际内存占用大于各成员占用的和。如下图，stu1、stu2 其实占用了 17+3&#x3D;20 字节<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516336.jpeg" alt="2"></p>
<h2 id="5-1内存对齐概述"><a href="#5-1内存对齐概述" class="headerlink" title="5.1内存对齐概述"></a>5.1内存对齐概述</h2><p>1.CPU怎么访问内存中的数据最高效？<br>答：用最少的访问次数，获取该数据所在的内存空间的值。<br>2.怎么做到对某类型数据的最少访问？<br>答：编译器设置数据的存放地址的单位为数据占用空间的长度，CPU以数据长度为单位查询偏移地址，找到数据空间首地址后，根据数据类型取出其占用空间大小的数据。<br>如int数据，就存放在以4字节为单位的偏移地址，如0，4，8…,CPU取数据就按0，4，8…的地址查询，找到该数据地址后取4字节。这样做到一次性访问获取int数据。如果CPU按单字节访问int,就要查询4次，如int首字节地址为0x00001024, CPU要分4次查询0x00001024~0x00001027才能得到一个int。<br>3.对于结构体，包含多种数据类型，怎么对齐？<br>答：各成员按各自的类型对齐，即对于成员来说不存在结构体的概念，它认为它就是基本的数据类型int、char、指针等。</p>
<h2 id="5-2结构体与内存对齐"><a href="#5-2结构体与内存对齐" class="headerlink" title="5.2结构体与内存对齐"></a>5.2结构体与内存对齐</h2><p>结构体是不同类型数据的集合，因此内存对齐问题就特别突出。一个例子：</p>
<pre><code>#include &quot;stdio.h&quot;
typedef struct &#123;
    int a;
    double b;
    char c;
&#125;A; 

typedef struct &#123;
    int a;
    char b;
    double c;
&#125;B;

int main()
&#123;
    printf(&quot;sizeof A: %d, sizeof B: %d\n&quot;, sizeof(A), sizeof(B));
&#125;
</code></pre>
<p>A和B的内存占用：A&#x3D;24字节，B&#x3D;16字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516111.png" alt="3"><br>结构体内存对齐的计算规则：<br>1.默认首地址已对齐（或认为是0地址)<br>2.各成员按自己的类型对齐<br>3.整个结构体分配的空间是期中最大成员占用空间的整数倍<br>对于A：<br>int a占用4字节，地址byte[0<del>3]<br>double b占8字节，起始地址必须是8的倍数，占用byte[7</del>15]<br>char c占1字节，因此占byte[16]<br>目前共占用17字节。编译器会按照规则3，将byte[17~13]也分配给结构体，因此最终结构体占用3<em>8&#x3D;24字节。<br>对于B, int a和char b加起来都不够8字节，double c再占用8字节，共占用2</em>8&#x3D;16字节。<br>因此<strong>结构体的内存分配&#x3D;各成员按类型对齐+总空间是最大成员空间的倍数</strong><br>注意，结构体不仅成员间要对齐，最后一个成员后面的空余空间可能也分配给结构体。<br>查看下面的测试程序：</p>
<pre><code>typedef struct &#123;
    int a;
    double b;
    char c;
    char d;         //d作为成员
&#125;C;

typedef struct &#123;
    int a;
    double b;
    char c;
    struct &#123;        //d作为嵌套结构体的成员
        char d; 
    &#125;;
&#125;D;

printf(&quot;sizeof C: %d, sizeof D: %d\n&quot;, sizeof(C), sizeof(D));
</code></pre>
<p>C和D的内存占用：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517211.png" alt="4"><br>新增的char d作为C的成员被分配在第三个8byte区域的第二个字节（byte[17])，嵌套的结构体并不从第四个8byte开始分配，它占用空间还是byte[17]。可见编译器对结构体内存分配不区分成员类型，只根据成员大小来处理。</p>
<h1 id="6-联合、位域、枚举"><a href="#6-联合、位域、枚举" class="headerlink" title="6.联合、位域、枚举"></a>6.联合、位域、枚举</h1><p>这几种数据结构体和结构体相关联，通常混合使用。</p>
<h2 id="6-1联合"><a href="#6-1联合" class="headerlink" title="6.1联合"></a>6.1联合</h2><p>联合(Union)也称共用体，和结构体的区别：<br>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。<br>声明格式：</p>
<pre><code>union 共用体名&#123;
    成员列表
&#125;;
</code></pre>
<p>共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>联合的一个示例：</p>
<pre><code>#include &lt;stdio.h&gt;
union data&#123;
    int n;
    char ch;
    short m;
&#125;;
int main()&#123;
    union data a;
    printf(&quot;%d, %d\n&quot;, sizeof(a), sizeof(union data) );
    a.n = 0x40;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.ch = &#39;9&#39;;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.m = 0x2059;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.n = 0x3E25AD54;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>4, 4
40, @, 40
39, 9, 39
2059, Y, 2059
3E25AD54, T, AD54
</code></pre>
<p>在内存中数据分布如下（以大端，低字节存高位为例）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517262.jpeg" alt="5"><br>可见数据会相互覆盖，联合可以理解为分时复用的结构体，其空间占用定长，为最大的成员长度，在不同时间，值的含义不同。</p>
<h2 id="6-2位域"><a href="#6-2位域" class="headerlink" title="6.2位域"></a>6.2位域</h2><p>有的结构体成员在存储时并不占用一个完整的字节，只需要按二进制位为单位分配空间即可。可以指定该成员所占用的二进制位数（Bit），这就是位域。</p>
<pre><code>#include &quot;stdio.h&quot;
struct &#123;
        unsigned char a;    //a占完整的8bit
        unsigned char b: 2; //b占2bit
        unsigned char c: 6; //C占6bit
&#125;bs;

int main()
&#123;
    printf(&quot;sizeof bs: %d\n&quot;, sizeof(bs));
&#125;
</code></pre>
<p>输出2字节，可见b和c刚好拼成一个unsigned char(8 bit)：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517807.png" alt="6"><br>位域将结构体成员占用的空间从基本数据类型为单位，变成了以二进制位为单位，是更精细的结构体内存分配。<br>位域不能超过对应基本类型的二进制位数。</p>
<h2 id="6-3枚举"><a href="#6-3枚举" class="headerlink" title="6.3枚举"></a>6.3枚举</h2><p>枚举可以理解为计数宏的结构体。</p>
<pre><code>#include &lt;stdio.h&gt;
int main()&#123;
    enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125; day;
    scanf(&quot;%d&quot;, &amp;day);
    switch(day)&#123;
        case Mon: puts(&quot;Monday&quot;); break;
        case Tues: puts(&quot;Tuesday&quot;); break;
        case Wed: puts(&quot;Wednesday&quot;); break;
        case Thurs: puts(&quot;Thursday&quot;); break;
        case Fri: puts(&quot;Friday&quot;); break;
        case Sat: puts(&quot;Saturday&quot;); break;
        case Sun: puts(&quot;Sunday&quot;); break;
        default: puts(&quot;Error!&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
<p>枚举值默认从0开始，往后逐个加 1（递增）；如果第一个成员赋值，从那个成员值往后递增。也就是说，week中的 Mon、Tues …… Sun 对应的值分别为 1、2… 7。<br>宏在编译的预处理阶段将名字替换成对应的值，而枚举在编译阶段将名字替换成对应的值。在编译过程中，Mon、Tues、Wed 名字都被替换成了对应的数字。这意味着Mon、Tues、Wed 等都不是变量，不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是被编译到指令里面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。<br>枚举类型实例的内存占用通常&#x3D;int类型占用&#x3D;4字节。</p>
<h1 id="7-结构体常见用法"><a href="#7-结构体常见用法" class="headerlink" title="7.结构体常见用法"></a>7.结构体常见用法</h1><h2 id="7-1结构体数组"><a href="#7-1结构体数组" class="headerlink" title="7.1结构体数组"></a>7.1结构体数组</h2><p>结构体数组是将多个同类型结构体按数组的方式存储，其成员访问方式为：先访问数组元素，再访问结构体成员。<br>结构体数组本质还是数组，但数组成员是结构体，结构体内可以包含各种类型的成员。<br>一个Linux NandFlash驱动的结构体数组如下：</p>
<pre><code>    static struct mtd_partition s3c_nand_parts[] = &#123;
    [0] = &#123;
        .name   = &quot;bootloader&quot;,
        .size   = 0x00040000,
        .offset    = 0,
    &#125;,
    [1] = &#123;
        .name   = &quot;params&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00020000,
    &#125;,
    [2] = &#123;
        .name   = &quot;kernel&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00200000,
    &#125;,
    [3] = &#123;
        .name   = &quot;root&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = MTDPART_SIZ_FULL,
    &#125;
&#125;;
</code></pre>
<p> 该数组名为s3c_nand_parts，成员为mtd_partition结构体，包含分区名，分区大小和分区偏移地址。每个结构体成员分别初始化赋值。注意结构体数组实例没写结构体名，只有数组下标[]，结构体成员没写结构体名,只有.符号。这是Linux kernel常见的精简写法。<br> 访问一个结构体数组的成员：</p>
<pre><code>s3c_nand_parts[0].name = &quot;bootloader_2&quot;
</code></pre>
<p>结构体数组的内存占用&#x3D;数组成员数*单个结构体内存占用。</p>
<h2 id="7-2结构体指针"><a href="#7-2结构体指针" class="headerlink" title="7.2结构体指针"></a>7.2结构体指针</h2><p>结构体指针本质是指针变量，其值是结构体的地址。<br>前面结构体重定义一节已经定义和初始化过结构体指针，需要注意的是，结构体指针的初始化值来源于结构体实例，结构体类型名只是标签，不代表结构体地址，注意和”数组名&#x3D;数组地址“区分。</p>
<pre><code>struct stu&#123;         
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;

struct stu *stu_p = stu;    //错，stu只是符号，不占内存
struct stu *stu_p = &amp;stu1;  //对，stu1是结构体实例，占内存  //对，stu1是stu实例变量，有内存占用
</code></pre>
<p>结构体指针的常见用途：malloc分配结构体空间</p>
<pre><code>stu_p =(stu_t *)malloc(sizeof(stu_t));  //分配结构体空间，返回地址给结构体指针
</code></pre>
<p>结构体指针最重要的用途：函数传参<br>结构体变量作为函数参数时传递的是整个结构体内存空间，也就是所有成员空间，而不是像数组一样被编译器转换成一个指针。如果结构体成员较多，传送的时间和空间开销会很大，影响程序的运行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。</p>
<h2 id="7-2结构体嵌套"><a href="#7-2结构体嵌套" class="headerlink" title="7.2结构体嵌套"></a>7.2结构体嵌套</h2><p>结构体嵌套是结构体的成员也是结构体。有两种情况：<br>1.成员是其他类型的结构体<br>2.成员是同类型的结构体</p>
<h3 id="7-2-1-嵌套其他类型"><a href="#7-2-1-嵌套其他类型" class="headerlink" title="7.2.1.嵌套其他类型"></a>7.2.1.嵌套其他类型</h3><p>在协议开发中，一个命令的数据可以用结构体来表达，在命令的内部又分为很多个数据域，每个数据域又用结构体来表达，因此需要结构体嵌套。对于同一块数据，根据命令的不同，解析为不同的结构体,因此存在多类命令公用一块数据域的情况，因此需要联合（Union）。以NVMe协议为例，结构体嵌套和联合一起使用的例子：</p>
<pre><code>typedef struct  //nvme命令结构体
&#123;
     union      //命令中dword10空间的联合
    &#123;
        u32 command_dw10;
        struct
        &#123;
            u32 cntid:16;   //16 bit位域
            u32 resv1:8;    //8 bit位域
            u32 cns:8;      //8 bit位域
        &#125;identify;          //当命令为identify时
        struct
        &#123;
            u32 save:1;
            u32 resv1:20;
            u32 select:3;
            u32 feature_identifier:8;
        &#125;get_features;      //当命令为get_featuresy时
        struct
        &#123;
            u32 queue_size:16;
            u32 queue_identifier:16;
        &#125;io_queue_create_delete_dw10;
        ...
    &#125;;
    
    union   //命令中dword11空间的联合
    &#123;
        u32 command_dw11;
        struct
        &#123;
            u32 completion:16;
            u32 submission:16;
        &#125;number_of_queues;
        struct
        &#123;
            u32 interrupt_vector:16;
            u32 resv1:14;
            u32 interrupt_enabled:1;
            u32 physically_contiguous:1;
        &#125;create_io_completion_queue_dw11;
        ...
    &#125;;
    
&#125;command_t, *command_p;
</code></pre>
<p>该例子结合了结构体、联合、位域。对每个nvme命令，多个联合并存在结构体command_t实例里，每个联合长度为一个dword(4字节)，分别表示dword0~15中的一个。对于dword内部，根据解析到命令的不同，作为不同含义处理，如解析为identify就按identify的结构体读写成员，如解析为get_features则按get_features的结构体读写成员。在结构体内部，用位域更精细控制这个dword内各bit的含义。</p>
<h3 id="7-2-2嵌套自身类型"><a href="#7-2-2嵌套自身类型" class="headerlink" title="7.2.2嵌套自身类型"></a>7.2.2嵌套自身类型</h3><p>结构体嵌套自身类型的典型应用：链表数据结构体</p>
<pre><code>typedef struct ListNode &#123;
    DataType data;          // 节点数据 
    struct ListNode *next;  // 指向下一个结点的指针 
&#125; ListNode_t;
</code></pre>
<p>这个结构体有两个成员：DataType类型的数据，和指向 struct ListNode类型(&#x3D;ListNode_t类型)的实例的指针。有多个ListNode_t类型的结构体被实例化且依次指向后续节点后，可以依次node1-&gt;next-&gt;next…-&gt;data访问链表中的节点数据。<br>注意：结构体体能嵌套自身类型的指针，而不能嵌套自身类型的实例。因为指针分配内存是定长（通常4字节），而循环嵌套结构体变量是无穷的。以下写法是错的</p>
<pre><code>typedef struct ListNode &#123;
    DataType data;           
    struct ListNode next;  // 错，嵌套的是实例 
&#125; ListNode_t;
</code></pre>
<h1 id="8-结构体高级用法：面向对象"><a href="#8-结构体高级用法：面向对象" class="headerlink" title="8.结构体高级用法：面向对象"></a>8.结构体高级用法：面向对象</h1><h2 id="8-1函数指针"><a href="#8-1函数指针" class="headerlink" title="8.1函数指针"></a>8.1函数指针</h2><p>程序中定义的函数，在编译时会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的入口地址。函数名表示的就是这个地址的值。可以定义一个指针变量来存放函数的入口地址，这个指针变量就叫作函数指针变量，简称函数指针。<br>这段话什么意思？<br>1.函数名&#x3D;函数入口地址<br>2.可以用指针变量的值取代函数名，函数的调用和该指针变量的调用等价<br>3.可以把这个指针变量当参数传递给别的函数，也可以把这个指针变量作为结构体的成员，总之，一切指针能做的，函数指针都能做。<br>函数指针的定义：</p>
<pre><code>返回值 函数入口地址(入参1的类型，入参2的类型，...)
int (*p)(int, int);     //p为函数指针，*p为入口地址
</code></pre>
<p>定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数。p 的类型为 int(*)(int，int)<br>函数指针的初始化：</p>
<pre><code>int Func(int x);   /*声明一个函数，包含入参名*/
int (*p) (int);  /*声明一个函数指针，只有入参类型*/
p = Func;         /*将Func函数的入口地址赋给指针变量p*/
</code></pre>
<p>函数指针作为结构体成员的调用如下</p>
<pre><code>struct&#123;
    int (* func)(int);
&#125;stu1, *stu1_p; //分配两个结构体实例：stu1结构体和指针stu1_p

stu1.func(10);  //通过结构体调用函数指针
stu1_p-&gt;func(10);   //通过结构体指针调用函数指针
</code></pre>
<h2 id="8-2回调函数"><a href="#8-2回调函数" class="headerlink" title="8.2回调函数"></a>8.2回调函数</h2><p>回调函数(Callback)就是一个通过函数指针调用的函数。把函数指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由函数的实现方直接调用，而是在特定的事件或条件发生时，由把它当参数的那个函数调用的，用于对该事件或条件进行响应。<br>回调的两个特点：<br>1.函数&#x3D;参数。函数A指针当参数传递B<br>2.异步。特定时间发生时，B才调用A指针指向的函数</p>
<h2 id="8-3结构体与面向对象"><a href="#8-3结构体与面向对象" class="headerlink" title="8.3结构体与面向对象"></a>8.3结构体与面向对象</h2><p>当函数指针作为结构体的成员，可以通过结构体实例调用成员函数，此时可以实现类似其他语言中“类”或“接口”的概念：<br>结构体声明&#x3D;类声明&#x3D;接口声明<br>结构体的函数指针成员&#x3D;类方法&#x3D;接口函数<br>结构体实例调用函数指针成员&#x3D;类实例调用方法&#x3D;接口的实现<br>这种设计思想在Linux内核和驱动框架中很常用。以字符设备驱动为例：<br>字符设备驱动顶层框架将所有字符操作函数作为接口在结构体file_operations中定义，在底层具体的设备驱动中实现file_operations的方法。底层驱动实例化file_operations结构体（分配内存），将各种操作的具体实现函数赋值给接口定义的函数，然后上报（注册）该file_operations实例给顶层驱动框架，顶层驱动框架接收到应用层的系统调用请求时，回调已注册的file_operations实例的函数。<br>上层驱动框架定义的字符文件操作接口如下，这些open、read、write作为文件操作的方法供应用层调用。</p>
<pre><code> struct file_operations &#123;   //字符文件操作的接口定义
　　struct module *owner;   //结构体指针
　　ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);      //函数指针read
　　ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);    //函数指针write
　　int (*open) (struct inode *, struct file *);    //函数指针open
　　int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);   //函数指针ioctl
　　...
&#125;;
</code></pre>
<p>而这些方法具体实现（内部做什么）是由底层驱动代码实现：</p>
<pre><code>static int my_drv_open(struct inode *inode, struct file *file)
&#123;
    //硬件寄存器操作A...
    return 0;
&#125;

static ssize_t my_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)
&#123;
    //硬件寄存器操作B...
    return 0;
&#125;
</code></pre>
<p>那么这些实现怎么关联接口：在底层驱动分配结构体实例，初始化函数指针为实现函数</p>
<pre><code>static struct file_operations my_drv_fops = &#123;
    .owner  =   THIS_MODULE,   
    .open   =   my_drv_open,   //open接口由my_drv_open函数实现  
    .write    =    my_drv_write,     //write接口由my_drv_write函数实现  
&#125;;
</code></pre>
<p>关联完了，上层驱动怎么调用：结构体指针传参+回调<br>my_drv_fops是file_operations的实例，上报给上层驱动，上层驱动有它自己的字符设备结构体cdev，取出my_drv_fops实例的.结构体指针fops的值，赋给cdev实例内的ops指针。之后它就能用ops调用my_drv_open、my_drv_write函数。</p>
<pre><code>//注册结构体
cdev-&gt;owner = fops-&gt;owner;
cdev-&gt;ops = fops;
//回调.open方法
cdev-&gt;ops-&gt;open(inode,file);
</code></pre>
<p>由于my_drv_write是值，open才是结构体成员，因此调用的时候看上去调用的是open函数，本质上执行的还是my_drv_write的流程。函数指针的回调能将接口名暴露，方法名隐藏。因此底层实现的函数名和上层驱动的调用函数名不相关，上层永远都可以用.open .read .write这些接口调用底层驱动，而底层函数可以随便改名（不能改入参出参类型，否则函数指针类型变了），这种特性都是函数指针决定的。<br>对于应用程序，是调用上层驱动提供的系统调用接口，还是如.open .read .write等接口。Linux驱动将设备抽象成了文件，驱动程序实现了文件的各种方法，所以对应用程序，打开文件&#x3D;打开设备，调用文件对应的接口&#x3D;调用设备驱动提供的接口。</p>
<pre><code>fd = open(&quot;/dev/xyz&quot;, O_RDWR);  //打开文件（设备）
read(fd, &amp;val, 1);  //读fd文件（设备）的值到val变量
</code></pre>
<p>除了C语言，在golang中也有类似的结构体+函数指针实现的面向对象方法。<br>NOTE:关于结构体中的函数指针写法易错点：<br>不包含变量名，只能使用基本类型</p>
<pre><code>   #一个结构体
   typedef stru&#123;    //定义结构体名
        int a;
        char b;
   &#125;stru_t, *stru_p; //重定义结构体变量和指针
    
    #普通函数声明
    int func(int a, stru_p p); //参数写类型且写值，可以使用typedef后的结构体指针类型
    
    #函数指针声明
    int (*func)(int, struct stru *);    //参数只写类型不写参数，只能使用C基本类型，不能使用typedef后的类型，只能写struct stru *类型
</code></pre>
<p>函数指针声明使用typedef后的类型名，编译器不认识，产生syntax error。    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/02/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/15/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Linux常用命令行笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-15 14:30:12" itemprop="dateCreated datePublished" datetime="2020-02-15T14:30:12+08:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 14:33:26" itemprop="dateModified" datetime="2022-12-05T14:33:26+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="查找包含指定内容的文件"><a href="#查找包含指定内容的文件" class="headerlink" title="查找包含指定内容的文件"></a>查找包含指定内容的文件</h1><pre><code>grep -r 字符串 目录
</code></pre>
<p>示例：查找当前目录的包含“stream”内容的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &quot;stream&quot; ./</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2019/12/06/Xshell%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/06/Xshell%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Xshell配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-06 14:54:42" itemprop="dateCreated datePublished" datetime="2019-12-06T14:54:42+08:00">2019-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-06 15:03:44" itemprop="dateModified" datetime="2022-12-06T15:03:44+08:00">2022-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ssh/" itemprop="url" rel="index"><span itemprop="name">ssh</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>配置x’shell的默认字体以及一些操作设置</p>
<h1 id="会话设置"><a href="#会话设置" class="headerlink" title="会话设置"></a>会话设置</h1><p>设置主机<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457347.png" alt="1"><br>设置主机账号密码<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457719.png" alt="2"><br>设置xshell字体<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457495.png" alt="3"></p>
<h1 id="操作设置"><a href="#操作设置" class="headerlink" title="操作设置"></a>操作设置</h1><p>设置Ctrl+c,Ctrl+v复制粘贴<br>工具-&gt;选项-&gt;编辑按键<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061457000.png" alt="4"><br>新建按键，按ctrl+c<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061458030.png" alt="5"><br>设置功能为复制<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061458880.png" alt="6"><br>同理设置ctrl+v为粘贴<br>注意,原shell的ctrl+c终止程序，被替换成了shift+ctrl+c</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2019/07/06/Office%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/Office%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Office常用操作笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 14:19:23" itemprop="dateCreated datePublished" datetime="2019-07-06T14:19:23+08:00">2019-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-09 11:45:50" itemprop="dateModified" datetime="2023-02-09T11:45:50+08:00">2023-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Office/" itemprop="url" rel="index"><span itemprop="name">Office</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h1><h2 id="Word设置自动推导的标题列表"><a href="#Word设置自动推导的标题列表" class="headerlink" title="Word设置自动推导的标题列表"></a>Word设置自动推导的标题列表</h2><p>word自动标题列表的是写文档必不可少的，自动标题能自动推导更新各级标题的序号，增删改查任何标题都不需要手动的写标题序号。</p>
<p>（1）创建多级列表<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423943.png" alt="image-20221206142307899"></p>
<p>（2）设置一级标题</p>
<ul>
<li>设置一级标题的序号样式为1,2,3</li>
<li>链接一级标题的字体样式到word文档的一级标题字体样式<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423121.png" alt="image-20221206142315070"></li>
</ul>
<p>（2）设置二级、三级、n级标题</p>
<p>需要设置列表序号，标题字体两部分。注意列表序号的正确设置是序号自动推导的关键。<br>以二级标题为例，其他子级类推。</p>
<ul>
<li><p>设置二级标题中的一级序号来自于level1。这一步保证二级标题中的一级序号是自动推导的。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061423795.png" alt="image-20221206142327739"></p>
</li>
<li><p>设置二级标题中的二级序号的样式，二级标题中的一、二级序号用.号隔开<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424185.png" alt="image-20221206142401132"></p>
</li>
<li><p>二级标题最终的序号样式如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424492.png" alt="image-20221206142411436"></p>
</li>
<li><p>然后设置二级标题的字体风格，直接链接到word的二级标题字体风格<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424730.png" alt="image-20221206142420685"></p>
</li>
<li><p>二级标题列表的所有设置完毕，如下<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061424880.png" alt="image-20221206142428828"></p>
</li>
</ul>
<p>(3)依次完成所有标题列表设置，例如三级标题，前两级的值来自于level1,level2，第三级设置数字格式即可，中间用.号隔开。完成以后各级标题就可以自动推导。</p>
<h2 id="Word导出原图"><a href="#Word导出原图" class="headerlink" title="Word导出原图"></a>Word导出原图</h2><p>Word默认图片如果直接复制出来，不是原图是压缩后的图。<br>保存原图方法： 文档另存为html网页格式，会把word文档转换成资源文件夹，里面有原始图片。</p>
<h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><h2 id="excel设置筛选"><a href="#excel设置筛选" class="headerlink" title="excel设置筛选"></a>excel设置筛选</h2><p>参考<a target="_blank" rel="noopener" href="https://support.microsoft.com/zh-cn/office/%E7%AD%9B%E9%80%89%E5%8C%BA%E5%9F%9F%E6%88%96%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE-01832226-31b5-4568-8806-38c37dcc180e#:~:text=%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E7%AD%9B%E9%80%89%201%20%E9%80%89%E6%8B%A9%E8%A6%81%E7%AD%9B%E9%80%89%20%E5%88%97%E7%9A%84%E5%88%97%E6%A0%87%E9%A2%98%E7%AE%AD%E5%A4%B4%E3%80%82%202%20%E5%8F%96%E6%B6%88%20%28%E9%80%89%E6%8B%A9%22%29%20%22%EF%BC%8C,%E5%8D%95%E5%87%BB%E2%80%9C%20%E7%A1%AE%E5%AE%9A%20%E2%80%9D%E3%80%82%20%E5%88%97%E6%A0%87%E9%A2%98%E7%AE%AD%E5%A4%B4%20%22%E7%AD%9B%E9%80%89%20%E6%9B%B4%E6%94%B9%20%E3%80%82%20%E9%80%89%E6%8B%A9%E6%AD%A4%E5%9B%BE%E6%A0%87%E5%8F%AF%E6%9B%B4%E6%94%B9%E6%88%96%E6%B8%85%E9%99%A4%E7%AD%9B%E9%80%89%E3%80%82">筛选区域或表中的数据</a></p>
<ol>
<li><p>选中列，点击筛选</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302091144706.png" alt="image-20230209114432580"></p>
</li>
<li><p>可以按文字或者颜色筛选</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302091145967.png" alt="image-20230209114508910"></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
