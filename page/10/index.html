<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/10/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/11/08/%E6%B5%85%E8%B0%88C-%E7%9A%84RAII%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/08/%E6%B5%85%E8%B0%88C-%E7%9A%84RAII%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">浅谈C++的RAII机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-08 16:57:03" itemprop="dateCreated datePublished" datetime="2020-11-08T16:57:03+08:00">2020-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-资源与内存分配"><a href="#1-资源与内存分配" class="headerlink" title="1.资源与内存分配"></a>1.资源与内存分配</h1><p>资源的概念:资源是数量有限且对系统正常运转具有一定作用的元素。比如，内存，文件句柄，网络套接字（network sockets），互斥锁（mutex locks）等等<br>对于进程，这些资源都作为某种数据结构存储在内存中。<br>程序运行需要分配内存来管理以上资源，内存分配可以分为三类：</p>
<ul>
<li>静态分配：如创建一个进程执行某段代码，需要加载该代码的代码段，数据段等数据到内存中，其中数据段包含已初始化的全局数据，可以称为是静态的内存分配</li>
<li>自动分配：进程内函数的调用和返回，以及其内部的局部变量创建和销毁，对应该进程高地址的入栈出栈，这个是操作系统自动处理的，无需应用程序控制</li>
<li>动态分配：静态数据和堆栈之前的空间（称为堆），可由应用程序动态分配，同时，也必须由应用程序释放。所谓的内存的动态分配与释放，通常讨论的是这种情况</li>
</ul>
<p>以32位Linux环境的应用程序为例，每个进程可见的（虚拟）内存分布如下，C&#x2F;C++常用的malloc&#x2F;free, new&#x2F;delete对应的内存分配释放都在.heap段内<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081658341.png" alt="image-20221208165846274"></p>
<h1 id="2-动态内存管理的缺陷"><a href="#2-动态内存管理的缺陷" class="headerlink" title="2.动态内存管理的缺陷"></a>2.动态内存管理的缺陷</h1><p>我们在使用资源时必须严格遵循的步骤是：</p>
<ol>
<li>获取资源</li>
<li>使用资源</li>
<li>释放资源</li>
</ol>
<p>代码形式：</p>
<pre><code>void UseResources()    
{  
    // 获取资源1  
    // ...  
    // 获取资源n  
     
    // 使用这些资源  
     
    // 释放资源n  
    // ...  
    // 释放资源1  
} 
</code></pre>
<p>当代码量和复杂度达到一定程度，这种手动资源管理容易出错，且难以避免<br>例如C++使用new和delete时可能发生的一些错误是：</p>
<ul>
<li>内存泄漏：例如，使用new分配对象，而忘记删除该对象，打开文件，忘记关闭文件等等</li>
<li>过早删除（或悬挂引用）：持有指向对象的另一个指针，删除该对象，但是还有其他指针在引用它。</li>
<li>双重删除：尝试两次删除一个对象</li>
</ul>
<h1 id="3-RAII：将资源管理交给系统"><a href="#3-RAII：将资源管理交给系统" class="headerlink" title="3.RAII：将资源管理交给系统"></a>3.RAII：将资源管理交给系统</h1><ul>
<li>自动内存管理，局部变量能在调用函数时分配，退出函数时释放</li>
<li>类是 C++ 中的主要抽象工具，将资源抽象为类，用局部对象来表示资源，把管理资源的任务转化为管理局部对象的任务</li>
</ul>
<p>RAII 就是基于以上思想，折中了全手动和全自动的内存管理，手动的选择管理哪些资源，自动的分配和释放资源。有效地实现了 C++ 资源管理的自动化</p>
<p>RAII（Resource Acquisition Is Initialization, 资源获取即初始化）:<br>是80年代，Bjarne Stroustrup为C++发明了的范例。<br>具体实现方法：将资源的声明周期，绑定到对象的生命周期，即将资源分配和释放操作，包含到指定对象的构造函数和析构函数中，这些构造函数和析构函数在适当的时候由编译器自动调用，资源数据包含到对象的成员中。</p>
<p>一个简单示例：</p>
<p>（1）常规内存管理</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std; 
int main() 
{ 
    int *testArray = new int [10]; 
    // Here, you can use the array 
    delete [] testArray; 
    testArray = NULL ; 
    return 0; 
}
</code></pre>
<p>（2）RAII方式</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std; 

class ArrayOperation 
{ 
public : 
    ArrayOperation() 
    { 
        m_Array = new int [10]; //构造函数包含资源的分配
    } 
 
    void InitArray()  //使用资源
    { 
        for (int i = 0; i &lt; 10; ++i) 
        { 
            *(m_Array + i) = i; 
        } 
    } 
 
    void ShowArray() //使用资源
    { 
        for (int i = 0; i &lt;10; ++i) 
        { 
            cout&lt;&lt;m_Array[i]&lt;&lt;endl; 
        } 
    } 
 
    ~ArrayOperation()  //析构函数包含资源的释放
    { 
        cout&lt;&lt; &quot;~ArrayOperation is called&quot; &lt;&lt;endl; 
        if (m_Array != NULL ) 
        { 
            delete[] m_Array;  
            m_Array = NULL ; 
        } 
    } 
 
private : 
    int *m_Array;  //成员变量包含资源
}; 
 
int main() 
{ 
    ArrayOperation arrayOp; //资源自动分配
    arrayOp.InitArray(); 
    arrayOp.ShowArray(); 
    return 0;           //资源自动释放
}
</code></pre>
<p>根据RAII对资源的所有权控制，分为常性类型和外部初始化类型<br>上述示例即为常性类型，也是最纯粹的RAII形式，最容易理解，最容易编码。获取资源的地点是构造函数，释放点是析构函数，并且在这两点之间的一段时间里，任何对该RAII类型实例的操纵都不应该从它手里夺走资源的所有权<br>外部初始化类型是指资源在外部被创建，并被传给RAII实例的构造函数，后者进而接管了其所有权。boost::shared_ptr&lt;&gt;和std::auto_ptr&lt;&gt;都是此类型</p>
<h1 id="4-RAII的应用场景"><a href="#4-RAII的应用场景" class="headerlink" title="4.RAII的应用场景"></a>4.RAII的应用场景</h1><p>常见的应用有：</p>
<ul>
<li>文件操作</li>
<li>智能指针</li>
<li>互斥量</li>
</ul>
<h2 id="4-1文件操作"><a href="#4-1文件操作" class="headerlink" title="4.1文件操作"></a>4.1文件操作</h2><p>（1）常规形式</p>
<pre><code>void UseFile(char const* fn)  
{  
    FILE* f = fopen(fn, &quot;r&quot;);        // 获取资源  
    // 在此处使用文件句柄f...代码          // 使用资源  
    fclose(f);                       // 释放资源  
}  
</code></pre>
<p>（2）RAII<br>文件类：</p>
<pre><code>class FileHandle {  
public:  
    FileHandle(char const* n, char const* a) { p = fopen(n, a); } 
    ~FileHandle() { fclose(p); }  
private:   
    FileHandle(FileHandle const&amp;);  
    FileHandle&amp; operator= (FileHandle const&amp;); // 禁止拷贝操作  
    FILE *p;  
}; 
</code></pre>
<p> FileHandle 类的构造函数调用 fopen() 获取资源；FileHandle类的析构函数调用 fclose()释放资源。请注意，考虑到FileHandle对象代表一种资源，它并不具有拷贝语义，因此将拷贝构造函数和赋值运算符声明为私有成员<br> 使用：</p>
<pre><code>void UseFile(char const* fn)  
{  
    FileHandle file(fn, &quot;r&quot;);  
    // 在此处使用文件句柄  
    // 超出此作用域时，系统会自动调用file的析构函数，从而释放资源
}  
</code></pre>
<h2 id="4-2互斥量"><a href="#4-2互斥量" class="headerlink" title="4.2互斥量"></a>4.2互斥量</h2><p>C++标准库提供lock_guard类实现mutex分配与释放，其实现就是RAII方式。</p>
<pre><code>template&lt;class... _Mutexes&gt;
	class lock_guard
	{	// class with destructor that unlocks mutexes
public:
	explicit lock_guard(_Mutexes&amp;... _Mtxes)
		: _MyMutexes(_Mtxes...)
		{	// construct and lock
		_STD lock(_Mtxes...);
		}
 
	lock_guard(_Mutexes&amp;... _Mtxes, adopt_lock_t)
		: _MyMutexes(_Mtxes...)
		{	// construct but don&#39;t lock
		}
 
	~lock_guard() _NOEXCEPT
		{	// unlock all
		_For_each_tuple_element(
			_MyMutexes,
			[](auto&amp; _Mutex) _NOEXCEPT { _Mutex.unlock(); });
		}
 
	lock_guard(const lock_guard&amp;) = delete;
	lock_guard&amp; operator=(const lock_guard&amp;) = delete;
private:
	tuple&lt;_Mutexes&amp;...&gt; _MyMutexes;
	};
</code></pre>
<p>使用多线程时，经常会涉及到共享数据的问题，C++中通过实例化std::mutex创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。不过这意味着必须记住在每个函数出口都要去调用unlock()，也包括异常的情况，这非常麻烦，而且不易管理。C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，其会在构造函数的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。上面的代码属于mutex头文件</p>
<h2 id="4-3智能指针"><a href="#4-3智能指针" class="headerlink" title="4.3智能指针"></a>4.3智能指针</h2><p>先看一个例子，用RAII管理指针</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;fstream&gt;
using namespace std;

enum class shape_type {
    circle,
    rectangle,
};

class shape {
public:
    shape() { cout &lt;&lt; &quot;shape&quot; &lt;&lt; endl; }
    virtual void print() {
        cout &lt;&lt; &quot;I am shape&quot; &lt;&lt; endl;
    }
    virtual ~shape() {}
};

class circle : public shape {
public:
    circle() { cout &lt;&lt; &quot;circle&quot; &lt;&lt; endl; }
    void print() {
        cout &lt;&lt; &quot;I am circle&quot; &lt;&lt; endl;
    }
};

class rectangle : public shape {
public:
    rectangle() { cout &lt;&lt; &quot;rectangle&quot; &lt;&lt; endl; }
    void print() {
        cout &lt;&lt; &quot;I am rectangle&quot; &lt;&lt; endl;
    }
};

// 利用多态上转,如果返回值为shape,会存在对象切片问题。
shape *create_shape(shape_type type) {
    switch (type) {
        case shape_type::circle:
            return new circle();
        case shape_type::rectangle:
            return new rectangle();
    }
}

class shape_wrapper {
public:
    explicit shape_wrapper(shape *ptr = nullptr) : ptr_(ptr) {}

    ~shape_wrapper() {
        delete ptr_;
    }

    shape *get() const {
        return ptr_;
    }

private:
    shape *ptr_;
};
</code></pre>
<p>​<br>​<br>    int main() {</p>
<pre><code>    // 第一种方式, 手动管理指针
    shape *sp = create_shape(shape_type::circle);
    sp-&gt;print();
    delete sp; //显式delete

    // 第二种方式， RAII管理指针，一般封装到函数，更快释放
    shape_wrapper ptr(create_shape(shape_type::circle));
    ptr.get()-&gt;print();

    return 0;
}
</code></pre>
<p>C++标准库的智能指针：auto_ptr(C++11弃用), unique_ptr,shared_ptr, weak_ptr<br>可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/WindSun/p/11444429.html">WindSun:详解C++11智能指针</a></p>
<h2 id="4-4实现自己的RAII类"><a href="#4-4实现自己的RAII类" class="headerlink" title="4.4实现自己的RAII类"></a>4.4实现自己的RAII类</h2><p>一般情况下，RAII临时对象不允许复制和赋值，当然更不允许在heap上创建，所以先写下一个RAII的base类，使子类私有继承Base类来禁用这些操作：</p>
<pre><code>class RAIIBase  
{  
public:  
    RAIIBase(){}  
    ~RAIIBase(){}//由于不能使用该类的指针，定义虚函数是完全没有必要的  
      
    RAIIBase (const RAIIBase &amp;);  
    RAIIBase &amp; operator = (const RAIIBase &amp;);  
    void * operator new(size_t size);   
    // 不定义任何成员  
};
</code></pre>
<p>要写自己的RAII类时就可以直接继承该类的实现</p>
<pre><code>template&lt;typename T&gt;  
class ResourceHandle: private RAIIBase //私有继承 禁用Base的所有继承操作  
{  
public:  
    explicit ResourceHandle(T * aResource):r_(aResource){}//获取资源  
    ~ResourceHandle() {delete r_;} //释放资源  
    T *get()    {return r_ ;} //访问资源  
private:  
    T * r_;  
};
</code></pre>
<p>将Handle类做成模板类，这样就可以将class类型放入其中。另外，ResourceHandle可以根据不同资源类型的释放形式来定义不同的析构函数。由于不能使用该类的指针，所以不使用虚函数。</p>
<h1 id="5-GC和RAII"><a href="#5-GC和RAII" class="headerlink" title="5.GC和RAII"></a>5.GC和RAII</h1><p>在没有RAII的时代，GC和非GC语言是水火不容，GC追求开发效率和稳健设计，非GC如C++最求极致性能和绝对控制。RAII的设计机制，兼顾了两者的优点。<br>如果用三个等级代表程序员对系统资源的使用权限，如下：</p>
<ul>
<li>动态分配：C++的new&#x2F;delete之类，程序员100%负责内存使用和释放，编译器、操作系统不额外干预</li>
<li>垃圾回收(GC)：java&#x2F;go语言之类，程序员只负责要内存，而不用管，也管不了内存释放，其由该语言运行环境管理，规则可以描述成：如果一个资源没被任何对象使用(例如没有指针指向它)，运行环境定时或者其他方式检测到后，自动释放该资源，该过程对程序员不可控。可以说程序员有50%的权限，即想要就能要，但想甩却不能甩</li>
<li>RAII：程序员负责资源编排，运行时的分配与释放由系统自动完成，可以说程序员有90%的权限，放权10%给系统</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>RAII的本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来，从而确保在对象的生存期内资源始终有效，对象销毁时资源必被释放。换句话说，拥有对象就等于拥有资源，对象存在则资源必定存在。<br>具体实现：</p>
<ul>
<li>资源在构造函数中获取</li>
<li>资源在析构函数中释放</li>
<li>资源是类的成员变量</li>
<li>类的实例是堆栈分配的</li>
</ul>
<p>相关文章<br><a target="_blank" rel="noopener" href="https://light-city.club/sc/codingStyleIdioms/RAII/">C++那些事：RAII</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/10/30/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Socket%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/%E6%B5%85%E8%B0%88Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Socket%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">浅谈Linux网络编程: Socket基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-30 12:06:24" itemprop="dateCreated datePublished" datetime="2020-10-30T12:06:24+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="套接字（socket）基础"><a href="#套接字（socket）基础" class="headerlink" title="套接字（socket）基础"></a>套接字（socket）基础</h1><p>套接字是网络编程中，应用层和传输层之间的数据结构，其作用如下:<br>应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字(Socket)的接口，以区分不同应用程序进程间的网络通信和连接。</p>
<h1 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h1><p>通用套接字地址的结构体sockaddr定义如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411648.png" alt="1"><br>在以太网中，不直接使用sockaddr结构体，而使用sockaddr_in,其定义如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411109.png"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411045.png" alt="3"></p>
<p>通用结构体sockaddr和以太网的sockaddr_in结构体，有点像C++中的父类和子类的关系，sockaddr_in是对sockaddr的细化，其存储结构大小相同，分布如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411360.png" alt="4"><br>由于大小相同，在设置socket地址时，一般先设置sockaddr_in结构体，然后强转为sockaddr类型</p>
<h1 id="套接字地址结构在用户层和内核层的交互"><a href="#套接字地址结构在用户层和内核层的交互" class="headerlink" title="套接字地址结构在用户层和内核层的交互"></a>套接字地址结构在用户层和内核层的交互</h1><p>sockaddr的使用，以socket流程中的bind()函数为例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411733.png" alt="5"><br>bind函数需要传入sockaddr结构体的指针，和sockaddr结构体的长度</p>
<h2 id="向内核传入数据"><a href="#向内核传入数据" class="headerlink" title="向内核传入数据"></a>向内核传入数据</h2><p>向内核传入数据的socket函数有：bind,send<br>传入过程如下：</p>
<ul>
<li>sockaddr结构体的长度，以传值方式传入内核</li>
<li>内核通过sockaddr结构体的指针以及结构体长度，以内存复制的方式，从用户层拷贝sockaddr结构体到内核层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051411951.png" alt="6"></p>
<h2 id="从内核获取数据"><a href="#从内核获取数据" class="headerlink" title="从内核获取数据"></a>从内核获取数据</h2><p>从内核得到数据的socket函数有：accept,recv</p>
<ul>
<li>sockaddr结构体的长度，以传值方式传入内核</li>
<li>内核通过sockaddr结构体的指针以及结构体长度，以内存复制的方式，从内核层拷贝sockaddr结构体到用户层。</li>
<li>内核返回内核的结构体的长度<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412551.png" alt="7"></li>
</ul>
<h1 id="Socket编程流程"><a href="#Socket编程流程" class="headerlink" title="Socket编程流程"></a>Socket编程流程</h1><h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>TCP编程主要为C&#x2F;S模式，即服务器和客户端编程，我们讲socket编程，要区分是服务器端的流程还是客户端的流程。</p>
<ul>
<li>服务器端：创建服务-等待客户端连接-收到连接请求-处理</li>
<li>客户端：发起对服务器的连接请求-根据服务器的响应做处理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412551.png"></p>
<p>服务端各函数含义:</p>
<ul>
<li>socket：套接字初始化</li>
<li>bind：绑定套接字和端口</li>
<li>listen：配置服务器的请求队列，监测连接请求</li>
<li>accept：接受客户端连接</li>
<li>read&#x2F;write：数据的接收、发送</li>
<li>close：断开连接，释放套接字</li>
</ul>
<p>客户端函数：</p>
<ul>
<li>客户端套接字不需要绑定端口和监听，直接connect发起连接请求，其他函数和服务端一致。</li>
</ul>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>socket函数用于创建socket套接字的文件描述符，</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412223.png" alt="9"></p>
<p>有三个入参：</p>
<ul>
<li>domain：域，区分本地，IPV4 Internet，IPV6 Internet等。有的以PF开头，有的以AF开头，这两者值一样。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412180.png" alt="10"></p>
<ul>
<li>type：通信类型，如流式（TCP）,数据报式（UDP）等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412975.png" alt="11"></p>
<ul>
<li>protocal：协议类型，指定通信类型中的子类型，一般为0</li>
</ul>
<p>socket套接字初始化的一个例子：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051412776.png" alt="12"></p>
<h2 id="socket函数在应用层和内核层的交互"><a href="#socket函数在应用层和内核层的交互" class="headerlink" title="socket函数在应用层和内核层的交互"></a>socket函数在应用层和内核层的交互</h2><p>用户调用的socket函数，会调用内核的sys_socket函数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051415958.png" alt="2"></p>
<p>sys_socket做两件事：</p>
<ul>
<li><p>sock_create生成内核的socket结构，和应用层的结构不同，如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413920.png" alt="13"></p>
</li>
<li><p>sock_map_fd将内核socket结构绑定文件描述符fd,用户层可通过fd访问内核socket结构</p>
</li>
</ul>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>服务端用socket函数建立套接字文件描述符后，需要绑定地址和端口到该文件描述符，才能接受客户端请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413732.png" alt="14"></p>
<ul>
<li>sockfd：socket函数创建的文件描述符</li>
<li>sockaddr结构的指针：指向的sockaddr结构，包含ip和port等信息</li>
<li>addrlen：即sizeof(struct sockaddr)</li>
</ul>
<p>bind函数绑定UNIX族的套接字：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413483.png" alt="15"></p>
<p>bind函数绑定AF_INET族的套接字:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051413289.png" alt="16"></p>
<h2 id="bind函数在应用层和内核层的交互"><a href="#bind函数在应用层和内核层的交互" class="headerlink" title="bind函数在应用层和内核层的交互"></a>bind函数在应用层和内核层的交互</h2><p>以AF_INET族的套接字绑定为例，不同协议族实际上是调用内核不同的绑定函数<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051418474.png" alt="image-20221205141814380"></p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>listen函数用于初始化服务器的可连接队列，即服务器处理客户的请求，不是并行处理，而是异步的串行处理。服务器建立可连接队列，将当前不能同步处理的新请求放到队列中，等队列前面的请求处理完了，才异步处理这个请求。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051414568.png" alt="18"></p>
<ul>
<li>backlog是服务器可连接队列的最大长度</li>
<li>当前队列没满，即当前队列的请求没超过backlog值，才可以调用accept</li>
<li>listen函数只针对SOCK_STREAM和SOCK_SEQPACKET才能调用，因为TCP请求才需要建立连接。对于SOCK_DGRAM不支持listen，因为UDP是无连接的。</li>
</ul>
<p>TCP连接中，SOCK_STREAM类型的套接字，调用listen的示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419762.png" alt="image-20221205141912644"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419995.png" alt="image-20221205141921877"></p>
<h2 id="listen函数在应用层和内核层的交互"><a href="#listen函数在应用层和内核层的交互" class="headerlink" title="listen函数在应用层和内核层的交互"></a>listen函数在应用层和内核层的交互</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051419209.png" alt="image-20221205141934130"></p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>服务端用listen建立连接队列后，客户端以connect发来一个请求，会加入到服务端连接队列的队尾，当这个请求到达队头，会调用accept真正处理该请求。<br>accept会创建一个新的套接字文件描述符，用来描述客户端的连接，这个时候会有两个套接字描述符并存：</p>
<ul>
<li>socket函数创建的老的sockfd，表示正在监听的ip和端口</li>
<li>accept函数创建的新的clientfd，表示当前的客户端连接，后续的客户端的收发和客户端关闭，即send，recv，close函数，都使用clientfd</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420456.png" alt="image-20221205142030402"></p>
<p>流式连接的accept示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420563.png" alt="image-20221205142038423"><br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051420232.png" alt="image-20221205142048069"></p>
<h2 id="accept函数在应用层和内核层的交互"><a href="#accept函数在应用层和内核层的交互" class="headerlink" title="accept函数在应用层和内核层的交互"></a>accept函数在应用层和内核层的交互</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051421941.png" alt="image-20221205142100841"></p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>connect函数是客户端调用的函数，在客户端调用socket函数创建套接字文件sockfd后，可调用connect函数向服务端发起连接请求，请求的ip和端口信息包含在sockaddr结构体内。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051422137.png" alt="image-20221205142256082"></p>
<p>客户端的socket connect示例：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051422137.png"></p>
<h2 id="connect函数在应用层和内核层的交互"><a href="#connect函数在应用层和内核层的交互" class="headerlink" title="connect函数在应用层和内核层的交互"></a>connect函数在应用层和内核层的交互</h2><p>根据数据流式或数据报式的请求，具体调用inet_stream_connect或inet_dgram_connect<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423142.png" alt="image-20221205142315046"></p>
<h2 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h2><p>服务端和客户端真正建立连接后（socket通信逻辑连接，不是TCP&#x2F;UDP的面向连接&#x2F;无连接的传输层连接），即客户端发起connect，服务端accept完成，双方就可以相互read&#x2F;write，读写对方的数据，通过sockfd文件描述符，就像读写本地文件一样。</p>
<ul>
<li>read：从套接字文件读取数据，写入本地缓冲区，返回非空的有效数据大小<br> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423066.png" alt="image-20221205142328017"></li>
<li>write：向套接字文件写入数据，将本地缓冲区数据写入socket函数创建的socket文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423066.png"></li>
</ul>
<h2 id="close和shutdown函数"><a href="#close和shutdown函数" class="headerlink" title="close和shutdown函数"></a>close和shutdown函数</h2><ul>
<li>close：关闭socket连接，释放内核的套接字资源，不能通过套接字文件来读写操作</li>
<li>shutdown：支持读写的单向关闭，即关闭套接字文件的读、写、或者读写能力（等同于close）</li>
</ul>
<h1 id="Socket客户端和服务端交互的例程"><a href="#Socket客户端和服务端交互的例程" class="headerlink" title="Socket客户端和服务端交互的例程"></a>Socket客户端和服务端交互的例程</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>客户端从标准输入读取用户输入的字符串，发送给服务端，服务端读取数据，回写这些数据到客户端，客户端收到数据后输出到标准输出。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051423842.png" alt="image-20221205142345794"></p>
<p>客户端和服务端可以在同一台机器部署，访问回环地址127.0.0.1即可，注意服务端的监听端口不能和其他进程的端口冲突。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>服务端代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
//#define PORT 8088						/*侦听端口地址*/
#define BACKLOG 2						/*侦听队列长度*/

int main(int argc, char *argv[])
{
	int ss,sc;		/*ss为服务器的socket描述符，sc为客户端的socket描述符*/
	struct sockaddr_in server_addr;	/*服务器地址结构*/
	struct sockaddr_in client_addr;	/*客户端地址结构*/
	int err;							/*返回值*/
	pid_t pid;							/*分叉的进行ID*/

	/*建立一个流式套接字*/
	ss = socket(AF_INET, SOCK_STREAM, 0);
	if(ss &lt; 0){							/*出错*/
		printf(&quot;socket error\n&quot;);
		return -1;	
	}
	
	/*设置服务器地址*/
	bzero(&amp;server_addr, sizeof(server_addr));			/*清零*/
	server_addr.sin_family = AF_INET;					/*协议族*/
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);	/*本地地址*/
	//server_addr.sin_port = htons(PORT);
	server_addr.sin_port = htons(atoi(argv[1]));		/*服务器端口*/
	
	/*绑定地址结构到套接字描述符*/
	err = bind(ss, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));
	if(err &lt; 0){/*出错*/
		printf(&quot;bind error\n&quot;);
		return -1;	
	}
	
	/*设置侦听*/
	err = listen(ss, BACKLOG);
	if(err &lt; 0){										/*出错*/
		printf(&quot;listen error\n&quot;);
		return -1;	
	}
	
		/*主循环过程*/
	for(;;)	{
		socklen_t addrlen = sizeof(struct sockaddr);
		/*接受客户端连接*/
		sc = accept(ss, (struct sockaddr*)&amp;client_addr, &amp;addrlen); 
		if(sc &lt; 0){							/*出错*/
			continue;						/*结束本次循环*/
		}	
		
		/*建立一个新的进程处理到来的连接*/
		pid = fork();						/*分叉进程*/
		if( pid == 0 ){						/*子进程中*/
			process_conn_server(sc);		/*处理连接*/
			close(ss);						/*在子进程中关闭服务器的侦听*/
		}else{
			close(sc);						/*在父进程中关闭客户端的连接*/
		}
	}
}
</code></pre>
<p>服务端注意几点:</p>
<ul>
<li>accept后处理连接的过程，是在子进程中处理的，使用fork创建子进程用于连接处理。根据fork返回的pid是0还是其他，判断当前调度到子进程还是父进程，从全局上来讲，这个<code>if-else</code>的两种流程分别在父进程和子进程中指向。</li>
<li>服务端有两个套接字：侦听套接字和连接套接字。处理连接传入的是连接套接字。</li>
<li>在父进程（侦听进程）中，要关闭连接套接字；在子进程（连接处理进程）中，要关闭侦听套接字。这是为了避免子父进程相互影响。</li>
<li>对于多进程，一个进程的套接字关闭不会释放该套接字内存，只有所有进程都关闭了这个套接字，内核才会 释放该套接字，所有可以放心在侦听进程和连接处理进程中，关闭对方的套接字。</li>
</ul>
<p>客户端代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
//#define PORT 8088								/*侦听端口地址*/

int main(int argc, char *argv[])
{
	int s;										/*s为socket描述符*/
	struct sockaddr_in server_addr;			/*服务器地址结构*/
	
	s = socket(AF_INET, SOCK_STREAM, 0); 		/*建立一个流式套接字 */
	if(s &lt; 0){									/*出错*/
		printf(&quot;socket error\n&quot;);
		return -1;
	}	
	
	/*设置服务器地址*/
	bzero(&amp;server_addr, sizeof(server_addr));	/*清零*/
	server_addr.sin_family = AF_INET;					/*协议族*/
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);	/*本地地址*/
	server_addr.sin_port = htons(atoi(argv[2]));		/*服务器端口*/
	
	/*将用户输入的字符串类型的IP地址转为整型*/
	inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);	
	/*连接服务器*/
	connect(s, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr));
	process_conn_client(s);						/*客户端处理过程*/
	close(s);									/*关闭连接*/
	return 0;
}
</code></pre>
<p>建立连接后的读写交互代码，包含服务端的调用和客户端的调用：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
/*客户端的处理过程*/
void process_conn_client(int s)					/* 传入的是客户端调用socket时创建的s */
{
	ssize_t size = 0;
	char buffer[1024];							/*数据的缓冲区*/
	
	for(;;){									/*循环处理过程*/
		/*从标准输入中读取数据放到缓冲区buffer中,标准输入：0，标准输出：1，标准错误：2*/
		size = read(0, buffer, 1024);
		if(size &gt; 0){							/*读到数据*/
			write(s, buffer, size);				/*发送给服务器*/
			/*客户端阻塞，等待服务器有数据可读*/
			size = read(s, buffer, 1024);		/*从服务器读取数据*/
			write(1, buffer, size);				/*写到标准输出*/
		}
	}	
}
/*服务器对客户端的处理*/
void process_conn_server(int s) 				/* 传入的是服务端调用accept时创建的sc */
{
	ssize_t size = 0;
	char buffer[1024];							/*数据的缓冲区*/
	
	for(;;){									/*循环处理过程*/		
		size = read(s, buffer, 1024);			/*从套接字中读取数据放到缓冲区buffer中*/
		if(size == 0){							/*没有数据*/
			return;	
		}
		
		/*构建响应数据*/
		//sprintf(buffer, &quot;server receive %d bytes from client\n&quot;, size);
		//write(s, buffer, strlen(buffer));
		write(s, buffer, size);					/*发回给客户端*/
	}	
}
</code></pre>
<p>Makefile编译脚本:</p>
<pre><code>all:client server					#all规则，它依赖于client和server规则

client:tcp_process.o tcp_client.o	#client规则，生成客户端可执行程序
	gcc -o client tcp_process.o tcp_client.o
server:tcp_process.o tcp_server.o	#server规则，生成服务器端可执行程序
	gcc -o server tcp_process.o tcp_server.o	
tcp_process.o:						#tcp_process.o规则，生成tcp_process.o
	gcc -c tcp_process.c -o tcp_process.o
clean:								#清理规则，删除client、server和中间文件
	rm -f client server *.o
</code></pre>
<h2 id="部署和运行"><a href="#部署和运行" class="headerlink" title="部署和运行"></a>部署和运行</h2><p>后台运行server,指定监听端口:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424795.png" alt="image-20221205142401747"><br>运行client，指定服务端的ip, port：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424795.png"><br>客户端每输入一个字符串，服务端返回完全相同的字符串，通信正常<br>如果运行服务端时，有bind error，可能是端口被占用，<code>netstat</code>找到占用端口的PID，kill之后再运行server<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051424796.png" alt="image-20221205142416741"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/09/06/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E4%B8%8B%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E4%B8%8B%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Git多人协作下的换行符问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 11:23:00" itemprop="dateCreated datePublished" datetime="2020-09-06T11:23:00+08:00">2020-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目文件中有如下类型文件：</p>
<pre><code>Makefile, .sh, .bat, .cfg, .exe
</code></pre>
<p>源码用git管理，客户端用cygwin实现windows内的linux环境</p>
<p>问题：如何解决git多人协作下的linux、windows换行符差异问题？</p>
<p>(1)什么是换行符<br>LF：”\n”，Linux的换行符, 只包含“换行”；<br>CRLF：”\r\n”，Windows的换行符，包含“回车+换行”;</p>
<p>(2)不同换行符带来什么问题<br>用git管理代码，必定有远程端和本地端两个仓库，两端的操作系统不同，换行符可能有差异;</p>
<p>多人协作时，本地端可能有linux环境和windows, 如果所有人都是linux就不存在换行符差异的问题；如果有windows和linux就有该问题;<br>例如A上传了Linux换行符LF的代码到远程，B 本地环境是windows, B git pull下来，其git-config设置了自动转换成本地换行，将代码换行全成了CRLF，B上传后，远程仓库变成CRLF换行。此时A git diff查看，所有代码都有换行差异，扰乱真正的代码diff。</p>
<p>不仅是影响git diff， 换行差异还影响脚本执行</p>
<ul>
<li>例如LF换行的.sh，git pull到windows环境后换行转换成CRLF, 导致sh无法正常执行；</li>
<li>.bat调用.exe读取.cfg内的一行，.exe是windows程序，其readline方法只能识别CRLF换行，无法读取LF换行的.cfg文件内容</li>
</ul>
<h1 id="git的自动换行符转换配置"><a href="#git的自动换行符转换配置" class="headerlink" title="git的自动换行符转换配置"></a>git的自动换行符转换配置</h1><p>参考：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git">core.autocrlf</a></p>
<p>假如你正在 Windows 上写程序，而其他人用的是其他系统（或相反），你可能会遇到 CRLF 问题。 这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 macOS 和 Linux 只使用换行（LF）一个字符。 虽然这是小问题，但它会极大地扰乱跨平台协作。许多 Windows 上的编辑器会悄悄把行尾的换行字符转换成回车和换行， 或在用户按下 Enter 键时，插入回车和换行两个字符。</p>
<p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。 你可以用 core.autocrlf 来打开此项功能。 如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<pre><code>$ git config --global core.autocrlf true
</code></pre>
<p>如果使用以换行作为行结束符的 Linux 或 macOS，你不需要 Git 在检出文件时进行自动的转换； 然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p>
<pre><code>$ git config --global core.autocrlf input
</code></pre>
<p>这样在 Windows 上的检出文件中会保留回车和换行，而在 macOS 和 Linux 上，以及版本库中会保留换行。</p>
<p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中：</p>
<pre><code>$ git config --global core.autocrlf false
</code></pre>
<p><strong>使用<code>git config --global core.autocrlf input</code>就可以做到windows的CRLF换行自动转换成LF换行存储在git远程仓库，且git pull&#x2F;clone到本地时维持LF换行，不影响.sh等linux shell script执行。</strong></p>
<h1 id="手动换行符转换"><a href="#手动换行符转换" class="headerlink" title="手动换行符转换"></a>手动换行符转换</h1><ul>
<li><p>dos2unix FilePath</p>
</li>
<li><p>unix2dos FilePath</p>
</li>
<li><p>windows2linux</p>
<p> sed -i ‘s&#x2F;.$&#x2F;&#x2F;‘ FilePath</p>
</li>
<li><p>linux2windows</p>
<p> sed -i ‘s&#x2F;$&#x2F;\r&#x2F;‘ FilePath</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/09/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9ASSD%E7%9A%84S3-S4-S5%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9ASSD%E7%9A%84S3-S4-S5%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/" class="post-title-link" itemprop="url">Linux Shell笔记：SSD的S3/S4/S5压力测试脚本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-05 15:52:13" itemprop="dateCreated datePublished" datetime="2020-09-05T15:52:13+08:00">2020-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>存储设备产品（如SSD&#x2F;eMMC）的读写速度和稳定性测试，是量产前必不可少的步骤。除了常规的两个设备来回拷贝读写，存储设备做系统盘的情况下，反复的启动，睡眠，休眠，也是重要的测试项。本文介绍这几种测试的原理，工具实现，和调试过程</p>
<h1 id="系统电源状态"><a href="#系统电源状态" class="headerlink" title="系统电源状态"></a>系统电源状态</h1><p>ACPI（高级配置与电源接口）是电源配置和接口的规范，供操作系统和应用程序管理所有电源，其定义了几种状态（State）：S1~S6<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051553199.png" alt="image-20221205155311145"></p>
<p>操作系统在ACPI基础上实现各自的电源状态划分<br>Linux电源状态划分为如下：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554689.png" alt="image-20221205155406635"></p>
<p>其中，常见的几种状态有别称，如S3通常也称Suspend，S4也称Hibernation, S5即shutdown。下面描述这几种状态的区别</p>
<p>S3:<br>1、将系统当前的运行状态等数据保存在内存中，此时仍需要向RAM供电，以保证后续快速恢复至工作状态<br>2、冻结用户态的进程和内核态的任务（进入内核态的进程或内核自己的task）<br>3、关闭外围设备，如显示屏、鼠标等,中断唤醒外设不会关闭，如电源键<br>4、CPU停止工作</p>
<p>S4：<br>挂起到硬盘，俗称休眠（Hibernation）将系统当前的运行状态等数据保存到硬盘上，并自动关机。下次开机时便从硬盘上读取之前保存的数据，恢复到休眠关机之前的状态。<br>譬如在休眠关机时，桌面打开了一个应用，那么下一次开机启动时，该应用也处于打开状态。而正常的关机-开机流程，该应用是不会打开的</p>
<p>S5:<br>关机并断电，实际上，S5在不同场景下，可以指代关机和重启两种操作，关机是彻底power off的，而重启不是彻底断电，只是重新启动了系统，（当然基本所有设备都被reset），重启！&#x3D;关机再启动。</p>
<h1 id="测试工具设计"><a href="#测试工具设计" class="headerlink" title="测试工具设计"></a>测试工具设计</h1><p>需求：设计工具使系统从S0(working)进入S3&#x2F;S4&#x2F;S5状态，维持一段时间，然后退出该状态，在S0维持一段时间，再次进入S3&#x2F;S4&#x2F;S5状态，如此反复循环。用户输入工作模式（S3&#x2F;S4&#x2F;S5）和循环次数，工具输出运行日志，包含已运行次数和时间戳。</p>
<h2 id="Linux测试脚本实现"><a href="#Linux测试脚本实现" class="headerlink" title="Linux测试脚本实现"></a>Linux测试脚本实现</h2><p>Linux环境有现成的工具：rtcwake，参看其man page：</p>
<pre><code>NAME
       rtcwake - enter a system sleep state until specified wakeup time
SYNOPSIS
       rtcwake [options] [-d device] [-m standby_mode] {-s seconds|-t time_t}
DESCRIPTION
       This program is used to enter a system sleep state and to automatically wake from it at a specified time.
       This uses cross-platform Linux interfaces to enter a system sleep state, and leave it no later than a specified time.  It uses any RTC framework driver that supports standard driver model wakeup flags.
       This is normally used like the old apmsleep utility, to wake from a suspend state like ACPI S1 (standby) or S3 (suspend-to-RAM).  Most platforms can implement those without analogues of BIOS, APM, or ACPI.
       On some systems, this can also be used like nvram-wakeup, waking from states like ACPI S4 (suspend to disk).  Not all systems have persistent media that are appropriate for such suspend modes.
       Note that alarm functionality depends on hardware; not every RTC is able to setup an alarm up to 24 hours in the future.
       The suspend setup may be interrupted by active hardware; for example wireless USB input devices that continue to send events for some fraction of a second after the return key is pressed.  rtcwake tries to avoid this problem and it waits to terminal to settle down before entering a system sleep.
</code></pre>
<p>其重要option如下：</p>
<pre><code>      -m, --mode mode
              Go into the given standby state.  Valid values for mode are:

              standby
                     ACPI state S1.  This state offers minimal, though real,
                     power savings, while providing a very low-latency
                     transition back to a working system.  This is the
                     default mode.

              freeze The processes are frozen, all the devices are suspended
                     and all the processors idled.  This state is a general
                     state that does not need any platform-specific support,
                     but it saves less power than Suspend-to-RAM, because
                     the system is still in a running state.  (Available
                     since Linux 3.9.)

              mem    ACPI state S3 (Suspend-to-RAM).  This state offers
                     significant power savings as everything in the system
                     is put into a low-power state, except for memory, which
                     is placed in self-refresh mode to retain its contents.

              disk   ACPI state S4 (Suspend-to-disk).  This state offers the
                     greatest power savings, and can be used even in the
                     absence of low-level platform support for power
                     management.  This state operates similarly to Suspend-
                     to-RAM, but includes a final step of writing memory
                     contents to disk.

              off    ACPI state S5 (Poweroff).  This is done by calling
                     &#39;/sbin/shutdown&#39;.  Not officially supported by ACPI,
                     but it usually works.

              no     Don&#39;t suspend, only set the RTC wakeup time.

              on     Don&#39;t suspend, but read the RTC device until an alarm
                     time appears.  This mode is useful for debugging.

              disable
                     Disable a previously set alarm.

              show   Print alarm information in format: &quot;alarm: off|on
                     &lt;time&gt;&quot;.  The time is in ctime() output format, e.g.,
                     &quot;alarm: on  Tue Nov 16 04:48:45 2010&quot;.
                     
       -s, --seconds seconds
              Set the wakeup time to seconds in the future from now.

       -t, --time time_t
              Set the wakeup time to the absolute time time_t.  time_t is
              the time in seconds since 1970-01-01, 00:00 UTC.  Use the
              date(1) tool to convert between human-readable time and
              time_t.
</code></pre>
<p>只需要写shell script调用rtcwake即可<br>注意要求跨状态记录日志，S3&#x2F;S4很容易，运行信息只是被挪到内存、硬盘，不会丢失，但S5会shutdown, 因此循环次数和时间只能记录在掉电不丢失的硬盘里。<br>S3S4可以用一个脚本完成，而S5需要单独设计<br>S3S4.sh如下：<br>接受用户输入：<br>opt: S3或S4模式；COUNT：循环次数<br>每次执行rtcwake，日志写入LOG</p>
<pre><code>opt=$1
COUNT=$2
interval=30
s3timer=120
s4timer=120

mkdir -p log
DATE=$(date +%Y-%m-%d)
LOG=log/${opt}_${DATE}.log
cat /dev/null &gt; ${LOG}

echo &quot;=============================== $opt test start ===============================&quot; |tee -a ${LOG}

for (( i=1; i&lt;=$COUNT; i++ ))
do 
	if [ $opt == &quot;s3&quot; ];then
		echo &quot;************************* S3 Cycle: $i start *************************&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S3, Duration &quot;$s3timer&quot; sec&quot; |tee -a ${LOG}
		sudo rtcwake -m mem -s $s3timer &gt;&gt; ${LOG} 2&gt;&amp;1
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Waitable timer triggered.&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Wake up from S3, Cycle &quot;$i&quot;&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Successfully left sleep state S3...&quot; |tee -a ${LOG}
	elif [ $opt == &quot;s4&quot; ];then
		echo &quot;************************* S4 Cycle: $i start *************************&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S4, Duration &quot;$s4timer&quot; sec&quot; |tee -a ${LOG}
		sudo rtcwake -m disk -s $s4timer &gt;&gt; ${LOG} 2&gt;&amp;1
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Waitable timer triggered.&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Wake up from S4, Cycle &quot;$i&quot;&quot; |tee -a ${LOG}
		echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S`&quot; Successfully left sleep state S4...&quot; |tee -a ${LOG}
	else
		echo &quot;error input, use s3 or s4 as input&quot;
	fi
	echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;wake up for $interval seconds&quot; |tee -a ${LOG}
	echo &quot;************************* $opt Cycle: $i finish *************************&quot; |tee -a ${LOG}
	#keep wake up time
	sleep $interval
done

echo &quot;=============================== $opt test finished =============================== &quot; |tee -a ${LOG}
</code></pre>
<p>S5必须要解决两个问题：<br>1.每次测试的信息如何跨越重启<br>2.如何使系统自动不断的重启</p>
<p>对于1，可以将日志写入固定文件，每次重启后读该文件并追加，知道S5循环结束<br>对于2，Linux有开机自动启动某些桌面程序、shellscript的机制</p>
<p>S5测试脚本分为三部分：<br>配置自启动并执行首次重启的脚本：s5_start.sh<br>执行单次S5的脚本，即自启动调用的脚本：s5.sh<br>停止S5，清楚自启动配置的脚本：s5_stop.sh</p>
<p>s5_start.sh</p>
<pre><code>#!/bin/bash
USER=$(users)
opt=s5
interval=30
s5timer=180

#config autostart
mkdir -p /home/$USER/.config/autostart
touch /home/$USER/.config/autostart/s5.desktop
echo &quot;
[Desktop Entry]
Type=Application
Exec=gnome-terminal -e /home/$USER/s5.sh
Terminal=true
X-GNOME-Autostart-enabled=true
&quot; &gt; /home/$USER/.config/autostart/s5.desktop
chmod 777 /home/$USER/.config/autostart/s5.desktop
echo &quot;config autostart finished&quot;

#config sudo
echo &quot;$USER ALL=(ALL) NOPASSWD:ALL&quot; &gt;&gt; /etc/sudoers

#config s5 log and temp file 
mkdir -p log
DATE=$(date +%Y-%m-%d)
LOG=log/${opt}_${DATE}.log
cat /dev/null &gt; ${LOG}
echo &quot;1&quot; &gt; ${opt}_cycle.txt
echo &quot;$LOG&quot; &gt; ${opt}_log.txt
chmod 777 -R ./*.sh ./log/*.log ./*.txt

echo &quot;System will shutdown after &quot;$interval&quot; sec, then restart after &quot;$s5timer&quot; sec&quot;
echo &quot;*********************** S5 Cycle: 1 *************************&quot; |tee -a ${LOG}
echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S5 after &quot;$interval&quot; sec&quot; |tee -a ${LOG}
sleep $interval

rtcwake -m off -s $s5timer &gt;&gt; ${LOG} 2&gt;&amp;1
</code></pre>
<p>s5.sh</p>
<pre><code>#!/bin/bash
COUNT=&quot;999&quot;
opt=s5
interval=30
s5timer=180
cycle=$(&lt;${opt}_cycle.txt)
LOG=$(&lt;${opt}_log.txt)

#update cycle
((cycle++))
echo &quot;$cycle&quot; &gt; ${opt}_cycle.txt 

#keep wake
echo &quot;*********************** S5 Cycle: $cycle *************************&quot; |tee -a ${LOG}
echo `date +%Y-%m-%d&#39; &#39;%H:%M:%S` &quot;Going to S5 after &quot;$interval&quot; sec&quot; |tee -a ${LOG}
sleep $interval

sudo rtcwake -m off -s $s5timer &gt;&gt; ${LOG} 2&gt;&amp;1
</code></pre>
<p>s5_stop.sh</p>
<pre><code>#!/bin/bash
USER=$(users)
opt=s5
rm -f /home/$USER/.config/autostart/s5.desktop
rm -f ${opt}_cycle.txt ${opt}_log.txt
sed -i &#39;/NOPASSWD/d&#39; /etc/sudoers
</code></pre>
<h2 id="测试脚本使用"><a href="#测试脚本使用" class="headerlink" title="测试脚本使用"></a>测试脚本使用</h2><h3 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h3><pre><code>./s3s4.sh s3 999      启动s3测试,运行999次
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554212.png" alt="image-20221205155429129"></p>
<h3 id="S4"><a href="#S4" class="headerlink" title="S4"></a>S4</h3><p>S4在内存和硬盘直接读写运行时映像，硬盘需要指定那一块区域用于和内存交换，即交换分区。Linux一切皆文件，交换分区也可以用swapfile配置。以下配置swapfile</p>
<ol>
<li><p>df –h 查看挂载点为&#x2F;对应的文件系统是&#x2F;dev&#x2F;nvme0n1p2,根据你具体情况记录<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554816.png"></p>
</li>
<li><p><code>blkid</code>查看UUID值，根据1对应的nvme文件系统记录UUID<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554581.png"></p>
</li>
<li><p><code>filefrag –v /swapfile</code>查看swapfile的物理起始地址，记录physical_offset左侧值<img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051554581.png"></p>
</li>
<li><p>将UUID和physical_offset值写入grub：<br>终端输入gedit &#x2F;etc&#x2F;default&#x2F;grub ，修改以下参数并保存<br><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash resume=UUID=你的UUID值 resume_offset=你的physical_offset值</code>“</p>
<p> <img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051555015.png" alt="image-20221205155518922"></p>
</li>
<li><p>   重新生成grub: 终端输入 <code>update-grub</code> 回车并重启电脑。</p>
</li>
</ol>
<p>启动S4脚本</p>
<pre><code>./s3s4.sh s4 999
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051557197.png" alt="image-20221205155749113"></p>
<h3 id="S5"><a href="#S5" class="headerlink" title="S5"></a>S5</h3><p>自动重启需要先解决账户密码问题<br>设置普通账户自动登录：<br>普通账户为装系统时设置的账户，重启后默认以普通账户登录<br>1.终端输入<code>gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</code>弹出编辑界面<br>设置以下参数，ctrl+s保存后关闭</p>
<pre><code>[Seat:*]
user-session=ubuntu
autologin-user=你的账户名
</code></pre>
<p>2.终端输入<code>gedit /etc/gdm3/custom.conf</code>，设置以下几行的值为如下</p>
<pre><code># Enabling automatic login
AutomaticLoginEnable = true
AutomaticLogin =你的账户名
</code></pre>
<p>重启，确认可免密码登录桌面。</p>
<pre><code>./s5_start.sh 启动s5
./s5_stop.sh 结束S5
</code></pre>
<h1 id="Dmesg分析和调试"><a href="#Dmesg分析和调试" class="headerlink" title="Dmesg分析和调试"></a>Dmesg分析和调试</h1><h2 id="dmesg简介"><a href="#dmesg简介" class="headerlink" title="dmesg简介"></a>dmesg简介</h2><p>dmesg命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备<br>注意：<br>dmesg只记录从启动到当前时间的信息，掉电丢失</p>
<p>使用示例：</p>
<pre><code>dmesg //默认输出
dmesg | less //从头分页显示
dmesg | tail -100 //显示最后100行
dmesg | head  -100 //显示最早100行
dmesg | grep -i usb //包含usb的信息，忽略大小写
dmesg -C //清除log
</code></pre>
<p>输出示例：</p>
<pre><code>[root]# dmesg | grep sda
 
[    1.280971] sd 2:0:0:0: [sda] 488281250 512-byte logical blocks: (250 GB/232 GiB)
[    1.281014] sd 2:0:0:0: [sda] Write Protect is off
[    1.281016] sd 2:0:0:0: [sda] Mode Sense: 00 3a 00 00
[    1.281039] sd 2:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn&#39;t support DPO or FUA
[    1.359585]  sda: sda1 sda2 &lt; sda5 sda6 sda7 sda8 &gt;
[    1.360052] sd 2:0:0:0: [sda] Attached SCSI disk
[    2.347887] EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
[   22.928440] Adding 3905532k swap on /dev/sda6.  Priority:-1 extents:1 across:3905532k FS
[   23.950543] EXT4-fs (sda1): re-mounted. Opts: errors=remount-ro
[   24.134016] EXT4-fs (sda5): mounted filesystem with ordered data mode. Opts: (null)
[   24.330762] EXT4-fs (sda7): mounted filesystem with ordered data mode. Opts: (null)
[   24.561015] EXT4-fs (sda8): mounted filesystem with ordered data mode. Opts: (null)
</code></pre>
<p>输出时间戳是从上电开始，到当前的时间，以秒为单位。</p>
<h2 id="调试S4-hang"><a href="#调试S4-hang" class="headerlink" title="调试S4 hang"></a>调试S4 hang</h2><p>在测试中发现，nvme存储设备，首次进入S4的时间较长，约30s, 且系统处于hang状态，鼠标无法移动。<br>dmesg查看单次S4 enter &amp; resume的过程，log如下</p>
<pre><code>[   43.090180] PM: hibernation entry          //开机43秒进s4流程
[   43.090579] PM: Syncing filesystems ...   
[   43.090682] PM: done.
[   43.090684] Freezing user space processes ... (elapsed 0.003 seconds) done.   //冻结用户进程，这个时候会hang
[   43.093699] OOM killer disabled.
[   43.093876] PM: Marking nosave pages: [mem 0x00000000-0x00000fff]       //准备哪些内存要转存到disk
[   43.093878] PM: Marking nosave pages: [mem 0x0005f000-0x0005ffff]
[   43.093880] PM: Marking nosave pages: [mem 0x000a0000-0x000fffff]
[   43.093887] PM: Marking nosave pages: [mem 0x80185000-0x80186fff]
[   43.093889] PM: Marking nosave pages: [mem 0x88c4f000-0x890acfff]
[   43.093944] PM: Marking nosave pages: [mem 0x89214000-0x89efefff]
[   43.094102] PM: Marking nosave pages: [mem 0x89f00000-0xffffffff]
[   43.098151] PM: Basic memory bitmaps created
[   43.098541] PM: Preallocating image memory... 
[   43.143802] hpet_rtc_timer_reinit: 29 callbacks suppressed
[   43.143803] hpet1: lost 2 rtc interrupts
[   43.197779] hpet1: lost 2 rtc interrupts
[   43.251708] done (allocated 333315 pages)               //分配内存侧的交换页
[   43.251709] PM: Allocated 1333260 kbytes in 0.15 seconds (8888.40 MB/s)
[   43.251710] Freezing remaining freezable tasks ... (elapsed 0.126 seconds) done.
[   43.379023] printk: Suspending console(s) (use no_console_suspend to debug)
[   43.381268] serial 00:02: disabled
[   43.382187] parport_pc 00:01: disabled
[   43.701432] ACPI: Preparing to enter system sleep state S4  //准备进S4, 关CPU, 中断，
[   44.400195] PM: Saving platform NVS memory
[   44.404308] Disabling non-boot CPUs ...
[   44.404935] IRQ 123: no longer affine to CPU1
[   44.404942] IRQ 132: no longer affine to CPU1
[   44.405979] smpboot: CPU 1 is now offline
[   44.410695] smpboot: CPU 2 is now offline
[   44.414738] IRQ 122: no longer affine to CPU3
[   44.415784] smpboot: CPU 3 is now offline
[   44.422078] PM: Creating hibernation image:           //准备创建disk映像
[   44.503241] PM: Need to copy 330336 pages
[   44.503242] PM: Normal pages needed: 330336 + 1024, available pages: 1731140
                                                                                       //磁盘写入操作和时间没有记录
[   44.901845] PM: free pages cleared after restore    //S4已被唤醒，这里不是绝对时间，S4休眠时间未记入
[   44.901889] PM: Restoring platform NVS memory  
[   44.903440] Enabling non-boot CPUs ...
[   44.903474] x86: Booting SMP configuration:
[   44.903474] smpboot: Booting Node 0 Processor 1 APIC 0x2
[   44.904974]  cache: parent cpu1 should not be sleeping
[   44.905085] CPU1 is up
[   44.905101] smpboot: Booting Node 0 Processor 2 APIC 0x4
[   44.905478]  cache: parent cpu2 should not be sleeping
[   44.905602] CPU2 is up
[   44.905618] smpboot: Booting Node 0 Processor 3 APIC 0x6
[   44.905995]  cache: parent cpu3 should not be sleeping
[   44.906125] CPU3 is up
[   44.908816] ACPI: Waking up from system sleep state S4
[   45.003392] usb usb1: root hub lost power or was reset
[   45.003393] usb usb2: root hub lost power or was reset
[   45.006573] sd 0:0:0:0: [sda] Starting disk
[   45.006732] parport_pc 00:01: activated
[   45.008262] serial 00:02: activated
[   45.384656] ata1: SATA link up 3.0 Gbps (SStatus 123 SControl 300)
[   45.384717] ata2: SATA link down (SStatus 4 SControl 300)
[   45.384741] ata3: SATA link down (SStatus 4 SControl 300)
[   45.384758] ata6: SATA link down (SStatus 4 SControl 300)
[   45.384779] ata5: SATA link down (SStatus 4 SControl 300)
[   45.384798] ata4: SATA link down (SStatus 4 SControl 300)
[   45.387712] ata1.00: configured for UDMA/100
[   45.500662] usb 1-9: reset low-speed USB device number 2 using xhci_hcd
[   46.056539] usb 1-10: reset low-speed USB device number 3 using xhci_hcd
[   46.318112] nvme nvme0: 4/0/0 default/read/poll queues
[   46.336791] nvme nvme0: ctrl returned bogus length: 2 for NVME_NIDT_EUI64
[   46.363904] acpi LNXPOWER:07: Turning OFF
[   46.363916] acpi LNXPOWER:06: Turning OFF
[   46.364472] PM: Basic memory bitmaps freed
[   46.364474] OOM killer enabled.
[   46.364475] Restarting tasks ... done.   //恢复进程
[   47.098831] e1000e: eno1 NIC Link is Up 100 Mbps Full Duplex, Flow Control: None
[   47.098837] e1000e 0000:00:1f.6 eno1: 10/100 speed: disabling TSO
[   49.489104] video LNXVIDEO:00: Restoring backlight state
[   49.489109] PM: hibernation exit    //S4退出完成
</code></pre>
<p>比较奇怪的是，dmesg没记录写磁盘的操作,时间戳上也反映不出来。可能这时候IO交给DMA了，kernel就挂起了，所以dmesg无法工作，包括时间戳记录？？<br>为了验证S4 hang原因在于写磁盘，对不同SSD做读写测速：</p>
<pre><code>DISK               :         R/W speed MB/s   :       S4 hang time
Samsung SATA SSD   :         567/529          :       4s
Our SSD            :         170.1/104.7      :       25s
</code></pre>
<p>基本验证读写速度和S4 hang是线性关系。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/08/27/Github%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/Github%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Github常用配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-27 10:57:00" itemprop="dateCreated datePublished" datetime="2020-08-27T10:57:00+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-03 15:01:58" itemprop="dateModified" datetime="2025-01-03T15:01:58+08:00">2025-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Github常用配置笔记"><a href="#Github常用配置笔记" class="headerlink" title="Github常用配置笔记"></a>Github常用配置笔记</h1><h2 id="配置SSH登录（Github，Gitlab等各种git-server通用）"><a href="#配置SSH登录（Github，Gitlab等各种git-server通用）" class="headerlink" title="配置SSH登录（Github，Gitlab等各种git server通用）"></a>配置SSH登录（Github，Gitlab等各种git server通用）</h2><p>配置SSH登录的目的是git操作免密码验证，方便拉取和上传代码。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000043924833">https://segmentfault.com/a/1190000043924833</a> (若要为个人和公司使用不同git账号，见此链接)</p>
<p>下面windows环境创建全局使用唯一的git账号和SSH key；</p>
<p>Linux环境创建SSH key，先查看~&#x2F;.ssh有没有key，如果没有key或者有key但git clone有问题，可以删除key再重新创建id_rsa.pub</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ git config --global user.name thomas.hu</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ git config --global user.email thomas.hu@o2micro.com</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/cursorhu/.ssh/id_rsa):</span><br><span class="line">/c/Users/cursorhu/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)?</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ cat /c/Users/cursorhu/.ssh/id_rsa</span><br><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn</span><br><span class="line">....</span><br><span class="line">2hdYrBeOK+vu1LAAAACGN1cnNvcmh1AQI=</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br><span class="line"></span><br><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ cat /c/Users/cursorhu/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDONvU2p10NVjRhu6UGlEMsRWqhbo16zK2Tnqg8....chI60tVZHozCK9PMKZd4dE9RoYMXpJWTo6uIRKEV41qHfaiipfsu1ibRCj1drz/3BTs= cursorhu</span><br></pre></td></tr></table></figure>

<p>最后将id_rsa.pub公钥内容文本粘贴到github&#x2F;gitlab的git账号设置页面中，之后无需登录密码即可git clone，git push。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cursorhu@DESKTOP-73G2O3N MINGW64 /c/gitlab-bht</span><br><span class="line">$ git clone git@10.52.1.103:software/storport.git</span><br><span class="line">Cloning into &#x27;storport&#x27;...</span><br><span class="line">remote: Enumerating objects: 12830, done.</span><br><span class="line">remote: Counting objects: 100% (12830/12830), done.</span><br><span class="line">remote: Compressing objects: 100% (3441/3441), done.</span><br><span class="line">remote: Total 12830 (delta 9621), reused 12368 (delta 9251)</span><br><span class="line">Receiving objects: 100% (12830/12830), 259.92 MiB | 52.21 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (9621/9621), done.</span><br></pre></td></tr></table></figure>



<h2 id="初始化git和github仓库"><a href="#初始化git和github仓库" class="headerlink" title="初始化git和github仓库"></a>初始化git和github仓库</h2><p>1.安装git</p>
<p>2.进入本地源码目录</p>
<pre><code>git init
</code></pre>
<p>会出现.git目录<br>首次需要配置github账户和邮箱</p>
<pre><code>git config --global user.name &quot;github注册的用户名&quot;
git config --global user.mail &quot;github注册的邮箱&quot;
</code></pre>
<p>3.添加远程仓库</p>
<p>在github网页新建仓库</p>
<pre><code>git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<p>.git&#x2F;config文件内容会出现remote等内容，ssh方式的url是git开头，http(s)方式是http(s)开头<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051116187.png" alt="image-20221205111653141"><br>如果是从别人拉过来的仓库，修改后新建仓库，上传遇到<code>fatal: remote origin already exists</code>问题，解决方法:</p>
<pre><code>git remote rm origin
git remote add origin git@github.com:github用户名/仓库名.git
</code></pre>
<p>4.git add, commit, push三连</p>
<pre><code>git add -A
git commit -m &#39;first commit&#39;
git push -f --set-upstream origin master //首次提交
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117987.png" alt="image-20221205111703940"><br>完成以后远程可以看得到仓库的文件   </p>
<p>5.创建分支</p>
<p>如果已经有主线，在本地<code>git checkout branchname</code>, 远程创建分支，记录.git链接， 然后关联远程分支即可：</p>
<pre><code>git remote add origin https://github.com/*/*.git
</code></pre>
<p>然后推送</p>
<pre><code>git push origin branchname
</code></pre>
<h2 id="首次配置可能的问题："><a href="#首次配置可能的问题：" class="headerlink" title="首次配置可能的问题："></a>首次配置可能的问题：</h2><h3 id="push时有RSA-key错误"><a href="#push时有RSA-key错误" class="headerlink" title="push时有RSA key错误"></a>push时有RSA key错误</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117281.png" alt="image-20221205111713234"><br>因为Git使用SSH连接，而SSH第一次连接需要验证GitHub服务器的Key。确认GitHub的Key的指纹信息是否真的来自GitHub的服务器。解决办法是在本地生成key，配置到github服务器<br>（1)创建ssh key</p>
<pre><code>ls -al ~/.ssh
ssh-keygen -t rsa -C &quot;github用户名&quot;
全部回车默认，生成key
cat ~/.ssh/id_rsa.pub
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117255.png" alt="image-20221205111721197"><br>在push三连过程可以设置global全局配置，以后默认push到github<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117055.png" alt="image-20221205111728996"></p>
<p>（2）配置ssh key到github<br>登陆github,头像-settings-new SSH,复制新生成的SSH配置到服务器<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051117386.png" alt="image-20221205111737339"><br>（3）需要重新add origin新建仓库（或者网页上新建仓库)，再push，<code>git status</code>和<code>git log</code>查看分支和日志</p>
<h3 id="push时不能使用密码登陆"><a href="#push时不能使用密码登陆" class="headerlink" title="push时不能使用密码登陆"></a>push时不能使用密码登陆</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Support for password authentication was removed on August 13, 2021.</span><br></pre></td></tr></table></figure>

<p>使用personal token替代密码登陆：</p>
<p>Github setting -&gt; Developer setting -&gt; Personal access token -&gt; Generate a New Token (classic) -&gt; 设置不过时，所有权限勾上 -&gt; 首次会显示token字符，下次不会显示，记得备份token！-&gt; 再次输入账号密码时用token代替密码即可push</p>
<h3 id="git-clone有HTTP2错误"><a href="#git-clone有HTTP2错误" class="headerlink" title="git clone有HTTP2错误"></a>git clone有HTTP2错误</h3><p>错误码：RPC failed; curl 16 Error in the HTTP2 framing layer</p>
<p>解决办法：Git使用HTTP1.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.version HTTP/1.1</span><br></pre></td></tr></table></figure>

<h2 id="Github-clone使用国内镜像"><a href="#Github-clone使用国内镜像" class="headerlink" title="Github clone使用国内镜像"></a>Github clone使用国内镜像</h2><p>国内搞开发最痛苦的就是限速+断开连接，github clone经常失败。推荐国内镜像服务作为代理进行git clone，将原git地址的github.com替换成代理地址即可。参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/463954956">无需代理直接加速各种 GitHub 资源拉取</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#git clone原地址</span><br><span class="line">$ git clone https://github.com/kubernetes/kubernetes.git</span><br><span class="line"></span><br><span class="line">#手动配置代理地址，任选其一能clone成功即可</span><br><span class="line">$ git clone https://github.com.cnpmjs.org/kubernetes/kubernetes.git</span><br><span class="line">$ git clone https://hub.fastgit.org/kubernetes/kubernetes.git</span><br><span class="line">$ git clone https://gitclone.com/github.com/kubernetes/kubernetes.git</span><br><span class="line"></span><br><span class="line">#配置git自动使用代理，配置以后可以用git clone原地址，自动走代理</span><br><span class="line">git config --global url.&quot;https://hub.fastgit.org&quot;.insteadOf https://github.com</span><br><span class="line">#取消自动代理</span><br><span class="line">$ git config --global --unset url.https://github.com/.insteadof</span><br></pre></td></tr></table></figure>

<p>使用国内镜像并不一定能解决所有clone问题，有的recursive clone对依赖包有版本要求，国内镜像版本不匹配导致clone fail，此时不能使用国内镜像。</p>
<p>解决版本：下载release版本的zip包，绕开git clone操作。</p>
<h2 id="Github连接报错问题"><a href="#Github连接报错问题" class="headerlink" title="Github连接报错问题"></a>Github连接报错问题</h2><h3 id="OpenSSL-errno-10054"><a href="#OpenSSL-errno-10054" class="headerlink" title="OpenSSL errno 10054"></a>OpenSSL errno 10054</h3><p>一劳永逸的解决办法：git bash -&gt; git config –global http.sslVerify “false”</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29493173/article/details/114534057">OpenSSL SSL_read: Connection was reset, errno 10054</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">Linux Shell笔记：实现芯片固件的批量编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-12 14:58:37" itemprop="dateCreated datePublished" datetime="2020-08-12T14:58:37+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某软件有不同的配置参数，实现不同功能版本的编译<br>批量测试需要批量编译各种版本，实现方式为：<br>1.将编译参数组合，生成大量配置文件<br>2.编译过程遍历这些配置文件，依次编译对应版本<br>3.有参数加入，修改，删除，只需要更新这些配置文件<br>如何实现这些配置文件的更新？</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>某芯片的Firmware批量编译实现：<br>Firmware代码为C, 配置参数用宏实现，后缀为.def<br>目录结构如下</p>
<p>|–project_folder<br>　　|–config<br>　　　|–build.def<br>　　　|–defs<br>　　　　　|–1.def 2.def … n.def<br>　　|–src<br>　　|–Makefile<br>　　|–build_All.sh<br>　　|–update.sh</p>
<h2 id="批量编译脚本"><a href="#批量编译脚本" class="headerlink" title="批量编译脚本"></a>批量编译脚本</h2><p>批量编译脚本如下<br>基本过程：<br>1.依次拷贝def文件夹中的每个def，替换默认的build.def<br>2.编译，接受所有编译参数<br>3.拷贝编译输出的image到包含git tag, def名，时间等信息的文件夹</p>
<pre><code>#!/bin/bash

echo &quot;Batch build support args:&quot;
echo &quot;1. functin version:&quot;
echo &quot;verargs=mp_fpga&quot;
echo &quot;verargs=mpw_asic&quot;
echo &quot;2. boot debug:&quot;
echo &quot;bootargs=debug&quot;

OUTPUT=batch_build_$1$2

mkdir -p ${OUTPUT}
rm -rf ./batch_build_*

build_time=`date +%Y%m%d%H%M%S`

#commit_id=`git rev-parse HEAD`

tag_name=`git describe --exact-match --tags 2&gt;/dev/null`

if [ -z &quot;${tag_name}&quot; ]; then
	tag_name=&quot;NO_TAG&quot;
fi

mv ./config/build.def ./config/build.def.bak 

for file in `ls ./config/defs/*.def`;
do
	file_name=${file##*/}
	config_name=${file_name%.def}
	
	cp -rf ${file} ./config/build.def
	make clean
	make -j4 $@
	#mv ./build/image ./batch_build/${tag_name}_${config_name}_time_${build_time}_cid_${commit_id}
	mkdir -p ./${OUTPUT}/${tag_name}_${config_name}_time_${build_time}
	mv ./build/image/* ./${OUTPUT}/${tag_name}_${config_name}_time_${build_time}
done

mv ./config/build.def.bak ./config/build.def
</code></pre>
<p>def文件内的.def文件即各种参数配置文件，.def文件名即参数功能的别名组合<br>例如：</p>
<pre><code>CQ_emmc_two_card_enhance_hs400_always_l0_MSIx_dllphase14_tuning_on.def
</code></pre>
<p>对应的内容是：</p>
<pre><code>/*0: Non-CQ mode 1:CQ mode enable*/
#define BB_CQ_MODE_ENABLE 1
/*the card number support emmc#0:0 emmc#1:1 two card:2*/
#define BB_CARD_NUMBER 2
/*0:legacy 1:High Speed 50MHz 2:HS200 3:HS400 4:Enhance HS400*/
#define BB_MAX_TRANSFER_MODE 4
/* power mode management: 0: Low Power 1:Balance 2:High Performance 3:Direct HP 4:Always L0*/
#define POWER_MANAGEMENT_MODE 4
/* INT_MODE: 0:MSI_X 1:INTx 2:MSI_MULTIPLE 3:MSI_SINGLE */
#define INT_MODE 0
/* The selection of DLL PHASE COUNT is 11 or 14 */
#define DLL_phase_cnt 14
/* 0: fixed output phase  1: auto output tuning */
#define AUTO_OUTPUT_TUNING 1
</code></pre>
<h2 id="批量编辑配置文件"><a href="#批量编辑配置文件" class="headerlink" title="批量编辑配置文件"></a>批量编辑配置文件</h2><p>配置文件def有两个属性<br>1.文件名每个词代表一个功能，各词用下划线“_”分隔<br>2.内部用宏定义实现功能配置，宏定义的值要和外部文件名匹配</p>
<p>基于以上属性，编辑脚本需求为：<br>1.新增：增加一个宏定义，并增加对应的功能缩写到文件名<br>2.修改：修改一个已存在的宏定义，并修改对应的功能缩写到文件名<br>3.删除：删除一个已存在的宏定义，并删除对应的功能缩写到文件名<br>4.其他功能，如直接删除含某缩写的文件，备份原配置文件</p>
<p>shell实现为update.sh,如下:</p>
<pre><code>#!/bin/bash

DEFS_PATH=&quot;./config/defs&quot;
DEFS_BACKUP_PATH=&quot;./config/defs_backup&quot;
DEFS_TEMP_PATH=&quot;./config/defs_temp&quot;

if [ $# -lt 1 ];then
		echo &quot;usage: ./update.sh [option] [args]&quot;

		echo &quot;example 0:&quot;
		echo &quot;		backup defs files:&quot;
		echo &quot;		./update.sh -bf&quot;
		echo &quot;&quot;

		echo &quot;example 1:&quot;
		echo &quot;		add a macro name and macro value to defs, and add file postfix:&quot;
		echo &quot;		./update.sh -b&quot;
		echo &quot;		./update.sh -a balance POWER_MANAGEMENT_MODE 1 &quot;
		echo &quot;		./update.sh -a high_performance POWER_MANAGEMENT_MODE 2 &quot;
		echo &quot;		add other values...&quot;
		echo &quot;&quot;

		echo &quot;example 2:&quot;
		echo &quot;		update a macro name and macro value to defs, and update file postfix:&quot;
		echo &quot;		./update.sh -u balance lowpower POWER_MANAGEMENT_MODE 1 &quot;
		echo &quot;&quot;

		echo &quot;example 3:&quot;
		echo &quot;		delete a macro name and macro value of defs, and delete file postfix:&quot;
		echo &quot;		./update.sh -d lowpower POWER_MANAGEMENT_MODE&quot;
		echo &quot;&quot;

		echo &quot;example 4:&quot;
		echo &quot;		delete target files:&quot;
		echo &quot;		./update.sh -df lowpower&quot;
		echo &quot;&quot;

		echo &quot;example 5:&quot;
		echo &quot;		clean backup defs files:&quot;
		echo &quot;		./update.sh -cf&quot;
		echo &quot;&quot;

		exit;
	fi

if [ $1 = &quot;-bf&quot; ];then #backup defs
	mkdir -p $DEFS_BACKUP_PATH
	mv $DEFS_PATH/*.def $DEFS_BACKUP_PATH

elif [ $1 = &quot;-cf&quot; ];then #clear backup defs
	rm -rf $DEFS_BACKUP_PATH
</code></pre>
<p>​<br>​    #add a macro name and macro value to defs, and add file postfix<br>​    elif [ $1 &#x3D; “-a” ];then<br>​<br>    	if [ $# !&#x3D; 4 ];then<br>    		echo “usage: .&#x2F;update.sh -a FILE_POSTFIX MACRO_NAME MACRO_VALUE”<br>    		exit;<br>    	fi</p>
<pre><code>	mkdir -p $DEFS_TEMP_PATH &amp;&amp; cp -rf $DEFS_BACKUP_PATH/*.def $DEFS_TEMP_PATH
	
	FILE_POSTFIX=$2
	MACRO_NAME=$3
	MACRO_VALUE=$4
	# sed -i makes change on original file, otherwise on stream
	# xargs transfer multiple output from stream to multiple args to sed
	find ${DEFS_TEMP_PATH} -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
	
	for file in `ls ${DEFS_TEMP_PATH}/*.def`
	do
	 mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
	done
	
	cp -rf $DEFS_TEMP_PATH/*.def $DEFS_PATH
	rm -rf $DEFS_TEMP_PATH

#update a macro name and macro value to defs, and update file postfix
elif [ $1 = &quot;-u&quot; ];then

	if [ $# != 5 ];then
		echo &quot;usage: ./update.sh -u ORIGIN_POSTFIX UPDATED_POSTFIX MACRO_NAME MACRO_UPDATED_VALUE&quot;
		exit;
	fi

	ORIGIN_POSTFIX=$2
	UPDATED_POSTFIX=$3
	MACRO_NAME=$4
	MACRO_UPDATED_VALUE=$5

	#replace all lines that pattern matches $MACRO_NAME
	find ${DEFS_PATH} -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
	#update file postfix
	for file in `ls ${DEFS_PATH}/*$ORIGIN_POSTFIX*.def`
	do
	 	mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
	done
</code></pre>
<p>​<br>​    #delete a macro name and macro value of defs, and delete file postfix<br>​    elif [ $1 &#x3D; “-d” ];then<br>​    	<br>    	if [ $# !&#x3D; 3 ];then<br>    		echo “usage: .&#x2F;update.sh -d DELETE_POSTFIX MACRO_NAME”<br>    		exit;<br>    	fi</p>
<pre><code>	DELETE_POSTFIX=$2
	MACRO_NAME=$3
	#delete all lines that contain $MACRO_NAME
	find ${DEFS_PATH} -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
	#delete file postfix
	for file in `ls ${DEFS_PATH}/*.def`
	do
	 	mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
	done

#delete target file by postfix
elif [ $1 = &quot;-df&quot; ];then
	
	if [ $# != 2 ];then
		echo &quot;usage: ./update.sh -df DELETE_POSTFIX&quot;
		exit;
	fi

	DELETE_POSTFIX=$2
	rm -f ${DEFS_PATH}/*$DELETE_POSTFIX*.def

fi
</code></pre>
<p><strong>重点讲下其中的几个sed和文件操作</strong><br>1.多个文件，每个文件最后一行追加内容</p>
<pre><code>find ${DEFS_TEMP_PATH} -name &#39;*.def&#39; | xargs sed -i &#39;$a\#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_VALUE&quot;&#39;&#39;
</code></pre>
<ul>
<li>xargs的作用： find <path> -name <string> 输出的是多个文件名，不能直接传给sed， <strong>xargs将多个文件名转化成多个参数</strong>，每个参数是一个文件名，sed可以接收</li>
<li>-i的作用：sed本身是在文件的拷贝上操作，不直接在文件本身修改，-i（insert）使sed的操作在文件上生效，<strong>如果不加-i，源文件不会被修改</strong></li>
<li>$：表示最后一行，sed ‘a\string’是基础格式</li>
<li>注意sed怎么用带空格和变量的字符串：<strong>空格用转义’\ ‘表示，变量是单引号内加双引号</strong>，即’”$ARG”‘</li>
</ul>
<p>2.找到包含字符串A的所有文件，替换内容：将字符串B替换为C</p>
<pre><code>#replace all lines that pattern matches $MACRO_NAME
find ${DEFS_PATH} -name &#39;*.def&#39; | grep $ORIGIN_POSTFIX | xargs sed -i &#39;s/.*&#39;&quot;$MACRO_NAME&quot;&#39;.*/#define\ &#39;&quot;$MACRO_NAME&quot;&#39;\ &#39;&quot;$MACRO_UPDATED_VALUE&quot;&#39;/g&#39;
</code></pre>
<ul>
<li>find | grep 是常用套路，先找在过滤，注意find -name 可以使用*， grep不要用*，否则grep会把它当成要匹配的字符</li>
<li>sed ‘s&#x2F;stringB&#x2F;stringC’是基础格式，g表示全局，注意要-i</li>
</ul>
<p>3.找到包含字符串A的所有文件，删除内容：包含字符串B的行</p>
<pre><code>#delete all lines that contain $MACRO_NAME
find ${DEFS_PATH} -name &#39;*.def&#39; | grep $DELETE_POSTFIX | xargs sed -i &#39;/&#39;&quot;$MACRO_NAME&quot;&#39;/d&#39;
</code></pre>
<p>4.对多个文件的文件名，增加，修改，删除特定字符串</p>
<pre><code>#在原文件名最后，后缀之前，增加字符串“_$FILE_POSTFIX”
for file in `ls ${DEFS_TEMP_PATH}/*.def`
	do
	 mv $file `echo $file | sed &#39;s/\(.*\)\(\..*\)/\1_&#39;&quot;$FILE_POSTFIX&quot;&#39;\2/g&#39;`
	done

#替换文件名中匹配的字符
for file in `ls ${DEFS_PATH}/*$ORIGIN_POSTFIX*.def`
do
 	mv $file `echo $file | sed &#39;s/&#39;&quot;$ORIGIN_POSTFIX&quot;&#39;/&#39;&quot;$UPDATED_POSTFIX&quot;&#39;/g&#39;`
done

#删除文件名指定字符
for file in `ls ${DEFS_PATH}/*.def`
do
 	mv $file `echo $file | sed &#39;s/_&#39;&quot;$DELETE_POSTFIX&quot;&#39;//g&#39;`
done
</code></pre>
<ul>
<li>for &lt; args &gt; in `ls &lt; path &gt;`是把多个文件名依次写入变量args的常用操作，类似于xargs，不过是用循环每次处理一个文件名变量</li>
<li>mv $file `echo $file | sed ‘s&#x2F;stringA&#x2F;stringB&#x2F;g’&#96;实际是两个步骤：先用echo把当前处理的文件名传给sed, sed处理完的输出文件名，作为mv的目标文件名，覆盖了原文件</li>
<li>注意，文件名xargs传给sed,处理的是文件内容，for-in-do一个个mv，才是处理文件名本身</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a target="_blank" rel="noopener" href="https://linux.cn/article-11367-1.html">使用 sed 命令查找和替换文件中的字符串的 16 个示例</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40572607/article/details/90812959">sed引入变量的几种方法</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/elong490/article/details/52587171">sed 批量替换文件内容</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/06/22/GCC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/22/GCC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">GCC使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-22 17:22:34" itemprop="dateCreated datePublished" datetime="2020-06-22T17:22:34+08:00">2020-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GCC/" itemprop="url" rel="index"><span itemprop="name">GCC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gcc编译选项"><a href="#gcc编译选项" class="headerlink" title="gcc编译选项"></a>gcc编译选项</h1><p>gcc提供了大量的警告选项，对代码中可能存在的问题提出警告，通常可以使用-Wall来开启以下警告:</p>
<pre><code>   -Waddress -Warray-bounds (only with -O2) -Wc++0x-compat
   -Wchar-subscripts -Wimplicit-int -Wimplicit-function-declaration
   -Wcomment -Wformat -Wmain (only for C/ObjC and unless
   -ffreestanding) -Wmissing-braces -Wnonnull -Wparentheses
   -Wpointer-sign -Wreorder -Wreturn-type -Wsequence-point
   -Wsign-compare (only in C++) -Wstrict-aliasing -Wstrict-overflow=1
   -Wswitch -Wtrigraphs -Wuninitialized (only with -O1 and above)
   -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value
   -Wunused-variable

unused-function:警告声明但是没有定义的static函数;
unused- label:声明但是未使用的标签;
unused-parameter:警告未使用的函数参数;
unused-variable:声明但是未使用的本地变量;
unused-value:计算了但是未使用的值;
format:printf和scanf这样的函数中的格式字符串的使用不当;
implicit-int:未指定类型;
implicit-function:函数在声明前使用;
char- subscripts:使用char类作为数组下标(因为char可能是有符号数);
missingbraces:大括号不匹配;
parentheses: 圆括号不匹配;
return-type:函数有无返回值以及返回值类型不匹配;
sequence-point:违反顺序点的代码,比如 a[i] = c[i++];
switch:switch语句缺少default或者switch使用枚举变量为索引时缺少某个变量的case;
strict- aliasing=n:使用n设置对指针变量指向的对象类型产生警告的限制程度,默认n=3;只有在-fstrict-aliasing设置的情况下有效;
unknow-pragmas:使用未知的#pragma指令;
uninitialized:使用的变量为初始化,只在-O2时有效;
</code></pre>
<p>以下是在-Wall中不会激活的警告选项:</p>
<pre><code>cast-align:当指针进行类型转换后有内存对齐要求更严格时发出警告;
sign- compare:当使用signed和unsigned类型比较时;
missing-prototypes:当函数在使用前没有函数原型时;
packed:packed 是gcc的一个扩展,是使结构体各成员之间不留内存对齐所需的空间,有时候会造成内存对齐的问题;
padded:也是gcc的扩展,使结构体成员之间进行内存对齐的填充,会造成结构体体积增大.
unreachable-code:有不会执行的代码时.
inline:当inline函数不再保持inline时 (比如对inline函数取地址);
disable-optimization:当不能执行指定的优化时.(需要太多时间或系统资源).
可以使用 -Werror时所有的警告都变成错误,使出现警告时也停止编译.需要和指定警告的参数一起使用.
</code></pre>
<p>编译的优化级别:<br>gcc默认提供了5级优化选项的集合:</p>
<pre><code>-O0:无优化(默认)
-O和-O1:使用能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化.在编译大型程序的时候会显著增加编译时内存的使用.
-O2: 包含-O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化.编译器不执行循环展开以及函数内联.此选项将增加编译时间和目标文件的执行性能.
-Os:专门优化目标文件大小,执行所有的不增加目标文件大小的-O2优化选项.并且执行专门减小目标文件大小的优化选项.
-O3: 打开所有-O2的优化选项并且增加 -finline-functions, -funswitch-loops,-fpredictive-commoning, -fgcse-after-reload and -ftree-vectorize优化选项.
</code></pre>
<p>-O1包含的选项-O1通常可以安全的和调试的选项一起使用:</p>
<pre><code>   -fauto-inc-dec -fcprop-registers -fdce -fdefer-pop -fdelayed-branch
   -fdse -fguess-branch-probability -fif-conversion2 -fif-conversion
   -finline-small-functions -fipa-pure-const -fipa-reference
   -fmerge-constants -fsplit-wide-types -ftree-ccp -ftree-ch
   -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse
   -ftree-fre -ftree-sra -ftree-ter -funit-at-a-time
</code></pre>
<p>以下所有的优化选项需要在名字前加上-f,如果不需要此选项可以使用-fno-前缀</p>
<pre><code>defer-pop:延迟到只在必要时从函数参数栈中pop参数;
thread- jumps:使用跳转线程优化,避免跳转到另一个跳转;
branch-probabilities:分支优化;
cprop- registers:使用寄存器之间copy-propagation传值;
guess-branch-probability:分支预测;
omit- frame-pointer:可能的情况下不产生栈帧;
</code></pre>
<p>-O2:以下是-O2在-O1基础上增加的优化选项:</p>
<pre><code>    -falign-functions  -falign-jumps -falign-loops  -falign-labels
   -fcaller-saves -fcrossjumping -fcse-follow-jumps  -fcse-skip-blocks
   -fdelete-null-pointer-checks -fexpensive-optimizations -fgcse
   -fgcse-lm -foptimize-sibling-calls -fpeephole2 -fregmove
   -freorder-blocks  -freorder-functions -frerun-cse-after-loop
   -fsched-interblock  -fsched-spec -fschedule-insns
   -fschedule-insns2 -fstrict-aliasing -fstrict-overflow -ftree-pre
   -ftree-vrp
</code></pre>
<p>cpu架构的优化选项,通常是-mcpu(将被取消);-march,-mtune</p>
<p>Debug选项:</p>
<pre><code>在 gcc编译源代码时指定-g选项可以产生带有调试信息的目标代码,gcc可以为多个不同平台上帝不同调试器提供调试信息,默认gcc产生的调试信息是为 gdb使用的,可以使用-gformat 指定要生成的调试信息的格式以提供给其他平台的其他调试器使用.常用的格式有
-ggdb:生成gdb专用的调试信息,使用最适合的格式(DWARF 2,stabs等)会有一些gdb专用的扩展,可能造成其他调试器无法运行.
-gstabs:使用 stabs格式,不包含gdb扩展,stabs常用于BSD系统的DBX调试器.
-gcoff:产生COFF格式的调试信息,常用于System V下的SDB调试器;
-gxcoff:产生XCOFF格式的调试信息,用于IBM的RS/6000下的DBX调试器;
-gdwarf- 2:产生DWARF version2 的格式的调试信息,常用于IRIXX6上的DBX调试器.GCC会使用DWARF version3的一些特性.
</code></pre>
<p>可以指定调试信息的等级:在指定的调试格式后面加上等级:<br>如: -ggdb2 等,0代表不产生调试信息.在使用-gdwarf-2时因为最早的格式为-gdwarf2会造成混乱,所以要额外使用一个-glevel来指定调试信息的等级,其他格式选项也可以另外指定等级.<br>gcc可以使用-p选项指定生成信息以供porf使用.</p>
<h1 id="gcc配置选项"><a href="#gcc配置选项" class="headerlink" title="gcc配置选项"></a>gcc配置选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727329.png" alt="6"></p>
<h1 id="gcc常用选项"><a href="#gcc常用选项" class="headerlink" title="gcc常用选项"></a>gcc常用选项</h1><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081725642.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726685.png" alt="2"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726022.png" alt="3"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081726272.png" alt="4"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081727091.png" alt="5"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/06/10/Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/Makefile%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Makefile使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-10 17:20:09" itemprop="dateCreated datePublished" datetime="2020-06-10T17:20:09+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/makefile/" itemprop="url" rel="index"><span itemprop="name">makefile</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件名替换"><a href="#文件名替换" class="headerlink" title="文件名替换"></a>文件名替换</h1><p>1.wildcard<br>展开多个文件为使用空格分开的、匹配此模式的列表参数<br>格式<br><code>$(wildcard PATTERN...)</code></p>
<p>示例：</p>
<pre><code>SRC=$(wildcard *.c)
</code></pre>
<p>2.patsubst<br>替换通配符<br>格式</p>
<pre><code>$(patsubst %.c,%.o,$(dir))
</code></pre>
<p>示例：</p>
<pre><code>obj := $(patsubst %.c,%.o,$(wildcard *.c))
</code></pre>
<p>3.替换引用<br>patsubst的示例等价于：</p>
<pre><code>obj=$(dir:%.c=%.o)
</code></pre>
<p>引用替换：</p>
<pre><code>$(var:a=b) 或 ${var:a=b}
</code></pre>
<p>含义是把变量var中的每一个值，用b替换掉a</p>
<h1 id="PHONY"><a href="#PHONY" class="headerlink" title="PHONY"></a>PHONY</h1><p>Makefile执行的规则是A:B，表示A依赖于B</p>
<ul>
<li>有B才能执行A对应的编译操</li>
<li>B有更新(检测文件时间)，则A会执行，若B没有更新，不执行A</li>
</ul>
<p>问题来了，clean: 不需要依赖任何对象，如何执行<br>PHONY定义伪目标,可以解决源文件不是最终目标直接依赖（即间接依赖）带来的不能自动检查更新规则, 示例如下</p>
<pre><code>.PHONY: clean
clean:
    rm -f *.o
</code></pre>
<p>PHONY不仅用于clean，对于间接依赖也有用，例如A:B， B:C ，有时C为空，就需要把B定义为PHONY</p>
<pre><code>OBJS = *.o
program:  $(OBJS)
        gcc *.o -o program
 
.PHONY : $(OBJS)
$(OBJS):
        make -C $(dir $@)
</code></pre>
<p>不过一般情况，obj依赖于%.c，总之，对于没有依赖项的对象，需要定义为PHONY</p>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>常见通配符</p>
<pre><code>$@, $^, $&lt;, $?

$@  表示目标文件
$^  表示所有的依赖文件
$&lt;  表示第一个依赖文件
$?  表示比目标还要新的依赖文件列表
</code></pre>
<p>示例：<br>编译Test目录下的.cpp文件，输出test可执行程序<br>直接指定依赖文件名的makefile写法：</p>
<pre><code>test: $(wildcard Test/*.cpp)
	$(CXX) $(CFLAGS) -o test $(wildcard Test/*.cpp) 
</code></pre>
<p>虽然wildcard实现了所有依赖的.cpp的通配，编译语句再用wildcard写一次依赖文件不优雅，而且test在依赖中已经写了，编译语句又写一遍 -o test。<br>编译语句使用通配, 称为通用格式：</p>
<pre><code>test: $(wildcard Test/*.cpp)
	$(CXX) $(CFLAGS) -o $@ $^
</code></pre>
<h1 id="多个源文件分别编译"><a href="#多个源文件分别编译" class="headerlink" title="多个源文件分别编译"></a>多个源文件分别编译</h1><p>目录下有很多源文件，每个单独编译和执行的，将每一个文件编译成可执行文件，不用单独命名如：gcc -c xxx.c -o xxx<br>(1)Makefile实现</p>
<pre><code>SRC=$(wildcard *.c)
OBJ=$(SRC:%.c=%.o)
BIN=$(OBJ:%.o=%)
 
CC=gcc
CFLAGS=-Wall -g -c
 
all:$(BIN)

$(BIN):%:%.o
        $(CC) $^ -o $@
$(OBJ):%.o:%.c
        $(CC) $(CFLAGS) $^ -o $@

.PHONY: clean
clean:
        rm -rf $(OBJ) $(BIN)
</code></pre>
<p>(2)Shell实现</p>
<pre><code>#! /bin/bash
for file in ./*.c
do
if [ -f $file ]
then
file=${file#./}
target=${file%.c}
gcc -o $target $file
echo $target
fi
if [ -d $file ]
then
echo $file is mu lu
fi
done
</code></pre>
<p>(2)Makefile编译指定目录<br>Makefile可以输入参数，直接在make命令的后面加上参数，如:</p>
<pre><code>make BUILD_DIR=./foldername/
</code></pre>
<p>传入的变量将会覆盖相应Makefile中的<code>BUILD_DIR</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8sed-awk-grep/" class="post-title-link" itemprop="url">Linux Shell笔记：文本编辑利器sed+awk+grep</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 14:50:22" itemprop="dateCreated datePublished" datetime="2020-05-30T14:50:22+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shell增删改查概述"><a href="#shell增删改查概述" class="headerlink" title="shell增删改查概述"></a>shell增删改查概述</h1><p>Linux Shell环境对文本增删改查，可以通过sed，awk和grep命令完成。</p>
<ul>
<li>sed: 支持特定模式匹配的增加、插入、删除、替换、提取等操作</li>
<li>awk: 支持特定模式匹配的过滤查找，如提取某行列的字符串</li>
<li>grep: 支持包含特定字符串的结果提取，可配合find和awk实现过滤查找</li>
</ul>
<p>这几种命令都支持流输入和文本输入，支持管道传递参数，也可以命令行传参。对于多个步骤的处理，可以几个命令串行使用。</p>
<h1 id="shell的输入参数概述"><a href="#shell的输入参数概述" class="headerlink" title="shell的输入参数概述"></a>shell的输入参数概述</h1><p>Shell的命令，如<code>cat, echo, sed, awk, grep</code>, 管道命令<code>|</code>等，都要有输入参数，即待处理的数据。<br>输入参数有两种类型：</p>
<ul>
<li>标准输入：本质是stdin文件，即读取该文件的内容作为命令的输入参数，该文件内容可由其他命令的输出，或者用户输入来产生</li>
<li>命令行输入：直接接受用户在命令行输入的字符串，一次性使用,不存储在stdin</li>
</ul>
<p>支持标准输入作为参数的命令：<code>cat, sed, awk, grep, |</code> 等<br>只支持命令行输入字符串的命令：<code>echo, ls</code>等<br>标准输入示例：</p>
<pre><code>cat /etc/passwd | grep root
</code></pre>
<p>上面的代码使用了管道命令<code>|</code>，管道命令的作用是将左侧命令<code>cat /etc/passwd</code>的标准输出转换为标准输入，提供给右侧命令<code>grep root</code>作为参数。<br>以上命令也可以写成命令行输入形式：</p>
<pre><code>grep root /etc/passwd
</code></pre>
<p>不支持标准输入的示例：</p>
<pre><code>echo &quot;hello world&quot; | echo
</code></pre>
<p>输出为空，管道右侧的echo不接受管道传来的标准输入作为参数。<br>xargs的作用：将标准输入转为命令行参数</p>
<pre><code>echo &quot;hello world&quot; | xargs echo
</code></pre>
<p>输出“hello world”，xargs和管道配合使用，能使管道也支持非标准输入命令。<br>xargs支持一些选项做进一步细化处理，如-p(打印), -d(分割) 等。</p>
<h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><h2 id="sed命令概述"><a href="#sed命令概述" class="headerlink" title="sed命令概述"></a>sed命令概述</h2><p>sed支持文本编辑，实现增、删、改的功能。<br>sed命令格式：</p>
<pre><code>sed [options] &#39;command&#39; filename
</code></pre>
<p>sed的输入参数可以用命令行，管道和xargs传入：</p>
<pre><code>//命令行传入文件名参数
sed [options] &#39;command&#39; filename 
//管道传入文件名参数
cat filename | sed [options] &#39;command&#39;
//xargs传入文件名参数
cat filename | xargs sed [options] &#39;command&#39;
</code></pre>
<p>sed对文件的编辑在缓冲区，不直接修改文本。要直接修改文本有以下方法：</p>
<ul>
<li>重定向覆盖文本， <code>sed - x &#39;XXX&#39; file.txt &gt; file.txt</code></li>
<li>特定的sed命令支持直接修改文本，如<code>sed -i &#39;XXX&#39; file.txt</code></li>
</ul>
<p>sed的常用选项：</p>
<pre><code>-n ：关闭默认输出,只显示匹配的行
-i ：直接修改读取的文件内容，而不是输出到终端。
-e ：直接在命令列模式上进行sed的动作编辑；
-f ：直接将sed的动作写在一个文件内，-f filename 则可以运行filename内的sed动作；
-r ：启用扩展的正则表达式
</code></pre>
<p>sed的常用命令：</p>
<pre><code>a ：新增行，在指定行的后面附加一行，[address]a\新文本内容
i ：插入行，在指定行的前面插入一行，[address]i\新文本内容
s ：替换特定模式匹配的字符串, [address]s/pattern/replacement/flags
c ：将指定行中的所有内容，替换成该选项后面的字符串, [address]c\用于替换的新文本
d ：删除行，[address]d
p ：打印， 通常与参数 -n 一起用，[address]p
w : 将文本中指定行的内容写入文件, [address]w filename
</code></pre>
<h2 id="sed命令详解"><a href="#sed命令详解" class="headerlink" title="sed命令详解"></a>sed命令详解</h2><p>本节从sed文本操作的“增删改查”举例说明其具体命令用法</p>
<h3 id="新增和插入：a和i"><a href="#新增和插入：a和i" class="headerlink" title="新增和插入：a和i"></a>新增和插入：a和i</h3><p>sed的命令a和i都能实现新增行，其区别在于：</p>
<ul>
<li>a ：append, 指定行后面新增一行</li>
<li>i : insert, 表示在指定行前面插入一行</li>
</ul>
<p>注意区分i命令和i选项<br>a和i命令的基本格式完全相同：</p>
<pre><code>[address]a（或 i）\新文本内容
</code></pre>
<p>将一个新行插入到数据流第三行前：</p>
<pre><code>sed &#39;3i\This is an inserted line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is an inserted line.
This is line number 3.
This is line number 4.
</code></pre>
<p>将一个新行附加到数据流中第三行后:</p>
<pre><code>sed &#39;3a\This is an appended line.&#39; data6.txt

This is line number 1.
This is line number 2.
This is line number 3.
This is an appended line.
This is line number 4.
</code></pre>
<p>将一个多行数据添加到数据流中，只需对要行末尾添加反斜线即可，类似C语言的代码换行</p>
<pre><code>sed &#39;1i\
This is one line of new text.\
This is another line of new text.&#39; data6.txt

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
</code></pre>
<h3 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h3><ul>
<li>d: delete, 删除行</li>
</ul>
<p>格式：</p>
<pre><code>[address]d
</code></pre>
<p>删除第三行：</p>
<pre><code>[root@localhost ~]# cat data6.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
[root@localhost ~]# sed &#39;3d&#39; data6.txt
This is line number 1.
This is line number 2.
This is line number 4.
</code></pre>
<p>删除二、三行：</p>
<pre><code>sed &#39;2,3d&#39; data6.txt
This is line number 1.
This is line number 4.
</code></pre>
<p>删除第三行开始的后续所有行：</p>
<pre><code>[root@localhost ~]# sed &#39;3,$d&#39; data6.txt
This is line number 1.
This is line number 2.
</code></pre>
<p>注意：sed d 命令并不会修改原始文件，这里被删除的行只是从 sed 的缓冲区中消失了，原始文件没做任何改变，若要修改源文件，可重定向sed的输出到源文件，覆盖原内容使修改生效。</p>
<h3 id="匹配定位：-pattern"><a href="#匹配定位：-pattern" class="headerlink" title="匹配定位：&#x2F;pattern&#x2F;"></a>匹配定位：&#x2F;pattern&#x2F;</h3><p>sed的增删操作，可以针对包含匹配字符串的行进行操作，其原理是活用[address], 支持匹配字符串的定位，以插入命令’i’为例，匹配格式如下：</p>
<pre><code>sed [option] &#39;/匹配字符串/i \插入字符串&#39;
[option] 通常为 -i, 修改直接在源文件生效
</code></pre>
<p>原文件：</p>
<pre><code>cat testfile 
hello
</code></pre>
<p>在包含”hello”的一行的上一行，插入”upline”:</p>
<pre><code>sed -i &#39;/hello/i\upline&#39; testfile
</code></pre>
<p>“hello”下一行插入”upline”:</p>
<pre><code>sed -i &#39;/hello/a\down&#39; testfile
</code></pre>
<p>修改后的文件：</p>
<pre><code>cat testfile 
up
hello
down
</code></pre>
<p>删除匹配到”hello”的行：</p>
<pre><code>sed -i &#39;/hello/d&#39; testfile
</code></pre>
<p>如果匹配字符串有“&#x2F;”，为了和sed命令的分隔符“&#x2F;”，使用“\”转义。<br>例如删除匹配某个路径字符串的行：</p>
<pre><code>匹配&quot;\etc\install.sh&quot;
set -i &#39;/\/etc\/install.sh/d&#39; test.txt
</code></pre>
<p>sed 命令包含一些预定义特殊符号，代表行尾，行首等。<br>删除以A开头的行：</p>
<pre><code>sed -i &#39;/^A.*/d&#39; test.txt
^A表示开头是A, .*表示后跟任意字符串
</code></pre>
<p>在行尾追加一行内容:</p>
<pre><code>sed -i &#39;$a\added-content&#39; test.txt
$表示定位到行尾，a是追加命令，added-content是追加内容
</code></pre>
<h3 id="替换修改-s"><a href="#替换修改-s" class="headerlink" title="替换修改: s"></a>替换修改: s</h3><p>s替换命令内部格式为：</p>
<pre><code>[address]s/pattern/replacement/flags
</code></pre>
<ul>
<li>address 指定要操作的具体行</li>
<li>pattern 指定需要替换的内容</li>
<li>replacement 指定替换的新内容</li>
<li>flags 指定特殊功能</li>
</ul>
<p>常用的flags:</p>
<ul>
<li>n	1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换</li>
<li>g	对数据中所有匹配到的内容进行替换，否则只会在第一次匹配成功时做替换操作</li>
<li>p	会打印与替换命令中指定的模式匹配的行。此标记通常与 -n    选项一起使用</li>
<li>\	转义（转义替换部分包含：&amp;、\ 等）。</li>
</ul>
<p>替换每行第二个匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/2&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the trial script
This is second test of the trial script
</code></pre>
<p>只替换第二行的匹配字符串：</p>
<pre><code>sed &#39;2s/test/trial/&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first test of the test script
This is second test of the trial script
</code></pre>
<p>全局替换所有匹配字符串：</p>
<pre><code>sed &#39;s/test/trial/g&#39; data.txt
原文本：
This is first test of the test script
This is second test of the test script
输出：
This is first trial of the trial script
This is second trial of the trial script
</code></pre>
<h3 id="提取：p"><a href="#提取：p" class="headerlink" title="提取：p"></a>提取：p</h3><p>sed p命令配合字符串匹配，可以输出包含指定字符串的行内容。</p>
<pre><code>sed -n &#39;/string/p&#39; filename
提取filename文件中,所有包含string的行的内容，并打印到标准输出
-n是只打印匹配命中的内容
</code></pre>
<p>sed p和grep都能提取内容，其区别在于：</p>
<ul>
<li><code>sed &#39;/string/p&#39;</code>是提取指定文件的行内容，重点在内容提取</li>
<li><code>grep &quot;string&quot; path</code>是输出包含指定内容的所有文件路径，重点在查找文件位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452182.png" alt="image-20221205145238133"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051452191.png" alt="image-20221205145248149"></p>
<h2 id="sed进阶与实战"><a href="#sed进阶与实战" class="headerlink" title="sed进阶与实战"></a>sed进阶与实战</h2><h3 id="多文件批量追加和删除"><a href="#多文件批量追加和删除" class="headerlink" title="多文件批量追加和删除"></a>多文件批量追加和删除</h3><p>背景介绍：<br>底层固件代码有一些功能由宏定义控制，不同功能需要不同的宏定义组合，因此有不同的宏定义文件，命名为.def后缀。批量编译不同版本，编译脚本依次提取def文件夹内的.def文件和源代码一起编译。单个def内容如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453765.png" alt="image-20221205145321718"></p>
<p>每一个宏都有多个取值，因此组合起来，需要生成一堆.def文件，批量编译才能覆盖各自功能。<br>每新增一个宏，都要修改所有.def文件，如果这个宏有两个取值，.def文件数量将翻倍。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453942.png" alt="image-20221205145327892"></p>
<p>人工修改过于低效，使用sed可解决此问题。</p>
<p>查找指定文件，并批量追加一行内容：</p>
<pre><code>find . -name &#39;*.def*&#39; | xargs sed -i &#39;$a\added-content&#39;
</code></pre>
<p>各命令含义：</p>
<pre><code>find [path] -name &quot;*.def&quot;
查找path路径下，以.def结尾的所有文件，结果存储在stdout
|
管道，将查找结果转存到标准输入stdin
xargs
查找结果有很多个，用xargs转成命令行输入，sed才能批量处理
sed -i &#39;$a\added-content&#39;
    -i 直接修改文件，&#39;$a\added-content&#39; 最后一行追加added-content
</code></pre>
<p>查找指定文件，并批量删除匹配某字符串的行：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/deleteString/d&quot;
</code></pre>
<p>查找指定文件，并批量替换匹配某字符串：</p>
<pre><code>find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/oldString/newString/&quot;
</code></pre>
<p>在实际shell脚本中，通常由用户输入变量，<code>$1, $2, $@</code> 解析变量。a、i、d和s能否在命令中使用双引号解析变量，实现动态编辑？<br>实验如下：</p>
<pre><code>ARGS=&quot;AA BB&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$a\${ARGS}&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;$i\${ARGS}&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;/${ARGS}/d&quot;
find ./defs -name &#39;*.def&#39; | xargs sed -i &quot;s/aabb/$ARGS/&quot;
</code></pre>
<ul>
<li>i 和 a 命令不能解析变量，实际追加的就是是${ARGS}</li>
<li>d命令可以解析变量，实际删除的是有”AA BB”的行</li>
<li>s命令可以解析变量，实际替换后的结果是”AA BB”</li>
</ul>
<p>结论：将命令中的单引号改成双引号，理论上可以解析$包含的变量，实际上有的命令支持，有的命令不支持。</p>
<h3 id="提取文件中的关键内容"><a href="#提取文件中的关键内容" class="headerlink" title="提取文件中的关键内容"></a>提取文件中的关键内容</h3><p>背景介绍：<br>底层固件需要将代码段、数据段等关键信息存储在固件头部，编译过程中用编译器的size命令可以获取这些信息，并存储到文本，但是固件头部需要按自己的格式存储起始地址和大小信息，因此需要用sed提取并编辑该文本。</p>
<p>原文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453983.png" alt="image-20221205145348933"></p>
<p>提取后文本：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051453414.png"></p>
<p>sed命令：</p>
<pre><code>sed -n &#39;/string/p&#39; oldFile | awk &#39;{print $3}&#39; &gt;&gt; newFile
提取oldFile内包含string的行，并用awk提取第三列，再写入newFile
</code></pre>
<p>该命令在Makefile实现，需要根据Makefile和shell特性做修改：</p>
<ul>
<li>@：编译过程隐藏命令输出，类似于后台执行</li>
<li>$(shell xxxx): Makefile执行shell命令</li>
<li>$$: Makefile不能直接用shell的“$”解析变量，用“$$”</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212051454928.png" alt="image-20221205145409877"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">NodeJs笔记：使用pm2部署项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 14:25:24" itemprop="dateCreated datePublished" datetime="2020-05-20T14:25:24+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJs/" itemprop="url" rel="index"><span itemprop="name">NodeJs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>nodejs服务可以用<code>nohup node xxx.js &amp;</code>后台启动，但是实际使用发现不太稳定，使用专门的node后台服务管理工具：pm2解决此问题</p>
<h1 id="pm2特性"><a href="#pm2特性" class="headerlink" title="pm2特性"></a>pm2特性</h1><p>1、内建负载均衡（使用Node cluster 集群模块）<br>2、后台运行<br>3、0秒停机重载<br>4、具有Ubuntu和CentOS 的启动脚本<br>5、停止不稳定的进程（避免无限循环）<br>6、控制台检测<br>7、提供 HTTP API<br>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p>
<h1 id="pm2安装"><a href="#pm2安装" class="headerlink" title="pm2安装"></a>pm2安装</h1><pre><code>npm install -g pm2
</code></pre>
<h1 id="pm2用法"><a href="#pm2用法" class="headerlink" title="pm2用法"></a>pm2用法</h1><pre><code>pm2 start app.js        //启动进程
pm2 start app.js -i 4   // 后台运行pm2，启动4个app.js
pm2 start app.js -i max //启动，使用所有CPU核心
pm2 start app.js --name my-api // 命名进程
pm2 list               // 显示所有进程状态
pm2 monit              // 监视所有进程
pm2 logs               //  显示所有进程日志
pm2 stop all           // 停止所有进程
pm2 restart all        // 重启所有进程
pm2 reload all         // 0秒停机重载进程 (用于 NETWORKED 进程)
pm2 stop 0             // 停止指定的进程
pm2 restart 0          // 重启指定的进程
pm2 startup            // 产生 init 脚本 保持进程活着
pm2 web                // 运行健壮的 computer API endpoint 
pm2 delete 0           // 杀死指定的进程
pm2 delete all         // 杀死全部进程
</code></pre>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>部署Github项目NodeMail，每天给指定邮箱发邮件。</p>
<p>后台启动main.js并监测状态：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427417.png" alt="image-20221206142729375"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427110.png" alt="image-20221206142743066"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427682.png" alt="image-20221206142752627"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061428280.png" alt="image-20221206142800236"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cursorhu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cursorhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cursorhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2449055512@qq.com" title="E-Mail → mailto:2449055512@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cursorhu</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
