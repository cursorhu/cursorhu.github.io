<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/my_icon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/my_icon/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/my_icon/manifest.json">
  <meta name="msapplication-config" content="/images/my_icon/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/2/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy | 化繁为简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20%E7%94%B5%E6%B1%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E7%94%B5%E9%87%8F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20%E7%94%B5%E6%B1%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E7%94%B5%E9%87%8F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">电量计 -- 电池基础知识和电量计算法简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:26:12" itemprop="dateModified" datetime="2025-11-18T10:26:12+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E9%87%8F%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">电量计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计-–-电池基础知识和电量计算法简介"><a href="#电量计-–-电池基础知识和电量计算法简介" class="headerlink" title="电量计 – 电池基础知识和电量计算法简介"></a>电量计 – 电池基础知识和电量计算法简介</h1><h2 id="算法背景简介"><a href="#算法背景简介" class="headerlink" title="算法背景简介"></a>算法背景简介</h2><h3 id="电池建模"><a href="#电池建模" class="headerlink" title="电池建模"></a>电池建模</h3><p>电量计芯片算法首先是建立在电池 &#x2F; 电芯建模的基础上。 由于电芯的SOC受到电池的电压，电池充放电电流以及温度的影响。</p>
<p>根据客户应用场景的需求， 将电芯按照不同的温度和电流进行充电和放电，得到不同场景的充放电数据。 通过大瞬科技自己研发的数据处理软件， 作为该种电池的基础模型数据保存下来， 储存在芯片 flash 或主机端中作为算法的内部数据使用。 当电池进行充放电时， 芯片固件会参考该数据， 对芯片的充放电 SOC 状态进行误差评估， 然后结合当前的电压， 电流和温度， 进行动态的修正。 抑制各种动态环境带来的偏差。</p>
<p>电量计建模会生成两种数据内容：</p>
<p>电池的OCV（Open Circuit Voltage）表，由于库伦积分法无法得到电池的初始SOC，所以在电池上电的初始阶段会应用此表查到的SOC来作为电池初始化的SOC.</p>
<p>电池在不同电压，不同电流以及不同温度下的SOC表格，此表用来作为安时积分法的SOC计算参考表格。<br>温度一般选取-10度，0度，25度和45度4个点。<br>电流根据客户的充放电应用选取3-4个点。<br>同时记录电池在不同温度和不同电流下不同SOC对应的电压点。<br>在实际应用中，对于温度或电流不在建模表范围内的点，采用专用算法进行插值处理。</p>
<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>电芯按照充放电状态，可以分为充充电状态，空闲状态和放电状态，三种状态会分别执行不同的逻辑。</p>
<p>对于充电状态：<br>在充电初始状态，使用当前电压，电流，温度和 SOH 值来对整体满充电芯容量进行预估。<br>在充电进行中，使用库仑计进行库伦积分，当温度和电流变化时，芯片会计算不同电流和温度下的库伦效率值，整合滤波算法来更新 SOC。<br>根据当前的电压和电流值，以及设定的截至电压和截至电流来判定 CC 和 CV 充电状态。<br>根据设定的截至电压和截至电流以及库伦积分值来判定是否达到满充。其中截至电压和截至电流作为主要判定条件。</p>
<p>对于放电状态：</p>
<p>在放电初始状态，使用当前电压，电流，温度和 SOH 值来对整体电芯的可用容量进行预估。<br>在放电进行中，使用库仑计进行库伦积分，结合 放电模型更新当前可用的有效容量和 SOC，当温度，电流和电压变化时，放电模型会自动更新电芯的有效容量，同时结合自适应 算法 来更新 SOC，保证 SOC 的精度。<br>在放电末端，SOC 小于 10%之后，根据放电的截止电压，对 SOC 值进行额外的滤波处理使其在尾端尽可能逼近截止电压，同时不会因为特定的应用情况而出现跳变。</p>
<p>对于空闲状态：</p>
<p>对于电流死区（10mA，可配置）以上的电流，库伦会记录电流积分数据并更新到SOC 上。<br>对于长时间处于空闲状态的电池，每隔一定时间（12h，可配置），使用电压查询OCV，得到 SOC，对当前的 SOC 进行滤波修正。<br>在无负载状态时，当温度发生变化，电芯电压可能会发生变化。为了避免终端用户在无负载情况下，直接观察到 SOC 下降或者上升，认为设备异常。在这种情况下，电量计 SOC 输出会维持不变。当电芯转入充电或者放电状态时，再根据实际电流，电压和温度情况调整电芯容量预估值，使 SOC 平滑过渡，准确达到充电截止或者放电截止。</p>
<h3 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h3><p>由于不同客户电池的放电容量不同，EOD（End of Discharge）电压不同，电池内阻不同，温度等其他参数对电量的影响也不同，所以在基于大瞬电量计的基础算法上，需根据电量计精度的测试结果来进行调参。<br>对于电池包端电量计，大瞬科技开发有专用的调参仿真软件进行调参。<br>对于主板端电量计，目前仍需实测方式进行调参。</p>
<p>充电精度测量：<br>在实际测试中，充电阶段以芯片报 0%开始，芯片达到 100%结束。通过统计该阶段的库仑计值，就可以计算出该充电阶段的标准 SOC 值。使用该值减去芯片输出的 RSOC 值就可以得到充电阶段 SOC 的误差值。同时充电也需要评估芯片充电截止时的截止电流与客户配置的截止电流之间的实际差异。<br>放电精度测量：<br>对于放电阶段同理，以满充状态为 100%，以芯片报 0%为放电完成。统计该阶段的库仑计值，计算出该放电阶段的标准 SOC 值。使用该值减去芯片输出的 RSOC 值就可以得到放电阶段 SOC 的误差值。放电阶段需要额外评估放电阶段的实际截止电压与客户配置的截止电压之间的差异。</p>
<h2 id="锂电池基础知识"><a href="#锂电池基础知识" class="headerlink" title="锂电池基础知识"></a>锂电池基础知识</h2><h3 id="常用电池参数"><a href="#常用电池参数" class="headerlink" title="常用电池参数"></a>常用电池参数</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211602675.png" alt="image-20250321160203631"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211602332.png" alt="image-20250321160221281"></p>
<h3 id="电池充电曲线"><a href="#电池充电曲线" class="headerlink" title="电池充电曲线"></a>电池充电曲线</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211602487.png" alt="image-20250321160244457"></p>
<h3 id="电池放电特性"><a href="#电池放电特性" class="headerlink" title="电池放电特性"></a>电池放电特性</h3><p>放电电流影响内阻压降</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211603864.png" alt="image-20250321160323833"></p>
<p>负载移除有瞬态效应</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211603115.png" alt="image-20250321160343073"></p>
<p>环境温度影响放电曲线</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211604683.png" alt="image-20250321160416649"></p>
<h3 id="循环次数"><a href="#循环次数" class="headerlink" title="循环次数"></a>循环次数</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211607520.png" alt="image-20250321160709488"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211607989.png" alt="image-20250321160721945"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211607159.png" alt="image-20250321160743128"></p>
<h2 id="电量计简介"><a href="#电量计简介" class="headerlink" title="电量计简介"></a>电量计简介</h2><h3 id="电量计功能"><a href="#电量计功能" class="headerlink" title="电量计功能"></a>电量计功能</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211608835.png" alt="image-20250321160835792"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211608143.png" alt="image-20250321160848105"></p>
<h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211610665.png" alt="image-20250321161013632"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211610250.png" alt="image-20250321161026216"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211611917.png" alt="image-20250321161050760"></p>
<h3 id="电量检测算法简介"><a href="#电量检测算法简介" class="headerlink" title="电量检测算法简介"></a>电量检测算法简介</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211611646.png" alt="image-20250321161131608"></p>
<h4 id="OCV查询"><a href="#OCV查询" class="headerlink" title="OCV查询"></a>OCV查询</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211611128.png" alt="image-20250321161159088"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211612406.png" alt="image-20250321161210368"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211612126.png" alt="image-20250321161223080"></p>
<h4 id="库伦监测"><a href="#库伦监测" class="headerlink" title="库伦监测"></a>库伦监测</h4><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211612654.png" alt="image-20250321161249617"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211613724.png" alt="image-20250321161306688"></p>
<h3 id="通用算法流程"><a href="#通用算法流程" class="headerlink" title="通用算法流程"></a>通用算法流程</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211620706.png" alt="image-20250321162020664"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20%E9%98%BB%E6%8A%97%E8%BF%BD%E8%B8%AA%E7%AE%97%E6%B3%95%E7%A7%BB%E6%A4%8D%E5%92%8C%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20%E9%98%BB%E6%8A%97%E8%BF%BD%E8%B8%AA%E7%AE%97%E6%B3%95%E7%A7%BB%E6%A4%8D%E5%92%8C%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">电量计 -- 阻抗追踪算法移植和调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:26:08" itemprop="dateModified" datetime="2025-11-18T10:26:08+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E9%87%8F%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">电量计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计-–-阻抗追踪算法移植和调试"><a href="#电量计-–-阻抗追踪算法移植和调试" class="headerlink" title="电量计 – 阻抗追踪算法移植和调试"></a>电量计 – 阻抗追踪算法移植和调试</h1><h2 id="V-term跳变导致R跳变"><a href="#V-term跳变导致R跳变" class="headerlink" title="V_term跳变导致R跳变"></a>V_term跳变导致R跳变</h2><p>放电电流的大小本身不会影响电池内阻，电池内阻是电池固有状态。</p>
<p>但是调整电流时，因为压降变化，V_term会有大幅度跳变，会影响内阻计算，导致内阻跳变。</p>
<p>这属于算法问题，并不是真实内阻有跳变。</p>
<p>方案：平滑V_term，使用avgcellmv</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202508041642079.png" alt="image-20250804164236977"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20%E9%97%AE%E9%A2%98%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1%20--%20%E9%97%AE%E9%A2%98%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">电量计 -- 问题和功能记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 11:52:57" itemprop="dateModified" datetime="2025-11-18T11:52:57+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E9%87%8F%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">电量计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计–问题和功能记录"><a href="#电量计–问题和功能记录" class="headerlink" title="电量计–问题和功能记录"></a>电量计–问题和功能记录</h1><h2 id="切换CV相关问题"><a href="#切换CV相关问题" class="headerlink" title="切换CV相关问题"></a>切换CV相关问题</h2><h3 id="充电过充中切cv"><a href="#充电过充中切cv" class="headerlink" title="充电过充中切cv"></a>充电过充中切cv</h3><p>需求描述：（NPC660项目）在充电过充中Host发送SBS73命令切换截止电压，从默认的4.35v切到4.1v，同时Charger充电器也设置截止电压4.15v以保证能充满到4.1v。期望充电到4.1v时rsoc能报100. </p>
<p>问题分析：在充电过充中切换截止电压，之前电量计累计的数据没有清0，导致充满到4.1v时电量还是按4.35v计算，只有70%</p>
<p>解决方案：收到SBS73就复位电量计数据（清0），注意清0会导致rsoc跳变。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081354520.png" alt="image-20250408135441409"></p>
<h3 id="放电过充中切cv"><a href="#放电过充中切cv" class="headerlink" title="放电过充中切cv"></a>放电过充中切cv</h3><p>需求描述：（NPC660项目）按4.35v充满后，如果长时间没拔下充电器，充电器会判断为长时间过充，Host发送SBS73命令切换截止电压，从默认的4.35v切到4.1v，之后放电到4.1v。期望放电到4.1v过充中rsoc能保持100，4.1v以下按正常电量消耗显示，电量无跳变。</p>
<p>问题分析：</p>
<p>（1）切换后Host有时读到soc是0值，可能是正好读到了复位数据。</p>
<p>（2）初始方案是判断电压在4.35~4.1时直接sbsif强制上报100，但4.1v时soc会有跳变。</p>
<p>（3）Host在4.35v时发送cv切换时GGMEM0看到soc是100，但4.35放电到4.1v过充中，soc一直下降，放电到4.1v按真实soc显示会跳变到89。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081405362.png" alt="image-20250408140512307"></p>
<p>解决方案：</p>
<p>（1）测试发现放电中每次发SBS73切cv到4.1v时，GGMEM0 soc都复位到100，因此解决方案是4.1v附近再复位一次电量计数据。</p>
<p>（2）不能在刚刚4.1v时复位，算法来不及刷新数据，会导致soc跳变。在4.1V + 20mV时提前复位。</p>
<p>（3）为了防止跳变，预设了平滑下降数据，平滑追赶跳变soc值。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081504160.png" alt="image-20250408150400108"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">uint8_t cv_adjusted_flag = 0;</span><br><span class="line">static int16_t adjusted_cv_value = 0;</span><br><span class="line">#define FAKE_SOC_TABLE_SIZE 40</span><br><span class="line">static uint8_t fake_soc[FAKE_SOC_TABLE_SIZE] = &#123;</span><br><span class="line">                99, 99, 98, 98, 97, 97, 96, 96, 95, 95, 94, 94, 93, 93, 92, 92, 91, 91, 90, 90,</span><br><span class="line">                89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70,</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">//main loop每秒调用一次</span><br><span class="line">void check_and_force_soc_if_needed(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 获取当前电池电压</span><br><span class="line">    int16_t current_voltage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS09_BATTVOLT];</span><br><span class="line"></span><br><span class="line">    // 判断是否需要处理CV调整后的特殊情况</span><br><span class="line">    if (cv_adjusted_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果电压仍高于调整后的CV值，保持SOC为100%</span><br><span class="line">        if (current_voltage &gt; adjusted_cv_value)</span><br><span class="line">        &#123;</span><br><span class="line">            // 检查是否是放电状态</span><br><span class="line">            if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0A_BATTCURR] &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //4.1V以上时直接上报100，避免误读到SBS73的reset soc值0.</span><br><span class="line">                ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = 100;</span><br><span class="line">                ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC] = 100;</span><br><span class="line">    </span><br><span class="line">                //接近4.1V时提前reset数据，这样降到4.1v时真实soc能接近100</span><br><span class="line">                //如果不reset，从4.35放电到4.1的电量会被计算到soc，造成4.1v的soc只有90%</span><br><span class="line">                if(current_voltage - adjusted_cv_value &lt; 20)</span><br><span class="line">                    reset_gauge_parameters();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // 电压已降至CV值以下，按真实soc报</span><br><span class="line">            if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0A_BATTCURR] &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // 不要在这里复位，不然客户会看到soc跳变</span><br><span class="line">                // reset_gauge_parameters();</span><br><span class="line">    </span><br><span class="line">                // 备选: 如果用真实rsoc有跳变(5~15%左右)，做平滑处理，每秒降低soc直到匹配真实soc</span><br><span class="line">                static int idrop = 0;</span><br><span class="line">                if((((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] &lt; fake_soc[idrop]) &amp;&amp;</span><br><span class="line">                   (idrop &lt; FAKE_SOC_TABLE_SIZE))</span><br><span class="line">                &#123;</span><br><span class="line">                    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = fake_soc[idrop]; </span><br><span class="line">                    idrop++;</span><br><span class="line">                    return; //这里退出，下次继续，直到匹配或者超出fake table</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 清除全局标志</span><br><span class="line">            cv_adjusted_flag = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void smart_charge_func(void)</span><br><span class="line">&#123;</span><br><span class="line">    // SBS73: 超长时间充电切CV值功能</span><br><span class="line">    int16_t host_update = (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS73_UPDATE_CV] &gt;&gt; 16) &amp; 0xFFFF;</span><br><span class="line">    int16_t update_cv = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS73_UPDATE_CV] &amp; 0xFFFF</span><br><span class="line">    // 如果收到Host发送的CV调整命令</span><br><span class="line">    if (host_update &amp;&amp; update_cv)</span><br><span class="line">    &#123;</span><br><span class="line">        // 记录新的CV值</span><br><span class="line">        adjusted_cv_value = update_cv;</span><br><span class="line"></span><br><span class="line">        // 获取当前电池电压</span><br><span class="line">        int16_t current_voltage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS09_BATTVOLT];</span><br><span class="line"></span><br><span class="line">        // 如果当前电压高于新设定的CV值，设置标志且只设置一次</span><br><span class="line">        if ((cv_adjusted_flag == 0) &amp;&amp;</span><br><span class="line">            (current_voltage &gt; adjusted_cv_value))</span><br><span class="line">        &#123;</span><br><span class="line">            cv_adjusted_flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure>

<h2 id="充电到99停充，自动报百"><a href="#充电到99停充，自动报百" class="headerlink" title="充电到99停充，自动报百"></a>充电到99停充，自动报百</h2><p>FW有优化处理，当Charger提前截止充电了，电池处于idle状态且当前电量在99，Host发送81命令0x3数据通知电量计，电量计idle_process检测此标志位，持续30s后电量计自动报100，避免充电器插着但长时间停充场景的电量到不了100。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504241113416.png" alt="image-20250424111349241"></p>
<h2 id="GGMEM数据使用SBS命令导出"><a href="#GGMEM数据使用SBS命令导出" class="headerlink" title="GGMEM数据使用SBS命令导出"></a>GGMEM数据使用SBS命令导出</h2><p>客户环境下可能没有多的I2C接口能接Cobra上位机去读GGMEM，而问题调试必须依赖于GGMEM数据。</p>
<p>客户的Host代码可以使用SBS D0 ~ D8命令获取GGMEM0 ~8</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504241136014.png" alt="image-20250424113644949"></p>
<h2 id="Host乱切cv导致跳0和满充75问题"><a href="#Host乱切cv导致跳0和满充75问题" class="headerlink" title="Host乱切cv导致跳0和满充75问题"></a>Host乱切cv导致跳0和满充75问题</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251501835.png" alt="image-20250425150103773"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251509651.png" alt="image-20250425150921622"></p>
<p>Host侧代码可通过SBS D0~D8读GGMEM去分析这种跳0问题：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251510572.png" alt="image-20250425151016548"></p>
<p>注意Cobra轮询时间比较长最短1s，有时不一定能观测到soc跳0的值，但GGMEM0第一个DWORD复位为DESIGN FCC &#x3D; 13ec是可以作为判断的。</p>
<p>最终原因就是Host Charger逻辑问题，一直在发SBS73，而FW没加防呆，频繁复位libfg数据，导致最终4.1V时接近OCV查表值的电量75，而不是CV追赶值100.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251548428.png" alt="image-20250425154850336"></p>
<h2 id="Cycle-count放电循环次数"><a href="#Cycle-count放电循环次数" class="headerlink" title="Cycle-count放电循环次数"></a>Cycle-count放电循环次数</h2><p>SBS17 cycle-count &#x3D; 总放电量&#x2F;电池容量，每秒更新</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505071010300.png" alt="image-20250507101040214"></p>
<p>不接i2c多次循环再读cycle count可以读到更新，因为sleep机制下会有timer每60s唤醒一次持续1s，更新libfg信息，包括累计discharge ccmah，计算cycle count</p>
<h2 id="USB模式和AC-Charger模式的eocma调整接口"><a href="#USB模式和AC-Charger模式的eocma调整接口" class="headerlink" title="USB模式和AC Charger模式的eocma调整接口"></a>USB模式和AC Charger模式的eocma调整接口</h2><p>USB口只有500mA电流，应该保证USB充电的eocma小于500mA，典型值是200mA。参数的满充截止电流如果和USB电流相等都是500mA，host必须发SBS74切eocma到200mA，否则充电尾端加速过快，容易读到电量跳变。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505151622340.png" alt="image-20250515162238231"></p>
<h2 id="NTC表的两种形式"><a href="#NTC表的两种形式" class="headerlink" title="NTC表的两种形式"></a>NTC表的两种形式</h2><p>SD77561原版使用电压-电阻查表；SD77428A3使用电阻-温度查表，支持6uA&#x2F;48uA两种电流源切换，大电流源保证高温时R*I &#x3D; V有更大的值，这样电压ADC有更高精度。现在需要将SD77561的电压-电阻查表改成电阻-温度查表，支持6uA&#x2F;72uA两种电流源切换：</p>
<p>(1)首先将SD77428代码里已经有的R-T表，手动创建一个77561 PRJ的NTC.txt格式表：</p>
<p>x轴是16个采样点，total length是cobra解析此表的参数总和，即16*2 (x和y) + 6(header) &#x3D; 38</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202506301553903.png" alt="image-20250630155253817"></p>
<p>(2)修改ADC查表方式，并添加高温切换大电流源</p>
<p>代码分支：HaoPeng-I0917A</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Copy raw thm voltage to buffer</span><br><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_val = sbs_cal_lsb_factor((int32_t)(dacq_p-&gt;raw_buff[((SBSIF_T *)psbsifHandle)-&gt;sbs_val]), ADC_EXTMPLSB, ADC_EXTMPLSB_FACTOR);</span><br><span class="line">//暂存，后面切换电流源用到此raw电压作为条件</span><br><span class="line">temp2 = ((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line">/* find Re, with 20uA source */</span><br><span class="line">// we modify thermal table as Voltage V.S. Temperature, so don&#x27;t need to multiple THM_OHM</span><br><span class="line">//((SBSIF_T *)psbsifHandle)-&gt;sbs_val 		*= (THM_OHM);						//Re = 1000uV / 20uA ==&gt; Ohm</span><br><span class="line"></span><br><span class="line">//转换电压成电阻：电压*1000精度/电流源 = NTC R，支持72ua和6ua电流源，72uA为了高温下高精度测量</span><br><span class="line">if(EXTNTCSRC_72UA == Chip_ADC_GetNTCSrc()) </span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= (1000/72);</span><br><span class="line">else</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= (1000/6);</span><br><span class="line"></span><br><span class="line">//查表，改成电阻-温度表</span><br><span class="line">lut_one_latitude(TEMPERATURE_DATA_NUM,</span><br><span class="line">                 (one_latitude_data_t *)GDM_FLASH_THML_TABLE,</span><br><span class="line">                 ((SBSIF_T *)psbsifHandle)-&gt;sbs_val,</span><br><span class="line">                 &amp;temp1);</span><br><span class="line">temp1 += DK_BASE;</span><br><span class="line">//记录温度</span><br><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS61_ETDK1] = temp1 - (int32_t)(param_board_cfg[PARM_BCFG_EXTTHMOFFSET]); //((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据ntc电压（温度状况）决定电流源切换提高精度：</span><br><span class="line">//高温ntc电压小于60mV切换72uA，常温低温ntc电压大于900mV切换6uA</span><br><span class="line">if((temp2 &lt; 60) &amp;&amp; (EXTNTCSRC_6UA == Chip_ADC_GetNTCSrc()))&#123;</span><br><span class="line">    Chip_ADC_SetNTCSrc(EXTNTCSRC_72UA);</span><br><span class="line">&#125;else if ((temp2 &gt; 900) &amp;&amp; (EXTNTCSRC_72UA == Chip_ADC_GetNTCSrc()))&#123;</span><br><span class="line">    Chip_ADC_SetNTCSrc(EXTNTCSRC_6UA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在线升级bin和参数对照"><a href="#在线升级bin和参数对照" class="headerlink" title="在线升级bin和参数对照"></a>在线升级bin和参数对照</h2><p>终端在线升级出问题一般只会回传bin，需要对照bin的参数是怎么配置的，注意bin没有8K的bootloader offset即可找到参数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507232039915.png" alt="image-20250723203915801"></p>
<p>缺失的参数定义在C:\git-834\COBRA\COBRA Documents\SD77226SBS_X_20250315\Project\Parameter查看</p>
<h2 id="SOH更新原理"><a href="#SOH更新原理" class="headerlink" title="SOH更新原理"></a>SOH更新原理</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507251146800.png" alt="image-20250725114616713"></p>
<h2 id="77428-Host驱动使用硬件I2C判断通信问题"><a href="#77428-Host驱动使用硬件I2C判断通信问题" class="headerlink" title="77428 Host驱动使用硬件I2C判断通信问题"></a>77428 Host驱动使用硬件I2C判断通信问题</h2><p>i2c sbs接口持续错误可用此方式判断是硬件问题还是软件问题</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507251147766.png" alt="image-20250725114726725"></p>
<h2 id="注释函数大幅减少Code段占用"><a href="#注释函数大幅减少Code段占用" class="headerlink" title="注释函数大幅减少Code段占用"></a>注释函数大幅减少Code段占用</h2><p>一般注释掉函数的调用处，但不注释函数体本身，只会减少运行时堆栈，并不会减少Code代码段，；但是561 KEIL项目注释main的libfg_update后，Code段从36K减到20K</p>
<p>原因是编译器优化：未被调用的函数被从Image中移除；只有被调用的函数体才存放在Image。</p>
<p>如下图分别是不调用和调用libfg_update时的.map信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507291025458.png" alt="image-20250729102546398"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507291026312.png" alt="image-20250729102611276"></p>
<h2 id="SD77428-power-supply框架获取电量信息"><a href="#SD77428-power-supply框架获取电量信息" class="headerlink" title="SD77428 power supply框架获取电量信息"></a>SD77428 power supply框架获取电量信息</h2><p>框架参考：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/power/power_supply_class.html">https://www.kernel.org/doc/html/latest/power/power_supply_class.html</a></p>
<p>代码见&lt;include&#x2F;linux&#x2F;power_supply.h&gt;</p>
<p>基本原理是dev设备，注册power supply属性，其中的desc描述结构包含get_property回调函数接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int32_t sd77428_power_supply_init(struct sd77428_data *chip)</span><br><span class="line">&#123;</span><br><span class="line">    chip-&gt;bat_cfg.drv_data = chip;</span><br><span class="line">    chip-&gt;bat_cfg.of_node = chip-&gt;client-&gt;dev.of_node;</span><br><span class="line"></span><br><span class="line">    chip-&gt;bat_desc.name = &quot;sd77428&quot;;</span><br><span class="line">    chip-&gt;bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;</span><br><span class="line">    chip-&gt;bat_desc.properties = sd77428_battery_props;</span><br><span class="line">    chip-&gt;bat_desc.num_properties = ARRAY_SIZE(sd77428_battery_props);</span><br><span class="line">    chip-&gt;bat_desc.get_property = sd77428_battery_get_property; //这里是get_property回调</span><br><span class="line">    chip-&gt;bat_desc.no_thermal = 1;</span><br><span class="line">    chip-&gt;bat_desc.external_power_changed = sd77428_external_power_changed;</span><br><span class="line"></span><br><span class="line">    chip-&gt;bat = devm_power_supply_register(chip-&gt;dev, &amp;chip-&gt;bat_desc, &amp;chip-&gt;bat_cfg);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>驱动实现get_property回调，关联电量信息和上报的状态，有的信息需要映射，例如SOH不能直接上报值只能报状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">case POWER_SUPPLY_PROP_VOLTAGE_NOW:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_voltage; //mV</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CURRENT_NOW:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_current; //mA</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CAPACITY: //capacity in percents(soc), from 0 to 100</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_rsoc;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_TEMP:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_temp; //单位：摄氏度</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN: //design charge capacity</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_capacity;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_FULL: //full-charge-capacity(FCC)</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_fcc; </span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_NOW: //charge capacity now</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_rc;</span><br><span class="line">    break;</span><br><span class="line">    </span><br><span class="line">case POWER_SUPPLY_PROP_HEALTH:</span><br><span class="line">    //val-&gt;intval = chip-&gt;batt_info.batt_soh; //不能直接返回SOH值</span><br><span class="line">    val-&gt;intval = POWER_SUPPLY_HEALTH_GOOD; //根据状态返回POWER_SUPPLY_HEALTH定义的状态</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<p>然后linux应用层通过sysfs访问power_supply路径下的节点，设备名称是前面注册的.name名称(sd77428)，路径下是各属性都像文件一样访问。</p>
<p>用uevent查看节点的所有实时信息，power_supply节点的任何信息的更新都会反映到默认属性uevent(power_supply属于uevent子类，基于uevent通知机制实现)；如果只查看某个信息如capacity，charge_now，都可以分开cat查看</p>
<p>如下是终端输出，sysfs查看uevent和驱动打印的电池信息是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@phytiumpi:~# ls /sys/class/power_supply</span><br><span class="line">sd77428</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# ls /sys/class/power_supply/sd77428 </span><br><span class="line">capacity            charge_now   device  power    status     temp  uevent</span><br><span class="line">charge_full_design  current_now  health  present  subsystem  type  voltage_now</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# cat /sys/class/power_supply/sd77428/uevent</span><br><span class="line">POWER_SUPPLY_NAME=sd77428</span><br><span class="line">POWER_SUPPLY_STATUS=Discharging</span><br><span class="line">POWER_SUPPLY_PRESENT=1</span><br><span class="line">POWER_SUPPLY_VOLTAGE_NOW=4089</span><br><span class="line">POWER_SUPPLY_CURRENT_NOW=0</span><br><span class="line">POWER_SUPPLY_CAPACITY=98</span><br><span class="line">POWER_SUPPLY_TEMP=25</span><br><span class="line">POWER_SUPPLY_CHARGE_FULL_DESIGN=3400</span><br><span class="line">POWER_SUPPLY_CHARGE_FULL=3400</span><br><span class="line">POWER_SUPPLY_CHARGE_NOW=3318</span><br><span class="line">POWER_SUPPLY_HEALTH=Good</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# [   23.297385] [bmt]sd77428_get_batt_info: vbat:4089, ibat:00000, tbat:25, rsoc:098, fcc:3400, dcap:3400, soh:100, cycle:0, rc:3318, dfcc:3798, cc:8242, ext_chg -1</span><br></pre></td></tr></table></figure>

<h2 id="561-cobra导出EEPROM-64K数据"><a href="#561-cobra导出EEPROM-64K数据" class="headerlink" title="561 cobra导出EEPROM 64K数据"></a>561 cobra导出EEPROM 64K数据</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510091639531.png" alt="image-20251009163917427"></p>
<p>从左到右依次read all，每次export一个bin，得到3个bin，然后用hex editor合并成一个64KB的bin，按EEPROM+Sytem+Information合并</p>
<h2 id="561-SBS改成428格式，交叉测试"><a href="#561-SBS改成428格式，交叉测试" class="headerlink" title="561 SBS改成428格式，交叉测试"></a>561 SBS改成428格式，交叉测试</h2><p>LK阶段问题怀疑是428使用轮询I2C造成slave持续拉低clock&#x2F;data，561使用中断处理I2C，为了快速验证，不改host 428驱动情况下，使用561修改部分命令成428格式测试。</p>
<p>改两处即可：I2C slave地址，SBS命令的值和长度。注意Slave地址设置原代码有问题，应该直接赋值SADDR1，不能或等，否则COM通信失败</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111445198.png" alt="image-20251011144509147"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111444197.png" alt="image-20251011144420090"></p>
<h2 id="561-使用轮询方式处理I2C"><a href="#561-使用轮询方式处理I2C" class="headerlink" title="561 使用轮询方式处理I2C"></a>561 使用轮询方式处理I2C</h2><p>需求同上，为了对比测试428问题，561使用轮询i2c方式</p>
<p>修改两处：</p>
<p>1.i2c slave handle加到while1 ms轮询</p>
<p>2.关闭NVIC I2C中断开关 （561基于ARM，428的riscv是另外一套PLIC关闭）</p>
<p>注意自定义的数字逻辑也有中断使能和中断状态，这个和NVIC中断是无关的，属于内部状态，所以即使关了外部NVIC中断开关，也只是切断了ISR回调处理，轮询方式调用i2c slave handle仍可以读内部i2c register中断状态判断是读是写是传输完成，只要保证清除状态，不要重复处理即可。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111452813.png" alt="image-20251011145237741"></p>
<h2 id="77428A3不更新FCC问题"><a href="#77428A3不更新FCC问题" class="headerlink" title="77428A3不更新FCC问题"></a>77428A3不更新FCC问题</h2><p>A3驱动下载参数后需要发SBS8F带非0参数，reset_lib去更新FCC&#x3D;Design Capacity</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/10/28/f21ba8363f115b8d.png" alt="image-20251028142924671"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--77428%E5%90%88%E5%B9%B6%E5%8F%82%E6%95%B0%E5%88%B0MCU%20baseline%E7%9A%84%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--77428%E5%90%88%E5%B9%B6%E5%8F%82%E6%95%B0%E5%88%B0MCU%20baseline%E7%9A%84%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">电量计 -- 77428的MCU sample代码交付</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 11:52:40" itemprop="dateModified" datetime="2025-11-18T11:52:40+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E9%87%8F%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">电量计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计–77428的MCU-sample代码交付"><a href="#电量计–77428的MCU-sample代码交付" class="headerlink" title="电量计–77428的MCU sample代码交付"></a>电量计–77428的MCU sample代码交付</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>77428电量计的固件代码是固化在芯片内部ROM而不是Flash，无法下载更新。</p>
<p>一般客户需求是提供电量计配套的Host侧MCU sample代码，其中实现可配置参数的下载流程，不同的电池使用不同的参数建模数据，在客户MCU代码运行时下载到电量计。</p>
<p>可配置参数的来源：</p>
<p>（1）电池厂商提供的电池规格书文档和参数信息表excel，FAE和客户沟通获得。</p>
<p>（1）电芯特征数据：电芯拿到实验室 -&gt; 用循环仪器测试工具对电池循环充放电 -&gt; 得到循环仪原始采集文件csv，包括电压电流电荷 -&gt; 使用软件TableMaker从循环仪采集文件中提取出参数文件txt（RC table.txt和OCV table.txt），这部分需要FAE，软件开发，循环仪操作人协作。</p>
<p>可配置参数的写入：MCU host通过I2C给77428 chip中的F&#x2F;W（固化ROM）通信，写配置参数，以适配不同的电池模块。</p>
<h2 id="电池建模"><a href="#电池建模" class="headerlink" title="电池建模"></a>电池建模</h2><p>拿到客户电池，根据电池规格书的放电电流参数范围，决定要采集的电流范围；根据客户需求的温度范围，决定采集的温度范围。</p>
<p>77428 A2版本的固件要求电池建模必须至少采集4个电流 * 4个温度，共16种情况；每个采集得到电荷变化算出剩余容量RC</p>
<p>循环仪采集的建模数据集合示例：</p>
<p><a target="_blank" rel="noopener" href="https://o2micro-my.sharepoint.com/:u:/p/thomas_hu/Ebuc3fWIJndPnko8315TasIBkeIUS6LSJDYvnNlXK7-8TQ?e=OqHlto">JG-20250321.7z</a></p>
<p>经过77428 版本的TableMaker工具转换成77428 MCU sample代码能用的txt，77428项目使用的电池特征参数文件是OCV.txt和RC.txt，建模工具输出的.c&#x2F;.h是给其他项目使用。</p>
<p><a target="_blank" rel="noopener" href="https://o2micro-my.sharepoint.com/:u:/p/thomas_hu/ETi91u6I8-pFsxZtX3DQWlMB1pY2zaLarvceKMmWCYZR8g?e=FHpIXc">JG TABLE-20250321.7z</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211449916.png" alt="image-20250321144922884"></p>
<p>OCV table默认用OCV&#x2F;FalconLY里面的x数据（36个），用OCV目录的也可以，取y数据（36个）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211449354.png" alt="image-20250321144916301"></p>
<h2 id="MCU-sample代码合并电池参数的方法"><a href="#MCU-sample代码合并电池参数的方法" class="headerlink" title="MCU sample代码合并电池参数的方法"></a>MCU sample代码合并电池参数的方法</h2><p>（1）配OCV voltage，来源是OCV.txt的x或y。一般采样36个电压，电压范围来自规格书</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141702910.png" alt="image-20250214170240774"></p>
<p>（2）配RC.txt中的电压，电流，温度区间，以及RC容量值。</p>
<p>注意RC table的成员要和77428温度数组的项数目对应。</p>
<p>77428 A2版本FW规定死了Host代码配置的电流是4组，温度是4组，电压是36个采样，如果Host代码定义不符合，会写入参数报错。意味着循环仪对电池的采样测试至少要做4*4 &#x3D; 16组数据，可以多测但不能少。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201735883.png" alt="image-20250320173549846"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141716710.png" alt="image-20250214171651607"></p>
<p>（3）配MCU .h中的充放电参数，数据来自FAE提供的excel（源数据来自电池规格书）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141721613.png" alt="image-20250214172136527"></p>
<p>注：电池建模采集电压的范围要根据具体电池的规格书确定。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211405169.png" alt="image-20250321140503084"></p>
<p>注：DFCC table是调整算法的策略，其温度、电流、电压区间与电池建模的区间无关。没有调算法的需求就先不动。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211406800.png" alt="image-20250321140625765"></p>
<h2 id="MCU-sample代码分析"><a href="#MCU-sample代码分析" class="headerlink" title="MCU sample代码分析"></a>MCU sample代码分析</h2><p>MCU sample代码中有下发I2C配置77428的示例，客户需要根据自己的平台按类似的I2C包格式实现代码</p>
<p>（1）下载电池参数到77428。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141728106.png" alt="image-20250214172824010"></p>
<p>（2）通过77428自定义I2C SBS命令，查询电池状态</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202502141731968.png" alt="image-20250214173133900"></p>
<p>（3） SBS各命令的含义和格式要求见Firmware Specification</p>
<p>Host给电量计发的命令格式要按电量计specification规定，读写指定长度的数据，且带校验字节（PEC：Packet Error Check）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211413628.png" alt="image-20250321141318580"></p>
<h2 id="MCU-sample客户交付示例"><a href="#MCU-sample客户交付示例" class="headerlink" title="MCU sample客户交付示例"></a>MCU sample客户交付示例</h2><p><a target="_blank" rel="noopener" href="https://o2micro-my.sharepoint.com/:u:/p/thomas_hu/EePUWfAMJ2BMqXaudjTf96MBcnzJImOLlWLKQ6FRuVb5Og?e=uZMr2S">SW6000_SD77428_MCU_20250214.zip</a></p>
<h2 id="MCU-sample内部测试环境：代码移植到STM32F407运行"><a href="#MCU-sample内部测试环境：代码移植到STM32F407运行" class="headerlink" title="MCU sample内部测试环境：代码移植到STM32F407运行"></a>MCU sample内部测试环境：代码移植到STM32F407运行</h2><p><a target="_blank" rel="noopener" href="https://o2micro-my.sharepoint.com/:f:/p/thomas_hu/EmPIBLrw8ylMmO33dsfI9DQBnrkCqU9n5anKoXvQ-5et2w?e=dUpdfx">2.STM32F407测试环境</a></p>
<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>TODO</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--77561(77226)%E7%9A%84Firmware%20Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--77561(77226)%E7%9A%84Firmware%20Architecture/" class="post-title-link" itemprop="url">电量计 -- 77561(77226)的Firmware Architecture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 11:52:44" itemprop="dateModified" datetime="2025-11-18T11:52:44+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E9%87%8F%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">电量计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计–77561-77226-的Firmware-Architecture"><a href="#电量计–77561-77226-的Firmware-Architecture" class="headerlink" title="电量计–77561(77226)的Firmware Architecture"></a>电量计–77561(77226)的Firmware Architecture</h1><h1 id="Part1-总体结构概述"><a href="#Part1-总体结构概述" class="headerlink" title="Part1 总体结构概述"></a>Part1 总体结构概述</h1><h2 id="Keil-MDK项目结构"><a href="#Keil-MDK项目结构" class="headerlink" title="Keil MDK项目结构"></a>Keil MDK项目结构</h2><p>项目基于ARM Cortex-M0 MCU，使用Keil MDK开发环境构建。核心代码分为底层驱动、算法库和应用三层结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- newton.uvprojx           # Keil项目主文件</span><br><span class="line">- newton.sct               # 链接脚本</span><br><span class="line">- Device/                  # ARM M0 MCU设备相关文件</span><br><span class="line">- RTE/                     # 运行时环境配置</span><br><span class="line">- lib/                     # 核心算法库文件</span><br><span class="line">  - lib_fg.c/h             # 电量计核心算法库(Fuel Gauge)</span><br><span class="line">  - lib_pg.c/h             # 电池包电量计算法库(Pack Gauge)</span><br><span class="line">- user/                    # 用户应用代码</span><br><span class="line">  - main.c                 # 主程序入口</span><br><span class="line">  - parameter.c/h          # 参数配置</span><br><span class="line">  - sbsd.c/h               # SBS通信协议实现</span><br><span class="line">  - filter.c/h             # 数据滤波处理</span><br><span class="line">  - db_print.c/h           # 调试打印功能</span><br><span class="line">- flash/                   # Flash操作相关</span><br><span class="line">- chip/                    # 芯片驱动层</span><br><span class="line">- table/                   # 查找表数据</span><br><span class="line">- o2bootloader/            # 引导加载程序</span><br></pre></td></tr></table></figure>

<h2 id="启动和运行主流程"><a href="#启动和运行主流程" class="headerlink" title="启动和运行主流程"></a>启动和运行主流程</h2><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><ol>
<li><p>上电后从o2bootloader引导区启动</p>
</li>
<li><p>初始化MCU系统时钟和基本外设</p>
</li>
<li><p>初始化电量计参数和查找表</p>
</li>
<li><p>调用fg_init函数初始化电量计算法库</p>
</li>
<li><p>进入主循环</p>
</li>
</ol>
<h3 id="主循环流程"><a href="#主循环流程" class="headerlink" title="主循环流程"></a>主循环流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[上电] → [初始化] → [主循环&#123;</span><br><span class="line">  读取电池数据(电压/电流/温度)</span><br><span class="line">  处理电量计算法</span><br><span class="line">  更新SOC和其他电池状态</span><br><span class="line">  处理SBS通信请求</span><br><span class="line">  进入低功耗状态</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>主程序采用状态机设计，根据不同的电池状态(充电&#x2F;放电&#x2F;空闲)调用不同的处理函数。</p>
<h3 id="模块关系和流程图"><a href="#模块关系和流程图" class="headerlink" title="模块关系和流程图"></a>模块关系和流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[硬件层]</span><br><span class="line">  │</span><br><span class="line">  ├── MCU外设(ADC/I2C/Flash) </span><br><span class="line">  │       │</span><br><span class="line">  │       ▼</span><br><span class="line">  ├── 驱动层(chip/) </span><br><span class="line">  │       │</span><br><span class="line">  │       ▼</span><br><span class="line">[软件层]</span><br><span class="line">  │       </span><br><span class="line">  ├── 电量计算法核心(lib_fg) ◄────┐</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── 电池包管理(lib_pg)          │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── 应用层(user/main)           │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── SBS通信层(sbsd)             │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">[数据层]                          │</span><br><span class="line">  │                               │</span><br><span class="line">  └── 查找表(table/) ─────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">读取原始数据(电压/电流/温度) </span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">数据过滤(filter.c) </span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">状态判断(充电/放电/空闲)</span><br><span class="line">       │</span><br><span class="line">       ┌───────────┬────────────┐</span><br><span class="line">       ▼           ▼            ▼</span><br><span class="line">   充电状态     放电状态      空闲状态</span><br><span class="line">   处理函数     处理函数      处理函数</span><br><span class="line">       │           │            │</span><br><span class="line">       └───────────┼────────────┘</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">         SOC计算(库伦积分+OCV校正)</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">            电量计状态更新</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">              SBS数据更新</span><br></pre></td></tr></table></figure>

<h2 id="I2C-SBS通信命令"><a href="#I2C-SBS通信命令" class="headerlink" title="I2C SBS通信命令"></a>I2C SBS通信命令</h2><p>SBS（Smart Battery System）通信是电量计与主机通信的标准协议。该项目中在sbsd.c&#x2F;h文件实现了SBS标准通信命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">| 命令码 | 命令名称 | 描述 |</span><br><span class="line">|-------|---------|------|</span><br><span class="line">| 0x00 | ManufacturerAccess | 制造商访问 |</span><br><span class="line">| 0x01 | RemainingCapacityAlarm | 剩余容量警报 |</span><br><span class="line">| 0x02 | RemainingTimeAlarm | 剩余时间警报 |</span><br><span class="line">| 0x03 | BatteryMode | 电池模式 |</span><br><span class="line">| 0x04 | Temperature | 温度 |</span><br><span class="line">| 0x05 | Voltage | 电压 |</span><br><span class="line">| 0x06 | Current | 电流 |</span><br><span class="line">| 0x07 | AverageCurrent | 平均电流 |</span><br><span class="line">| 0x08 | MaxError | 最大误差 |</span><br><span class="line">| 0x09 | RelativeStateOfCharge | 相对电量百分比 |</span><br><span class="line">| 0x0A | AbsoluteStateOfCharge | 绝对电量百分比 |</span><br><span class="line">| 0x0B | RemainingCapacity | 剩余容量 |</span><br><span class="line">| 0x0C | FullChargeCapacity | 满充容量 |</span><br><span class="line">| 0x0D | RunTimeToEmpty | 运行剩余时间 |</span><br><span class="line">| 0x0E | AverageTimeToEmpty | 平均剩余时间 |</span><br><span class="line">| 0x0F | AverageTimeToFull | 平均充满时间 |</span><br><span class="line">| 0x10 | ChargingCurrent | 充电电流 |</span><br><span class="line">| 0x11 | ChargingVoltage | 充电电压 |</span><br><span class="line">| 0x12 | BatteryStatus | 电池状态 |</span><br><span class="line">| 0x13 | CycleCount | 循环次数 |</span><br><span class="line">| 0x14 | DesignCapacity | 设计容量 |</span><br><span class="line">| 0x15 | DesignVoltage | 设计电压 |</span><br><span class="line">| 0x16 | SpecificationInfo | 规格信息 |</span><br><span class="line">| 0x17 | ManufactureDate | 生产日期 |</span><br><span class="line">| 0x18 | SerialNumber | 序列号 |</span><br><span class="line">| 0x19 | ManufacturerName | 制造商名称 |</span><br><span class="line">| 0x1A | DeviceName | 设备名称 |</span><br><span class="line">| 0x1B | DeviceChemistry | 电池化学成分 |</span><br><span class="line">| 0x1C | ManufacturerData | 制造商数据 |</span><br><span class="line">| 0x3C-0x3F | GGMEM0-GGMEM8 | 调试内存区域 |</span><br></pre></td></tr></table></figure>

<p>此外，项目还实现了一些扩展命令，用于调试和配置电量计算法参数。</p>
<h2 id="电量计算法fg-lib分析"><a href="#电量计算法fg-lib分析" class="headerlink" title="电量计算法fg_lib分析"></a>电量计算法fg_lib分析</h2><h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef *struct* &#123;</span><br><span class="line">  // 电量计状态</span><br><span class="line">  *int* status;         // 电量计状态标志位</span><br><span class="line">  // 容量相关</span><br><span class="line">  *int* fcc;          // 满充容量(Full Charge Capacity)</span><br><span class="line">  *int* facc;          // 满充绝对容量(Full Absolute Charge Capacity)</span><br><span class="line">  *int* rca;          // 剩余容量(Remaining Capacity)</span><br><span class="line">  *int* chgcap;         // 充电容量</span><br><span class="line"></span><br><span class="line">  // SOC相关</span><br><span class="line">  *int* soc;          // 当前SOC百分比(0-10000，对应0-100%)</span><br><span class="line">  *int* soc_raw;        // 原始SOC</span><br><span class="line">  *int* soc_now;        // 实时SOC</span><br><span class="line">  *int* rsoc_now;        // 相对SOC</span><br><span class="line"></span><br><span class="line">  // 电池参数</span><br><span class="line">  *int* cell_temp;       // 电池温度</span><br><span class="line">  *int* cell_volt;       // 电池电压</span><br><span class="line">  *int* cell_curr;       // 电池电流</span><br><span class="line"></span><br><span class="line">  // 算法参数</span><br><span class="line">  *int* parm_eocmv;       // 充电截止电压</span><br><span class="line">  *int* parm_eocma;       // 充电截止电流</span><br><span class="line">  *int* parm_eodmv;       // 放电截止电压</span><br><span class="line"></span><br><span class="line">  // 时间记录</span><br><span class="line">  *unsigned* *int* chgtime;    // 充电时间</span><br><span class="line">  *unsigned* *int* dsgtime;    // 放电时间</span><br><span class="line">  *unsigned* *int* idletime;   // 空闲时间</span><br><span class="line"></span><br><span class="line">  // 表格数据</span><br><span class="line">  FG_LUT_T fg_tbls;      // 查找表结构</span><br><span class="line"></span><br><span class="line">  // 滤波相关</span><br><span class="line">  *int* cavgmov;        // 移动平均电流</span><br><span class="line">  *int* cavgcntr[4];      // 电流滤波器</span><br><span class="line">&#125; LIB_FG_TYPE_T;</span><br></pre></td></tr></table></figure>



<h3 id="算法核心模块"><a href="#算法核心模块" class="headerlink" title="算法核心模块"></a>算法核心模块</h3><h4 id="电量计状态机"><a href="#电量计状态机" class="headerlink" title="电量计状态机"></a>电量计状态机</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电量计使用状态机管理不同的工作状态：</span><br><span class="line">\#define FG_STAT_INIT    0x00000001 // 初始化状态</span><br><span class="line">\#define FG_STAT_CHG     0x00000002 // 充电状态</span><br><span class="line">\#define FG_STAT_DSG     0x00000004 // 放电状态</span><br><span class="line">\#define FG_STAT_IDLE    0x00000008 // 空闲状态</span><br><span class="line">\#define FG_STAT_CHG_CC   0x00000010 // 恒流充电</span><br><span class="line">\#define FG_STAT_CHG_CV   0x00000020 // 恒压充电</span><br><span class="line">\#define FG_STAT_CHG_EOC   0x00000040 // 充电截止</span><br><span class="line">\#define FG_STAT_DSG_EOD   0x00000080 // 放电截止</span><br><span class="line">\#define FG_STAT_DSG_FST1  0x00000100 // 快速放电1</span><br><span class="line">\#define FG_STAT_DSG_FST2  0x00000200 // 快速放电2</span><br><span class="line">\#define FG_STAT_DSG_LT   0x00000400 // 低温放电</span><br></pre></td></tr></table></figure>



<h4 id="SOC计算核心"><a href="#SOC计算核心" class="headerlink" title="SOC计算核心"></a>SOC计算核心</h4><p>SOC (State of Charge) 计算采用混合算法：</p>
<ol>
<li><p>库伦积分法</p>
<p>：根据电流积分计算电量变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 电流积分计算</span><br><span class="line">  delta_capacity = (current * delta_time) / 3600; // 单位：mAh</span><br><span class="line">  rca = rca - delta_capacity; // 更新剩余容量</span><br><span class="line">  soc = (rca * 10000) / fcc;  // 计算SOC(0-10000)</span><br></pre></td></tr></table></figure>


</li>
<li><p>OCV校准</p>
<p>：通过电压查表获取SOC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> // 通过OCV查表获取SOC</span><br><span class="line">  FG_ERROR_T fg_get_soc_by_ocv(FG_HANDLE_T **handle*, *short* *ocv_mv*, *short* **soc*)</span><br><span class="line">  &#123;</span><br><span class="line">​    // 通过一维表查找获取SOC</span><br><span class="line">​    return lut_one_axis_r(handle, &amp;(((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.ocv_tbl), ocv_mv, soc);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>混合算法</p>
<p>：结合库伦积分和OCV校准</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // 空闲状态下的OCV校准</span><br><span class="line">  if (idle_time &gt; OCV_RELAX_TIME) &#123;</span><br><span class="line">​    // 获取OCV对应的SOC</span><br><span class="line">​    fg_get_soc_by_ocv(handle, ocv, &amp;ocv_soc);</span><br><span class="line"></span><br><span class="line">​    // 计算偏差</span><br><span class="line">​    delta = ocv_soc - current_soc;</span><br><span class="line"></span><br><span class="line">​    // 如果偏差超过阈值，进行校准</span><br><span class="line">​    if (abs(delta) &gt; OCV_DELTA_THRESHOLD) &#123;</span><br><span class="line">​      // 使用滤波平滑过渡</span><br><span class="line">​      current_soc = current_soc + (delta * OCV_FILTER_FACTOR) / 100;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="温度补偿"><a href="#温度补偿" class="headerlink" title="温度补偿"></a>温度补偿</h4><p>温度对电池容量和电压有显著影响，算法中实现了温度补偿：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 温度补偿</span><br><span class="line">FG_ERROR_T fg_get_temp_factor(FG_HANDLE_T **handle*, *short* *temp*, *short* **factor*)</span><br><span class="line">&#123;</span><br><span class="line">  // 查表获取温度补偿系数</span><br><span class="line">  return lut_one_axis_f(handle, &amp;(((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.temp_factor_tbl), temp, factor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 应用温度补偿</span><br><span class="line">fcc_temp = (fcc * temp_factor) / 1000; // 温度修正后的满充容量</span><br></pre></td></tr></table></figure>



<h4 id="老化补偿"><a href="#老化补偿" class="headerlink" title="老化补偿"></a>老化补偿</h4><p>电池循环次数增加会导致容量衰减，算法实现了老化补偿：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 老化因子计算</span><br><span class="line">*int* fg_check_agefactor(FG_HANDLE_T **handle*)</span><br><span class="line">&#123;</span><br><span class="line">  *int* temp = fg_idiv_rounddown(handle, ((LIB_FG_TYPE_T *)handle)-&gt;chgcap, ((LIB_FG_TYPE_T *)handle)-&gt;facc);</span><br><span class="line">  temp *= FG_AGING_RATIO_MIN; // 最小损耗 * 循环次数</span><br><span class="line">  temp = (10000 - temp) / 100;</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 应用老化补偿</span><br><span class="line">fcc_aged = (fcc * (10000 - aging_factor)) / 10000; // 老化修正后的满充容量</span><br></pre></td></tr></table></figure>



<h4 id="快速放电处理"><a href="#快速放电处理" class="headerlink" title="快速放电处理"></a>快速放电处理</h4><p>在大电流放电或低电压情况下，电池容量会急剧下降，算法实现了快速放电处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static *int* fg_fast_dsg(FG_HANDLE_T **handle*, FG_PARAM_T **param*)</span><br><span class="line">&#123;</span><br><span class="line">  // 根据不同电压档位加速SOC下降速率</span><br><span class="line">  if (param-&gt;volt_lo_mv &lt; (((LIB_FG_TYPE_T *)handle)-&gt;parm_eodmv - ((LIB_FG_TYPE_T *)handle)-&gt;parm_ddv - 200)) &#123;</span><br><span class="line">​    // 每秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 100);</span><br><span class="line">  &#125; else if (param-&gt;volt_lo_mv &lt; (((LIB_FG_TYPE_T *)handle)-&gt;parm_eodmv - ((LIB_FG_TYPE_T *)handle)-&gt;parm_ddv - 100)) &#123;</span><br><span class="line">​    // 每5秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 500);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">​    // 每10秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新状态</span><br><span class="line">  ((LIB_FG_TYPE_T *)handle)-&gt;status |= FG_STAT_DSG_FST1;</span><br><span class="line">  return ERR_FG_NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="查表算法"><a href="#查表算法" class="headerlink" title="查表算法"></a>查表算法</h4><p>算法使用多种查表算法进行插值计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 一维表正向查找</span><br><span class="line">static *int* lut_one_axis_f(FG_HANDLE_T **handle*, *tbl_one_t* **table*, *short* *input*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 通过输入值在表中查找并插值计算输出值</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一维表反向查找</span><br><span class="line">static *int* lut_one_axis_r(FG_HANDLE_T **handle*, *tbl_one_t* **table*, *short* *value*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 通过目标值反向查找输入值</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 三维表查找</span><br><span class="line">static *int* lut_three_axis(FG_HANDLE_T **handle*, *tbl_three_t* **table*, *short* *x_value*, *short* *y_value*, *short* *z_value*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 三维插值计算</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法流程概述"><a href="#算法流程概述" class="headerlink" title="算法流程概述"></a>算法流程概述</h3><h4 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h4><p>fg_init() → 初始化电量计参数和状态 → 加载查找表 → OCV初始化SOC</p>
<h4 id="充电处理流程"><a href="#充电处理流程" class="headerlink" title="充电处理流程"></a>充电处理流程</h4><p>检测充电状态 → 更新充电时间 → 库伦积分计算SOC → 判断CC&#x2F;CV模式 → 检查充电截止条件 → 更新SOC</p>
<h4 id="放电处理流程"><a href="#放电处理流程" class="headerlink" title="放电处理流程"></a>放电处理流程</h4><p>检测放电状态 → 更新放电时间 → 库伦积分计算SOC → 温度补偿 → 低电压检测 → 快速放电处理 → 更新SOC</p>
<h4 id="空闲处理流程"><a href="#空闲处理流程" class="headerlink" title="空闲处理流程"></a>空闲处理流程</h4><p>检测空闲状态 → 更新空闲时间 → 检查OCV稳定时间 → OCV校准SOC → 更新SOC</p>
<h2 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h2><p>该电量计实现了以下低功耗策略：</p>
<ol>
<li><p>工作周期设计：系统大部分时间处于深度睡眠状态，定时唤醒采集数据和处理</p>
</li>
<li><p>外设优化：只在需要时启用ADC、I2C等外设</p>
</li>
<li><p>代码执行效率：优化算法减少指令执行次数</p>
</li>
<li><p>数据存储优化：使用查找表减少计算量</p>
</li>
</ol>
<h2 id="调试和校准工具"><a href="#调试和校准工具" class="headerlink" title="调试和校准工具"></a>调试和校准工具</h2><p>根据Cobra工具文档，系统支持以下调试和校准功能：</p>
<ol>
<li>电流校准：通过Cobra工具校准0电流、正向电流和负向电流</li>
<li>数据采集：通过SBS协议读取电量计内部状态</li>
<li>内存调试：通过GGMEM0-GGMEM8访问电量计内部RAM</li>
<li>参数配置：通过Cobra工具配置电量计算法参数</li>
</ol>
<h1 id="Part2-Firmware主要功能模块分析"><a href="#Part2-Firmware主要功能模块分析" class="headerlink" title="Part2 Firmware主要功能模块分析"></a>Part2 Firmware主要功能模块分析</h1><h2 id="通信接口（SBS命令流程）"><a href="#通信接口（SBS命令流程）" class="headerlink" title="通信接口（SBS命令流程）"></a>通信接口（SBS命令流程）</h2><p>以SBS命令0x0D(RSOC - 相对电量)为例，详细介绍整个处理流程，包含main.c、sbs.c和i2c.c三个文件在这个流程中的角色和作用</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>（1）main.c中的初始化：</p>
<p>在main.c中：</p>
<ol>
<li>调用i2cif_init初始化I2C接口，设置从机地址和回调函数sbs_callback_i2c_slave</li>
<li>调用sbsif_init初始化SBS接口</li>
<li>调用gg_lib_init初始化电量计算库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int* main(*void*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // ...系统初始化</span><br><span class="line"></span><br><span class="line">  // 初始化I2C接口，设置从机地址和回调函数</span><br><span class="line">  i2cif_init(param_board_cfg[PARM_BCFG_I2CADDR], tx_buff, sbs_callback_i2c_slave);</span><br><span class="line"></span><br><span class="line">  // 初始化SBS接口</span><br><span class="line">  sbsif_init(param_board_cfg[PARM_BCFG_I2CADDR]);</span><br><span class="line"></span><br><span class="line">  // 初始化电量计模块</span><br><span class="line">  gg_lib_init();</span><br><span class="line"></span><br><span class="line">  // ...其他初始化</span><br><span class="line"></span><br><span class="line">  // 进入主循环</span><br><span class="line">  main_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）sbs.c中的初始化</p>
<ol>
<li>初始化SBS接口数据结构</li>
<li>初始化SBS数据缓冲区，包括SBS0D_RSOC（相对电量）的初始值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void* sbsif_init(*uint32_t* *slv_addr*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  psbsifHandle = (SBS_HANDLE_T *)sbs_mem;</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_slv_addr = slv_addr;</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff = sbs_data_buff;</span><br><span class="line"></span><br><span class="line">  // ...初始化各种SBS数据</span><br><span class="line"></span><br><span class="line">  // 初始相对电量为0</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）i2c.c中的初始化</p>
<ol>
<li><p>初始化I2C接口数据结构</p>
</li>
<li><p>配置I2C硬件参数</p>
</li>
<li><p>设置回调函数，该函数将在I2C通信事件发生时被调用</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void* i2cif_init(*uint32_t* *slv_addr*, *uint8_t* **t_buff*, i2c_callback *p_callback*)</span><br><span class="line">&#123;</span><br><span class="line">  i2cif_p = (I2CIF_T *)(i2c_mem);</span><br><span class="line">  i2cif_p-&gt;pI2C_Base = I2C;      // I2C模块基地址</span><br><span class="line">  i2cif_p-&gt;slv_addr = slv_addr;    // 从机地址</span><br><span class="line">  i2cif_p-&gt;tx_buffer = t_buff;     // 发送缓冲区</span><br><span class="line">  i2cif_p-&gt;i2c_callback_f = p_callback; // 回调函数</span><br><span class="line"></span><br><span class="line">  // ...配置I2C硬件</span><br><span class="line"></span><br><span class="line">  // 启用中断</span><br><span class="line">  Chip_I2C_EnableInts(i2cif_p-&gt;pI2C_Base, (...));</span><br><span class="line">  Chip_I2C_Enable(i2cif_p-&gt;pI2C_Base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="电量数据更新阶段"><a href="#电量数据更新阶段" class="headerlink" title="电量数据更新阶段"></a>电量数据更新阶段</h3><p>（1）main.c中的电量数据更新：</p>
<p>主循环调用gg_step计算最新的电量数据<br>调用gg_sync_result将电量计算结果同步到SBS数据<br>调用sbsif_update和sbsif_update_time更新SBS数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void* main_loop()</span><br><span class="line">&#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">​    // ...其他循环处理</span><br><span class="line">​    // 更新电量计算</span><br><span class="line">​    gg_step(passSec);</span><br><span class="line">​    // 同步电量计结果到SBS</span><br><span class="line">​    gg_sync_result();</span><br><span class="line">​    // 更新SBS数据</span><br><span class="line">​    sbsif_update(1);</span><br><span class="line">​    sbsif_update_time();</span><br><span class="line">​    // ...其他处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static *void* gg_sync_result(*void*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // 将电量计计算结果同步到SBS数据</span><br><span class="line">  sbsif_set_data(SBS0D_RSOC, gg_result.rsoc);</span><br><span class="line">  // ...更新其他SBS数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）sbs.c中的电量数据更新</p>
<p>sbsif_set_data函数允许外部模块（如电量计）直接设置SBS数据<br>sbsif_update函数基于库仑计数据和满充容量计算相对电量<br>将计算结果存储在SBS0D_RSOC（相对电量）中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void sbsif_update(uint8_t updata_cc)</span><br><span class="line">&#123;</span><br><span class="line">    // ...更新其他数据</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 更新相对电量</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS5F_CCACCMAH];</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= 100;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val /= ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS10_FCC];</span><br><span class="line">    temp1 = ((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line">    if (temp1 &gt; 100)</span><br><span class="line">        temp1 = 100;</span><br><span class="line">    </span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC] = temp1;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void sbsif_set_data(SBS_DATA_T index, int32_t ivalue)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; SBSD_CMD_MAX) &#123;</span><br><span class="line">        sbs_data_buff[index] = ivalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I2C通信阶段-处理SBS-0x0D命令"><a href="#I2C通信阶段-处理SBS-0x0D命令" class="headerlink" title="I2C通信阶段 - 处理SBS 0x0D命令"></a>I2C通信阶段 - 处理SBS 0x0D命令</h3><p>当上位机发送SBS命令0x0D（读取相对电量）时：</p>
<p>（1）i2c.c中的命令接收</p>
<p>首先接收SBS命令字节(0x0D)并识别它<br>当上位机发送读请求时，调用回调函数准备要发送的数据<br>当I2C发送缓冲区需要数据时，发送预先准备好的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">I2C_STATUS_T i2cif_slave_handle(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 地址匹配检测</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_ADDR) &#123;</span><br><span class="line">        // 检查I2C方向（读/写）</span><br><span class="line">        if (i2cif_p-&gt;intstat &amp; I2C_ISR1_SLV_ADDR_DIR) &#123;</span><br><span class="line">            // 读操作 - 准备发送数据</span><br><span class="line">            i2cif_p-&gt;i2c_state = I2C_XFER_SLVSND;</span><br><span class="line">            // ...</span><br><span class="line">            i2cif_p-&gt;i2c_status = I2C_STATUS_TXDATA;</span><br><span class="line">            if (i2cif_p-&gt;i2c_callback_f) &#123;</span><br><span class="line">                i2cif_p-&gt;i2c_callback_f(i2cif_p-&gt;i2c_status, i2cif_p-&gt;sbd_idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 写操作 - 准备接收命令</span><br><span class="line">            i2cif_p-&gt;i2c_state = I2C_XFER_SLVRCV;</span><br><span class="line">            i2cif_p-&gt;rx_idx = 0;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 接收数据</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_RXNE) &#123;</span><br><span class="line">        i2cif_p-&gt;data = Chip_I2C_ReadRXData(i2cif_p-&gt;pI2C_Base);</span><br><span class="line">        </span><br><span class="line">        // 第一个字节是SBS命令</span><br><span class="line">        if (i2cif_p-&gt;rx_idx == 0) &#123;</span><br><span class="line">            i2cif_p-&gt;i2c_cmd = (uint8_t)i2cif_p-&gt;data; // 0x0D</span><br><span class="line">            </span><br><span class="line">            // 查找命令定义</span><br><span class="line">            do &#123;</span><br><span class="line">                if (((sbsd_cmd_def[i2cif_p-&gt;sbd_idx] &amp; SBSD_CMD_Msk) &gt;&gt; SBSD_CMD_Pos) == i2cif_p-&gt;i2c_cmd) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; while ((i2cif_p-&gt;sbd_idx++) &lt; SBSD_CMD_MAX);</span><br><span class="line">            </span><br><span class="line">            // ...处理命令</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 发送数据</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_TXIS &amp;&amp; i2cif_p-&gt;i2c_state == I2C_XFER_SLVSND) &#123;</span><br><span class="line">        if (i2cif_p-&gt;tx_idx &lt; i2cif_p-&gt;tx_size) &#123;</span><br><span class="line">            if (i2cif_p-&gt;tx_buffer) &#123;</span><br><span class="line">                i2cif_p-&gt;data = *i2cif_p-&gt;tx_buffer;</span><br><span class="line">                i2cif_p-&gt;tx_buffer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // ...</span><br><span class="line">        </span><br><span class="line">        i2cif_p-&gt;tx_idx++;</span><br><span class="line">        Chip_I2C_WriteTXData(i2cif_p-&gt;pI2C_Base, i2cif_p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）main.c中的I2C回调处理</p>
<p>回调函数sbs_callback_i2c_slave处理I2C事件<br>当接收到状态I2C_STATUS_TXDATA时，准备发送数据<br>对于命令SBS0D_RSOC，调用sbsif_get_data获取当前相对电量<br>将数据填充到发送缓冲区<br>调用i2cif_set_tx通知I2C模块准备发送这些数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void sbs_callback_i2c_slave(uint32_t status, uint32_t n)</span><br><span class="line">&#123;</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case I2C_STATUS_TXDATA:</span><br><span class="line">            // 准备发送数据</span><br><span class="line">            switch (n) &#123;</span><br><span class="line">                case SBS0D_RSOC:</span><br><span class="line">                    // 准备发送相对电量数据</span><br><span class="line">                    value = sbsif_get_data(SBS0D_RSOC);</span><br><span class="line">                    </span><br><span class="line">                    // 设置发送缓冲区</span><br><span class="line">                    *tx_ptr++ = (uint8_t)value;</span><br><span class="line">                    *tx_ptr++ = (uint8_t)(value &gt;&gt; 8);</span><br><span class="line">                    </span><br><span class="line">                    // 设置要发送的数据大小</span><br><span class="line">                    i2cif_set_tx(tx_cnt, tx_buff);</span><br><span class="line">                    break;</span><br><span class="line">                </span><br><span class="line">                // ...处理其他SBS命令</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">        // ...处理其他I2C状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）sbs.c中的数据获取</p>
<p>sbsif_get_data函数返回指定SBS命令的当前值<br>对于SBS0D_RSOC，返回当前存储的相对电量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int32_t sbsif_get_data(SBS_DATA_T index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;= SBSD_CMD_MAX)</span><br><span class="line">        return sbs_data_buff[SBS03_BATTMODE];</span><br><span class="line">    else</span><br><span class="line">        return sbs_data_buff[index]; // 返回SBS0D_RSOC的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整流程图解"><a href="#完整流程图解" class="headerlink" title="完整流程图解"></a>完整流程图解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">【初始化阶段】</span><br><span class="line">main.c:main() </span><br><span class="line">    ↓</span><br><span class="line">    ├── i2c.c:i2cif_init() → 初始化I2C接口</span><br><span class="line">    ├── sbs.c:sbsif_init() → 初始化SBS数据接口</span><br><span class="line">    └── main.c:gg_lib_init() → 初始化电量计算库</span><br><span class="line"></span><br><span class="line">【电量数据更新阶段 - 周期性执行】</span><br><span class="line">main.c:main_loop()</span><br><span class="line">    ↓</span><br><span class="line">    ├── main.c:gg_step() → 电量计算</span><br><span class="line">    ├── main.c:gg_sync_result() → 同步电量计结果</span><br><span class="line">    │   └── sbs.c:sbsif_set_data(SBS0D_RSOC, ...) → 更新SBS数据</span><br><span class="line">    ├── sbs.c:sbsif_update() → 更新SBS接口数据</span><br><span class="line">    └── sbs.c:sbsif_update_time() → 更新时间预测数据</span><br><span class="line"></span><br><span class="line">【I2C通信阶段 - 上位机请求时】</span><br><span class="line">上位机发送SBS命令0x0D</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:I2C_IRQHandler() → I2C中断处理</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_slave_handle() → 识别命令0x0D</span><br><span class="line">    ↓</span><br><span class="line">main.c:sbs_callback_i2c_slave() → 处理I2C回调</span><br><span class="line">    ↓</span><br><span class="line">sbs.c:sbsif_get_data(SBS0D_RSOC) → 获取当前相对电量值</span><br><span class="line">    ↓</span><br><span class="line">main.c:sbs_callback_i2c_slave() → 准备发送数据</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_set_tx() → 设置发送缓冲区</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_slave_handle() → 通过I2C发送数据</span><br><span class="line">    ↓</span><br><span class="line">上位机接收相对电量数据</span><br></pre></td></tr></table></figure>

<h3 id="SBS命令的隐式支持"><a href="#SBS命令的隐式支持" class="headerlink" title="SBS命令的隐式支持"></a>SBS命令的隐式支持</h3><p>注意sbs_callback_i2c_slave中的default流程，可能隐藏支持一些SBS命令，例如SBS30_CV</p>
<p>每秒轮询更新eocmv之后，存储到sbs buffer的SBS30_CV：</p>
<pre><code>smart_charge_func:
	((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS30_CV] = eocmv;
	((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS34_EOC] = eocma;
</code></pre>
<p>((SBSIF_T *)psbsifHandle)-&gt;sbs_buff和sbs_data_buff指向同一个内存区域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void sbsif_init(uint32_t slv_addr)</span><br><span class="line">&#123;</span><br><span class="line">    psbsifHandle = (SBS_HANDLE_T *)sbs_mem;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_slv_addr = slv_addr;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff = sbs_data_buff;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host发SBS30命令查询时，进到sbs_callback_i2c_slave的I2C_STATUS_TXDATA default，拿到sbs_data_buff数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sbs_callback_i2c_slave:</span><br><span class="line"></span><br><span class="line">//命令返回数据大小</span><br><span class="line">size = ((sbsd_cmd_def[n] &amp; SBSD_LEN_Msk) &gt;&gt; SBSD_LEN_Pos);</span><br><span class="line"></span><br><span class="line">switch (n)&#123;</span><br><span class="line">... //显式定义的命令处理</span><br><span class="line">//隐式处理命令：只要定义过的命令数据写到了sbs_data_buff就能获取到</span><br><span class="line">default: </span><br><span class="line">	pBuff = (uint8_t*)(&amp;sbs_data_buff[n]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2cif_set_tx(size, pBuff);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>default隐式支持的命令必须在sbsd_cmd_def数组中注册，否则I2C接口无法识别。</p>
</li>
<li><p>注册的数据大小要和传入值一致（0x30的SBSD_LEN_Pos处定义数据是4byte）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const unsigned int sbsd_cmd_def[SBSD_CMD_MAX] = &#123;</span><br><span class="line">	(0x03UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RW &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),		//0x03000434UL, /* BattMode */</span><br><span class="line">	(0x09UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x09000415UL, /* Voltage */</span><br><span class="line">	(0x0AUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0A000415UL, /* Current */</span><br><span class="line">	(0x0BUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0B000415UL, /* AvgCurrent */</span><br><span class="line">	(0x0DUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0D000415UL, /* RSOC */</span><br><span class="line">	(0x0EUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0E000415UL, /* ASOC */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">(0x30UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),			/* CHGVOLT */</span><br><span class="line">(0x32UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),			/* CHGCURRENT */</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>FW参数有两个来源：</p>
<p>代码的默认配置；</p>
<p>Cobra写入到PRJ文件的Flash参数区域（GDM）</p>
<h3 id="代码默认配置参数"><a href="#代码默认配置参数" class="headerlink" title="代码默认配置参数"></a>代码默认配置参数</h3><h3 id="Cobra写入Flash参数"><a href="#Cobra写入Flash参数" class="headerlink" title="Cobra写入Flash参数"></a>Cobra写入Flash参数</h3><p>以param_board_cfg[PARM_BCFG_DESIGNCAPACITY]为例：</p>
<p>（1）定义：</p>
<p>param_board_cfg[PARM_BCFG_DESIGNCAPACITY] 是从 Flash 中读取的设计容量参数</p>
<p>在 parameter.h 中定义了参数的枚举类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">  // ...</span><br><span class="line">  PARM_BCFG_DESIGNCAPACITY, //=14</span><br><span class="line">  // ...</span><br><span class="line">  PARM_BCFG_MAX</span><br><span class="line">&#125; PARM_TYPE_BCFG_T;</span><br></pre></td></tr></table></figure>

<p>parameter.c 中定义了参数数组及其默认值（实际不是值，是Flash offset）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile signed int param_board_cfg[(PARM_BCFG_MAX)] = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  0x1388,                //0x0D48, PARM_BCFG_DESIGNCAPACITY, 5000mAh</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）参数加载过程：</p>
<p>在 gdm_init() 函数中，位于 flash&#x2F;gdm.c 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void gdm_init()</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    if (M32(GDM_FLASH_TABLECHECKSUM) != NEWTON_FLASH_EMPTY_DWORD)</span><br><span class="line">    &#123;</span><br><span class="line">        // copy Board configure from flash</span><br><span class="line">        ptrmemu32 = (uint32_t *)param_board_cfg;</span><br><span class="line">        for (i = 0; i &lt; PARM_BCFG_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flashoffset = GDM_FLASH_BOARD_CONF + i * 4;</span><br><span class="line">            *(ptrmemu32 + i) = M32(flashoffset);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...</span><br><span class="line">        gdm_load_sw_cali();</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码：<br>首先检查 Flash 中的校验和是否有效<br>如果有效，则从 Flash 地址 GDM_FLASH_BOARD_CONF 开始，按顺序读取所有配置参数<br>每个参数占用 4 字节，按照枚举顺序依次读取<br>将读取的值存储到 param_board_cfg 数组中</p>
<p>（3）参数使用</p>
<p>设计容量参数在多处被使用，例如在 user&#x2F;main.c 中初始化电量计算配置时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FG_CONFIG_T cfg;</span><br><span class="line">cfg.dsncap = (int32_t)(param_board_cfg[PARM_BCFG_DESIGNCAPACITY]);</span><br></pre></td></tr></table></figure>

<p>在 sbs.c 中初始化 SBS 接口时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS18_DSNCAP] = param_board_cfg[PARM_BCFG_DESIGNCAPACITY];</span><br></pre></td></tr></table></figure>



<h2 id="数据持久化（Flash-log日志）"><a href="#数据持久化（Flash-log日志）" class="headerlink" title="数据持久化（Flash log日志）"></a>数据持久化（Flash log日志）</h2><h3 id="log数据结构"><a href="#log数据结构" class="headerlink" title="log数据结构"></a>log数据结构</h3><p>log.c实现了电池管理系统的日志记录和数据持久化功能，主要包括：<br>历史数据记录：记录电池使用过程中的极值数据，如最高&#x2F;最低电压、最大充放电电流、最高&#x2F;最低温度等<br>参数持久化：存储电量计算所需的自学习参数，确保系统断电后能恢复重要数据<br>Flash管理：管理Flash存储空间，实现数据的读写和擦除功能<br>CRC校验：通过CRC校验确保持久化数据的完整性</p>
<p>日志模块使用LOG_T结构体存储数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint16_t checksum;        // CRC校验值</span><br><span class="line">    uint16_t logindex;        // 日志索引</span><br><span class="line">    uint32_t historiage;      // 历史容量老化累计</span><br><span class="line">    uint16_t rc;              // 当前剩余容量</span><br><span class="line">    uint8_t packinfo[64];     // 电池包信息</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 极值记录</span><br><span class="line">    uint16_t vmaxcell1;       // 最高单体电压</span><br><span class="line">    uint16_t vmincell1;       // 最低单体电压</span><br><span class="line">    uint16_t cmaxchg;         // 最大充电电流</span><br><span class="line">    int16_t cmaxdsg;          // 最大放电电流</span><br><span class="line">    uint16_t maxtempcell;     // 最高温度</span><br><span class="line">    uint8_t maxtempcnt;       // 高温事件计数</span><br><span class="line">    uint16_t mintempcell;     // 最低温度</span><br><span class="line">    </span><br><span class="line">    // 时间统计</span><br><span class="line">    uint16_t timefw;          // 固件运行时间</span><br><span class="line">    uint16_t timeUT;          // 极低温时间</span><br><span class="line">    uint16_t timeELT;         // 超低温时间</span><br><span class="line">    uint16_t timeLTL;         // 低温下限时间</span><br><span class="line">    uint16_t timeLT;          // 低温时间</span><br><span class="line">    uint16_t timeLTH;         // 低温上限时间</span><br><span class="line">    uint16_t timeSTL;         // 标准温度下限时间</span><br><span class="line">    uint16_t timeRT;          // 参考温度时间</span><br><span class="line">    uint16_t timeSTH;         // 标准温度上限时间</span><br><span class="line">    uint16_t timeHT;          // 高温时间</span><br><span class="line">    uint16_t timeOT;          // 过温时间</span><br><span class="line"></span><br><span class="line">&#125; LOG_T;</span><br></pre></td></tr></table></figure>

<h3 id="日志数据初始化和更新"><a href="#日志数据初始化和更新" class="headerlink" title="日志数据初始化和更新"></a>日志数据初始化和更新</h3><p>（1）初始化流程：初始化过程中，系统会从Flash中读取最新的日志记录，校验其完整性，并将数据同步到内存中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void log_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化Flash接口</span><br><span class="line">    eflash_init();</span><br><span class="line">    </span><br><span class="line">    // 查找最新的日志</span><br><span class="line">    ret = find_latest_log();</span><br><span class="line">    if (-1 == ret) &#123;</span><br><span class="line">        // 没有找到日志，初始化缓冲区</span><br><span class="line">        log_init_buff();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 读取日志数据</span><br><span class="line">        for (i = 0; i &lt; sizeof(LOG_T); i++)</span><br><span class="line">            log_mem[i] = Chip_Flash_Read_Main_Byte(...);</span><br><span class="line">        </span><br><span class="line">        // 校验CRC</span><br><span class="line">        for (i = LOG_DATA_START; i &lt; sizeof(LOG_T); i += 2)</span><br><span class="line">            wval = math_calc_crc16(*(uint16_t *)(log_mem + i), wval);</span><br><span class="line">            </span><br><span class="line">        if (wval == log_p-&gt;checksum) &#123;</span><br><span class="line">            // CRC校验通过，同步数据到内存</span><br><span class="line">            ((SBSIF_T *)psbsifHandle)-&gt;sbs_historiage = log_p-&gt;historiage;</span><br><span class="line">            vmaxcell1_now = log_p-&gt;vmaxcell1;</span><br><span class="line">            vmincell1_now = log_p-&gt;vmincell1;</span><br><span class="line">            // ...其他数据同步</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 日志索引自增</span><br><span class="line">        log_p-&gt;logindex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void recover_dfcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 从Flash读取DFCC数据</span><br><span class="line">    log_crc = Chip_Flash_Read_Main_DWord(PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET);</span><br><span class="line"></span><br><span class="line">    // 计算数据的CRC校验值</span><br><span class="line">    for (i = 0; i &lt; DFCC_TABLE_LEN; i += 2) &#123;</span><br><span class="line">        value = Chip_Flash_Read_Main_Word((PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET) + 4 + i);</span><br><span class="line">        wval = math_calc_crc16(value, wval);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 校验CRC</span><br><span class="line">    if ((log_crc == wval) &amp;&amp; (wval != 0)) &#123;</span><br><span class="line">        // 复制数据到内存</span><br><span class="line">        fn_memcpy(DFCC_table, (uint8_t *)(PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET) + 4, DFCC_TABLE_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类似地恢复充电FCC表和放电偏移量表...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）数据更新流程</p>
<p>数据更新流程中，系统会持续监控电池参数的极值，并在特定条件下（如极值变化、定时更新、强制更新）将数据写入Flash。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void update_log_data(uint8_t right_now)</span><br><span class="line">&#123;</span><br><span class="line">    // 更新电压极值</span><br><span class="line">    if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &gt; vmaxcell1_now)</span><br><span class="line">        vmaxcell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &lt; vmincell1_now)</span><br><span class="line">        vmincell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line">    </span><br><span class="line">    // 判断是否需要更新日志</span><br><span class="line">    if ((log_check_ultimate_value() &amp;&amp; lifetime_en) || right_now || (time_flag[10] &amp;&amp; lifetime_en)) &#123;</span><br><span class="line">        // 更新日志数据</span><br><span class="line">        log_p-&gt;historiage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_agemah;</span><br><span class="line">        log_p-&gt;rc = sbsif_get_data(SBS0F_RC);</span><br><span class="line">        </span><br><span class="line">        if (lifetime_en) &#123;</span><br><span class="line">            log_p-&gt;vmaxcell1 = vmaxcell1_now;</span><br><span class="line">            log_p-&gt;vmincell1 = vmincell1_now;</span><br><span class="line">            log_p-&gt;cmaxchg = cmaxchg_now;</span><br><span class="line">            log_p-&gt;cmaxdsg = cmaxdsg_now;</span><br><span class="line">            log_p-&gt;maxtempcell = (maxtempcell_now - DK_BASE) / 10;</span><br><span class="line">            log_p-&gt;mintempcell = (mintempcell_now - DK_BASE) / 10;</span><br><span class="line">            log_p-&gt;maxtempcnt = maxtempcnt;</span><br><span class="line">            log_update_time();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 计算CRC校验值</span><br><span class="line">        for (i = LOG_DATA_START; i &lt; sizeof(LOG_T); i += 2) &#123;</span><br><span class="line">            wval = math_calc_crc16(*(uint16_t *)(log_mem + i), wval);</span><br><span class="line">        &#125;</span><br><span class="line">        log_p-&gt;checksum = wval;</span><br><span class="line">        </span><br><span class="line">        // 写入Flash</span><br><span class="line">        write_log_into_flash();</span><br><span class="line">        log_p-&gt;logindex++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 充电完成后更新自学习参数</span><br><span class="line">    if ((!charge_full_flag &amp;&amp; (sbsif_get_data(SBS16_BATTSTATUS) &amp; SBS16_FULLY_CHARGED)) || update_dfcc_flag) &#123;</span><br><span class="line">        if (log_check_update_condition()) &#123;</span><br><span class="line">            log_update_dfcc_data();</span><br><span class="line">            log_update_charge_fcc_data();</span><br><span class="line">            log_update_discharge_offset();</span><br><span class="line">        &#125;</span><br><span class="line">        update_dfcc_flag = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化数据类型"><a href="#持久化数据类型" class="headerlink" title="持久化数据类型"></a>持久化数据类型</h3><p>（1）基本电池信息日志</p>
<p>由LOG_T结构体存储，包含：<br>电池容量老化历史<br>电压电流温度极值记录<br>各温度区间使用时间统计<br>这些数据用于追踪电池使用历史和健康状态。</p>
<p>（2）放电容量动态学习表(DFCC)</p>
<p>DFCC表存储了不同温度和电流条件下的放电容量校正因子，用于提高电量计算精度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void log_update_dfcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态放电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_dsg_enable)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 擦除Flash页</span><br><span class="line">    eflash_erase_page(PAGE_DEFCC_START);</span><br><span class="line">    </span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)DFCC_table, sizeof(DFCC_table));</span><br><span class="line">    </span><br><span class="line">    // 写入CRC校验值</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, 0, 4, (uint8_t *)&amp;wval);</span><br><span class="line">    </span><br><span class="line">    // 写入DFCC表</span><br><span class="line">    eflash_mem_to_flashEX(PAGE_DEFCC_START, 4, sizeof(DFCC_table), (uint8_t *)DFCC_table);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）充电容量动态学习表(CFCC)</p>
<p>充电FCC表记录了不同温度和电流条件下的充电容量校正数据，用于优化充电过程中的电量计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void log_update_charge_fcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态充电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_chg_enable)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)charge_fcc_data, sizeof(charge_fcc_data));</span><br><span class="line">    </span><br><span class="line">    // 写入CRC校验值</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_CHARGE_FCC_OFFSET, 4, (uint8_t *)&amp;wval);</span><br><span class="line">    </span><br><span class="line">    // 写入充电FCC表</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_CHARGE_FCC_OFFSET + 4, sizeof(charge_fcc_data), (uint8_t *)charge_fcc_data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）放电偏移量表</p>
<p>放电偏移量表存储了不同条件下的放电偏移校正值，用于补偿放电过程中的误差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void log_update_discharge_offset(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态放电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_dsg_enable)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)discharge_offset, sizeof(discharge_offset));</span><br><span class="line">    </span><br><span class="line">    // 组装数据</span><br><span class="line">    fn_memcpy(log_buf, &amp;wval, 4);</span><br><span class="line">    fn_memcpy(log_buf + 4, discharge_offset, sizeof(discharge_offset));</span><br><span class="line">    </span><br><span class="line">    // 写入放电偏移量表</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_DISCHARGE_OFFSET_OFFSET, 12, (uint8_t *)log_buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化的应用"><a href="#持久化的应用" class="headerlink" title="持久化的应用"></a>持久化的应用</h3><p>（1）电池电量计算精度提升</p>
<p>问题：电池在不同温度、电流条件下的容量会有显著差异，使用固定参数难以保证准确性。<br>解决方案：通过日志模块记录DFCC表和充电FCC表，实现动态学习和参数调整。</p>
<p>数据收集：<br>充放电过程中记录温度、电流等参数<br>完整放电&#x2F;充电周期后计算实际容量<br>参数更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (log_check_update_condition()) &#123;</span><br><span class="line">    log_update_dfcc_data();</span><br><span class="line">    log_update_charge_fcc_data();</span><br><span class="line">    log_update_discharge_offset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用算法：<br>电量计根据当前温度和电流查表获取校正因子<br>应用校正因子调整容量计算</p>
<p>（2）电池健康状态监测</p>
<p>问题：需要监控电池寿命周期内的健康状态变化，为用户提供电池健康程度的指导。<br>解决方案：利用日志模块的极值记录功能。</p>
<p>极值记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &gt; vmaxcell1_now)</span><br><span class="line">    vmaxcell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line"></span><br><span class="line">// 定期持久化</span><br><span class="line">log_p-&gt;vmaxcell1 = vmaxcell1_now;</span><br></pre></td></tr></table></figure>

<p>健康评估：<br>分析电压极值分布判断是否过充&#x2F;过放<br>通过温度极值记录判断是否经历过高&#x2F;低温<br>基于充放电电流极值评估是否有过大电流冲击</p>
<p>容量衰减追踪：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_p-&gt;historiage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_agemah;</span><br></pre></td></tr></table></figure>

<p>（3）断电数据保护</p>
<p>问题：电池管理系统断电后会丢失当前的电量计算参数和状态。<br>解决方案：关键参数的持久化存储与恢复。</p>
<p>状态保存：<br>定期或在特定事件（如充满电）时保存电量计算状态<br>包括当前电量(RC)、最大容量(FCC)、学习参数等</p>
<p>上电恢复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 启动时恢复数据</span><br><span class="line">if (wval == log_p-&gt;checksum) &#123;</span><br><span class="line">    // CRC校验通过，同步数据</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_historiage = log_p-&gt;historiage;</span><br><span class="line">    vmaxcell1_now = log_p-&gt;vmaxcell1;</span><br><span class="line">    // ...其他数据恢复</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 恢复学习参数</span><br><span class="line">recover_dfcc_data();</span><br></pre></td></tr></table></figure>

<p>（4）Flash寿命管理</p>
<p>考虑到Flash的有限擦写次数，系统采取了以下策略：<br>只在必要时（极值变化、定时更新）写入数据<br>使用日志循环写入机制，平均分布擦写压力</p>
<h2 id="状态机（State-Machine）"><a href="#状态机（State-Machine）" class="headerlink" title="状态机（State Machine）"></a>状态机（State Machine）</h2><p>TODO</p>
<h1 id="Part3：电量算法模块"><a href="#Part3：电量算法模块" class="headerlink" title="Part3：电量算法模块"></a>Part3：电量算法模块</h1><h2 id="OCV-table"><a href="#OCV-table" class="headerlink" title="OCV table"></a>OCV table</h2><p>OCV表在lib_fg.c中的确实应用主要集中在：<br>系统初始化时的SOC确定<br>静置状态下的SOC校正<br>电压与SOC之间的转换计算<br>反向查询电压</p>
<p>（1）fg_init_soc函数：用于初始化SOC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static FG_ERROR_T fg_init_soc(FG_HANDLE_T *handle, short volt, short curr, short cellthm)</span><br><span class="line">&#123;</span><br><span class="line">    short soc = 0;</span><br><span class="line">    // 使用OCV表估算初始SOC</span><br><span class="line">    if (lut_soc_by_ocv(handle, volt, &amp;soc) != ERR_FG_NO_ERROR)</span><br><span class="line">        return ERR_FG_LUT_ERROR;</span><br><span class="line">    // ...设置初始SOC及库仑计数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）fg_idle_process函数：静置状态下的SOC校正</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static FG_ERROR_T fg_idle_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // ...在静置条件下</span><br><span class="line">    // 使用OCV表估算SOC并进行校正</span><br><span class="line">    if (lut_soc_by_ocv(handle, tmp_volt, &amp;ocv_soc) == ERR_FG_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        // ...根据OCV表估算结果校正SOC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）lut_soc_by_ocv函数本身：OCV查表获取SOC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static FG_ERROR_T lut_soc_by_ocv(FG_HANDLE_T *handle, int volt, short *soc)</span><br><span class="line">&#123;</span><br><span class="line">    // 实现查表逻辑，根据电压和温度获取SOC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）使用OCV表反向查询电压</p>
<p>lib_fg.c中的lut_ocv_by_soc函数提供了OCV表的反向查询能力，用于预测特定SOC点的电压：</p>
<p>在以下场景有应用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int fg_time_estimation(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    short eod_ocv = 0;</span><br><span class="line">    int time_to_empty = 0;</span><br><span class="line"></span><br><span class="line">    // 预测放电终止点的OCV</span><br><span class="line">    if (lut_ocv_by_soc(handle, 0, &amp;eod_ocv) == ERR_FG_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        // 根据当前电压与终止电压的差距，以及当前放电速率，估算剩余时间</span><br><span class="line">        int voltage_drop = param-&gt;volt_lo_mv - eod_ocv;</span><br><span class="line">        int discharge_rate = voltage_drop * 3600 / ((LIB_FG_TYPE_T*)handle)-&gt;bat_avg_rate;</span><br><span class="line">        </span><br><span class="line">        time_to_empty = ((LIB_FG_TYPE_T*)handle)-&gt;cc_prv * 3600 / </span><br><span class="line">                        (param-&gt;current_ma * discharge_rate / 100);</span><br><span class="line">        </span><br><span class="line">        ((LIB_FG_TYPE_T*)handle)-&gt;time_to_empty = time_to_empty;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RC-table"><a href="#RC-table" class="headerlink" title="RC table"></a>RC table</h2><p>RC表是一个三维查找表，存储了电池在不同电压、电流和温度条件下电池内阻相关的容量校正因子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// RC表的查询实现</span><br><span class="line">// 输入电压、电流、温度，输出RC值</span><br><span class="line">static FG_ERROR_T lut_rc_f(FG_HANDLE_T *handle, short volt, short curr, short temp, short *output)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查输入参数有效性</span><br><span class="line">    // 可能会对电流取绝对值</span><br><span class="line"></span><br><span class="line">    // 使用三维表查询函数获取RC值</span><br><span class="line">    // 可能调用三线性插值函数</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR; // 成功返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RC表的应用"><a href="#RC表的应用" class="headerlink" title="RC表的应用"></a>RC表的应用</h3><p>RC表在fg_update中的应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FG_ERROR_T fg_update(FG_HANDLE_T *handle, FG_PARAM_T *param, FG_RESULT_T *result)</span><br><span class="line">&#123;</span><br><span class="line">    // 更新电池状态</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 在这里调用lut_rc_f获取RC值</span><br><span class="line">    </span><br><span class="line">    // 将RC值填充到结果结构体中</span><br><span class="line">    result-&gt;rc = ((LIB_FG_TYPE_T *)handle)-&gt;rc;</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在放电过程中的应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在fg_mobile_discharge_process函数中，RC表用于调整放电容量估计</span><br><span class="line"></span><br><span class="line">static FG_ERROR_T fg_mobile_discharge_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 放电处理逻辑</span><br><span class="line">    </span><br><span class="line">    // 在这里调用lut_rc_f获取放电条件下的RC值</span><br><span class="line">    // 使用RC值调整容量估计</span><br><span class="line">    </span><br><span class="line">    // 更新内部状态</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在充电过程中的应用</p>
<p>在fg_mobile_charge_process函数中，RC表用于调整充电容量估计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static FG_ERROR_T fg_mobile_charge_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 充电处理逻辑</span><br><span class="line"></span><br><span class="line">    // 在这里调用lut_rc_f获取充电条件下的RC值</span><br><span class="line">    // 使用RC值调整容量估计</span><br><span class="line">    </span><br><span class="line">    // 更新内部状态</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在时间预估中的应用：</p>
<p>用于fg_time_estimation函数中，影响剩余时间计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int fg_time_estimation(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 在这里间接调用lut_rc_f获取的RC值</span><br><span class="line">    // 使用RC值调整剩余时间计算</span><br><span class="line">    </span><br><span class="line">    // 计算并更新time_to_empty或time_to_full</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在SOH计算中的应用：</p>
<p>在soh_update函数中用于电池健康状态评估：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void soh_update(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 在这里调用lut_rc_f获取标准条件下的RC值</span><br><span class="line">    // 使用RC值参与SOH计算</span><br><span class="line">   </span><br><span class="line">    // 更新SOH值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RC表小结"><a href="#RC表小结" class="headerlink" title="RC表小结"></a>RC表小结</h3><p>RC与电池内阻：</p>
<p>RC表代表以下含义：<br>在放电过程中：RC表值较大表示内阻小、可用容量高；RC表值较小表示内阻大、可用容量低<br>在低温条件下：RC表值会降低，反映低温对容量的不利影响<br>在大电流条件下：RC表值会降低，反映大电流放电对有效容量的减少<br>在电池老化后：RC表配合SOH机制，反映容量衰减</p>
<p>因为温度和负载情况(电流大小)都会最终反映到锂电池内阻上，RC表的容量值变化实际是与电池内阻相关：<br>IR压降补偿：<br>估算负载下的电压损失<br>计算实际OCV(开路电压)<br>提高电量估算精度</p>
<p>容量校正：<br>调整电池在不同条件下的实际可用容量<br>考虑温度和电流对容量的影响</p>
<p>放电终点预测：<br>根据内阻预测不同负载下的放电终止点<br>提高剩余时间估算精度</p>
<p>RC表在实际应用中的一般流程：</p>
<p>获取实时数据：读取电池电压、电流和温度<br>查询RC表：调用lut_rc_f函数，获取当前条件下的RC值<br>容量调整：根据RC值调整FCC(满充容量)和CC(当前容量)<br>SOC计算：基于调整后的容量计算SOC<br>结果输出：将RC值和其他计算结果返回给系统</p>
<h2 id="DFCC-table"><a href="#DFCC-table" class="headerlink" title="DFCC table"></a>DFCC table</h2><h3 id="DFCC表的配置与初始化"><a href="#DFCC表的配置与初始化" class="headerlink" title="DFCC表的配置与初始化"></a>DFCC表的配置与初始化</h3><p>默认数据结构和初始值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 表的维度定义</span><br><span class="line">#define DFCC_X 11  // SOC轴</span><br><span class="line">#define DFCC_Y 3   // 电流轴  </span><br><span class="line">#define DFCC_Z 4   // 温度轴</span><br><span class="line"></span><br><span class="line">// 各轴的数据范围</span><br><span class="line">const short DFCC_XDATA[DFCC_X] = &#123;500, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000&#125;; // SOC: 5%-100%</span><br><span class="line">const short DFCC_YDATA[DFCC_Y] = &#123;600, 1500, 3000&#125;;  // 电流: 600mA-3000mA</span><br><span class="line">const short DFCC_ZDATA[DFCC_Z] = &#123;-100, 0, 250, 550&#125;; // 温度: -10°C到55°C</span><br><span class="line"></span><br><span class="line">// DFCC表数据结构</span><br><span class="line">short DFCC_table[DFCC_Y * DFCC_Z][DFCC_X];  // 3D查找表</span><br></pre></td></tr></table></figure>

<p>使用前的初始化：</p>
<p>从main.c中的代码片段可以看到DFCC表是作为查找表(lut)的一部分进行初始化的：</p>
<p>这段代码配置了一个三维查找表结构(tbl_three_t)，包含：<br>轴点数量：x_num, y_num, z_num<br>轴数据指针：p_x_start, p_y_start, p_z_start<br>表数据指针：p_data_start</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lut.dfcc_tbl.x_num = DFCC_X;</span><br><span class="line">lut.dfcc_tbl.y_num = DFCC_Y;</span><br><span class="line">lut.dfcc_tbl.z_num = DFCC_Z;</span><br><span class="line">lut.dfcc_tbl.p_x_start = (short *)DFCC_XDATA;</span><br><span class="line">lut.dfcc_tbl.p_y_start = (short *)DFCC_YDATA;</span><br><span class="line">lut.dfcc_tbl.p_z_start = (short *)DFCC_ZDATA;</span><br><span class="line">lut.dfcc_tbl.p_data_start = (short *)DFCC_table;</span><br></pre></td></tr></table></figure>

<p>查找表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int     x_num;              // X轴点数</span><br><span class="line">    int     y_num;              // Y轴点数</span><br><span class="line">    int     z_num;              // Z轴点数</span><br><span class="line">    short*  p_x_start;          // X轴数据起始指针</span><br><span class="line">    short*  p_y_start;          // Y轴数据起始指针</span><br><span class="line">    short*  p_z_start;          // Z轴数据起始指针</span><br><span class="line">    short*  p_data_start;       // 表数据起始指针</span><br><span class="line">&#125; tbl_three_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    tbl_read_t  readfunc;       // 表读取函数</span><br><span class="line">    tbl_one_t   thm_tbl;        // 温度表信息</span><br><span class="line">    tbl_one_t   ocv_tbl;        // OCV表信息</span><br><span class="line">    tbl_three_t rc_tbl;         // RC表信息</span><br><span class="line">    tbl_three_t dfcc_tbl;       // DFCC表信息</span><br><span class="line">&#125; FG_LUT_T;</span><br></pre></td></tr></table></figure>

<h3 id="lut-dfcc-f查表函数"><a href="#lut-dfcc-f查表函数" class="headerlink" title="lut_dfcc_f查表函数"></a>lut_dfcc_f查表函数</h3><p>定义DFCC table为宏DDTABLE </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DDTABLE ((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.dfcc_tbl.p_data_start</span><br></pre></td></tr></table></figure>

<p>在放电处理流程内调用lut_dfcc_f查表，过程：</p>
<p>a) 输入参数限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SOC限制</span><br><span class="line">if (soc &lt; XDTABLE[0]) &#123;</span><br><span class="line">    soc = XDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (soc &gt; XDTABLE[XDNUM - 1]) &#123;</span><br><span class="line">    soc = XDTABLE[XDNUM - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电流限制</span><br><span class="line">if (curr &lt; YDTABLE[0]) &#123;</span><br><span class="line">    curr = YDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (curr &gt; YDTABLE[YDNUM - 1]) &#123;</span><br><span class="line">    curr = YDTABLE[YDNUM - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 温度限制</span><br><span class="line">if (temp &lt; ZDTABLE[0]) &#123;</span><br><span class="line">    temp = ZDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (temp &gt; ZDTABLE[ZDNUM - 1]) &#123;</span><br><span class="line">    temp = ZDTABLE[ZDNUM - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b) 索引查找：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 查找SOC对应的索引</span><br><span class="line">for (IDX = 1; IDX &lt; XDNUM; IDX++) &#123;</span><br><span class="line">    if ((XDTABLE[IDX-1] &lt;= soc) &amp;&amp; (XDTABLE[IDX] &gt; soc)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找电流对应的索引</span><br><span class="line">for (IDY = 1; IDY &lt; YDNUM; IDY++) &#123;</span><br><span class="line">    if ((YDTABLE[IDY-1] &lt;= curr) &amp;&amp; (YDTABLE[IDY] &gt; curr)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找温度对应的索引</span><br><span class="line">for (IDZ = 1; IDZ &lt; ZDNUM; IDZ++) &#123;</span><br><span class="line">    if ((ZDTABLE[IDZ-1] &lt;= temp) &amp;&amp; (ZDTABLE[IDZ] &gt; temp)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c) 三线性插值计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// X轴(SOC)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    XFRACS = 1 * 100;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    XFRACS = fg_idiv(handle, (soc - STMP) * 100, (SVAL - STMP));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Y轴(电流)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    YFRAC = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    YFRAC = (SVAL - STMP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Z轴(温度)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    ZFRAC = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ZFRAC = (SVAL - STMP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFCC与动态容量"><a href="#DFCC与动态容量" class="headerlink" title="DFCC与动态容量"></a>DFCC与动态容量</h3><p>放电流程中查找RC table后继续查找DFCC table，动态修改FCC容量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error = lut_dfcc_f(*handle*, ((LIB_FG_TYPE_T *)*handle*)-&gt;rsoc_now, -curr_now, *param*-&gt;cellthm, (*short* *)&amp;dfcc_comp);</span><br><span class="line"></span><br><span class="line">rca_prv = (fg_idiv(*handle*, tmp_soh_mah, ((LIB_FG_TYPE_T *)*handle*)-&gt;rsoc_now) * dfcc_comp) / 10000;</span><br><span class="line"></span><br><span class="line">((LIB_FG_TYPE_T *)*handle*)-&gt;fcc = rca_prv;</span><br></pre></td></tr></table></figure>

<h2 id="查表函数的插值原理"><a href="#查表函数的插值原理" class="headerlink" title="查表函数的插值原理"></a>查表函数的插值原理</h2><p>RC table和DFCC table都是三维查表函数，是离散点。而电量计检测到的温度电流电压soc等数据是连续点。因此需要三维插值去处理连续点无法在离散表中查询到的情况。</p>
<p>三线性插值是一种在三维空间中进行插值的技术，它基于周围8个已知点的值来估计任意位置的值。整个过程分三步：</p>
<ol>
<li><p>X方向插值：对Z和Y固定，在X方向上插值得到4个点</p>
</li>
<li><p>Y方向插值：对这4个点在Y方向上插值得到2个点</p>
</li>
<li><p>Z方向插值：对这2个点在Z方向上插值得到最终结果</p>
</li>
</ol>
<p>插值公式：</p>
<p>!V &#x3D; V_{000}(1-x)(1-y)(1-z) + V_{100}x(1-y)(1-z) + V_{010}(1-x)y(1-z) + V_{110}xy(1-z) + V_{001}(1-x)(1-y)z + V_{101}x(1-y)z + V_{011}(1-x)yz + V_{111}xyz</p>
<p>其中x, y, z是归一化的坐标（范围0到1）。</p>
<p>以下是示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">int lut_three_latitude(tbl_three_t *p_tbl, short x, short y, short z, short *result)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int x_idx, y_idx, z_idx;</span><br><span class="line">    float fx[2], fy[2], fz[2];  // 插值权重</span><br><span class="line">    float tmp_xyz[8];           // 八个顶点的值</span><br><span class="line">    float tmp_xy[4];            // 四条边的插值结果</span><br><span class="line">    float tmp_x[2];             // 两个面的插值结果</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 查找X轴索引并计算插值权重</span><br><span class="line">    x_idx = find_table_index(p_tbl-&gt;p_x_start, p_tbl-&gt;x_num, x);</span><br><span class="line">    if (x_idx &lt; 0) return -1;</span><br><span class="line">    if (x_idx == p_tbl-&gt;x_num - 1) &#123;</span><br><span class="line">        fx[0] = 1.0f; fx[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fx[1] = (float)(x - p_tbl-&gt;p_x_start[x_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_x_start[x_idx+1] - p_tbl-&gt;p_x_start[x_idx]);</span><br><span class="line">        fx[0] = 1.0f - fx[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 查找Y轴索引并计算插值权重</span><br><span class="line">    y_idx = find_table_index(p_tbl-&gt;p_y_start, p_tbl-&gt;y_num, y);</span><br><span class="line">    if (y_idx &lt; 0) return -1;</span><br><span class="line">    if (y_idx == p_tbl-&gt;y_num - 1) &#123;</span><br><span class="line">        fy[0] = 1.0f; fy[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fy[1] = (float)(y - p_tbl-&gt;p_y_start[y_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_y_start[y_idx+1] - p_tbl-&gt;p_y_start[y_idx]);</span><br><span class="line">        fy[0] = 1.0f - fy[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 查找Z轴索引并计算插值权重</span><br><span class="line">    z_idx = find_table_index(p_tbl-&gt;p_z_start, p_tbl-&gt;z_num, z);</span><br><span class="line">    if (z_idx &lt; 0) return -1;</span><br><span class="line">    if (z_idx == p_tbl-&gt;z_num - 1) &#123;</span><br><span class="line">        fz[0] = 1.0f; fz[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fz[1] = (float)(z - p_tbl-&gt;p_z_start[z_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_z_start[z_idx+1] - p_tbl-&gt;p_z_start[z_idx]);</span><br><span class="line">        fz[0] = 1.0f - fz[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取周围8个点的值</span><br><span class="line">    for (k = 0; k &lt; 2 &amp;&amp; (z_idx + k) &lt; p_tbl-&gt;z_num; k++) &#123;</span><br><span class="line">        for (j = 0; j &lt; 2 &amp;&amp; (y_idx + j) &lt; p_tbl-&gt;y_num; j++) &#123;</span><br><span class="line">            for (i = 0; i &lt; 2 &amp;&amp; (x_idx + i) &lt; p_tbl-&gt;x_num; i++) &#123;</span><br><span class="line">                int data_idx = (z_idx + k) * (p_tbl-&gt;y_num * p_tbl-&gt;x_num) + </span><br><span class="line">                               (y_idx + j) * p_tbl-&gt;x_num + (x_idx + i);</span><br><span class="line">                tmp_xyz[k*4 + j*2 + i] = (float)p_tbl-&gt;p_data_start[data_idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿X轴插值，得到4个边的值</span><br><span class="line">    for (k = 0; k &lt; 2; k++) &#123;</span><br><span class="line">        for (j = 0; j &lt; 2; j++) &#123;</span><br><span class="line">            tmp_xy[k*2 + j] = tmp_xyz[k*4 + j*2] * fx[0] + tmp_xyz[k*4 + j*2 + 1] * fx[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿Y轴插值，得到2个面的值</span><br><span class="line">    for (k = 0; k &lt; 2; k++) &#123;</span><br><span class="line">        tmp_x[k] = tmp_xy[k*2] * fy[0] + tmp_xy[k*2 + 1] * fy[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿Z轴插值，得到最终结果</span><br><span class="line">    *result = (short)(tmp_x[0] * fz[0] + tmp_x[1] * fz[1]);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过三线性插值，系统能够在RC表&#x2F;DFCC表的离散数据点之间生成平滑的过渡值，这带来以下优势：</p>
<ol>
<li><p>平滑过渡：避免在临界点附近出现电量跳变</p>
</li>
<li><p>精细粒度：无需为每个可能的条件定义离散值，大幅减少表的大小</p>
</li>
<li><p>处理边界条件：即使输入参数超出表定义范围，也能提供合理的边界值</p>
</li>
<li><p>适用性广：同一表格可用于各种电池和工作条件</p>
</li>
</ol>
<p>一个插值示例：</p>
<p>场景：电池在-5°C环境下以1500mA电流放电，SOC为25%。</p>
<p>插值过程：</p>
<ol>
<li>温度在-10°C(DFCC_ZDATA[0]&#x3D;-100)和0°C(DFCC_ZDATA[1]&#x3D;0)之间</li>
</ol>
<ul>
<li>温度插值权重：fz[0]&#x3D;0.5, fz[1]&#x3D;0.5</li>
</ul>
<ol>
<li>电流在1000mA(DFCC_YDATA[1])和2000mA(DFCC_YDATA[2])之间</li>
</ol>
<ul>
<li>电流插值权重：fy[0]&#x3D;0.5, fy[1]&#x3D;0.5</li>
</ul>
<ol>
<li>SOC在10%(DFCC_XDATA[1]&#x3D;1000)和30%(DFCC_XDATA[2]&#x3D;3000)之间</li>
</ol>
<ul>
<li>SOC插值权重：fx[0]&#x3D;0.75, fx[1]&#x3D;0.25</li>
</ul>
<p>计算过程：</p>
<ul>
<li><p>获取8个顶点值：</p>
</li>
<li><p>V000 &#x3D; DFCC_table[0<em>3+1][1] &#x3D; 88（-10°C, 1000mA, 10%SOC）</em></p>
</li>
<li><p>V001 &#x3D; DFCC_table[1<em>3+1][1] &#x3D; 85（0°C, 1000mA, 10%SOC）</em></p>
</li>
<li><p>V010 &#x3D; DFCC_table[0<em>3+2][1] &#x3D; 60（-10°C, 2000mA, 10%SOC）</em></p>
</li>
<li><p>V011 &#x3D; DFCC_table[1<em>3+2][1] &#x3D; 75（0°C, 2000mA, 10%SOC）</em></p>
</li>
<li><p>V100 &#x3D; DFCC_table[0<em>3+1][2] &#x3D; 90（-10°C, 1000mA, 30%SOC）</em></p>
</li>
<li><p>V101 &#x3D; DFCC_table[1<em>3+1][2] &#x3D; 85（0°C, 1000mA, 30%SOC）</em></p>
</li>
<li><p>V110 &#x3D; DFCC_table[0<em>3+2][2] &#x3D; 75（-10°C, 2000mA, 30%SOC）</em></p>
</li>
<li><p>V111 &#x3D; DFCC_table[1<em>3+2][2] &#x3D; 75（0°C, 2000mA, 30%SOC）</em></p>
</li>
<li><p>应用三线性插值公式计算最终值（简化计算）：</p>
</li>
<li><p>X方向插值（SOC）：</p>
</li>
<li><p>tmp_xy[0] &#x3D; 88<em>0.75 + 90</em>0.25 &#x3D; 88.5</p>
</li>
<li><p>tmp_xy[1] &#x3D; 60<em>0.75 + 75</em>0.25 &#x3D; 63.75</p>
</li>
<li><p>tmp_xy[2] &#x3D; 85<em>0.75 + 85</em>0.25 &#x3D; 85</p>
</li>
<li><p>tmp_xy[3] &#x3D; 75<em>0.75 + 75</em>0.25 &#x3D; 75</p>
</li>
<li><p>Y方向插值（电流）：</p>
</li>
<li><p>tmp_x[0] &#x3D; 88.5<em>0.5 + 63.75</em>0.5 &#x3D; 76.125</p>
</li>
<li><p>tmp_x[1] &#x3D; 85<em>0.5 + 75</em>0.5 &#x3D; 80</p>
</li>
<li><p>Z方向插值（温度）：</p>
</li>
<li><p>result &#x3D; 76.125<em>0.5 + 80</em>0.5 &#x3D; 78.06</p>
</li>
</ul>
<p>最终校正因子约为78.06%，表示在-5°C、1500mA放电电流和25% SOC条件下，电池实际可用容量约为标称容量的78.06%。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--Cobra%E5%BE%AA%E7%8E%AF%E4%BB%AA%E7%94%B5%E6%B1%A0%E5%8C%85%E7%9A%84%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--Cobra%E5%BE%AA%E7%8E%AF%E4%BB%AA%E7%94%B5%E6%B1%A0%E5%8C%85%E7%9A%84%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">电量计 -- Cobra/循环仪/电池包的测试环境说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 11:51:39" itemprop="dateModified" datetime="2025-11-18T11:51:39+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E9%87%8F%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">电量计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计–Cobra-循环仪-电池包的测试环境说明"><a href="#电量计–Cobra-循环仪-电池包的测试环境说明" class="headerlink" title="电量计–Cobra&#x2F;循环仪&#x2F;电池包的测试环境说明"></a>电量计–Cobra&#x2F;循环仪&#x2F;电池包的测试环境说明</h1><p>以Newton FW项目(77561, 77226)为例，介绍cobra工具配合客户环境电池包的使用。</p>
<p>客户环境指：电量计内置在电池包，通信接口只有I2C，不支持串口调试和Jtag下载FW；而开发环境的电量计是独立开发板，支持串口打印和Jtag下载。</p>
<p>在实验室环境：使用Chroma循环仪模拟真实的客户Charger，对电量计和电池系统充放电测试，用cobra配置电量计FW和参数并采集数据，调试客户遇到的问题。</p>
<h2 id="Cobra编辑和下载project文件"><a href="#Cobra编辑和下载project文件" class="headerlink" title="Cobra编辑和下载project文件"></a>Cobra编辑和下载project文件</h2><ol>
<li><p>启动项目匹配的Cobra shell版本，加载项目oce文件</p>
<p>cobra shell是程序启动器，版本号在 About查看，目前使用1.01.19版本</p>
<p>oce是cobra功能文件，决定具体项目支持的功能，不同项目的oce不同；oce分为X版本和Y版本，X为发布给用户使用版本，Y仅用于内部Debug。</p>
<p>下图在Extension Manager中select SD77226SBS_X_20250315.oce，oce路径在COBRA\Extensions</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191558616.png" alt="img"></p>
<ol start="2">
<li>（对于Newton项目）加载prj</li>
</ol>
<p>prj文件(project)是cobra对Newton FW bin和Flash参数文件xml（parameter_newton，OCV table， RCtable，user_setting）的打包。</p>
<p>加载prj后默认显示newton FW bin：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191608196.png" alt="img"></p>
<p>加载prj后可查看(show)参数：根据电池规格书配置Design Capacity容量，Limited Charge Voltage电压等参数；根据常温和高低温需求配置CC转CV的电压值(Constant Current切换的Constant Voltage转折点)的电压值和温度阈值。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191613694.png" alt="image-20250319161351611"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191614471.png" alt="image-20250319161401395"></p>
<p>OCV(Open Circuit Voltage) table和RC(Remaining Capacity) table都是根据具体电池实测的电池数据，一般不会更改（除非测试数据有问题或者更换电池）。</p>
<p>以RC table为例，数组对应关系如下同颜色的标号</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191635013.png" alt="image-20250319163556911"></p>
<p><strong>关于RC table：</strong></p>
<p>RC table反映的是在不同环境下的充放电过程中的电压和剩余容量的对应关系。</p>
<p>RC table的采集方法是对电池放电（从满电以恒流放到截止电压），在不同温度下，用不同电流放电，分别采集到电池输出电压和电池剩余容量的关系。</p>
<p>为什么RC table是采集放电过程而不是充电过程：（可能）是因为放电过程可以保持恒流，如果采集充电过程，充电CC-CV阶段开始后电流会降低，破坏了恒定电流值的要求。</p>
<p>为什么RC table要考虑问题温度和电流：锂电池特性决定，温度影响锂电池的放电容量，温度降低，电池内阻加大，电池放电容量下降；温度过高有风险，有时应用上需要调低满电容量。电流实际能反映负载的分压，由于电池开路电压一定，电池内置在某时刻一定，那么电池带负载时输出电流越大说明外部负载电阻小，大电流放电，电池内阻导致的压降更多，放电到截止电压就会提前到来，满电对应的输出电压也不一样，最终反映到RC table。</p>
<p><strong>关于OCV table：</strong></p>
<p>OCV table反映的是电池开路(非充放电)状态下的电压和剩余容量的对应关系。</p>
<p>严格的OCV table应该是用极小的电流放电采集容量变化。小电流说明负载电阻极大，可以近似开路环境。但这种采集时间太长，一般没搞。</p>
<p>项目实际用的OCV table是RC table采集过程中提取出来的数据，会有误差。</p>
<p>对于电量计FW，OCV table一般用于电池在持续Idle&#x2F;sleep状态下查询剩余容量，因为此时没有电流，只能靠电压查询。</p>
<p>充放电过程中查询容量主要使用RC table，初始充电时也会参考OCV table。</p>
<p><strong>关于电量计计算SOC（State-of-charge）是否符合标准的判定方法：</strong></p>
<p>SOC（State-of-charge）可以简单理解成剩余电荷容量（RC）占满充总容量(FCC，Full Charge Capacity)的百分比[0 ~ 100]</p>
<p>理论上，电量计应该在每个时刻都反映精确的剩余容量百分比，但很难做到（原因？？？？）</p>
<p>项目的SOC算法的目标：</p>
<p>(1) 应用层目标：在充电达到截止电流时，SOC要报100；在放电达到截止电压时，SOC要报0。SOC误差 &lt; 3%</p>
<p>(2) 基于(1)的两个测试标准，如果FW只靠RC table和OCV table计算SOC，可能不能达到要求。因此SOC算法添加了追赶机制：</p>
<p>当充电进入CV阶段恒流升压转恒压降流，SOC算法可能会开启SOC追赶，确保电流达到截止时SOC能到100。CV过程的SOC并不能反映真实电量变化。</p>
<p>当放电接近截止电压，SOC算法可能会开启SOC追赶，确保达到截止电压时SOC能到0。这个过程的SOC也不能反映真实电量变化。</p>
<p>中间的过程SOC值主要来自RC table数据，SOC算法可能只做一些消抖平滑处理。</p>
<p>3.（对于Newton项目）下载prj到电量计芯片(ARM M0)的Flash</p>
<p>Full download下载当前prj内的所有bin和参数数据到电量计（通信方式是I2C）</p>
<p>4.（对于Newton项目）更新prj</p>
<p>如果FW bin需要修改，可以在当前prj界面open用KEIL MDK编译出的新newton_encript.bin，再save as新的prj</p>
<p>如果有参数需要修改，直接改参数，再save as新的prj</p>
<h2 id="Cobra使用SBS采集数据"><a href="#Cobra使用SBS采集数据" class="headerlink" title="Cobra使用SBS采集数据"></a>Cobra使用SBS采集数据</h2><h3 id="连接电量计"><a href="#连接电量计" class="headerlink" title="连接电量计"></a>连接电量计</h3><p>Bus setting选择port连接。使用o2link gen1 USB转I2C转接板(8051芯片)，需要先安装windows转接板驱动。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191930845.png" alt="img"></p>
<h3 id="初始界面"><a href="#初始界面" class="headerlink" title="初始界面"></a>初始界面</h3><p>默认可勾选查询哪些电量计信息，下方可切换页面到log信息页面</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191935049.png" alt="image-20250319193558973"></p>
<h3 id="开启调试内存GGMEM-（可选）"><a href="#开启调试内存GGMEM-（可选）" class="headerlink" title="开启调试内存GGMEM#（可选）"></a>开启调试内存GGMEM#（可选）</h3><p>GGMEM0~GGMEM8是Cobra查询电量计内存中指定RAM区域数据的接口，是Cobra环境监测电量计参数变化的主要手段。</p>
<p>选中FWVersion，Ctrl+ALT+Y输入密码888888，使能GGMEM0~GGMEM8</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191941173.png" alt="image-20250319194120118"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191943097.png" alt="image-20250319194304045"></p>
<h3 id="查看Cobra-log"><a href="#查看Cobra-log" class="headerlink" title="查看Cobra log"></a>查看Cobra log</h3><p>Cobra log是每秒发送一次之前勾选的SBS命令给电量计，查询电量计已获取的电池信息（电量计可能每秒轮询一次电池信息）。</p>
<p>主要关注电压(Battery Voltage)，外部温度(ETHM), 电流(Battery Current)和电量计算法输出的SOC容量（RSOC）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191945945.png" alt="image-20250319194542869"></p>
<h3 id="查看GGMEM"><a href="#查看GGMEM" class="headerlink" title="查看GGMEM"></a>查看GGMEM</h3><p>查看GGMEM0值</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192008717.png" alt="image-20250319200834671"></p>
<p>查看GGMEM7的值和Cobra参数设定一致（高温环境，EOC电压是4100mV，EOC电流是500）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192020659.png" alt="image-20250319202040571"></p>
<h3 id="详细了解ggmem的映射过程"><a href="#详细了解ggmem的映射过程" class="headerlink" title="详细了解ggmem的映射过程"></a>详细了解ggmem的映射过程</h3><p>GGMEM字段在电量计FW中的定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192014937.png" alt="image-20250319201430891"></p>
<p>GGMEM是如何从电量计RAM对应到Cobra SBS命令的：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192016127.png" alt="image-20250319201605094"></p>
<p>如果要打开更多GGMEM9显示到Cobra log，需要更新cobra oce支持新SBSD9_GGMEM9，修改FW新增绑定SBS SBSD9_GGMEM9 &#x3D; gg_mem[X]，X可以是任何偏移，不一定是72。</p>
<h2 id="Cobra电流校准"><a href="#Cobra电流校准" class="headerlink" title="Cobra电流校准"></a>Cobra电流校准</h2><p>更新新的prj到电量计后，有时候Cobra采集的电流和charger&#x2F;循环仪的真实电量不一致，需要calibration校准电流，分为3步：</p>
<p>0电流校准；3V充电校准；-3V放电校准。</p>
<p>先用循环仪设置对应的电流，再点击cobra calibrate按钮即可；分别校准3种电流情况之后，SBS log的电流误差应该会消除。</p>
<p>如果没有更新prj，校准过的数据无需再校准</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192035028.png" alt="image-20250319203521951"></p>
<h2 id="Cobra应用示例"><a href="#Cobra应用示例" class="headerlink" title="Cobra应用示例"></a>Cobra应用示例</h2><p>如下图是充电进入CV阶段的部分log，电压恒压，电流减少。但RSOC只有62%，后面算法应该会加速追赶，确保在达到满充（电流降到500）时SOC到100%</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192040622.png" alt="image-20250319204006543"></p>
<p>这是export log导出csv文件，用曲线图分析</p>
<h2 id="循环仪Chroma-17020的使用"><a href="#循环仪Chroma-17020的使用" class="headerlink" title="循环仪Chroma 17020的使用"></a>循环仪Chroma 17020的使用</h2><h3 id="选择充电和放电配方"><a href="#选择充电和放电配方" class="headerlink" title="选择充电和放电配方"></a>选择充电和放电配方</h3><p>选择1A恒流充电（CC_1A），勾选连接到电量计的通道1-3，可开始充电和停止充电。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201021090.png" alt="image-20250320102129025"></p>
<p>1A恒流放电（DS_1A）同理：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201023474.PNG" alt="img"></p>
<p>在Cobra电流校准时，使用CC_3A和DS_3A，启动充电和放电后，再点击Cobra校准。</p>
<h3 id="编辑充放电配方"><a href="#编辑充放电配方" class="headerlink" title="编辑充放电配方"></a>编辑充放电配方</h3><p>配方编辑器可查看现有的配方，也可以编辑和新增配方</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201024587.PNG" alt="img"></p>
<p>查看已有的CC_3A配方的具体设置：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201025579.PNG" alt="img"></p>
<p>CC转CV电压模式充电：</p>
<p>CC阶段恒流3A充电电压逐渐升高到4.53，之后开始CV阶段恒压4.53，电流从3A逐渐减少到截止电流0.12A停止；关闭所有过流保护。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201025475.PNG" alt="img"></p>
<p>查看DS_1A放电的配方设置：</p>
<p>恒流放电：</p>
<p>1A恒流放电，电压从4.xV左右逐渐降低到截止电压3V就停止；关闭所有过流保护。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201027970.PNG" alt="img">对于不同的电池测试需求，可以修改参数之后存储档案。</p>
<h3 id="新建充放电配方"><a href="#新建充放电配方" class="headerlink" title="新建充放电配方"></a>新建充放电配方</h3><p>可以配置“放电+静置+充电”的自动运行配方，方便自动测试</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201034525.PNG" alt="img"></p>
<h2 id="Cobra采集数据分析"><a href="#Cobra采集数据分析" class="headerlink" title="Cobra采集数据分析"></a>Cobra采集数据分析</h2><p>示例数据：<a target="_blank" rel="noopener" href="https://o2micro-my.sharepoint.com/:x:/p/thomas_hu/EftK5pMRry5HtS552GzuDRcBmb_yms6TSJNWoHF33muY4A?e=noJtCx">Scan_03_19_2025_11_44_14.csv</a></p>
<p>从放电快结束开始记录，静置，然后CC-CV充电到截止电流。</p>
<p>电压-电流曲线：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211526999.png" alt="image-20250321152603963"></p>
<p>比较真实电荷变化(mAh)和电量计评估的容量（RSOC）：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211528188.png" alt="image-20250321152851154"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211525757.png" alt="image-20250321152538723"></p>
<p><img src="C:\Users\cursorhu\AppData\Roaming\Typora\typora-user-images\image-20250321152447765.png" alt="image-20250321152447765"></p>
<h2 id="Cobra调试FW"><a href="#Cobra调试FW" class="headerlink" title="Cobra调试FW"></a>Cobra调试FW</h2><p>Y版本发指定SBS命令，格式参考FW代码和FW spec文档。</p>
<h3 id="SBS-F9打开串口、关闭串口"><a href="#SBS-F9打开串口、关闭串口" class="headerlink" title="SBS F9打开串口、关闭串口"></a>SBS F9打开串口、关闭串口</h3><p>串口测试环境必须要demo板子，电池包只有i2c不能看串口信息。测试环境如下</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081924569.png" alt="image-20250408192436055"></p>
<p>Cobra Y版本，发送 SBS F9 + 01 28，打开串口。 发送 SBS F9 + 01 29，关闭串口。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081918994.png" alt="image-20250408191814914"></p>
<h3 id="SBS51读高温次数和时间的数据"><a href="#SBS51读高温次数和时间的数据" class="headerlink" title="SBS51读高温次数和时间的数据"></a>SBS51读高温次数和时间的数据</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081931949.png" alt="image-20250408193124921"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--%E4%B8%B2%E5%8F%A3%EF%BC%9AUART%E5%92%8CUSB-COM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--%E4%B8%B2%E5%8F%A3%EF%BC%9AUART%E5%92%8CUSB-COM/" class="post-title-link" itemprop="url">STM32--串口：UART和USB-COM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:50:44" itemprop="dateModified" datetime="2025-11-18T10:50:44+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32/" itemprop="url" rel="index"><span itemprop="name">STM32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–串口：UART和USB-COM"><a href="#STM32–串口：UART和USB-COM" class="headerlink" title="STM32–串口：UART和USB-COM"></a>STM32–串口：UART和USB-COM</h1><p>背景描述：STM32板子有TTL UART连接下游IC，同时有USB口连接上游的上位机PC。</p>
<p>本文描述STM32如何直接使用UART通信，如何用USB CDC实现虚拟串口USB-COM也用UART通信。</p>
<h2 id="UART项目配置"><a href="#UART项目配置" class="headerlink" title="UART项目配置"></a>UART项目配置</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301153104.png" alt="image-20240430115304007"></p>
<h2 id="UART的轮询与中断"><a href="#UART的轮询与中断" class="headerlink" title="UART的轮询与中断"></a>UART的轮询与中断</h2><h2 id="USB的CDC类实现USB-COM"><a href="#USB的CDC类实现USB-COM" class="headerlink" title="USB的CDC类实现USB-COM"></a>USB的CDC类实现USB-COM</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417744.png" alt="image-20240430141713692"></p>
<h2 id="双串口的实现：UART和USB-COM"><a href="#双串口的实现：UART和USB-COM" class="headerlink" title="双串口的实现：UART和USB-COM"></a>双串口的实现：UART和USB-COM</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417818.png" alt="image-20240430141738799"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417518.png" alt="image-20240430141746453"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#Communications_Devices_Class_(CDC)">ST: Introduction to USB with STM32</a></p>
<p><a target="_blank" rel="noopener" href="https://controllerstech.com/send-and-receive-data-to-pc-without-uart-stm32-usb-com/">send-and-receive-data-to-pc-without-uart-stm32-usb-com</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/FBsharl/p/17847962.html">stm32：实现USB虚拟串口（CDC_VPC）</a></p>
<p><a target="_blank" rel="noopener" href="https://shequ.stmicroelectronics.cn/thread-637593-1-1.html">如何让CDC类USB设备批量接收64字节以上数据</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--Firmware%20Architecture%20part2%EF%BC%9ABMS%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AJEV323%E5%92%8CSkyways/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--Firmware%20Architecture%20part2%EF%BC%9ABMS%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AJEV323%E5%92%8CSkyways/" class="post-title-link" itemprop="url">STM32--Firmware Architecture part2：业务代码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:50:24" itemprop="dateModified" datetime="2025-11-18T10:50:24+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32/" itemprop="url" rel="index"><span itemprop="name">STM32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–Firmware-Architecture-part2：业务代码分析–o2link-FWs"><a href="#STM32–Firmware-Architecture-part2：业务代码分析–o2link-FWs" class="headerlink" title="STM32–Firmware Architecture part2：业务代码分析–o2link FWs"></a>STM32–Firmware Architecture part2：业务代码分析–o2link FWs</h1><h1 id="o2link-FWs的架构区别"><a href="#o2link-FWs的架构区别" class="headerlink" title="o2link FWs的架构区别"></a>o2link FWs的架构区别</h1><p>o2link FWs指三类：</p>
<ul>
<li>o2link original FW(gen2): 用于老项目的对外发布版FW</li>
<li>o2link JEV323 FW: 在o2link original FW上，针对JEV323做了功能改动和架构改动</li>
<li>o2link Skyways FW: 在o2link original FW上，针对Skyways做了功能改动</li>
</ul>
<h2 id="Bootloader和Firmware结构"><a href="#Bootloader和Firmware结构" class="headerlink" title="Bootloader和Firmware结构"></a>Bootloader和Firmware结构</h2><h3 id="bootloader和Firmware在Flash的分布"><a href="#bootloader和Firmware在Flash的分布" class="headerlink" title="bootloader和Firmware在Flash的分布"></a>bootloader和Firmware在Flash的分布</h3><ol>
<li>o2link original FW和o2link Skyways FW是分为bootloader和Firmware两部分，两者共同构成烧录的bin文件</li>
</ol>
<ul>
<li><p>bootloader：放在Flash的0x0800_0000 ~ 0x0x0800_8000空间，空间32KB；用作USB上位机烧录Firmware到Flash功能。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171036206.png" alt="image-20240517103655180"></p>
</li>
<li><p>Firmware: 放在Flash的0x0800_8000~ 0x0801_0000空间，空间32KB；用作处理USB上位机下发的各种控制、读写请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171037852.png" alt="image-20240517103700830"></p>
<p>bootloader和Firmware所有代码在Flash的分布如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171117725.png" alt="image-20240517111755697"></p>
<p>注意：ROM&#x2F;RAM空间分布对应到.sct的配置内容需要特别小心：</p>
<p>Bootloader的.sct:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00008000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00008000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x200000C0 0x00003F30  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Firmware的.sct: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08008000 0x00008000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08008000 0x00008000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x200000C0 0x00003F30  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有正确配置.sct, 例如把Firmware的.sct LR&#x2F;ER起始地址配成0x0800_0000,后面用JLink烧录时就报错：No Algorithm for 0x80000000~0x….，Flash program fail. 因为JLink发现program的地址和.sct指定的LR&#x2F;ER地址不一致。</p>
<p>2.o2link JEV323 FW是简化后的架构，只包含firmware部分，不支持USB上位机烧录FW bin：</p>
<ul>
<li><p>Firmware: 放在Flash的0x0800_0000~ 0x0801_0000空间，空间64KB；用作处理USB上位机下发的各种控制、读写请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171037152.png" alt="image-20240517103730129"></p>
</li>
</ul>
<p>3.RAM空间的分布</p>
<p>上面bootloader+FW架构的Keil配置中，bootloader和FW的RAM空间都是从0xC0偏移开始的，不是从RAM的0x00，</p>
<p>而单FW架构，FW是从RAM的0开始。</p>
<p>原因是bootloader跳转执行FW时，需要从Flash拷贝中断向量表192bytes(0xC0)到RAM起始地址，所以FW代码的RAM数据区不划分这块空间。详见direct_jump_to_app()</p>
<h3 id="IAP和ICP的概念"><a href="#IAP和ICP的概念" class="headerlink" title="IAP和ICP的概念"></a>IAP和ICP的概念</h3><p>为什么有两种代码结构分布？涉及到以下两种烧录Firmware的方式：参考STM32 RM0091文档</p>
<p>• IAP (in-application programming): IAP is the ability to re-program the flash memory of a microcontroller while the user program is running.</p>
<p>• ICP (in-circuit programming): ICP is the ability to program the flash memory of amicrocontroller using the JTAG protocol, the SWD protocol or the bootloader while thedevice is mounted on the user application board.</p>
<p>o2link作为成熟的产品，需要支持用户侧烧录firmware(IAP)，因此开发了USB接口的IAP烧录功能，这部分划分为bootloader。</p>
<blockquote>
<p>An important requirement for most Flash-memory-based systems is the ability to update firmware when installed in the end product. This ability is referred to as in-application programming (IAP).</p>
<p>The IAP code uses the USB to:</p>
<p>● Download a binary file from the USB HID to the STM32F0xx’s internal Flash memory.</p>
<p>● Upload the STM32F0xx’s internal Flash memory content (starting from the defined user </p>
<p>application address) into a binary file.</p>
<p>● Execute the user program.</p>
</blockquote>
<p>（实质上这不是真正意义的bootloader，仅仅是firmware update功能；如果firmware代码在SRAM运行，这部分功能完全可以做到Firmware代码中去，不用占用32KB空间）</p>
<p>jev323 firmware目前是内部测试用，因此不需要IAP，用Jlink的ICP方式烧录。全部Flash空间(64KB)可用于业务流程。</p>
<h3 id="bootloader和firmware的执行流程"><a href="#bootloader和firmware的执行流程" class="headerlink" title="bootloader和firmware的执行流程"></a>bootloader和firmware的执行流程</h3><p>参考o2link spec:</p>
<ul>
<li><p>bootloader基本逻辑是：每次上电RESET时，先执行bootloader判断当前Flash的firmware区域（app）有没有valid FW能执行？如果有，就跳转firmware的main去执行；如果没有，bootloader启动IAP流程，响应USB上位机的erase flash、program firmware的指令，完成以后再跳转执行firmware指令；</p>
</li>
<li><p>firmware在执行时，如果收到USB上位机的IAP命令(USB_IAP_JUMP_TO_BOOT)，就是要跳转到bootloader，准备IAP去下载新的firmware bin；其他情况不会跳转到bootloader。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171055206.png" alt="image-20240517105536135"></p>
<h2 id="bootloader代码分析（重要-难点）"><a href="#bootloader代码分析（重要-难点）" class="headerlink" title="bootloader代码分析（重要+难点）"></a>bootloader代码分析（重要+难点）</h2><p>整个bootloader代码和Firmware流程都是main初始化+While1轮询USB请求的结构，区别在于执行流程。</p>
<h3 id="bootloader校验FW"><a href="#bootloader校验FW" class="headerlink" title="bootloader校验FW"></a>bootloader校验FW</h3><p>bootloader的main初始化系统时钟后，就立即check FW是否valid：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	HAL_Init();</span><br><span class="line">	SystemClock_Config();</span><br><span class="line">	//判断FW是否valid</span><br><span class="line">	check_if_jump_to_app();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">check_if_jump_to_app():</span><br><span class="line"></span><br><span class="line">    if(*(uint32_t *)RAM_FROM_APP_FLAG_ADDR != RAM_FROM_APP_FLAG_DATA)&#123;</span><br><span class="line">            *(uint32_t *)RAM_FROM_APP_FLAG_ADDR = 0;</span><br><span class="line">            if((*(uint32_t *)APP_FILE_EDN_ADDR == APP_FILE_END_DATA) &amp;&amp; </span><br><span class="line">                ( *(uint32_t *)APP_FILE_START_ADDR == APP_FILE_START_DATA) &amp;&amp;</span><br><span class="line">                (pin_state == GPIO_PIN_SET)) //PB4</span><br><span class="line">                direct_jump_to_app();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>校验FW有效包括三个条件都要满足：</p>
<ol>
<li>查看RAM 0x3f3C位置(0x20003f3C)的DWORD是否为RAM_FROM_APP_FLAG_DATA(0x6a756d70)，然后清0。这个flag是USB上位机下发USB_IAP_JUMP_TO_BOOT时调用jump_to_boot()设置的，这个USB请求在bootloader或FW阶段都可能被发起。</li>
</ol>
<p>​      目的：确认是上位机发起的jump to boot，而不是其他原因比如CPU异常reset进入的boot。</p>
<ol start="2">
<li><p>查看Flash的FW区域（0x0800_8000开始）的开始（0x08008014）和尾部区域（0x0800fffc）的两个DWORD是否分别为0x00617070和0x00656e64。</p>
<p>目的：确认Flash的FW是valid，确认尾部是确保数据完整</p>
</li>
<li><p>查看PB4 pin是否为高。</p>
<p>目的：根据原例图，可能是防止和one-wire功能冲突？待确认</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171138048.png" alt="image-20240517113801021"></p>
</li>
</ol>
<h3 id="bootloader跳转到FW代码的过程"><a href="#bootloader跳转到FW代码的过程" class="headerlink" title="bootloader跳转到FW代码的过程"></a>bootloader跳转到FW代码的过程</h3>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">direct_jump_to_app():</span><br><span class="line"></span><br><span class="line">#define  APPLICATION_ADDRESS   (0x08000000 + 0x8000) //FW在Flash的起始地址 </span><br><span class="line"></span><br><span class="line">void direct_jump_to_app(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	uint32_t JumpAddress;</span><br><span class="line">	pFunction Jump_To_Application;</span><br><span class="line">	</span><br><span class="line">	__disable_irq(); </span><br><span class="line">	</span><br><span class="line">	//拷贝Firmwware的192bytes的中断向量表到SRAM</span><br><span class="line">	for(i = 0; i &lt; 48; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		*((uint32_t*)(0x20000000 + (i &lt;&lt; 2)))=*(__IO uint32_t*)(APPLICATION_ADDRESS + (i&lt;&lt;2));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 /* Test if user code is programmed starting from address &quot;APPLICATION_ADDRESS&quot; */</span><br><span class="line">	 //判断栈指针是否位于SRAM</span><br><span class="line">	if (((*(__IO uint32_t*)APPLICATION_ADDRESS) &amp; 0x2FFE0000 ) == 0x20000000)</span><br><span class="line">    &#123; /* Jump to user application */</span><br><span class="line">      </span><br><span class="line">      	//设置函数指针，跳转到Firmware的RESET入口</span><br><span class="line">		JumpAddress = *(__IO uint32_t*) (APPLICATION_ADDRESS + 4);</span><br><span class="line">		Jump_To_Application = (pFunction) JumpAddress;</span><br><span class="line">		</span><br><span class="line">		/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">		__set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);</span><br><span class="line">		</span><br><span class="line">		//执行跳转</span><br><span class="line">		Jump_To_Application();</span><br><span class="line">	&#125;  </span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		__enable_irq();</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（1）拷贝Firmwware的192bytes的中断向量表到SRAM</strong></p>
<p><strong>Q1：为什么要拷贝？中断向量表放在Flash中不能执行吗？</strong></p>
<p>Cortex M0的限制：Flash的中断向量表一定要放在Flash开始的地方，不能relocation到Flash的其他偏移地址，参考Reference Manual RM0091：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171723698.png" alt="image-20240517172328661"></p>
<p>Firmware中断向量表是放在Flash的32KB offset的地方，是不能被硬件使用的；</p>
<p>RM0091给出Cortex M0对此问题的方案：将中断向量表拷贝到SRAM的0地址，再设置SYSCFG register，remap SRAM空间作为CPU 0地址。这样CPU异常、中断发生时，就能进入SRAM的中断向量表。</p>
<p><strong>Q2：为什么只需要拷贝中断向量表的192bytes，而不是拷贝整个Firmware的32KB？SRAM空间都remap为CPU 0地址了，Flash中的Firmware代码不拷贝到SRAM还能执行到吗？</strong></p>
<p>这里要分析MCU的PC指针取指令的流程：</p>
<ol>
<li>在bootloader开始阶段，PC指针取指令都是在Flash 起始地址~32KB之间取bootloader指令执行</li>
<li>bootloader拷贝FW中断向量表到SRAM的0地址，并设置CPU memory空间为SRAM空间 (注释1)</li>
<li>bootloader跳转，注意看上面代码，跳转到Flash的Firmware空间(Flash 32KB~64KB)的Firmware入口，也就是说，PC指针还是从Flash取指令，只不过指令是Firmware的main</li>
<li>Firmware执行main初始化和while1，PC指针始终在while1中转圈</li>
<li>如果中断或者异常发生，硬件跳转到SRAM的Firmware中断向量表，取中断回调指令执行，这个中断回调指令还是在Flash的Firmware空间(Flash 32KB~64KB)，中断返回后，PC指针恢复之前在Firmware while1里的位置。</li>
</ol>
<p>根据以上分析，PC指针仅仅在中断发生时需要用跳到SRAM的中断向量表，其他时间都在Flash的Firmware区域取指令，所有Firmware代码都能被执行到。因此SRAM remap不影响Flash的代码执行，不需要拷贝Firmware代码到SRAM (要拷贝FW到SRAM以提高执行速度也行，要改Firmware编译的基地址为SRAM)。</p>
<p>（注释1）CPU remap实际在main才设置（但应该在bootloader里设置），代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__HAL_REMAPMEMORY_SRAM();</span><br><span class="line"></span><br><span class="line">#define __HAL_REMAPMEMORY_SRAM                __HAL_SYSCFG_REMAPMEMORY_SRAM</span><br><span class="line">#define __HAL_SYSCFG_REMAPMEMORY_SRAM()         do &#123;SYSCFG-&gt;CFGR1 &amp;= ~(SYSCFG_CFGR1_MEM_MODE); \</span><br><span class="line">                                             SYSCFG-&gt;CFGR1 |= (SYSCFG_CFGR1_MEM_MODE_0 | SYSCFG_CFGR1_MEM_MODE_1); \</span><br><span class="line">                                            &#125;while(0) </span><br></pre></td></tr></table></figure>

<p><strong>关于CPU空间的remapping，有两个概念需清楚：</strong></p>
<ol>
<li><p>CPU空间remap到SRAM还是Flash，并不影响CPU对Flash和SRAM的访问；</p>
<p>不管谁被remap为CPU memory空间，pc取指令都可以用0x0800_0000 + offset访问Flash，0x2000_0000 + offset访问SRAM</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171747713.png" alt="image-20240517174752681"></p>
</li>
<li><p>CPU remap只影响”MCU的0地址在哪个设备空间“，和启动位置相关；</p>
<p>SYSCFG register的CPU memory mapping定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171745110.png" alt="image-20240517174553060"></p>
<p>注意该SYSCFG register配置会被reset，即reset启动后的CPU space是BOOT0 pin和nBOOT1 register共同决定的：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171756653.png" alt="image-20240517175619616"></p>
</li>
</ol>
<p><strong>Q3：Firmware和bootloader的中断向量表的指令应该差不多，为什么不能公用一套中断向量表？</strong></p>
<p>这个问题涉及到编译和链接：bootloader和Firmware的中断向量表的指令还是有区别，因为中断回调不同，导致必须要分两套中断向量表；</p>
<p>两套中断向量表编译出的基础地址不一样：如下图bootloader中断向量表指令都是基于0x0800_8000，FW的都是0x0800_0000。这个基础地址是.sct链接文件指定。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171859345.png" alt="image-20240517185911311"></p>
<p><strong>（2）跳转到Firmwware指令</strong></p>
<p>跳转的条件判断是个难点：为什么要判断FW代码的首个DWORD的值是否在SRAM空间？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (((*(__IO uint32_t*)APPLICATION_ADDRESS) &amp; 0x2FFE0000 ) == 0x20000000)</span><br></pre></td></tr></table></figure>

<p>FW代码的首个DWORD的值是什么：</p>
<p>参考FW的startup.s：是__initial_sp符号，找不到具体指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp                   ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                  ; Reset Handler</span><br></pre></td></tr></table></figure>

<p>__initial_sp符号符号是什么：</p>
<p>FW的startup.s只能找到声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size		EQU     0x500</span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br></pre></td></tr></table></figure>

<p>对此代码的解释：</p>
<p>__initial_sp is a label which takes the origin (ORG) value of the assembler after it allocates the space. Look at a .LST or .MAP file.</p>
<p>参考：<a target="_blank" rel="noopener" href="https://community.st.com/t5/stm32-mcus-products/about-initial-sp/td-p/551812">https://community.st.com/t5/stm32-mcus-products/about-initial-sp/td-p/551812</a></p>
<p>基于此解释，查看FW的.map，找到symbol的分布：</p>
<p>最后一个Data symbol是uwTick，尾部地址是0x20003514 + 4 &#x3D; 0x20003518；</p>
<p>__initial_sp符号的起始地址正好是0x20003518 + 0x500（startup.s指定的Stack_Size），因此验证了以上解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Global Symbols</span><br><span class="line"></span><br><span class="line">    Symbol Name                              Value     Ov Type        Size  Object(Section)</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">    huart1                                   0x20001a3c   Data         132  usart.o(.bss.huart1)</span><br><span class="line">    huart2                                   0x20001ac0   Data         132  usart.o(.bss.huart2)</span><br><span class="line">    huart3                                   0x20001b44   Data         132  usart.o(.bss.huart3)</span><br><span class="line">    one_wire_data                            0x20001fcc   Data         152  one_wire.o(.bss.one_wire_data)</span><br><span class="line">    uart_rx_fifo_buf                         0x20002064   Data        5120  main.o(.bss.uart_rx_fifo_buf)</span><br><span class="line">    uwTick                                   0x20003514   Data           4  stm32f0xx_hal.o(.bss.uwTick)</span><br><span class="line">    __initial_sp                             0x20003a18   Data           0  startup_stm32f072xb.o(STACK)</span><br></pre></td></tr></table></figure>

<p>基于以上，__initial_sp 是编译器自动形成的值，作为RAM中的栈顶位置。</p>
<p>bootloader设置Stack_Size为0x500，编译器就在RAM中把所有全局变量排列完后，在加0x500作为栈空间，也就是说这个值最后是取决于代码数据占的RAM空间的，并不是固定的RAM最尾部的地址。</p>
<p>注：Stack_Size值应该根据.map情况，设置成和RAM可用栈空间接近，不然RAM空间没充分利用，形成爆栈。</p>
<p>所以FW的第一个指令保存了RAM中的栈顶（栈起始地址），第二个指令才是RESET。</p>
<p>前面代码是bootloader对__initial_sp 判断是否在RAM空间，因为跳转时要设置栈指针的安全性判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">__set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);</span><br></pre></td></tr></table></figure>

<p><strong>（3）Jump_To_Application函数指针</strong></p>
<p>这里不详细分析。STM32 bootloader跳转FW有模板代码，参考原厂固件库代码。</p>
<h2 id="Flash烧录问题（重要）"><a href="#Flash烧录问题（重要）" class="headerlink" title="Flash烧录问题（重要）"></a>Flash烧录问题（重要）</h2><h3 id="用Keil的JLink烧录Flash"><a href="#用Keil的JLink烧录Flash" class="headerlink" title="用Keil的JLink烧录Flash"></a>用Keil的JLink烧录Flash</h3><p>Keil内置安装JLink，Keil烧录.bin到开发板的Flash，实际是调用内置的JLink烧录。</p>
<p>对于Bootloader和Firmware，需要正确配置烧录区域：</p>
<ul>
<li>Address Range： .bin文件烧录到Flash的区域(一般是Flash空间)；这个区域应该和Keil项目配置的ROM区域一致</li>
<li>Erase Sectors：只擦除选中的Flash Address Range的sectors</li>
<li>RAM for Algorithm：这个跟烧录的.bin运行时RAM没关系，是指烧录程序本身要占用的RAM，参考：<a target="_blank" rel="noopener" href="https://www.keil.com/support/man/docs/ulinkme/ulinkme_su_ram_for_algorithm.htm">https://www.keil.com/support/man/docs/ulinkme/ulinkme_su_ram_for_algorithm.htm</a></li>
</ul>
<p>o2link的bootloader：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201046576.png" alt="image-20240520104651534"></p>
<p>o2link的firmware：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201047437.png" alt="image-20240520104700405"></p>
<h3 id="如何确认Flash正确烧录"><a href="#如何确认Flash正确烧录" class="headerlink" title="如何确认Flash正确烧录"></a>如何确认Flash正确烧录</h3><p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/lnfiniteloop/article/details/134575496?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-134575496-blog-118443669.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-134575496-blog-118443669.235%5Ev43%5Epc_blog_bottom_relevance_base4&utm_relevant_index=2">J-Flash读取STM32内部程序，导出Hex&#x2F;Bin文件</a></p>
<p>JLink安装，需要安装包里的USB驱动：SEGGER\JLink_V796e\USBDriver\x64\dpinst_x64.exe</p>
<p>使用JLink读Flash并比较：</p>
<ol>
<li>JLink: Target -&gt; Connect</li>
<li>读Flash(一般Range或者Entire chip)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112900.png" alt="image-20240520111220863"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112614.png" alt="image-20240520111250598"></p>
<ol start="3">
<li>保存数据到.bin</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112851.png" alt="image-20240520111256831"></p>
<ol start="4">
<li>比较bootloader.bin和从Flash读出的数据.bin是否一致：</li>
</ol>
<p>使用Winmerge比较二进制文件：</p>
<p>左侧bootloader.bin，右侧Flash读出的bootloader；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201104475.png" alt="image-20240520110440432"></p>
<p>可见bootloader真实数据约0x7524 bytes；Flash擦除整个bootloader区域0~0x8000, 所以Flash读的后部分数据为0xFF。</p>
<p>Firmware区域比较同理，JLink的Flash读出区域改成0x08008000~0x08010000</p>
<h2 id="特殊的编译和代码修改记录"><a href="#特殊的编译和代码修改记录" class="headerlink" title="特殊的编译和代码修改记录"></a>特殊的编译和代码修改记录</h2><p>编译问题：</p>
<ol>
<li><p>Firmware编译无法输出.bin文件但Keil没报错，输出了ER$$.ARM.__at_0x0800fffc文件</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201155089.png" alt="image-20240520115554066"></p>
<p>原因：main定义了以下section，但链接器找不到这个符号，所以生成bin时报error</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const uint32_t file_end __attribute__((section(&quot;.ARM.__at_0x0800fffc&quot;))) = 0x00656e64;</span><br></pre></td></tr></table></figure>

<p>目前没找到根本性的解决办法；因为代码没用到这个file_end，所以注释掉这个定义。这个定义地址本身是合理的，是Firmware的Flash区域的最后一个DWORD。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/dui0474/m/scatter-loading-features/root-execution-regions/methods-of-placing-functions-and-data-at-specific-addresses?lang=en">Methods of placing functions and data at specific addresses</a></p>
<p><a target="_blank" rel="noopener" href="https://documentation-service.arm.com/static/63eb51fc9567172d4e2aa918">ARM asmlink User Guide</a></p>
</li>
</ol>
<p>代码问题：</p>
<p>bootloader+Firmware只支持用USB上位机更新Firmware，不支持JLink烧录Firmware，因为bootloader校验Dword不通过；所以需要修改bootloader代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void check_if_jump_to_app(void):</span><br><span class="line"></span><br><span class="line">#ifdef SKYWAYS_TEST</span><br><span class="line">	direct_jump_to_app(); //这里直接跳转，不校验是USB上位机发起的跳转</span><br><span class="line">#else</span><br><span class="line">	if (*(uint32_t *)RAM_FROM_APP_FLAG_ADDR != RAM_FROM_APP_FLAG_DATA)</span><br><span class="line">	&#123;</span><br><span class="line">		*(uint32_t *)RAM_FROM_APP_FLAG_ADDR = 0;</span><br><span class="line">		if ((*(uint32_t *)APP_FILE_EDN_ADDR == APP_FILE_END_DATA) &amp;&amp;</span><br><span class="line">			(*(uint32_t *)APP_FILE_START_ADDR == APP_FILE_START_DATA) &amp;&amp;</span><br><span class="line">			(pin_state == GPIO_PIN_SET))</span><br><span class="line">			direct_jump_to_app();</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="Skyways业务代码分析"><a href="#Skyways业务代码分析" class="headerlink" title="Skyways业务代码分析"></a>Skyways业务代码分析</h1><p>在《STM32–Firmware Architecture part1：开发环境和HAL API应用》中已经分析了整体的Firmware-USB上位机之间的请求处理流程，这里针对Skyways Firmware具体分析业务流程的差异点。</p>
<h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><h3 id="USB下发数据给UART（TX-no-buffer）"><a href="#USB下发数据给UART（TX-no-buffer）" class="headerlink" title="USB下发数据给UART（TX, no buffer）"></a>USB下发数据给UART（TX, no buffer）</h3><p>调用过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUSTOM_HID_OutEvent_FS -&gt; write_uart_function() -&gt; HAL_UART_Transmit()</span><br></pre></td></tr></table></figure>

<p>Skyways版本的UART TX代码有几点需要注意：</p>
<ol>
<li>usb_send_buf[0] |&#x3D; 0x80;表示错误，用于通知USB上位机。Tx一次发送超过60bytes, 或者HAL_UART_Transmit有Timeout，则上报USB上位机有错。</li>
<li>以下代码的UART返回数据没发送给USB，和o2link Spec不一致：UART没有返回USB：0101+buffer data.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void write_uart_function()</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t ret = 0;</span><br><span class="line">	uint32_t i;</span><br><span class="line">	length = usb_send_buf[2] &lt;&lt; 8 | usb_send_buf[3];</span><br><span class="line">	if(length &gt; MAX_UART_WRITE_LENGTH)&#123; //60bytes</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = UART_PARAMETER_ERROR;</span><br><span class="line">		usb_send(usb_send_buf,USB_TIMEOUT_TIME);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cdc_receive_flag = CDC_FLAG_HID;</span><br><span class="line">	ret = HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;usb_send_buf[4],length,UART_TIMEOUT_TIME);</span><br><span class="line"></span><br><span class="line">	if(ret)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = ret;</span><br><span class="line">		usb_send(usb_send_buf,USB_TIMEOUT_TIME);</span><br><span class="line">	&#125;</span><br><span class="line">	//usb_send(usb_send_buf,USB_TIMEOUT_TIME); //这里和o2link Spec不一致，UART没有返回USB：0101+buffer.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="USB从UART接收数据（RX-1KB-buffer-DMA）"><a href="#USB从UART接收数据（RX-1KB-buffer-DMA）" class="headerlink" title="USB从UART接收数据（RX, 1KB buffer, DMA）"></a>USB从UART接收数据（RX, 1KB buffer, DMA）</h3><p>代码流程在《STM32–Firmware Architecture part1：开发环境和HAL API应用》的”UART2部分”有详细分析。</p>
<p>应用上的结论：UART2 DMA使用UART IDLE frame作为传输完成中断的触发源，只要应用上保证一次UART读数据中没有异常的IDLE frame，则UART2 DMA IDLE frame产生的完成中断可作为一次完整的UART数据传输结束标志。</p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>Skyways的SPI data transmission底层操作在的”8.1 usb_to_spi”有详细描述，这里看到以下区别：</p>
<ul>
<li>发起spi数据传输之前，Deinit了I2C，把I2C的SDA&#x2F;SCL两个pin作为GPIO输入模式拉高。</li>
<li>完成spi数据传输之后，重新init了I2C到100K速度.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void usb_handle_process(void):</span><br><span class="line"></span><br><span class="line">case USB_TO_SKYWAY_SPI_WRITE:</span><br><span class="line">		HAL_I2C_DeInit(&amp;hi2c1);</span><br><span class="line">		i2c_gpio_fun();</span><br><span class="line">		usb_to_spi_convert_skyway_write();</span><br><span class="line">		MX_I2C1_Init(100000, 7);</span><br><span class="line">		break;</span><br><span class="line">case USB_TO_SKYWAY_SPI_READ:</span><br><span class="line">		HAL_I2C_DeInit(&amp;hi2c1);</span><br><span class="line">		i2c_gpio_fun();</span><br><span class="line">		usb_to_spi_convert_skyway_read();</span><br><span class="line">		MX_I2C1_Init(100000, 7);</span><br><span class="line">		break;</span><br></pre></td></tr></table></figure>

<p>根据Skyways和MCU的连接，SPI和I2C并没有复用；Skyways和MCU的SPI通信也没要求对I2C的pin做什么特殊操作（测试SPI read、write甚至都没连接I2C），因此猜测此处代码只是早期开发时，预防I2C和SPI同时使用时有冲突，实际没这个需求。 – 下个版本删除此I2C代码，测试SPI read、write.</p>
<h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><p>TODO</p>
<h2 id="one-wire"><a href="#one-wire" class="headerlink" title="one-wire"></a>one-wire</h2><p>TODO</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--%E4%BB%8E0%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--%E4%BB%8E0%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">STM32--从0创建项目和设计架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:50:39" itemprop="dateModified" datetime="2025-11-18T10:50:39+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32/" itemprop="url" rel="index"><span itemprop="name">STM32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–从0创建项目和设计架构"><a href="#STM32–从0创建项目和设计架构" class="headerlink" title="STM32–从0创建项目和设计架构"></a>STM32–从0创建项目和设计架构</h1><h2 id="野火STM32-F4创建项目："><a href="#野火STM32-F4创建项目：" class="headerlink" title="野火STM32 F4创建项目："></a>野火STM32 F4创建项目：</h2><p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/mcu/stm32/f4/hal_general/zh/latest/doc/chapter10/chapter10.html">https://doc.embedfire.com/mcu/stm32/f4/hal_general/zh/latest/doc/chapter10/chapter10.html</a></p>
<h2 id="STMF0创建项目："><a href="#STMF0创建项目：" class="headerlink" title="STMF0创建项目："></a>STMF0创建项目：</h2><p>（1）芯片型号启动创建</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221510696.png" alt="image-20240722151016542"></p>
<p>（2）配置时钟和各外设</p>
<p>这里参考已有的其他stm32f0项目，用CubeMX打开两个项目，在GUI对照配置新项目自动生成代码。要特别注意时钟的配置，如果使用外接晶振，和具体开发板环境有关。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221516703.png" alt="image-20240722151602583"></p>
<p>配置外设和GPIO有技巧：先配置外设（connectivity项，SPI，UART，I2C…），配好后会自动配置外设占用的GPIO；而独立的GPIO功能（一般作为debug pin）在外设配完后再补充。</p>
<p>外设pin脚可以设置标签，便于不看电路原理图就知道是做什么用，但是注意要保留pin本身的含义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221528881.png" alt="image-20240722152839824"></p>
<p>在配置pin功能如果有感叹号表示有部分功能和其他模块冲突，例如UART1的流控功能和USB冲突（红色），由于UART1并不开启流控，此处不需要管。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221600775.png" alt="image-20240722160043740"></p>
<p>(3)生成MDK-ARM项目</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>CubeMX项目要想可维护，后期能通过GUI方式更新配置同时不破坏用户自定义代码，有两种方式：</p>
<ul>
<li>在GUI生成代码内加User代码，即User Begin ~ User End的代码区域</li>
<li>创建独立的代码文件夹，和GUI创建的项目代码完全隔离。用户代码要使用GUI生成的函数和数据只引用GUI的外设头文件</li>
</ul>
<p>以下是使用独立代码文件夹的方式：</p>
<p>（1）Keil打开GUI自动创建的项目（包含USB middleware），首先配置好编译链接烧录等配置。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221630057.png" alt="image-20240722163031991"></p>
<p>（2）添加自定义文件夹的.c文件</p>
<p>这里的Group一般以文件夹结构命名，Files只是.c源文件，头文件.h不是在这里添加</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221648462.png" alt="image-20240722164837416"></p>
<p>（3）添加自定义文件夹的.h头文件</p>
<p>在项目option里加头文件路径</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221650166.png" alt="image-20240722165046119"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221652202.png" alt="image-20240722165206164"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--%E6%90%AD%E5%BB%BAVSCode+STMCubeIDE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--%E6%90%AD%E5%BB%BAVSCode+STMCubeIDE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">STM32--搭建VSCode+STMCubeIDE开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-18 10:50:31" itemprop="dateModified" datetime="2025-11-18T10:50:31+08:00">2025-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32/" itemprop="url" rel="index"><span itemprop="name">STM32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–搭建VSCode-STMCubeIDE开发环境"><a href="#STM32–搭建VSCode-STMCubeIDE开发环境" class="headerlink" title="STM32–搭建VSCode+STMCubeIDE开发环境"></a>STM32–搭建VSCode+STMCubeIDE开发环境</h1><h2 id="用STM32CubeIDE创建工程"><a href="#用STM32CubeIDE创建工程" class="headerlink" title="用STM32CubeIDE创建工程"></a>用STM32CubeIDE创建工程</h2><h2 id="用VSCode编辑代码"><a href="#用VSCode编辑代码" class="headerlink" title="用VSCode编辑代码"></a>用VSCode编辑代码</h2><h3 id="配置-vscode使能tab补全"><a href="#配置-vscode使能tab补全" class="headerlink" title="配置.vscode使能tab补全"></a>配置.vscode使能tab补全</h3><p>Stm32的HAL库默认是没有被VSCode的C&#x2F;C++ intelligence检测到，自动补全功能不完整，例如HAL_UART_XXX不能tab补全到HAL_UART_Transmit，这个API定义在Drivers&#x2F;Drivers&#x2F;STM32FXXX_HAL_Driver&#x2F;Inc里，C&#x2F;C++ intelligence没有检测到这个路径，因此需要配置C&#x2F;C++ intelligence的c_cpp_properties.json, 添加include和defines。</p>
<p>（1）打开STM32项目</p>
<p>注意：要配置哪个STM32项目就VSCode打开哪个目录，不要打开包括多个STM32项目的workspace，不然配置的.vscode是针对workspace目录的，不会对各项目生效。</p>
<p>比如以下workspace有几个STM32CubeIDE创建的项目，VSCode应该打开具体的项目serial-test-isr再配置该项目的.vscode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0&gt; ls</span><br><span class="line"></span><br><span class="line">    目录: C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2024/4/29     10:03                .metadata</span><br><span class="line">d-----         2024/4/29     10:34                .vscode</span><br><span class="line">d-----         2024/4/24     19:45                led-test</span><br><span class="line">d-----         2024/4/25     11:25                serial-test</span><br><span class="line">d-----         2024/4/29     10:06                serial-test-isr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0&gt; cd .\serial-test-isr\</span><br><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0\serial-test-isr&gt; ls</span><br><span class="line"></span><br><span class="line">    目录: C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0\serial-test-isr</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2024/4/28     22:33                .settings</span><br><span class="line">d-----         2024/4/29     10:06                .vscode</span><br><span class="line">d-----         2024/4/28     16:26                Core</span><br><span class="line">d-----         2024/4/28     17:51                Debug</span><br><span class="line">d-----         2024/4/28     16:26                Drivers</span><br><span class="line">-a----         2024/4/28     16:39          25210 .cproject</span><br><span class="line">-a----         2024/4/28     16:39           8275 .mxproject</span><br><span class="line">-a----         2024/4/28     16:30           1221 .project</span><br><span class="line">-a----         2024/4/28     17:56          10224 serial-test-isr Debug.launch</span><br><span class="line">-a----         2024/4/28     16:39           2975 serial-test-isr.ioc</span><br><span class="line">-a----         2024/4/28     16:39           5306 STM32F072C8TX_FLASH.ld</span><br></pre></td></tr></table></figure>

<p>（2）配置.vscode</p>
<p>VSCode左下角setting -&gt; Command Palette -&gt; 搜索: C&#x2F;C++ Edit Configurations (UI) 或者 (JSON)</p>
<p>C&#x2F;C++ Edit Configurations (UI) ：</p>
<p>在Include path添加HAL库定义的路径：这里直接用**递归搜索，类似.gitignore的语法，不需要指定到具体的Drivers&#x2F;STM32FXXX_HAL_Driver&#x2F;Inc路径。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404291104878.png" alt="image-20240429104934058"></p>
<p>C&#x2F;C++ Edit Configurations (JSON)方式的配置，UI配置也会反应在此 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;Drivers/**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;gnu++17&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）VSCode调用STM32 HAL 函数自动补全</p>
<p>现在可以tab补全STM32 HAL的所有库函数，可以彻底抛弃STM32CubeIDE的编辑界面：)</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404291104289.png" alt="image-20240429105530310"></p>
<h2 id="用STM32CubeIDE和J-link调试和烧录"><a href="#用STM32CubeIDE和J-link调试和烧录" class="headerlink" title="用STM32CubeIDE和J-link调试和烧录"></a>用STM32CubeIDE和J-link调试和烧录</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cursorhu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cursorhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cursorhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cursorhu@outlook.com" title="E-Mail → mailto:cursorhu@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cursorhu</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
