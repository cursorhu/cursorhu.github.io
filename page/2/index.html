<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/2/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/04/26/Ubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/26/Ubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Ubuntu使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 11:08:09" itemprop="dateCreated datePublished" datetime="2023-04-26T11:08:09+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-15 19:19:58" itemprop="dateModified" datetime="2023-05-15T19:19:58+08:00">2023-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文基于Ubuntu 22.04 LTS</p>
<h2 id="软件下载源"><a href="#软件下载源" class="headerlink" title="软件下载源"></a>软件下载源</h2><p>使用国内软件源下载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">software&amp;updates -&gt; Ubuntu Software -&gt; download from -&gt; cn99.com或aliyun.com</span><br></pre></td></tr></table></figure>

<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>安装中文输入法(pinyin)的步骤：</p>
<p>安装中文支持：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Install/Remove Languages -&gt; 安装chinese simplified</span><br></pre></td></tr></table></figure>

<p>设置系统语言为中文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成Chinese</span><br></pre></td></tr></table></figure>

<p>安装Fcitx框架和中文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx-bin #安装fcitx框架</span><br><span class="line">sudo apt-get install fcitx-table #安装输入法栏，其中自动安装拼音输入法</span><br><span class="line">fcitx --version</span><br></pre></td></tr></table></figure>

<p>使用Fcitx框架，重启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Manage Installed Languages -&gt; Keyboard input method system 选择Fcitx 4</span><br></pre></td></tr></table></figure>

<p>添加输入法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu右上角的小键盘图标 -&gt; configure -&gt; 添加pinyin（只有系统语言为中文时才能添加中文输入法）</span><br></pre></td></tr></table></figure>

<p>切换中英文输入法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + space</span><br></pre></td></tr></table></figure>

<p>设置系统语言改回英文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings -&gt; Region&amp;language -&gt; Language改成English</span><br></pre></td></tr></table></figure>

<h2 id="snap包管理工具"><a href="#snap包管理工具" class="headerlink" title="snap包管理工具"></a>snap包管理工具</h2><p><a target="_blank" rel="noopener" href="https://snapcraft.io/store">Snap</a>是Canonical开发的Linux包管理和软件部署工具。 </p>
<p>安装和使用参考 <a target="_blank" rel="noopener" href="https://phoenixnap.com/kb/install-snap-ubuntu#:~:text=1%20Start%20by%20updating%20packages%3A%0Asudo%20apt,update%202%20Enter%20the%20following%20command%3A"><strong>How to Install Snap on Ubuntu</strong></a></p>
<p>特点：丰富的第三方工具库，包括开源工具和闭源工具；二进制安装，不是源码编译</p>
<p>相比apt，其查找工具和安装极为简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo snap find &lt;keyword&gt; #查找keyword相关的工具，显示可安装的列表</span><br><span class="line">sudo snap install &lt;package&gt; #安装列表中的工具</span><br></pre></td></tr></table></figure>

<p>查看和卸载snap安装的包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">snap list</span><br><span class="line">sudo snap remove &lt;package&gt;</span><br></pre></td></tr></table></figure>

<p>示例：安装VSCode和Chrome</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo snap find vscode #找到&lt;package&gt;为code</span><br><span class="line">sudo snap install code --classic</span><br><span class="line">sudo snap find chrome #找到&lt;package&gt;为chromium</span><br><span class="line">sudo snap install chromium</span><br></pre></td></tr></table></figure>

<h2 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h2><p>setting -&gt; keyboard -&gt; shortcuts -&gt; custom shortcut -&gt; 为应用程序添加快捷键</p>
<p>以截图工具flameshot为例，设置快捷键的command为调用flameshot的命令，截图默认保存到~&#x2F;Pictures</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305051055723.png" alt="image-20230505105544618"></p>
<p>要配置其他flameshot命令的快捷键，用 <code>man flameshot</code> 查看，参考 <a target="_blank" rel="noopener" href="https://flameshot.org/docs/guide/key-bindings/">Keyboard shortcuts for Flameshot</a></p>
<h2 id="Timeshift备份系统"><a href="#Timeshift备份系统" class="headerlink" title="Timeshift备份系统"></a>Timeshift备份系统</h2><p>22.04系统似乎比较容易挂，进不了系统显示”Oh no… system can’t recover…”，比如：</p>
<p>Nvdia驱动选择开源版本xserver就挂了一次, recovery模式看&#x2F;var&#x2F;log&#x2F;message有nouveau和nvidia module相关问题</p>
<p>学习xv6时安装编译环境时也挂了一次(不能安装到&#x2F;usr&#x2F;local，应该安装到&#x2F;home)，recovery模式dpkg report显示failure log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbol lookup error: /lib/x86_64-linux-gnu/libgnutls.so.30: undefined symbol: __gmpz_limbs_write </span><br></pre></td></tr></table></figure>

<p>都是找遍办法都修复不了，只能重装…</p>
<p>为了解决此问题，使用Timeshift将系统备份，参考: <a target="_blank" rel="noopener" href="https://itsfoss.com/backup-restore-linux-timeshift/">How to Backup and Restore Linux System Settings With Timeshift</a></p>
<p>安装timeshift：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install timeshift</span><br></pre></td></tr></table></figure>

<p>备份整个系统，包括&#x2F;root和&#x2F;home&#x2F;user，设置定时备份</p>
<p>如何恢复：</p>
<p>情景一：系统无法进入桌面，但是可以进入recovery模式root操作：</p>
<p>如下图，用<code>timeshift --help</code>查看各种命令，使用<code>timeshift --restore</code>恢复指定snapshot</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202305081931009.png" alt="image-20230508193100794"></p>
<p>情景二：系统无法进入recovery模式，但是备份的snapshot数据还在</p>
<p>使用<a target="_blank" rel="noopener" href="https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows?ref=itsfoss.com">Ubuntu Live USB</a> ，即装系统的USB进入try ubuntu环境，联网换国内源安装timeshift，再恢复系统盘中的snapshot数据</p>
<p>情景三：磁盘中的snapshot数据损害：只能重装系统，为了避免此情况发生，应该将系统备份到其他硬盘而不仅仅在当前系统盘</p>
<h2 id="Clonezilla克隆系统"><a href="#Clonezilla克隆系统" class="headerlink" title="Clonezilla克隆系统"></a>Clonezilla克隆系统</h2><p>类似windows ghost的整盘克隆：</p>
<p><a target="_blank" rel="noopener" href="https://www.linuxbabe.com/backup/how-to-use-clonezilla-live">https://www.linuxbabe.com/backup/how-to-use-clonezilla-live</a></p>
<p>至少需要三个盘：</p>
<p>在U盘写入Clonezilla的live usb iso生成Clonezilla live USB，再以Clonezilla live USB启动，对待备份的SSD盘做系统备份，到另一个SSD或者大USB盘；</p>
<p>恢复也是需要Clonezilla live USB + 有系统备份的盘 + 目标写入盘</p>
<h2 id="关于系统目录"><a href="#关于系统目录" class="headerlink" title="关于系统目录"></a>关于系统目录</h2><p>&#x2F;usr：系统级的目录，可以理解为C:&#x2F;Windows&#x2F;，apt安装的一般在&#x2F;usr&#x2F;bin和&#x2F;usr&#x2F;lib</p>
<p>&#x2F;usr&#x2F;lib：理解为C:&#x2F;Windows&#x2F;System32</p>
<p>&#x2F;usr&#x2F;local：用户级的程序目录，可以理解为C:&#x2F;Progrem Files&#x2F;，用户自己编译的软件默认安装到这个目录下</p>
<p>&#x2F;opt是用户级的目录用来安装大型的第三方附加软件包，可以理解为D:&#x2F;Software</p>
<p>开发过程中为了避免lib冲突，自己编译的包建议放在&#x2F;home&#x2F;&lt;具体的项目目录&gt;，此外注意自己编译基础库设置的LD_LIBRARY_PATH造成系统库链接冲突</p>
<h2 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/04/10/%E6%B5%85%E8%B0%88%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8CReDriver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/10/%E6%B5%85%E8%B0%88%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8CReDriver/" class="post-title-link" itemprop="url">浅谈信号完整性和ReDriver</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-10 10:51:25" itemprop="dateCreated datePublished" datetime="2023-04-10T10:51:25+08:00">2023-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-11 10:30:02" itemprop="dateModified" datetime="2023-04-11T10:30:02+08:00">2023-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IC/" itemprop="url" rel="index"><span itemprop="name">IC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="信号完整性"><a href="#信号完整性" class="headerlink" title="信号完整性"></a>信号完整性</h2><p>在讨论ReDriver之前，先说明信号完整性（Signal Integrity, SI）的相关背景。<br>电子信号在传输过程中(无线或有线)都会受到环境噪声干扰，信号功率也会随着传输距离衰减(signal attenuation)。<br>通信系统中用信噪比表达的信号的好坏:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">信噪比(dB)=10*log（信号/噪音）</span><br></pre></td></tr></table></figure>

<ul>
<li>当信噪比大于设备接收灵敏度时，信号能被正常接收和解析（成逻辑0&#x2F;1）</li>
<li>当信噪比小于设备接收灵敏度时，信号被错误解析（错误的逻辑0&#x2F;1）或者是根本解析不出信号(噪声完全淹没信号，接收端恒为0或1，没有信号变化)。</li>
</ul>
<p>信号完整性（Signal Integrity, SI）一般指PCB电路中的电压信号的信噪比好坏。如果电路中信号能够以要求的时序、持续时间和电压幅度到达接收器，则该电路具有较好的信号完整性。反之当信号不能正常响应时，就出现了信号完整性问题。一般通过眼图观测信号完整性好坏。</p>
<p>信号完整性在高速电路更容易出问题，表现为信号有传输延迟和时序错误、电路串扰（电容性、电感性串扰）等。</p>
<p>高速信号的PCB电路设计和信号完整性密切相关，例如下图是PCB使用FR4材料和Megtron6材料，信号-频率函数显示衰减度不同。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101118830.png" alt="Attenuation versus Frequency as a function of PCB material"></p>
<h2 id="ReDriver"><a href="#ReDriver" class="headerlink" title="ReDriver"></a>ReDriver</h2><p>Redriver能减弱信号在远距离、高噪声环境的传输中的信号完整性问题对接收端的影响。</p>
<p>Redriver类似通信系统中的基站，其接收传输线路中的信号，重新生成原始信号，再转发给远端设备；其输出信号基本和原始信号完全一致以保证接收端能正常解析信号。</p>
<p>(1)PCIe redriver</p>
<p>以典型的高速信号PCIe接口为例，其使用Redriver和Retimer提高信号完整性，参考：<a target="_blank" rel="noopener" href="https://www.allaboutcircuits.com/industry-articles/choosing-the-right-redriver-or-retimer-device-to-extend-pcie-protocol-signal-range/">Choosing the Right Redriver or Retimer Device to Extend PCIe Protocol Signal Range</a></p>
<p>其RX, EQ接收PCIe信号源的TX, EQ信号，redrive生成原始信号后再从TX, EQ发送给接收端。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101126665.png" alt="Single lane redriver block diagram"></p>
<p>(2)USB redriver</p>
<p>以多层子设备结构的USB接口为例，其使用Redriver提高子USB host的驱动能力，参考 <a target="_blank" rel="noopener" href="https://www.diodes.com/zh/products/connectivity-and-timing/redrivers-repeaters/">信号完整性 - ReDriver&#x2F; 信号中继器 &#x2F; 调节器</a></p>
<p><img src="https://www.diodes.com/assets/Uploads/redrivers-application2__ResizedImageWzYwMCwzNTFd.png" alt="redrivers application2"></p>
<p>(3)SD redriver</p>
<p>即使是较低速的SD接口(MB&#x2F;s级别)也有PCB设计和传输距离引起的信号完整性问题，也需要redriver解决。</p>
<p>如下SD redriver接收SD host的几个信号并重新生成：SD clock, SD cmd, SD data, Vdd power。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202304101130119.png" alt="image-20230410113046013"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/03/28/Github%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9Alinked-list-good-taste/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/28/Github%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9Alinked-list-good-taste/" class="post-title-link" itemprop="url">Github项目学习：linked-list-good-taste</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-28 10:30:15" itemprop="dateCreated datePublished" datetime="2023-03-28T10:30:15+08:00">2023-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-04 11:00:31" itemprop="dateModified" datetime="2023-05-04T11:00:31+08:00">2023-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/github%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">github项目学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转载自 <a target="_blank" rel="noopener" href="https://github.com/mkirchner/linked-list-good-taste">linked-list-good-taste</a>，添加了个人理解的注释</p>
<h1 id="Linked-lists-pointer-tricks-and-good-taste"><a href="#Linked-lists-pointer-tricks-and-good-taste" class="headerlink" title="Linked lists, pointer tricks and good taste"></a>Linked lists, pointer tricks and good taste</h1><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-code">The code</a><ul>
<li><a href="#the-cs101-version">The CS101 version</a></li>
<li><a href="#a-more-elegant-solution">A more elegant solution</a></li>
</ul>
</li>
<li><a href="#how-does-it-work">How does it work?</a><ul>
<li><a href="#integrating-the-head-pointer">Integrating the head pointer</a></li>
<li><a href="#maintaining-a-handle">Maintaining a handle</a></li>
</ul>
</li>
<li><a href="#going-beyond">Going beyond</a><ul>
<li><a href="#inserting-before-existing-items">Inserting before existing items</a></li>
<li><a href="#quick-refactor">Quick refactor</a></li>
<li><a href="#implementing-insert_before">Implementing insert_before()</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In a 2016 <a target="_blank" rel="noopener" href="https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux">TED interview</a> (14:10) Linus Torvalds speaks about what he considers <em>good taste</em> in coding. As an example, he presents two implementations of item removal in singly linked lists (reproduced below).  In order to remove the first item from a list, one of the implementations requires a special case, the other one does not.  Linus, obviously, prefers the latter.</p>
<p>His comment is:</p>
<blockquote>
<p>[…] I don’t want you to understand why it doesn’t have the if statement.<br>But I want you to understand that sometimes you can see a problem in a<br>different way and rewrite it so that a special case goes away and becomes the<br>normal case, and that’s <em>good code</em>. […] – L. Torvalds</p>
</blockquote>
<p>The code snippets he presents are C-style pseudocode and are simple enough to follow. However, as Linus mentions in the comment, the snippets lack a conceptual explanation and it is not immediately evident how the more elegant solution actually works.</p>
<p>The next two sections look at the technical approach in detail and demonstrate how and why the indirect addressing approach is so neat. The last section extends the solution from item deletion to insertion.</p>
<h2 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h2><p>The basic data structure for a singly linked list of integers is shown in Figure 1.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281032617.png" alt="linked list"></p>
<p>Numbers are arbitrarily chosen integer values and arrows indicate pointers. <code>head</code> is a pointer of type <code>list_item *</code> and each of the boxes is an instance of an <code>list_item</code> struct, each with a member variable (called <code>next</code> in the code) of type <code>list_item *</code> that points to the next item.</p>
<p>The C implementation of the data structure is:</p>
<p><strong>注释：list的item包含两个成员：值和指针变量；list本身是用head指针表示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> <span class="title">list_item</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_item</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We also include a (minimal) API:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The textbook version */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br><span class="line"><span class="comment">/* A more elegant solution */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span>;</span><br></pre></td></tr></table></figure>

<p>With that in place, let’s have a look at the implementations of <code>remove_cs101()</code> and <code>remove_elegant()</code>. The code of these examples is true to the pseudocode from Linus’ example and also compiles and runs.</p>
<h3 id="The-CS101-version"><a href="#The-CS101-version" class="headerlink" title="The CS101 version"></a>The CS101 version</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281919267.png" alt="image-20230328191958119"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_cs101</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item *cur = l-&gt;head, *prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != target) &#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev)</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                l-&gt;head = cur-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释：如果将list理解为(值+指针变量)成员组成的一串数据，那么访问一个成员的前置成员就得用经典的双指针法，因为单链表没有”记忆性”，要额外的前置指针保存前置位置。</strong></p>
<p><strong>考虑边界条件：1.遍历完了都找不到目标成员；2.前置指针在使用前要判空，如果为空，表明第一个节点就是目标节点，这两种情况都属于上述代码的else case处理</strong></p>
<p>The standard CS101 approach makes use of two traversal pointers <code>cur</code> and <code>prev</code>, marking the current and previous traversal position in the list, respectively.  <code>cur</code> starts at the list head <code>head</code>, and advances until the target is found.  <code>prev</code> starts at <code>NULL</code> and is subsequently updated with the previous value of <code>cur</code> every time <code>cur</code> advances. After the target is found, the algorithm tests if <code>prev</code> is non-<code>NULL</code>. If yes, the item is not at the beginning of the list and the removal consists of re-routing the linked list around <code>cur</code>. If <code>prev</code> is <code>NULL</code>, <code>cur</code> is pointing to the first element in the list, in which case, removal means moving the list head forward.</p>
<h3 id="A-more-elegant-solution"><a href="#A-more-elegant-solution" class="headerlink" title="A more elegant solution"></a>A more elegant solution</h3><p>The more elegant version has less code and does not require a separate branch to deal with deletion of the first element in a list.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code uses an indirect pointer <code>p</code> that holds the address of a pointer to a list item, starting with the address of <code>head</code>.  In every iteration, that pointer is advanced to hold the address of the pointer to the next list item, i.e. the address of the <code>next</code> element in the current <code>list_item</code>.<br>When the pointer to the list item <code>*p</code> equals <code>target</code>, we exit the search loop and remove the item from the list.</p>
<h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h2><p>The key insight is that using an indirect pointer <code>p</code> has two conceptual benefits:</p>
<ol>
<li>It allows us to interpret the linked list in a way that makes the <code>head</code> pointer an integral part the data structure. This eliminates the need for a special case to remove the first item.</li>
<li>It also allows us to evaluate the condition of the <code>while</code> loop without having to let go of the pointer that points to <code>target</code>. This allows us to modify the pointer that points to <code>target</code> and to get away with a single iterator as opposed to <code>prev</code> and <code>cur</code>.</li>
</ol>
<p>Let’s look each of these points in turn.</p>
<h3 id="Integrating-the-head-pointer"><a href="#Integrating-the-head-pointer" class="headerlink" title="Integrating the head pointer"></a>Integrating the <code>head</code> pointer</h3><p>The standard model interprets the linked list as a sequence of <code>list_item</code> instances. The beginning of the sequence can be accessed through a <code>head</code> pointer. This leads to the conceptual model illustrated in Figure 2 above. The <code>head</code> pointer is merely considered as a handle to access the start of the list. <code>prev</code> and <code>cur</code> are pointers of type <code>list_item *</code> and always point to an item or <code>NULL</code>.</p>
<p>The elegant implementation uses indirect addressing scheme that yields a different view on the data structure:</p>
<p><strong>注释：核心就是改变对链表数据结构的理解，将链表的最小单元理解为：前置指针 + (值+指针变量)成员，这样需要一个二级指针指向成员内的指针变量，链表也没有特殊性，每个成员一定有非空的前置指针和(值+指针变量)，如下图的蓝色框。</strong></p>
<p><strong>这个方法本质上是双指针的优化，只用一个二级指针就可以同时访问目标节点和前置的节点的指针变量，解决了单链表遍历过程中，找到目标节点后无法反向获得前置节点的指针变量的问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303281920824.png" alt="image-20230328192017690"></p>
<p>Here, <code>p</code> is of type <code>list_item **</code> and holds the address of the pointer to the current list item. When we advance the pointer, we forward to the address of the pointer to the next list item.</p>
<p>In code, this translates to <code>p = &amp;(*p)-&gt;next</code>, meaning we</p>
<ol>
<li><code>(*p)</code>: dereference the address to the pointer to the current list item</li>
<li><code>-&gt;next</code>: dereference that pointer again and select the field that holds the address of the next list item</li>
<li><code>&amp;</code>: take the address of that address field (i.e. get a pointer to it)</li>
</ol>
<p>This corresponds to an interpretation of the data structure where the list is a a sequence of pointers to <code>list_item</code>s (cf. Figure 3).</p>
<h3 id="Maintaining-a-handle"><a href="#Maintaining-a-handle" class="headerlink" title="Maintaining a handle"></a>Maintaining a handle</h3><p>An additional benefit of that particular interpretation is that it supports editing the <code>next</code> pointer of the predecessor of the current item throughout the entire traversal.</p>
<p>With <code>p</code> holding the address of a pointer to a list item, the comparison in the search loop becomes</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (*p != target)</span><br></pre></td></tr></table></figure>

<p>The search loop will exit if <code>*p</code> equals <code>target</code>, and once it does, we are still able to modify <code>*p</code> since we hold its address <code>p</code>. Thus, despite iterating the loop until we hit <code>target</code>, we still maintain a handle (the address of the <code>next</code> field or the <code>head</code> pointer) that can be used to directly modify the pointer that points <em>to</em> the item.</p>
<p>This is the reason why we can modify the incoming pointer to an item to point to a different location using <code>*p = target-&gt;next</code> and why we do not need <code>prev</code> and <code>cur</code> pointers to traverse the list for item removal.</p>
<h2 id="Going-beyond"><a href="#Going-beyond" class="headerlink" title="Going beyond"></a>Going beyond</h2><p>It turns out that the idea behind <code>remove_elegant()</code> can be applied to yield a particularly concise implementation of another function in the list API:<code>insert_before()</code>, i.e. inserting a given item before another one.</p>
<h3 id="Inserting-before-existing-items"><a href="#Inserting-before-existing-items" class="headerlink" title="Inserting before existing items"></a>Inserting before existing items</h3><p>First, let’s add the following declaration to the list API in <code>list.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span>;</span><br></pre></td></tr></table></figure>

<p>The function will take a pointer to a list <code>l</code>, a pointer <code>before</code> to an item in that list and a pointer to a new list item <code>item</code> that the function will insert before <code>before</code>.</p>
<h3 id="Quick-refactor"><a href="#Quick-refactor" class="headerlink" title="Quick refactor"></a>Quick refactor</h3><p><strong>注释：单链表的删除节点和前向插入节点有共同的痛点：找到目标节点后无法反向获得前置节点的指针变量，此二级指针方法完美解决这类问题。</strong></p>
<p>Before we move on, we refactor the search loop into a separate function</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> list_item **<span class="title function_">find_indirect</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = &amp;l-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (*p != target)</span><br><span class="line">                p = &amp;(*p)-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>and use that function in <code>remove_elegant()</code> like so</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove_elegant</span><span class="params">(<span class="built_in">list</span> *l, list_item *target)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, target);</span><br><span class="line">        *p = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Implementing-insert-before"><a href="#Implementing-insert-before" class="headerlink" title="Implementing insert_before()"></a>Implementing <code>insert_before()</code></h3><p>Using <code>find_indirect()</code>, it is straightforward to implement <code>insert_before()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_before</span><span class="params">(<span class="built_in">list</span> *l, list_item *before, list_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">        list_item **p = find_indirect(l, before);</span><br><span class="line">        *p = item;</span><br><span class="line">        item-&gt;next = before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A particularly beautiful outcome is that the implementation has consistent semantics for the edge cases: if <code>before</code> points to the list head, the new item will be inserted at the beginning of the list, if <code>before</code> is <code>NULL</code> or invalid (i.e. the item does not exist in <code>l</code>), the new item will be appended at the end.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The premise of the more elegant solution for item deletion is a single, simple change: using an indirect <code>list_item **</code> pointer to iterate over the pointers to the list items.  Everything else flows from there: there is no need for a special case or branching and a single iterator is sufficient to find and remove the target item.<br>It also turns out that the same approach provides an elegant solution for item insertion in general and for insertion <em>before</em> an existing item in particular.</p>
<p>So, going back to Linus’ initial comment: is it good taste? Hard to say, but it’s certainly a different, creative and very elegant solution to a well-known CS task.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/03/15/hexo%E5%92%8Cnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/15/hexo%E5%92%8Cnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">hexo和next主题的配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-15 12:00:15" itemprop="dateCreated datePublished" datetime="2023-03-15T12:00:15+08:00">2023-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-21 20:36:31" itemprop="dateModified" datetime="2023-03-21T20:36:31+08:00">2023-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="hexo相关配置"><a href="#hexo相关配置" class="headerlink" title="hexo相关配置"></a>hexo相关配置</h3><p>hexo各页面的配置，参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3a05351a37dc">jianshu-Hexo的Next主题详细配置</a></p>
<p>hexo主页显示摘要，参考 <a target="_blank" rel="noopener" href="https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%20Next%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E6%96%87%EF%BC%89/">Hexo Next主题首页配置为只显示部分摘要</a></p>
<h3 id="next设置字体"><a href="#next设置字体" class="headerlink" title="next设置字体"></a>next设置字体</h3><p>参考 <a target="_blank" rel="noopener" href="https://tzynwang.github.io/2021/next-theme-edit/#:~:text=Search%20for%20the%20font%20family%20%E2%80%9CRoboto%E2%80%9D%20Click%20%E2%80%9C%2B,as%20the%20value%20for%20%E2%80%9Chost%E2%80%9D%20key%20in%20_config.next.yml">tzynwang.github.io&#x2F;2021&#x2F;next-theme-edit</a></p>
<p>下面重点描述如何使用Google Font来配置next主题的字体，基于next version 8.0.0</p>
<ul>
<li>推荐英文字体使用Roboto，中文字体使用 Noto Serif (注：Noto Serif字符集包含chinese&#x2F;Japanese&#x2F;korea等，参考 <a target="_blank" rel="noopener" href="https://github.com/notofonts/noto-cjk">noto-cjk</a>；Noto Serif 是宋体但不是宋体思源，见后文)</li>
<li>在<a target="_blank" rel="noopener" href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索框搜索字体英文名添加以上两种字体，产生URI(Uniform Resource Identifier)，复制href字段的引号内容</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151454240.png" alt="image-20230315145422134"></p>
<ul>
<li>在hexo的next配置文件<code>hexo\themes\next\_config.yml</code>的font字段添加host URI和字体名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span><br><span class="line">  host: https://fonts.googlefonts.cn/css?family=Noto+Serif|Roboto</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: x.x`. Use `em` as unit. Default: 1 (16px)</span><br><span class="line"></span><br><span class="line">  # Global font settings used for all elements inside &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Noto Serif</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for site title (.site-title).</span><br><span class="line">  title:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for posts (.post-body).</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto</span><br></pre></td></tr></table></figure>

<ul>
<li>在静态页面的base style配置文件<code>hexo\themes\next\source\css\_variables\base.styl</code>指定中文字体font-family-chinese为’Noto Serif’（注意看这里get_font_family解析到next配置文件_config.yml的字段’global’, ‘title’ … ‘codes’等作为静态页面的配置）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Font families.</span><br><span class="line">$font-family-chinese      = &#x27;Noto Serif&#x27;;</span><br><span class="line"></span><br><span class="line">$font-family-base         = $font-family-chinese, sans-serif;</span><br><span class="line">$font-family-base         = get_font_family(&#x27;global&#x27;), $font-family-chinese, sans-serif if get_font_family(&#x27;global&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-logo         = $font-family-base;</span><br><span class="line">$font-family-logo         = get_font_family(&#x27;title&#x27;), $font-family-base if get_font_family(&#x27;title&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-headings     = $font-family-base;</span><br><span class="line">$font-family-headings     = get_font_family(&#x27;headings&#x27;), $font-family-base if get_font_family(&#x27;headings&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-posts        = $font-family-base;</span><br><span class="line">$font-family-posts        = get_font_family(&#x27;posts&#x27;), $font-family-base if get_font_family(&#x27;posts&#x27;);</span><br><span class="line"></span><br><span class="line">$font-family-monospace    = monospace, consolas, Menlo, $font-family-chinese;</span><br><span class="line">$font-family-monospace    = get_font_family(&#x27;codes&#x27;), monospace, consolas, Menlo, $font-family-chinese if get_font_family(&#x27;codes&#x27;);</span><br></pre></td></tr></table></figure>

<p>自此next中英文字体都应该生效，<code>hexo g + hexo s</code> 重新部署验证一下发现中文字体似乎不是思源宋体？</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151606100.png" alt="image-20230315160648032"></p>
<p>原因是Noto Serif !&#x3D; Noto Serif SC (simplified chinese)，Noto Serif SC才是思源宋体</p>
<p><a target="_blank" rel="noopener" href="https://www.googlefonts.cn/">Google字体中国网站</a>搜索不到思源宋体，<a target="_blank" rel="noopener" href="https://fonts.google.com/">google font原站</a>又打不开，因此需要直接替换URI，将fonts.googlefonts.cn替换为fonts.googleapis.com，Noto Serif替换为Noto Serif SC</p>
<p>next配置文件改动如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hexo\themes\next\_config.yml:</span><br><span class="line"></span><br><span class="line">font:</span><br><span class="line">    - host: https://fonts.googlefonts.cn/css?family=Noto+Serif|Roboto</span><br><span class="line">    + host: https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto</span><br><span class="line"></span><br><span class="line">    global:</span><br><span class="line">    - family: Noto Serif</span><br><span class="line">    + family: Noto Serif SC</span><br><span class="line">    </span><br><span class="line">hexo\themes\next\source\css\_variables\base.styl:</span><br><span class="line"></span><br><span class="line">// Font families.</span><br><span class="line">- $font-family-chinese = &#x27;Noto Serif&#x27;;</span><br><span class="line">+ $font-family-chinese = &#x27;Noto Serif SC&#x27;;</span><br></pre></td></tr></table></figure>

<p>验证结果为思源宋体：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303151559719.png" alt="image-20230315155911647"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/03/09/Linux%20kernel%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%92%8Cpatch%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/09/Linux%20kernel%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%92%8Cpatch%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Linux kernel代码提交和patch使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-09 15:19:37" itemprop="dateCreated datePublished" datetime="2023-03-09T15:19:37+08:00">2023-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-04 11:31:27" itemprop="dateModified" datetime="2023-09-04T11:31:27+08:00">2023-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文描述：如何参与到Linux kernel社区中，为Linux kernel提交Patch代码；以Linux子系统MMC&#x2F;SD为例介绍如何使用patch。</p>
<h2 id="Linux-kernel提交代码的基本概念"><a href="#Linux-kernel提交代码的基本概念" class="headerlink" title="Linux kernel提交代码的基本概念"></a>Linux kernel提交代码的基本概念</h2><h3 id="如何参与Linux内核开发"><a href="#如何参与Linux内核开发" class="headerlink" title="如何参与Linux内核开发"></a>如何参与Linux内核开发</h3><p>Linux kernel的官方网站：<a target="_blank" rel="noopener" href="https://kernel.org/">kernel.org</a></p>
<p>kernel.org内的中文文档：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/translations/zh_CN/process/howto.html">如何参与Linux内核开发</a>, 其中最常用的：</p>
<ul>
<li>内核源码库：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a> 在线查看kernel源码而无需git下载</li>
<li>内核子系统(subsystem)的补丁(patch)列表：<a target="_blank" rel="noopener" href="https://patchwork.kernel.org/">https://patchwork.kernel.org/</a> 显示正在发布、评论或修订的patch： </li>
<li>内核邮件列表的存档(archive)：<a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/">https://lore.kernel.org/lkml/</a> 所有正在进行或已存档的patchwork都能在此找到邮件记录：</li>
</ul>
<h3 id="如何提交Patch"><a href="#如何提交Patch" class="headerlink" title="如何提交Patch"></a>如何提交Patch</h3><p>Patch是提交到kernel之前的一个阶段，由kernel subsystem maintainer review后<strong>有机会</strong>进入Linux kernel Mainline。事实上绝大所述patch最终未进入Linux kernel Mainline，仅存档到了邮件列表，在lore&#x2F;patchwork.kernel.org可查看这部分patch的内容和提交过程。</p>
<ul>
<li><p>提交Patch的总体规范参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.kernel.org/translations/zh_CN/process/submitting-patches.html">提交补丁：如何让你的改动进入内核</a></p>
</li>
<li><p>具体地讲如何向kernel提交patch和使用patch（需要详细看）: </p>
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v4.11/process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v4.11/process/applying-patches.html?highlight=applying%20patches%20linux%20kernel">Applying Patches To The Linux Kernel</a></p>
</li>
<li><p>关于patch命令如何使用，参考： </p>
<p><a target="_blank" rel="noopener" href="https://www.thegeekstuff.com/2014/12/patch-command-examples/">patch-command-examples</a></p>
<p><a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man1/patch.1.html">patch(1) — Linux manual page</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dl0914791011/article/details/17299103">Linux下生成patch和打patch</a></p>
</li>
</ul>
<h2 id="示例：Linux-MMC子系统中UHS-II-Patch的演化过程"><a href="#示例：Linux-MMC子系统中UHS-II-Patch的演化过程" class="headerlink" title="示例：Linux MMC子系统中UHS-II Patch的演化过程"></a>示例：Linux MMC子系统中UHS-II Patch的演化过程</h2><h3 id="Linux-MMC子系统的现状"><a href="#Linux-MMC子系统的现状" class="headerlink" title="Linux MMC子系统的现状"></a>Linux MMC子系统的现状</h3><p>MMC子系统主要包含SD card, eMMC card, SDIO几部分，Kernel Mainline的支持情况参考：<a target="_blank" rel="noopener" href="https://elinux.org/images/9/91/Clement-sd-mmc-high-speed-support-in-linux-kernel_0.pdf#:~:text=%E2%96%B6New%20speed%20modes%20%28name%20are%20base%20on%20the,the%203.3V%20forDS%28Default%20Speed25MHz%29%20andHS%28High%20Speed%20at%2050MHz%29">SD&#x2F;eMMC: new speed modes and their support in Linux</a></p>
<p>这里只关注SD card, Kernel Mainline在当前时间点（kernel 6.2）：</p>
<ul>
<li>不支持UHS-II (SD 4.0 specification)</li>
<li>SD express(SD 7.0 specification)在Kernel 5.11版本以后是支持的</li>
<li>SD UHS-I (SD 3.0 specification)和更老版本的SD协议则在kernel 3.0就已经支持</li>
</ul>
<h3 id="Linux-MMC-UHS-II-patch的演变"><a href="#Linux-MMC-UHS-II-patch的演变" class="headerlink" title="Linux MMC UHS-II patch的演变"></a>Linux MMC UHS-II patch的演变</h3><p>Linux MMC子系统的维护者可以在<a target="_blank" rel="noopener" href="https://patchwork.kernel.org/">patchwork.kernel.org</a>的MMC development的about页面看到：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091635752.png" alt="image-20230309163541697"></p>
<p>在patch页面可以搜索以<a target="_blank" rel="noopener" href="https://patchwork.kernel.org/project/linux-mmc/list/?q=UHS-II&archive=both&series=&submitter=&delegate=&state=*">UHS-II为关键字的相关patch</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091621148.png" alt="image-20230309162128061">结果如下：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091623615.png" alt="image-20230309162327522"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091623615.png"> </p>
<p>具体看一下上面这些UHS-II patch的内容和reviewer的评论：</p>
<p>1.首次提交是<a target="_blank" rel="noopener" href="https://patchwork.kernel.org/project/linux-mmc/patch/1419672479-30852-2-git-send-email-yi.y.sun@intel.com/">Intel的yisun</a>, 该patch被MMC维护者Ulf Hansson评论：应该split it up，之后就没有再修改和提交。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[RFC,1/2] mmc: core: support UHS-II in core stack.</span><br><span class="line"></span><br><span class="line">Commit Message</span><br><span class="line"></span><br><span class="line">[yisun1](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=102631)Dec. 27, 2014, 9:27 a.m. UTC</span><br><span class="line"></span><br><span class="line">This patch adds the UHS-II support in core layer. This is a RFC patch for</span><br><span class="line">community review.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Yi Sun &lt;yi.y.sun@intel.com&gt;</span><br><span class="line">---</span><br><span class="line"> drivers/mmc/core/Makefile |    3 +-</span><br><span class="line"> drivers/mmc/core/bus.c    |    5 +-</span><br><span class="line"> drivers/mmc/core/core.c   |   89 ++++-</span><br><span class="line"> drivers/mmc/core/sd.c     |   15 +</span><br><span class="line"> drivers/mmc/core/sd_ops.c |   12 +</span><br><span class="line"> drivers/mmc/core/uhs2.c   |  908 +++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> drivers/mmc/core/uhs2.h   |   26 ++</span><br><span class="line"> include/linux/mmc/core.h  |    6 +</span><br><span class="line"> include/linux/mmc/host.h  |   27 ++</span><br><span class="line"> include/linux/mmc/uhs2.h  |  274 ++++++++++++++</span><br><span class="line"> 10 files changed, 1356 insertions(+), 9 deletions(-)</span><br><span class="line"> create mode 100644 drivers/mmc/core/uhs2.c</span><br><span class="line"> create mode 100644 drivers/mmc/core/uhs2.h</span><br><span class="line"> create mode 100644 include/linux/mmc/uhs2.h</span><br><span class="line"></span><br><span class="line">Comments</span><br><span class="line"></span><br><span class="line">[Ulf Hansson](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=45281)Jan. 21, 2015, 10:31 a.m. UTC | [#1](https://patchwork.kernel.org/comment/12007791/)</span><br><span class="line"></span><br><span class="line">Even if this an RFC, me and likely everybody else just stops from</span><br><span class="line">reviewing this patch by looking at the above change log.</span><br><span class="line"></span><br><span class="line">Is there a way to split it up?</span><br><span class="line"></span><br><span class="line">Kind regards</span><br><span class="line">Uffe</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Genesys的Ben Chuang, Jason Lai, Victor.shih 和linaro 的akashi 在Intel的UHS-II patch上不断提交修改后的UHS-II patch（V3~V6）跟随着Kernel版本不断演化，此patch完整内容可在GitLab查看 <a target="_blank" rel="noopener" href="https://gitlab.com/ben.chuang/linux-uhs2-gl9755">linux-uhs2-gl9755</a>，在patchwork也可以查看commit内容和review意见：<a target="_blank" rel="noopener" href="https://patchwork.kernel.org/project/linux-mmc/patch/20221213090047.3805-7-victor.shih@genesyslogic.com.tw/">V6 patch的第6&#x2F;24提交</a>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">[V6,06/24] mmc: core: Support UHS-II card control and access</span><br><span class="line"></span><br><span class="line">Commit Message </span><br><span class="line"></span><br><span class="line">[Victor Shih](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=207469) Dec. 13, 2022, 9 a.m. UTC</span><br><span class="line"></span><br><span class="line">Embed UHS-II access/control functionality into the MMC request</span><br><span class="line">processing flow.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Ulf Hansson &lt;ulf.hansson@linaro.org&gt;</span><br><span class="line">Signed-off-by: Jason Lai &lt;jason.lai@genesyslogic.com.tw&gt;</span><br><span class="line">Signed-off-by: Victor Shih &lt;victor.shih@genesyslogic.com.tw&gt;</span><br><span class="line">---</span><br><span class="line"> drivers/mmc/core/block.c   |    6 +-</span><br><span class="line"> drivers/mmc/core/core.c    |   20 +</span><br><span class="line"> drivers/mmc/core/mmc_ops.c |   25 +-</span><br><span class="line"> drivers/mmc/core/mmc_ops.h |    1 +</span><br><span class="line"> drivers/mmc/core/sd.c      |   11 +-</span><br><span class="line"> drivers/mmc/core/sd.h      |    3 +</span><br><span class="line"> drivers/mmc/core/sd_ops.c  |   13 +</span><br><span class="line"> drivers/mmc/core/sd_ops.h  |    3 +</span><br><span class="line"> drivers/mmc/core/sd_uhs2.c | 1171 +++++++++++++++++++++++++++++++++++-</span><br><span class="line"> 9 files changed, 1206 insertions(+), 47 deletions(-)</span><br><span class="line"></span><br><span class="line">Comments</span><br><span class="line"></span><br><span class="line">[Adrian Hunter](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=31052) Jan. 5, 2023, 9:26 p.m. UTC | [#1](https://patchwork.kernel.org/comment/25148889/)</span><br><span class="line"></span><br><span class="line">&gt; +u32 sd_uhs2_select_voltage(struct mmc_host *host, u32 ocr)</span><br><span class="line">&gt; +&#123;</span><br><span class="line">...</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +	if (host-&gt;caps2 &amp; MMC_CAP2_FULL_PWR_CYCLE) &#123;</span><br><span class="line">&gt; +		bit = ffs(ocr) - 1;</span><br><span class="line">&gt; +		ocr &amp;= 3 &lt;&lt; bit;</span><br><span class="line">&gt; +		/* Power cycle */</span><br><span class="line">&gt; +		err = sd_uhs2_power_off(host);</span><br><span class="line">&gt; +		if (err)</span><br><span class="line">&gt; +			return 0;</span><br><span class="line">&gt; +		err = sd_uhs2_reinit(host);</span><br><span class="line"></span><br><span class="line">This looks circular:</span><br><span class="line"></span><br><span class="line">sd_uhs2_select_voltage</span><br><span class="line">-&gt; sd_uhs2_reinit</span><br><span class="line">   -&gt; sd_uhs2_init_card</span><br><span class="line">      -&gt; sd_uhs2_legacy_init</span><br><span class="line">         -&gt; sd_uhs2_select_voltage</span><br><span class="line"></span><br><span class="line">[Ulf Hansson](https://patchwork.kernel.org/project/linux-mmc/list/?submitter=45281) Feb. 8, 2023, 3:30 p.m. UTC | [#2](https://patchwork.kernel.org/comment/25202573/)</span><br><span class="line"></span><br><span class="line">&gt; diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span><br><span class="line">&gt; index 20da7ed43e6d..d3e8ec43cdd5 100644</span><br><span class="line">&gt; --- a/drivers/mmc/core/block.c</span><br><span class="line">&gt; +++ b/drivers/mmc/core/block.c</span><br><span class="line">&gt; @@ -1596,6 +1596,9 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;         struct request *req = mmc_queue_req_to_req(mqrq);</span><br><span class="line">&gt;         struct mmc_blk_data *md = mq-&gt;blkdata;</span><br><span class="line">&gt;         bool do_rel_wr, do_data_tag;</span><br><span class="line">&gt; +       bool do_multi;</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +       do_multi = (card-&gt;uhs2_state &amp; MMC_UHS2_INITIALIZED) ? true : false;</span><br><span class="line">&gt;</span><br><span class="line">&gt;         mmc_blk_data_prep(mq, mqrq, recovery_mode, &amp;do_rel_wr, &amp;do_data_tag);</span><br><span class="line">&gt;</span><br><span class="line">&gt; @@ -1606,7 +1609,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;                 brq-&gt;cmd.arg &lt;&lt;= 9;</span><br><span class="line">&gt;         brq-&gt;cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;</span><br><span class="line">&gt;</span><br><span class="line">&gt; -       if (brq-&gt;data.blocks &gt; 1 || do_rel_wr) &#123;</span><br><span class="line">&gt; +       if (brq-&gt;data.blocks &gt; 1 || do_rel_wr || do_multi) &#123;</span><br><span class="line"></span><br><span class="line">This looks wrong to me. UHS2 can use single block read/writes too. Right?</span><br><span class="line"></span><br><span class="line">&gt;                 /* SPI multiblock writes terminate using a special</span><br><span class="line">&gt;                  * token, not a STOP_TRANSMISSION request.</span><br><span class="line">&gt;                  */</span><br><span class="line">&gt; @@ -1619,6 +1622,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span><br><span class="line">&gt;                 brq-&gt;mrq.stop = NULL;</span><br><span class="line">&gt;                 readcmd = MMC_READ_SINGLE_BLOCK;</span><br><span class="line">&gt;                 writecmd = MMC_WRITE_BLOCK;</span><br><span class="line">&gt; +               brq-&gt;cmd.uhs2_tmode0_flag = 1;</span><br><span class="line"></span><br><span class="line">As &quot;do_multi&quot; is always set for UHS2, setting this flag here seems to</span><br><span class="line">be wrong/redundant.</span><br><span class="line"></span><br><span class="line">Anyway, if I understand correctly, the flag is intended to be used to</span><br><span class="line">inform the host driver whether the so-called 2L_HD_mode (half-duplex</span><br><span class="line">or full-duplex) should be used for the I/O request or not.</span><br><span class="line"></span><br><span class="line">To fix the above behaviour, I suggest we try to move the entire</span><br><span class="line">control of the flag into mmc_uhs2_prepare_cmd(). We want the flag to</span><br><span class="line">be set for multi block read/writes (CMD18 and CMD25), but only if the</span><br><span class="line">host and card supports the 2L_HD_mode too. According to my earlier</span><br><span class="line">suggestions, we should be able to check that via the bits we set</span><br><span class="line">earlier in the ios-&gt;timing.</span><br><span class="line"></span><br><span class="line">Moreover, by making mmc_uhs2_prepare_cmd() responsible for setting the</span><br><span class="line">flag, I think we can also move the definition of the flag into the</span><br><span class="line">struct uhs2_command. While at it, I suggest we also rename the flag</span><br><span class="line">into &quot;tmode_half_duplex&quot;, to better describe its purpose, which also</span><br><span class="line">means the interpretation of the flag becomes inverted.</span><br></pre></td></tr></table></figure>

<h2 id="详解Patch的使用"><a href="#详解Patch的使用" class="headerlink" title="详解Patch的使用"></a>详解Patch的使用</h2><p>Kernel document: <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/process/applying-patches.html#:~:text=A%20patch%20is%20a%20small%20text%20document%20containing,the%20patch%20will%20change%20the%20source%20tree%20into.">Applying Patches To The Linux Kernel</a></p>
<h3 id="Patch与git-diff"><a href="#Patch与git-diff" class="headerlink" title="Patch与git diff"></a>Patch与git diff</h3><p>Patch文件的内容实际是<code>git diff</code>命令的输出，git diff的输出定义为.diff文件或.patch文件，即可作为patch使用。打patch实际上就是按diff规则，解析diff&#x2F;patch文件，去改变本地的代码树和内容。</p>
<p>git diff说明文档参考 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-diff">git-diff</a>，比较常用的是使用<code>git diff [&lt;path&gt;…]</code>输出某个路径&#x2F;文件的差异；如果path为空，则输出当前git仓库所有文件的差异。</p>
<p>如下示例：在drivers&#x2F;mmc&#x2F;core&#x2F;block.c增加修改了<code>//AAAAAAAAA</code>，在drivers&#x2F;mmc&#x2F;core&#x2F;block.h增加了<code>//BBBBBBBBB</code>，以下详细说明git diff 输出的含义：</p>
<ul>
<li>diff –git a&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c b&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c：用git diff命令，比较a和b版本的drivers&#x2F;mmc&#x2F;core&#x2F;block.c，a和b是diff用来区分同名文件的标识，不是实际路径。</li>
<li>index 7fa83e5..8963e57：这个diff如果被commit提交，commit-id将是index值7fa83e5..8963e57。</li>
<li>— a&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c 和+++ b&#x2F;drivers&#x2F;mmc&#x2F;core&#x2F;block.c 同时存在：表示是对已存在的block.c文件有内容修改；与之相对的是某个文件只有+++或—，表示是新增文件文件，或者是删除了文件。</li>
<li>@@ -1829,6 +1829,8 @@ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)：该修改代码所在的行数以及所在的函数名。</li>
<li>+&#x2F;&#x2F;AAAAAAAAA：具体的修改内容，+是新增，-是删除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span><br><span class="line">index 7fa83e5..8963e57 100644</span><br><span class="line">--- a/drivers/mmc/core/block.c</span><br><span class="line">+++ b/drivers/mmc/core/block.c</span><br><span class="line">@@ -1829,6 +1829,8 @@ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)</span><br><span class="line">        u32 blocks;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">+//AAAAAAAAA</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">diff --git a/drivers/mmc/core/block.h b/drivers/mmc/core/block.h</span><br><span class="line">index 31153f6..5501895 100644</span><br><span class="line">--- a/drivers/mmc/core/block.h</span><br><span class="line">+++ b/drivers/mmc/core/block.h</span><br><span class="line">@@ -17,4 +17,6 @@ struct work_struct;</span><br><span class="line"></span><br><span class="line"> void mmc_blk_mq_complete_work(struct work_struct *work);</span><br><span class="line"></span><br><span class="line">+//BBBBBBBBB</span><br><span class="line"></span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure>

<p>如果是已经git commit的两个版本之间的diff, 可直接产生所有修改内容的diff文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff commit-a commit-b</span><br></pre></td></tr></table></figure>

<p>一般提交给Kernel社区的patch需要按功能和文件拆分成多个patch提交，也就是说应该对某个文件或者路径git diff, 而不建议直接对版本所有文件git diff。例如以上patch可以分为两个diff，内容等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff drivers/mmc/core/block.c</span><br><span class="line"></span><br><span class="line">git diff drivers/mmc/core/block.h</span><br></pre></td></tr></table></figure>

<h3 id="Patch与kernel版本"><a href="#Patch与kernel版本" class="headerlink" title="Patch与kernel版本"></a>Patch与kernel版本</h3><p>为了正确打一个补丁，你需要知道这个补丁是从哪个基础代码版本(base)产生的，以及这个补丁会使源码树升级成哪个版本。</p>
<h4 id="用于Kernel升级的官方patch"><a href="#用于Kernel升级的官方patch" class="headerlink" title="用于Kernel升级的官方patch"></a>用于Kernel升级的官方patch</h4><p>在kernel.org可以看到有很多Kernel版本之间有patch可以用于升级kernel，例如从kernel 4.19.275升级到5.4.234，可以下载并安装patch-5.4.234.xz</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091942357.png" alt="image-20230309194230288"></p>
<h4 id="patchwork社区的第三方patch"><a href="#patchwork社区的第三方patch" class="headerlink" title="patchwork社区的第三方patch"></a>patchwork社区的第三方patch</h4><p>可以下载diff或者series去获取patch文件，根据patch提交时间和代码上下文大致估计当时的Kernel版本</p>
<ul>
<li>diff: 当前patch的diff, 由于一个大patch可能被拆分为多个小patch，此文件通常为某个小patch</li>
<li>mbox: 在diff基础上包含了邮件信息（MIME信息）</li>
<li>series: 整个功能的所有patch系列的mbox合并内容，包括邮件信息（MIME信息）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303091945285.png" alt="image-20230309194559245"></p>
<p>Patch命令使用以上的.diff文件，有的也命名为.patch文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; xxx.diff</span><br></pre></td></tr></table></figure>

<p>-p 表示path：跳过第几级目录；1 表示忽略第一级目录</p>
<p>例如diff如下时，第一级目录用a, b表示，patch -p1将忽略a, b，将drivers&#x2F;mmc&#x2F;xxx的diff内容打patch到当前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c</span><br><span class="line">index 86d2711..6565754 100644</span><br><span class="line">--- a/drivers/mmc/core/bus.c</span><br><span class="line">+++ b/drivers/mmc/core/bus.c</span><br><span class="line">@@ -308,8 +308,9 @@ int mmc_add_card(struct mmc_card *card)</span><br><span class="line"> 	&#125; else &#123;</span><br><span class="line"> 		pr_info(&quot;%s: new %s%s%s%s%s card at address %04x\n&quot;,</span><br><span class="line"> 			mmc_hostname(card-&gt;host),</span><br><span class="line">-			mmc_card_uhs(card) ? &quot;ultra high speed &quot; :</span><br><span class="line">-			(mmc_card_hs(card) ? &quot;high speed &quot; : &quot;&quot;),</span><br><span class="line">+			mmc_card_uhs2(card) ? &quot;ultra high speed 2 &quot; :</span><br><span class="line">+			(mmc_card_uhs(card) ? &quot;ultra high speed 1&quot; :</span><br><span class="line">+			(mmc_card_hs(card) ? &quot;high speed &quot; : &quot;&quot;)),</span><br><span class="line"> 			mmc_card_hs400(card) ? &quot;HS400 &quot; :</span><br><span class="line"> 			(mmc_card_hs200(card) ? &quot;HS200 &quot; : &quot;&quot;),</span><br><span class="line"> 			mmc_card_ddr52(card) ? &quot;DDR &quot; : &quot;&quot;,</span><br></pre></td></tr></table></figure>

<p>对于一个大功能的多个patch series，需要分别下载各diff文件； 或者一次下载series后手动删除所有MIME信息。</p>
<h4 id="如何寻找Patch对应的kernel版本"><a href="#如何寻找Patch对应的kernel版本" class="headerlink" title="如何寻找Patch对应的kernel版本"></a>如何寻找Patch对应的kernel版本</h4><p>如果Patch和kernel版本不匹配，patch命令无法合并patch到此kernel中，导致patch失败，因此打patch首先要确定其对应哪个kernel版本。</p>
<p>（1）如果patch commit是已提交到kernel的官方patch，则可以根据commit-id查找包含此commit的kernel版本，参考：<a target="_blank" rel="noopener" href="https://lwn.net/Articles/392293/">Finding a patch’s kernel version with git</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --contains &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>

<p>（2）大多数patch是没提交到kernel的第三方patch，因此patch中的index在kernel是找不到的，所以只能通过提交邮件的信息确定适用的kernel版本。</p>
<p>以前文提到的 <a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20201106022726.19831-2-takahiro.akashi@linaro.org/T/#u">RFC PATCH v3.1 16&#x2F;27</a>为例，patch是在提交时间点的kernel master版本或tag版本上测试的。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[auto build test WARNING on linus/master]</span><br><span class="line">[also build test WARNING on v5.10-rc2]</span><br><span class="line">[cannot apply to v3.1 next-20201105]</span><br><span class="line">[If your patch is applied to the wrong git tree, kindly drop us a note</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另外一个示例：提交者在提交信息中写了基于哪个kernel版本：<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20221213090047.3805-24-victor.shih@genesyslogic.com.tw/T/#u">Add support UHS-II for GL9755</a></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes in v6 (Dec. 12, 2022)</span><br><span class="line">* rebased to the linux-kernel-v6.1.0-rc8 in Ulf Hansson next branch.</span><br><span class="line"></span><br><span class="line">Changes in v5 (Oct. 19, 2022)</span><br><span class="line">* rebased to the linux-kernel-v6.1-rc1 in Ulf Hansson next branch.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果一个第三方patch没有任何kernel版本的信息，只能通过提交时间来尝试kernel，一般情况下不建议这种尝试，因为提交者使用的可能是当时最新的kernel, 也可能是一两个月前的kernel, 中间可能有很多-rc版本。</p>
<p>下面以<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/525EAED47491124EB5123A51BD2FC79101A30EE2@SHSMSX101.ccr.corp.intel.com/">RFC 0&#x2F;2 mmc: UHS-II implementation</a>为例，尝试寻找此patch可应用的kernel版本，此patch提交信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* RE: [RFC 0/2] mmc: UHS-II implementation</span><br><span class="line">  2014-12-27  9:27 [RFC 0/2] mmc: UHS-II implementation Yi Sun</span><br><span class="line">  2014-12-27  9:27 ` [RFC 1/2] mmc: core: support UHS-II in core stack Yi Sun</span><br><span class="line">  2014-12-27  9:27 ` [RFC 2/2] mmc: sdhci: support UHS-II in SDHCI host Yi Sun</span><br></pre></td></tr></table></figure>

<p>（1）首先在linux kernel git tag时间记录找到接近此patch提交时间的kernel版本：</p>
<p>在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux">linux kernel github</a> 下拉tag列表，找接近patch申请时间的kernel release版本，可见kernel version &lt; 4.0是此patch可能适用的版本</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131133722.png" alt="image-20230313113324650"></p>
<p>（2）patch内容的函数名和上下文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@ -248,6 +252,12 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)</span><br><span class="line"> 			mrq-&gt;stop-&gt;mrq = mrq;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">+</span><br><span class="line">+	if (host-&gt;flags &amp; MMC_UHS2_SUPPORT &amp;&amp;</span><br><span class="line">+	    host-&gt;flags &amp; MMC_UHS2_INITIALIZED)</span><br><span class="line">+		if (mrq-&gt;cmd-&gt;uhs2_cmd == NULL)</span><br><span class="line">+			uhs2_prepare_sd_cmd(host, mrq);</span><br><span class="line">+</span><br><span class="line"> 	mmc_host_clk_hold(host);</span><br><span class="line"> 	led_trigger_event(host-&gt;led, LED_FULL);</span><br><span class="line"> 	host-&gt;ops-&gt;request(host, mrq);</span><br></pre></td></tr></table></figure>

<p>（3）在 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.9/source/drivers/mmc/core/core.c#L264">bootlin</a> 找到kernel的同函数并对比上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (mrq-&gt;data) &#123;</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">	mrq-&gt;cmd-&gt;data = mrq-&gt;data;</span><br><span class="line">	mrq-&gt;data-&gt;error = 0;</span><br><span class="line">	mrq-&gt;data-&gt;mrq = mrq;</span><br><span class="line">	if (mrq-&gt;stop) &#123;</span><br><span class="line">		mrq-&gt;data-&gt;stop = mrq-&gt;stop;</span><br><span class="line">		mrq-&gt;stop-&gt;error = 0;</span><br><span class="line">		mrq-&gt;stop-&gt;mrq = mrq;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///// 此处为patch添加处</span><br><span class="line"></span><br><span class="line">led_trigger_event(host-&gt;led, LED_FULL);</span><br><span class="line">__mmc_start_request(host, mrq);</span><br><span class="line"></span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<p>在stable kernel版本上尝试此patch (跳过-rc版本)，首先找kernel tag早于此patch邮件的时间，尝试了kernel 3.18, 3.17都有patch fail，如下可见patch和kernel有少量代码offset能自动匹配，但是有些差异patch搞不定，例如有merge代码冲突会导致对应的Hunk # FAILED，hunk是patch中的diff –git的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~/linux-4.9$ patch -p1 &lt; RFC-1-2-mmc-core-support-UHS-II-in-core-stack..diff </span><br><span class="line">patching file drivers/mmc/core/Makefile</span><br><span class="line">Hunk #1 FAILED at 7.</span><br><span class="line">1 out of 1 hunk FAILED -- saving rejects to file drivers/mmc/core/Makefile.rej</span><br><span class="line">patching file drivers/mmc/core/bus.c</span><br><span class="line">Hunk #1 succeeded at 334 with fuzz 2 (offset 26 lines).</span><br><span class="line">patching file drivers/mmc/core/core.c</span><br><span class="line">Hunk #2 FAILED at 36.</span><br><span class="line">Hunk #3 succeeded at 63 with fuzz 2 (offset 6 lines).</span><br><span class="line">Hunk #4 FAILED at 250.</span><br><span class="line">Hunk #5 succeeded at 503 (offset 116 lines).</span><br><span class="line">Hunk #6 succeeded at 518 (offset 116 lines).</span><br><span class="line">Hunk #7 FAILED at 425.</span><br><span class="line">...</span><br><span class="line">6 out of 17 hunks FAILED -- saving rejects to file drivers/mmc/core/core.c.rej</span><br></pre></td></tr></table></figure>

<p>在kernel 3.18打此patch，只有一个fail，可以根据此fail进一步定位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hunk #13 FAILED at 2339.</span><br><span class="line">1 out of 17 hunks FAILED -- saving rejects to file drivers/mmc/core/core.c.rej</span><br></pre></td></tr></table></figure>

<p>core.c.rej 内容如下，注意这里的行号是已经经过patch操作被偏移的代码的行号，实际行号应该去patch原文件查看此hunk的行号，这里只看是什么函数名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--- drivers/mmc/core/core.c</span><br><span class="line">+++ drivers/mmc/core/core.c</span><br><span class="line">@@ -2339,7 +2391,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Set initial state and call mmc_set_ios */</span><br><span class="line">-       mmc_set_initial_state(host);</span><br><span class="line">+       /* TODO: need verify this for UHS2. */</span><br><span class="line">+       if (!host-&gt;flags &amp; MMC_UHS2_SUPPORT)</span><br><span class="line">+               mmc_set_initial_state(host);</span><br><span class="line"></span><br><span class="line">        mmc_host_clk_release(host);</span><br></pre></td></tr></table></figure>

<p>patch原文件drivers&#x2F;mmc&#x2F;core&#x2F;core.c搜索函数名对应的hunk内容，得知代码行数是2287：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@@ -2287,7 +2339,9 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	/* Set initial state and call mmc_set_ios */</span><br><span class="line">-	mmc_set_initial_state(host);</span><br><span class="line">+	/* TODO: need verify this for UHS2. */</span><br><span class="line">+	if (!host-&gt;flags &amp; MMC_UHS2_SUPPORT)</span><br><span class="line">+		mmc_set_initial_state(host);</span><br><span class="line"> </span><br><span class="line"> 	mmc_host_clk_release(host);</span><br></pre></td></tr></table></figure>

<p>去bootlin.com查找<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.18/source/drivers/mmc/core/core.c">kernel 3.18的core.c代码</a>如下(直接搜索drivers&#x2F;mmc&#x2F;core&#x2F;core.c定位到文件，然后在core.c文件ctrl+F查找行数2287)，2287行对不上当然patch fail。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131921412.png" alt="image-20230313192134365"></p>
<p>根据patch提交时间，其大概率是使用3.18~4.0之间的kernel版本，因此搜寻3.18以后，且符合上面fail点的代码，首先就是<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.19/source/drivers/mmc/core/core.c">3.19版本</a>对比代码如下，可见2287开始的几行和patch完全对应：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303131917802.png" alt="image-20230313191733743"></p>
<p>打patch也全部通过未报错，所以3.19是此patch可适配的kernel版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~/linux-3.19$ patch -p1 &lt; RFC-1-2-mmc-core-support-UHS-II-in-core-stack..diff</span><br><span class="line">patching file drivers/mmc/core/Makefile</span><br><span class="line">patching file drivers/mmc/core/bus.c</span><br><span class="line">patching file drivers/mmc/core/core.c</span><br><span class="line">patching file drivers/mmc/core/sd.c</span><br><span class="line">patching file drivers/mmc/core/sd_ops.c</span><br><span class="line">patching file drivers/mmc/core/uhs2.c</span><br><span class="line">patching file drivers/mmc/core/uhs2.h</span><br><span class="line">patching file include/linux/mmc/core.h</span><br><span class="line">patching file include/linux/mmc/host.h</span><br><span class="line">patching file include/linux/mmc/uhs2.h</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/03/01/%E6%B5%85%E8%B0%88%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B9%8BPLL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E6%B5%85%E8%B0%88%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B9%8BPLL/" class="post-title-link" itemprop="url">浅谈数字电路之PLL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 11:40:15" itemprop="dateCreated datePublished" datetime="2023-03-01T11:40:15+08:00">2023-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-07 12:07:29" itemprop="dateModified" datetime="2023-03-07T12:07:29+08:00">2023-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IC/" itemprop="url" rel="index"><span itemprop="name">IC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文PLL的基础内容参考了Digital Integrated Circuits一书，下载方式：在 <a target="_blank" rel="noopener" href="https://vdoc.pub/">vdoc</a> 搜索关键字 Digital Integrated Circuits</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303011144938.jpeg" alt="img"></p>
<h2 id="PLL的应用概述"><a href="#PLL的应用概述" class="headerlink" title="PLL的应用概述"></a>PLL的应用概述</h2><p>两个作用：Clock Synthesis（时钟综合）和 Clock Synchronization（时钟同步）</p>
<ul>
<li>Clock Synthesis，Synthesis是综合&#x2F;生成的意思，Clock Synthesis即生成时钟，但此处含义不是作为时钟源，而是在低频晶振时钟的基础上倍频生成高频时钟：其中低频的晶振时钟的特性：10~200MHz， accurate, low-jitter ，高频时钟特性：200MHz ~ GHz级别，通常也称为系统时钟，例如SOC core的基准频率</li>
<li>Clock Synchronization，不同芯片之间传递时钟信号需要同步时钟相位，例如SOC的CPU和外设之间的通信接口一般是：分频后的时钟信号（reference clock）和数据信号（Date），CPU和外设间的信号传递是需要时间的，高速信号传递到外设侧有相位偏移（可以简单理解为延迟），因此需要PLL同步时钟相位以保证对数据采样的正确性（想象一下，如果reference clock相位偏移过大，可能每个采样时刻得到的data数据都是错位的）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031043844.png" alt="image-20230303104354744"></p>
<h2 id="相位的概念"><a href="#相位的概念" class="headerlink" title="相位的概念"></a>相位的概念</h2><p>Digital Integrated Circuits一书对相位的描述：</p>
<p>Periodic signals of known frequency can be discribed exactly by only one parameter, their<br>phase. More accurately a set of two or more periodic signals of the same frequency can be<br>well defined if we know one of them and its phase with respect to the other signals.  </p>
<p>翻译下就是：</p>
<ul>
<li><p>多个已知频率的周期信号只用一个参数就能精确区分：相位</p>
</li>
<li><p>如果这些信号的频率相同，则只需知道相位差就可以从一个信号精确推测另一个信号</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031634330.png" alt="image-20230303163446269"></p>
<p>基于以上概念，下面介绍PLL的两个核心功能：</p>
<ul>
<li>将输入PLL的时钟和PLL输出时钟的频率精确同步：输出时钟信号频率是输入时钟信号频率的精确的N倍</li>
<li>将输入PLL的时钟和PLL输出时钟的相位精确同步：输出时钟信号N分频后，其应该和输入信号完全一致，其上升&#x2F;下降沿应该精确对齐输入时钟信号的上升&#x2F;下降沿</li>
</ul>
<h2 id="PLL内部实现"><a href="#PLL内部实现" class="headerlink" title="PLL内部实现"></a>PLL内部实现</h2><p>PLL内部结构如下，真正核心的只有两个组件：</p>
<ul>
<li>VCO: The voltage-controlled oscillator (VCO) takes an analog control input and generates a clock signal of the desired frequency.  VCO接受电压（模拟信号），转换为频率（数字信号），也就是说，VCO使输出频率是电压的函数(非线性)。Charge pump是控制电压增加和减少的模块，Loop filter是低通滤波器，过滤掉电压信号中的高频正弦噪声，使VCO的输入更“纯粹”（减少毛刺信号，jittery clock）</li>
<li>Phase Detectors: 为什么带s ? 因为可以有两种实现：XOR Phase Detector  和 Phase-Frequency Detector ，Phase Detectors是相位和频率同步的核心，具体原理下面讲</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031635776.png" alt="image-20230303163504732"></p>
<h3 id="XOR-Phase-Detector"><a href="#XOR-Phase-Detector" class="headerlink" title="XOR Phase Detector"></a>XOR Phase Detector</h3><p>用一个异或门(XOR)就能实现相位检测，是最简单但有缺陷的实现：</p>
<p>当ref clock和local clock(反馈时钟)有相位差，异或之后输出的就是相位差信号(phase error)，这个信号经过线性函数转换成Vdd, 作为VCO的控制电压。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031433820.png" alt="image-20230303143346757"></p>
<p>XOR的缺陷：当local clock相位和ref clock相位一致，但local clock频率是ref clock的N倍时，XOR检不输出相位差，但此时PLL输出频率不是预期的频率，而是N倍的预期频率。</p>
<h3 id="Phase-Frequency-Detector-PFD"><a href="#Phase-Frequency-Detector-PFD" class="headerlink" title="Phase-Frequency Detector (PFD)"></a>Phase-Frequency Detector (PFD)</h3><p>为了解决XOR的缺陷，引入了Phase-Frequency Detector (PFD)，看名字就知道，它同时检测相位和频率，以保证PLL输出的正确性</p>
<p>如下图，UP&#x2F;DN是控制VCO的信号，用于给VCO加压&#x2F;降压；A和B是local clock和ref clock；</p>
<p>PFD使用触发器(flip-flops)，将UP&#x2F;DN变成A和B的状态机；关于flip-flops的特性，参考 <a target="_blank" rel="noopener" href="https://courses.cs.washington.edu/courses/cse370/03sp/pdfs/lectures/lecture15.pdf">Overview The D latch - University of Washington</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031532421.png" alt="image-20230303153203366"></p>
<p>(1) PFD如何检测相位差</p>
<p>以左侧信号为例，过程如下：</p>
<ol>
<li>信号A相位超前于信号B, A上升沿时会触发UP信号输出(D触发器特性，这里A作为D触发器的CLK输入信号)；</li>
<li>当信号B上升沿变化时, B处的触发器也输出DN脉冲，两个触发器的输出都为1，经过与门后Rst复位信号为1，导致A和B的触发器都被reset, 之后UP和DN都变为低；</li>
<li>综合下来看，UP信号的宽度就等于相位差，线性转换后就可以作为控制VCO的电压</li>
</ol>
<p>右侧波形同理，信号A相位落后于信号B，DN即相位差</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031500042.png" alt="image-20230303150043973"></p>
<p>(2) PFD如何检测频率差</p>
<p>如下图，当B频率比A低，PFD输出更多的UP信号增加VCO电压，提高B的频率；当B频率比A高则相反，PFD输出更多DN信号降低B的频率</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031517323.png" alt="image-20230303151725271"></p>
<h2 id="PLL的指标"><a href="#PLL的指标" class="headerlink" title="PLL的指标"></a>PLL的指标</h2><p>PLL structure is a feedback structure and the addition of extra phase shifts, as is done by a high-order filter, may result in instability. </p>
<p>PLL是能造成相位偏移（矫正）的反馈电路，既然是反馈就得像数学求极限一样不断趋近，这决定PLL不是一上电就能马上稳定工作，因此引入PLL的关键指标如下：</p>
<p>Important properties of a PLL are：</p>
<ul>
<li><p>lock range—the range of input frequencies over which the loop can maintain functionality; PLL能接受的输入时钟不可能太高，一般是OSC晶振低频时钟。想象一下，太高的输入时钟要去同步相位和倍频，对VCO和相位检测器的精度要求也极高</p>
</li>
<li><p>the lock time—the time it takes for the PLL to lock onto a given input signal; PLL是反馈环路电路，需要不断递归趋近于目标时钟信号直到稳定，稳定需要的时间称为PLL锁定时间</p>
</li>
<li><p>jitter.  毛刺信号，在模拟端称为noise(VCO输入电压)，在数字端称为jitter毛刺(VCO输出时钟)，这是时钟信号相关模块必不可少的指标</p>
</li>
</ul>
<h2 id="PLL的稳定过程"><a href="#PLL的稳定过程" class="headerlink" title="PLL的稳定过程"></a>PLL的稳定过程</h2><p>如下图是Spice 仿真将100Mhz reference clock倍频8倍，VCO最终稳定输出800Mhz system clock的过程：</p>
<ul>
<li><p>左侧是VCO控制电压，经过几次反馈调整后最终稳定</p>
</li>
<li><p>右侧是时钟信号，ref是输入的100Mhz reference clock，vco是输出的system clock， div是vco输出8分频后的反馈时钟</p>
</li>
</ul>
<p>可见PLL稳定过程是将ref，vco和div时钟信号的相位、频率都收敛到一致</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303031423652.png" alt="image-20230303142344571"></p>
<h2 id="PLL在IC设计IP的实例"><a href="#PLL在IC设计IP的实例" class="headerlink" title="PLL在IC设计IP的实例"></a>PLL在IC设计IP的实例</h2><p>以SMIC的PLL IP S65NLLPLLGS 为例介绍实际IC设计中的PLL模块：</p>
<p>(1) 简介</p>
<p>This PLL is developed as an IP block to reduce time to market, risk and cost in the<br>development of Analog Front –End design. This macro cell is mainly for the clock<br>generator. It can generate stable high-speed clock from a slower clock signal with<br>single power supply. The output frequency is adjustable and can be up to 1500MHz.<br>This PLL integrates a Phase Frequency Detector (PFD), a Low Pass Filter (LPF), a<br>Voltage Controlled Oscillator and other associated circuit. All fundamental building<br>blocks as well as fully programmable dividers are integrated in the core. It is useful<br>for clock multiplication of stable crystal oscillator sources and for de-skew clock<br>signals  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061656462.png" alt="image-20230306165657371"></p>
<p>可见主要模块还是PFD + VCO，输出时钟加了一些逻辑门控制，例如PDRST是PLL时钟复位控制。</p>
<p>(2) 主要参数</p>
<p>Technology: SMIC 65nm logic LL process  </p>
<p>PFD comparison frequency range from 1Mhz to 50Mhz.  </p>
<p>Output clock frequency range from 62.5MHz to 1500MHz  </p>
<p>基本体现了PLL的指标：输入输出时钟频率有限制</p>
<p>(3) PLL reset</p>
<p>PLL作为实际可用的模块，其输出频率一定是可调的，以下PLL IP的pin中的M, N即调整频率；对于固件、驱动软件开发者，M，N分频的访问接口是作为寄存器来动态配置。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061707268.png" alt="image-20230306170709189"></p>
<p>在M，N调整分配时，必须reset PLL并等待PLL再次稳定（PLL lock time），如下图：</p>
<p>LKDT: Lock Detection, 表示目前PLL正在lock，即反映PLL是否处于不稳定状态</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061711496.png" alt="image-20230306171156449"></p>
<h2 id="PLL在外设时钟配置的实例"><a href="#PLL在外设时钟配置的实例" class="headerlink" title="PLL在外设时钟配置的实例"></a>PLL在外设时钟配置的实例</h2><p>SD控制器(SD host)是SOC中常用的外围模块，通过SD specification规定的SD Command通信格式向SD卡通信。</p>
<p>下面以SD host&#x2F;card的时钟初始化为例，介绍PLL的lock time在外设时钟初始化的影响</p>
<p>(1) SD 4.0标准的host和card的物理框图如下图，这里重点关注host侧的时钟相关的模块：</p>
<ul>
<li>OSC: host 的时钟来源，同时也是PLL的输入</li>
<li>PLL: host的倍频器，为了给SD UHS-II card提供更高速的工作时钟(UHS-I低速SD card不需要此PLL)</li>
<li>RCLK: SD card的工作时钟(reference clock)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303061954691.png" alt="image-20230306195458581"></p>
<p>(2) SD host和card的时钟初始化</p>
<p>SD host和card的时钟初始化包含三步：</p>
<p>1.使能internal clock: sd host chip自己的工作时钟(即base clock，来源是OSC)，并等待其稳定，如下图(3)~(4)</p>
<p>2.enable PLL，并等待其稳定，这个等待稳定超时时间为150ms ，如下图(5)~(6)。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303062016985.png" alt="image-20230306172758282"></p>
<p>3.待host PLL输出稳定后，即可enable SD clock开始对SD卡供应reference clock时钟, 注意SD clock是下图(1)~(2)就已经计算好的，如下表Base Clock为internal clock，M可理解为PLL倍频后的频率, 经过2^N分频后给SD card作为reference clock。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303062013044.png" alt="image-20230306201345998"></p>
<h2 id="PLL在电源管理的实例"><a href="#PLL在电源管理的实例" class="headerlink" title="PLL在电源管理的实例"></a>PLL在电源管理的实例</h2><p>所谓电源管理，通俗的讲就是按需管理电源：</p>
<ul>
<li>按需，指的是按应用场景的需求，例如在高性能肯定对应高功耗，各种模块全部开启，且时钟频率拉到最大；而睡眠休眠等模式，有时只需要保留能唤醒系统的时钟就行；</li>
<li>管理电源，涉及到供电和时钟：将低功耗情景下不需要用到的模块直接关电，将要用到但速度要求不高的模块进入低速时钟工作。</li>
</ul>
<p>下面以PCIe的电源管理为例，介绍低功耗状态如何影响PLL的状态</p>
<p>（1）PCIe电源管理基本概念</p>
<p>PCIe的电源管理基本概念参考 <a target="_blank" rel="noopener" href="https://www.intel.cn/content/www/cn/zh/io/pci-express/pci-express-architecture-power-management-rev-1-1-paper.html">PCI EXPRESS ARCHITECTURE POWER MANAGEMENT</a>, 也可以参考PCIe标准协议PCIe Base Spec</p>
<p>从上到下包含三层：系统电源状态(S)，PCIe链路电源状态(L)，PCIe设备电源状态(D)</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071046331.png" alt="Untitled Diagram"></p>
<ul>
<li>Sleep state</li>
</ul>
<p>S0 (Working): This is the active system state in which the platform appears to be “on.”  </p>
<p>S1&#x2F;POS, S1 (Microsoft* OS Stand By): These are the lowest wake latency sleeping states.  </p>
<p>S3 (Microsoft OS Stand By) and S4 (Microsoft OS Hibernate): S3 is a low wake latency sleeping state in which all device contexts are lost except system memory</p>
<p>S5 (Microsoft OS Soft-off): In this state, the OS does not save any context and requires a complete OS boot when the system wakes  </p>
<ul>
<li>Link States</li>
</ul>
<p>L0: Active state  </p>
<p>L1: This link state is a low exit latency link state that is intended to reduce power when the device becomes aware of a lack of outstanding requests or pending transactions  </p>
<p>L2&#x2F;L3 Ready: This link state prepares the PCI Express link for the removal of power and clock.   </p>
<p>L3 (link off): Power and clock are removed in this link state  </p>
<ul>
<li>Device States</li>
</ul>
<p>D0 (Fully-on): The device is completely active and responsive during this D-state  </p>
<p>D1 and D2: There is no universal definition for these D-states. In general, D1 is expected to save<br>less power but preserve more device context than D2  </p>
<p>D3 (Off): Primary power may be fully removed from the device (D3cold), or not removed from the device (D3hot). </p>
<p>S, L, D 三层状态的对应关系如下表</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071050761.png" alt="image-20230307105034704"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071050372.png" alt="image-20230307105052312"></p>
<p>注意，Link state是Sleep state对Device state作用的结果，即状态变化的过程是：</p>
<p>系统发起S3 -&gt; Device sate进入D3-&gt;Link state进入L2&#x2F;L3</p>
<p>（2）使用PLL控制Device state</p>
<p>Device sate进入D3, 设备内部操作即包含PLL的disable，将PLL模块整个关掉，保留OSC低速时钟作为退出D3状态的唤醒时钟源（软件上可以理解为heart beat），当PLL关掉后，其他依赖PLL的高速模块通常也断电，整个设备接近（或彻底）断电，因此设备功耗极低。</p>
<p>Device sate退出D3并进入D0则是相反过程，设备的PLL模块打开，其他依赖PLL的高速模块也打开，整个设备进入Active状态，功耗自然升高。</p>
<p>（3）使用PLL控制Link state</p>
<p>参考chapter11 of <a target="_blank" rel="noopener" href="https://vdoc.pub/download/introduction-to-pci-express-a-hardware-and-software-developers-guide-1r2bcv8l7e6o">Introduction to PCI Express: A Hardware and Software Developer’s Guide</a></p>
<p>当PCIe link改变时，本质是PCIe时钟改变；PCIe host侧（bridge&#x2F;Root Complex）的时钟也是低速clock source经PLL倍频后的2.5GHz，如下图：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202303071202081.png" alt="image-20230307120222026"></p>
<p>L1 link state的本质：The L1 Link state is an idle state with the internal Phase Lock Loop Circuit turned off. The source clock is still feeding a 100-megahertz differential clock signal to the PCI Express component.</p>
<p>L2 link state的本质：The L2 Link state is an optional auxiliary idle state with the internal Phase Lock Loop Circuit, the external clock source, and the main device power turned off (auxiliary power remains on)</p>
<p>总结就是：PCIe Link State本质是通过关闭PCIe host侧的PLL甚至clock source来实现的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/02/02/Ubuntu-SSH%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/02/Ubuntu-SSH%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Ubuntu SSH服务配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-02 11:01:24" itemprop="dateCreated datePublished" datetime="2023-02-02T11:01:24+08:00">2023-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-22 10:58:27" itemprop="dateModified" datetime="2023-08-22T10:58:27+08:00">2023-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h1><h2 id="SSH基本概念"><a href="#SSH基本概念" class="headerlink" title="SSH基本概念"></a>SSH基本概念</h2><ul>
<li>SSH是Secure Shell缩写，实现安全远程登录</li>
</ul>
<p>​    SSH的安全性好，原因是其对数据进行加密，方式主要有两种：对称加密（密钥加密）和非对称加密（公钥加密）<br>​    对称加密指加密解密使用的是同一套秘钥。Client端把密钥加密后发送给Server端，Server用同一套密钥解密。对称加密的加密强度比较高，很难破解。但是如果有一个Client端的密钥泄漏，那么整个系统的安全性就存在严重的漏洞。<br>​    为了解决对称加密的漏洞，于是就产生了非对称加密。<br>​    非对称加密有两个密钥：“公钥”和“私钥”。公钥加密后的密文，只能通过对应的私钥进行解密。想从公钥推理出私钥几乎不可能，所以非对称加密的安全性比较高。</p>
<ul>
<li>SSH的加密原理中，使用了RSA非对称加密算法。</li>
</ul>
<p>​    整个过程：</p>
<p>​    （1）远程主机收到用户的登录请求，把自己的公钥发给用户。</p>
<p>​    （2）用户使用这个公钥，将登录密码加密后，发送回来。</p>
<p>​    （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<ul>
<li>关于中间人攻击（Man-in-the-middle attack）</li>
</ul>
<p>​    中间人攻击的概念：如果有人冒充远程主机将伪造的公钥发给用户，用户很难辨别公钥真伪，用户    会和伪造主机通信而不是真正的主机。</p>
<p>​    因为SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，是主机和用户之间自己签    发的，所有SSH从原理上无法彻底防止中间人攻击</p>
<ul>
<li><p>SSH使用首次验证方式减少中间人攻击的概率：</p>
<p>SSH首次连接会下载服务端的公钥，用户确认后公钥将被保存并信任。</p>
<p>下次访问时客户端将会核对服务端发来的公钥和本地保存的是否相同，如果不同就发出中间人攻击的警告拒绝连接，除非用户手动清除已保存的公钥。</p>
<p>所以，只要SSH首次连接没有中间人攻击，之后的SSH连接就无需担心中间人攻击</p>
</li>
</ul>
<h2 id="Ubuntu安装SSH服务"><a href="#Ubuntu安装SSH服务" class="headerlink" title="Ubuntu安装SSH服务"></a>Ubuntu安装SSH服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ssh -y</span><br><span class="line">sudo service ssh start</span><br><span class="line">sudo service ssh status</span><br></pre></td></tr></table></figure>

<p>在系统重启后ssh service会自启动，不需要<code>systemctl enable</code>去配置自启动</p>
<h2 id="Windows访问SSH服务"><a href="#Windows访问SSH服务" class="headerlink" title="Windows访问SSH服务"></a>Windows访问SSH服务</h2><ul>
<li><p>使用win+R CMD验证SSH连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 远程主机用户名@远程主机IP</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用putty，xshell等工具访问主机</p>
</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://www.how2shout.com/how-to/how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7.html#:~:text=How%20do%20I%20SSH%20into%20Ubuntu%20from%20Windows%3F,to%20Ubuntu%20server%20via%20Putty%20SSH%20client%20">how2shout.com&#x2F;how-to&#x2F;how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7</a></p>
<p>首次登陆会验证RSA公钥（1024位）的MD5 fingerprint（128位）</p>
<blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当首次连接的公钥被接受以后，会保存在本地文件。下次再连接这台主机会跳过公钥警告，直接提示输入密码。如果以后的连接是中间人攻击，其公钥和本地的首次公钥不同，从而保证安全性。</p>
<ul>
<li>使用xftp, filezilla工具传输文件</li>
</ul>
<p>和putty，xshell配置类似</p>
<ul>
<li>使用scp命令传输文件</li>
</ul>
<p>在linux主机之间可以用scp传输文件和目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#从远程cp到本地</span><br><span class="line">scp username@ip_address:/home/username/filename .</span><br><span class="line">#从本地cp到远程</span><br><span class="line">scp filename username@ip_address:/home/username</span><br><span class="line">#拷贝目录</span><br><span class="line">scp -r source_dir username@ip_address:/home/username/target_dir</span><br></pre></td></tr></table></figure>

<h2 id="SSH远程开发"><a href="#SSH远程开发" class="headerlink" title="SSH远程开发"></a>SSH远程开发</h2><p>示例一：在SSH server和客户端建立后，可以使用VSCode和source insight等代码编辑工具改代码，用xftp传输代码到SSH Linux主机，用xshell远程编译。</p>
<p>示例二：VSCode安装SSH远程开发插件，可以直接远程SSH Linux主机完成代码编辑、编译，<a target="_blank" rel="noopener" href="https://www.how2shout.com/how-to/how-to-login-into-ubuntu-using-ssh-from-windows-10-8-7.html#:~:text=How%20do%20I%20SSH%20into%20Ubuntu%20from%20Windows%3F,to%20Ubuntu%20server%20via%20Putty%20SSH%20client%20">visualstudio.com&#x2F;Remote Development using SSH</a></p>
<h1 id="远程连接相关的Ubuntu配置"><a href="#远程连接相关的Ubuntu配置" class="headerlink" title="远程连接相关的Ubuntu配置"></a>远程连接相关的Ubuntu配置</h1><h2 id="Ubuntu设置静态IP"><a href="#Ubuntu设置静态IP" class="headerlink" title="Ubuntu设置静态IP"></a>Ubuntu设置静态IP</h2><p>在使用SSH和Samba连远程Ubuntu PC时，发现IP有时候会改变，因此需要配置Ubuntu PC为静态IP</p>
<p>1.ifconfig查看ethernet接口和当前IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Z390-GAMING-X:~$ ifconfig</span><br><span class="line">eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.52.4.71  netmask 255.255.255.0  broadcast 10.52.4.255</span><br></pre></td></tr></table></figure>

<p>2.编辑Ubuntu的netplan配置文件&#x2F;etc&#x2F;netplan&#x2F;*.yaml，用tab补全找到具体的yaml，制定静态IP和DNS</p>
<p>参考 <a target="_blank" rel="noopener" href="https://linuxconfig.org/netplan-network-configuration-tutorial-for-beginners">Netplan network configuration tutorial for beginners</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">    eno1:</span><br><span class="line">      addresses:</span><br><span class="line">        - 10.52.4.71/24</span><br><span class="line">      nameservers:</span><br><span class="line">         addresses:</span><br><span class="line">            - 10.52.1.1</span><br><span class="line">            - 10.52.1.2</span><br><span class="line">      #gateway4: 10.52.0.1</span><br><span class="line">      routes:</span><br><span class="line">         - to: default</span><br><span class="line">           via: 10.52.0.1</span><br></pre></td></tr></table></figure>

<p>以上IP和nameservers(DNS)是必须的，gateway4是网关，在ubuntu22被废弃（ubuntu22显示 &#96;&#96;gateway4<code> has been deprecated, use default routes instead.</code>）使用routes配置网关，参考 <a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1410750/netplan-gateway-has-been-deprecated">netplan-gateway-has-been-deprecated</a>。怎么获取这三个值，参考以下网络命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看所有</span><br><span class="line">nmcli</span><br><span class="line">#查看gateway</span><br><span class="line">netstat -rn 或 route -n</span><br><span class="line">#DNS配置文件</span><br><span class="line">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>例如nmcli输出如下，其中 <code> inet4 10.52.4.71/24</code>即当前IP&#x2F;mask， <code>route4 default via 10.52.0.1</code>即默认网关，<code>DNS configuration servers: 10.52.1.1 10.52.1.2</code>即nameservers</p>
<blockquote>
<p>eno1: connected to netplan-eno1<br>        “Intel I219-V”<br>        ethernet (e1000e), 18:C0:4D:1F:BA:B7, hw, mtu 1500<br>        ip4 default<br>        inet4 10.52.4.71&#x2F;24<br>        route4 10.52.4.0&#x2F;24 metric 100<br>        route4 10.52.0.1&#x2F;32 metric 100<br>        route4 default via 10.52.0.1 metric 100<br>        inet6 fe80::1ac0:4dff:fe1f:bab7&#x2F;64<br>        route6 fe80::&#x2F;64 metric 256</p>
<p>virbr0: connected (externally) to virbr0<br>        “virbr0”<br>        bridge, 52:54:00:13:EB:68, sw, mtu 1500<br>        inet4 192.168.122.1&#x2F;24<br>        route4 169.254.0.0&#x2F;16 metric 1000<br>        route4 192.168.122.0&#x2F;24 metric 0</p>
<p>lo: unmanaged<br>        “lo”<br>        loopback (unknown), 00:00:00:00:00:00, sw, mtu 65536</p>
<p>DNS configuration:<br>        servers: 10.52.1.1 10.52.1.2<br>        interface: eno1</p>
</blockquote>
<p>3.生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<p>ping确认网络正常：</p>
<blockquote>
<p>ubuntu@ubuntu-Z390-GAMING-X:~$ ping <a target="_blank" rel="noopener" href="http://www.bing.com/">www.bing.com</a><br>PING china.bing123.com (202.89.233.101) 56(84) bytes of data.<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;1 ttl&#x3D;117 time&#x3D;27.1 ms<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;2 ttl&#x3D;117 time&#x3D;27.2 ms<br>64 bytes from 202.89.233.101 (202.89.233.101): icmp_seq&#x3D;3 ttl&#x3D;117 time&#x3D;27.2 ms</p>
</blockquote>
<p>如果DNS server或gateway不符合当前网络状况，ping会失败，输出：</p>
<blockquote>
<p>Name or service not known</p>
</blockquote>
<h2 id="Ubuntu禁止自动登出"><a href="#Ubuntu禁止自动登出" class="headerlink" title="Ubuntu禁止自动登出"></a>Ubuntu禁止自动登出</h2><p>自动登出会使SSH断开链接，按如下禁用</p>
<blockquote>
<p>setting-&gt;Privacy-&gt;Screen-&gt;Automatic Screen Lock (OFF)</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/01/30/Ubuntu%20Samba%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/30/Ubuntu%20Samba%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Ubuntu Samba配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-30 10:55:24" itemprop="dateCreated datePublished" datetime="2023-01-30T10:55:24+08:00">2023-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-27 19:35:38" itemprop="dateModified" datetime="2023-07-27T19:35:38+08:00">2023-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Samba基本概念"><a href="#Samba基本概念" class="headerlink" title="Samba基本概念"></a>Samba基本概念</h2><p>Samba是SMB protocol的应用程序实现，分为服务端和客户端；</p>
<p>Samba通常的使用场景：在同一局域网内的的Linux主机安装Samba服务，windows主机可以访问Linux Samba服务指定的共享目录。</p>
<p>在嵌入式开发中通常在windows 上编辑Samba共享目录下的代码，通过 Linux环境编译代码，而无需在两个主机间拷贝代码文件。</p>
<h2 id="Ubuntu安装Samba服务"><a href="#Ubuntu安装Samba服务" class="headerlink" title="Ubuntu安装Samba服务"></a>Ubuntu安装Samba服务</h2><p>Ubuntu 20.04和22.04 版本，安装Samba服务参考：</p>
<p><a target="_blank" rel="noopener" href="https://linux.how2shout.com/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux/#:~:text=Steps%20to%20install%20SAMBA%20on%20Ubuntu%2022.04%20LTS,...%206%206.%20Access%20the%20shared%20folder%20">www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux</a><br>主要流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#install and run samba service</span><br><span class="line">sudo apt install samba -y</span><br><span class="line"></span><br><span class="line">#enable auto start samba service</span><br><span class="line">sudo systemctl enable --now smbd</span><br><span class="line"></span><br><span class="line">#firewall allow samba</span><br><span class="line">sudo ufw allow samba</span><br><span class="line"></span><br><span class="line">#add system user to sambashare group</span><br><span class="line">sudo usermod -aG sambashare $USER</span><br><span class="line"></span><br><span class="line">#set passwd for sambashare</span><br><span class="line">sudo smbpasswd -a $USER</span><br><span class="line"></span><br><span class="line">#check samba service is running</span><br><span class="line">systemctl status smbd</span><br><span class="line"></span><br><span class="line">#share the folder in ubuntu GUI checkbox</span><br><span class="line">右键要共享的home文件夹properties -&gt; local Network Share -&gt; share this folder -&gt;share name不能直接用用户名，可以用&#x27;用户名+Home&#x27;</span><br></pre></td></tr></table></figure>

<p>显示无权共享：非root用户要共享&#x2F;home，需要修改smb.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br><span class="line">在[global]新增usershare owner only = false</span><br><span class="line">sudo systemctl restart smbd</span><br></pre></td></tr></table></figure>



<h2 id="Windows访问Samba共享目录"><a href="#Windows访问Samba共享目录" class="headerlink" title="Windows访问Samba共享目录"></a>Windows访问Samba共享目录</h2><p>windows下可以在文件浏览器直接访问Linux主机ip查看共享的Linux目录</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301103020.png" alt="image-20230130110305978"></p>
<p>首次windows访问共享目录有权限问题（不能写入），需要在Linux修改共享目录&#x2F;home的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /home -R </span><br></pre></td></tr></table></figure>

<p>为了以后方便连接，可以创建网络位置，参考：<a href="www.how2shout.com/linux/how-to-install-samba-on-ubuntu-22-04-lts-jammy-linux">6. Access the shared folder On Windows 11 or 10</a></p>
<p>如果一个主机有两个samba共享目录，windows不允许多重连接；</p>
<p>要更改连接目录，操作如下：</p>
<p>win10系统在搜索框搜索【凭据管理器】，然后删除已有的windows samba网络连接凭据</p>
<p><code>win+R</code> CMD输入 <code>net use * /del /y</code>断开所有远程链接，包括samba网络连接</p>
<p>重新配置windows samba网络连接</p>
<h2 id="重装Samba"><a href="#重装Samba" class="headerlink" title="重装Samba"></a>重装Samba</h2><p>Samba的配置文件位于&#x2F;etc&#x2F;samba&#x2F;smb.conf，如果此文件被错误配置或者误删除，需要重装Samba，流程如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove samba --purge //删掉samba服务</span><br><span class="line">sudo apt-get remove samba-common --purge //这一步是关键，只重装samba不会恢复smb.conf</span><br><span class="line">sudo apt-get autoremove //删掉其他samba依赖库</span><br><span class="line">sudo apt-get install samba //重装，包括samba和samba-common等</span><br></pre></td></tr></table></figure>

<h2 id="Samba使用示例"><a href="#Samba使用示例" class="headerlink" title="Samba使用示例"></a>Samba使用示例</h2><p>Samba最重要的特性是两个主机之间直接共享目录，不需要用户去拷贝文件。</p>
<p>在代码开发中，在windows主机的VSCode或其他编辑器直接打开Linux主机共享目录的代码，然后SSH远程Linux主机去编译。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2023/01/30/Windows-CMD-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/30/Windows-CMD-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Windows CMD 常用命令笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-30 10:38:16 / 修改时间：10:51:12" itemprop="dateCreated datePublished" datetime="2023-01-30T10:38:16+08:00">2023-01-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/windows/" itemprop="url" rel="index"><span itemprop="name">windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tree命令生成目录树"><a href="#Tree命令生成目录树" class="headerlink" title="Tree命令生成目录树"></a>Tree命令生成目录树</h1><blockquote>
<p>tree 命令的目录格式：TREE 【drive：】【path】【&#x2F;F】【&#x2F;A】</p>
<ul>
<li>可在cmd内输入（help tree 或 tree &#x2F; ？）查看</li>
<li>&#x2F;F  显示每个文件夹中文件的名称</li>
<li>&#x2F;A  使用ASCII字符，而不使用拓展字符</li>
</ul>
</blockquote>
<p>示例一：只显示路径名不显示文件名</p>
<p><code>TREE 【drive：】【path】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301049746.png" alt="image-20230130104934713"></p>
<p>示例二：显示路径名和文件名</p>
<p><code>TREE 【drive：】【path】【/F】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301048851.png" alt="image-20230130104835813"></p>
<p>示例三：将目录树存入指定文件</p>
<p><code>TREE 【drive：】【path】 &gt; 文件路径】</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202301301051100.png" alt="image-20230130105102054"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2022/12/08/VSCode%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/08/VSCode%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">VSCode配置笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-08 11:50:24" itemprop="dateCreated datePublished" datetime="2022-12-08T11:50:24+08:00">2022-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-31 14:14:13" itemprop="dateModified" datetime="2023-08-31T14:14:13+08:00">2023-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="修改工作区存储目录"><a href="#修改工作区存储目录" class="headerlink" title="修改工作区存储目录"></a>修改工作区存储目录</h2><p>VSCode会将每个工作区的一些配置、扩展、缓存等默认保存在C盘的AppData\Code\workspaceStorage，使用一段时间后数据能达到上十GB。</p>
<p>当C盘空间不足，用SpaceSniffer可以找到这些“数据垃圾”，但每隔一段时间清理也不是一劳永逸。</p>
<p>修改workspaceStorage存储路径到非系统盘：</p>
<p>1.首先选择VSCode在开始栏，状态栏，或桌面栏的快捷方式图标，常用哪个就修改哪个，右键属性：</p>
<p>添加启动的命令行选项，指定user-data-dir:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--user-data-dir &quot;目标路径，例如F:\VSCodeWorkspaceStorage&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081200216.png" alt="image-20221208120051137"></p>
<p>2.转移已有的workspaceStorage.</p>
<p>修改完成后，将%AppData%\Code下的所有内容拷贝到设置的目录中;  也可以删除%AppData%\Code，但是需要重新配置VSCode。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>以双斜杠&#x2F;&#x2F;注释和取消注释:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">注释：ctrl + / </span><br><span class="line">取消注释：ctrl + /</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法二：</span><br><span class="line">注释：ctrl + k, ctrl + c </span><br><span class="line">取消注释：ctrl + k, ctrl + u</span><br></pre></td></tr></table></figure>

<p>以星号&#x2F;**&#x2F;注释和取消注释:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注释：shift + alt + a </span><br><span class="line">取消注释：shift + alt + a</span><br></pre></td></tr></table></figure>

<h3 id="更改快捷键"><a href="#更改快捷键" class="headerlink" title="更改快捷键"></a>更改快捷键</h3><p>File-&gt;Preference-&gt;KeyboardShortCuts</p>
<p>例如可以把块注释&#x2F;**&#x2F;快捷键改成<code>ctrl+Alt+/</code>，和行注释<code>ctrl+/</code>达成统一：</p>
<p>选择recording keys，直接录入要修改的快捷键</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202302201101988.png" alt="image-20230220110133891"></p>
<h2 id="项目文件过滤"><a href="#项目文件过滤" class="headerlink" title="项目文件过滤"></a>项目文件过滤</h2><p>在项目的顶层目录中新建 <strong>.vscode</strong> 文件夹，在该文件夹下面新建 <strong>settings.json</strong> 文件</p>
<p>例如，对于Linux kernel项目，编译过的目录有大量编译输出文件(.o, .ko, .mod等)，只想查看和搜索驱动目录下的源码，过滤示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;files.exclude&quot;: &#123;</span><br><span class="line">        &quot;**/*.cmd&quot;: true, //当前所有目录的所有以.cmd结尾的文件</span><br><span class="line">        &quot;**/*.a&quot;: true,</span><br><span class="line">        &quot;**/*.o&quot;: true,</span><br><span class="line">        &quot;**/*.d&quot;: true,</span><br><span class="line">        &quot;**/*.mod&quot;: true,</span><br><span class="line">        &quot;**/*.mod.c&quot;: true,</span><br><span class="line">        &quot;**/*.ko&quot;: true,</span><br><span class="line"></span><br><span class="line">        &quot;[^drivers]*&quot;: true, //除了包含&#x27;d&#x27;&#x27;r&#x27;&#x27;i&#x27;&#x27;v&#x27;&#x27;e&#x27;&#x27;r&#x27;&#x27;s&#x27;目录以外的所有目录，近似等效于除了&quot;drivers&quot;文件夹以外的文件都被files.exclude</span><br><span class="line">        &quot;[^include]*&quot;: true,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;search.exclude&quot;: &#123;</span><br><span class="line">        &quot;[^driver]*&quot;: true,</span><br><span class="line">        &quot;[^include]*&quot;: true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正则表达式参考 <a target="_blank" rel="noopener" href="https://geek-docs.com/regexp/regexp-tutorials/75_regular_expression_exclude_characters.html#:~:text=Regex%20%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%83%BD%E5%A4%9F%E7%94%A8%E9%AB%98%E6%95%88%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2%E7%AD%89%E6%93%8D%E4%BD%9C%E3%80%82%20%E5%9C%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%EF%BC%8C%E6%9C%89%E6%97%B6%E9%9C%80%E8%A6%81%E6%8E%92%E9%99%A4%E6%9F%90%E4%BA%9B%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%82%20%E6%9C%AC%E6%96%87%E5%B0%86%E4%BB%8B%E7%BB%8D%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E6%8E%92%E9%99%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%82%20%E6%8E%92%E9%99%A4%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%20%E5%9C%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20%5E%20%E7%AC%A6%E5%8F%B7%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%8C%B9%E9%85%8D%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%82,%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%20%20a%5D%20%E4%B8%8A%E8%BF%B0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%20%5E%20%E8%A1%A8%E7%A4%BA%E6%8E%92%E9%99%A4%E5%AD%97%E7%AC%A6%EF%BC%8C%20%5B%5D%20%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88%E3%80%82">正则表达式排除字符</a></p>
<h2 id="VSCode-remote免密码登录-SSH密钥认证"><a href="#VSCode-remote免密码登录-SSH密钥认证" class="headerlink" title="VSCode remote免密码登录(SSH密钥认证)"></a>VSCode remote免密码登录(SSH密钥认证)</h2><p>Windows端的VSCode remote如何配置参考<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/remote/ssh">Remote Development using SSH</a>，Linux服务器配置好SSH服务后直接连接即可。</p>
<p>日常使用经常需要重启Linux服务端，需要重新输入密码登录；使用SSH密钥可以免密码登录。</p>
<p>SSH密钥登录的流程：</p>
<ul>
<li><p>在进行SSH连接之前，SSH客户端需要先生成自己的公钥私钥对，并将自己的公钥存放在SSH服务器上。</p>
</li>
<li><p>SSH客户端发送登录请求，SSH服务器就会根据请求中的用户名等信息在本地搜索客户端的公钥，并用这个公钥加密一个随机数发送给客户端。</p>
</li>
<li><p>客户端使用自己的私钥对返回信息进行解密，并发送给服务器。</p>
</li>
<li><p>服务器验证客户端解密的信息是否正确，如果正确则认证通过。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308221100363.png" alt="image-20230822110009079"></p>
</li>
</ul>
<p><strong>(1)Windows客户端生成ssh key</strong></p>
<p><code>win+R -&gt; ssh-keygen</code> 生成密钥对，id_rsa.pub是公钥，id_rsa是私钥；</p>
<p>如果已经有ssh-key, 不需要重新生成；如果已有的key不能配置生效，参考如下方式生成重命名的ssh-key，后续流程一致。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308221115183.png" alt="image-20230822111509800"></p>
<p><strong>(2)Linux服务端生成ssh key</strong></p>
<p>用xshell或samba拷贝windows端的<code>C:\Users\用户名\.ssh\id_rsa.pub</code>到Linux服务端的~&#x2F;<strong>.ssh</strong> </p>
<p>拷贝到authorized_keys，并修改权限，否则Vscode remote不能访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">chmod 777 authorized_keys </span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<p><strong>(3)配置VSCode remote</strong></p>
<p>ssh配置文件<code>C:\Users\用户名\.ssh\config</code></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202308221047708.png" alt="image-20230822104703184"></p>
<p>添加IdentityFile字段，填写windows本机的id_rsa路径，注意没有.pub后缀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host 10.52.4.63</span><br><span class="line">  HostName 10.52.4.63</span><br><span class="line">  User cursorhu</span><br><span class="line">  IdentityFile &quot;C:\Users\thomas.hu\.ssh\id_rsa&quot;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cursorhu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
