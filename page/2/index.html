<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/2/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--Cobra%E5%BE%AA%E7%8E%AF%E4%BB%AA%E7%94%B5%E6%B1%A0%E5%8C%85%E7%9A%84%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--Cobra%E5%BE%AA%E7%8E%AF%E4%BB%AA%E7%94%B5%E6%B1%A0%E5%8C%85%E7%9A%84%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">电量计--Cobra/循环仪/电池包的测试环境说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:03:04" itemprop="dateModified" datetime="2025-11-04T17:03:04+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BMS/" itemprop="url" rel="index"><span itemprop="name">BMS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计–Cobra-循环仪-电池包的测试环境说明"><a href="#电量计–Cobra-循环仪-电池包的测试环境说明" class="headerlink" title="电量计–Cobra&#x2F;循环仪&#x2F;电池包的测试环境说明"></a>电量计–Cobra&#x2F;循环仪&#x2F;电池包的测试环境说明</h1><p>以Newton FW项目(77561, 77226)为例，介绍cobra工具配合客户环境电池包的使用。</p>
<p>客户环境指：电量计内置在电池包，通信接口只有I2C，不支持串口调试和Jtag下载FW；而开发环境的电量计是独立开发板，支持串口打印和Jtag下载。</p>
<p>在实验室环境：使用Chroma循环仪模拟真实的客户Charger，对电量计和电池系统充放电测试，用cobra配置电量计FW和参数并采集数据，调试客户遇到的问题。</p>
<h2 id="Cobra编辑和下载project文件"><a href="#Cobra编辑和下载project文件" class="headerlink" title="Cobra编辑和下载project文件"></a>Cobra编辑和下载project文件</h2><ol>
<li><p>启动项目匹配的Cobra shell版本，加载项目oce文件</p>
<p>cobra shell是程序启动器，版本号在 About查看，目前使用1.01.19版本</p>
<p>oce是cobra功能文件，决定具体项目支持的功能，不同项目的oce不同；oce分为X版本和Y版本，X为发布给用户使用版本，Y仅用于内部Debug。</p>
<p>下图在Extension Manager中select SD77226SBS_X_20250315.oce，oce路径在COBRA\Extensions</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191558616.png" alt="img"></p>
<ol start="2">
<li>（对于Newton项目）加载prj</li>
</ol>
<p>prj文件(project)是cobra对Newton FW bin和Flash参数文件xml（parameter_newton，OCV table， RCtable，user_setting）的打包。</p>
<p>加载prj后默认显示newton FW bin：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191608196.png" alt="img"></p>
<p>加载prj后可查看(show)参数：根据电池规格书配置Design Capacity容量，Limited Charge Voltage电压等参数；根据常温和高低温需求配置CC转CV的电压值(Constant Current切换的Constant Voltage转折点)的电压值和温度阈值。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191613694.png" alt="image-20250319161351611"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191614471.png" alt="image-20250319161401395"></p>
<p>OCV(Open Circuit Voltage) table和RC(Remaining Capacity) table都是根据具体电池实测的电池数据，一般不会更改（除非测试数据有问题或者更换电池）。</p>
<p>以RC table为例，数组对应关系如下同颜色的标号</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191635013.png" alt="image-20250319163556911"></p>
<p><strong>关于RC table：</strong></p>
<p>RC table反映的是在不同环境下的充放电过程中的电压和剩余容量的对应关系。</p>
<p>RC table的采集方法是对电池放电（从满电以恒流放到截止电压），在不同温度下，用不同电流放电，分别采集到电池输出电压和电池剩余容量的关系。</p>
<p>为什么RC table是采集放电过程而不是充电过程：（可能）是因为放电过程可以保持恒流，如果采集充电过程，充电CC-CV阶段开始后电流会降低，破坏了恒定电流值的要求。</p>
<p>为什么RC table要考虑问题温度和电流：锂电池特性决定，温度影响锂电池的放电容量，温度降低，电池内阻加大，电池放电容量下降；温度过高有风险，有时应用上需要调低满电容量。电流实际能反映负载的分压，由于电池开路电压一定，电池内置在某时刻一定，那么电池带负载时输出电流越大说明外部负载电阻小，大电流放电，电池内阻导致的压降更多，放电到截止电压就会提前到来，满电对应的输出电压也不一样，最终反映到RC table。</p>
<p><strong>关于OCV table：</strong></p>
<p>OCV table反映的是电池开路(非充放电)状态下的电压和剩余容量的对应关系。</p>
<p>严格的OCV table应该是用极小的电流放电采集容量变化。小电流说明负载电阻极大，可以近似开路环境。但这种采集时间太长，一般没搞。</p>
<p>项目实际用的OCV table是RC table采集过程中提取出来的数据，会有误差。</p>
<p>对于电量计FW，OCV table一般用于电池在持续Idle&#x2F;sleep状态下查询剩余容量，因为此时没有电流，只能靠电压查询。</p>
<p>充放电过程中查询容量主要使用RC table，初始充电时也会参考OCV table。</p>
<p><strong>关于电量计计算SOC（State-of-charge）是否符合标准的判定方法：</strong></p>
<p>SOC（State-of-charge）可以简单理解成剩余电荷容量（RC）占满充总容量(FCC，Full Charge Capacity)的百分比[0 ~ 100]</p>
<p>理论上，电量计应该在每个时刻都反映精确的剩余容量百分比，但很难做到（原因？？？？）</p>
<p>项目的SOC算法的目标：</p>
<p>(1) 应用层目标：在充电达到截止电流时，SOC要报100；在放电达到截止电压时，SOC要报0。SOC误差 &lt; 3%</p>
<p>(2) 基于(1)的两个测试标准，如果FW只靠RC table和OCV table计算SOC，可能不能达到要求。因此SOC算法添加了追赶机制：</p>
<p>当充电进入CV阶段恒流升压转恒压降流，SOC算法可能会开启SOC追赶，确保电流达到截止时SOC能到100。CV过程的SOC并不能反映真实电量变化。</p>
<p>当放电接近截止电压，SOC算法可能会开启SOC追赶，确保达到截止电压时SOC能到0。这个过程的SOC也不能反映真实电量变化。</p>
<p>中间的过程SOC值主要来自RC table数据，SOC算法可能只做一些消抖平滑处理。</p>
<p>3.（对于Newton项目）下载prj到电量计芯片(ARM M0)的Flash</p>
<p>Full download下载当前prj内的所有bin和参数数据到电量计（通信方式是I2C）</p>
<p>4.（对于Newton项目）更新prj</p>
<p>如果FW bin需要修改，可以在当前prj界面open用KEIL MDK编译出的新newton_encript.bin，再save as新的prj</p>
<p>如果有参数需要修改，直接改参数，再save as新的prj</p>
<h2 id="Cobra使用SBS采集数据"><a href="#Cobra使用SBS采集数据" class="headerlink" title="Cobra使用SBS采集数据"></a>Cobra使用SBS采集数据</h2><h3 id="连接电量计"><a href="#连接电量计" class="headerlink" title="连接电量计"></a>连接电量计</h3><p>Bus setting选择port连接。使用o2link gen1 USB转I2C转接板(8051芯片)，需要先安装windows转接板驱动。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191930845.png" alt="img"></p>
<h3 id="初始界面"><a href="#初始界面" class="headerlink" title="初始界面"></a>初始界面</h3><p>默认可勾选查询哪些电量计信息，下方可切换页面到log信息页面</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191935049.png" alt="image-20250319193558973"></p>
<h3 id="开启调试内存GGMEM-（可选）"><a href="#开启调试内存GGMEM-（可选）" class="headerlink" title="开启调试内存GGMEM#（可选）"></a>开启调试内存GGMEM#（可选）</h3><p>GGMEM0~GGMEM8是Cobra查询电量计内存中指定RAM区域数据的接口，是Cobra环境监测电量计参数变化的主要手段。</p>
<p>选中FWVersion，Ctrl+ALT+Y输入密码888888，使能GGMEM0~GGMEM8</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191941173.png" alt="image-20250319194120118"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191943097.png" alt="image-20250319194304045"></p>
<h3 id="查看Cobra-log"><a href="#查看Cobra-log" class="headerlink" title="查看Cobra log"></a>查看Cobra log</h3><p>Cobra log是每秒发送一次之前勾选的SBS命令给电量计，查询电量计已获取的电池信息（电量计可能每秒轮询一次电池信息）。</p>
<p>主要关注电压(Battery Voltage)，外部温度(ETHM), 电流(Battery Current)和电量计算法输出的SOC容量（RSOC）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503191945945.png" alt="image-20250319194542869"></p>
<h3 id="查看GGMEM"><a href="#查看GGMEM" class="headerlink" title="查看GGMEM"></a>查看GGMEM</h3><p>查看GGMEM0值</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192008717.png" alt="image-20250319200834671"></p>
<p>查看GGMEM7的值和Cobra参数设定一致（高温环境，EOC电压是4100mV，EOC电流是500）</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192020659.png" alt="image-20250319202040571"></p>
<h3 id="详细了解ggmem的映射过程"><a href="#详细了解ggmem的映射过程" class="headerlink" title="详细了解ggmem的映射过程"></a>详细了解ggmem的映射过程</h3><p>GGMEM字段在电量计FW中的定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192014937.png" alt="image-20250319201430891"></p>
<p>GGMEM是如何从电量计RAM对应到Cobra SBS命令的：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192016127.png" alt="image-20250319201605094"></p>
<p>如果要打开更多GGMEM9显示到Cobra log，需要更新cobra oce支持新SBSD9_GGMEM9，修改FW新增绑定SBS SBSD9_GGMEM9 &#x3D; gg_mem[X]，X可以是任何偏移，不一定是72。</p>
<h2 id="Cobra电流校准"><a href="#Cobra电流校准" class="headerlink" title="Cobra电流校准"></a>Cobra电流校准</h2><p>更新新的prj到电量计后，有时候Cobra采集的电流和charger&#x2F;循环仪的真实电量不一致，需要calibration校准电流，分为3步：</p>
<p>0电流校准；3V充电校准；-3V放电校准。</p>
<p>先用循环仪设置对应的电流，再点击cobra calibrate按钮即可；分别校准3种电流情况之后，SBS log的电流误差应该会消除。</p>
<p>如果没有更新prj，校准过的数据无需再校准</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192035028.png" alt="image-20250319203521951"></p>
<h2 id="Cobra应用示例"><a href="#Cobra应用示例" class="headerlink" title="Cobra应用示例"></a>Cobra应用示例</h2><p>如下图是充电进入CV阶段的部分log，电压恒压，电流减少。但RSOC只有62%，后面算法应该会加速追赶，确保在达到满充（电流降到500）时SOC到100%</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503192040622.png" alt="image-20250319204006543"></p>
<p>这是export log导出csv文件，用曲线图分析</p>
<h2 id="循环仪Chroma-17020的使用"><a href="#循环仪Chroma-17020的使用" class="headerlink" title="循环仪Chroma 17020的使用"></a>循环仪Chroma 17020的使用</h2><h3 id="选择充电和放电配方"><a href="#选择充电和放电配方" class="headerlink" title="选择充电和放电配方"></a>选择充电和放电配方</h3><p>选择1A恒流充电（CC_1A），勾选连接到电量计的通道1-3，可开始充电和停止充电。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201021090.png" alt="image-20250320102129025"></p>
<p>1A恒流放电（DS_1A）同理：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201023474.PNG" alt="img"></p>
<p>在Cobra电流校准时，使用CC_3A和DS_3A，启动充电和放电后，再点击Cobra校准。</p>
<h3 id="编辑充放电配方"><a href="#编辑充放电配方" class="headerlink" title="编辑充放电配方"></a>编辑充放电配方</h3><p>配方编辑器可查看现有的配方，也可以编辑和新增配方</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201024587.PNG" alt="img"></p>
<p>查看已有的CC_3A配方的具体设置：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201025579.PNG" alt="img"></p>
<p>CC转CV电压模式充电：</p>
<p>CC阶段恒流3A充电电压逐渐升高到4.53，之后开始CV阶段恒压4.53，电流从3A逐渐减少到截止电流0.12A停止；关闭所有过流保护。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201025475.PNG" alt="img"></p>
<p>查看DS_1A放电的配方设置：</p>
<p>恒流放电：</p>
<p>1A恒流放电，电压从4.xV左右逐渐降低到截止电压3V就停止；关闭所有过流保护。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201027970.PNG" alt="img">对于不同的电池测试需求，可以修改参数之后存储档案。</p>
<h3 id="新建充放电配方"><a href="#新建充放电配方" class="headerlink" title="新建充放电配方"></a>新建充放电配方</h3><p>可以配置“放电+静置+充电”的自动运行配方，方便自动测试</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503201034525.PNG" alt="img"></p>
<h2 id="Cobra采集数据分析"><a href="#Cobra采集数据分析" class="headerlink" title="Cobra采集数据分析"></a>Cobra采集数据分析</h2><p>示例数据：<a target="_blank" rel="noopener" href="https://o2micro-my.sharepoint.com/:x:/p/thomas_hu/EftK5pMRry5HtS552GzuDRcBmb_yms6TSJNWoHF33muY4A?e=noJtCx">Scan_03_19_2025_11_44_14.csv</a></p>
<p>从放电快结束开始记录，静置，然后CC-CV充电到截止电流。</p>
<p>电压-电流曲线：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211526999.png" alt="image-20250321152603963"></p>
<p>比较真实电荷变化(mAh)和电量计评估的容量（RSOC）：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211528188.png" alt="image-20250321152851154"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202503211525757.png" alt="image-20250321152538723"></p>
<p><img src="C:\Users\cursorhu\AppData\Roaming\Typora\typora-user-images\image-20250321152447765.png" alt="image-20250321152447765"></p>
<h2 id="Cobra调试FW"><a href="#Cobra调试FW" class="headerlink" title="Cobra调试FW"></a>Cobra调试FW</h2><p>Y版本发指定SBS命令，格式参考FW代码和FW spec文档。</p>
<h3 id="SBS-F9打开串口、关闭串口"><a href="#SBS-F9打开串口、关闭串口" class="headerlink" title="SBS F9打开串口、关闭串口"></a>SBS F9打开串口、关闭串口</h3><p>串口测试环境必须要demo板子，电池包只有i2c不能看串口信息。测试环境如下</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081924569.png" alt="image-20250408192436055"></p>
<p>Cobra Y版本，发送 SBS F9 + 01 28，打开串口。 发送 SBS F9 + 01 29，关闭串口。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081918994.png" alt="image-20250408191814914"></p>
<h3 id="SBS51读高温次数和时间的数据"><a href="#SBS51读高温次数和时间的数据" class="headerlink" title="SBS51读高温次数和时间的数据"></a>SBS51读高温次数和时间的数据</h3><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081931949.png" alt="image-20250408193124921"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--77561(77226)%E7%9A%84Firmware%20Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--77561(77226)%E7%9A%84Firmware%20Architecture/" class="post-title-link" itemprop="url">电量计--77561(77226)的Firmware Architecture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:01:39" itemprop="dateModified" datetime="2025-11-04T17:01:39+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BMS/" itemprop="url" rel="index"><span itemprop="name">BMS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计–77561-77226-的Firmware-Architecture"><a href="#电量计–77561-77226-的Firmware-Architecture" class="headerlink" title="电量计–77561(77226)的Firmware Architecture"></a>电量计–77561(77226)的Firmware Architecture</h1><h1 id="Part1-总体结构概述"><a href="#Part1-总体结构概述" class="headerlink" title="Part1 总体结构概述"></a>Part1 总体结构概述</h1><h2 id="Keil-MDK项目结构"><a href="#Keil-MDK项目结构" class="headerlink" title="Keil MDK项目结构"></a>Keil MDK项目结构</h2><p>项目基于ARM Cortex-M0 MCU，使用Keil MDK开发环境构建。核心代码分为底层驱动、算法库和应用三层结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- newton.uvprojx           # Keil项目主文件</span><br><span class="line">- newton.sct               # 链接脚本</span><br><span class="line">- Device/                  # ARM M0 MCU设备相关文件</span><br><span class="line">- RTE/                     # 运行时环境配置</span><br><span class="line">- lib/                     # 核心算法库文件</span><br><span class="line">  - lib_fg.c/h             # 电量计核心算法库(Fuel Gauge)</span><br><span class="line">  - lib_pg.c/h             # 电池包电量计算法库(Pack Gauge)</span><br><span class="line">- user/                    # 用户应用代码</span><br><span class="line">  - main.c                 # 主程序入口</span><br><span class="line">  - parameter.c/h          # 参数配置</span><br><span class="line">  - sbsd.c/h               # SBS通信协议实现</span><br><span class="line">  - filter.c/h             # 数据滤波处理</span><br><span class="line">  - db_print.c/h           # 调试打印功能</span><br><span class="line">- flash/                   # Flash操作相关</span><br><span class="line">- chip/                    # 芯片驱动层</span><br><span class="line">- table/                   # 查找表数据</span><br><span class="line">- o2bootloader/            # 引导加载程序</span><br></pre></td></tr></table></figure>

<h2 id="启动和运行主流程"><a href="#启动和运行主流程" class="headerlink" title="启动和运行主流程"></a>启动和运行主流程</h2><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><ol>
<li><p>上电后从o2bootloader引导区启动</p>
</li>
<li><p>初始化MCU系统时钟和基本外设</p>
</li>
<li><p>初始化电量计参数和查找表</p>
</li>
<li><p>调用fg_init函数初始化电量计算法库</p>
</li>
<li><p>进入主循环</p>
</li>
</ol>
<h3 id="主循环流程"><a href="#主循环流程" class="headerlink" title="主循环流程"></a>主循环流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[上电] → [初始化] → [主循环&#123;</span><br><span class="line">  读取电池数据(电压/电流/温度)</span><br><span class="line">  处理电量计算法</span><br><span class="line">  更新SOC和其他电池状态</span><br><span class="line">  处理SBS通信请求</span><br><span class="line">  进入低功耗状态</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>主程序采用状态机设计，根据不同的电池状态(充电&#x2F;放电&#x2F;空闲)调用不同的处理函数。</p>
<h3 id="模块关系和流程图"><a href="#模块关系和流程图" class="headerlink" title="模块关系和流程图"></a>模块关系和流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[硬件层]</span><br><span class="line">  │</span><br><span class="line">  ├── MCU外设(ADC/I2C/Flash) </span><br><span class="line">  │       │</span><br><span class="line">  │       ▼</span><br><span class="line">  ├── 驱动层(chip/) </span><br><span class="line">  │       │</span><br><span class="line">  │       ▼</span><br><span class="line">[软件层]</span><br><span class="line">  │       </span><br><span class="line">  ├── 电量计算法核心(lib_fg) ◄────┐</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── 电池包管理(lib_pg)          │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── 应用层(user/main)           │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">  ├── SBS通信层(sbsd)             │</span><br><span class="line">  │       │                       │</span><br><span class="line">  │       ▼                       │</span><br><span class="line">[数据层]                          │</span><br><span class="line">  │                               │</span><br><span class="line">  └── 查找表(table/) ─────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">读取原始数据(电压/电流/温度) </span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">数据过滤(filter.c) </span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">状态判断(充电/放电/空闲)</span><br><span class="line">       │</span><br><span class="line">       ┌───────────┬────────────┐</span><br><span class="line">       ▼           ▼            ▼</span><br><span class="line">   充电状态     放电状态      空闲状态</span><br><span class="line">   处理函数     处理函数      处理函数</span><br><span class="line">       │           │            │</span><br><span class="line">       └───────────┼────────────┘</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">         SOC计算(库伦积分+OCV校正)</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">            电量计状态更新</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">              SBS数据更新</span><br></pre></td></tr></table></figure>

<h2 id="I2C-SBS通信命令"><a href="#I2C-SBS通信命令" class="headerlink" title="I2C SBS通信命令"></a>I2C SBS通信命令</h2><p>SBS（Smart Battery System）通信是电量计与主机通信的标准协议。该项目中在sbsd.c&#x2F;h文件实现了SBS标准通信命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">| 命令码 | 命令名称 | 描述 |</span><br><span class="line">|-------|---------|------|</span><br><span class="line">| 0x00 | ManufacturerAccess | 制造商访问 |</span><br><span class="line">| 0x01 | RemainingCapacityAlarm | 剩余容量警报 |</span><br><span class="line">| 0x02 | RemainingTimeAlarm | 剩余时间警报 |</span><br><span class="line">| 0x03 | BatteryMode | 电池模式 |</span><br><span class="line">| 0x04 | Temperature | 温度 |</span><br><span class="line">| 0x05 | Voltage | 电压 |</span><br><span class="line">| 0x06 | Current | 电流 |</span><br><span class="line">| 0x07 | AverageCurrent | 平均电流 |</span><br><span class="line">| 0x08 | MaxError | 最大误差 |</span><br><span class="line">| 0x09 | RelativeStateOfCharge | 相对电量百分比 |</span><br><span class="line">| 0x0A | AbsoluteStateOfCharge | 绝对电量百分比 |</span><br><span class="line">| 0x0B | RemainingCapacity | 剩余容量 |</span><br><span class="line">| 0x0C | FullChargeCapacity | 满充容量 |</span><br><span class="line">| 0x0D | RunTimeToEmpty | 运行剩余时间 |</span><br><span class="line">| 0x0E | AverageTimeToEmpty | 平均剩余时间 |</span><br><span class="line">| 0x0F | AverageTimeToFull | 平均充满时间 |</span><br><span class="line">| 0x10 | ChargingCurrent | 充电电流 |</span><br><span class="line">| 0x11 | ChargingVoltage | 充电电压 |</span><br><span class="line">| 0x12 | BatteryStatus | 电池状态 |</span><br><span class="line">| 0x13 | CycleCount | 循环次数 |</span><br><span class="line">| 0x14 | DesignCapacity | 设计容量 |</span><br><span class="line">| 0x15 | DesignVoltage | 设计电压 |</span><br><span class="line">| 0x16 | SpecificationInfo | 规格信息 |</span><br><span class="line">| 0x17 | ManufactureDate | 生产日期 |</span><br><span class="line">| 0x18 | SerialNumber | 序列号 |</span><br><span class="line">| 0x19 | ManufacturerName | 制造商名称 |</span><br><span class="line">| 0x1A | DeviceName | 设备名称 |</span><br><span class="line">| 0x1B | DeviceChemistry | 电池化学成分 |</span><br><span class="line">| 0x1C | ManufacturerData | 制造商数据 |</span><br><span class="line">| 0x3C-0x3F | GGMEM0-GGMEM8 | 调试内存区域 |</span><br></pre></td></tr></table></figure>

<p>此外，项目还实现了一些扩展命令，用于调试和配置电量计算法参数。</p>
<h2 id="电量计算法fg-lib分析"><a href="#电量计算法fg-lib分析" class="headerlink" title="电量计算法fg_lib分析"></a>电量计算法fg_lib分析</h2><h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef *struct* &#123;</span><br><span class="line">  // 电量计状态</span><br><span class="line">  *int* status;         // 电量计状态标志位</span><br><span class="line">  // 容量相关</span><br><span class="line">  *int* fcc;          // 满充容量(Full Charge Capacity)</span><br><span class="line">  *int* facc;          // 满充绝对容量(Full Absolute Charge Capacity)</span><br><span class="line">  *int* rca;          // 剩余容量(Remaining Capacity)</span><br><span class="line">  *int* chgcap;         // 充电容量</span><br><span class="line"></span><br><span class="line">  // SOC相关</span><br><span class="line">  *int* soc;          // 当前SOC百分比(0-10000，对应0-100%)</span><br><span class="line">  *int* soc_raw;        // 原始SOC</span><br><span class="line">  *int* soc_now;        // 实时SOC</span><br><span class="line">  *int* rsoc_now;        // 相对SOC</span><br><span class="line"></span><br><span class="line">  // 电池参数</span><br><span class="line">  *int* cell_temp;       // 电池温度</span><br><span class="line">  *int* cell_volt;       // 电池电压</span><br><span class="line">  *int* cell_curr;       // 电池电流</span><br><span class="line"></span><br><span class="line">  // 算法参数</span><br><span class="line">  *int* parm_eocmv;       // 充电截止电压</span><br><span class="line">  *int* parm_eocma;       // 充电截止电流</span><br><span class="line">  *int* parm_eodmv;       // 放电截止电压</span><br><span class="line"></span><br><span class="line">  // 时间记录</span><br><span class="line">  *unsigned* *int* chgtime;    // 充电时间</span><br><span class="line">  *unsigned* *int* dsgtime;    // 放电时间</span><br><span class="line">  *unsigned* *int* idletime;   // 空闲时间</span><br><span class="line"></span><br><span class="line">  // 表格数据</span><br><span class="line">  FG_LUT_T fg_tbls;      // 查找表结构</span><br><span class="line"></span><br><span class="line">  // 滤波相关</span><br><span class="line">  *int* cavgmov;        // 移动平均电流</span><br><span class="line">  *int* cavgcntr[4];      // 电流滤波器</span><br><span class="line">&#125; LIB_FG_TYPE_T;</span><br></pre></td></tr></table></figure>



<h3 id="算法核心模块"><a href="#算法核心模块" class="headerlink" title="算法核心模块"></a>算法核心模块</h3><h4 id="电量计状态机"><a href="#电量计状态机" class="headerlink" title="电量计状态机"></a>电量计状态机</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电量计使用状态机管理不同的工作状态：</span><br><span class="line">\#define FG_STAT_INIT    0x00000001 // 初始化状态</span><br><span class="line">\#define FG_STAT_CHG     0x00000002 // 充电状态</span><br><span class="line">\#define FG_STAT_DSG     0x00000004 // 放电状态</span><br><span class="line">\#define FG_STAT_IDLE    0x00000008 // 空闲状态</span><br><span class="line">\#define FG_STAT_CHG_CC   0x00000010 // 恒流充电</span><br><span class="line">\#define FG_STAT_CHG_CV   0x00000020 // 恒压充电</span><br><span class="line">\#define FG_STAT_CHG_EOC   0x00000040 // 充电截止</span><br><span class="line">\#define FG_STAT_DSG_EOD   0x00000080 // 放电截止</span><br><span class="line">\#define FG_STAT_DSG_FST1  0x00000100 // 快速放电1</span><br><span class="line">\#define FG_STAT_DSG_FST2  0x00000200 // 快速放电2</span><br><span class="line">\#define FG_STAT_DSG_LT   0x00000400 // 低温放电</span><br></pre></td></tr></table></figure>



<h4 id="SOC计算核心"><a href="#SOC计算核心" class="headerlink" title="SOC计算核心"></a>SOC计算核心</h4><p>SOC (State of Charge) 计算采用混合算法：</p>
<ol>
<li><p>库伦积分法</p>
<p>：根据电流积分计算电量变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 电流积分计算</span><br><span class="line">  delta_capacity = (current * delta_time) / 3600; // 单位：mAh</span><br><span class="line">  rca = rca - delta_capacity; // 更新剩余容量</span><br><span class="line">  soc = (rca * 10000) / fcc;  // 计算SOC(0-10000)</span><br></pre></td></tr></table></figure>


</li>
<li><p>OCV校准</p>
<p>：通过电压查表获取SOC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> // 通过OCV查表获取SOC</span><br><span class="line">  FG_ERROR_T fg_get_soc_by_ocv(FG_HANDLE_T **handle*, *short* *ocv_mv*, *short* **soc*)</span><br><span class="line">  &#123;</span><br><span class="line">​    // 通过一维表查找获取SOC</span><br><span class="line">​    return lut_one_axis_r(handle, &amp;(((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.ocv_tbl), ocv_mv, soc);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>混合算法</p>
<p>：结合库伦积分和OCV校准</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // 空闲状态下的OCV校准</span><br><span class="line">  if (idle_time &gt; OCV_RELAX_TIME) &#123;</span><br><span class="line">​    // 获取OCV对应的SOC</span><br><span class="line">​    fg_get_soc_by_ocv(handle, ocv, &amp;ocv_soc);</span><br><span class="line"></span><br><span class="line">​    // 计算偏差</span><br><span class="line">​    delta = ocv_soc - current_soc;</span><br><span class="line"></span><br><span class="line">​    // 如果偏差超过阈值，进行校准</span><br><span class="line">​    if (abs(delta) &gt; OCV_DELTA_THRESHOLD) &#123;</span><br><span class="line">​      // 使用滤波平滑过渡</span><br><span class="line">​      current_soc = current_soc + (delta * OCV_FILTER_FACTOR) / 100;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="温度补偿"><a href="#温度补偿" class="headerlink" title="温度补偿"></a>温度补偿</h4><p>温度对电池容量和电压有显著影响，算法中实现了温度补偿：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 温度补偿</span><br><span class="line">FG_ERROR_T fg_get_temp_factor(FG_HANDLE_T **handle*, *short* *temp*, *short* **factor*)</span><br><span class="line">&#123;</span><br><span class="line">  // 查表获取温度补偿系数</span><br><span class="line">  return lut_one_axis_f(handle, &amp;(((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.temp_factor_tbl), temp, factor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 应用温度补偿</span><br><span class="line">fcc_temp = (fcc * temp_factor) / 1000; // 温度修正后的满充容量</span><br></pre></td></tr></table></figure>



<h4 id="老化补偿"><a href="#老化补偿" class="headerlink" title="老化补偿"></a>老化补偿</h4><p>电池循环次数增加会导致容量衰减，算法实现了老化补偿：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 老化因子计算</span><br><span class="line">*int* fg_check_agefactor(FG_HANDLE_T **handle*)</span><br><span class="line">&#123;</span><br><span class="line">  *int* temp = fg_idiv_rounddown(handle, ((LIB_FG_TYPE_T *)handle)-&gt;chgcap, ((LIB_FG_TYPE_T *)handle)-&gt;facc);</span><br><span class="line">  temp *= FG_AGING_RATIO_MIN; // 最小损耗 * 循环次数</span><br><span class="line">  temp = (10000 - temp) / 100;</span><br><span class="line">  return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 应用老化补偿</span><br><span class="line">fcc_aged = (fcc * (10000 - aging_factor)) / 10000; // 老化修正后的满充容量</span><br></pre></td></tr></table></figure>



<h4 id="快速放电处理"><a href="#快速放电处理" class="headerlink" title="快速放电处理"></a>快速放电处理</h4><p>在大电流放电或低电压情况下，电池容量会急剧下降，算法实现了快速放电处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static *int* fg_fast_dsg(FG_HANDLE_T **handle*, FG_PARAM_T **param*)</span><br><span class="line">&#123;</span><br><span class="line">  // 根据不同电压档位加速SOC下降速率</span><br><span class="line">  if (param-&gt;volt_lo_mv &lt; (((LIB_FG_TYPE_T *)handle)-&gt;parm_eodmv - ((LIB_FG_TYPE_T *)handle)-&gt;parm_ddv - 200)) &#123;</span><br><span class="line">​    // 每秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 100);</span><br><span class="line">  &#125; else if (param-&gt;volt_lo_mv &lt; (((LIB_FG_TYPE_T *)handle)-&gt;parm_eodmv - ((LIB_FG_TYPE_T *)handle)-&gt;parm_ddv - 100)) &#123;</span><br><span class="line">​    // 每5秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 500);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">​    // 每10秒减少1%容量</span><br><span class="line">​    ((LIB_FG_TYPE_T *)handle)-&gt;deltauah -= fg_idiv_roundup(handle, ((LIB_FG_TYPE_T *)handle)-&gt;facc * param-&gt;delta_ms, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新状态</span><br><span class="line">  ((LIB_FG_TYPE_T *)handle)-&gt;status |= FG_STAT_DSG_FST1;</span><br><span class="line">  return ERR_FG_NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="查表算法"><a href="#查表算法" class="headerlink" title="查表算法"></a>查表算法</h4><p>算法使用多种查表算法进行插值计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 一维表正向查找</span><br><span class="line">static *int* lut_one_axis_f(FG_HANDLE_T **handle*, *tbl_one_t* **table*, *short* *input*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 通过输入值在表中查找并插值计算输出值</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一维表反向查找</span><br><span class="line">static *int* lut_one_axis_r(FG_HANDLE_T **handle*, *tbl_one_t* **table*, *short* *value*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 通过目标值反向查找输入值</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 三维表查找</span><br><span class="line">static *int* lut_three_axis(FG_HANDLE_T **handle*, *tbl_three_t* **table*, *short* *x_value*, *short* *y_value*, *short* *z_value*, *short* **output*)</span><br><span class="line">&#123;</span><br><span class="line">  // 三维插值计算</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法流程概述"><a href="#算法流程概述" class="headerlink" title="算法流程概述"></a>算法流程概述</h3><h4 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h4><p>fg_init() → 初始化电量计参数和状态 → 加载查找表 → OCV初始化SOC</p>
<h4 id="充电处理流程"><a href="#充电处理流程" class="headerlink" title="充电处理流程"></a>充电处理流程</h4><p>检测充电状态 → 更新充电时间 → 库伦积分计算SOC → 判断CC&#x2F;CV模式 → 检查充电截止条件 → 更新SOC</p>
<h4 id="放电处理流程"><a href="#放电处理流程" class="headerlink" title="放电处理流程"></a>放电处理流程</h4><p>检测放电状态 → 更新放电时间 → 库伦积分计算SOC → 温度补偿 → 低电压检测 → 快速放电处理 → 更新SOC</p>
<h4 id="空闲处理流程"><a href="#空闲处理流程" class="headerlink" title="空闲处理流程"></a>空闲处理流程</h4><p>检测空闲状态 → 更新空闲时间 → 检查OCV稳定时间 → OCV校准SOC → 更新SOC</p>
<h2 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h2><p>该电量计实现了以下低功耗策略：</p>
<ol>
<li><p>工作周期设计：系统大部分时间处于深度睡眠状态，定时唤醒采集数据和处理</p>
</li>
<li><p>外设优化：只在需要时启用ADC、I2C等外设</p>
</li>
<li><p>代码执行效率：优化算法减少指令执行次数</p>
</li>
<li><p>数据存储优化：使用查找表减少计算量</p>
</li>
</ol>
<h2 id="调试和校准工具"><a href="#调试和校准工具" class="headerlink" title="调试和校准工具"></a>调试和校准工具</h2><p>根据Cobra工具文档，系统支持以下调试和校准功能：</p>
<ol>
<li>电流校准：通过Cobra工具校准0电流、正向电流和负向电流</li>
<li>数据采集：通过SBS协议读取电量计内部状态</li>
<li>内存调试：通过GGMEM0-GGMEM8访问电量计内部RAM</li>
<li>参数配置：通过Cobra工具配置电量计算法参数</li>
</ol>
<h1 id="Part2-Firmware主要功能模块分析"><a href="#Part2-Firmware主要功能模块分析" class="headerlink" title="Part2 Firmware主要功能模块分析"></a>Part2 Firmware主要功能模块分析</h1><h2 id="通信接口（SBS命令流程）"><a href="#通信接口（SBS命令流程）" class="headerlink" title="通信接口（SBS命令流程）"></a>通信接口（SBS命令流程）</h2><p>以SBS命令0x0D(RSOC - 相对电量)为例，详细介绍整个处理流程，包含main.c、sbs.c和i2c.c三个文件在这个流程中的角色和作用</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>（1）main.c中的初始化：</p>
<p>在main.c中：</p>
<ol>
<li>调用i2cif_init初始化I2C接口，设置从机地址和回调函数sbs_callback_i2c_slave</li>
<li>调用sbsif_init初始化SBS接口</li>
<li>调用gg_lib_init初始化电量计算库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int* main(*void*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // ...系统初始化</span><br><span class="line"></span><br><span class="line">  // 初始化I2C接口，设置从机地址和回调函数</span><br><span class="line">  i2cif_init(param_board_cfg[PARM_BCFG_I2CADDR], tx_buff, sbs_callback_i2c_slave);</span><br><span class="line"></span><br><span class="line">  // 初始化SBS接口</span><br><span class="line">  sbsif_init(param_board_cfg[PARM_BCFG_I2CADDR]);</span><br><span class="line"></span><br><span class="line">  // 初始化电量计模块</span><br><span class="line">  gg_lib_init();</span><br><span class="line"></span><br><span class="line">  // ...其他初始化</span><br><span class="line"></span><br><span class="line">  // 进入主循环</span><br><span class="line">  main_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）sbs.c中的初始化</p>
<ol>
<li>初始化SBS接口数据结构</li>
<li>初始化SBS数据缓冲区，包括SBS0D_RSOC（相对电量）的初始值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void* sbsif_init(*uint32_t* *slv_addr*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  psbsifHandle = (SBS_HANDLE_T *)sbs_mem;</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_slv_addr = slv_addr;</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff = sbs_data_buff;</span><br><span class="line"></span><br><span class="line">  // ...初始化各种SBS数据</span><br><span class="line"></span><br><span class="line">  // 初始相对电量为0</span><br><span class="line">  ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）i2c.c中的初始化</p>
<ol>
<li><p>初始化I2C接口数据结构</p>
</li>
<li><p>配置I2C硬件参数</p>
</li>
<li><p>设置回调函数，该函数将在I2C通信事件发生时被调用</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void* i2cif_init(*uint32_t* *slv_addr*, *uint8_t* **t_buff*, i2c_callback *p_callback*)</span><br><span class="line">&#123;</span><br><span class="line">  i2cif_p = (I2CIF_T *)(i2c_mem);</span><br><span class="line">  i2cif_p-&gt;pI2C_Base = I2C;      // I2C模块基地址</span><br><span class="line">  i2cif_p-&gt;slv_addr = slv_addr;    // 从机地址</span><br><span class="line">  i2cif_p-&gt;tx_buffer = t_buff;     // 发送缓冲区</span><br><span class="line">  i2cif_p-&gt;i2c_callback_f = p_callback; // 回调函数</span><br><span class="line"></span><br><span class="line">  // ...配置I2C硬件</span><br><span class="line"></span><br><span class="line">  // 启用中断</span><br><span class="line">  Chip_I2C_EnableInts(i2cif_p-&gt;pI2C_Base, (...));</span><br><span class="line">  Chip_I2C_Enable(i2cif_p-&gt;pI2C_Base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="电量数据更新阶段"><a href="#电量数据更新阶段" class="headerlink" title="电量数据更新阶段"></a>电量数据更新阶段</h3><p>（1）main.c中的电量数据更新：</p>
<p>主循环调用gg_step计算最新的电量数据<br>调用gg_sync_result将电量计算结果同步到SBS数据<br>调用sbsif_update和sbsif_update_time更新SBS数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void* main_loop()</span><br><span class="line">&#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">​    // ...其他循环处理</span><br><span class="line">​    // 更新电量计算</span><br><span class="line">​    gg_step(passSec);</span><br><span class="line">​    // 同步电量计结果到SBS</span><br><span class="line">​    gg_sync_result();</span><br><span class="line">​    // 更新SBS数据</span><br><span class="line">​    sbsif_update(1);</span><br><span class="line">​    sbsif_update_time();</span><br><span class="line">​    // ...其他处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static *void* gg_sync_result(*void*)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // 将电量计计算结果同步到SBS数据</span><br><span class="line">  sbsif_set_data(SBS0D_RSOC, gg_result.rsoc);</span><br><span class="line">  // ...更新其他SBS数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）sbs.c中的电量数据更新</p>
<p>sbsif_set_data函数允许外部模块（如电量计）直接设置SBS数据<br>sbsif_update函数基于库仑计数据和满充容量计算相对电量<br>将计算结果存储在SBS0D_RSOC（相对电量）中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void sbsif_update(uint8_t updata_cc)</span><br><span class="line">&#123;</span><br><span class="line">    // ...更新其他数据</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 更新相对电量</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS5F_CCACCMAH];</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= 100;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val /= ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS10_FCC];</span><br><span class="line">    temp1 = ((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line">    if (temp1 &gt; 100)</span><br><span class="line">        temp1 = 100;</span><br><span class="line">    </span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC] = temp1;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void sbsif_set_data(SBS_DATA_T index, int32_t ivalue)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; SBSD_CMD_MAX) &#123;</span><br><span class="line">        sbs_data_buff[index] = ivalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I2C通信阶段-处理SBS-0x0D命令"><a href="#I2C通信阶段-处理SBS-0x0D命令" class="headerlink" title="I2C通信阶段 - 处理SBS 0x0D命令"></a>I2C通信阶段 - 处理SBS 0x0D命令</h3><p>当上位机发送SBS命令0x0D（读取相对电量）时：</p>
<p>（1）i2c.c中的命令接收</p>
<p>首先接收SBS命令字节(0x0D)并识别它<br>当上位机发送读请求时，调用回调函数准备要发送的数据<br>当I2C发送缓冲区需要数据时，发送预先准备好的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">I2C_STATUS_T i2cif_slave_handle(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 地址匹配检测</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_ADDR) &#123;</span><br><span class="line">        // 检查I2C方向（读/写）</span><br><span class="line">        if (i2cif_p-&gt;intstat &amp; I2C_ISR1_SLV_ADDR_DIR) &#123;</span><br><span class="line">            // 读操作 - 准备发送数据</span><br><span class="line">            i2cif_p-&gt;i2c_state = I2C_XFER_SLVSND;</span><br><span class="line">            // ...</span><br><span class="line">            i2cif_p-&gt;i2c_status = I2C_STATUS_TXDATA;</span><br><span class="line">            if (i2cif_p-&gt;i2c_callback_f) &#123;</span><br><span class="line">                i2cif_p-&gt;i2c_callback_f(i2cif_p-&gt;i2c_status, i2cif_p-&gt;sbd_idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 写操作 - 准备接收命令</span><br><span class="line">            i2cif_p-&gt;i2c_state = I2C_XFER_SLVRCV;</span><br><span class="line">            i2cif_p-&gt;rx_idx = 0;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 接收数据</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_RXNE) &#123;</span><br><span class="line">        i2cif_p-&gt;data = Chip_I2C_ReadRXData(i2cif_p-&gt;pI2C_Base);</span><br><span class="line">        </span><br><span class="line">        // 第一个字节是SBS命令</span><br><span class="line">        if (i2cif_p-&gt;rx_idx == 0) &#123;</span><br><span class="line">            i2cif_p-&gt;i2c_cmd = (uint8_t)i2cif_p-&gt;data; // 0x0D</span><br><span class="line">            </span><br><span class="line">            // 查找命令定义</span><br><span class="line">            do &#123;</span><br><span class="line">                if (((sbsd_cmd_def[i2cif_p-&gt;sbd_idx] &amp; SBSD_CMD_Msk) &gt;&gt; SBSD_CMD_Pos) == i2cif_p-&gt;i2c_cmd) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; while ((i2cif_p-&gt;sbd_idx++) &lt; SBSD_CMD_MAX);</span><br><span class="line">            </span><br><span class="line">            // ...处理命令</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 发送数据</span><br><span class="line">    if (i2cif_p-&gt;isr2stat &amp; I2C_ISR2_SLV_TXIS &amp;&amp; i2cif_p-&gt;i2c_state == I2C_XFER_SLVSND) &#123;</span><br><span class="line">        if (i2cif_p-&gt;tx_idx &lt; i2cif_p-&gt;tx_size) &#123;</span><br><span class="line">            if (i2cif_p-&gt;tx_buffer) &#123;</span><br><span class="line">                i2cif_p-&gt;data = *i2cif_p-&gt;tx_buffer;</span><br><span class="line">                i2cif_p-&gt;tx_buffer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // ...</span><br><span class="line">        </span><br><span class="line">        i2cif_p-&gt;tx_idx++;</span><br><span class="line">        Chip_I2C_WriteTXData(i2cif_p-&gt;pI2C_Base, i2cif_p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）main.c中的I2C回调处理</p>
<p>回调函数sbs_callback_i2c_slave处理I2C事件<br>当接收到状态I2C_STATUS_TXDATA时，准备发送数据<br>对于命令SBS0D_RSOC，调用sbsif_get_data获取当前相对电量<br>将数据填充到发送缓冲区<br>调用i2cif_set_tx通知I2C模块准备发送这些数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void sbs_callback_i2c_slave(uint32_t status, uint32_t n)</span><br><span class="line">&#123;</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case I2C_STATUS_TXDATA:</span><br><span class="line">            // 准备发送数据</span><br><span class="line">            switch (n) &#123;</span><br><span class="line">                case SBS0D_RSOC:</span><br><span class="line">                    // 准备发送相对电量数据</span><br><span class="line">                    value = sbsif_get_data(SBS0D_RSOC);</span><br><span class="line">                    </span><br><span class="line">                    // 设置发送缓冲区</span><br><span class="line">                    *tx_ptr++ = (uint8_t)value;</span><br><span class="line">                    *tx_ptr++ = (uint8_t)(value &gt;&gt; 8);</span><br><span class="line">                    </span><br><span class="line">                    // 设置要发送的数据大小</span><br><span class="line">                    i2cif_set_tx(tx_cnt, tx_buff);</span><br><span class="line">                    break;</span><br><span class="line">                </span><br><span class="line">                // ...处理其他SBS命令</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">        // ...处理其他I2C状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）sbs.c中的数据获取</p>
<p>sbsif_get_data函数返回指定SBS命令的当前值<br>对于SBS0D_RSOC，返回当前存储的相对电量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int32_t sbsif_get_data(SBS_DATA_T index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;= SBSD_CMD_MAX)</span><br><span class="line">        return sbs_data_buff[SBS03_BATTMODE];</span><br><span class="line">    else</span><br><span class="line">        return sbs_data_buff[index]; // 返回SBS0D_RSOC的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整流程图解"><a href="#完整流程图解" class="headerlink" title="完整流程图解"></a>完整流程图解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">【初始化阶段】</span><br><span class="line">main.c:main() </span><br><span class="line">    ↓</span><br><span class="line">    ├── i2c.c:i2cif_init() → 初始化I2C接口</span><br><span class="line">    ├── sbs.c:sbsif_init() → 初始化SBS数据接口</span><br><span class="line">    └── main.c:gg_lib_init() → 初始化电量计算库</span><br><span class="line"></span><br><span class="line">【电量数据更新阶段 - 周期性执行】</span><br><span class="line">main.c:main_loop()</span><br><span class="line">    ↓</span><br><span class="line">    ├── main.c:gg_step() → 电量计算</span><br><span class="line">    ├── main.c:gg_sync_result() → 同步电量计结果</span><br><span class="line">    │   └── sbs.c:sbsif_set_data(SBS0D_RSOC, ...) → 更新SBS数据</span><br><span class="line">    ├── sbs.c:sbsif_update() → 更新SBS接口数据</span><br><span class="line">    └── sbs.c:sbsif_update_time() → 更新时间预测数据</span><br><span class="line"></span><br><span class="line">【I2C通信阶段 - 上位机请求时】</span><br><span class="line">上位机发送SBS命令0x0D</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:I2C_IRQHandler() → I2C中断处理</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_slave_handle() → 识别命令0x0D</span><br><span class="line">    ↓</span><br><span class="line">main.c:sbs_callback_i2c_slave() → 处理I2C回调</span><br><span class="line">    ↓</span><br><span class="line">sbs.c:sbsif_get_data(SBS0D_RSOC) → 获取当前相对电量值</span><br><span class="line">    ↓</span><br><span class="line">main.c:sbs_callback_i2c_slave() → 准备发送数据</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_set_tx() → 设置发送缓冲区</span><br><span class="line">    ↓</span><br><span class="line">i2c.c:i2cif_slave_handle() → 通过I2C发送数据</span><br><span class="line">    ↓</span><br><span class="line">上位机接收相对电量数据</span><br></pre></td></tr></table></figure>

<h3 id="SBS命令的隐式支持"><a href="#SBS命令的隐式支持" class="headerlink" title="SBS命令的隐式支持"></a>SBS命令的隐式支持</h3><p>注意sbs_callback_i2c_slave中的default流程，可能隐藏支持一些SBS命令，例如SBS30_CV</p>
<p>每秒轮询更新eocmv之后，存储到sbs buffer的SBS30_CV：</p>
<pre><code>smart_charge_func:
	((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS30_CV] = eocmv;
	((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS34_EOC] = eocma;
</code></pre>
<p>((SBSIF_T *)psbsifHandle)-&gt;sbs_buff和sbs_data_buff指向同一个内存区域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void sbsif_init(uint32_t slv_addr)</span><br><span class="line">&#123;</span><br><span class="line">    psbsifHandle = (SBS_HANDLE_T *)sbs_mem;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_slv_addr = slv_addr;</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff = sbs_data_buff;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host发SBS30命令查询时，进到sbs_callback_i2c_slave的I2C_STATUS_TXDATA default，拿到sbs_data_buff数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sbs_callback_i2c_slave:</span><br><span class="line"></span><br><span class="line">//命令返回数据大小</span><br><span class="line">size = ((sbsd_cmd_def[n] &amp; SBSD_LEN_Msk) &gt;&gt; SBSD_LEN_Pos);</span><br><span class="line"></span><br><span class="line">switch (n)&#123;</span><br><span class="line">... //显式定义的命令处理</span><br><span class="line">//隐式处理命令：只要定义过的命令数据写到了sbs_data_buff就能获取到</span><br><span class="line">default: </span><br><span class="line">	pBuff = (uint8_t*)(&amp;sbs_data_buff[n]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2cif_set_tx(size, pBuff);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>default隐式支持的命令必须在sbsd_cmd_def数组中注册，否则I2C接口无法识别。</p>
</li>
<li><p>注册的数据大小要和传入值一致（0x30的SBSD_LEN_Pos处定义数据是4byte）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const unsigned int sbsd_cmd_def[SBSD_CMD_MAX] = &#123;</span><br><span class="line">	(0x03UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RW &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),		//0x03000434UL, /* BattMode */</span><br><span class="line">	(0x09UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x09000415UL, /* Voltage */</span><br><span class="line">	(0x0AUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0A000415UL, /* Current */</span><br><span class="line">	(0x0BUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0B000415UL, /* AvgCurrent */</span><br><span class="line">	(0x0DUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0D000415UL, /* RSOC */</span><br><span class="line">	(0x0EUL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_SWD),		//0x0E000415UL, /* ASOC */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">(0x30UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),			/* CHGVOLT */</span><br><span class="line">(0x32UL &lt;&lt; SBSD_CMD_Pos) | (4UL &lt;&lt; SBSD_LEN_Pos) | (SBSD_PRO_DIR_RD &lt;&lt; SBSD_PRO_DIR_Pos) | (SBSD_PRO_TYP_WWD),			/* CHGCURRENT */</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>FW参数有两个来源：</p>
<p>代码的默认配置；</p>
<p>Cobra写入到PRJ文件的Flash参数区域（GDM）</p>
<h3 id="代码默认配置参数"><a href="#代码默认配置参数" class="headerlink" title="代码默认配置参数"></a>代码默认配置参数</h3><h3 id="Cobra写入Flash参数"><a href="#Cobra写入Flash参数" class="headerlink" title="Cobra写入Flash参数"></a>Cobra写入Flash参数</h3><p>以param_board_cfg[PARM_BCFG_DESIGNCAPACITY]为例：</p>
<p>（1）定义：</p>
<p>param_board_cfg[PARM_BCFG_DESIGNCAPACITY] 是从 Flash 中读取的设计容量参数</p>
<p>在 parameter.h 中定义了参数的枚举类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">  // ...</span><br><span class="line">  PARM_BCFG_DESIGNCAPACITY, //=14</span><br><span class="line">  // ...</span><br><span class="line">  PARM_BCFG_MAX</span><br><span class="line">&#125; PARM_TYPE_BCFG_T;</span><br></pre></td></tr></table></figure>

<p>parameter.c 中定义了参数数组及其默认值（实际不是值，是Flash offset）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile signed int param_board_cfg[(PARM_BCFG_MAX)] = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  0x1388,                //0x0D48, PARM_BCFG_DESIGNCAPACITY, 5000mAh</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）参数加载过程：</p>
<p>在 gdm_init() 函数中，位于 flash&#x2F;gdm.c 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void gdm_init()</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    if (M32(GDM_FLASH_TABLECHECKSUM) != NEWTON_FLASH_EMPTY_DWORD)</span><br><span class="line">    &#123;</span><br><span class="line">        // copy Board configure from flash</span><br><span class="line">        ptrmemu32 = (uint32_t *)param_board_cfg;</span><br><span class="line">        for (i = 0; i &lt; PARM_BCFG_MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flashoffset = GDM_FLASH_BOARD_CONF + i * 4;</span><br><span class="line">            *(ptrmemu32 + i) = M32(flashoffset);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...</span><br><span class="line">        gdm_load_sw_cali();</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码：<br>首先检查 Flash 中的校验和是否有效<br>如果有效，则从 Flash 地址 GDM_FLASH_BOARD_CONF 开始，按顺序读取所有配置参数<br>每个参数占用 4 字节，按照枚举顺序依次读取<br>将读取的值存储到 param_board_cfg 数组中</p>
<p>（3）参数使用</p>
<p>设计容量参数在多处被使用，例如在 user&#x2F;main.c 中初始化电量计算配置时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FG_CONFIG_T cfg;</span><br><span class="line">cfg.dsncap = (int32_t)(param_board_cfg[PARM_BCFG_DESIGNCAPACITY]);</span><br></pre></td></tr></table></figure>

<p>在 sbs.c 中初始化 SBS 接口时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS18_DSNCAP] = param_board_cfg[PARM_BCFG_DESIGNCAPACITY];</span><br></pre></td></tr></table></figure>



<h2 id="数据持久化（Flash-log日志）"><a href="#数据持久化（Flash-log日志）" class="headerlink" title="数据持久化（Flash log日志）"></a>数据持久化（Flash log日志）</h2><h3 id="log数据结构"><a href="#log数据结构" class="headerlink" title="log数据结构"></a>log数据结构</h3><p>log.c实现了电池管理系统的日志记录和数据持久化功能，主要包括：<br>历史数据记录：记录电池使用过程中的极值数据，如最高&#x2F;最低电压、最大充放电电流、最高&#x2F;最低温度等<br>参数持久化：存储电量计算所需的自学习参数，确保系统断电后能恢复重要数据<br>Flash管理：管理Flash存储空间，实现数据的读写和擦除功能<br>CRC校验：通过CRC校验确保持久化数据的完整性</p>
<p>日志模块使用LOG_T结构体存储数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    uint16_t checksum;        // CRC校验值</span><br><span class="line">    uint16_t logindex;        // 日志索引</span><br><span class="line">    uint32_t historiage;      // 历史容量老化累计</span><br><span class="line">    uint16_t rc;              // 当前剩余容量</span><br><span class="line">    uint8_t packinfo[64];     // 电池包信息</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 极值记录</span><br><span class="line">    uint16_t vmaxcell1;       // 最高单体电压</span><br><span class="line">    uint16_t vmincell1;       // 最低单体电压</span><br><span class="line">    uint16_t cmaxchg;         // 最大充电电流</span><br><span class="line">    int16_t cmaxdsg;          // 最大放电电流</span><br><span class="line">    uint16_t maxtempcell;     // 最高温度</span><br><span class="line">    uint8_t maxtempcnt;       // 高温事件计数</span><br><span class="line">    uint16_t mintempcell;     // 最低温度</span><br><span class="line">    </span><br><span class="line">    // 时间统计</span><br><span class="line">    uint16_t timefw;          // 固件运行时间</span><br><span class="line">    uint16_t timeUT;          // 极低温时间</span><br><span class="line">    uint16_t timeELT;         // 超低温时间</span><br><span class="line">    uint16_t timeLTL;         // 低温下限时间</span><br><span class="line">    uint16_t timeLT;          // 低温时间</span><br><span class="line">    uint16_t timeLTH;         // 低温上限时间</span><br><span class="line">    uint16_t timeSTL;         // 标准温度下限时间</span><br><span class="line">    uint16_t timeRT;          // 参考温度时间</span><br><span class="line">    uint16_t timeSTH;         // 标准温度上限时间</span><br><span class="line">    uint16_t timeHT;          // 高温时间</span><br><span class="line">    uint16_t timeOT;          // 过温时间</span><br><span class="line"></span><br><span class="line">&#125; LOG_T;</span><br></pre></td></tr></table></figure>

<h3 id="日志数据初始化和更新"><a href="#日志数据初始化和更新" class="headerlink" title="日志数据初始化和更新"></a>日志数据初始化和更新</h3><p>（1）初始化流程：初始化过程中，系统会从Flash中读取最新的日志记录，校验其完整性，并将数据同步到内存中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void log_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化Flash接口</span><br><span class="line">    eflash_init();</span><br><span class="line">    </span><br><span class="line">    // 查找最新的日志</span><br><span class="line">    ret = find_latest_log();</span><br><span class="line">    if (-1 == ret) &#123;</span><br><span class="line">        // 没有找到日志，初始化缓冲区</span><br><span class="line">        log_init_buff();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 读取日志数据</span><br><span class="line">        for (i = 0; i &lt; sizeof(LOG_T); i++)</span><br><span class="line">            log_mem[i] = Chip_Flash_Read_Main_Byte(...);</span><br><span class="line">        </span><br><span class="line">        // 校验CRC</span><br><span class="line">        for (i = LOG_DATA_START; i &lt; sizeof(LOG_T); i += 2)</span><br><span class="line">            wval = math_calc_crc16(*(uint16_t *)(log_mem + i), wval);</span><br><span class="line">            </span><br><span class="line">        if (wval == log_p-&gt;checksum) &#123;</span><br><span class="line">            // CRC校验通过，同步数据到内存</span><br><span class="line">            ((SBSIF_T *)psbsifHandle)-&gt;sbs_historiage = log_p-&gt;historiage;</span><br><span class="line">            vmaxcell1_now = log_p-&gt;vmaxcell1;</span><br><span class="line">            vmincell1_now = log_p-&gt;vmincell1;</span><br><span class="line">            // ...其他数据同步</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 日志索引自增</span><br><span class="line">        log_p-&gt;logindex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void recover_dfcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 从Flash读取DFCC数据</span><br><span class="line">    log_crc = Chip_Flash_Read_Main_DWord(PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET);</span><br><span class="line"></span><br><span class="line">    // 计算数据的CRC校验值</span><br><span class="line">    for (i = 0; i &lt; DFCC_TABLE_LEN; i += 2) &#123;</span><br><span class="line">        value = Chip_Flash_Read_Main_Word((PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET) + 4 + i);</span><br><span class="line">        wval = math_calc_crc16(value, wval);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 校验CRC</span><br><span class="line">    if ((log_crc == wval) &amp;&amp; (wval != 0)) &#123;</span><br><span class="line">        // 复制数据到内存</span><br><span class="line">        fn_memcpy(DFCC_table, (uint8_t *)(PAGE_DEFCC_START &lt;&lt; PAGE_NO_SHIFT_TO_OFFSET) + 4, DFCC_TABLE_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类似地恢复充电FCC表和放电偏移量表...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）数据更新流程</p>
<p>数据更新流程中，系统会持续监控电池参数的极值，并在特定条件下（如极值变化、定时更新、强制更新）将数据写入Flash。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void update_log_data(uint8_t right_now)</span><br><span class="line">&#123;</span><br><span class="line">    // 更新电压极值</span><br><span class="line">    if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &gt; vmaxcell1_now)</span><br><span class="line">        vmaxcell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &lt; vmincell1_now)</span><br><span class="line">        vmincell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line">    </span><br><span class="line">    // 判断是否需要更新日志</span><br><span class="line">    if ((log_check_ultimate_value() &amp;&amp; lifetime_en) || right_now || (time_flag[10] &amp;&amp; lifetime_en)) &#123;</span><br><span class="line">        // 更新日志数据</span><br><span class="line">        log_p-&gt;historiage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_agemah;</span><br><span class="line">        log_p-&gt;rc = sbsif_get_data(SBS0F_RC);</span><br><span class="line">        </span><br><span class="line">        if (lifetime_en) &#123;</span><br><span class="line">            log_p-&gt;vmaxcell1 = vmaxcell1_now;</span><br><span class="line">            log_p-&gt;vmincell1 = vmincell1_now;</span><br><span class="line">            log_p-&gt;cmaxchg = cmaxchg_now;</span><br><span class="line">            log_p-&gt;cmaxdsg = cmaxdsg_now;</span><br><span class="line">            log_p-&gt;maxtempcell = (maxtempcell_now - DK_BASE) / 10;</span><br><span class="line">            log_p-&gt;mintempcell = (mintempcell_now - DK_BASE) / 10;</span><br><span class="line">            log_p-&gt;maxtempcnt = maxtempcnt;</span><br><span class="line">            log_update_time();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 计算CRC校验值</span><br><span class="line">        for (i = LOG_DATA_START; i &lt; sizeof(LOG_T); i += 2) &#123;</span><br><span class="line">            wval = math_calc_crc16(*(uint16_t *)(log_mem + i), wval);</span><br><span class="line">        &#125;</span><br><span class="line">        log_p-&gt;checksum = wval;</span><br><span class="line">        </span><br><span class="line">        // 写入Flash</span><br><span class="line">        write_log_into_flash();</span><br><span class="line">        log_p-&gt;logindex++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 充电完成后更新自学习参数</span><br><span class="line">    if ((!charge_full_flag &amp;&amp; (sbsif_get_data(SBS16_BATTSTATUS) &amp; SBS16_FULLY_CHARGED)) || update_dfcc_flag) &#123;</span><br><span class="line">        if (log_check_update_condition()) &#123;</span><br><span class="line">            log_update_dfcc_data();</span><br><span class="line">            log_update_charge_fcc_data();</span><br><span class="line">            log_update_discharge_offset();</span><br><span class="line">        &#125;</span><br><span class="line">        update_dfcc_flag = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化数据类型"><a href="#持久化数据类型" class="headerlink" title="持久化数据类型"></a>持久化数据类型</h3><p>（1）基本电池信息日志</p>
<p>由LOG_T结构体存储，包含：<br>电池容量老化历史<br>电压电流温度极值记录<br>各温度区间使用时间统计<br>这些数据用于追踪电池使用历史和健康状态。</p>
<p>（2）放电容量动态学习表(DFCC)</p>
<p>DFCC表存储了不同温度和电流条件下的放电容量校正因子，用于提高电量计算精度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void log_update_dfcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态放电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_dsg_enable)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 擦除Flash页</span><br><span class="line">    eflash_erase_page(PAGE_DEFCC_START);</span><br><span class="line">    </span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)DFCC_table, sizeof(DFCC_table));</span><br><span class="line">    </span><br><span class="line">    // 写入CRC校验值</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, 0, 4, (uint8_t *)&amp;wval);</span><br><span class="line">    </span><br><span class="line">    // 写入DFCC表</span><br><span class="line">    eflash_mem_to_flashEX(PAGE_DEFCC_START, 4, sizeof(DFCC_table), (uint8_t *)DFCC_table);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）充电容量动态学习表(CFCC)</p>
<p>充电FCC表记录了不同温度和电流条件下的充电容量校正数据，用于优化充电过程中的电量计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void log_update_charge_fcc_data()</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态充电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_chg_enable)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)charge_fcc_data, sizeof(charge_fcc_data));</span><br><span class="line">    </span><br><span class="line">    // 写入CRC校验值</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_CHARGE_FCC_OFFSET, 4, (uint8_t *)&amp;wval);</span><br><span class="line">    </span><br><span class="line">    // 写入充电FCC表</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_CHARGE_FCC_OFFSET + 4, sizeof(charge_fcc_data), (uint8_t *)charge_fcc_data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）放电偏移量表</p>
<p>放电偏移量表存储了不同条件下的放电偏移校正值，用于补偿放电过程中的误差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void log_update_discharge_offset(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查是否启用动态放电自学习</span><br><span class="line">    if (!plib_en_cfg-&gt;l_fg_dync_dsg_enable)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 计算CRC校验值</span><br><span class="line">    wval = log_calculate_crc((uint8_t *)discharge_offset, sizeof(discharge_offset));</span><br><span class="line">    </span><br><span class="line">    // 组装数据</span><br><span class="line">    fn_memcpy(log_buf, &amp;wval, 4);</span><br><span class="line">    fn_memcpy(log_buf + 4, discharge_offset, sizeof(discharge_offset));</span><br><span class="line">    </span><br><span class="line">    // 写入放电偏移量表</span><br><span class="line">    eflash_mem_to_flash(PAGE_DEFCC_START, LOG_DISCHARGE_OFFSET_OFFSET, 12, (uint8_t *)log_buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化的应用"><a href="#持久化的应用" class="headerlink" title="持久化的应用"></a>持久化的应用</h3><p>（1）电池电量计算精度提升</p>
<p>问题：电池在不同温度、电流条件下的容量会有显著差异，使用固定参数难以保证准确性。<br>解决方案：通过日志模块记录DFCC表和充电FCC表，实现动态学习和参数调整。</p>
<p>数据收集：<br>充放电过程中记录温度、电流等参数<br>完整放电&#x2F;充电周期后计算实际容量<br>参数更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (log_check_update_condition()) &#123;</span><br><span class="line">    log_update_dfcc_data();</span><br><span class="line">    log_update_charge_fcc_data();</span><br><span class="line">    log_update_discharge_offset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用算法：<br>电量计根据当前温度和电流查表获取校正因子<br>应用校正因子调整容量计算</p>
<p>（2）电池健康状态监测</p>
<p>问题：需要监控电池寿命周期内的健康状态变化，为用户提供电池健康程度的指导。<br>解决方案：利用日志模块的极值记录功能。</p>
<p>极值记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01] &gt; vmaxcell1_now)</span><br><span class="line">    vmaxcell1_now = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS3C_CELLMV01];</span><br><span class="line"></span><br><span class="line">// 定期持久化</span><br><span class="line">log_p-&gt;vmaxcell1 = vmaxcell1_now;</span><br></pre></td></tr></table></figure>

<p>健康评估：<br>分析电压极值分布判断是否过充&#x2F;过放<br>通过温度极值记录判断是否经历过高&#x2F;低温<br>基于充放电电流极值评估是否有过大电流冲击</p>
<p>容量衰减追踪：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_p-&gt;historiage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_agemah;</span><br></pre></td></tr></table></figure>

<p>（3）断电数据保护</p>
<p>问题：电池管理系统断电后会丢失当前的电量计算参数和状态。<br>解决方案：关键参数的持久化存储与恢复。</p>
<p>状态保存：<br>定期或在特定事件（如充满电）时保存电量计算状态<br>包括当前电量(RC)、最大容量(FCC)、学习参数等</p>
<p>上电恢复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 启动时恢复数据</span><br><span class="line">if (wval == log_p-&gt;checksum) &#123;</span><br><span class="line">    // CRC校验通过，同步数据</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_historiage = log_p-&gt;historiage;</span><br><span class="line">    vmaxcell1_now = log_p-&gt;vmaxcell1;</span><br><span class="line">    // ...其他数据恢复</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 恢复学习参数</span><br><span class="line">recover_dfcc_data();</span><br></pre></td></tr></table></figure>

<p>（4）Flash寿命管理</p>
<p>考虑到Flash的有限擦写次数，系统采取了以下策略：<br>只在必要时（极值变化、定时更新）写入数据<br>使用日志循环写入机制，平均分布擦写压力</p>
<h2 id="状态机（State-Machine）"><a href="#状态机（State-Machine）" class="headerlink" title="状态机（State Machine）"></a>状态机（State Machine）</h2><p>TODO</p>
<h1 id="Part3：电量算法模块"><a href="#Part3：电量算法模块" class="headerlink" title="Part3：电量算法模块"></a>Part3：电量算法模块</h1><h2 id="OCV-table"><a href="#OCV-table" class="headerlink" title="OCV table"></a>OCV table</h2><p>OCV表在lib_fg.c中的确实应用主要集中在：<br>系统初始化时的SOC确定<br>静置状态下的SOC校正<br>电压与SOC之间的转换计算<br>反向查询电压</p>
<p>（1）fg_init_soc函数：用于初始化SOC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static FG_ERROR_T fg_init_soc(FG_HANDLE_T *handle, short volt, short curr, short cellthm)</span><br><span class="line">&#123;</span><br><span class="line">    short soc = 0;</span><br><span class="line">    // 使用OCV表估算初始SOC</span><br><span class="line">    if (lut_soc_by_ocv(handle, volt, &amp;soc) != ERR_FG_NO_ERROR)</span><br><span class="line">        return ERR_FG_LUT_ERROR;</span><br><span class="line">    // ...设置初始SOC及库仑计数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）fg_idle_process函数：静置状态下的SOC校正</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static FG_ERROR_T fg_idle_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // ...在静置条件下</span><br><span class="line">    // 使用OCV表估算SOC并进行校正</span><br><span class="line">    if (lut_soc_by_ocv(handle, tmp_volt, &amp;ocv_soc) == ERR_FG_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        // ...根据OCV表估算结果校正SOC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）lut_soc_by_ocv函数本身：OCV查表获取SOC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static FG_ERROR_T lut_soc_by_ocv(FG_HANDLE_T *handle, int volt, short *soc)</span><br><span class="line">&#123;</span><br><span class="line">    // 实现查表逻辑，根据电压和温度获取SOC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）使用OCV表反向查询电压</p>
<p>lib_fg.c中的lut_ocv_by_soc函数提供了OCV表的反向查询能力，用于预测特定SOC点的电压：</p>
<p>在以下场景有应用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int fg_time_estimation(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    short eod_ocv = 0;</span><br><span class="line">    int time_to_empty = 0;</span><br><span class="line"></span><br><span class="line">    // 预测放电终止点的OCV</span><br><span class="line">    if (lut_ocv_by_soc(handle, 0, &amp;eod_ocv) == ERR_FG_NO_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        // 根据当前电压与终止电压的差距，以及当前放电速率，估算剩余时间</span><br><span class="line">        int voltage_drop = param-&gt;volt_lo_mv - eod_ocv;</span><br><span class="line">        int discharge_rate = voltage_drop * 3600 / ((LIB_FG_TYPE_T*)handle)-&gt;bat_avg_rate;</span><br><span class="line">        </span><br><span class="line">        time_to_empty = ((LIB_FG_TYPE_T*)handle)-&gt;cc_prv * 3600 / </span><br><span class="line">                        (param-&gt;current_ma * discharge_rate / 100);</span><br><span class="line">        </span><br><span class="line">        ((LIB_FG_TYPE_T*)handle)-&gt;time_to_empty = time_to_empty;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RC-table"><a href="#RC-table" class="headerlink" title="RC table"></a>RC table</h2><p>RC表是一个三维查找表，存储了电池在不同电压、电流和温度条件下电池内阻相关的容量校正因子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// RC表的查询实现</span><br><span class="line">// 输入电压、电流、温度，输出RC值</span><br><span class="line">static FG_ERROR_T lut_rc_f(FG_HANDLE_T *handle, short volt, short curr, short temp, short *output)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查输入参数有效性</span><br><span class="line">    // 可能会对电流取绝对值</span><br><span class="line"></span><br><span class="line">    // 使用三维表查询函数获取RC值</span><br><span class="line">    // 可能调用三线性插值函数</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR; // 成功返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RC表的应用"><a href="#RC表的应用" class="headerlink" title="RC表的应用"></a>RC表的应用</h3><p>RC表在fg_update中的应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FG_ERROR_T fg_update(FG_HANDLE_T *handle, FG_PARAM_T *param, FG_RESULT_T *result)</span><br><span class="line">&#123;</span><br><span class="line">    // 更新电池状态</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 在这里调用lut_rc_f获取RC值</span><br><span class="line">    </span><br><span class="line">    // 将RC值填充到结果结构体中</span><br><span class="line">    result-&gt;rc = ((LIB_FG_TYPE_T *)handle)-&gt;rc;</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在放电过程中的应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在fg_mobile_discharge_process函数中，RC表用于调整放电容量估计</span><br><span class="line"></span><br><span class="line">static FG_ERROR_T fg_mobile_discharge_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 放电处理逻辑</span><br><span class="line">    </span><br><span class="line">    // 在这里调用lut_rc_f获取放电条件下的RC值</span><br><span class="line">    // 使用RC值调整容量估计</span><br><span class="line">    </span><br><span class="line">    // 更新内部状态</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在充电过程中的应用</p>
<p>在fg_mobile_charge_process函数中，RC表用于调整充电容量估计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static FG_ERROR_T fg_mobile_charge_process(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 充电处理逻辑</span><br><span class="line"></span><br><span class="line">    // 在这里调用lut_rc_f获取充电条件下的RC值</span><br><span class="line">    // 使用RC值调整容量估计</span><br><span class="line">    </span><br><span class="line">    // 更新内部状态</span><br><span class="line">    </span><br><span class="line">    return ERR_FG_NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在时间预估中的应用：</p>
<p>用于fg_time_estimation函数中，影响剩余时间计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int fg_time_estimation(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 在这里间接调用lut_rc_f获取的RC值</span><br><span class="line">    // 使用RC值调整剩余时间计算</span><br><span class="line">    </span><br><span class="line">    // 计算并更新time_to_empty或time_to_full</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RC表在SOH计算中的应用：</p>
<p>在soh_update函数中用于电池健康状态评估：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void soh_update(FG_HANDLE_T *handle, FG_PARAM_T *param)</span><br><span class="line">&#123;</span><br><span class="line">    // 在这里调用lut_rc_f获取标准条件下的RC值</span><br><span class="line">    // 使用RC值参与SOH计算</span><br><span class="line">   </span><br><span class="line">    // 更新SOH值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RC表小结"><a href="#RC表小结" class="headerlink" title="RC表小结"></a>RC表小结</h3><p>RC与电池内阻：</p>
<p>RC表代表以下含义：<br>在放电过程中：RC表值较大表示内阻小、可用容量高；RC表值较小表示内阻大、可用容量低<br>在低温条件下：RC表值会降低，反映低温对容量的不利影响<br>在大电流条件下：RC表值会降低，反映大电流放电对有效容量的减少<br>在电池老化后：RC表配合SOH机制，反映容量衰减</p>
<p>因为温度和负载情况(电流大小)都会最终反映到锂电池内阻上，RC表的容量值变化实际是与电池内阻相关：<br>IR压降补偿：<br>估算负载下的电压损失<br>计算实际OCV(开路电压)<br>提高电量估算精度</p>
<p>容量校正：<br>调整电池在不同条件下的实际可用容量<br>考虑温度和电流对容量的影响</p>
<p>放电终点预测：<br>根据内阻预测不同负载下的放电终止点<br>提高剩余时间估算精度</p>
<p>RC表在实际应用中的一般流程：</p>
<p>获取实时数据：读取电池电压、电流和温度<br>查询RC表：调用lut_rc_f函数，获取当前条件下的RC值<br>容量调整：根据RC值调整FCC(满充容量)和CC(当前容量)<br>SOC计算：基于调整后的容量计算SOC<br>结果输出：将RC值和其他计算结果返回给系统</p>
<h2 id="DFCC-table"><a href="#DFCC-table" class="headerlink" title="DFCC table"></a>DFCC table</h2><h3 id="DFCC表的配置与初始化"><a href="#DFCC表的配置与初始化" class="headerlink" title="DFCC表的配置与初始化"></a>DFCC表的配置与初始化</h3><p>默认数据结构和初始值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 表的维度定义</span><br><span class="line">#define DFCC_X 11  // SOC轴</span><br><span class="line">#define DFCC_Y 3   // 电流轴  </span><br><span class="line">#define DFCC_Z 4   // 温度轴</span><br><span class="line"></span><br><span class="line">// 各轴的数据范围</span><br><span class="line">const short DFCC_XDATA[DFCC_X] = &#123;500, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000&#125;; // SOC: 5%-100%</span><br><span class="line">const short DFCC_YDATA[DFCC_Y] = &#123;600, 1500, 3000&#125;;  // 电流: 600mA-3000mA</span><br><span class="line">const short DFCC_ZDATA[DFCC_Z] = &#123;-100, 0, 250, 550&#125;; // 温度: -10°C到55°C</span><br><span class="line"></span><br><span class="line">// DFCC表数据结构</span><br><span class="line">short DFCC_table[DFCC_Y * DFCC_Z][DFCC_X];  // 3D查找表</span><br></pre></td></tr></table></figure>

<p>使用前的初始化：</p>
<p>从main.c中的代码片段可以看到DFCC表是作为查找表(lut)的一部分进行初始化的：</p>
<p>这段代码配置了一个三维查找表结构(tbl_three_t)，包含：<br>轴点数量：x_num, y_num, z_num<br>轴数据指针：p_x_start, p_y_start, p_z_start<br>表数据指针：p_data_start</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lut.dfcc_tbl.x_num = DFCC_X;</span><br><span class="line">lut.dfcc_tbl.y_num = DFCC_Y;</span><br><span class="line">lut.dfcc_tbl.z_num = DFCC_Z;</span><br><span class="line">lut.dfcc_tbl.p_x_start = (short *)DFCC_XDATA;</span><br><span class="line">lut.dfcc_tbl.p_y_start = (short *)DFCC_YDATA;</span><br><span class="line">lut.dfcc_tbl.p_z_start = (short *)DFCC_ZDATA;</span><br><span class="line">lut.dfcc_tbl.p_data_start = (short *)DFCC_table;</span><br></pre></td></tr></table></figure>

<p>查找表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int     x_num;              // X轴点数</span><br><span class="line">    int     y_num;              // Y轴点数</span><br><span class="line">    int     z_num;              // Z轴点数</span><br><span class="line">    short*  p_x_start;          // X轴数据起始指针</span><br><span class="line">    short*  p_y_start;          // Y轴数据起始指针</span><br><span class="line">    short*  p_z_start;          // Z轴数据起始指针</span><br><span class="line">    short*  p_data_start;       // 表数据起始指针</span><br><span class="line">&#125; tbl_three_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    tbl_read_t  readfunc;       // 表读取函数</span><br><span class="line">    tbl_one_t   thm_tbl;        // 温度表信息</span><br><span class="line">    tbl_one_t   ocv_tbl;        // OCV表信息</span><br><span class="line">    tbl_three_t rc_tbl;         // RC表信息</span><br><span class="line">    tbl_three_t dfcc_tbl;       // DFCC表信息</span><br><span class="line">&#125; FG_LUT_T;</span><br></pre></td></tr></table></figure>

<h3 id="lut-dfcc-f查表函数"><a href="#lut-dfcc-f查表函数" class="headerlink" title="lut_dfcc_f查表函数"></a>lut_dfcc_f查表函数</h3><p>定义DFCC table为宏DDTABLE </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DDTABLE ((LIB_FG_TYPE_T *)handle)-&gt;fg_tbls.dfcc_tbl.p_data_start</span><br></pre></td></tr></table></figure>

<p>在放电处理流程内调用lut_dfcc_f查表，过程：</p>
<p>a) 输入参数限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SOC限制</span><br><span class="line">if (soc &lt; XDTABLE[0]) &#123;</span><br><span class="line">    soc = XDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (soc &gt; XDTABLE[XDNUM - 1]) &#123;</span><br><span class="line">    soc = XDTABLE[XDNUM - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电流限制</span><br><span class="line">if (curr &lt; YDTABLE[0]) &#123;</span><br><span class="line">    curr = YDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (curr &gt; YDTABLE[YDNUM - 1]) &#123;</span><br><span class="line">    curr = YDTABLE[YDNUM - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 温度限制</span><br><span class="line">if (temp &lt; ZDTABLE[0]) &#123;</span><br><span class="line">    temp = ZDTABLE[0];</span><br><span class="line">&#125;</span><br><span class="line">if (temp &gt; ZDTABLE[ZDNUM - 1]) &#123;</span><br><span class="line">    temp = ZDTABLE[ZDNUM - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b) 索引查找：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 查找SOC对应的索引</span><br><span class="line">for (IDX = 1; IDX &lt; XDNUM; IDX++) &#123;</span><br><span class="line">    if ((XDTABLE[IDX-1] &lt;= soc) &amp;&amp; (XDTABLE[IDX] &gt; soc)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找电流对应的索引</span><br><span class="line">for (IDY = 1; IDY &lt; YDNUM; IDY++) &#123;</span><br><span class="line">    if ((YDTABLE[IDY-1] &lt;= curr) &amp;&amp; (YDTABLE[IDY] &gt; curr)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找温度对应的索引</span><br><span class="line">for (IDZ = 1; IDZ &lt; ZDNUM; IDZ++) &#123;</span><br><span class="line">    if ((ZDTABLE[IDZ-1] &lt;= temp) &amp;&amp; (ZDTABLE[IDZ] &gt; temp)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c) 三线性插值计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// X轴(SOC)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    XFRACS = 1 * 100;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    XFRACS = fg_idiv(handle, (soc - STMP) * 100, (SVAL - STMP));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Y轴(电流)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    YFRAC = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    YFRAC = (SVAL - STMP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Z轴(温度)方向插值</span><br><span class="line">if (SVAL == STMP) &#123;</span><br><span class="line">    ZFRAC = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ZFRAC = (SVAL - STMP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFCC与动态容量"><a href="#DFCC与动态容量" class="headerlink" title="DFCC与动态容量"></a>DFCC与动态容量</h3><p>放电流程中查找RC table后继续查找DFCC table，动态修改FCC容量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error = lut_dfcc_f(*handle*, ((LIB_FG_TYPE_T *)*handle*)-&gt;rsoc_now, -curr_now, *param*-&gt;cellthm, (*short* *)&amp;dfcc_comp);</span><br><span class="line"></span><br><span class="line">rca_prv = (fg_idiv(*handle*, tmp_soh_mah, ((LIB_FG_TYPE_T *)*handle*)-&gt;rsoc_now) * dfcc_comp) / 10000;</span><br><span class="line"></span><br><span class="line">((LIB_FG_TYPE_T *)*handle*)-&gt;fcc = rca_prv;</span><br></pre></td></tr></table></figure>

<h2 id="查表函数的插值原理"><a href="#查表函数的插值原理" class="headerlink" title="查表函数的插值原理"></a>查表函数的插值原理</h2><p>RC table和DFCC table都是三维查表函数，是离散点。而电量计检测到的温度电流电压soc等数据是连续点。因此需要三维插值去处理连续点无法在离散表中查询到的情况。</p>
<p>三线性插值是一种在三维空间中进行插值的技术，它基于周围8个已知点的值来估计任意位置的值。整个过程分三步：</p>
<ol>
<li><p>X方向插值：对Z和Y固定，在X方向上插值得到4个点</p>
</li>
<li><p>Y方向插值：对这4个点在Y方向上插值得到2个点</p>
</li>
<li><p>Z方向插值：对这2个点在Z方向上插值得到最终结果</p>
</li>
</ol>
<p>插值公式：</p>
<p>!V &#x3D; V_{000}(1-x)(1-y)(1-z) + V_{100}x(1-y)(1-z) + V_{010}(1-x)y(1-z) + V_{110}xy(1-z) + V_{001}(1-x)(1-y)z + V_{101}x(1-y)z + V_{011}(1-x)yz + V_{111}xyz</p>
<p>其中x, y, z是归一化的坐标（范围0到1）。</p>
<p>以下是示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">int lut_three_latitude(tbl_three_t *p_tbl, short x, short y, short z, short *result)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int x_idx, y_idx, z_idx;</span><br><span class="line">    float fx[2], fy[2], fz[2];  // 插值权重</span><br><span class="line">    float tmp_xyz[8];           // 八个顶点的值</span><br><span class="line">    float tmp_xy[4];            // 四条边的插值结果</span><br><span class="line">    float tmp_x[2];             // 两个面的插值结果</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 查找X轴索引并计算插值权重</span><br><span class="line">    x_idx = find_table_index(p_tbl-&gt;p_x_start, p_tbl-&gt;x_num, x);</span><br><span class="line">    if (x_idx &lt; 0) return -1;</span><br><span class="line">    if (x_idx == p_tbl-&gt;x_num - 1) &#123;</span><br><span class="line">        fx[0] = 1.0f; fx[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fx[1] = (float)(x - p_tbl-&gt;p_x_start[x_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_x_start[x_idx+1] - p_tbl-&gt;p_x_start[x_idx]);</span><br><span class="line">        fx[0] = 1.0f - fx[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 查找Y轴索引并计算插值权重</span><br><span class="line">    y_idx = find_table_index(p_tbl-&gt;p_y_start, p_tbl-&gt;y_num, y);</span><br><span class="line">    if (y_idx &lt; 0) return -1;</span><br><span class="line">    if (y_idx == p_tbl-&gt;y_num - 1) &#123;</span><br><span class="line">        fy[0] = 1.0f; fy[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fy[1] = (float)(y - p_tbl-&gt;p_y_start[y_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_y_start[y_idx+1] - p_tbl-&gt;p_y_start[y_idx]);</span><br><span class="line">        fy[0] = 1.0f - fy[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 查找Z轴索引并计算插值权重</span><br><span class="line">    z_idx = find_table_index(p_tbl-&gt;p_z_start, p_tbl-&gt;z_num, z);</span><br><span class="line">    if (z_idx &lt; 0) return -1;</span><br><span class="line">    if (z_idx == p_tbl-&gt;z_num - 1) &#123;</span><br><span class="line">        fz[0] = 1.0f; fz[1] = 0.0f;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fz[1] = (float)(z - p_tbl-&gt;p_z_start[z_idx]) / </span><br><span class="line">                (float)(p_tbl-&gt;p_z_start[z_idx+1] - p_tbl-&gt;p_z_start[z_idx]);</span><br><span class="line">        fz[0] = 1.0f - fz[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取周围8个点的值</span><br><span class="line">    for (k = 0; k &lt; 2 &amp;&amp; (z_idx + k) &lt; p_tbl-&gt;z_num; k++) &#123;</span><br><span class="line">        for (j = 0; j &lt; 2 &amp;&amp; (y_idx + j) &lt; p_tbl-&gt;y_num; j++) &#123;</span><br><span class="line">            for (i = 0; i &lt; 2 &amp;&amp; (x_idx + i) &lt; p_tbl-&gt;x_num; i++) &#123;</span><br><span class="line">                int data_idx = (z_idx + k) * (p_tbl-&gt;y_num * p_tbl-&gt;x_num) + </span><br><span class="line">                               (y_idx + j) * p_tbl-&gt;x_num + (x_idx + i);</span><br><span class="line">                tmp_xyz[k*4 + j*2 + i] = (float)p_tbl-&gt;p_data_start[data_idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿X轴插值，得到4个边的值</span><br><span class="line">    for (k = 0; k &lt; 2; k++) &#123;</span><br><span class="line">        for (j = 0; j &lt; 2; j++) &#123;</span><br><span class="line">            tmp_xy[k*2 + j] = tmp_xyz[k*4 + j*2] * fx[0] + tmp_xyz[k*4 + j*2 + 1] * fx[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿Y轴插值，得到2个面的值</span><br><span class="line">    for (k = 0; k &lt; 2; k++) &#123;</span><br><span class="line">        tmp_x[k] = tmp_xy[k*2] * fy[0] + tmp_xy[k*2 + 1] * fy[1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 沿Z轴插值，得到最终结果</span><br><span class="line">    *result = (short)(tmp_x[0] * fz[0] + tmp_x[1] * fz[1]);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过三线性插值，系统能够在RC表&#x2F;DFCC表的离散数据点之间生成平滑的过渡值，这带来以下优势：</p>
<ol>
<li><p>平滑过渡：避免在临界点附近出现电量跳变</p>
</li>
<li><p>精细粒度：无需为每个可能的条件定义离散值，大幅减少表的大小</p>
</li>
<li><p>处理边界条件：即使输入参数超出表定义范围，也能提供合理的边界值</p>
</li>
<li><p>适用性广：同一表格可用于各种电池和工作条件</p>
</li>
</ol>
<p>一个插值示例：</p>
<p>场景：电池在-5°C环境下以1500mA电流放电，SOC为25%。</p>
<p>插值过程：</p>
<ol>
<li>温度在-10°C(DFCC_ZDATA[0]&#x3D;-100)和0°C(DFCC_ZDATA[1]&#x3D;0)之间</li>
</ol>
<ul>
<li>温度插值权重：fz[0]&#x3D;0.5, fz[1]&#x3D;0.5</li>
</ul>
<ol>
<li>电流在1000mA(DFCC_YDATA[1])和2000mA(DFCC_YDATA[2])之间</li>
</ol>
<ul>
<li>电流插值权重：fy[0]&#x3D;0.5, fy[1]&#x3D;0.5</li>
</ul>
<ol>
<li>SOC在10%(DFCC_XDATA[1]&#x3D;1000)和30%(DFCC_XDATA[2]&#x3D;3000)之间</li>
</ol>
<ul>
<li>SOC插值权重：fx[0]&#x3D;0.75, fx[1]&#x3D;0.25</li>
</ul>
<p>计算过程：</p>
<ul>
<li><p>获取8个顶点值：</p>
</li>
<li><p>V000 &#x3D; DFCC_table[0<em>3+1][1] &#x3D; 88（-10°C, 1000mA, 10%SOC）</em></p>
</li>
<li><p>V001 &#x3D; DFCC_table[1<em>3+1][1] &#x3D; 85（0°C, 1000mA, 10%SOC）</em></p>
</li>
<li><p>V010 &#x3D; DFCC_table[0<em>3+2][1] &#x3D; 60（-10°C, 2000mA, 10%SOC）</em></p>
</li>
<li><p>V011 &#x3D; DFCC_table[1<em>3+2][1] &#x3D; 75（0°C, 2000mA, 10%SOC）</em></p>
</li>
<li><p>V100 &#x3D; DFCC_table[0<em>3+1][2] &#x3D; 90（-10°C, 1000mA, 30%SOC）</em></p>
</li>
<li><p>V101 &#x3D; DFCC_table[1<em>3+1][2] &#x3D; 85（0°C, 1000mA, 30%SOC）</em></p>
</li>
<li><p>V110 &#x3D; DFCC_table[0<em>3+2][2] &#x3D; 75（-10°C, 2000mA, 30%SOC）</em></p>
</li>
<li><p>V111 &#x3D; DFCC_table[1<em>3+2][2] &#x3D; 75（0°C, 2000mA, 30%SOC）</em></p>
</li>
<li><p>应用三线性插值公式计算最终值（简化计算）：</p>
</li>
<li><p>X方向插值（SOC）：</p>
</li>
<li><p>tmp_xy[0] &#x3D; 88<em>0.75 + 90</em>0.25 &#x3D; 88.5</p>
</li>
<li><p>tmp_xy[1] &#x3D; 60<em>0.75 + 75</em>0.25 &#x3D; 63.75</p>
</li>
<li><p>tmp_xy[2] &#x3D; 85<em>0.75 + 85</em>0.25 &#x3D; 85</p>
</li>
<li><p>tmp_xy[3] &#x3D; 75<em>0.75 + 75</em>0.25 &#x3D; 75</p>
</li>
<li><p>Y方向插值（电流）：</p>
</li>
<li><p>tmp_x[0] &#x3D; 88.5<em>0.5 + 63.75</em>0.5 &#x3D; 76.125</p>
</li>
<li><p>tmp_x[1] &#x3D; 85<em>0.5 + 75</em>0.5 &#x3D; 80</p>
</li>
<li><p>Z方向插值（温度）：</p>
</li>
<li><p>result &#x3D; 76.125<em>0.5 + 80</em>0.5 &#x3D; 78.06</p>
</li>
</ul>
<p>最终校正因子约为78.06%，表示在-5°C、1500mA放电电流和25% SOC条件下，电池实际可用容量约为标称容量的78.06%。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--%E9%97%AE%E9%A2%98%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/18/%E7%94%B5%E9%87%8F%E8%AE%A1--%E9%97%AE%E9%A2%98%E5%92%8C%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">电量计--问题和功能记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-18 15:50:54" itemprop="dateCreated datePublished" datetime="2025-05-18T15:50:54+08:00">2025-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:03:43" itemprop="dateModified" datetime="2025-11-04T17:03:43+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BMS/" itemprop="url" rel="index"><span itemprop="name">BMS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电量计–问题和功能记录"><a href="#电量计–问题和功能记录" class="headerlink" title="电量计–问题和功能记录"></a>电量计–问题和功能记录</h1><h2 id="切换CV相关问题"><a href="#切换CV相关问题" class="headerlink" title="切换CV相关问题"></a>切换CV相关问题</h2><h3 id="充电过充中切cv"><a href="#充电过充中切cv" class="headerlink" title="充电过充中切cv"></a>充电过充中切cv</h3><p>需求描述：（NPC660项目）在充电过充中Host发送SBS73命令切换截止电压，从默认的4.35v切到4.1v，同时Charger充电器也设置截止电压4.15v以保证能充满到4.1v。期望充电到4.1v时rsoc能报100. </p>
<p>问题分析：在充电过充中切换截止电压，之前电量计累计的数据没有清0，导致充满到4.1v时电量还是按4.35v计算，只有70%</p>
<p>解决方案：收到SBS73就复位电量计数据（清0），注意清0会导致rsoc跳变。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081354520.png" alt="image-20250408135441409"></p>
<h3 id="放电过充中切cv"><a href="#放电过充中切cv" class="headerlink" title="放电过充中切cv"></a>放电过充中切cv</h3><p>需求描述：（NPC660项目）按4.35v充满后，如果长时间没拔下充电器，充电器会判断为长时间过充，Host发送SBS73命令切换截止电压，从默认的4.35v切到4.1v，之后放电到4.1v。期望放电到4.1v过充中rsoc能保持100，4.1v以下按正常电量消耗显示，电量无跳变。</p>
<p>问题分析：</p>
<p>（1）切换后Host有时读到soc是0值，可能是正好读到了复位数据。</p>
<p>（2）初始方案是判断电压在4.35~4.1时直接sbsif强制上报100，但4.1v时soc会有跳变。</p>
<p>（3）Host在4.35v时发送cv切换时GGMEM0看到soc是100，但4.35放电到4.1v过充中，soc一直下降，放电到4.1v按真实soc显示会跳变到89。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081405362.png" alt="image-20250408140512307"></p>
<p>解决方案：</p>
<p>（1）测试发现放电中每次发SBS73切cv到4.1v时，GGMEM0 soc都复位到100，因此解决方案是4.1v附近再复位一次电量计数据。</p>
<p>（2）不能在刚刚4.1v时复位，算法来不及刷新数据，会导致soc跳变。在4.1V + 20mV时提前复位。</p>
<p>（3）为了防止跳变，预设了平滑下降数据，平滑追赶跳变soc值。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504081504160.png" alt="image-20250408150400108"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">uint8_t cv_adjusted_flag = 0;</span><br><span class="line">static int16_t adjusted_cv_value = 0;</span><br><span class="line">#define FAKE_SOC_TABLE_SIZE 40</span><br><span class="line">static uint8_t fake_soc[FAKE_SOC_TABLE_SIZE] = &#123;</span><br><span class="line">                99, 99, 98, 98, 97, 97, 96, 96, 95, 95, 94, 94, 93, 93, 92, 92, 91, 91, 90, 90,</span><br><span class="line">                89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70,</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">//main loop每秒调用一次</span><br><span class="line">void check_and_force_soc_if_needed(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 获取当前电池电压</span><br><span class="line">    int16_t current_voltage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS09_BATTVOLT];</span><br><span class="line"></span><br><span class="line">    // 判断是否需要处理CV调整后的特殊情况</span><br><span class="line">    if (cv_adjusted_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果电压仍高于调整后的CV值，保持SOC为100%</span><br><span class="line">        if (current_voltage &gt; adjusted_cv_value)</span><br><span class="line">        &#123;</span><br><span class="line">            // 检查是否是放电状态</span><br><span class="line">            if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0A_BATTCURR] &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //4.1V以上时直接上报100，避免误读到SBS73的reset soc值0.</span><br><span class="line">                ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = 100;</span><br><span class="line">                ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0E_ASOC] = 100;</span><br><span class="line">    </span><br><span class="line">                //接近4.1V时提前reset数据，这样降到4.1v时真实soc能接近100</span><br><span class="line">                //如果不reset，从4.35放电到4.1的电量会被计算到soc，造成4.1v的soc只有90%</span><br><span class="line">                if(current_voltage - adjusted_cv_value &lt; 20)</span><br><span class="line">                    reset_gauge_parameters();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // 电压已降至CV值以下，按真实soc报</span><br><span class="line">            if (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0A_BATTCURR] &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // 不要在这里复位，不然客户会看到soc跳变</span><br><span class="line">                // reset_gauge_parameters();</span><br><span class="line">    </span><br><span class="line">                // 备选: 如果用真实rsoc有跳变(5~15%左右)，做平滑处理，每秒降低soc直到匹配真实soc</span><br><span class="line">                static int idrop = 0;</span><br><span class="line">                if((((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] &lt; fake_soc[idrop]) &amp;&amp;</span><br><span class="line">                   (idrop &lt; FAKE_SOC_TABLE_SIZE))</span><br><span class="line">                &#123;</span><br><span class="line">                    ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS0D_RSOC] = fake_soc[idrop]; </span><br><span class="line">                    idrop++;</span><br><span class="line">                    return; //这里退出，下次继续，直到匹配或者超出fake table</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 清除全局标志</span><br><span class="line">            cv_adjusted_flag = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void smart_charge_func(void)</span><br><span class="line">&#123;</span><br><span class="line">    // SBS73: 超长时间充电切CV值功能</span><br><span class="line">    int16_t host_update = (((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS73_UPDATE_CV] &gt;&gt; 16) &amp; 0xFFFF;</span><br><span class="line">    int16_t update_cv = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS73_UPDATE_CV] &amp; 0xFFFF</span><br><span class="line">    // 如果收到Host发送的CV调整命令</span><br><span class="line">    if (host_update &amp;&amp; update_cv)</span><br><span class="line">    &#123;</span><br><span class="line">        // 记录新的CV值</span><br><span class="line">        adjusted_cv_value = update_cv;</span><br><span class="line"></span><br><span class="line">        // 获取当前电池电压</span><br><span class="line">        int16_t current_voltage = ((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS09_BATTVOLT];</span><br><span class="line"></span><br><span class="line">        // 如果当前电压高于新设定的CV值，设置标志且只设置一次</span><br><span class="line">        if ((cv_adjusted_flag == 0) &amp;&amp;</span><br><span class="line">            (current_voltage &gt; adjusted_cv_value))</span><br><span class="line">        &#123;</span><br><span class="line">            cv_adjusted_flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure>

<h2 id="充电到99停充，自动报百"><a href="#充电到99停充，自动报百" class="headerlink" title="充电到99停充，自动报百"></a>充电到99停充，自动报百</h2><p>FW有优化处理，当Charger提前截止充电了，电池处于idle状态且当前电量在99，Host发送81命令0x3数据通知电量计，电量计idle_process检测此标志位，持续30s后电量计自动报100，避免充电器插着但长时间停充场景的电量到不了100。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504241113416.png" alt="image-20250424111349241"></p>
<h2 id="GGMEM数据使用SBS命令导出"><a href="#GGMEM数据使用SBS命令导出" class="headerlink" title="GGMEM数据使用SBS命令导出"></a>GGMEM数据使用SBS命令导出</h2><p>客户环境下可能没有多的I2C接口能接Cobra上位机去读GGMEM，而问题调试必须依赖于GGMEM数据。</p>
<p>客户的Host代码可以使用SBS D0 ~ D8命令获取GGMEM0 ~8</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504241136014.png" alt="image-20250424113644949"></p>
<h2 id="Host乱切cv导致跳0和满充75问题"><a href="#Host乱切cv导致跳0和满充75问题" class="headerlink" title="Host乱切cv导致跳0和满充75问题"></a>Host乱切cv导致跳0和满充75问题</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251501835.png" alt="image-20250425150103773"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251509651.png" alt="image-20250425150921622"></p>
<p>Host侧代码可通过SBS D0~D8读GGMEM去分析这种跳0问题：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251510572.png" alt="image-20250425151016548"></p>
<p>注意Cobra轮询时间比较长最短1s，有时不一定能观测到soc跳0的值，但GGMEM0第一个DWORD复位为DESIGN FCC &#x3D; 13ec是可以作为判断的。</p>
<p>最终原因就是Host Charger逻辑问题，一直在发SBS73，而FW没加防呆，频繁复位libfg数据，导致最终4.1V时接近OCV查表值的电量75，而不是CV追赶值100.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504251548428.png" alt="image-20250425154850336"></p>
<h2 id="Cycle-count放电循环次数"><a href="#Cycle-count放电循环次数" class="headerlink" title="Cycle-count放电循环次数"></a>Cycle-count放电循环次数</h2><p>SBS17 cycle-count &#x3D; 总放电量&#x2F;电池容量，每秒更新</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505071010300.png" alt="image-20250507101040214"></p>
<p>不接i2c多次循环再读cycle count可以读到更新，因为sleep机制下会有timer每60s唤醒一次持续1s，更新libfg信息，包括累计discharge ccmah，计算cycle count</p>
<h2 id="USB模式和AC-Charger模式的eocma调整接口"><a href="#USB模式和AC-Charger模式的eocma调整接口" class="headerlink" title="USB模式和AC Charger模式的eocma调整接口"></a>USB模式和AC Charger模式的eocma调整接口</h2><p>USB口只有500mA电流，应该保证USB充电的eocma小于500mA，典型值是200mA。参数的满充截止电流如果和USB电流相等都是500mA，host必须发SBS74切eocma到200mA，否则充电尾端加速过快，容易读到电量跳变。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202505151622340.png" alt="image-20250515162238231"></p>
<h2 id="NTC表的两种形式"><a href="#NTC表的两种形式" class="headerlink" title="NTC表的两种形式"></a>NTC表的两种形式</h2><p>SD77561原版使用电压-电阻查表；SD77428A3使用电阻-温度查表，支持6uA&#x2F;48uA两种电流源切换，大电流源保证高温时R*I &#x3D; V有更大的值，这样电压ADC有更高精度。现在需要将SD77561的电压-电阻查表改成电阻-温度查表，支持6uA&#x2F;72uA两种电流源切换：</p>
<p>(1)首先将SD77428代码里已经有的R-T表，手动创建一个77561 PRJ的NTC.txt格式表：</p>
<p>x轴是16个采样点，total length是cobra解析此表的参数总和，即16*2 (x和y) + 6(header) &#x3D; 38</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202506301553903.png" alt="image-20250630155253817"></p>
<p>(2)修改ADC查表方式，并添加高温切换大电流源</p>
<p>代码分支：HaoPeng-I0917A</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Copy raw thm voltage to buffer</span><br><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_val = sbs_cal_lsb_factor((int32_t)(dacq_p-&gt;raw_buff[((SBSIF_T *)psbsifHandle)-&gt;sbs_val]), ADC_EXTMPLSB, ADC_EXTMPLSB_FACTOR);</span><br><span class="line">//暂存，后面切换电流源用到此raw电压作为条件</span><br><span class="line">temp2 = ((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line">/* find Re, with 20uA source */</span><br><span class="line">// we modify thermal table as Voltage V.S. Temperature, so don&#x27;t need to multiple THM_OHM</span><br><span class="line">//((SBSIF_T *)psbsifHandle)-&gt;sbs_val 		*= (THM_OHM);						//Re = 1000uV / 20uA ==&gt; Ohm</span><br><span class="line"></span><br><span class="line">//转换电压成电阻：电压*1000精度/电流源 = NTC R，支持72ua和6ua电流源，72uA为了高温下高精度测量</span><br><span class="line">if(EXTNTCSRC_72UA == Chip_ADC_GetNTCSrc()) </span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= (1000/72);</span><br><span class="line">else</span><br><span class="line">    ((SBSIF_T *)psbsifHandle)-&gt;sbs_val *= (1000/6);</span><br><span class="line"></span><br><span class="line">//查表，改成电阻-温度表</span><br><span class="line">lut_one_latitude(TEMPERATURE_DATA_NUM,</span><br><span class="line">                 (one_latitude_data_t *)GDM_FLASH_THML_TABLE,</span><br><span class="line">                 ((SBSIF_T *)psbsifHandle)-&gt;sbs_val,</span><br><span class="line">                 &amp;temp1);</span><br><span class="line">temp1 += DK_BASE;</span><br><span class="line">//记录温度</span><br><span class="line">((SBSIF_T *)psbsifHandle)-&gt;sbs_buff[SBS61_ETDK1] = temp1 - (int32_t)(param_board_cfg[PARM_BCFG_EXTTHMOFFSET]); //((SBSIF_T *)psbsifHandle)-&gt;sbs_val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据ntc电压（温度状况）决定电流源切换提高精度：</span><br><span class="line">//高温ntc电压小于60mV切换72uA，常温低温ntc电压大于900mV切换6uA</span><br><span class="line">if((temp2 &lt; 60) &amp;&amp; (EXTNTCSRC_6UA == Chip_ADC_GetNTCSrc()))&#123;</span><br><span class="line">    Chip_ADC_SetNTCSrc(EXTNTCSRC_72UA);</span><br><span class="line">&#125;else if ((temp2 &gt; 900) &amp;&amp; (EXTNTCSRC_72UA == Chip_ADC_GetNTCSrc()))&#123;</span><br><span class="line">    Chip_ADC_SetNTCSrc(EXTNTCSRC_6UA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在线升级bin和参数对照"><a href="#在线升级bin和参数对照" class="headerlink" title="在线升级bin和参数对照"></a>在线升级bin和参数对照</h2><p>终端在线升级出问题一般只会回传bin，需要对照bin的参数是怎么配置的，注意bin没有8K的bootloader offset即可找到参数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507232039915.png" alt="image-20250723203915801"></p>
<p>缺失的参数定义在C:\git-834\COBRA\COBRA Documents\SD77226SBS_X_20250315\Project\Parameter查看</p>
<h2 id="SOH更新原理"><a href="#SOH更新原理" class="headerlink" title="SOH更新原理"></a>SOH更新原理</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507251146800.png" alt="image-20250725114616713"></p>
<h2 id="77428-Host驱动使用硬件I2C判断通信问题"><a href="#77428-Host驱动使用硬件I2C判断通信问题" class="headerlink" title="77428 Host驱动使用硬件I2C判断通信问题"></a>77428 Host驱动使用硬件I2C判断通信问题</h2><p>i2c sbs接口持续错误可用此方式判断是硬件问题还是软件问题</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507251147766.png" alt="image-20250725114726725"></p>
<h2 id="注释函数大幅减少Code段占用"><a href="#注释函数大幅减少Code段占用" class="headerlink" title="注释函数大幅减少Code段占用"></a>注释函数大幅减少Code段占用</h2><p>一般注释掉函数的调用处，但不注释函数体本身，只会减少运行时堆栈，并不会减少Code代码段，；但是561 KEIL项目注释main的libfg_update后，Code段从36K减到20K</p>
<p>原因是编译器优化：未被调用的函数被从Image中移除；只有被调用的函数体才存放在Image。</p>
<p>如下图分别是不调用和调用libfg_update时的.map信息：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507291025458.png" alt="image-20250729102546398"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202507291026312.png" alt="image-20250729102611276"></p>
<h2 id="SD77428-power-supply框架获取电量信息"><a href="#SD77428-power-supply框架获取电量信息" class="headerlink" title="SD77428 power supply框架获取电量信息"></a>SD77428 power supply框架获取电量信息</h2><p>框架参考：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/power/power_supply_class.html">https://www.kernel.org/doc/html/latest/power/power_supply_class.html</a></p>
<p>代码见&lt;include&#x2F;linux&#x2F;power_supply.h&gt;</p>
<p>基本原理是dev设备，注册power supply属性，其中的desc描述结构包含get_property回调函数接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int32_t sd77428_power_supply_init(struct sd77428_data *chip)</span><br><span class="line">&#123;</span><br><span class="line">    chip-&gt;bat_cfg.drv_data = chip;</span><br><span class="line">    chip-&gt;bat_cfg.of_node = chip-&gt;client-&gt;dev.of_node;</span><br><span class="line"></span><br><span class="line">    chip-&gt;bat_desc.name = &quot;sd77428&quot;;</span><br><span class="line">    chip-&gt;bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;</span><br><span class="line">    chip-&gt;bat_desc.properties = sd77428_battery_props;</span><br><span class="line">    chip-&gt;bat_desc.num_properties = ARRAY_SIZE(sd77428_battery_props);</span><br><span class="line">    chip-&gt;bat_desc.get_property = sd77428_battery_get_property; //这里是get_property回调</span><br><span class="line">    chip-&gt;bat_desc.no_thermal = 1;</span><br><span class="line">    chip-&gt;bat_desc.external_power_changed = sd77428_external_power_changed;</span><br><span class="line"></span><br><span class="line">    chip-&gt;bat = devm_power_supply_register(chip-&gt;dev, &amp;chip-&gt;bat_desc, &amp;chip-&gt;bat_cfg);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>驱动实现get_property回调，关联电量信息和上报的状态，有的信息需要映射，例如SOH不能直接上报值只能报状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">case POWER_SUPPLY_PROP_VOLTAGE_NOW:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_voltage; //mV</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CURRENT_NOW:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_current; //mA</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CAPACITY: //capacity in percents(soc), from 0 to 100</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_rsoc;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_TEMP:</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_temp; //单位：摄氏度</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN: //design charge capacity</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_capacity;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_FULL: //full-charge-capacity(FCC)</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_fcc; </span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case POWER_SUPPLY_PROP_CHARGE_NOW: //charge capacity now</span><br><span class="line">    val-&gt;intval = chip-&gt;batt_info.batt_rc;</span><br><span class="line">    break;</span><br><span class="line">    </span><br><span class="line">case POWER_SUPPLY_PROP_HEALTH:</span><br><span class="line">    //val-&gt;intval = chip-&gt;batt_info.batt_soh; //不能直接返回SOH值</span><br><span class="line">    val-&gt;intval = POWER_SUPPLY_HEALTH_GOOD; //根据状态返回POWER_SUPPLY_HEALTH定义的状态</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<p>然后linux应用层通过sysfs访问power_supply路径下的节点，设备名称是前面注册的.name名称(sd77428)，路径下是各属性都像文件一样访问。</p>
<p>用uevent查看节点的所有实时信息，power_supply节点的任何信息的更新都会反映到默认属性uevent(power_supply属于uevent子类，基于uevent通知机制实现)；如果只查看某个信息如capacity，charge_now，都可以分开cat查看</p>
<p>如下是终端输出，sysfs查看uevent和驱动打印的电池信息是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@phytiumpi:~# ls /sys/class/power_supply</span><br><span class="line">sd77428</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# ls /sys/class/power_supply/sd77428 </span><br><span class="line">capacity            charge_now   device  power    status     temp  uevent</span><br><span class="line">charge_full_design  current_now  health  present  subsystem  type  voltage_now</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# cat /sys/class/power_supply/sd77428/uevent</span><br><span class="line">POWER_SUPPLY_NAME=sd77428</span><br><span class="line">POWER_SUPPLY_STATUS=Discharging</span><br><span class="line">POWER_SUPPLY_PRESENT=1</span><br><span class="line">POWER_SUPPLY_VOLTAGE_NOW=4089</span><br><span class="line">POWER_SUPPLY_CURRENT_NOW=0</span><br><span class="line">POWER_SUPPLY_CAPACITY=98</span><br><span class="line">POWER_SUPPLY_TEMP=25</span><br><span class="line">POWER_SUPPLY_CHARGE_FULL_DESIGN=3400</span><br><span class="line">POWER_SUPPLY_CHARGE_FULL=3400</span><br><span class="line">POWER_SUPPLY_CHARGE_NOW=3318</span><br><span class="line">POWER_SUPPLY_HEALTH=Good</span><br><span class="line"></span><br><span class="line">root@phytiumpi:~# [   23.297385] [bmt]sd77428_get_batt_info: vbat:4089, ibat:00000, tbat:25, rsoc:098, fcc:3400, dcap:3400, soh:100, cycle:0, rc:3318, dfcc:3798, cc:8242, ext_chg -1</span><br></pre></td></tr></table></figure>

<h2 id="561-cobra导出EEPROM-64K数据"><a href="#561-cobra导出EEPROM-64K数据" class="headerlink" title="561 cobra导出EEPROM 64K数据"></a>561 cobra导出EEPROM 64K数据</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510091639531.png" alt="image-20251009163917427"></p>
<p>从左到右依次read all，每次export一个bin，得到3个bin，然后用hex editor合并成一个64KB的bin，按EEPROM+Sytem+Information合并</p>
<h2 id="561-SBS改成428格式，交叉测试"><a href="#561-SBS改成428格式，交叉测试" class="headerlink" title="561 SBS改成428格式，交叉测试"></a>561 SBS改成428格式，交叉测试</h2><p>LK阶段问题怀疑是428使用轮询I2C造成slave持续拉低clock&#x2F;data，561使用中断处理I2C，为了快速验证，不改host 428驱动情况下，使用561修改部分命令成428格式测试。</p>
<p>改两处即可：I2C slave地址，SBS命令的值和长度。注意Slave地址设置原代码有问题，应该直接赋值SADDR1，不能或等，否则COM通信失败</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111445198.png" alt="image-20251011144509147"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111444197.png" alt="image-20251011144420090"></p>
<h2 id="561-使用轮询方式处理I2C"><a href="#561-使用轮询方式处理I2C" class="headerlink" title="561 使用轮询方式处理I2C"></a>561 使用轮询方式处理I2C</h2><p>需求同上，为了对比测试428问题，561使用轮询i2c方式</p>
<p>修改两处：</p>
<p>1.i2c slave handle加到while1 ms轮询</p>
<p>2.关闭NVIC I2C中断开关 （561基于ARM，428的riscv是另外一套PLIC关闭）</p>
<p>注意自定义的数字逻辑也有中断使能和中断状态，这个和NVIC中断是无关的，属于内部状态，所以即使关了外部NVIC中断开关，也只是切断了ISR回调处理，轮询方式调用i2c slave handle仍可以读内部i2c register中断状态判断是读是写是传输完成，只要保证清除状态，不要重复处理即可。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202510111452813.png" alt="image-20251011145237741"></p>
<h2 id="77428A3不更新FCC问题"><a href="#77428A3不更新FCC问题" class="headerlink" title="77428A3不更新FCC问题"></a>77428A3不更新FCC问题</h2><p>A3驱动下载参数后需要发SBS8F带非0参数，reset_lib去更新FCC&#x3D;Design Capacity</p>
<p><img src="https://s3.bmp.ovh/imgs/2025/10/28/f21ba8363f115b8d.png" alt="image-20251028142924671"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--Firmware%20Architecture%20part2%EF%BC%9ABMS%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AJEV323%E5%92%8CSkyways/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--Firmware%20Architecture%20part2%EF%BC%9ABMS%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AJEV323%E5%92%8CSkyways/" class="post-title-link" itemprop="url">STM32--Firmware Architecture part2：业务代码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:22:20" itemprop="dateModified" datetime="2025-11-04T17:22:20+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MCU%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">MCU驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–Firmware-Architecture-part2：业务代码分析–o2link-FWs"><a href="#STM32–Firmware-Architecture-part2：业务代码分析–o2link-FWs" class="headerlink" title="STM32–Firmware Architecture part2：业务代码分析–o2link FWs"></a>STM32–Firmware Architecture part2：业务代码分析–o2link FWs</h1><h1 id="o2link-FWs的架构区别"><a href="#o2link-FWs的架构区别" class="headerlink" title="o2link FWs的架构区别"></a>o2link FWs的架构区别</h1><p>o2link FWs指三类：</p>
<ul>
<li>o2link original FW(gen2): 用于老项目的对外发布版FW</li>
<li>o2link JEV323 FW: 在o2link original FW上，针对JEV323做了功能改动和架构改动</li>
<li>o2link Skyways FW: 在o2link original FW上，针对Skyways做了功能改动</li>
</ul>
<h2 id="Bootloader和Firmware结构"><a href="#Bootloader和Firmware结构" class="headerlink" title="Bootloader和Firmware结构"></a>Bootloader和Firmware结构</h2><h3 id="bootloader和Firmware在Flash的分布"><a href="#bootloader和Firmware在Flash的分布" class="headerlink" title="bootloader和Firmware在Flash的分布"></a>bootloader和Firmware在Flash的分布</h3><ol>
<li>o2link original FW和o2link Skyways FW是分为bootloader和Firmware两部分，两者共同构成烧录的bin文件</li>
</ol>
<ul>
<li><p>bootloader：放在Flash的0x0800_0000 ~ 0x0x0800_8000空间，空间32KB；用作USB上位机烧录Firmware到Flash功能。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171036206.png" alt="image-20240517103655180"></p>
</li>
<li><p>Firmware: 放在Flash的0x0800_8000~ 0x0801_0000空间，空间32KB；用作处理USB上位机下发的各种控制、读写请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171037852.png" alt="image-20240517103700830"></p>
<p>bootloader和Firmware所有代码在Flash的分布如下：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171117725.png" alt="image-20240517111755697"></p>
<p>注意：ROM&#x2F;RAM空间分布对应到.sct的配置内容需要特别小心：</p>
<p>Bootloader的.sct:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00008000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00008000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x200000C0 0x00003F30  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Firmware的.sct: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08008000 0x00008000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08008000 0x00008000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x200000C0 0x00003F30  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有正确配置.sct, 例如把Firmware的.sct LR&#x2F;ER起始地址配成0x0800_0000,后面用JLink烧录时就报错：No Algorithm for 0x80000000~0x….，Flash program fail. 因为JLink发现program的地址和.sct指定的LR&#x2F;ER地址不一致。</p>
<p>2.o2link JEV323 FW是简化后的架构，只包含firmware部分，不支持USB上位机烧录FW bin：</p>
<ul>
<li><p>Firmware: 放在Flash的0x0800_0000~ 0x0801_0000空间，空间64KB；用作处理USB上位机下发的各种控制、读写请求。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171037152.png" alt="image-20240517103730129"></p>
</li>
</ul>
<p>3.RAM空间的分布</p>
<p>上面bootloader+FW架构的Keil配置中，bootloader和FW的RAM空间都是从0xC0偏移开始的，不是从RAM的0x00，</p>
<p>而单FW架构，FW是从RAM的0开始。</p>
<p>原因是bootloader跳转执行FW时，需要从Flash拷贝中断向量表192bytes(0xC0)到RAM起始地址，所以FW代码的RAM数据区不划分这块空间。详见direct_jump_to_app()</p>
<h3 id="IAP和ICP的概念"><a href="#IAP和ICP的概念" class="headerlink" title="IAP和ICP的概念"></a>IAP和ICP的概念</h3><p>为什么有两种代码结构分布？涉及到以下两种烧录Firmware的方式：参考STM32 RM0091文档</p>
<p>• IAP (in-application programming): IAP is the ability to re-program the flash memory of a microcontroller while the user program is running.</p>
<p>• ICP (in-circuit programming): ICP is the ability to program the flash memory of amicrocontroller using the JTAG protocol, the SWD protocol or the bootloader while thedevice is mounted on the user application board.</p>
<p>o2link作为成熟的产品，需要支持用户侧烧录firmware(IAP)，因此开发了USB接口的IAP烧录功能，这部分划分为bootloader。</p>
<blockquote>
<p>An important requirement for most Flash-memory-based systems is the ability to update firmware when installed in the end product. This ability is referred to as in-application programming (IAP).</p>
<p>The IAP code uses the USB to:</p>
<p>● Download a binary file from the USB HID to the STM32F0xx’s internal Flash memory.</p>
<p>● Upload the STM32F0xx’s internal Flash memory content (starting from the defined user </p>
<p>application address) into a binary file.</p>
<p>● Execute the user program.</p>
</blockquote>
<p>（实质上这不是真正意义的bootloader，仅仅是firmware update功能；如果firmware代码在SRAM运行，这部分功能完全可以做到Firmware代码中去，不用占用32KB空间）</p>
<p>jev323 firmware目前是内部测试用，因此不需要IAP，用Jlink的ICP方式烧录。全部Flash空间(64KB)可用于业务流程。</p>
<h3 id="bootloader和firmware的执行流程"><a href="#bootloader和firmware的执行流程" class="headerlink" title="bootloader和firmware的执行流程"></a>bootloader和firmware的执行流程</h3><p>参考o2link spec:</p>
<ul>
<li><p>bootloader基本逻辑是：每次上电RESET时，先执行bootloader判断当前Flash的firmware区域（app）有没有valid FW能执行？如果有，就跳转firmware的main去执行；如果没有，bootloader启动IAP流程，响应USB上位机的erase flash、program firmware的指令，完成以后再跳转执行firmware指令；</p>
</li>
<li><p>firmware在执行时，如果收到USB上位机的IAP命令(USB_IAP_JUMP_TO_BOOT)，就是要跳转到bootloader，准备IAP去下载新的firmware bin；其他情况不会跳转到bootloader。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171055206.png" alt="image-20240517105536135"></p>
<h2 id="bootloader代码分析（重要-难点）"><a href="#bootloader代码分析（重要-难点）" class="headerlink" title="bootloader代码分析（重要+难点）"></a>bootloader代码分析（重要+难点）</h2><p>整个bootloader代码和Firmware流程都是main初始化+While1轮询USB请求的结构，区别在于执行流程。</p>
<h3 id="bootloader校验FW"><a href="#bootloader校验FW" class="headerlink" title="bootloader校验FW"></a>bootloader校验FW</h3><p>bootloader的main初始化系统时钟后，就立即check FW是否valid：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	HAL_Init();</span><br><span class="line">	SystemClock_Config();</span><br><span class="line">	//判断FW是否valid</span><br><span class="line">	check_if_jump_to_app();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">check_if_jump_to_app():</span><br><span class="line"></span><br><span class="line">    if(*(uint32_t *)RAM_FROM_APP_FLAG_ADDR != RAM_FROM_APP_FLAG_DATA)&#123;</span><br><span class="line">            *(uint32_t *)RAM_FROM_APP_FLAG_ADDR = 0;</span><br><span class="line">            if((*(uint32_t *)APP_FILE_EDN_ADDR == APP_FILE_END_DATA) &amp;&amp; </span><br><span class="line">                ( *(uint32_t *)APP_FILE_START_ADDR == APP_FILE_START_DATA) &amp;&amp;</span><br><span class="line">                (pin_state == GPIO_PIN_SET)) //PB4</span><br><span class="line">                direct_jump_to_app();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>校验FW有效包括三个条件都要满足：</p>
<ol>
<li>查看RAM 0x3f3C位置(0x20003f3C)的DWORD是否为RAM_FROM_APP_FLAG_DATA(0x6a756d70)，然后清0。这个flag是USB上位机下发USB_IAP_JUMP_TO_BOOT时调用jump_to_boot()设置的，这个USB请求在bootloader或FW阶段都可能被发起。</li>
</ol>
<p>​      目的：确认是上位机发起的jump to boot，而不是其他原因比如CPU异常reset进入的boot。</p>
<ol start="2">
<li><p>查看Flash的FW区域（0x0800_8000开始）的开始（0x08008014）和尾部区域（0x0800fffc）的两个DWORD是否分别为0x00617070和0x00656e64。</p>
<p>目的：确认Flash的FW是valid，确认尾部是确保数据完整</p>
</li>
<li><p>查看PB4 pin是否为高。</p>
<p>目的：根据原例图，可能是防止和one-wire功能冲突？待确认</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171138048.png" alt="image-20240517113801021"></p>
</li>
</ol>
<h3 id="bootloader跳转到FW代码的过程"><a href="#bootloader跳转到FW代码的过程" class="headerlink" title="bootloader跳转到FW代码的过程"></a>bootloader跳转到FW代码的过程</h3>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">direct_jump_to_app():</span><br><span class="line"></span><br><span class="line">#define  APPLICATION_ADDRESS   (0x08000000 + 0x8000) //FW在Flash的起始地址 </span><br><span class="line"></span><br><span class="line">void direct_jump_to_app(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	uint32_t JumpAddress;</span><br><span class="line">	pFunction Jump_To_Application;</span><br><span class="line">	</span><br><span class="line">	__disable_irq(); </span><br><span class="line">	</span><br><span class="line">	//拷贝Firmwware的192bytes的中断向量表到SRAM</span><br><span class="line">	for(i = 0; i &lt; 48; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		*((uint32_t*)(0x20000000 + (i &lt;&lt; 2)))=*(__IO uint32_t*)(APPLICATION_ADDRESS + (i&lt;&lt;2));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 /* Test if user code is programmed starting from address &quot;APPLICATION_ADDRESS&quot; */</span><br><span class="line">	 //判断栈指针是否位于SRAM</span><br><span class="line">	if (((*(__IO uint32_t*)APPLICATION_ADDRESS) &amp; 0x2FFE0000 ) == 0x20000000)</span><br><span class="line">    &#123; /* Jump to user application */</span><br><span class="line">      </span><br><span class="line">      	//设置函数指针，跳转到Firmware的RESET入口</span><br><span class="line">		JumpAddress = *(__IO uint32_t*) (APPLICATION_ADDRESS + 4);</span><br><span class="line">		Jump_To_Application = (pFunction) JumpAddress;</span><br><span class="line">		</span><br><span class="line">		/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">		__set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);</span><br><span class="line">		</span><br><span class="line">		//执行跳转</span><br><span class="line">		Jump_To_Application();</span><br><span class="line">	&#125;  </span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		__enable_irq();</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（1）拷贝Firmwware的192bytes的中断向量表到SRAM</strong></p>
<p><strong>Q1：为什么要拷贝？中断向量表放在Flash中不能执行吗？</strong></p>
<p>Cortex M0的限制：Flash的中断向量表一定要放在Flash开始的地方，不能relocation到Flash的其他偏移地址，参考Reference Manual RM0091：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171723698.png" alt="image-20240517172328661"></p>
<p>Firmware中断向量表是放在Flash的32KB offset的地方，是不能被硬件使用的；</p>
<p>RM0091给出Cortex M0对此问题的方案：将中断向量表拷贝到SRAM的0地址，再设置SYSCFG register，remap SRAM空间作为CPU 0地址。这样CPU异常、中断发生时，就能进入SRAM的中断向量表。</p>
<p><strong>Q2：为什么只需要拷贝中断向量表的192bytes，而不是拷贝整个Firmware的32KB？SRAM空间都remap为CPU 0地址了，Flash中的Firmware代码不拷贝到SRAM还能执行到吗？</strong></p>
<p>这里要分析MCU的PC指针取指令的流程：</p>
<ol>
<li>在bootloader开始阶段，PC指针取指令都是在Flash 起始地址~32KB之间取bootloader指令执行</li>
<li>bootloader拷贝FW中断向量表到SRAM的0地址，并设置CPU memory空间为SRAM空间 (注释1)</li>
<li>bootloader跳转，注意看上面代码，跳转到Flash的Firmware空间(Flash 32KB~64KB)的Firmware入口，也就是说，PC指针还是从Flash取指令，只不过指令是Firmware的main</li>
<li>Firmware执行main初始化和while1，PC指针始终在while1中转圈</li>
<li>如果中断或者异常发生，硬件跳转到SRAM的Firmware中断向量表，取中断回调指令执行，这个中断回调指令还是在Flash的Firmware空间(Flash 32KB~64KB)，中断返回后，PC指针恢复之前在Firmware while1里的位置。</li>
</ol>
<p>根据以上分析，PC指针仅仅在中断发生时需要用跳到SRAM的中断向量表，其他时间都在Flash的Firmware区域取指令，所有Firmware代码都能被执行到。因此SRAM remap不影响Flash的代码执行，不需要拷贝Firmware代码到SRAM (要拷贝FW到SRAM以提高执行速度也行，要改Firmware编译的基地址为SRAM)。</p>
<p>（注释1）CPU remap实际在main才设置（但应该在bootloader里设置），代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__HAL_REMAPMEMORY_SRAM();</span><br><span class="line"></span><br><span class="line">#define __HAL_REMAPMEMORY_SRAM                __HAL_SYSCFG_REMAPMEMORY_SRAM</span><br><span class="line">#define __HAL_SYSCFG_REMAPMEMORY_SRAM()         do &#123;SYSCFG-&gt;CFGR1 &amp;= ~(SYSCFG_CFGR1_MEM_MODE); \</span><br><span class="line">                                             SYSCFG-&gt;CFGR1 |= (SYSCFG_CFGR1_MEM_MODE_0 | SYSCFG_CFGR1_MEM_MODE_1); \</span><br><span class="line">                                            &#125;while(0) </span><br></pre></td></tr></table></figure>

<p><strong>关于CPU空间的remapping，有两个概念需清楚：</strong></p>
<ol>
<li><p>CPU空间remap到SRAM还是Flash，并不影响CPU对Flash和SRAM的访问；</p>
<p>不管谁被remap为CPU memory空间，pc取指令都可以用0x0800_0000 + offset访问Flash，0x2000_0000 + offset访问SRAM</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171747713.png" alt="image-20240517174752681"></p>
</li>
<li><p>CPU remap只影响”MCU的0地址在哪个设备空间“，和启动位置相关；</p>
<p>SYSCFG register的CPU memory mapping定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171745110.png" alt="image-20240517174553060"></p>
<p>注意该SYSCFG register配置会被reset，即reset启动后的CPU space是BOOT0 pin和nBOOT1 register共同决定的：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171756653.png" alt="image-20240517175619616"></p>
</li>
</ol>
<p><strong>Q3：Firmware和bootloader的中断向量表的指令应该差不多，为什么不能公用一套中断向量表？</strong></p>
<p>这个问题涉及到编译和链接：bootloader和Firmware的中断向量表的指令还是有区别，因为中断回调不同，导致必须要分两套中断向量表；</p>
<p>两套中断向量表编译出的基础地址不一样：如下图bootloader中断向量表指令都是基于0x0800_8000，FW的都是0x0800_0000。这个基础地址是.sct链接文件指定。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171859345.png" alt="image-20240517185911311"></p>
<p><strong>（2）跳转到Firmwware指令</strong></p>
<p>跳转的条件判断是个难点：为什么要判断FW代码的首个DWORD的值是否在SRAM空间？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (((*(__IO uint32_t*)APPLICATION_ADDRESS) &amp; 0x2FFE0000 ) == 0x20000000)</span><br></pre></td></tr></table></figure>

<p>FW代码的首个DWORD的值是什么：</p>
<p>参考FW的startup.s：是__initial_sp符号，找不到具体指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp                   ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                  ; Reset Handler</span><br></pre></td></tr></table></figure>

<p>__initial_sp符号符号是什么：</p>
<p>FW的startup.s只能找到声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size		EQU     0x500</span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br></pre></td></tr></table></figure>

<p>对此代码的解释：</p>
<p>__initial_sp is a label which takes the origin (ORG) value of the assembler after it allocates the space. Look at a .LST or .MAP file.</p>
<p>参考：<a target="_blank" rel="noopener" href="https://community.st.com/t5/stm32-mcus-products/about-initial-sp/td-p/551812">https://community.st.com/t5/stm32-mcus-products/about-initial-sp/td-p/551812</a></p>
<p>基于此解释，查看FW的.map，找到symbol的分布：</p>
<p>最后一个Data symbol是uwTick，尾部地址是0x20003514 + 4 &#x3D; 0x20003518；</p>
<p>__initial_sp符号的起始地址正好是0x20003518 + 0x500（startup.s指定的Stack_Size），因此验证了以上解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Global Symbols</span><br><span class="line"></span><br><span class="line">    Symbol Name                              Value     Ov Type        Size  Object(Section)</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">    huart1                                   0x20001a3c   Data         132  usart.o(.bss.huart1)</span><br><span class="line">    huart2                                   0x20001ac0   Data         132  usart.o(.bss.huart2)</span><br><span class="line">    huart3                                   0x20001b44   Data         132  usart.o(.bss.huart3)</span><br><span class="line">    one_wire_data                            0x20001fcc   Data         152  one_wire.o(.bss.one_wire_data)</span><br><span class="line">    uart_rx_fifo_buf                         0x20002064   Data        5120  main.o(.bss.uart_rx_fifo_buf)</span><br><span class="line">    uwTick                                   0x20003514   Data           4  stm32f0xx_hal.o(.bss.uwTick)</span><br><span class="line">    __initial_sp                             0x20003a18   Data           0  startup_stm32f072xb.o(STACK)</span><br></pre></td></tr></table></figure>

<p>基于以上，__initial_sp 是编译器自动形成的值，作为RAM中的栈顶位置。</p>
<p>bootloader设置Stack_Size为0x500，编译器就在RAM中把所有全局变量排列完后，在加0x500作为栈空间，也就是说这个值最后是取决于代码数据占的RAM空间的，并不是固定的RAM最尾部的地址。</p>
<p>注：Stack_Size值应该根据.map情况，设置成和RAM可用栈空间接近，不然RAM空间没充分利用，形成爆栈。</p>
<p>所以FW的第一个指令保存了RAM中的栈顶（栈起始地址），第二个指令才是RESET。</p>
<p>前面代码是bootloader对__initial_sp 判断是否在RAM空间，因为跳转时要设置栈指针的安全性判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">__set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);</span><br></pre></td></tr></table></figure>

<p><strong>（3）Jump_To_Application函数指针</strong></p>
<p>这里不详细分析。STM32 bootloader跳转FW有模板代码，参考原厂固件库代码。</p>
<h2 id="Flash烧录问题（重要）"><a href="#Flash烧录问题（重要）" class="headerlink" title="Flash烧录问题（重要）"></a>Flash烧录问题（重要）</h2><h3 id="用Keil的JLink烧录Flash"><a href="#用Keil的JLink烧录Flash" class="headerlink" title="用Keil的JLink烧录Flash"></a>用Keil的JLink烧录Flash</h3><p>Keil内置安装JLink，Keil烧录.bin到开发板的Flash，实际是调用内置的JLink烧录。</p>
<p>对于Bootloader和Firmware，需要正确配置烧录区域：</p>
<ul>
<li>Address Range： .bin文件烧录到Flash的区域(一般是Flash空间)；这个区域应该和Keil项目配置的ROM区域一致</li>
<li>Erase Sectors：只擦除选中的Flash Address Range的sectors</li>
<li>RAM for Algorithm：这个跟烧录的.bin运行时RAM没关系，是指烧录程序本身要占用的RAM，参考：<a target="_blank" rel="noopener" href="https://www.keil.com/support/man/docs/ulinkme/ulinkme_su_ram_for_algorithm.htm">https://www.keil.com/support/man/docs/ulinkme/ulinkme_su_ram_for_algorithm.htm</a></li>
</ul>
<p>o2link的bootloader：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201046576.png" alt="image-20240520104651534"></p>
<p>o2link的firmware：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201047437.png" alt="image-20240520104700405"></p>
<h3 id="如何确认Flash正确烧录"><a href="#如何确认Flash正确烧录" class="headerlink" title="如何确认Flash正确烧录"></a>如何确认Flash正确烧录</h3><p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/lnfiniteloop/article/details/134575496?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-134575496-blog-118443669.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-134575496-blog-118443669.235%5Ev43%5Epc_blog_bottom_relevance_base4&utm_relevant_index=2">J-Flash读取STM32内部程序，导出Hex&#x2F;Bin文件</a></p>
<p>JLink安装，需要安装包里的USB驱动：SEGGER\JLink_V796e\USBDriver\x64\dpinst_x64.exe</p>
<p>使用JLink读Flash并比较：</p>
<ol>
<li>JLink: Target -&gt; Connect</li>
<li>读Flash(一般Range或者Entire chip)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112900.png" alt="image-20240520111220863"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112614.png" alt="image-20240520111250598"></p>
<ol start="3">
<li>保存数据到.bin</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201112851.png" alt="image-20240520111256831"></p>
<ol start="4">
<li>比较bootloader.bin和从Flash读出的数据.bin是否一致：</li>
</ol>
<p>使用Winmerge比较二进制文件：</p>
<p>左侧bootloader.bin，右侧Flash读出的bootloader；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201104475.png" alt="image-20240520110440432"></p>
<p>可见bootloader真实数据约0x7524 bytes；Flash擦除整个bootloader区域0~0x8000, 所以Flash读的后部分数据为0xFF。</p>
<p>Firmware区域比较同理，JLink的Flash读出区域改成0x08008000~0x08010000</p>
<h2 id="特殊的编译和代码修改记录"><a href="#特殊的编译和代码修改记录" class="headerlink" title="特殊的编译和代码修改记录"></a>特殊的编译和代码修改记录</h2><p>编译问题：</p>
<ol>
<li><p>Firmware编译无法输出.bin文件但Keil没报错，输出了ER$$.ARM.__at_0x0800fffc文件</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405201155089.png" alt="image-20240520115554066"></p>
<p>原因：main定义了以下section，但链接器找不到这个符号，所以生成bin时报error</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const uint32_t file_end __attribute__((section(&quot;.ARM.__at_0x0800fffc&quot;))) = 0x00656e64;</span><br></pre></td></tr></table></figure>

<p>目前没找到根本性的解决办法；因为代码没用到这个file_end，所以注释掉这个定义。这个定义地址本身是合理的，是Firmware的Flash区域的最后一个DWORD。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/dui0474/m/scatter-loading-features/root-execution-regions/methods-of-placing-functions-and-data-at-specific-addresses?lang=en">Methods of placing functions and data at specific addresses</a></p>
<p><a target="_blank" rel="noopener" href="https://documentation-service.arm.com/static/63eb51fc9567172d4e2aa918">ARM asmlink User Guide</a></p>
</li>
</ol>
<p>代码问题：</p>
<p>bootloader+Firmware只支持用USB上位机更新Firmware，不支持JLink烧录Firmware，因为bootloader校验Dword不通过；所以需要修改bootloader代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void check_if_jump_to_app(void):</span><br><span class="line"></span><br><span class="line">#ifdef SKYWAYS_TEST</span><br><span class="line">	direct_jump_to_app(); //这里直接跳转，不校验是USB上位机发起的跳转</span><br><span class="line">#else</span><br><span class="line">	if (*(uint32_t *)RAM_FROM_APP_FLAG_ADDR != RAM_FROM_APP_FLAG_DATA)</span><br><span class="line">	&#123;</span><br><span class="line">		*(uint32_t *)RAM_FROM_APP_FLAG_ADDR = 0;</span><br><span class="line">		if ((*(uint32_t *)APP_FILE_EDN_ADDR == APP_FILE_END_DATA) &amp;&amp;</span><br><span class="line">			(*(uint32_t *)APP_FILE_START_ADDR == APP_FILE_START_DATA) &amp;&amp;</span><br><span class="line">			(pin_state == GPIO_PIN_SET))</span><br><span class="line">			direct_jump_to_app();</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="Skyways业务代码分析"><a href="#Skyways业务代码分析" class="headerlink" title="Skyways业务代码分析"></a>Skyways业务代码分析</h1><p>在《STM32–Firmware Architecture part1：开发环境和HAL API应用》中已经分析了整体的Firmware-USB上位机之间的请求处理流程，这里针对Skyways Firmware具体分析业务流程的差异点。</p>
<h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><h3 id="USB下发数据给UART（TX-no-buffer）"><a href="#USB下发数据给UART（TX-no-buffer）" class="headerlink" title="USB下发数据给UART（TX, no buffer）"></a>USB下发数据给UART（TX, no buffer）</h3><p>调用过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUSTOM_HID_OutEvent_FS -&gt; write_uart_function() -&gt; HAL_UART_Transmit()</span><br></pre></td></tr></table></figure>

<p>Skyways版本的UART TX代码有几点需要注意：</p>
<ol>
<li>usb_send_buf[0] |&#x3D; 0x80;表示错误，用于通知USB上位机。Tx一次发送超过60bytes, 或者HAL_UART_Transmit有Timeout，则上报USB上位机有错。</li>
<li>以下代码的UART返回数据没发送给USB，和o2link Spec不一致：UART没有返回USB：0101+buffer data.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void write_uart_function()</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t ret = 0;</span><br><span class="line">	uint32_t i;</span><br><span class="line">	length = usb_send_buf[2] &lt;&lt; 8 | usb_send_buf[3];</span><br><span class="line">	if(length &gt; MAX_UART_WRITE_LENGTH)&#123; //60bytes</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = UART_PARAMETER_ERROR;</span><br><span class="line">		usb_send(usb_send_buf,USB_TIMEOUT_TIME);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cdc_receive_flag = CDC_FLAG_HID;</span><br><span class="line">	ret = HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;usb_send_buf[4],length,UART_TIMEOUT_TIME);</span><br><span class="line"></span><br><span class="line">	if(ret)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = ret;</span><br><span class="line">		usb_send(usb_send_buf,USB_TIMEOUT_TIME);</span><br><span class="line">	&#125;</span><br><span class="line">	//usb_send(usb_send_buf,USB_TIMEOUT_TIME); //这里和o2link Spec不一致，UART没有返回USB：0101+buffer.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="USB从UART接收数据（RX-1KB-buffer-DMA）"><a href="#USB从UART接收数据（RX-1KB-buffer-DMA）" class="headerlink" title="USB从UART接收数据（RX, 1KB buffer, DMA）"></a>USB从UART接收数据（RX, 1KB buffer, DMA）</h3><p>代码流程在《STM32–Firmware Architecture part1：开发环境和HAL API应用》的”UART2部分”有详细分析。</p>
<p>应用上的结论：UART2 DMA使用UART IDLE frame作为传输完成中断的触发源，只要应用上保证一次UART读数据中没有异常的IDLE frame，则UART2 DMA IDLE frame产生的完成中断可作为一次完整的UART数据传输结束标志。</p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>Skyways的SPI data transmission底层操作在的”8.1 usb_to_spi”有详细描述，这里看到以下区别：</p>
<ul>
<li>发起spi数据传输之前，Deinit了I2C，把I2C的SDA&#x2F;SCL两个pin作为GPIO输入模式拉高。</li>
<li>完成spi数据传输之后，重新init了I2C到100K速度.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void usb_handle_process(void):</span><br><span class="line"></span><br><span class="line">case USB_TO_SKYWAY_SPI_WRITE:</span><br><span class="line">		HAL_I2C_DeInit(&amp;hi2c1);</span><br><span class="line">		i2c_gpio_fun();</span><br><span class="line">		usb_to_spi_convert_skyway_write();</span><br><span class="line">		MX_I2C1_Init(100000, 7);</span><br><span class="line">		break;</span><br><span class="line">case USB_TO_SKYWAY_SPI_READ:</span><br><span class="line">		HAL_I2C_DeInit(&amp;hi2c1);</span><br><span class="line">		i2c_gpio_fun();</span><br><span class="line">		usb_to_spi_convert_skyway_read();</span><br><span class="line">		MX_I2C1_Init(100000, 7);</span><br><span class="line">		break;</span><br></pre></td></tr></table></figure>

<p>根据Skyways和MCU的连接，SPI和I2C并没有复用；Skyways和MCU的SPI通信也没要求对I2C的pin做什么特殊操作（测试SPI read、write甚至都没连接I2C），因此猜测此处代码只是早期开发时，预防I2C和SPI同时使用时有冲突，实际没这个需求。 – 下个版本删除此I2C代码，测试SPI read、write.</p>
<h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><p>TODO</p>
<h2 id="one-wire"><a href="#one-wire" class="headerlink" title="one-wire"></a>one-wire</h2><p>TODO</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--%E4%B8%B2%E5%8F%A3%EF%BC%9AUART%E5%92%8CUSB-COM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--%E4%B8%B2%E5%8F%A3%EF%BC%9AUART%E5%92%8CUSB-COM/" class="post-title-link" itemprop="url">STM32--串口：UART和USB-COM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:21:57" itemprop="dateModified" datetime="2025-11-04T17:21:57+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MCU%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">MCU驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–串口：UART和USB-COM"><a href="#STM32–串口：UART和USB-COM" class="headerlink" title="STM32–串口：UART和USB-COM"></a>STM32–串口：UART和USB-COM</h1><p>背景描述：STM32板子有TTL UART连接下游IC，同时有USB口连接上游的上位机PC。</p>
<p>本文描述STM32如何直接使用UART通信，如何用USB CDC实现虚拟串口USB-COM也用UART通信。</p>
<h2 id="UART项目配置"><a href="#UART项目配置" class="headerlink" title="UART项目配置"></a>UART项目配置</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301153104.png" alt="image-20240430115304007"></p>
<h2 id="UART的轮询与中断"><a href="#UART的轮询与中断" class="headerlink" title="UART的轮询与中断"></a>UART的轮询与中断</h2><h2 id="USB的CDC类实现USB-COM"><a href="#USB的CDC类实现USB-COM" class="headerlink" title="USB的CDC类实现USB-COM"></a>USB的CDC类实现USB-COM</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417744.png" alt="image-20240430141713692"></p>
<h2 id="双串口的实现：UART和USB-COM"><a href="#双串口的实现：UART和USB-COM" class="headerlink" title="双串口的实现：UART和USB-COM"></a>双串口的实现：UART和USB-COM</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417818.png" alt="image-20240430141738799"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404301417518.png" alt="image-20240430141746453"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#Communications_Devices_Class_(CDC)">ST: Introduction to USB with STM32</a></p>
<p><a target="_blank" rel="noopener" href="https://controllerstech.com/send-and-receive-data-to-pc-without-uart-stm32-usb-com/">send-and-receive-data-to-pc-without-uart-stm32-usb-com</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/FBsharl/p/17847962.html">stm32：实现USB虚拟串口（CDC_VPC）</a></p>
<p><a target="_blank" rel="noopener" href="https://shequ.stmicroelectronics.cn/thread-637593-1-1.html">如何让CDC类USB设备批量接收64字节以上数据</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--%E4%BB%8E0%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--%E4%BB%8E0%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">STM32--从0创建项目和设计架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:21:44" itemprop="dateModified" datetime="2025-11-04T17:21:44+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MCU%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">MCU驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–从0创建项目和设计架构"><a href="#STM32–从0创建项目和设计架构" class="headerlink" title="STM32–从0创建项目和设计架构"></a>STM32–从0创建项目和设计架构</h1><h2 id="野火STM32-F4创建项目："><a href="#野火STM32-F4创建项目：" class="headerlink" title="野火STM32 F4创建项目："></a>野火STM32 F4创建项目：</h2><p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/mcu/stm32/f4/hal_general/zh/latest/doc/chapter10/chapter10.html">https://doc.embedfire.com/mcu/stm32/f4/hal_general/zh/latest/doc/chapter10/chapter10.html</a></p>
<h2 id="STMF0创建项目："><a href="#STMF0创建项目：" class="headerlink" title="STMF0创建项目："></a>STMF0创建项目：</h2><p>（1）芯片型号启动创建</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221510696.png" alt="image-20240722151016542"></p>
<p>（2）配置时钟和各外设</p>
<p>这里参考已有的其他stm32f0项目，用CubeMX打开两个项目，在GUI对照配置新项目自动生成代码。要特别注意时钟的配置，如果使用外接晶振，和具体开发板环境有关。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221516703.png" alt="image-20240722151602583"></p>
<p>配置外设和GPIO有技巧：先配置外设（connectivity项，SPI，UART，I2C…），配好后会自动配置外设占用的GPIO；而独立的GPIO功能（一般作为debug pin）在外设配完后再补充。</p>
<p>外设pin脚可以设置标签，便于不看电路原理图就知道是做什么用，但是注意要保留pin本身的含义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221528881.png" alt="image-20240722152839824"></p>
<p>在配置pin功能如果有感叹号表示有部分功能和其他模块冲突，例如UART1的流控功能和USB冲突（红色），由于UART1并不开启流控，此处不需要管。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221600775.png" alt="image-20240722160043740"></p>
<p>(3)生成MDK-ARM项目</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>CubeMX项目要想可维护，后期能通过GUI方式更新配置同时不破坏用户自定义代码，有两种方式：</p>
<ul>
<li>在GUI生成代码内加User代码，即User Begin ~ User End的代码区域</li>
<li>创建独立的代码文件夹，和GUI创建的项目代码完全隔离。用户代码要使用GUI生成的函数和数据只引用GUI的外设头文件</li>
</ul>
<p>以下是使用独立代码文件夹的方式：</p>
<p>（1）Keil打开GUI自动创建的项目（包含USB middleware），首先配置好编译链接烧录等配置。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221630057.png" alt="image-20240722163031991"></p>
<p>（2）添加自定义文件夹的.c文件</p>
<p>这里的Group一般以文件夹结构命名，Files只是.c源文件，头文件.h不是在这里添加</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221648462.png" alt="image-20240722164837416"></p>
<p>（3）添加自定义文件夹的.h头文件</p>
<p>在项目option里加头文件路径</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221650166.png" alt="image-20240722165046119"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202407221652202.png" alt="image-20240722165206164"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--%E6%90%AD%E5%BB%BAVSCode+STMCubeIDE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--%E6%90%AD%E5%BB%BAVSCode+STMCubeIDE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">STM32--搭建VSCode+STMCubeIDE开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:21:30" itemprop="dateModified" datetime="2025-11-04T17:21:30+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MCU%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">MCU驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–搭建VSCode-STMCubeIDE开发环境"><a href="#STM32–搭建VSCode-STMCubeIDE开发环境" class="headerlink" title="STM32–搭建VSCode+STMCubeIDE开发环境"></a>STM32–搭建VSCode+STMCubeIDE开发环境</h1><h2 id="用STM32CubeIDE创建工程"><a href="#用STM32CubeIDE创建工程" class="headerlink" title="用STM32CubeIDE创建工程"></a>用STM32CubeIDE创建工程</h2><h2 id="用VSCode编辑代码"><a href="#用VSCode编辑代码" class="headerlink" title="用VSCode编辑代码"></a>用VSCode编辑代码</h2><h3 id="配置-vscode使能tab补全"><a href="#配置-vscode使能tab补全" class="headerlink" title="配置.vscode使能tab补全"></a>配置.vscode使能tab补全</h3><p>Stm32的HAL库默认是没有被VSCode的C&#x2F;C++ intelligence检测到，自动补全功能不完整，例如HAL_UART_XXX不能tab补全到HAL_UART_Transmit，这个API定义在Drivers&#x2F;Drivers&#x2F;STM32FXXX_HAL_Driver&#x2F;Inc里，C&#x2F;C++ intelligence没有检测到这个路径，因此需要配置C&#x2F;C++ intelligence的c_cpp_properties.json, 添加include和defines。</p>
<p>（1）打开STM32项目</p>
<p>注意：要配置哪个STM32项目就VSCode打开哪个目录，不要打开包括多个STM32项目的workspace，不然配置的.vscode是针对workspace目录的，不会对各项目生效。</p>
<p>比如以下workspace有几个STM32CubeIDE创建的项目，VSCode应该打开具体的项目serial-test-isr再配置该项目的.vscode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0&gt; ls</span><br><span class="line"></span><br><span class="line">    目录: C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2024/4/29     10:03                .metadata</span><br><span class="line">d-----         2024/4/29     10:34                .vscode</span><br><span class="line">d-----         2024/4/24     19:45                led-test</span><br><span class="line">d-----         2024/4/25     11:25                serial-test</span><br><span class="line">d-----         2024/4/29     10:06                serial-test-isr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0&gt; cd .\serial-test-isr\</span><br><span class="line">PS C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0\serial-test-isr&gt; ls</span><br><span class="line"></span><br><span class="line">    目录: C:\Users\cursorhu\STM32CubeIDE\workspace_1.15.0\serial-test-isr</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2024/4/28     22:33                .settings</span><br><span class="line">d-----         2024/4/29     10:06                .vscode</span><br><span class="line">d-----         2024/4/28     16:26                Core</span><br><span class="line">d-----         2024/4/28     17:51                Debug</span><br><span class="line">d-----         2024/4/28     16:26                Drivers</span><br><span class="line">-a----         2024/4/28     16:39          25210 .cproject</span><br><span class="line">-a----         2024/4/28     16:39           8275 .mxproject</span><br><span class="line">-a----         2024/4/28     16:30           1221 .project</span><br><span class="line">-a----         2024/4/28     17:56          10224 serial-test-isr Debug.launch</span><br><span class="line">-a----         2024/4/28     16:39           2975 serial-test-isr.ioc</span><br><span class="line">-a----         2024/4/28     16:39           5306 STM32F072C8TX_FLASH.ld</span><br></pre></td></tr></table></figure>

<p>（2）配置.vscode</p>
<p>VSCode左下角setting -&gt; Command Palette -&gt; 搜索: C&#x2F;C++ Edit Configurations (UI) 或者 (JSON)</p>
<p>C&#x2F;C++ Edit Configurations (UI) ：</p>
<p>在Include path添加HAL库定义的路径：这里直接用**递归搜索，类似.gitignore的语法，不需要指定到具体的Drivers&#x2F;STM32FXXX_HAL_Driver&#x2F;Inc路径。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404291104878.png" alt="image-20240429104934058"></p>
<p>C&#x2F;C++ Edit Configurations (JSON)方式的配置，UI配置也会反应在此 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;Drivers/**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;gnu++17&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）VSCode调用STM32 HAL 函数自动补全</p>
<p>现在可以tab补全STM32 HAL的所有库函数，可以彻底抛弃STM32CubeIDE的编辑界面：)</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202404291104289.png" alt="image-20240429105530310"></p>
<h2 id="用STM32CubeIDE和J-link调试和烧录"><a href="#用STM32CubeIDE和J-link调试和烧录" class="headerlink" title="用STM32CubeIDE和J-link调试和烧录"></a>用STM32CubeIDE和J-link调试和烧录</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--Firmware%20Architecture%20part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL%20API%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/30/STM32--Firmware%20Architecture%20part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL%20API%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">STM32--Firmware Architecture part1：开发环境和HAL API应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:22:08" itemprop="dateModified" datetime="2025-11-04T17:22:08+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MCU%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">MCU驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32–Firmware-Architecture-part1：开发环境和HAL-API应用"><a href="#STM32–Firmware-Architecture-part1：开发环境和HAL-API应用" class="headerlink" title="STM32–Firmware Architecture part1：开发环境和HAL API应用"></a>STM32–Firmware Architecture part1：开发环境和HAL API应用</h1><h1 id="STM32–开发环境"><a href="#STM32–开发环境" class="headerlink" title="STM32–开发环境"></a>STM32–开发环境</h1><p>当前主流的几种方案：(软件免费，无法律风险)：</p>
<p>1.STM32CubeMX + Keil（社区版）+ VSCode：使用CubeMX快速创建工程并导出为MDK-ARM项目文件，使用Keil编译调试MDK-ARM项目包，使用VSCode编辑代码和版本管理。</p>
<p>优势：兼容老项目，资料最多；Keil的调试经验可以复用到其他非STM32 ARM芯片；</p>
<p><a target="_blank" rel="noopener" href="https://www.keil.arm.com/mdk-community/">https://www.keil.arm.com/mdk-community/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubemx.html">https://www.st.com/en/development-tools/stm32cubemx.html</a></p>
<p>2.STM32CubeIDE：ST主推的方式，专用于ST32芯片的IDE，本质是STM32CubeMX + Eclipse IDE + ST的编译调试工具链。</p>
<p>优势：集成度最高；缺陷：只用于STM32</p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubeide.html#overview">https://www.st.com/en/development-tools/stm32cubeide.html#overview</a></p>
<p>3.VSCode + ARM&#x2F;ST插件 + GDB + OpenOCD + + STM32CubeMX</p>
<p>优势：通用性最强，对各类ARM&#x2F;RISCV等SOC都适用此方案。</p>
<p>缺陷：资料少，GDB debug效率没有Keil高。</p>
<p><a target="_blank" rel="noopener" href="https://stm32world.com/wiki/STM32_development_and_debugging_using_VSCode">https://stm32world.com/wiki/STM32_development_and_debugging_using_VSCode</a></p>
<p>结论：对于生产环境的STM32开发还是首选方案1，Keil社区版的功能和付费版基本一致。</p>
<h1 id="STM32–必读手册和固件"><a href="#STM32–必读手册和固件" class="headerlink" title="STM32–必读手册和固件"></a>STM32–必读手册和固件</h1><h2 id="STM32开发手册"><a href="#STM32开发手册" class="headerlink" title="STM32开发手册"></a>STM32开发手册</h2><p>helps-&gt;docs &amp; resource, 下载F0系列的：</p>
<p>Data Sheet(DS), Reference Manual(RM), Programming Manual(PM). </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101741846.png" alt="image-20240510174102795"></p>
<p>此外还有F1系列才有的<strong>User Manual UM1850</strong>，里面详细介绍各外设Driver的设计标准和API如何使用，对F0的Firmware也是通用，去ST官网下载。</p>
<h2 id="STM32固件包"><a href="#STM32固件包" class="headerlink" title="STM32固件包"></a>STM32固件包</h2><p>CubeMX&#x2F;CubeMXIDE首次运行STM32工程会要求安装STM32FXX的固件包，路径：CubeMX工程管理页面 -&gt; Firmware Package Path</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101708801.png" alt="image-20240510170810653"></p>
<p>原厂固件包的作用：</p>
<p>1.固件包是MCU厂商提供，学习任何一种MCU应该首先参考原厂固件包，不然容易被第三方教程误导。</p>
<p>2.对于STM32CubeMX, 其创建工程的原理是从固件包拷贝现成的模板代码，再根据用户在GUI界面配置的外设功能参数，自动输出项目代码。这个操作类似于VisualStudio开发MFC&#x2F;WinForm GUI应用，GUI模块被自动生成C#代码。</p>
<p>对于STM32F072xb的固件包，重点关注：</p>
<p>1.固件说明文档：STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Documentation\STM32CubeF0GettingStarted.pdf</p>
<p>2.模板代码和示例代码：STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Projects\STM32072B_EVAL\Examples</p>
<p>3.User Manual：整个固件库的代码文档，一般用HAL库关键词索引完整API定义</p>
<p>STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Drivers\STM32F0xx_HAL_Driver\STM32F072xB_User_Manual.chm</p>
<h2 id="小结：STM32项目的代码架构"><a href="#小结：STM32项目的代码架构" class="headerlink" title="小结：STM32项目的代码架构"></a>小结：STM32项目的代码架构</h2><p>根据开发手册和固件包文档做个小结。</p>
<p>STM32固件的架构，这也是STM32 Firmware项目的基本架构：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131502283.png" alt="image-20240513150236222"></p>
<ol>
<li>HAL和LL APIs是ST提供的STM32 chipset API，目的是hide theMCU and peripheral complexity to end user</li>
</ol>
<p>区别：</p>
<p>HAL drivers offer high-level and function-oriented APIs, with a high level of portability. Product&#x2F;IPs complexity is hidden for end users.</p>
<p>LL drivers offer low-layer APIs at registers level, with a better optimization but less portability. They require a deep knowledge of product&#x2F;IPs specifications.</p>
<p>HAL可以理解为硬件协议层，不直接配置register level，只实现通信协议和硬件配置流程。</p>
<p>LL是register level，完全不涉及通信协议和设备流程性的配置。</p>
<p>SysTick interrupts 只能在HAL使用，LL API无法调用SysTick interrupts，因为SysTick实际上是Hardware Timer的应用，而不是操作timer本身。</p>
<ol start="2">
<li><p>CMSIS（Cortex Microcontroller Software Interface Standard)  ARM指定的Cortex-M 硬件抽象层标准</p>
</li>
<li><p>Middleware：相当于应用层的基础库。The middleware is a set of libraries covering USB Device Libraries, STMTouch touch sensing, STemWin, FreeRTOS and FatFS</p>
</li>
</ol>
<h1 id="STM32–编译过程"><a href="#STM32–编译过程" class="headerlink" title="STM32–编译过程"></a>STM32–编译过程</h1><p>对于嵌入式代码的分析，首先应该看Makefile，去总览项目结构和编译过程。</p>
<p>以下有两种编译生态：</p>
<ol>
<li><p>Keil style：在Keil中编译MDK-ARM工程，编译过程被Keil隐藏到项目配置中；</p>
</li>
<li><p>Makefile style：CubeMX将MDK-ARM工程输出为Makefile工程，能一次看清整个编译过程。</p>
</li>
</ol>
<h2 id="Keil-style"><a href="#Keil-style" class="headerlink" title="Keil style"></a>Keil style</h2><h3 id="Keil编译配置"><a href="#Keil编译配置" class="headerlink" title="Keil编译配置"></a>Keil编译配置</h3><p>指定ARM编译器，指定代码目标是RAM\Flash位置的基地址</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102037591.png" alt="image-20240510203738554"></p>
<p>指定输出文件</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039243.png" alt="image-20240510203910212"></p>
<p>链接输出的符号总览文件.map</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039879.png" alt="image-20240510203928847"></p>
<p>编译的后处理过程，从hex生产bin</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102040886.png" alt="image-20240510204028853"></p>
<p>指定代码优化级别，警告级别，语言标准；指定头文件，组合成编译参数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102042899.png" alt="image-20240510204213867"></p>
<p>指定汇编器，一些伪汇编符号语法(syntax)和汇编器类型相关，例如Arm syntax和GUN syntax有很大差异</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102043211.png" alt="image-20240510204344181"></p>
<p>指定链接文件(scatter file), 功能对应Makefile的.ld链接脚本文件，用于指定各段分布。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102047297.png" alt="image-20240510204720264"></p>
<p>Debug和JLink烧录的配置，这里勾选JLink烧录后自动reset启动新程序:</p>
<p>这里实际是Keil调用JFlash烧写，需要指定Flash地址和大小，一般和Keil项目配置的ROM区间一致</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405170952108.png" alt="image-20240517095249013"></p>
<p>项目的目录配置中指定哪些.c参与编译:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102059394.png" alt="image-20240510205959362"></p>
<h3 id="Keil链接配置"><a href="#Keil链接配置" class="headerlink" title="Keil链接配置"></a>Keil链接配置</h3><p>Keil的链接脚本是.sct文件，链接配置的主要作用是在对.o文件链接时，指定链接基础地址，指定排列顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LR_IROM1 0x08000000 0x00020000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00020000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00004000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个比较重要的概念：</p>
<ol>
<li>加载域与执行域</li>
</ol>
<p>LR： Load Address，MCU从哪个空间加载代码</p>
<p>ER：Execute Address，MCU在哪个空间执行代码</p>
<p>以上STM32链接脚本，所有Flash的代码(IROM: *.o, RO, XO)的执行域和加载域都是Flash(0x08000000 ~ 0x00020000)，且指定bootloader entry：RESET为最开始执行的函数。</p>
<p>RAM的代码(IRAM: RW, ZI)加载域是SRAM，这部分是数据是运行时直接在RAM初始化，不需要从Flash取指令。</p>
<p><img src="https://img-blog.csdnimg.cn/d8d908434dad4d18b654fdbefa5778b9.png#pic_center" alt="img"></p>
<p>下图示例是执行Flash的RO data时，RW数据段（有初始值的数据）应该被bootloader拷贝到RAM。</p>
<p><img src="https://img-blog.csdnimg.cn/fa87d75e57db492e8a86582baf8971be.png#pic_center" alt="img"></p>
<ol start="2">
<li>代码段，数据段，BSS段…</li>
</ol>
<p>STM32的代码段分布如下表, 其中CODE（包括RO&#x2F;RW CODE和TEXT），DATA(RO&#x2F;RW DATA)，ZI(BSS) 即常规意义的可执行程序的三段。</p>
<p>在.sct链接脚本中对应：RO，RW和ZI(zero initialized )<br>      RO是程序中的指令和常量<br>      RW是程序中已初始化变量<br>      ZI是程序中未初始化或初始化为0的变量</p>
<p><img src="https://img-blog.csdnimg.cn/4ccfeec4537a4a40ad5a8102707c2705.png" alt="img"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/apythonlearner/article/details/133034055">【STM32】sct 分散加载文件的格式与应用</a></p>
<h2 id="Makefile-style"><a href="#Makefile-style" class="headerlink" title="Makefile style"></a>Makefile style</h2><h3 id="makefile编译配置"><a href="#makefile编译配置" class="headerlink" title="makefile编译配置"></a>makefile编译配置</h3><p>将已有的CubeMX+MDK工程输出为Makefile工程，产生Makefile和STM32F072C8Tx_FLASH.ld文件.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102056555.png" alt="image-20240510205610521"></p>
<p>Makefile分析：</p>
<p>指定编译目标，debug和优化级别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># target</span><br><span class="line">TARGET = stm32f072c8t6</span><br><span class="line"># debug build?</span><br><span class="line">DEBUG = 1</span><br><span class="line"># optimization</span><br><span class="line">OPT = -Og</span><br></pre></td></tr></table></figure>

<p>指定参与编译的源码.c和.s  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># C sources</span><br><span class="line">C_SOURCES =  \</span><br><span class="line">Core/Src/main.c \</span><br><span class="line">Core/Src/gpio.c \</span><br><span class="line">Core/Src/can.c \</span><br><span class="line">Core/Src/i2c.c \</span><br><span class="line">Core/Src/spi.c \</span><br><span class="line">Core/Src/usart.c \</span><br><span class="line">Core/Src/stm32f0xx_it.c \</span><br><span class="line">Core/Src/stm32f0xx_hal_msp.c \</span><br><span class="line">....</span><br><span class="line">Core/Src/system_stm32f0xx.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_ctlreq.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_ioreq.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Class/CustomHID/Src/usbd_customhid.c \</span><br><span class="line">Core/Src/sysmem.c \</span><br><span class="line">Core/Src/syscalls.c </span><br><span class="line"></span><br><span class="line"># ASM sources</span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">startup_stm32f072xb.s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定目标平台的编译器和链接器，指定输出hex&#x2F;bin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PREFIX = arm-none-eabi-</span><br><span class="line"></span><br><span class="line">CC = $(PREFIX)gcc</span><br><span class="line">AS = $(PREFIX)gcc -x assembler-with-cpp</span><br><span class="line">CP = $(PREFIX)objcopy</span><br><span class="line">SZ = $(PREFIX)size</span><br><span class="line"></span><br><span class="line">HEX = $(CP) -O ihex</span><br><span class="line">BIN = $(CP) -O binary -S</span><br></pre></td></tr></table></figure>

<p>编译参数CFLAGS和ASFLAGS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU = -mcpu=cortex-m0</span><br><span class="line"># float-abi</span><br><span class="line">MCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)</span><br></pre></td></tr></table></figure>

<p>宏定义和头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># macros for gcc</span><br><span class="line"># AS defines</span><br><span class="line">AS_DEFS = </span><br><span class="line"></span><br><span class="line"># C defines</span><br><span class="line">C_DEFS =  \</span><br><span class="line">-DUSE_HAL_DRIVER \</span><br><span class="line">-DSTM32F072xB</span><br><span class="line"></span><br><span class="line"># AS includes</span><br><span class="line">AS_INCLUDES = </span><br><span class="line"></span><br><span class="line"># C includes</span><br><span class="line">C_INCLUDES =  \</span><br><span class="line">-ICore/Inc \</span><br><span class="line">-IUSB_DEVICE/App \</span><br><span class="line">-IUSB_DEVICE/Target \</span><br><span class="line">-IDrivers/STM32F0xx_HAL_Driver/Inc \</span><br><span class="line">-IDrivers/STM32F0xx_HAL_Driver/Inc/Legacy \</span><br><span class="line">-IMiddlewares/ST/STM32_USB_Device_Library/Core/Inc \</span><br><span class="line">-IMiddlewares/ST/STM32_USB_Device_Library/Class/CustomHID/Inc \</span><br><span class="line">-IDrivers/CMSIS/Device/ST/STM32F0xx/Include \</span><br><span class="line">-IDrivers/CMSIS/Include</span><br></pre></td></tr></table></figure>

<p>最终的完整GCC FLAGS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># compile gcc flags</span><br><span class="line">ASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line">CFLAGS += $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br></pre></td></tr></table></figure>

<p>链接脚本与库路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># link script</span><br><span class="line">LDSCRIPT = STM32F072C8Tx_FLASH.ld</span><br><span class="line"></span><br><span class="line"># libraries</span><br><span class="line">LIBS = -lc -lm -lnosys </span><br><span class="line">LIBDIR = </span><br><span class="line">LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections</span><br></pre></td></tr></table></figure>

<p>输出文件：elf + hex + bin，参考：[elf,hex,bin,axf的区别](# elf,hex,bin,axf的区别)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># default action: build all</span><br><span class="line">all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin</span><br></pre></td></tr></table></figure>

<p>编译执行部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># list of objects</span><br><span class="line">OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))</span><br><span class="line">vpath %.c $(sort $(dir $(C_SOURCES)))</span><br><span class="line"># list of ASM program objects</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))</span><br><span class="line">vpath %.s $(sort $(dir $(ASM_SOURCES)))</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASMM_SOURCES:.S=.o)))</span><br><span class="line">vpath %.S $(sort $(dir $(ASMM_SOURCES)))</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) </span><br><span class="line">	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)</span><br><span class="line">	$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(BUILD_DIR)/%.o: %.S Makefile | $(BUILD_DIR)</span><br><span class="line">	$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile</span><br><span class="line">	$(CC) $(OBJECTS) $(LDFLAGS) -o $@</span><br><span class="line">	$(SZ) $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	$(HEX) $&lt; $@</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	$(BIN) $&lt; $@	</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR):</span><br><span class="line">	mkdir $@</span><br></pre></td></tr></table></figure>

<p>清理编译输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	-rm -fR $(BUILD_DIR)</span><br></pre></td></tr></table></figure>

<h3 id="makefile链接配置"><a href="#makefile链接配置" class="headerlink" title="makefile链接配置"></a>makefile链接配置</h3><p>GNU linker（LD）的语法参考：<a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/index.html">GNU linker ld (GNU Binutils)</a></p>
<p>STM32F072C8Tx_FLASH.ld：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* Entry Point */</span><br><span class="line">ENTRY(Reset_Handler)</span><br><span class="line"></span><br><span class="line">/* Highest address of the user mode stack */</span><br><span class="line">_estack = ORIGIN(RAM) + LENGTH(RAM);    /* end of RAM */</span><br><span class="line">/* Generate a link error if heap and stack don&#x27;t fit into RAM */</span><br><span class="line">_Min_Heap_Size = 0x300;      /* required amount of heap  */</span><br><span class="line">_Min_Stack_Size = 0x500; /* required amount of stack */</span><br><span class="line"></span><br><span class="line">/* Specify the memory areas */</span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 16K</span><br><span class="line">FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 64K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Define output sections */</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* The startup code goes first into FLASH */</span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    KEEP(*(.isr_vector)) /* Startup code */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* The program code and other data goes into FLASH */</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.text)           /* .text sections (code) */</span><br><span class="line">    *(.text*)          /* .text* sections (code) */</span><br><span class="line">    *(.glue_7)         /* glue arm to thumb code */</span><br><span class="line">    *(.glue_7t)        /* glue thumb to arm code */</span><br><span class="line">    *(.eh_frame)</span><br><span class="line"></span><br><span class="line">    KEEP (*(.init))</span><br><span class="line">    KEEP (*(.fini))</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _etext = .;        /* define a global symbols at end of code */</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* Constant data goes into FLASH */</span><br><span class="line">  .rodata :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.rodata)         /* .rodata sections (constants, strings, etc.) */</span><br><span class="line">    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH</span><br><span class="line">  .ARM : &#123;</span><br><span class="line">    __exidx_start = .;</span><br><span class="line">    *(.ARM.exidx*)</span><br><span class="line">    __exidx_end = .;</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .preinit_array     :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_start = .);</span><br><span class="line">    KEEP (*(.preinit_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .init_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.init_array.*)))</span><br><span class="line">    KEEP (*(.init_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .fini_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.fini_array.*)))</span><br><span class="line">    KEEP (*(.fini_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* used by the startup to initialize data */</span><br><span class="line">  _sidata = LOADADDR(.data);</span><br><span class="line"></span><br><span class="line">  /* Initialized data sections goes into RAM, load LMA copy after code */</span><br><span class="line">  .data : </span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _sdata = .;        /* create a global symbol at data start */</span><br><span class="line">    *(.data)           /* .data sections */</span><br><span class="line">    *(.data*)          /* .data* sections */</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _edata = .;        /* define a global symbol at data end */</span><br><span class="line">  &#125; &gt;RAM AT&gt; FLASH</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  /* Uninitialized data section */</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  .bss :</span><br><span class="line">  &#123;</span><br><span class="line">    /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">    _sbss = .;         /* define a global symbol at bss start */</span><br><span class="line">    __bss_start__ = _sbss;</span><br><span class="line">    *(.bss)</span><br><span class="line">    *(.bss*)</span><br><span class="line">    *(COMMON)</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _ebss = .;         /* define a global symbol at bss end */</span><br><span class="line">    __bss_end__ = _ebss;</span><br><span class="line">  &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">  /* User_heap_stack section, used to check that there is enough RAM left */</span><br><span class="line">  ._user_heap_stack :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">    PROVIDE ( end = . );</span><br><span class="line">    PROVIDE ( _end = . );</span><br><span class="line">    . = . + _Min_Heap_Size;</span><br><span class="line">    . = . + _Min_Stack_Size;</span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">  &#125; &gt;RAM</span><br></pre></td></tr></table></figure>

<h2 id="编译输出-elf-hex-bin-axf的区别"><a href="#编译输出-elf-hex-bin-axf的区别" class="headerlink" title="编译输出: elf,hex,bin,axf的区别"></a>编译输出: elf,hex,bin,axf的区别</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131142491.png" alt="image-20240513114246442"></p>
<h2 id="链接输出的-map符号表"><a href="#链接输出的-map符号表" class="headerlink" title="链接输出的.map符号表"></a>链接输出的.map符号表</h2><p>链接过程可以输出.map符号表，可用于分析代码和数据分布，再裁剪代码。</p>
<ol>
<li>ROM(Flash)的.hex&#x2F;bin文件的符号分布:</li>
</ol>
<p>可以看到，.sct指定的首个符号RESET在最开始位置，其他符号是链接器自动排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Memory Map of the image</span><br><span class="line"></span><br><span class="line">  Image Entry point : 0x080000c1</span><br><span class="line"></span><br><span class="line">  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x000082f0, Max: 0x00020000, ABSOLUTE, COMPRESSED[0x00008148])</span><br><span class="line"></span><br><span class="line">    Execution Region ER_IROM1 (Exec base: 0x08000000, Load base: 0x08000000, Size: 0x00007f84, Max: 0x00020000, ABSOLUTE)</span><br><span class="line"></span><br><span class="line">    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object</span><br><span class="line"></span><br><span class="line">    0x08000000   0x08000000   0x000000c0   Data   RO            3    RESET               startup_stm32f072xb.o</span><br><span class="line">    0x080000c0   0x080000c0   0x00000000   Code   RO         2440  * .ARM.Collect$$$$00000000  mc_p.l(entry.o)</span><br><span class="line">    0x080000c0   0x080000c0   0x00000004   Code   RO         2728    .ARM.Collect$$$$00000001  mc_p.l(entry2.o)</span><br><span class="line">    0x080000c4   0x080000c4   0x00000004   Code   RO         2731    .ARM.Collect$$$$00000004  </span><br><span class="line">    </span><br><span class="line">    ....         </span><br><span class="line"></span><br><span class="line">mc_p.l(init.o)</span><br><span class="line">    0x08000244   0x08000244   0x00000020   Code   RO         2768    .text               mc_p.l(llshl.o)</span><br><span class="line">    0x08000264   0x08000264   0x00000056   Code   RO         2784    .text               mc_p.l(__dczerorl2.o)</span><br><span class="line">    0x080002ba   0x080002ba   0x00000002   PAD</span><br><span class="line">    0x080002bc   0x080002bc   0x00000064   Code   RO          769    .text.CDC_Control_FS  usbd_cdc_if.o</span><br><span class="line">    0x08000320   0x08000320   0x00000004   Code   RO          767    .text.CDC_DeInit_FS  usbd_cdc_if.o</span><br><span class="line">    0x08000324   0x08000324   0x00000024   Code   RO          765    .text.CDC_Init_FS   usbd_cdc_if.o</span><br><span class="line">    0x08000348   0x08000348   0x00000034   Code   RO          771    .text.CDC_Receive_FS  usbd_cdc_if.o</span><br><span class="line">    0x0800037c   0x0800037c   0x00000044   Code   RO          773    .text.CDC_Transmit_FS  usbd_cdc_if.o</span><br><span class="line">    0x080003c0   0x080003c0   0x00000010   Code   RO          136    .text.CEC_CAN_IRQHandler  stm32f0xx_it.o</span><br><span class="line">    0x080003d0   0x080003d0   0x00000004   Code   RO          750    .text.CUSTOM_HID_DeInit_FS  usbd_custom_hid_if.o</span><br><span class="line">    0x080003d4   0x080003d4   0x00000004   Code   RO          748    .text.CUSTOM_HID_Init_FS  usbd_custom_hid_if.o</span><br><span class="line"></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>RAM中的数据段分布，包括.data段和.bss段：</p>
<p>可以看到，有初始值和无初始值的全局变量分布在.data和.bss区域。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Execution Region RW_IRAM1 (Exec base: 0x20000000, Load base: 0x08007f88, Size: 0x000021b8, Max: 0x00004000, ABSOLUTE, COMPRESSED[0x000001c0])</span><br><span class="line"></span><br><span class="line">    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object</span><br><span class="line"></span><br><span class="line">    0x20000000   COMPRESSED   0x00000004   Data   RW         2742    .data               mc_p.l(stdout.o)</span><br><span class="line">    0x20000004   COMPRESSED   0x00000008   Data   RW         1117    .data..L_MergedGlobals  stm32f0xx_hal.o</span><br><span class="line">    0x2000000c   COMPRESSED   0x00000022   Data   RW          754    .data.CUSTOM_HID_ReportDesc_FS  usbd_custom_hid_if.o</span><br><span class="line">    0x2000002e   COMPRESSED   0x00000002   PAD</span><br><span class="line">    0x20000030   COMPRESSED   0x0000001c   Data   RW          733    .data.FS_Desc       usbd_desc.o</span><br><span class="line">    0x2000004c   COMPRESSED   0x00000004   Data   RW         2228    .data.SystemCoreClock  system_stm32f0xx.o</span><br><span class="line">    0x20000050   COMPRESSED   0x00000038   Data   RW         2427    .data.USBD_CDC      usbd_cdc.o</span><br><span class="line">    0x20000088   COMPRESSED   0x00000043   Data   RW         2429    .data.USBD_CDC_CfgFSDesc  usbd_cdc.o</span><br><span class="line">    0x200000cb   COMPRESSED   0x00000001   PAD</span><br><span class="line">    0x200000cc   COMPRESSED   0x00000043   Data   RW         2428    .data.USBD_CDC_CfgHSDesc  usbd_cdc.o</span><br><span class="line">    0x2000010f   COMPRESSED   0x00000001   PAD</span><br><span class="line">    0x20000110   COMPRESSED   0x0000000a   Data   RW         2431    .data.USBD_CDC_DeviceQualifierDesc  usbd_cdc.o</span><br><span class="line">    0x2000011a   COMPRESSED   0x00000002   PAD</span><br><span class="line">    0x2000011c   COMPRESSED   0x00000010   Data   RW          775    .data.USBD_CDC_Interface_fops_FS  usbd_cdc_if.o</span><br><span class="line">    0x2000012c   COMPRESSED   0x00000008   Data   RW          776    .data.USBD_CDC_LineCoding  usbd_cdc_if.o</span><br><span class="line">    0x20000134   COMPRESSED   0x00000043   Data   RW         2430    .data.USBD_CDC_OtherSpeedCfgDesc  usbd_cdc.o</span><br><span class="line">  </span><br><span class="line">  ....</span><br><span class="line">  </span><br><span class="line">    0x20000368        -       0x0000002c   Zero   RW           29    .bss..L_MergedGlobals  main.o</span><br><span class="line">    0x20000394        -       0x00000030   Zero   RW          287    .bss..L_MergedGlobals  systime.o</span><br><span class="line">    0x200003c4        -       0x00000024   Zero   RW          569    .bss..L_MergedGlobals  can.o</span><br><span class="line">    0x200003e8        -       0x00000048   Zero   RW          756    .bss..L_MergedGlobals  usbd_custom_hid_if.o</span><br><span class="line">    0x20000430        -       0x00000008   Zero   RW         2388    .bss..L_MergedGlobals  usbd_composite.o</span><br><span class="line">    0x20000438        -       0x00000400   Zero   RW           25    .bss.UART2_RxBuffer  main.o</span><br><span class="line">    0x20000838        -       0x00000001   Zero   RW         2299    .bss.USBD_SetConfig.cfgidx  usbd_ctlreq.o</span><br><span class="line">    0x20000839   COMPRESSED   0x00000003   PAD</span><br><span class="line">    0x2000083c        -       0x00000200   Zero   RW          737    .bss.USBD_StrDesc   usbd_desc.o</span><br><span class="line">    0x20000a3c        -       0x00000040   Zero   RW          778    .bss.UserRxBufferFS  usbd_cdc_if.o</span><br><span class="line">    0x20000a7c        -       0x00000040   Zero   RW          779    .bss.UserTxBufferFS  usbd_cdc_if.o</span><br><span class="line">    0x20000abc        -       0x00000001   Zero   RW          777    .bss.cdc_receive_flag  usbd_cdc_if.o</span><br><span class="line">    0x20000abd   COMPRESSED   0x00000003   PAD</span><br><span class="line">    0x20000ac0        -       0x000002c4   Zero   RW          712    .bss.hUsbDeviceFS   usb_device.o</span><br><span class="line">    0x20000d84        -       0x00000028   Zero   RW          568    .bss.hcan           can.o</span><br><span class="line">    0x20000dac        -       0x00000044   Zero   RW          109    .bss.hdma_usart2_rx  usart.o</span><br><span class="line">    0x20000df0        -       0x0000004c   Zero   RW           59    .bss.hi2c1          i2c.o</span><br><span class="line">    0x20000e3c        -       0x000002f4   Zero   RW          850    .bss.hpcd_USB_FS    usbd_conf.o</span><br><span class="line">    0x20001130        -       0x00000064   Zero   RW           77    .bss.hspi1          spi.o</span><br><span class="line">    0x20001194        -       0x00000048   Zero   RW          419    .bss.htim6          tim.o</span><br><span class="line">    0x200011dc        -       0x00000084   Zero   RW          106    .bss.huart1         usart.o</span><br><span class="line">    0x20001260        -       0x00000084   Zero   RW          107    .bss.huart2         usart.o</span><br><span class="line">    0x200012e4        -       0x00000084   Zero   RW          108    .bss.huart3         usart.o</span><br><span class="line">    0x20001368        -       0x00000001   Zero   RW          227    .bss.i2c_error      usb_handle.o</span><br><span class="line">    0x20001369        -       0x00000400   Zero   RW          239    .bss.inter_buffer   uart_data_analysis.o</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>输出的hex&#x2F;bin中，各.obj对应的Code， Data， ZI段大小：</p>
<p>可快速定位哪些代码占用Flash&#x2F;RAM空间过大。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Image component sizes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line">        26          4          0          0         76       4060   can.o</span><br><span class="line">        48          4          0          0          0       1769   dma.o</span><br><span class="line">       348          0          0          0          0       9083   fifo.o</span><br><span class="line">        92         16          0          0          0       3240   flash.o</span><br><span class="line">       258          0          0          0          0       4158   general_function.o</span><br><span class="line">       252         16          0          0          0       2882   gpio.o</span><br><span class="line">       428         72          0          0         76       7196   i2c.o</span><br><span class="line">         2          0          0          0          0      23860   jaguar.o</span><br><span class="line">       788        128          0          0       2092       8846   main.o</span><br><span class="line">       872        206         25          0        152      10137   one_wire.o</span><br><span class="line">       268         28          0         32        100       5426   spi.o</span><br><span class="line">        28          8        192          0       1280        656   startup_stm32f072xb.o</span><br><span class="line">       168         24          0          8          4       5420   stm32f0xx_hal.o</span><br><span class="line">       958          6          0          0          0      14230   stm32f0xx_hal_can.o</span><br><span class="line">       164         28          0          0          0       5576   stm32f0xx_hal_cortex.o</span><br><span class="line">       678         12          0          0          0       8163   stm32f0xx_hal_dma.o</span><br><span class="line">       694         32          0          0          0       4994   stm32f0xx_hal_gpio.o</span><br><span class="line">      1786         60          0          0          0      63508   stm32f0xx_hal_i2c.o</span><br><span class="line">       132          0          0          0          0       5319   stm32f0xx_hal_i2c_ex.o</span><br><span class="line">        44          4          0          0          0       1058   stm32f0xx_hal_msp.o</span><br><span class="line">      3124        100          0          0          0      15820   stm32f0xx_hal_pcd.o</span><br><span class="line">        96          0          0          0          0       5855   stm32f0xx_hal_pcd_ex.o</span><br><span class="line">      1672         52         32          0          0       8371   stm32f0xx_hal_rcc.o</span><br><span class="line">       328         12          0          0          0       6715   stm32f0xx_hal_rcc_ex.o</span><br><span class="line">      1544          8          0          0          0      27530   stm32f0xx_hal_spi.o</span><br><span class="line">       736         44          0          0          0      63633   stm32f0xx_hal_tim.o</span><br><span class="line">        96          0          0          0          0      22483   stm32f0xx_hal_tim_ex.o</span><br><span class="line">      2884         92         16          0          0      41313   stm32f0xx_hal_uart.o</span><br><span class="line">       122          0          0          0          0       8856   stm32f0xx_hal_uart_ex.o</span><br><span class="line">       106         20          0          0          0       2835   stm32f0xx_it.o</span><br><span class="line">      3540        152          0          0          0      23016   stm32f0xx_ll_usb.o</span><br><span class="line">         2          0         24          4          0       1745   system_stm32f0xx.o</span><br><span class="line">       236         36          0          0         48       2973   systime.o</span><br><span class="line">       152         20          0          0         72       5392   tim.o</span><br><span class="line">       160         12          0          0       1024       1279   uart_data_analysis.o</span><br><span class="line">       828         84          0          0        464       7567   usart.o</span><br><span class="line">        64         12          0          0        708       2859   usb_device.o</span><br><span class="line">      1268        120          0          0          1       9115   usb_handle.o</span><br><span class="line">       722         20          0        267         92      10062   usbd_cdc.o</span><br><span class="line">       260         24          0         24        129       4611   usbd_cdc_if.o</span><br><span class="line">       452         64          0        181          8       5864   usbd_composite.o</span><br><span class="line">       758         32          0          0        756      15665   usbd_conf.o</span><br><span class="line">       718          0          0          0          0       8036   usbd_core.o</span><br><span class="line">      1252         28          0          0          1       8339   usbd_ctlreq.o</span><br><span class="line">       140         16          0         50         72       3641   usbd_custom_hid_if.o</span><br><span class="line">       594         46          0        198         84       7979   usbd_customhid.o</span><br><span class="line">       504        144          0         76        512       4167   usbd_desc.o</span><br><span class="line">       162          0          0          0          0       4514   usbd_ioreq.o</span><br></pre></td></tr></table></figure>

<h1 id="STM32–启动过程"><a href="#STM32–启动过程" class="headerlink" title="STM32–启动过程"></a>STM32–启动过程</h1><p>本部分介绍从上电到进入main函数的过程。</p>
<h2 id="启动位置"><a href="#启动位置" class="headerlink" title="启动位置"></a>启动位置</h2><p>STM32能从Flash&#x2F;SRAM或System memory(远程)启动。启动位置直接决定链接脚本的加载和运行的基地址配置。</p>
<p>如何确认：</p>
<ol>
<li>查固件包Reference Manual：对于F0系列，由BOOT0 pin和nBOOT1 register bit决定启动位置。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131603031.png" alt="image-20240513160303987"></p>
<ol start="2">
<li>查开发板BOOT0 pin：下拉接地，因此开发板是Boot from Flash。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131605456.png" alt="image-20240513160533426"></p>
<ol start="3">
<li>顺便查一下nBOOT1 register：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131606693.png" alt="image-20240513160652648"></p>
<h2 id="startup-s"><a href="#startup-s" class="headerlink" title="startup.s"></a>startup.s</h2><p>根据链接脚本指定的asm找到启动文件startup_stm32f072xb.s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ASM sources</span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">startup_stm32f072xb.s</span><br></pre></td></tr></table></figure>

<p>根据链接脚本的RESET符号，找到CPU复位时执行指令的入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp                   ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                  ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                    ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler              ; Hard Fault Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SVC_Handler                    ; SVCall Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     PendSV_Handler                 ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler                ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">                DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">                DCD     RCC_IRQHandler                 ; RCC</span><br><span class="line">                DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">                DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">                DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">                DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">                DCD     DMA1_Channel4_5_IRQHandler     ; DMA1 Channel 4 and Channel 5</span><br><span class="line">                DCD     ADC1_IRQHandler                ; ADC1 </span><br><span class="line">                DCD     TIM1_BRK_UP_TRG_COM_IRQHandler ; TIM1 Break, Update, Trigger and Commutation</span><br><span class="line">                DCD     TIM1_CC_IRQHandler             ; TIM1 Capture Compare</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM3_IRQHandler                ; TIM3</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM14_IRQHandler               ; TIM14</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM16_IRQHandler               ; TIM16</span><br><span class="line">                DCD     TIM17_IRQHandler               ; TIM17</span><br><span class="line">                DCD     I2C1_IRQHandler                ; I2C1</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SPI1_IRQHandler                ; SPI1</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     USART1_IRQHandler              ; USART1</span><br><span class="line">                DCD     USART2_IRQHandler              ; USART2</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     USB_IRQHandler                 ; USB</span><br><span class="line"></span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure>

<p>这里面的AREA&#x2F;DCD等伪汇编符号含义，参考[指令集与伪汇编](# 指令集与伪汇编)</p>
<p>以上代码声明了中断向量表，定义CPU中断、异常发生时的入口地址。</p>
<p>STM32 中断向量表的定义参考固件包Program Manual：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131542062.png" alt="image-20240513154213024"></p>
<p>MCU启动或者reset时：</p>
<p>PC指针从0x0: __initial_sp取指令，<del>此处没任何内容</del>  此处不是个指令，而是栈顶指针的值，由编译器根据代码量+StackSize自动生成；《STM32–Firmware Architecture part2》详细分析如何生成。</p>
<p>然后PC + 4，从0x4取指令，即执行Reset_Handler：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler routine</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler                 [WEAK]</span><br><span class="line">        IMPORT  __main</span><br><span class="line">        IMPORT  SystemInit  </span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>

<p>这里先后执行SystemInit和__main</p>
<ol>
<li>SystemInit的作用如下，o2link代码没有用此函数（空）</li>
</ol>
<p>This function is called at startup just after reset and before branch to main program. User can setups the default system clock (System clock source, PLL Multiplier and Divider factors, AHB&#x2F;APBx prescalers and Flash settings</p>
<ol start="2">
<li>__main符号即C的main函数 <em>int</em> main(<em>void</em>)，从此进入C代码执行。</li>
</ol>
<h2 id="指令集与伪汇编"><a href="#指令集与伪汇编" class="headerlink" title="指令集与伪汇编"></a>指令集与伪汇编</h2><p>指令集：MCU硬件决定的指令，例如STM32是Cortex M0指令集。 详见固件包Program Manual。</p>
<p>伪汇编指令：是编译器扩展的汇编语法，取决于编译器类型。根据汇编器找user guide，例如 armasm：</p>
<p><a target="_blank" rel="noopener" href="https://documentation-service.arm.com/static/63eb50c09567172d4e2aa777">https://documentation-service.arm.com/static/63eb50c09567172d4e2aa777</a></p>
<ol>
<li>Cortex M0指令集：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557835.png" alt="image-20240513155719763"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557727.png" alt="image-20240513155736664"></p>
<ol start="2">
<li>armasm的一些伪汇编指令：</li>
</ol>
<blockquote>
<p>AREA:声明一块区域的属性，例如：AREA A64ex, CODE, READONLY;  Name this block of code A64ex</p>
<p>EXPORT：使符号对其他文件可见。Labels are local to the source file unless you make them global using the EXPORT directive  </p>
<p>DCD: Declares one or more words of store. 声明一块区域，如果区域是函数符号表示声明该函数所占用的区域。</p>
</blockquote>
<h1 id="STM32–main初始化流程"><a href="#STM32–main初始化流程" class="headerlink" title="STM32–main初始化流程"></a>STM32–main初始化流程</h1><h2 id="HAL-Init"><a href="#HAL-Init" class="headerlink" title="HAL_Init"></a>HAL_Init</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">	HAL_Init();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */</span><br><span class="line">HAL_InitTick(TICK_INT_PRIORITY);</span><br><span class="line">--&gt; HAL_SYSTICK_Config: Configure the SysTick to have interrupt in 1ms time basis</span><br><span class="line">--&gt; HAL_NVIC_SetPriority: Configure the SysTick IRQ priority</span><br></pre></td></tr></table></figure>

<ol>
<li>关于HAL_SYSTICK_Config的底层实现（参考HAL user manual.chm：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00043    (+) The HAL_SYSTICK_Config()function calls the SysTick_Config() function which</span><br><span class="line">00044        is a CMSIS function that:</span><br><span class="line">00045         (++) Configures the SysTick Reload register with value passed as function parameter.</span><br><span class="line">00046         (++) Configures the SysTick IRQ priority to the lowest value (0x03).</span><br><span class="line">00047         (++) Resets the SysTick Counter register.</span><br><span class="line">00048         (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).</span><br><span class="line">00049         (++) Enables the SysTick Interrupt.</span><br><span class="line">00050         (++) Starts the SysTick Counter.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关于systick的NVIC中断优先级：</li>
</ol>
<p> * <em>@note</em> In the default implementation, SysTick timer is the source of time base. </p>
<p> *    It is used to generate interrupts at regular time intervals. </p>
<p> *    Care must be taken if HAL_Delay() is called from a peripheral ISR process, </p>
<p> *    The SysTick interrupt must have higher priority (numerically lower) </p>
<p> *    than the peripheral interrupt. Otherwise the caller ISR process will be blocked.</p>
<ol start="3">
<li>STM32 所有的中断和异常的优先级总表，参考Reference Manual：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131633379.png" alt="image-20240513163316319"></p>
<h2 id="SystemClock-Config"><a href="#SystemClock-Config" class="headerlink" title="SystemClock_Config"></a>SystemClock_Config</h2><ol>
<li>整个时钟树配置参数可以在CubeMX初始化项目时配置，系统时钟SYSCLK有外部HSE（8M OSC）和内部HSI（内部RC）多个源，由下图当前配置生效的是HSI 48M RC作为源。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131647697.png" alt="image-20240513164731624"></p>
<p>不同外设模式对时钟树的要求：</p>
<blockquote>
<p>I2c input frequency should up to 48M to support 1M i2c clock.</p>
<p>UART input frequency should be changed to HIS 8M to support lower than 1K baud rate and changed to 48M to support 1M baud rate.</p>
<p>USB modules need 48M input frequency</p>
</blockquote>
<ol start="2">
<li>系统时钟配置过程：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Configure the system clock */</span><br><span class="line">	SystemClock_Config();</span><br></pre></td></tr></table></figure>

<p>主要分两步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Initializes the RCC Oscillators</span><br><span class="line">Initializes the CPU, AHB and APB buses clocks</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>具体配置过程，以HAL_RCC_OscConfig的HSI Configuration为例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">HAL_RCC_OscConfig：</span><br><span class="line"></span><br><span class="line">/*----------------------------- HSI Configuration --------------------------*/ </span><br><span class="line">  if(((RCC_OscInitStruct-&gt;OscillatorType) &amp; RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)</span><br><span class="line">  &#123;</span><br><span class="line">    /* Check the parameters */</span><br><span class="line">    assert_param(IS_RCC_HSI(RCC_OscInitStruct-&gt;HSIState));</span><br><span class="line">    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct-&gt;HSICalibrationValue));</span><br><span class="line">    </span><br><span class="line">    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ </span><br><span class="line">    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) </span><br><span class="line">       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) &amp;&amp; (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))</span><br><span class="line">    &#123;</span><br><span class="line">      /* When HSI is used as system clock it will not disabled */</span><br><span class="line">      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) &amp;&amp; (RCC_OscInitStruct-&gt;HSIState != RCC_HSI_ON))</span><br><span class="line">      &#123;</span><br><span class="line">        return HAL_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">      /* Otherwise, just the calibration is allowed */</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/</span><br><span class="line">        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct-&gt;HSICalibrationValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      /* Check the HSI State */</span><br><span class="line">      if(RCC_OscInitStruct-&gt;HSIState != RCC_HSI_OFF)</span><br><span class="line">      &#123;</span><br><span class="line">       /* Enable the Internal High Speed oscillator (HSI). */</span><br><span class="line">        __HAL_RCC_HSI_ENABLE();</span><br><span class="line">        </span><br><span class="line">        /* Get Start Tick */</span><br><span class="line">        tickstart = HAL_GetTick();</span><br><span class="line">        </span><br><span class="line">        /* Wait till HSI is ready */</span><br><span class="line">        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)</span><br><span class="line">        &#123;</span><br><span class="line">          if((HAL_GetTick() - tickstart ) &gt; HSI_TIMEOUT_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">            return HAL_TIMEOUT;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/</span><br><span class="line">        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct-&gt;HSICalibrationValue);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        /* Disable the Internal High Speed oscillator (HSI). */</span><br><span class="line">        __HAL_RCC_HSI_DISABLE();</span><br><span class="line">        </span><br><span class="line">        /* Get Start Tick */</span><br><span class="line">        tickstart = HAL_GetTick();</span><br><span class="line">        </span><br><span class="line">        /* Wait till HSI is disabled */</span><br><span class="line">        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)</span><br><span class="line">        &#123;</span><br><span class="line">          if((HAL_GetTick() - tickstart ) &gt; HSI_TIMEOUT_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">            return HAL_TIMEOUT;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里判断HSI时钟源Ready的代码逻辑：</p>
<ul>
<li><p>根据时钟类型，读对应的register的ready bit是否为0。</p>
</li>
<li><p>如果到超时没ready，即此时钟不可用，继续初始化其他时钟。</p>
</li>
</ul>
<p>这里有个问题：系统时钟源还没配置完，为什么可以用HAL_GetTick去判断Ready超时，systick从哪来？</p>
<p>原因：CPU Reset后默认使用HSI时钟，前面的HAL_Init利用HSI初始化了1ms systick功能，因此systick可用；SystemClock_Config只是再次配置时钟，并不是说此时没有时钟。</p>
<ol start="4">
<li>判断时钟源ready register相关的代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)：</span><br><span class="line"></span><br><span class="line">typedef enum </span><br><span class="line">&#123;</span><br><span class="line">  RESET = 0U, </span><br><span class="line">  SET = !RESET</span><br><span class="line">&#125; FlagStatus, ITStatus;</span><br><span class="line"></span><br><span class="line">#define RCC_FLAG_HSERDY                  ((uint8_t)((CR_REG_INDEX &lt;&lt; 5U) | RCC_CR_HSERDY_BitNumber))</span><br><span class="line">#define CR_REG_INDEX                     ((uint8_t)1U)</span><br><span class="line">#define RCC_CR_HSERDY_BitNumber           17</span><br><span class="line"></span><br><span class="line">#define __HAL_RCC_GET_FLAG(__FLAG__) (((((__FLAG__) &gt;&gt; 5U) == CR_REG_INDEX)? RCC-&gt;CR :      \</span><br><span class="line">                                       (((__FLAG__) &gt;&gt; 5U) == CR2_REG_INDEX)? RCC-&gt;CR2 :    \</span><br><span class="line">                                       (((__FLAG__) &gt;&gt; 5U) == BDCR_REG_INDEX) ? RCC-&gt;BDCR : \</span><br><span class="line">                                       RCC-&gt;CSR) &amp; (1U &lt;&lt; ((__FLAG__) &amp; RCC_FLAG_MASK)))</span><br></pre></td></tr></table></figure>

<p>RCC-&gt;CR的定义为例：bit17为HSE RDY bit.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131708364.png" alt="image-20240513170841325"></p>
<h2 id="MX-GPIO-Init"><a href="#MX-GPIO-Init" class="headerlink" title="MX_GPIO_Init"></a>MX_GPIO_Init</h2><p>GPIO初始化入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Initialize all configured peripherals */</span><br><span class="line">	MX_GPIO_Init();</span><br></pre></td></tr></table></figure>

<p>GPIO重点描述几个话题：</p>
<ol>
<li><p>GPIO分组与复用</p>
<p>GPIO有A~F多组，各组的pin独立；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737151.png" alt="image-20240513173750127"></p>
<p>每组GPIO pin都有复用不同的功能；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737965.png" alt="image-20240513173701913"></p>
</li>
<li><p>GPIO的模式</p>
<p>参考Datasheet：Each of the GPIO pins can be configured by software as output (push-pull or open-drain), as input (with or without pull-up or pull-down) or as peripheral alternate function.   </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131747355.png" alt="image-20240513174736319"></p>
<p>输出模式的开漏和推挽模式的主要特性：</p>
<p>（1）开漏输出的高电平不是MCU驱动的，MCU仅作为控制源；输出高电平是借助外部上拉电平；可以自定义输出电平，例如3.3V&#x2F;5V只需要调节上拉电平，不需受到MCU驱动能力限制。</p>
<p>（2）推挽输出的高电平是MCU驱动，即MCU通过内部P&#x2F;N MOS结构真正输出电压（一般3.3V），MCU驱动能力有限。</p>
</li>
</ol>
<p>GPIO代码示例（输出模式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//初始化配置模式：输出，推挽</span><br><span class="line">//恢复默认值（GPIO_PIN_RESET，0）</span><br><span class="line">/*Configure GPIO pin Output Level */</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_8 | GPIO_PIN_15, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">//配置模式</span><br><span class="line">/*Configure GPIO pin : PA */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_8 | GPIO_PIN_15;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">//使用：翻转PA15</span><br><span class="line">HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_15);</span><br><span class="line">//使用：设置高</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);</span><br></pre></td></tr></table></figure>

<p>GPIO中断模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//设置中断模式和优先级</span><br><span class="line">/*Configure GPIO pin : PB */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_4;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING; //中断模式</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">//GPIO_MODE_IT_RISING_FALLING实际是设置EXTI中断</span><br><span class="line">#define  GPIO_MODE_IT_RISING_FALLING            (MODE_INPUT | EXTI_IT | TRIGGER_RISING | TRIGGER_FALLING) </span><br><span class="line"></span><br><span class="line">/* EXTI interrupt init*/</span><br><span class="line">HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);</span><br><span class="line">HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);</span><br><span class="line"></span><br><span class="line">//中断回调</span><br><span class="line">//GPIO4实际是PB4，因为仅PB4设置为INT模式</span><br><span class="line">void EXTI4_15_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MX-DMA-Init"><a href="#MX-DMA-Init" class="headerlink" title="MX_DMA_Init"></a>MX_DMA_Init</h2><h3 id="DMA的常规操作"><a href="#DMA的常规操作" class="headerlink" title="DMA的常规操作"></a>DMA的常规操作</h3><p>参考UM1850：</p>
<p>How to use this driver</p>
<ol>
<li>Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM &#x2F;FLASH memories: no initialization is necessary). Please refer to the Reference manual for connectionbetween peripherals and DMA requests.</li>
<li>For a given Channel, program the required configuration through the following parameters: Channel request,Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level,Source and Destination Increment mode using HAL_DMA_Init() function.</li>
<li>Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of errordetection.4. Use HAL_DMA_Abort() function to abort the current transfer</li>
</ol>
<p>轮询和中断两种模式：</p>
<p>Polling mode IO operation</p>
<p>• Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred</p>
<p>• Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can beconfigured by User depending from his application</p>
<p>Interrupt mode IO operation</p>
<p>• Configure the DMA interrupt priority using HAL_NVIC_SetPriority()</p>
<p>• Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()</p>
<p>• Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred. In this case the DMA interrupt is configured</p>
<p>• Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine</p>
<p>• At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can add his own functionby customization of function pointer XferCpltCallback and XferErrorCallback (i.e. a member of DMA handlestructure).</p>
<h3 id="DMA-Init和IRQ-handler"><a href="#DMA-Init和IRQ-handler" class="headerlink" title="DMA_Init和IRQ handler"></a>DMA_Init和IRQ handler</h3><p>DMA用于UART RX传输中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void MX_DMA_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* DMA controller clock enable */</span><br><span class="line">  __HAL_RCC_DMA1_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  /* DMA interrupt init */</span><br><span class="line">  /* DMA1_Channel4_5_6_7_IRQn interrupt configuration */</span><br><span class="line">  HAL_NVIC_SetPriority(DMA1_Channel4_5_6_7_IRQn, 0, 0);</span><br><span class="line">  HAL_NVIC_EnableIRQ(DMA1_Channel4_5_6_7_IRQn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DMA1_Channel4_5_6_7_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">  HAL_DMA_IRQHandler(&amp;hdma_usart2_rx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Drivers\CMSIS\Device\ST\STM32F0xx\Include\stm32f072xb.h:</span><br><span class="line">DMA1_Channel4_5_6_7_IRQn    = 11,     /*!&lt; DMA1 Channel 4 to Channel 7 Interrupt </span><br><span class="line"></span><br><span class="line">Drivers\CMSIS\Device\ST\STM32F0xx\Source\Templates\arm\startup_stm32f072xb.s:</span><br><span class="line">IRQ 11的handler即DMA1_Channel4_5_6_7_IRQHandler</span><br><span class="line">; External Interrupts</span><br><span class="line">DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">DCD     PVD_VDDIO2_IRQHandler          ; PVD through EXTI Line detect</span><br><span class="line">DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">DCD     RCC_CRS_IRQHandler             ; RCC and CRS</span><br><span class="line">DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">DCD     TSC_IRQHandler                 ; TS</span><br><span class="line">DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">DCD     DMA1_Channel4_5_6_7_IRQHandler ; DMA1 Channel 4, Channel 5, Channel 6 and Channel 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UART RX 使用DMA channel 5 处理接收数据中断</span><br><span class="line">HAL_UART_MspInit()：</span><br><span class="line">/* USART2 DMA Init */</span><br><span class="line">    /* USART2_RX Init */</span><br><span class="line">    hdma_usart2_rx.Instance = DMA1_Channel5;</span><br><span class="line">    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;</span><br><span class="line">    if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HAL_DMA_IRQHandler的具体操作:</p>
<p>处理DMA传输完成中断：分为half transfer complete和Transfer Complete两种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Transfer Complete Interrupt management ***********************************/</span><br><span class="line">  else if ((RESET != (flag_it &amp; (DMA_FLAG_TC1 &lt;&lt; hdma-&gt;ChannelIndex))) &amp;&amp; (RESET != (source_it &amp; DMA_IT_TC)))</span><br><span class="line">  &#123;</span><br><span class="line">  	if((hdma-&gt;Instance-&gt;CCR &amp; DMA_CCR_CIRC) == 0U)</span><br><span class="line">  	&#123;</span><br><span class="line">  		/* Disable the transfer complete  &amp; transfer error interrupts */</span><br><span class="line">  		/* if the DMA mode is not CIRCULAR */</span><br><span class="line">  		hdma-&gt;Instance-&gt;CCR &amp;= ~(DMA_IT_TC | DMA_IT_TE);</span><br><span class="line">  		</span><br><span class="line">  		/* Change the DMA state */</span><br><span class="line">  		hdma-&gt;State = HAL_DMA_STATE_READY;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	/* Clear the transfer complete flag */</span><br><span class="line">  	hdma-&gt;DmaBaseAddress-&gt;IFCR = DMA_FLAG_TC1 &lt;&lt; hdma-&gt;ChannelIndex;</span><br></pre></td></tr></table></figure>

<p>DMA传输完成的回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(hdma-&gt;XferCpltCallback != NULL)</span><br><span class="line">  	&#123;</span><br><span class="line">  		/* Transfer complete callback */</span><br><span class="line">  		hdma-&gt;XferCpltCallback(hdma);</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<p>o2link的UART2处理1KB DMA buffer的自定义逻辑，就是在此中断回调中实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UART_Start_Receive_DMA():</span><br><span class="line">/* Set the UART DMA transfer complete callback */</span><br><span class="line">    huart-&gt;hdmarx-&gt;XferCpltCallback = UART_DMAReceiveCplt;</span><br></pre></td></tr></table></figure>

<p>DMA传输错误中断的判断和回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Transfer Error Interrupt management ***************************************/</span><br><span class="line">  else if (( RESET != (flag_it &amp; (DMA_FLAG_TE1 &lt;&lt; hdma-&gt;ChannelIndex))) &amp;&amp; (RESET != (source_it &amp; DMA_IT_TE)))</span><br><span class="line">  &#123;</span><br><span class="line">  	/* When a DMA transfer error occurs */</span><br><span class="line">    /* A hardware clear of its EN bits is performed */</span><br><span class="line">    /* Then, disable all DMA interrupts */</span><br><span class="line">    hdma-&gt;Instance-&gt;CCR &amp;= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);</span><br><span class="line">    </span><br><span class="line">    /* Clear all flags */</span><br><span class="line">    hdma-&gt;DmaBaseAddress-&gt;IFCR = DMA_FLAG_GL1 &lt;&lt; hdma-&gt;ChannelIndex;</span><br><span class="line">    </span><br><span class="line">    /* Update error code */</span><br><span class="line">    hdma-&gt;ErrorCode = HAL_DMA_ERROR_TE;</span><br><span class="line">    </span><br><span class="line">    /* Change the DMA state */</span><br><span class="line">    hdma-&gt;State = HAL_DMA_STATE_READY;    </span><br><span class="line">    </span><br><span class="line">    /* Process Unlocked */</span><br><span class="line">    __HAL_UNLOCK(hdma); </span><br><span class="line">    </span><br><span class="line">    if(hdma-&gt;XferErrorCallback != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    	/* Transfer error callback */</span><br><span class="line">    	hdma-&gt;XferErrorCallback(hdma);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="DMA-channel和外设的对应关系"><a href="#DMA-channel和外设的对应关系" class="headerlink" title="DMA channel和外设的对应关系"></a>DMA channel和外设的对应关系</h3><p>参考（RM0091）：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132023514.png" alt="image-20240513202302455"></p>
<h2 id="MX-I2C1-Init"><a href="#MX-I2C1-Init" class="headerlink" title="MX_I2C1_Init"></a>MX_I2C1_Init</h2><p>首先明确一个问题：是硬件实现的I2C还是软件GPIO模拟的I2C？</p>
<p>怎么确认：看电路图+Datasheet+底层数据传输代码</p>
<ul>
<li>硬件I2C：此GPIO应该支持I2C功能，Datasheet确认，软件查看是否配成了I2C功能，数据传输是否配置I2C register</li>
<li>软件I2C：此GPIO是普通的GPIO功能，用软件控制high、low和delay控制I2C数据传输，底层操作不是用I2C register实现。</li>
</ul>
<p>根据以下，本环境是硬件I2C功能。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171539178.png" alt="image-20240517153927141"><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541038.png" alt="image-20240517154143995"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541688.png" alt="image-20240517154158646"></p>
<p>下面看初始化代码。</p>
<p>I2C初始化包括两步：</p>
<ol>
<li>设置I2C通信参数</li>
</ol>
<p>速度：standard (up to 100 kHz), Fast-mode (up to 400 kHz) or Fast-mode Plus (up to 1 MHz)  </p>
<p>寻址：7-bit&#x2F;10 bit addressing mode，决定i2c slave设备寻址空间</p>
<p>其他能力见RM0091:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132036579.png" alt="image-20240513203608542"></p>
<p>代码配置的速度和寻址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hi2c1.Init.Timing = SETTING_CLK_100K;</span><br><span class="line">hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置GPIO pin为I2C模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Init</span><br><span class="line"></span><br><span class="line">--&gt; HAL_I2C_MspInit:</span><br><span class="line"></span><br><span class="line">/**I2C1 GPIO Configuration</span><br><span class="line">PB6   ------&gt; I2C1_SCL</span><br><span class="line">PB7   ------&gt; I2C1_SDA</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_I2C1;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="MX-SPI1-Init"><a href="#MX-SPI1-Init" class="headerlink" title="MX_SPI1_Init"></a>MX_SPI1_Init</h2><p>和I2C初始化结构基本类似</p>
<ol>
<li><p>设置SPI通信参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hspi1.Init.Mode = SPI_MODE_MASTER;</span><br><span class="line">hspi1.Init.Direction = SPI_DIRECTION_2LINES; //双向</span><br><span class="line">hspi1.Init.DataSize = SPI_DATASIZE_8BIT; //数据是8bit模式</span><br><span class="line">hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH; //</span><br><span class="line">hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;</span><br></pre></td></tr></table></figure>

<p>关于SPI配置，主要关注数据模式是8bit还是16bit, 以及数据采样和传输的时间点(极性和相位)。</p>
<p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/689464409">SPI的四种传输模式及工作机制分析</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132055783.png" alt="image-20240513205538749"></p>
<p>黑线为数据采样点，与之相反为数据发送点</p>
</li>
<li><p>设置GPIO为SPI模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**SPI1 GPIO Configuration</span><br><span class="line">PA5     ------&gt; SPI1_SCK</span><br><span class="line">PA6     ------&gt; SPI1_MISO</span><br><span class="line">PA7     ------&gt; SPI1_MOSI</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MX-USART1-UART-Init"><a href="#MX-USART1-UART-Init" class="headerlink" title="MX_USART1_UART_Init"></a>MX_USART1_UART_Init</h2><p>对于o2link board, 使用三个UART：</p>
<p>(1) UART 1 PA9 PA10 is used as debug port.</p>
<p>(2) UART 2 PA2 PA3 is used as USB TO UART port</p>
<p>(3) UART 3 PB10 PB11 is used as system communication port.</p>
<p>本节讨论UART1</p>
<ol>
<li><p>设置UART通信参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">huart1.Instance = USART1;</span><br><span class="line">huart1.Init.BaudRate = 115200; //波特率</span><br><span class="line">huart1.Init.WordLength = UART_WORDLENGTH_8B; //8-bit long UART frame(可配7,8,9bit)</span><br><span class="line">huart1.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">huart1.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">huart1.Init.Mode = UART_MODE_TX_RX; //双向</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置GPIO为UART模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**USART1 GPIO Configuration</span><br><span class="line">PA9     ------&gt; USART1_TX</span><br><span class="line">PA10     ------&gt; USART1_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_USART1;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
</li>
<li><p>UART Idle frame和Break frame的概念</p>
<p>为什么UART pin默认拉高？</p>
<p>UART除了正常的数据传输情况，还有idle和break frame的特殊情况：</p>
<p>An Idle character is interpreted as an entire frame of “1”s (the number of “1”s includes the number of stop bits).</p>
<p>A Break character is interpreted on receiving “0”s for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132106226.png" alt="image-20240513210648197"></p>
<p>默认上拉, 如果MCU没有drive UART RX&#x2F;TX pin为低，则可以识别为idle frame；</p>
<p>默认上拉，UART start时MCU开始drive RX&#x2F;TX, 直接拉低pin形成Start信号。</p>
</li>
</ol>
<h2 id="MX-USART2-UART-Init"><a href="#MX-USART2-UART-Init" class="headerlink" title="MX_USART2_UART_Init"></a>MX_USART2_UART_Init</h2><p>o2link的UART 2 PA2 PA3 is used as USB TO UART port.</p>
<p>什么是USB to UART：涉及USB CDC虚拟串口的概念，参考： <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#Communications_Devices_Class_-CDC-_2">Communications Devices Class (CDC)</a>，即USB实现的虚拟串口协议；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132127552.png" alt="image-20240513212722508"></p>
<p>MCU侧配置UART2参数是来自于USBD_CDC_LineCoding.</p>
<p>对于o2link的USB to UART2:</p>
<p>UART TX has no buffer, it will send data directly to the TX pin when it receives data from USB HID, the max data is 64 bytes one time. UART RX has 1K bytes buffer, it uses idle frame to receive data, when it sees this idle frame, it will generate interrupt to tell the app code, and the app code will split data into 64 bytes and transmit the data to the USB.  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132125954.png" alt="image-20240513212534924"></p>
<h3 id="UART2初始化过程"><a href="#UART2初始化过程" class="headerlink" title="UART2初始化过程"></a>UART2初始化过程</h3><ol>
<li>根据USB CDC的配置，设置UART2参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void MX_USART2_UART_Init(uint32_t baurate)</span><br><span class="line">&#123;</span><br><span class="line">  USBD_CDC_LineCoding.bitrate = baurate; //1000 000</span><br><span class="line">  USBD_CDC_LineCoding.paritytype = UART_PARITY_NONE;</span><br><span class="line">  USBD_CDC_LineCoding.datatype = UART_WORDLENGTH_8B;</span><br><span class="line">  USBD_CDC_LineCoding.format = UART_STOPBITS_1;</span><br><span class="line">  UART2_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UART2_Init():</span><br><span class="line"></span><br><span class="line">huart2.Init.BaudRate = USBD_CDC_LineCoding.bitrate;</span><br><span class="line">switch (USBD_CDC_LineCoding.paritytype)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">    break;</span><br><span class="line">  case 1:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_ODD;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_EVEN;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart3.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (USBD_CDC_LineCoding.datatype)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0x07:</span><br><span class="line">    huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    break;</span><br><span class="line">  case 0x08:</span><br><span class="line">    if (huart2.Init.Parity == UART_PARITY_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">      huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      huart2.Init.WordLength = UART_WORDLENGTH_9B;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (USBD_CDC_LineCoding.format)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_2;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>配置GPIO，配置UART使用DMA模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**USART2 GPIO Configuration</span><br><span class="line">PA2     ------&gt; USART2_TX</span><br><span class="line">PA3     ------&gt; USART2_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_USART2;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">/* USART2 DMA Init */</span><br><span class="line">/* USART2_RX Init */</span><br><span class="line">hdma_usart2_rx.Instance = DMA1_Channel5;</span><br><span class="line">hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">hdma_usart2_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;</span><br><span class="line">if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__HAL_LINKDMA(uartHandle, hdmarx, hdma_usart2_rx);</span><br><span class="line"></span><br><span class="line">/* USART2 interrupt Init */</span><br><span class="line">HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);</span><br><span class="line">HAL_NVIC_EnableIRQ(USART2_IRQn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动DMA，随时准备处理UART RX的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">reset_uart_buffer() </span><br><span class="line">--&gt;</span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2, UART2_RxBuffer, UART_PACKAGE_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">参数如下：</span><br><span class="line">* @param huart UART handle.</span><br><span class="line">* @param pData Pointer to data buffer (uint8_t or uint16_t data elements).</span><br><span class="line">* @param Size  Amount of data elements (uint8_t or uint16_t) to be received.</span><br><span class="line"></span><br><span class="line">其中UART2_RxBuffer是1KB buffer， UART_PACKAGE_MAX_SIZE = 1024</span><br><span class="line"></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA的内容：</span><br><span class="line">/* Set Reception type to reception till IDLE Event*/</span><br><span class="line">huart-&gt;ReceptionType = HAL_UART_RECEPTION_TOIDLE; //Reception till completion or IDLE event. 即UART有idle frame能产生DMA中断，不一定要传输完整个buffer的1KB数据。</span><br><span class="line">//启动DMA</span><br><span class="line">status = UART_Start_Receive_DMA(huart, pData, Size);</span><br></pre></td></tr></table></figure>

<p>启动DMA传输的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UART_Start_Receive_DMA():</span><br><span class="line"></span><br><span class="line">/* Set the UART DMA transfer complete callback */</span><br><span class="line">huart-&gt;hdmarx-&gt;XferCpltCallback = UART_DMAReceiveCplt;</span><br><span class="line">/* Enable the DMA channel */</span><br><span class="line">HAL_DMA_Start_IT()    </span><br></pre></td></tr></table></figure>

<p>UART_DMAReceiveCplt里面自定义了完成的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">UART_DMAReceiveCplt()</span><br><span class="line">--&gt; HAL_UARTEx_RxEventCallback():</span><br><span class="line"></span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">&#123;</span><br><span class="line">	/* Prevent unused argument(s) compilation warning */</span><br><span class="line">	UNUSED(huart);</span><br><span class="line">	UNUSED(Size);</span><br><span class="line"></span><br><span class="line">	if (huart-&gt;Instance == USART2)</span><br><span class="line">	&#123;</span><br><span class="line">	    //Size是DMA已传输完的总长度（DMA硬件自动计算）</span><br><span class="line">        //Rx_buf_pos是firmware自定义, 记录RX buffer的偏移。 </span><br><span class="line">		//Rx_length即当前DMA complete的传输数据长度（不包括历史总长度）</span><br><span class="line">		Rx_length = Size - Rx_buf_pos;</span><br><span class="line">		if ((Size &lt; Rx_buf_pos) || (Size &gt; UART_PACKAGE_MAX_SIZE))</span><br><span class="line">		&#123;</span><br><span class="line">			Rx_buf_pos = Size;</span><br><span class="line">			if (Rx_buf_pos &gt;= UART_PACKAGE_MAX_SIZE)</span><br><span class="line">				Rx_buf_pos = 0;</span><br><span class="line">			printf(&quot;dma buffer error\r\n &quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//这里uart_rx_fifo和UART2_RxBuffer都是1KB buffer，uart_rx_fifo用于每次DMA的buffer，每次数据都从0开始存；UART2_RxBuffer是存储多次DMA的总数据，按偏移组合；</span><br><span class="line">		fifo_s_puts(&amp;uart_rx_fifo, (char *)&amp;UART2_RxBuffer[Rx_buf_pos], Rx_length);</span><br><span class="line">		Rx_buf_pos += Rx_length;</span><br><span class="line">		if (Rx_buf_pos &gt;= UART_PACKAGE_MAX_SIZE) //1024</span><br><span class="line">			Rx_buf_pos = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解以上代码，就可以理解USB to UART2的RX机制，是将下位机的大量UART data(最多1024 bytes)，分多次DMA存到UART2_RxBuffer，再按64bytes&#x2F;USB buffer发给上位机。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141625450.png" alt="image-20240514162541398"></p>
</li>
</ol>
<h3 id="UART的DMA传输小结"><a href="#UART的DMA传输小结" class="headerlink" title="UART的DMA传输小结"></a>UART的DMA传输小结</h3><p>UART为什么使用DMA：</p>
<ol>
<li>常规的UART传输，不管是轮询还是中断，一般需要先指定好传输长度是多少个byte，即必须数据长度已知。</li>
</ol>
<p>常规的UART传输如何知道传输完成：</p>
<p>如果是轮询就预估超时时间，如果是中断就按传输完成多少byte作为标志。</p>
<ol start="2">
<li>使用DMA中断的UART传输，可以支持不定长度的数据。</li>
</ol>
<p>使用DMA的UART如何知道传输完成：</p>
<p>数据传输完成；或者有UART event如Idle event，RTO event…</p>
<h2 id="MX-USART3-UART-Init"><a href="#MX-USART3-UART-Init" class="headerlink" title="MX_USART3_UART_Init"></a>MX_USART3_UART_Init</h2><p>UART 3 PB10 PB11 is used as system communication port.</p>
<p>和UART1配置区别仅在波特率，uart3实例没实际使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huart3.Init.BaudRate = 1000000;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**USART3 GPIO Configuration</span><br><span class="line">PB10     ------&gt; USART3_TX</span><br><span class="line">PB11     ------&gt; USART3_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_10 | GPIO_PIN_11;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF4_USART3;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<h2 id="MX-USB-DEVICE-Init"><a href="#MX-USB-DEVICE-Init" class="headerlink" title="MX_USB_DEVICE_Init"></a>MX_USB_DEVICE_Init</h2><p>USB设备的功能实现从上到下分为几层API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Middleware层的USB API：usbd_core (.c, .h), 例如USBD_Init</span><br><span class="line">--&gt; Low level层的USB API：例如USBD_LL_Init</span><br><span class="line">--&gt; HAL的USB host或peripheral API：例如HAL_PCD_Init</span><br><span class="line"></span><br><span class="line">HCD：USB host controller driver</span><br><span class="line">PCD：USB peripheral controller driver</span><br></pre></td></tr></table></figure>

<p>参考： <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#USB_device_library_overview">USB device library overview</a></p>
<p>下面具体分析USB初始化各层负责什么工作：</p>
<p>USBD_Init：Initializes the device stack and load the class driver. 负责USB协议范畴的设备class，设备descriptor等信息的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Unlink previous class*/</span><br><span class="line">  if (pdev-&gt;pClass != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    pdev-&gt;pClass = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Assign USBD Descriptors */</span><br><span class="line">  if (pdesc != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    pdev-&gt;pDesc = pdesc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Set Device initial State */</span><br><span class="line">  pdev-&gt;dev_state = USBD_STATE_DEFAULT;</span><br><span class="line">  pdev-&gt;id = id;</span><br></pre></td></tr></table></figure>

<p>USBD_LL_Init：Initializes the low level portion of the device driver. 负责PCD设备对象的初始化，包括设备属性，设备初始化，DMA配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PCD_HandleTypeDef hpcd_USB_FS;</span><br><span class="line"></span><br><span class="line">/* Link the driver to the stack. */</span><br><span class="line">hpcd_USB_FS.pData = pdev;</span><br><span class="line">pdev-&gt;pData = &amp;hpcd_USB_FS;</span><br><span class="line">//设备属性</span><br><span class="line">hpcd_USB_FS.Instance = USB;</span><br><span class="line">hpcd_USB_FS.Init.dev_endpoints = 8;</span><br><span class="line">hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;</span><br><span class="line">hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;</span><br><span class="line">hpcd_USB_FS.Init.low_power_enable = DISABLE;</span><br><span class="line">hpcd_USB_FS.Init.lpm_enable = DISABLE;</span><br><span class="line">hpcd_USB_FS.Init.battery_charging_enable = DISABLE;</span><br><span class="line"></span><br><span class="line">//设备初始化</span><br><span class="line">if (HAL_PCD_Init(&amp;hpcd_USB_FS) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//DMA配置</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , 0x00 , PCD_SNG_BUF, 0x28);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , 0x80 , PCD_SNG_BUF, 0x80);</span><br><span class="line"></span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CUSTOM_HID_EPIN_ADDR , PCD_SNG_BUF, 0xc0);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CUSTOM_HID_EPOUT_ADDR , PCD_SNG_BUF, 0x100);</span><br><span class="line"></span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_IN_EP , PCD_SNG_BUF, 0x140);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_OUT_EP , PCD_SNG_BUF, 0x180);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_CMD_EP , PCD_SNG_BUF, 0x1c0);</span><br></pre></td></tr></table></figure>

<p>USB设备对象PCD_HandleTypeDef的定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141148488.png" alt="image-20240514114808440"></p>
<p>初始化完成后是USBD_RegisterClass和USBD_Start，结构类似不细讲。</p>
<p>最终通过HAL_PCD_Start返回的USBD_OK status确认初始化OK。</p>
<h2 id="MX-CAN-Init"><a href="#MX-CAN-Init" class="headerlink" title="MX_CAN_Init"></a>MX_CAN_Init</h2><p>目前o2link没使用MX_CAN_Init，代码为空</p>
<h2 id="MX-TIM6-Init"><a href="#MX-TIM6-Init" class="headerlink" title="MX_TIM6_Init"></a>MX_TIM6_Init</h2><p>关于timer有两点背景：</p>
<ol>
<li>hardware timer和systick(Cortex System Timer)的区别：</li>
</ol>
<p>从大概功能上看，都是计时器计数产生中断；</p>
<p>主要是应用上的区别：</p>
<p>a. systick精度一般是1ms，属于系统运行时就一直产生中断，生命周期不停的计时器；常用于应用层的ms_delay延时。</p>
<p>b. hardware timer精度可以达到us, ns，属于即用即停，单次运行的计时器；常用于硬件操作相关的，比如时序要求的us_delay延时。</p>
<ol start="2">
<li>STM32的hardware timer有几类：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141206215.png" alt="image-20240514120637192"></p>
<p>o2link只用到base timer 6. 以下讨论都是针对base timer 6</p>
<ol>
<li>timer的计时原理图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141407505.png" alt="image-20240514140729465"></p>
<ol start="2">
<li><p>timer的计时精度和最大时间</p>
<p>对timer模块时钟的分频决定精度：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TIME_BASE_1US 48</span><br><span class="line">#define TIME_BASE_100US 4800</span><br></pre></td></tr></table></figure>

<p> timer模块的时钟是48MHZ, 所以48分频为1us计时.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141409488.png" alt="image-20240514140933458"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">htim6.Init.Prescaler = Prescaler - 1; //分频后的时钟，决定每个counter计数的时间间隔</span><br><span class="line">htim6.Init.CounterMode = TIM_COUNTERMODE_UP; //counter累加模式</span><br><span class="line">htim6.Init.Period = 0xffff; //最大counter数：65535</span><br><span class="line">htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE; //counter满后自动reload计数</span><br></pre></td></tr></table></figure>

<p>o2link设置timer6的Prescaler &#x3D; 4800, 即100us&#x2F;count，最大时间是100us*65535，约6.5s。</p>
<p>o2link对timer6的应用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim6);</span><br><span class="line">while (one_wire_timer_counter_100US &lt; one_wire_parameter.sync_high_time)&#123;&#125;;</span><br><span class="line">HAL_TIM_Base_Stop_IT(&amp;htim6);</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">#define one_wire_timer_counter_100US (htim6.Instance-&gt;CNT * 100) // 转化成微秒</span><br></pre></td></tr></table></figure>

<h2 id="使能irq和systick"><a href="#使能irq和systick" class="headerlink" title="使能irq和systick"></a>使能irq和systick</h2><p>全部外设配置完毕，启动系统：</p>
<p>enable irq：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  \brief   Enable IRQ Interrupts</span><br><span class="line">  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.</span><br><span class="line">           Can only be executed in Privileged modes.</span><br><span class="line"> */</span><br><span class="line">__STATIC_FORCEINLINE void __enable_irq(void)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM volatile (&quot;cpsie i&quot; : : : &quot;memory&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enable systick：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void systime_init()</span><br><span class="line">&#123;</span><br><span class="line">  systime_tick.tick_ms = 0;</span><br><span class="line">  systime_tick.tick_10ms = 0;</span><br><span class="line">  systime_tick.tick_100ms = 0;</span><br><span class="line">  systime_tick.tick_sec = 0;</span><br><span class="line">  systime_tick.tick_min = 0;</span><br><span class="line">  systime_tick.tick_hour = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  @brief:    Start systick, including IRQ (TBD)</span><br><span class="line"> *        Used when system is powered on</span><br><span class="line"> *  @param:    None</span><br><span class="line"> *  @return:  None</span><br><span class="line"> */</span><br><span class="line">void systime_start(void)</span><br><span class="line">&#123;</span><br><span class="line">  SysTick-&gt;CTRL |= (SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="STM32–while-loop业务流程"><a href="#STM32–while-loop业务流程" class="headerlink" title="STM32–while loop业务流程"></a>STM32–while loop业务流程</h1><p>以下分析基于o2link firmware</p>
<p>while(1)的处理主要分为几大类：</p>
<ol>
<li>用systick更新应用时间</li>
<li>处理UART DMA的RX buffer的数据</li>
<li>处理USB下发的控制信号</li>
</ol>
<h2 id="systick管理时间"><a href="#systick管理时间" class="headerlink" title="systick管理时间"></a>systick管理时间</h2><p>这个目前没什么应用，仅用于LED闪烁；真实用户场景可能用到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">systime_update()：</span><br><span class="line">void systime_update(void)</span><br><span class="line">&#123;</span><br><span class="line">  if (systime_tick.tick_ms != HAL_GetTick())</span><br><span class="line">  &#123;</span><br><span class="line">    systime_tick.tick_ms = HAL_GetTick();</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_10MS) == (TICKRATE_10MS - 1))</span><br><span class="line">      systime_tick.tick_10ms++;</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_100MS) == (TICKRATE_100MS - 1))</span><br><span class="line">      systime_tick.tick_100ms++;</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_HZ) == (TICKRATE_HZ - 1))</span><br><span class="line">    &#123;</span><br><span class="line">      systime_tick.tick_sec++;</span><br><span class="line">      systime_tick.tick_min = (systime_tick.tick_sec / MIN_UNIT);</span><br><span class="line">      systime_tick.tick_hour = (systime_tick.tick_sec / HOUR_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理UART-RX的DMA数据"><a href="#处理UART-RX的DMA数据" class="headerlink" title="处理UART RX的DMA数据"></a>处理UART RX的DMA数据</h2><p>UART从RX的DMA buffer中返回给USB接口，有USB-HID和USB-CDC两种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">uart_data_analysis():</span><br><span class="line">void uart_data_analysis(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t len;</span><br><span class="line">	uint8_t usb_back_buf[64] = &#123;0&#125;; //USB的buffer</span><br><span class="line">	uint8_t *buffer = inter_buffer;</span><br><span class="line">	len = fifo_s_used(&amp;uart_rx_fifo); // 待发送数据长度</span><br><span class="line">	if (len &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fifo_s_gets(&amp;uart_rx_fifo, (char *)inter_buffer, len); //从FIFO取数据</span><br><span class="line">		if (cdc_receive_flag == 0) //no CDC,即HID模式</span><br><span class="line">		&#123;</span><br><span class="line">			while (len &gt; 0) //fifo取到数据？</span><br><span class="line">			&#123;</span><br><span class="line">				usb_back_buf[0] = 0x01; //见o2link spec, 0101 for UART</span><br><span class="line">				usb_back_buf[1] = 0x01;</span><br><span class="line">				//fifo取了60bytes是否还有多的？4bytes是USB加的header</span><br><span class="line">				if (len &gt; MAX_USB_UART_PACKET_NUM)</span><br><span class="line">				&#123;</span><br><span class="line">					usb_back_buf[2] = (MAX_USB_UART_PACKET_NUM &amp; 0xff00) &gt;&gt; 8;</span><br><span class="line">					usb_back_buf[3] = (MAX_USB_UART_PACKET_NUM &amp; 0x00ff);</span><br><span class="line">					memcpy(&amp;usb_back_buf[4], buffer, MAX_USB_UART_PACKET_NUM);</span><br><span class="line">					usb_send(usb_back_buf, USB_TIMEOUT_TIME);</span><br><span class="line">					len -= MAX_USB_UART_PACKET_NUM;</span><br><span class="line">					buffer += MAX_USB_UART_PACKET_NUM;</span><br><span class="line">				&#125;</span><br><span class="line">				else //fifo数据小于60bytes</span><br><span class="line">				&#123;</span><br><span class="line">					usb_back_buf[2] = (len &amp; 0xff00) &gt;&gt; 8;</span><br><span class="line">					usb_back_buf[3] = (len &amp; 0x00ff);</span><br><span class="line">					memcpy(&amp;usb_back_buf[4], buffer, len);</span><br><span class="line">					usb_send(usb_back_buf, USB_TIMEOUT_TIME);</span><br><span class="line">					len = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else //USB-CDC模式</span><br><span class="line">			CDC_Transmit_FS(inter_buffer, len, USB_TIMEOUT_TIME);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>USB-HID发送数据的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint8_t usb_send(uint8_t *send_data,uint32_t time_out)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t tickstart = 0U;</span><br><span class="line">	tickstart = HAL_GetTick();</span><br><span class="line">	</span><br><span class="line">	 while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(USBD_OK == USBD_CUSTOM_HID_SendReport(&amp;hUsbDeviceFS, send_data, USBD_CUSTOMHID_OUTREPORT_BUF_SIZE))</span><br><span class="line">			return USBD_OK;</span><br><span class="line">		if((HAL_GetTick() - tickstart) &gt; time_out)</span><br><span class="line">			return USB_SEND_TIMEOUT;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>USB Custom HID的实现在此不详细分析，参考固件库Sample code和 <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#CustomHID_Class">5.3.2.2 CustomHID Class</a></p>
<h3 id="USB-COMPOSITE设计"><a href="#USB-COMPOSITE设计" class="headerlink" title="USB COMPOSITE设计"></a>USB COMPOSITE设计</h3><p>为什么这里USB能同时支持HID和CDC两种方式？这里有USBD_COMPOSITE的概念：</p>
<p>USB设备初始化时，注册class是USBD_COMPOSITE类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USBD_RegisterClass(&amp;hUsbDeviceFS, &amp;USBD_COMPOSITE) != USBD_OK</span><br></pre></td></tr></table></figure>

<p>compisite指USB可以工作为不同设备类型，其描述符包含HID&#x2F;CDC多种模式：Middlewares\ST\STM32_USB_Device_Library\Class\usbd_composite.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">/* USB composite device Configuration Descriptor */</span><br><span class="line">/*   All Descriptors (Configuration, Interface, Endpoint, Class, Vendor */</span><br><span class="line">__ALIGN_BEGIN uint8_t USBD_Composite_CfgFSDesc[USBD_COMPOSITE_DESC_SIZE] __ALIGN_END =</span><br><span class="line">    &#123;</span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        /************** Descriptor of Custom HID interface ****************/</span><br><span class="line">        /* 09 */</span><br><span class="line">        0x09,                    /*bLength: Interface Descriptor size*/</span><br><span class="line">        USB_DESC_TYPE_INTERFACE, /*bDescriptorType: Interface descriptor type*/</span><br><span class="line">        USBD_HID_INTERFACE,      /*bInterfaceNumber: Number of Interface 接口编号 0 */</span><br><span class="line">        0x00,                    /*bAlternateSetting: Alternate setting  备用接口 */</span><br><span class="line">        0x02,                    /*bNumEndpoints 使用的端点数 1 */</span><br><span class="line">        0x03,                    /*bInterfaceClass: HID*/</span><br><span class="line">        0x00,                    /*bInterfaceSubClass : 1=BOOT, 0=no boot*/</span><br><span class="line">        0x00,                    /*nInterfaceProtocol : 0=none, 1=keyboard, 2=mouse*/</span><br><span class="line">        0,                       /*iInterface: Index of string descriptor*/</span><br><span class="line">        /******************** Descriptor of Custom HID ********************/</span><br><span class="line">        /* 18 */</span><br><span class="line">        0x09,                       /*bLength: HID Descriptor size*/</span><br><span class="line">        CUSTOM_HID_DESCRIPTOR_TYPE, /*bDescriptorType: HID*/</span><br><span class="line">        0x11,                       /*bcdHID: HID Class Spec release number*/</span><br><span class="line">        0x01,</span><br><span class="line">        0x00,                             /*bCountryCode: Hardware target country*/</span><br><span class="line">        0x01,                             /*bNumDescriptors: Number of HID class descriptors to follow*/</span><br><span class="line">        0x22,                             /*bDescriptorType*/</span><br><span class="line">        USBD_CUSTOM_HID_REPORT_DESC_SIZE, /*wItemLength: Total length of Report descriptor*/</span><br><span class="line">        0x00,</span><br><span class="line">        </span><br><span class="line">        /* 27 */</span><br><span class="line">        0x07,                   /*bLength: Endpoint Descriptor size*/</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT, /*bDescriptorType:*/</span><br><span class="line"></span><br><span class="line">        CUSTOM_HID_EPIN_ADDR, /*bEndpointAddress: Endpoint Address (IN)*/</span><br><span class="line">        0x03,                 /*bmAttributes: Interrupt endpoint*/</span><br><span class="line">        CUSTOM_HID_EPIN_SIZE, /*wMaxPacketSize: 16 Byte max */</span><br><span class="line">        0x00,</span><br><span class="line">        CUSTOM_HID_FS_BINTERVAL, /*bInterval: Polling Interval */</span><br><span class="line">        /* 34 */</span><br><span class="line"></span><br><span class="line">        0x07,                   /* bLength: Endpoint Descriptor size */</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT, /* bDescriptorType: */</span><br><span class="line">        CUSTOM_HID_EPOUT_ADDR,  /*bEndpointAddress: Endpoint Address (OUT)*/</span><br><span class="line">        0x03,                   /* bmAttributes: Interrupt endpoint */</span><br><span class="line">        CUSTOM_HID_EPOUT_SIZE,  /* wMaxPacketSize: 2 Bytes max  */</span><br><span class="line">        0x00,</span><br><span class="line">        CUSTOM_HID_FS_BINTERVAL, /* bInterval: Polling Interval */</span><br><span class="line">        /* 41 */</span><br><span class="line"></span><br><span class="line">        /****************************CDC************************************/</span><br><span class="line">        /* IAD描述符 */</span><br><span class="line">        /* Interface Association Descriptor */</span><br><span class="line">        USBD_IAD_DESC_SIZE,       // bLength</span><br><span class="line">        USBD_IAD_DESCRIPTOR_TYPE, // bDescriptorType</span><br><span class="line">        0x01,                     // bFirstInterface 接口描述符是在总的配置描述符中的第几个从0开始数 1</span><br><span class="line">        0x02,                     // bInterfaceCount 接口描述符数量 2</span><br><span class="line">        0x02,                     // bFunctionClass     CDC Control</span><br><span class="line">        0x02,                     // bFunctionSubClass  Abstract Control Model</span><br><span class="line">        0x01,                     // bInterfaceProtocol  AT Commands: V.250 etc</span><br><span class="line">        0x00,                     // iFunction</span><br><span class="line"></span><br><span class="line">        /* CDC命令接口描述符 */</span><br><span class="line">        /*Interface Descriptor */</span><br><span class="line">        0x09,                    /* bLength: Interface Descriptor size 长度 */</span><br><span class="line">        USB_DESC_TYPE_INTERFACE, /* bDescriptorType: Interface 接口编号0x04 */</span><br><span class="line">        /* Interface descriptor type */</span><br><span class="line">        USBD_CDC_CMD_INTERFACE, /* bInterfaceNumber: Number of Interface 接口编号，第一个接口编号为1 */</span><br><span class="line">        0x00,                   /* bAlternateSetting: Alternate setting 接口备用编号 0 */</span><br><span class="line">        0x01,                   /* bNumEndpoints: One endpoints used 非0端点的数目 1 cdc接口只使用了一个中断输入端点 */</span><br><span class="line">        0x02,                   /* bInterfaceClass: Communication Interface Class 接口所使用的类0x02 */</span><br><span class="line">        0x02,                   /* bInterfaceSubClass: Abstract Control Model 接口所使用的子类0x02 */</span><br><span class="line">        0x01,                   /* bInterfaceProtocol: Common AT commands 使用AT命令协议 */</span><br><span class="line">        0x00,                   /* iInterface: 接口字符串索引值 0表示没有 */</span><br><span class="line"></span><br><span class="line">        /* 类特殊接口描述符--功能描述符 用来描述接口的功能 */</span><br><span class="line">        /*Header Functional Descriptor*/</span><br><span class="line">        0x05, /* bLength: Endpoint Descriptor size 描述符长度为5字节 */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x00, /* bDescriptorSubtype: Header Func Desc 子类为 Header Func Desc，编号0x00 */</span><br><span class="line">        0x10, /* bcdCDC: spec release number CDC版本 */</span><br><span class="line">        0x01,</span><br><span class="line"></span><br><span class="line">        /*Call Management Functional Descriptor*/</span><br><span class="line">        0x05, /* bFunctionLength */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x01, /* bDescriptorSubtype: Call Management Func Desc 子类为Call Management Func Desc 编号0x01*/</span><br><span class="line">        0x00, /* bmCapabilities: D0+D1 设备自己不管理call management */</span><br><span class="line">        0x01, /* bDataInterface: 1 有一个数据类接口用作call management */</span><br><span class="line"></span><br><span class="line">        /*ACM Functional Descriptor*/</span><br><span class="line">        0x04, /* bFunctionLength */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x02, /* bDescriptorSubtype: Abstract Control Management desc 子类为Abstract Control Management desc编号0x02*/</span><br><span class="line">        0x02, /* bmCapabilities 支持Set_Control_Line_State、Get_Line_Coding请求和Serial_State通知*/</span><br><span class="line"></span><br><span class="line">        /*Union Functional Descriptor*/</span><br><span class="line">        0x05,                    /* bFunctionLength */</span><br><span class="line">        0x24,                    /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE */</span><br><span class="line">        0x06,                    /* bDescriptorSubtype: Union func desc 子类为Union func desc 编号0x06*/</span><br><span class="line">        USBD_CDC_CMD_INTERFACE,  /* bMasterInterface: Communication class interface 编号为1的CDC接口 */</span><br><span class="line">        USBD_CDC_DATA_INTERFACE, /* bSlaveInterface0: Data Class Interface 编号为2的数据类接口 */</span><br><span class="line"></span><br><span class="line">        /*Endpoint 2 Descriptor*/</span><br><span class="line">        0x07,                        /* bLength: Endpoint Descriptor size */</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */</span><br><span class="line">        CDC_CMD_EP,                  /* bEndpointAddress */</span><br><span class="line">        0x03,                        /* bmAttributes: Interrupt */</span><br><span class="line">        LOBYTE(CDC_CMD_PACKET_SIZE), /* wMaxPacketSize: */</span><br><span class="line">        HIBYTE(CDC_CMD_PACKET_SIZE),</span><br><span class="line">        CDC_FS_BINTERVAL, /* bInterval: */</span><br><span class="line">        /*---------------------------------------------------------------------------*/</span><br><span class="line">        .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如何选择工作模式：取决于上位机</p>
<p>如果上位机发送CDC数据，就使能CDC处理；否则默认是USB-HID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">USBD_CDC_ItfTypeDef USBD_CDC_Interface_fops_FS =</span><br><span class="line">&#123;</span><br><span class="line">  CDC_Init_FS,</span><br><span class="line">  CDC_DeInit_FS,</span><br><span class="line">  CDC_Control_FS,</span><br><span class="line">  CDC_Receive_FS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8_t cdc_receive_flag = 0;</span><br><span class="line">static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 6 */</span><br><span class="line">  USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[0]);</span><br><span class="line">  USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);</span><br><span class="line">  cdc_receive_flag = 1;</span><br><span class="line">  // 注意这里是中断回调，串口函数有锁</span><br><span class="line">  HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;Buf[0],*Len,UART_TIMEOUT_TIME);</span><br><span class="line">  return (USBD_OK);</span><br><span class="line">  /* USER CODE END 6 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理USB下发的控制信号"><a href="#处理USB下发的控制信号" class="headerlink" title="处理USB下发的控制信号"></a>处理USB下发的控制信号</h2><p>USB HID下发信号的处理函数是CUSTOM_HID_OutEvent_FS：</p>
<p>USB中断传输方式中，每次PC机发送数据后USB设备都会产生中断，设备每完成一次从PC机的Out data的接收都会响应一次OutEvent，因此可以通过修改usbd_custom_hid_if.c中的static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)来实现对接收到数据做处理。实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">USBD_CUSTOM_HID_ItfTypeDef USBD_CustomHID_fops_FS =</span><br><span class="line">&#123;</span><br><span class="line">  CUSTOM_HID_ReportDesc_FS,</span><br><span class="line">  CUSTOM_HID_Init_FS,</span><br><span class="line">  CUSTOM_HID_DeInit_FS,</span><br><span class="line">  CUSTOM_HID_OutEvent_FS //接收数据回调</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)</span><br><span class="line">&#123;</span><br><span class="line">	uint16_t command ;</span><br><span class="line"></span><br><span class="line">    USB_Received_Count = USBD_GetRxCount( &amp;hUsbDeviceFS,CUSTOM_HID_EPOUT_ADDR );</span><br><span class="line">    </span><br><span class="line">    USBD_CUSTOM_HID_HandleTypeDef   *hhid; </span><br><span class="line">    hhid = pHIDData;</span><br><span class="line">    </span><br><span class="line">    //copy和解析</span><br><span class="line">	memcpy(usb_send_buf, hhid-&gt;Report_buf, USB_Received_Count);</span><br><span class="line">	command = usb_send_buf[0] &lt;&lt; 8 | usb_send_buf[1];</span><br><span class="line">	//这里做了个流程区分：如果是USB to UART则调用uart write流程；其他控制信号仅设置计数+1.</span><br><span class="line">	if(command ==WRITE_UART_FUNCITON)</span><br><span class="line">		write_uart_function();</span><br><span class="line">	else</span><br><span class="line">		usb_flag++;</span><br><span class="line">			</span><br><span class="line">  return (USBD_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MCU的while(1)处理usb_flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(1):</span><br><span class="line">	if (usb_flag)</span><br><span class="line">		&#123;</span><br><span class="line">			usb_flag--;</span><br><span class="line">			usb_handle_process();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>usb_handle_process就是对USB buffer的64byte解析并分发到各处理函数，基本实现IO control的机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void usb_handle_process(void)</span><br><span class="line">&#123;</span><br><span class="line">	command = usb_send_buf[0] &lt;&lt; 8 | usb_send_buf[1];</span><br><span class="line">	length = usb_send_buf[2] &lt;&lt; 8 | usb_send_buf[3];</span><br><span class="line"></span><br><span class="line">	switch (command)</span><br><span class="line">	&#123;</span><br><span class="line">	case UART_PARAMETER_SET:</span><br><span class="line">		uart_parameter_setting();</span><br><span class="line">		break;</span><br><span class="line">	case UART_PIN_LOW_SET:</span><br><span class="line">		uart_pin_low_set();</span><br><span class="line">		break;</span><br><span class="line">	case USB_TO_SPI_FUNCTION:</span><br><span class="line">		usb_to_spi_convert();</span><br><span class="line">		break;</span><br><span class="line">	case USB_TO_SPI_PARAMETER_SET:</span><br><span class="line">		spi_parameter_setting();</span><br><span class="line">		break;</span><br><span class="line">	....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不详细分析各switch case的内容，基本操作都是将usb_send_buf数据，通过SPI&#x2F;UART&#x2F;I2C….透传到MCU下游的芯片. </p>
<p>TODO：为什么UART write需要特殊处理，而不用usb_handle_process分发处理？</p>
<p>因为UART TX没有buffer，如果MCU收到UART write而不立即启动TX传输，上位机的USB 64bytes buffer可能被新的TX data覆盖掉？或者上位机有超时机制？</p>
<p>usb_handle_process只挑几个典型流程分析：</p>
<h3 id="jump-to-boot"><a href="#jump-to-boot" class="headerlink" title="jump_to_boot"></a>jump_to_boot</h3><p>这个用于MCU上直接升级Firmware（IAP）用到，目前开发阶段还没应用，以后用户升级可能用到。</p>
<p>使用函数指针，用调用函数的形式跳转到JumpAddress（0x08000004），即中断向量表的RESET入口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define BOOT_ADDR 0x08000000</span><br><span class="line">typedef void (*pFunction)(void);</span><br><span class="line"></span><br><span class="line">void jump_to_boot(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	uint32_t JumpAddress;</span><br><span class="line">	pFunction Jump_To_Application;</span><br><span class="line"></span><br><span class="line">	usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">	HAL_Delay(10);</span><br><span class="line">	__disable_irq();</span><br><span class="line"></span><br><span class="line">	JumpAddress = *(__IO uint32_t *)(BOOT_ADDR + 4);</span><br><span class="line">	Jump_To_Application = (pFunction)JumpAddress;</span><br><span class="line"></span><br><span class="line">	__HAL_RCC_SYSCFG_CLK_ENABLE();</span><br><span class="line">	__HAL_REMAPMEMORY_FLASH();</span><br><span class="line">	/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">	__set_MSP(*(__IO uint32_t *)BOOT_ADDR);</span><br><span class="line">	*(uint32_t *)RAM_FROM_APP_FLAG_ADDR = RAM_FROM_APP_FLAG_DATA; // jump</span><br><span class="line">	Jump_To_Application();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uart-pin-low"><a href="#uart-pin-low" class="headerlink" title="uart_pin_low"></a>uart_pin_low</h3><p>此功能是BMS业务的流程，BMS chip的wakeup操作使用RX pin，拉低UART TX为低并保持一段时间，再拉高TX，形成BMS chip的wakeup。</p>
<p>注意这里不是为了形成UART break frame（也是RX拉低，保持一个byte的周期，再拉高），所以UART RX pin需要先析构，在GPIO模式下才能无UART协议干扰的产生BMS wakeup信号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void jaguar_uart_pin_low_fun(uint32_t ustimer)</span><br><span class="line">&#123;</span><br><span class="line">	MX_TIM6_Init(TIME_BASE_1US); //timer 1us精度</span><br><span class="line">	UART2_DeInit(); //uart2析构</span><br><span class="line">	jaguar_uart_gpio_fun(); //设置PA2,PA3为高，即UART的RX/TX pin</span><br><span class="line"></span><br><span class="line">	HAL_TIM_Base_Start_IT(&amp;htim6); //开始计时</span><br><span class="line">	jaguar_wire_pin_low(); //设置PA2（TX）为低</span><br><span class="line">	while (one_wire_timer_counter_1US &lt; ustimer) //ustimer来自USB-HID数据</span><br><span class="line">	&#123;</span><br><span class="line">		// printf(&quot;sync low tim:%d \r\n&quot;,one_wire_timer_counter100US);</span><br><span class="line">	&#125;;</span><br><span class="line">	jaguar_wire_pin_high(); //设置PA2（TX）为高</span><br><span class="line">	HAL_TIM_Base_Stop_IT(&amp;htim6); //结束计时</span><br><span class="line">	//设置波特率，这里如果UART之前设置过，就保持原值；否则默认值1M波特率</span><br><span class="line">	if (saved_baudrate != 0)</span><br><span class="line">		MX_USART2_UART_Init(saved_baudrate); // keep the baudrate(set by USB-HID uart-config command).</span><br><span class="line">	else</span><br><span class="line">		MX_USART2_UART_Init(1000000); // reset baud rate.</span><br><span class="line">	Rx_buf_pos = 0;</span><br><span class="line">	MX_TIM6_Init(TIME_BASE_100US);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usb-to-spi"><a href="#usb-to-spi" class="headerlink" title="usb_to_spi"></a>usb_to_spi</h3><p>前面没有详细分析SPI的传输，此处分析。</p>
<p>o2link spec定义的USB to SPI数据包格式：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141701291.png" alt="image-20240514170141237"></p>
<p>SPI数据通信的原理：</p>
<p>SPI一般设置为全双工双向通信，利用移位register交换master&#x2F;slave两端的数据register(FIFO)里的数据。</p>
<p>全双工时，SPI不存在单向的发送或单向的接收，数据一定是“交换”的。firmware的关注点是用RX register发数据，还是从Tx register拿数据。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141715633.png" alt="image-20240514171557572"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141705044.png" alt="image-20240514170528006"></p>
<p>代码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void usb_to_spi_convert(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t recive_buf[SPI_MAX_DATA_NUM] = &#123;0&#125;;</span><br><span class="line">	uint8_t ret = 0;</span><br><span class="line"></span><br><span class="line">	if (usb_send_buf[SPI_LENGTH_SITE] &gt; 60)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = SPI_INVALID_PARAMETER;</span><br><span class="line">		usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//按o2link spec解析为SPI命令参数和数据，数据内容决定对下层DFE芯片register是读还是写</span><br><span class="line">	ret = usb_spi_convert_data(usb_send_buf[SPI_CHIPID_SITE], usb_send_buf[SPI_LENGTH_SITE], &amp;usb_send_buf[SPI_DATA_SITE], recive_buf);</span><br><span class="line">	if (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = ret;</span><br><span class="line">	&#125;</span><br><span class="line">	//按o2link spec解析出返回数据</span><br><span class="line">	memcpy(&amp;usb_send_buf[SPI_DATA_SITE], recive_buf, usb_send_buf[SPI_LENGTH_SITE]);</span><br><span class="line">	usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint8_t usb_spi_convert_data(uint8_t dev_id,uint8_t data_num,uint8_t * write_buf,uint8_t *read_buf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    uint8_t ret = 0;</span><br><span class="line">    </span><br><span class="line">    //拉低CS片选</span><br><span class="line">    HAL_GPIO_WritePin(spi_gpio_cs_pins[dev_id].gpio_base,spi_gpio_cs_pins[dev_id].gpio_pin,GPIO_PIN_RESET);</span><br><span class="line">	//启动SPI传输</span><br><span class="line">    ret = HAL_SPI_TransmitReceive(&amp;hspi1, write_buf, read_buf, data_num ,SPI_TIMEOUT_TIME);</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_WritePin(spi_gpio_cs_pins[dev_id].gpio_base,spi_gpio_cs_pins[dev_id].gpio_pin,GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPI传输的8bit模式具体内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_TransmitReceive():</span><br><span class="line"></span><br><span class="line">hspi-&gt;pRxBuffPtr  = (uint8_t *)pRxData; //RX buffer的指针</span><br><span class="line">hspi-&gt;RxXferCount = Size;</span><br><span class="line">hspi-&gt;RxXferSize  = Size;</span><br><span class="line">hspi-&gt;pTxBuffPtr  = (uint8_t *)pTxData; //TX buffer的指针</span><br><span class="line">hspi-&gt;TxXferCount = Size;</span><br><span class="line">hspi-&gt;TxXferSize  = Size;</span><br><span class="line"></span><br><span class="line">/* Enable SPI peripheral */</span><br><span class="line">__HAL_SPI_ENABLE(hspi);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">/* Transmit and Receive data in 8 Bit mode */</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    while ((hspi-&gt;TxXferCount &gt; 0U) || (hspi-&gt;RxXferCount &gt; 0U))</span><br><span class="line">    &#123;</span><br><span class="line">      /* Check TXE flag */</span><br><span class="line">      //SPI_FLAG_TXE: SPI status flag: Tx buffer empty flag, 表示当前TX FIFO数据为空，可能是首次启动还没填数据或上次已传完</span><br><span class="line">      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) &amp;&amp; (hspi-&gt;TxXferCount &gt; 0U) &amp;&amp; (txallowed == 1U))</span><br><span class="line">      &#123;</span><br><span class="line">       // DR: SPI data register, 按uint8（byte）填数据</span><br><span class="line">        *(__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR = (*hspi-&gt;pTxBuffPtr);</span><br><span class="line">        //更新数据指针(准备下次传输)</span><br><span class="line">        hspi-&gt;pTxBuffPtr++;</span><br><span class="line">        hspi-&gt;TxXferCount--;</span><br><span class="line">        /* Next Data is a reception (Rx). Tx not allowed */</span><br><span class="line">        //处理完TX，下面必须处理RX</span><br><span class="line">        txallowed = 0U;</span><br><span class="line">        </span><br><span class="line">        /* Wait until RXNE flag is reset */</span><br><span class="line">        //SPI_FLAG_RXNE: Rx buffer not empty flag, 有收到数据待处理</span><br><span class="line">          if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) &amp;&amp; (hspi-&gt;RxXferCount &gt; 0U))</span><br><span class="line">          &#123;</span><br><span class="line">          	//从DR register取数据到RX buffer</span><br><span class="line">            (*(uint8_t *)hspi-&gt;pRxBuffPtr) = *(__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR;</span><br><span class="line">            hspi-&gt;pRxBuffPtr++;</span><br><span class="line">            hspi-&gt;RxXferCount--;</span><br><span class="line">            /* Next Data is a Transmission (Tx). Tx is allowed */</span><br><span class="line">            //处理完RX，下一轮必须处理TX</span><br><span class="line">            txallowed = 1U;</span><br><span class="line">          &#125;</span><br><span class="line">          //超时判断</span><br><span class="line">          if ((((HAL_GetTick() - tickstart) &gt;=  Timeout) &amp;&amp; ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))</span><br><span class="line">          &#123;</span><br><span class="line">            errorcode = HAL_TIMEOUT;</span><br><span class="line">            goto error;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TX RX处理的判断标准是读SR register状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** @brief  Check whether the specified SPI flag is set or not.</span><br><span class="line">  * @param  __HANDLE__ specifies the SPI Handle.</span><br><span class="line">  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.</span><br><span class="line">  * @param  __FLAG__ specifies the flag to check.</span><br><span class="line">  *         This parameter can be one of the following values:</span><br><span class="line">  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag</span><br><span class="line">  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag</span><br><span class="line">  *            @arg SPI_FLAG_CRCERR: CRC error flag</span><br><span class="line">  *            @arg SPI_FLAG_MODF: Mode fault flag</span><br><span class="line">  *            @arg SPI_FLAG_OVR: Overrun flag</span><br><span class="line">  *            @arg SPI_FLAG_BSY: Busy flag</span><br><span class="line">  *            @arg SPI_FLAG_FRE: Frame format error flag</span><br><span class="line">  *            @arg SPI_FLAG_FTLVL: SPI fifo transmission level</span><br><span class="line">  *            @arg SPI_FLAG_FRLVL: SPI fifo reception level</span><br><span class="line">  * @retval The new state of __FLAG__ (TRUE or FALSE).</span><br><span class="line">  */</span><br><span class="line">#define __HAL_SPI_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)-&gt;Instance-&gt;SR) &amp; (__FLAG__)) == (__FLAG__))</span><br></pre></td></tr></table></figure>

<p>为什么SPI传输TX，RX是同时又交替的处理数据：</p>
<p>SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</p>
<p>因此HAL_SPI_TransmitReceive()同时处理RX和TX，和UART的RX&#x2F;TX单向传输不同。</p>
<p>​	</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89EDK2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89EDK2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">UEFI开发（一）EDK2环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:27:38" itemprop="dateModified" datetime="2025-11-04T17:27:38+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UEFI%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">UEFI开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UEFI开发（一）EDK2环境搭建"><a href="#UEFI开发（一）EDK2环境搭建" class="headerlink" title="UEFI开发（一）EDK2环境搭建"></a>UEFI开发（一）EDK2环境搭建</h1><p>官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-with-EDK-II">https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-with-EDK-II</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-User-Documentation">https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-User-Documentation</a></p>
<h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>参考：<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2?tab=readme-ov-file#submodules">edk2&#x2F;Submodules</a></p>
<p>在C盘根目录用git命令下载edk2并下载submodule：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tianocore/edk2.git</span><br><span class="line">cd edk2</span><br><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure>

<p>如果要切换到stable tag版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -l #列出tag， -l: list</span><br><span class="line">git checkout edk2-stable202X0X #切table tag</span><br><span class="line">git submodule update #更新submodule（对应stable tag）</span><br></pre></td></tr></table></figure>

<p>我的环境是VS2022，当前edk2 master主线支持VS2022，而最新的stable tag不支持，所以用master版本，没必要checkout到stable tag。</p>
<h2 id="编译EDK2"><a href="#编译EDK2" class="headerlink" title="编译EDK2"></a>编译EDK2</h2><h3 id="编译环境准备"><a href="#编译环境准备" class="headerlink" title="编译环境准备"></a>编译环境准备</h3><p>参考：<a target="_blank" rel="noopener" href="https://github.com/tianocore/tianocore.github.io/wiki/Windows-systems">https://github.com/tianocore/tianocore.github.io/wiki/Windows-systems</a></p>
<ol>
<li><p>按 <a href="edk2%5CBaseTools%5CBin"><strong>Build</strong></a> 下载NASM和ASL二进制包，放到C盘跟&#x3D;根目录（和edk2同路径）</p>
</li>
<li><p>运行edksetup.bat，编译edk2&#x2F;BaseTool</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">C:\edk2&gt;edksetup.bat</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">** Visual Studio 2022 Developer Command Prompt v17.13.6</span><br><span class="line">** Copyright (c) 2022 Microsoft Corporation</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">[vcvarsall.bat] Environment initialized for: &#x27;x86&#x27;</span><br><span class="line">Using EDK2 in-source Basetools</span><br><span class="line">          PATH      = C:\edk2\BaseTools\BinWrappers\WindowsLike;D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\HostX86\x86;D:\Program Files\Microsoft Visual .... Studio\2022\Community\Common7\IDE\VC\Linux\bin\ConnectionManagerExe;D:\Program Files\Microsoft Visual Studio\2022\Community\VC\vcpkg</span><br><span class="line"></span><br><span class="line">     WORKSPACE      = C:\edk2</span><br><span class="line"></span><br><span class="line">EDK_TOOLS_PATH      = C:\edk2\BaseTools</span><br><span class="line">BASE_TOOLS_PATH     = C:\edk2\BaseTools</span><br><span class="line"> EDK_TOOLS_BIN      = C:\edk2\BaseTools\Bin\Win32</span><br><span class="line">     CONF_PATH      = C:\edk2\Conf</span><br><span class="line">     PYTHON_COMMAND = py -3</span><br><span class="line">         PYTHONPATH = C:\edk2\BaseTools\Source\Python;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!!! WARNING !!! NASM_PREFIX environment variable is not set</span><br><span class="line">  Found nasm.exe, setting the environment variable to C:\nasm\</span><br><span class="line"></span><br><span class="line">!!! WARNING !!! CLANG_BIN environment variable is not set</span><br></pre></td></tr></table></figure>

<p>log中的一些信息含义：</p>
<p>（1）新版本edk2已经包含python包，无需自己再去下载和指定python路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYTHONPATH = C:\edk2\BaseTools\Source\Python;</span><br></pre></td></tr></table></figure>

<p>（2）已自动设置nasm路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found nasm.exe, setting the environment variable to C:\nasm\</span><br></pre></td></tr></table></figure>

<p>（3）用VS2022编译，CLANG_BIN不用设置</p>
<p>编译输出二进制在edk2\BaseTools\Bin</p>
<h3 id="编译目标模块"><a href="#编译目标模块" class="headerlink" title="编译目标模块"></a>编译目标模块</h3><p>运行edksetup后，再执行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build</span><br></pre></td></tr></table></figure>

<p>编译目标由edk2&#x2F;Conf&#x2F;target.txt的ACTIVE_PLATFORM和TARGET_ARCH指定</p>
<h3 id="终端乱码问题"><a href="#终端乱码问题" class="headerlink" title="终端乱码问题"></a>终端乱码问题</h3><p>在编译前可用以下命令将命令行的输出转成UTF8格式，防止输出乱码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure>

<p>下图说明从Conf&#x2F;target的产生到编译完成的全流程</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504141429251.png" alt="image-20250414142907112"></p>
<h2 id="搭建UEFI-shell启动盘"><a href="#搭建UEFI-shell启动盘" class="headerlink" title="搭建UEFI shell启动盘"></a>搭建UEFI shell启动盘</h2><h3 id="创建UEFI-shell盘"><a href="#创建UEFI-shell盘" class="headerlink" title="创建UEFI shell盘"></a>创建UEFI shell盘</h3><ol>
<li>找一个U盘，格式化成FAT32，然后在U盘根目录下建立&#x2F;efi&#x2F;boot目录。</li>
<li>自己编译UEFI shell.efi或者下载Shell.efi</li>
<li>把Shell.efi改名成BOOTX64.efi，然后把BOOTX64.efi拷贝到U盘&#x2F;efi&#x2F;boot&#x2F;目录下。</li>
<li>自己编译的其他UEFI程序，如MdeModulePkg Application efi或者DXE efi驱动，都可放到U盘根目录</li>
<li>U盘插入电脑，开机后按F12(不同厂商电脑可能有所不同)进入UEFI menu选择页面，选择从U盘启动</li>
</ol>
<p>(1) 如何自己编译UEFI shell.efi：</p>
<p>前面edk2编译环境ok后，改Conf&#x2F;target.txt为编译ShellPkg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACTIVE_PLATFORM       = ShellPkg/ShellPkg.dsc</span><br><span class="line">TARGET_ARCH           = X64</span><br><span class="line">TOOL_CHAIN_TAG        = VS2019</span><br></pre></td></tr></table></figure>

<p>编译完成后输出Shell.efi在Build&#x2F;Shell&#x2F;<TOOL_CHAIN_TAG>&#x2F;<TARGET_ARCH>&#x2F;ShellPkg&#x2F;Application&#x2F;Shell&#x2F;Shell&#x2F;OUTPUT&#x2F;目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Finished generating code</span><br><span class="line">        &quot;GenFw&quot; -e UEFI_APPLICATION -o C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\OUTPUT\Shell.efi C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\DEBUG\Shell.dll</span><br><span class="line">        copy /y C:\edk2\Build\Shell\DEBUG_VS2019\X64\ShellPkg\Application\Shell\Shell\OUTPUT\Shell.efi </span><br><span class="line"></span><br><span class="line">- Done -</span><br></pre></td></tr></table></figure>

<p>(2)下载编译好的Shell.efi</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pbatard/UEFI-Shell/releases">https://github.com/pbatard/UEFI-Shell/releases</a></p>
<p>包含各平台的shell.efi</p>
<h3 id="startup-nsh脚本"><a href="#startup-nsh脚本" class="headerlink" title="startup.nsh脚本"></a>startup.nsh脚本</h3><p>UEFI Shell.efi启动时会查找根目录下有没有startup.nsh脚本，如果有的话会自动执行startup.nsh脚本</p>
<p>比如U盘在UEFI shell下的盘符为 FS0: ，想要启动自动执行根目录的myUefiApp.efi程序，startup.nsh脚本如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#切换到FS0盘符的根目录</span><br><span class="line">FS0:</span><br><span class="line">#执行程序（预先放在根目录）</span><br><span class="line">MyUefiApp.efi</span><br></pre></td></tr></table></figure>

<p>也可以用绝对路径执行MyUefiApp.efi，即 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FS0:\MyUefiApp.efi</span><br></pre></td></tr></table></figure>

<h3 id="进入UEFI-shell"><a href="#进入UEFI-shell" class="headerlink" title="进入UEFI shell"></a>进入UEFI shell</h3><p>如图是F12进入U盘UEFI shell环境，其中：</p>
<p>UEFI shell版本v2.7，可见来源信息</p>
<p>map -r显示可识别设备信息：</p>
<ol>
<li><p>FS是filesystem文件系统设备。FS0是USB设备，位于PCi bridge 0x14上；FS1是Sata硬盘，位于PCi bridge 0x17上</p>
</li>
<li><p>BLK是文件分区。BLK0是USB的分区，BLK2和4都是Sata硬盘的文件分区</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202504161706334.png" alt="image-20250416170607057"></p>
<h3 id="copy-startup加快测试"><a href="#copy-startup加快测试" class="headerlink" title="copy+startup加快测试"></a>copy+startup加快测试</h3><p><a target="_blank" rel="noopener" href="https://ss64.com/nt/xcopy.html">https://ss64.com/nt/xcopy.html</a></p>
<p>调试efi经常要重新编译和拷贝efi到u盘，用copy命令自动化</p>
<p>build编译模块时，输出的efi已经拷贝过一次。这里再创建一个.bat拷到u盘（E盘根目录）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy /y C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\SdMmcPciHcDxe\OUTPUT\SdMmcPciHcDxe.efi C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\SdMmcPciHcDxe.efi</span><br><span class="line"></span><br><span class="line">copy /y C:\edk2\Build\MdeModule\DEBUG_VS2019\X64\SdMmcPciHcDxe.efi E:\</span><br></pre></td></tr></table></figure>

<p>这样编译后自动拷贝到U盘，在UEFI测试机上创建startup.sh自动运行efi驱动加载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs0:</span><br><span class="line">load SdMmcPciHcDxe.efi</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%E7%9F%A5%E8%AF%86%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%E7%9F%A5%E8%AF%86%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">UEFI开发（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-08-30T17:52:38+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-04 17:27:26" itemprop="dateModified" datetime="2025-11-04T17:27:26+08:00">2025-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UEFI%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">UEFI开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UEFI开发（二）"><a href="#UEFI开发（二）" class="headerlink" title="UEFI开发（二）"></a>UEFI开发（二）</h1><h2 id="Library库"><a href="#Library库" class="headerlink" title="Library库"></a>Library库</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45279063/article/details/115324601">https://blog.csdn.net/weixin_45279063/article/details/115324601</a></p>
<p>以后面要用到的DEBUG库为例：</p>
<p>库的调用方是MdeModulePkg下的某个INF模块，被调用方是MdePkg库（这个属于基础库很常用）</p>
<ol>
<li>调用方的INF中要导入库模块的dec和要用到的LibraryClasses</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Packages]</span><br><span class="line">  MdePkg/MdePkg.dec #这里包含了库模块MdePkg的dec声明，获取到MdePkg所有对外开放的库接口</span><br><span class="line">  MdeModulePkg/MdeModulePkg.dec #这是调用方模块</span><br><span class="line"></span><br><span class="line">[LibraryClasses]</span><br><span class="line">  DevicePathLib</span><br><span class="line">  UefiBootServicesTableLib</span><br><span class="line">  UefiRuntimeServicesTableLib</span><br><span class="line">  MemoryAllocationLib</span><br><span class="line">  BaseMemoryLib</span><br><span class="line">  UefiLib</span><br><span class="line">  BaseLib</span><br><span class="line">  UefiDriverEntryPoint</span><br><span class="line">  DebugLib #这里导入了MdePkg库的DebugLib类（头文件），类似其他语言的import或者include namespace</span><br><span class="line">  PcdLib</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用方的c代码中可以直接include库的头文件（不需要用相对地址包含头文件）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Library/DebugLib.h&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用方使用库的函数体DEBUG();</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG((DEBUG_INFO, &quot;Initializing XXX controller in slot %d\n&quot;, Slot));</span><br><span class="line"></span><br><span class="line">Status = InitController(PciIo, Slot);</span><br><span class="line">if (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG((DEBUG_ERROR, &quot;Failed to switch Host to PCIe mode: %r\n&quot;, Status));</span><br><span class="line">    return Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DEBUG打印"><a href="#DEBUG打印" class="headerlink" title="DEBUG打印"></a>DEBUG打印</h2><p><a target="_blank" rel="noopener" href="https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging">https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging</a></p>
<p>在使用DEBUG INFO的MdeModulePkg模块的dsc中，声明DEBUG库的全局变量PcdDebugPropertyMask和PcdDebugPrintErrorLevel，指定支持INFO级别打印，否则默认只会打印DEBUG(ERROR)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[PcdsFixedAtBuild]</span><br><span class="line"># refer to https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Debugging</span><br><span class="line">  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x0f</span><br><span class="line">  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x80000040</span><br></pre></td></tr></table></figure>

<p>再编译MdeModulePkg inf，输出的efi可见INFO级别的打印生效。</p>
<h2 id="UTF8中文报错"><a href="#UTF8中文报错" class="headerlink" title="UTF8中文报错"></a>UTF8中文报错</h2><p>问题log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\edk2\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\BayhubHost.h(1): error C2220: the following warning is treated as an error</span><br><span class="line">C:\edk2\MdeModulePkg\Bus\Pci\SdMmcPciHcDxe\BayhubHost.h(1): warning C4819: The file contains a character that cannot be represented in the current code page (936). Save the file in Unicode format to prevent data loss</span><br></pre></td></tr></table></figure>

<p>错误信息指出：<br>警告C4819被当作错误处理<br>文件包含无法在当前代码页(936，即中文GBK编码)中表示的字符</p>
<p>解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用Notepad++重新保存文件:</span><br><span class="line">打开文件，编码选择&quot;UTF-8 with signature (UTF-8-BOM)&quot;或者&quot;UTF-8&quot;</span><br><span class="line">保存文件</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件有非ASCII字符（特别是在注释中）</span><br><span class="line">有时文件的首行可能有不可见的BOM（字节顺序标记）或其他特殊字符</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cursorhu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cursorhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cursorhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2449055512@qq.com" title="E-Mail → mailto:2449055512@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cursorhu</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
