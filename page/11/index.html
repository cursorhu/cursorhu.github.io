<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/my_icon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/my_icon/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/my_icon/manifest.json">
  <meta name="msapplication-config" content="/images/my_icon/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ThinkNotes">
<meta property="og:url" content="https://cursorhu.github.io/page/11/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cursorhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cursorhu.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy       化繁为简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/NodeJs%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8pm2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">NodeJs笔记：使用pm2部署项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 14:25:24" itemprop="dateCreated datePublished" datetime="2020-05-20T14:25:24+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJs/" itemprop="url" rel="index"><span itemprop="name">NodeJs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>nodejs服务可以用<code>nohup node xxx.js &amp;</code>后台启动，但是实际使用发现不太稳定，使用专门的node后台服务管理工具：pm2解决此问题</p>
<h1 id="pm2特性"><a href="#pm2特性" class="headerlink" title="pm2特性"></a>pm2特性</h1><p>1、内建负载均衡（使用Node cluster 集群模块）<br>2、后台运行<br>3、0秒停机重载<br>4、具有Ubuntu和CentOS 的启动脚本<br>5、停止不稳定的进程（避免无限循环）<br>6、控制台检测<br>7、提供 HTTP API<br>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p>
<h1 id="pm2安装"><a href="#pm2安装" class="headerlink" title="pm2安装"></a>pm2安装</h1><pre><code>npm install -g pm2
</code></pre>
<h1 id="pm2用法"><a href="#pm2用法" class="headerlink" title="pm2用法"></a>pm2用法</h1><pre><code>pm2 start app.js        //启动进程
pm2 start app.js -i 4   // 后台运行pm2，启动4个app.js
pm2 start app.js -i max //启动，使用所有CPU核心
pm2 start app.js --name my-api // 命名进程
pm2 list               // 显示所有进程状态
pm2 monit              // 监视所有进程
pm2 logs               //  显示所有进程日志
pm2 stop all           // 停止所有进程
pm2 restart all        // 重启所有进程
pm2 reload all         // 0秒停机重载进程 (用于 NETWORKED 进程)
pm2 stop 0             // 停止指定的进程
pm2 restart 0          // 重启指定的进程
pm2 startup            // 产生 init 脚本 保持进程活着
pm2 web                // 运行健壮的 computer API endpoint 
pm2 delete 0           // 杀死指定的进程
pm2 delete all         // 杀死全部进程
</code></pre>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>部署Github项目NodeMail，每天给指定邮箱发邮件。</p>
<p>后台启动main.js并监测状态：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427417.png" alt="image-20221206142729375"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427110.png" alt="image-20221206142743066"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061427682.png" alt="image-20221206142752627"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061428280.png" alt="image-20221206142800236"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/Linux-Shell%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if-then-else-fi/" class="post-title-link" itemprop="url">Linux Shell笔记：判断语句if-then-else-fi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-05 14:46:30" itemprop="dateCreated datePublished" datetime="2020-05-05T14:46:30+08:00">2020-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>shell中if-then-else-fi判断语句如下：</p>
<pre><code>a=&quot;abc&quot;

if [ $a = &quot;abc&quot; ]
then
   echo &quot;$a = $b&quot;
else
   echo &quot;$a != $b&quot;
fi
</code></pre>
<p>注意以下几点：</p>
<ul>
<li>shell中的等号：<code>=</code>可用于赋值，也可以用于判断；<code>==</code>只用于判断，更规范</li>
<li>shell中的if语句各符号间都要空格分隔：<code>if</code>和<code>[ ]</code>之间要空格；<code>[ ]</code>和<code>“ ”</code>之间要空格； <code>&quot;</code>和<code>=</code>之间要空格。否则if语句中的符号会解析失败。</li>
<li>shell变量没有数据类型的区分，把任何存储在变量中的值，皆视为“字符串”</li>
<li>对于变量可能为空的情况，需要用双括号<code>[[ $a = &quot;abc&quot; ]]</code></li>
<li>if-then可以写在同一行，用;分隔两个语句：<code>if [ $a = &quot;abc&quot; ];then</code></li>
</ul>
<h1 id="不同类型的判断语句"><a href="#不同类型的判断语句" class="headerlink" title="不同类型的判断语句"></a>不同类型的判断语句</h1><h2 id="关系运算符判断"><a href="#关系运算符判断" class="headerlink" title="关系运算符判断"></a>关系运算符判断</h2><p>-eq	检测两个数是否相等，相等返回 true。	[ $a -eq $b ] 返回 false。</p>
<p>-ne	检测两个数是否不相等，不相等返回 true。	[ $a -ne $b ] 返回 true。</p>
<p>-gt	检测左边的数是否大于右边的，如果是，则返回 true。	[ $a -gt $b ] 返回 false。</p>
<p>-lt	检测左边的数是否小于右边的，如果是，则返回 true。	[ $a -lt $b ] 返回 true。</p>
<p>-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 返回 false。</p>
<p>-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 返回 true。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre>
<h2 id="布尔和逻辑运算符判断"><a href="#布尔和逻辑运算符判断" class="headerlink" title="布尔和逻辑运算符判断"></a>布尔和逻辑运算符判断</h2><p>!	非运算，表达式为 true 则返回 false，否则返回 true。	[ ! false ] 返回 true。</p>
<p>-o	或运算，有一个表达式为 true 则返回 true。	[ $a -lt 20 -o $b -gt 100 ] 返回 true。</p>
<p>-a	与运算，两个表达式都为 true 才返回 true。	[ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
<pre><code>#!/bin/bash

a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a == $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre>
<p>&amp;&amp;	逻辑的 AND	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</p>
<p>||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<pre><code>#!/bin/bash

a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>
<h2 id="字符串运算符判断"><a href="#字符串运算符判断" class="headerlink" title="字符串运算符判断"></a>字符串运算符判断</h2><p>&#x3D;	检测两个字符串是否相等，相等返回 true。	[ $a &#x3D; $b ] 返回 false。</p>
<p>!&#x3D;	检测两个字符串是否相等，不相等返回 true。	[ $a !&#x3D; $b ] 返回 true。</p>
<p>-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。  </p>
<p>-n	检测字符串长度是否不为 0，不为 0 返回 true。	[ -n “$a” ] 返回 true。</p>
<p><code>$</code> 检测字符串是否为空，不为空返回 true。	[ $a ] 返回 true。</p>
<pre><code>#!/bin/bash

a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a != $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a = $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n &quot;$a&quot; ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre>
<h2 id="文件检查运算符判断"><a href="#文件检查运算符判断" class="headerlink" title="文件检查运算符判断"></a>文件检查运算符判断</h2><p>b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 返回 false。</p>
<p>-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 返回 false。</p>
<p>-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。</p>
<p>-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。</p>
<p>-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ] 返回 false。</p>
<p>-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 返回 false。</p>
<p>-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 返回 false。</p>
<p>-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 返回 false。</p>
<p>-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 返回 true。</p>
<p>-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 返回 true。</p>
<p>-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 返回 true。</p>
<p>-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 返回 true。</p>
<p>-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 返回 true。</p>
<p>-S: 判断某文件是否 socket。<br>-L: 检测文件是否存在并且是一个符号链接。</p>
<pre><code>#!/bin/bash

file=&quot;/root/test.sh&quot;

if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre>
<h1 id="判断语句报错：”unary-operator-expected”"><a href="#判断语句报错：”unary-operator-expected”" class="headerlink" title="判断语句报错：”unary operator expected”"></a>判断语句报错：”unary operator expected”</h1><p>在匹配字符串相等时，用了类似这样的语句：</p>
<pre><code>if [ $STATUS == &quot;OK&quot; ]; then     
echo &quot;OK&quot;
fi
</code></pre>
<p>在运行时出现了 <code>[: =: unary operator expected</code> 的错误</p>
<pre><code>if [[ $STATUS == &quot;OK&quot; ]]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>究其原因，是因为如果变量STATUS值为空，那么就成了 [ &#x3D; “OK”] ，显然 [ 和 “OK” 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。<br>或者用下面的方法也能避免这种错误：</p>
<pre><code>if [ &quot;$STATUS&quot;x == &quot;OK&quot;x ]; 
then     
echo &quot;OK&quot;
fi
</code></pre>
<p>当然，x也可以是其他字符。shell中有没有双引号在很多情况下是一致的,因此x可以不加引号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/Gitlab%E7%AC%94%E8%AE%B0%EF%BC%9ACentOS7%E9%83%A8%E7%BD%B2Gitlab%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">Gitlab笔记：CentOS7部署Gitlab服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 14:39:02" itemprop="dateCreated datePublished" datetime="2020-04-30T14:39:02+08:00">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>阿里云ECS, CentOS7, RAM 4G</p>
<h1 id="安装Gitlab"><a href="#安装Gitlab" class="headerlink" title="安装Gitlab"></a>安装Gitlab</h1><p>1.安装ssh并配置</p>
<pre><code>#安装
sudo yum install -y curl policycoreutils-python openssh-server
#配置开机启动
sudo systemctl enable sshd
#启动服务
sudo systemctl start sshd
</code></pre>
<p>2.配置防火墙</p>
<pre><code>#启动防火墙
service firewalld start
#添加http服务到firewalld,pemmanent表示永久生效
sudo firewall-cmd --permanent --add-service=http
#重启防火墙
sudo systemctl reload firewalld
</code></pre>
<p>3.安装gitlab</p>
<pre><code>#下载安装脚本
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash
#安装
yum install -y gitlab-ee
</code></pre>
<p>4.配置gitlab</p>
<pre><code>#gitlab配置文件
vim /etc/gitlab/gitlab.rb
#修改以下内容为主机ip和未使用的端口，否则使用默认端口8080
external_url &#39;http://47.100.221.149:9030&#39;
</code></pre>
<p>5.配置生效并重启gitlab</p>
<pre><code>#配置生效，改了配置需要运行
gitlab-ctl reconfigure
#重启服务，没改配置直接重启
gitlab-ctl restart
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061444445.png" alt="image-20221206144455394"><br>似乎服务都正常启动了，实际上可能有各种问题，参考问题记录</p>
<h1 id="问题Debug记录"><a href="#问题Debug记录" class="headerlink" title="问题Debug记录"></a>问题Debug记录</h1><p>按以上步骤配置好后，访问主机ip:端口，直接弹出502服务端错误<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061445877.png" alt="image-20221206144542817"></p>
<h2 id="配置文件权限问题"><a href="#配置文件权限问题" class="headerlink" title="配置文件权限问题?"></a>配置文件权限问题?</h2><p>配置文件生效命令<code>gitlab-ctl reconfigure</code>做了以下事情：</p>
<ul>
<li>配置设置写到gitlab服务直接调用的文件</li>
</ul>
<p>实际生效的配置文件：</p>
<pre><code>vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446719.png" alt="image-20221206144606669"><br>可见配置被自动拷贝到此处，gitlab相关服务读取的是这里的配置项</p>
<ul>
<li>生成服务相关临时文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446110.png" alt="image-20221206144619066"></p>
<p>原因：gitlab服务的配置文件在reconfigure时生成于&#x2F;var&#x2F;log&#x2F;gitlab，这个文件目录默认权限不够，有些子服务不能正常运行。</p>
<p>解决方法：</p>
<pre><code>chmod -R 777 /var/log/gitlab
</code></pre>
<p>restart服务，网页即可正常访问gitlab，如果恢复该目录755权限，重启服务会502</p>
<p>每次重新配置，<code>gitlab-ctl reconfigure</code>似乎会删除该目录再重新写入<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446151.png" alt="image-20221206144636079"></p>
<p>因此每次gitlab-ctl reconfigure之后都要<code>chmod 777</code>改此目录权限</p>
<h2 id="还有502问题"><a href="#还有502问题" class="headerlink" title="还有502问题?"></a>还有502问题?</h2><h3 id="检查阿里云端口"><a href="#检查阿里云端口" class="headerlink" title="检查阿里云端口"></a>检查阿里云端口</h3><p>首先确保主机ip是公网能访问的，不是内网ip<br>其次看端口是否禁用。在阿里云ECS的安全组策略中查看端口是否允许TCP输入输出<br>我把所有端口（1~65535）全部打开了<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061446454.png" alt="image-20221206144656411"></p>
<h3 id="检查前向端口冲突"><a href="#检查前向端口冲突" class="headerlink" title="检查前向端口冲突"></a>检查前向端口冲突</h3><p>gitlab配置文件的external_url就包含前向端口</p>
<pre><code>netstat -nlp | grep 9030 (我的gitlab前向端口)
</code></pre>
<p>显示的是nginx服务端口，因为gitlab默认被nginx反向代理了，说明gitlab的代理服务确实占用9030。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449545.png" alt="image-20221206144927508"></p>
<h3 id="检查子服务的端口"><a href="#检查子服务的端口" class="headerlink" title="检查子服务的端口"></a>检查子服务的端口</h3><p>注意gitlab不只有一个服务，默认配置只设置了前向端口（nginx代理端口），而子服务都没配置端口，默认用了8080，如果有其他服务已经占用8080，可能子服务起不来<br>例如unicorn子服务：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449220.png" alt="image-20221206144946178"></p>
<p>查看子服务状态</p>
<pre><code>gitlab-ctl status
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061449573.png" alt="image-20221206144958510"></p>
<p>如果本地已有8080的服务，最好杀掉或换其他端口，否则要手动配置gitlab子服务端口</p>
<pre><code>unicorn[&#39;port&#39;] = 9032 （随便一个未使用端口）
gitlab_workhorse[&#39;auth_backend&#39;] = &quot;http://localhost:9032&quot;
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450285.png" alt="image-20221206145014236"></p>
<h3 id="检查内存资源不足"><a href="#检查内存资源不足" class="headerlink" title="检查内存资源不足"></a>检查内存资源不足</h3><p>阿里云2G以下RAM可能会有因内存不足，导致服务不能正常启动。<br>使用swap交换分区，避免内存不足的可能性。swap分区可以把部分内存分页存储到磁盘，变相“扩大”内存</p>
<pre><code>#查看现有swap分区，若未分配大小为0
cat /proc/swaps
#创建swap文件，大小4G，挂载到/mnt。交换分区可以使用真正的分区，或者以文件形式的分区
dd if=/dev/zero of=/mnt/swap bs=512 count=8388616
#使之成为swap分区
mkswap /mnt/swap
#修改swap分区配置
cat /proc/sys/vm/swappiness
sysctl -w vm.swappiness=60
#swap分区配置永久生效
vim /etc/sysctl.conf
修改vm.swappiness=60
#启动分区
swapon /mnt/swap
echo “/mnt/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab
#停用分区
swapoff /mnt/swap
swapoff -a &gt; /dev/null
</code></pre>
<p>启用分区后运行gitlab，发现已经有一部分数据转移到了swap文件<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450437.png" alt="image-20221206145023389"></p>
<h1 id="ssh访问配置"><a href="#ssh访问配置" class="headerlink" title="ssh访问配置"></a>ssh访问配置</h1><p>通过ssh上传下载，需要建立ssh key</p>
<pre><code>ssh-keygen   #一路回车
</code></pre>
<p>若创建成功，查看生成的公钥：</p>
<pre><code>cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yXXXXXXXX
</code></pre>
<p>添加公钥至gitlab</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061450049.png" alt="image-20221206145031977"></p>
<h1 id="初始化git项目"><a href="#初始化git项目" class="headerlink" title="初始化git项目"></a>初始化git项目</h1><p>配置git全局用户名，邮箱</p>
<pre><code>git config --global user.name &quot;YOUR NAME&quot;
git config --global user.email &quot;YOUR EMAIL@xxx.com&quot;
</code></pre>
<p>初始化git仓库<br>可以通过xftp上传项目文件夹到gitlab服务器，再到目录内初始化.git仓库。</p>
<pre><code>cd project_folder (项目文件夹)
git init
git remote add origin git@YOUR_IP:YOUR_NAME/project_folder.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
</code></pre>
<p>这样在网页上可看到gitlab有首次commit的文件，后续也可以顺利提交和下载。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/16/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">浅谈C的宏函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-16 15:07:37" itemprop="dateCreated datePublished" datetime="2020-04-16T15:07:37+08:00">2020-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-连接操作符"><a href="#1-连接操作符" class="headerlink" title="1. 连接操作符:##"></a>1. 连接操作符:##</h1><pre><code>#define Conn(x,y) x##y
</code></pre>
<p><code>##</code> 表示连接 , <code>x##y</code> 表示x连接y</p>
<p>示例：</p>
<pre><code>int n = Conn(123,456);
     ==&gt; int n=123456;
char* str = Conn(&quot;asdf&quot;, &quot;adf&quot;);
     ==&gt; char* str = &quot;asdfadf&quot;;
</code></pre>
<p><code>##</code> 的左右符号必须能够组成一个有意义的符号，否则预处理器会报错</p>
<h1 id="2-字符串化和字符化"><a href="#2-字符串化和字符化" class="headerlink" title="2.字符串化和字符化: #, #@"></a>2.字符串化和字符化: #, #@</h1><p>(1) # 把任意类型的宏入参转化成字符串：</p>
<pre><code>#define ToString(x) #x
</code></pre>
<p>符号 # 表示字符串化操作符（stringification）。<br>其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。<br>其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</p>
<p>示例：</p>
<pre><code> char* str = ToString(123132);
 ==&gt; char* str=&quot;123132&quot;;
</code></pre>
<p>如果要对展开后的宏参数进行字符串化，则需要使用两层宏。</p>
<pre><code>#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
     ==&gt; &quot;foo&quot;
xstr (foo)
     ==&gt; xstr (4)
     ==&gt; str (4)
     ==&gt; &quot;4&quot;
</code></pre>
<p>(2) #@ 把任意类型的宏入参转化成单字符：</p>
<pre><code>#define ToChar(x) #@x
</code></pre>
<p>示例：</p>
<pre><code>char a = ToChar(1);
     ==&gt; char a=&#39;1&#39;
</code></pre>
<h1 id="3-不定参数宏-VA-ARGS"><a href="#3-不定参数宏-VA-ARGS" class="headerlink" title="3. 不定参数宏: __VA_ARGS__"></a>3. 不定参数宏: <code>__VA_ARGS__</code></h1><p><code>__VA_ARGS__</code>宏用来接受不定数量的参数。例如：</p>
<pre><code>#define eprintf(...) fprintf (stderr, __VA_ARGS__)

eprintf (&quot;%s:%d: &quot;, input_file, lineno)
==&gt;  fprintf (stderr, &quot;%s:%d: &quot;, input_file, lineno)
</code></pre>
<p>当<code>__VA_ARGS__</code>宏前面加 <code>##</code> 时，可以省略参数输入。<br>例如：</p>
<pre><code>#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

eprintf (&quot;success!\n&quot;)
==&gt; fprintf(stderr, &quot;success!\n&quot;);
</code></pre>
<h1 id="4-宏函数定义-do-while-0-与换行"><a href="#4-宏函数定义-do-while-0-与换行" class="headerlink" title="4. 宏函数定义: do-while(0)与换行"></a>4. 宏函数定义: do-while(0)与换行</h1><p>(1) 用 do{}while(0) 定义宏函数</p>
<pre><code>#define foo() do{...}while(0)
</code></pre>
<p>宏函数可能在任意地方被调用，如果在if-else语句中，为了确保宏函数作为整体单元被编译器替换后不产生歧义，一般用do-while(0)包起来定义<br>这种定义有点像其他语言的“闭包函数”，纯粹是C语言中为了避免语法歧义的可靠性定义。</p>
<p>(2) 用显式换行符</p>
<p>宏函数定义不能直接回车换行，需要在回车换行前，用\（反斜线）表示下一行继续此宏的定义<br>预处理器在编译之前会自动将\与换行回车去掉。</p>
<p>例如：</p>
<pre><code>#define PRINT_INT(a)    \
do{                     \
    printf(&quot;%d \n&quot;, a); \
}while(0)
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%B5%85%E8%B0%88C%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">浅谈C的函数指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 12:30:00" itemprop="dateCreated datePublished" datetime="2020-04-01T12:30:00+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-函数指针基本概念"><a href="#1-函数指针基本概念" class="headerlink" title="1. 函数指针基本概念"></a>1. 函数指针基本概念</h2><p>C语言调用函数的本质是什么？</p>
<ol>
<li>CPU PC指针(program counter)跳转到函数的入口地址，传入参数，传入返回位置</li>
<li>在函数栈内生成临时变量并执行函数内容指令，执行完毕后返回参数</li>
<li>CPU返回原调用处执行</li>
</ol>
<p>这里，函数的入口地址实际上就存储在函数名中，也就是说，C代码中的函数名就是函数的入口地址。<br>既然是地址，就可以用来初始化一个指针，使指针指向该地址。<br>函数指针，就是存放函数首地址的指针。</p>
<h3 id="1-2-函数指针变量"><a href="#1-2-函数指针变量" class="headerlink" title="1.2 函数指针变量"></a>1.2 函数指针变量</h3><p>首先声明普通函数是如下格式：<br><code>void Func(int);</code><br>定义一个同类型函数的函数指针变量，只需要用<code>*p</code>表示函数名即可：<br><code>void (*p)(int);</code><br>注意，上面是定义了函数指针变量，而不是声明函数指针类型。</p>
<p>函数指针变量的定义，和普通变量格式不一样。</p>
<ul>
<li>普通变量： &lt;类型&gt; &lt;变量名&gt;</li>
<li>函数指针：&lt;函数类型 变量名&gt;，按函数声明的格式定义，变量是包含在类型内部</li>
</ul>
<p>那么此函数指针的类型是什么：<br><code>void (*)(int);</code></p>
<p>怎么使用此函数指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Func(int x) // 声明一个函数*/</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line">void (*p)(int); // 定义一个函数指针*/</span><br><span class="line">p = Func; // 将Func函数的首地址赋给函数指针变量p*/</span><br><span class="line">(*p)(100);  // 通过函数指针调用Func函数</span><br></pre></td></tr></table></figure>

<h3 id="1-3-函数指针类型"><a href="#1-3-函数指针类型" class="headerlink" title="1.3 函数指针类型"></a>1.3 函数指针类型</h3><p>typedef可以定义某种类型的别名，例如将unsigned char定义为u8<br><code>typedef unsigned char u8;</code><br>可见其格式是：typedef &lt;原类型&gt; &lt;别名类型&gt;</p>
<p>那么如何定义函数指针类型：<br>只需要在函数指针声明的格式前加typedef, p就定义为函数指针类型而不是变量:<br><code>typedef void (*p)(int);</code></p>
<p>这里定义了<code>void (*)(int)</code>类型的函数指针类型，其别名为p</p>
<p>怎么使用此函数指针类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义类型</span><br><span class="line">typedef void (*pFuncType)(int); </span><br><span class="line">//定义变量  </span><br><span class="line">pFuncType p;   </span><br><span class="line"></span><br><span class="line">void Func(int x)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%d&quot;,x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main()   </span><br><span class="line">&#123;   </span><br><span class="line">    p = Func; //初始化变量   </span><br><span class="line">    (*p)(100);   //使用变量</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="2-函数指针的应用"><a href="#2-函数指针的应用" class="headerlink" title="2. 函数指针的应用"></a>2. 函数指针的应用</h2><h3 id="2-1-Linux驱动软件设计的分层"><a href="#2-1-Linux驱动软件设计的分层" class="headerlink" title="2.1 Linux驱动软件设计的分层"></a>2.1 Linux驱动软件设计的分层</h3><p>C++中有多态的概念，父类定义某种函数类型，子类实现具体的函数内容，之后父类对象就可以调用子类的实现内容。<br>这样实现“父类定义格式，子类实现细节”的软件分层设计。</p>
<p>Linux驱动中也大量使用这种分层设计，C使用结构体和函数指针，分别对应C++的类和方法。<br>例如某驱动模块，顶层框架定义open, read, write, 而底层驱动根据具体硬件，实现xxx_open, xxx_read, xxx_write，然后按结构体成员赋值实现上下层联通：</p>
<p>以s3c的SDHCI驱动为例：<br>sdhci_ops即父类框架结构体，sdhci_s3c_ops为s3c芯片的具体实现结构体。<br><code>.set_clock = sdhci_s3c_set_clock</code>就实现了父类的set_clock方法被子类sdhci_s3c_set_clock实现的效果。<br>其本质是函数指针的赋值，父类和子类的函数名都指向同一个函数地址，所以父类可以通过调用set_clock来实现调用sdhci_s3c_set_clock的效果。<br>这样，父类设计者根本不关心底层用什么函数名实现set_clock的功能，只需要调用set_clock这个函数名即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct sdhci_ops sdhci_s3c_ops = &#123;</span><br><span class="line">	.get_max_clock		= sdhci_s3c_get_max_clk,</span><br><span class="line">	.set_clock		= sdhci_s3c_set_clock,</span><br><span class="line">	.get_min_clock		= sdhci_s3c_get_min_clock,</span><br><span class="line">	.set_bus_width		= sdhci_set_bus_width,</span><br><span class="line">	.reset			= sdhci_reset,</span><br><span class="line">	.set_uhs_signaling	= sdhci_set_uhs_signaling,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数指针实现指令跳转"><a href="#2-2-函数指针实现指令跳转" class="headerlink" title="2.2 函数指针实现指令跳转"></a>2.2 函数指针实现指令跳转</h3><p>调用一个函数，其内部就包含跳转操作(jump指令)<br>那么，如何用C语言实现跳转到某个绝对地址去执行？具体场景：<br>在Bootloader过程中，加载完kernel到RAM后，要跳转到kernel首地址开始执行，如何实现？</p>
<p>方案一：C嵌入汇编<br>以下是基于SPARC CPU的汇编，跳转到0x40000000, 即RAM首地址执行firmware.<br>对于其他CPU，汇编实现也不同，因此此方法不能跨平台。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void boot_exit()</span><br><span class="line">&#123;</span><br><span class="line">    /* jump to RAM entry to execute firmware. */</span><br><span class="line"></span><br><span class="line">    asm(</span><br><span class="line">        &quot;set 0x40000000, %g2\n&quot;</span><br><span class="line">        &quot;jmp %g2\n&quot;</span><br><span class="line">        &quot;nop&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：函数指针<br>Bootloader中很常用的一种跳转方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*pFuncType)(); //定义无入参无返回类型的函数指针类型</span><br><span class="line">pFuncType Reset = (pFuncType)0xF000FFF0; //函数指针指向待跳转地址</span><br><span class="line">Reset(); //调用函数，实际上执行了跳转</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8ESTL/" class="post-title-link" itemprop="url">C++面向对象笔记：模板、泛型与STL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 16:53:38" itemprop="dateCreated datePublished" datetime="2020-03-21T16:53:38+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 16:13:35" itemprop="dateModified" datetime="2024-04-26T16:13:35+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++除了支持面向对象，也支持函数的扩展和重用。继承类和多态充分支持了扩展，即基类进行概括抽象的设计，派生类实现具体的设计。那么重用呢，如何写一个函数，能在多种情况不加修改的套用？<br>考虑以下问题：</p>
<pre><code>交换两个整型变量的值的Swap函数：
void Swap(int &amp; x,int &amp; y)
{
    int tmp = x;
    x = y;
    y = tmp;
}
交换两个double型变量的值的Swap函数:
void Swap(double &amp; x,double &amp; y)
{
    double tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>这两个函数除了入参类型不同，函数名，参数个数，返回类型都相同。函数体的处理流程也完全一样。能否只写一个Swap，就能交换各种类型的变量？<br>模板（template）将解决这种问题。</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="函数模板的概念"><a href="#函数模板的概念" class="headerlink" title="函数模板的概念"></a>函数模板的概念</h2><p>用函数模板，设计仅数据类型不同的一组函数的通用模板：</p>
<pre><code>template &lt;class 类型参数1，class 类型参数2,……&gt;
返回值类型 模板名 (形参表)
{
    函数体
};

template &lt;class T&gt; //在函数前声明模板，参数类型（class）是T
void Swap(T &amp; x,T &amp; y)
{
    T tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>在普通函数前，先用template&lt; class T &gt;声明参数类型T，就可以在函数体使用T，就像使用普通变量一样。在运行时，T传入的类型不同，函数处理的数据类型也不同。<br>函数模板是如何实现的？它是一种函数吗？</p>
<pre><code>int main()
{
    int n = 1,m = 2;
    Swap(n,m); //编译器自动生成 void Swap(int &amp; ,int &amp; )函数
    double f = 1.2,g = 2.3;
    Swap(f,g); //编译器自动生成 void Swap(double &amp; ,double &amp; )函数
    return 0;
}
</code></pre>
<p>函数模板只是个模子，编译器通过模板和具体参数类型产生不同的函数。编译器会进行两次编译，第一次检测模板代码，第二次检测加参数后的具体函数代码。<br>在调用以上函数模板时，实际会生成两个具体函数：</p>
<pre><code>void Swap(int &amp; x,int &amp; y)
{
    int tmp = x;
    x = y;
    y = tmp;
}
void Swap(double &amp; x,double &amp; y)
{
    double tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>函数模板，可以理解为一种函数的宏，编译期在宏被调用的地方，全部替换成宏所对应的具体值。<br>函数模板和运行时函数，也类似于类和对象的关系，类只是类型，对象是给类分配了内存的实例。函数模板只是通用的类型，函数实例是函数模板的实例化对象。</p>
<h2 id="函数模板的特性"><a href="#函数模板的特性" class="headerlink" title="函数模板的特性"></a>函数模板的特性</h2><p>函数模板中可以有不止一个类型参数</p>
<pre><code>template &lt;class T1, class T2&gt;
T2 print(T1 arg1, T2 arg2)
{
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
    return arg2;
}
</code></pre>
<p>不通过参数也能实例化函数模板</p>
<pre><code>template &lt;class T&gt;
T Inc(T n)
{
    return 1 + n;
}
int main()
{
    cout &lt;&lt; Inc&lt;double&gt;(4)/2; //显式实例化模板，输出 2.5
    return 0;
}
</code></pre>
<h2 id="函数模板与重载"><a href="#函数模板与重载" class="headerlink" title="函数模板与重载"></a>函数模板与重载</h2><p>函数模板和函数重载，在写法上很接近，都是一组参数不同的同名函数。它们有什么联系和区别？</p>
<ul>
<li>函数重载，关键在参数个数</li>
<li>函数模板，关键在参数类型</li>
</ul>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<pre><code>template&lt;class T1, class T2&gt;
void print(T1 arg1, T2 arg2) {
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
}
template&lt;class T&gt;
void print(T arg1, T arg2) {
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
}
template&lt;class T,class T2&gt;
void print(T arg1, T arg2) {
    cout&lt;&lt; arg1 &lt;&lt; &quot; &quot;&lt;&lt; arg2&lt;&lt;endl;
}
</code></pre>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一条函数调用语句:</p>
<ol>
<li><p>先找参数完全匹配的普通函数(非由模板实例化而得的函数)</p>
</li>
<li><p>再找参数完全匹配的模板函数。</p>
</li>
<li><p>再找实参数经过自动类型转换后能够匹配的普通函数。</p>
</li>
</ol>
<ol start="4">
<li><p>上面的都找不到，则报错<br>如果有函数重载，在第（1）步就找到，如果没有，才找（2）的函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line"> T Max( T a, T b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> template &lt;class T,class T2&gt;</span><br><span class="line"> T Max( T a, T2 b) &#123;</span><br><span class="line">     cout &lt;&lt; &quot;TemplateMax2&quot; &lt;&lt;endl; return 0;</span><br><span class="line"> &#125;</span><br><span class="line"> double Max(double a, double b)&#123;</span><br><span class="line">     cout &lt;&lt; &quot;MyMax&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main() &#123;</span><br><span class="line">     int i=4, j=5;</span><br><span class="line">     Max( 1.2,3.4); // 输出MyMax</span><br><span class="line">     Max(i, j); //输出TemplateMax</span><br><span class="line">     Max( 1.2, 3); //输出TemplateMax2</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意上文的步骤（2）（3）是分开的，匹配模板函数时，是不进行类型自动转换的，不匹配就是不匹配。输入参数有二义性时。编译器不会为开发者做决定</p>
<pre><code>template&lt;class T&gt;
T myFunction( T arg1, T arg2)
{ cout&lt;&lt;arg1&lt;&lt;&quot; &quot;&lt;&lt;arg2&lt;&lt;&quot;\n&quot;; return arg1;}
……
myFunction( 5, 7); //ok： replace T with int
myFunction( 5.8, 8.4); //ok： replace T with double
myFunction( 5, 8.4); //error， no matching function for call to &#39;myFunction(int, double)&#39;
</code></pre>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="类模板的概念"><a href="#类模板的概念" class="headerlink" title="类模板的概念"></a>类模板的概念</h2><p>类也能使用模板，来生成不同成员类型的类<br>类模板：在定义类的时候，加上一个&#x2F;多个类型参数。在使用类模板时，指定类型参数应该如何替换成具体类型，编译器据此生成相应的模板类</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
class 类模板名
{
    成员函数和成员变量
};
</code></pre>
<p>类模板的成员函数的定义写法：</p>
<pre><code>template &lt;class 类型参数1， class 类型参数2， ……&gt; //类型参数表
返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名（ 参数表）
{
    ……
}
</code></pre>
<p>用类模板实例化对象的写法：</p>
<pre><code>类模板名 &lt;真实类型参数表&gt; 对象名(构造函数实参表);
</code></pre>
<p>一个例子：map类型中的pair类的实现：</p>
<pre><code>template &lt;class T1,class T2&gt;    //pair是类模板
class Pair
{
public:
    T1 key; //关键字
    T2 value; //值
    Pair(T1 k,T2 v):key(k),value(v) { }; //构造函数
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const; //运算符重载函数
};

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
//Pair的运算符重载函数的定义
{
    return key &lt; p.key;
}

 int main()
{
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,19); //实例化出一个类 Pair&lt;string,int&gt;
    cout &lt;&lt; student.key &lt;&lt; &quot; &quot; &lt;&lt; student.value;
    return 0;
}
</code></pre>
<p>输出：Tom 19<br>编译器由类模板生成类的过程叫类模板的实例化。 由类模板实例化得到的类， 叫模板类<br>同一个类模板的两个模板类是不兼容的，即两个不同的类</p>
<pre><code>Pair&lt;string,int&gt; * p;
Pair&lt;string,double&gt; a;
p = &amp; a; //错误，不是同类也不是继承类，不能赋值
</code></pre>
<p>函数模版可以作为类模板成员</p>
<pre><code>template &lt;class T&gt;
class A
{
public:
    template&lt;class T2&gt;
    void Func( T2 t) { cout &lt;&lt; t; } //成员函数模板
};
int main()
{
    A&lt;int&gt; a;
    a.Func(&#39;K&#39;); //成员函数模板 Func被实例化
    a.Func(&quot;hello&quot;); //成员函数模板 Func再次被实例化
    return 0;
} //输出： KHello
</code></pre>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数：</p>
<pre><code>template &lt;class T, int size&gt;
class CArray{
    T array[size];
    public:
    void Print( )
    {
        for( int i = 0;i &lt; size; ++i)
        cout &lt;&lt; array[i] &lt;&lt; endl;
    }
};

CArray&lt;double,40&gt; a2;
CArray&lt;int,50&gt; a3;
</code></pre>
<h2 id="类模板的派生"><a href="#类模板的派生" class="headerlink" title="类模板的派生"></a>类模板的派生</h2><p>类模板也支持类的派生：<br>• 类模板从类模板派生<br>• 类模板从模板类派生<br>• 类模板从普通类派生<br>• 普通类从模板类派生</p>
<p>(1)类模板从类模板派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A {
    T1 v1; T2 v2;
};

template &lt;class T1,class T2&gt;
class B:public A&lt;T2,T1&gt; {
    T1 v3; T2 v4;
};

template &lt;class T&gt;
class C:public B&lt;T,T&gt; {
    T v5;
};

int main() {
    B&lt;int,double&gt; obj1;
    C&lt;int&gt; obj2;
    return 0;
}
</code></pre>
<p>(2)类模板从模板类派生</p>
<pre><code>template &lt;class T1,class T2&gt;
class A {
    T1 v1; T2 v2;
};

template &lt;class T&gt;
class B:public A&lt;int,double&gt; {
    T v;
};

int main() {
    B&lt;char&gt; obj1; //自动生成两个模板类：A&lt;int,double&gt; 和 B&lt;char&gt;
    return 0;
}
</code></pre>
<p>(3)类模板从普通类派生</p>
<pre><code>class A {
    int v1;
};

template &lt;class T&gt;
class B:public A { //所有从B实例化得到的类， 都以A为基类
    T v;
};

int main() {
    B&lt;char&gt; obj1;
    return 0;
}
</code></pre>
<p>(4)普通类从模板类派生</p>
<pre><code>template &lt;class T&gt;
class A {
    T v1;
    int n;
};

class B:public A&lt;int&gt; {
    double v;
};
int main() {
    B obj1;
    return 0;
}
</code></pre>
<h2 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h2><p>• 函数、类、类的成员函数作为类模板的友元<br>• 函数模板作为类模板的友元<br>• 函数模板作为类的友元<br>• 类模板作为类模板的友元</p>
<p>(1)函数、类、类的成员函数作为类模板的友元</p>
<pre><code>void Func1() { }
class A { };
class B
{
    public:
    void Func() { }
};

template &lt;class T&gt;
class Tmpl
{
    friend void Func1();
    friend class A;
    friend void B::Func();
}; //任何从Tmp1实例化来的类， 都有以上三个友元
</code></pre>
<p>(2)函数模板作为类模板的友元</p>
<pre><code>template &lt;class T1,class T2&gt;
class Pair
{
private:
    T1 key; //关键字
    T2 value; //值
public:
    Pair(T1 k,T2 v):key(k),value(v) { };
    bool operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const;
    template &lt;class T3,class T4&gt;
    friend ostream &amp; operator&lt;&lt; ( ostream &amp; o,
    const Pair&lt;T3,T4&gt; &amp; p);
};

template&lt;class T1,class T2&gt;
bool Pair&lt;T1,T2&gt;::operator &lt; ( const Pair&lt;T1,T2&gt; &amp; p) const
{ //&quot;小&quot;的意思就是关键字小
    return key &lt; p.key;
}
template &lt;class T1,class T2&gt;
ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)
{
    o &lt;&lt; &quot;(&quot; &lt;&lt; p.key &lt;&lt; &quot;,&quot; &lt;&lt; p.value &lt;&lt; &quot;)&quot; ;
    return o;
}

int main()
{
    Pair&lt;string,int&gt; student(&quot;Tom&quot;,29);
    Pair&lt;int,double&gt; obj(12,3.14);
    cout &lt;&lt; student &lt;&lt; &quot; &quot; &lt;&lt; obj;
    return 0;
}

输出：
(Tom,29) (12,3.14)
</code></pre>
<p>任意从 <code>template &lt;class T1,class T2&gt; ostream &amp; operator&lt;&lt; (ostream &amp; o,const Pair&lt;T1,T2&gt; &amp; p)</code>生成的函数，都是任意Pair摸板类的友元</p>
<p>(3)函数模板作为类的友元</p>
<pre><code>class A
{
    int v;
    public:
    A(int n):v(n) { }
    template &lt;class T&gt;
    friend void Print(const T &amp; p);
};
template &lt;class T&gt;
void Print(const T &amp; p)
{
    cout &lt;&lt; p.v;
}

int main() {
    A a(4);
    Print(a);
    return 0;
}

输出：
4
</code></pre>
<p>所有从 <code>template &lt;class T&gt; void Print(const T &amp; p)</code><br>生成的函数，都成为 A 的友元</p>
<p>(4)类模板作为类模板的友元</p>
<pre><code>template &lt;class T&gt;
class B {
    T v;
    public:
    B(T n):v(n) { }
    template &lt;class T2&gt;
    friend class A;
};

template &lt;class T&gt;
class A {
public:
    void Func( ) {
        B&lt;int&gt; o(10);
        cout &lt;&lt; o.v &lt;&lt; endl;
    }
};

int main()
{
    A&lt; double &gt; a;
    a.Func ();
    return 0;
}

输出：
10
</code></pre>
<p>A&lt; double&gt;类，成了B<int>类的友元。任何从A模版实例化出来的类，都是任何B实例化出来的类的友元</p>
<h2 id="类模板与静态成员"><a href="#类模板与静态成员" class="headerlink" title="类模板与静态成员"></a>类模板与静态成员</h2><p>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员</p>
<pre><code>template &lt;class T&gt;
class A
{
private:
    static int count;
    public:
    A() { count ++; }
    ~A() { count -- ; };
    A( A &amp; ) { count ++ ; }
    static void PrintCount() { cout &lt;&lt; count &lt;&lt; endl; }
};

template&lt;&gt; int A&lt;int&gt;::count = 0;
template&lt;&gt; int A&lt;double&gt;::count = 0;
int main()
{
    A&lt;int&gt; ia;
    A&lt;double&gt; da;
    ia.PrintCount();
    da.PrintCount();
    return 0;
}

输出：
1 1
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/" class="post-title-link" itemprop="url">C++面向对象笔记：继承与多态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 16:49:06" itemprop="dateCreated datePublished" datetime="2020-03-20T16:49:06+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>前文分析了C++类内成员的关系，本文讨论类和类之间的关系。<br>考虑用C++对现实世界的交通工具进行描述。</p>
<ul>
<li>汽车可能包含各种类型，小汽车，公交车，但他们能抽象出四个轮子，烧油这些基本属性</li>
<li>飞机也有各种类型，但也能抽象出机翼，机身等基本属性</li>
<li>轮船…</li>
</ul>
<p>如果自顶向下设计，如何设计这些对象的类？</p>
<ul>
<li>提炼这些交通工具的共有属性，如材质，耗油量，价格，设计成一个交通工具基础类；然后设计一些操作方法，比如制造，启动，停止。</li>
<li>分别设计汽车、飞机、轮船等更具体的类的属性，比如轮子、排水量等，注意，他们也包含基础类的材质，耗油量，价格等基本属性；然后也设计一些方法，比如制造汽车、开汽车和造飞机、开飞机等</li>
<li>然后再设计更细节的类，作为汽车、飞机、轮船类的细化，比如A品牌的汽车，B品牌汽车，作为两个具体类。</li>
</ul>
<p>仔细考虑以上步骤，有以下问题：</p>
<ul>
<li>这些类的属性（成员变量）是相互独立的吗？</li>
<li>这些类的方法（成员函数）是相互独立的吗？</li>
</ul>
<p>C++用类的“继承”描述层层细化的类及其成员变量的关系，用“多态”描述各层方法的实现关系。</p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承关系的概念"><a href="#继承关系的概念" class="headerlink" title="继承关系的概念"></a>继承关系的概念</h2><p>继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个<strong>基类</strong>（也叫父类），而把B作为基类的一个<strong>派生类</strong>(也叫子类)。</p>
<ul>
<li>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数</li>
<li>派生类一经定义后，可以独立使用，不依赖于基类。</li>
<li>派生类拥有基类的全部成员函数和成员变量，不论是private、 protected、 public。但是派生类的成员函数不能访问基类中的private成员</li>
</ul>
<p>一个管理学生的类继承：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651314.png" alt="image-20221208165130260"><br>派生类语法:</p>
<pre><code>class 派生类名： public 基类名
{
};
</code></pre>
<p>学生类的派生:</p>
<pre><code>class CStudent {
    private:
    string sName;
    int nAge;
    public:
    bool IsThreeGood() { };
    void SetName( const string &amp; name )
    { sName = name; }
        //......
};

class CUndergraduateStudent: public CStudent {
    private:
    int nDepartment;
    public:
    bool IsThreeGood() { ...... }; //覆盖
    bool CanBaoYan() { .... };
}; // 派生类的写法是：类名: public 基类名
</code></pre>
<h2 id="类继承的存储空间"><a href="#类继承的存储空间" class="headerlink" title="类继承的存储空间"></a>类继承的存储空间</h2><p>在类与对象一文讲过，类对象的存储空间，实际就是成员变量的空间，成员函数不在对象空间内（虚函数包含一个虚函数表指针）。那么基类和派生类的对象空间有什么相关性？<br>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。 在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。<br>一个示例：</p>
<pre><code>class CBase
{
    int v1, v2;
};
class CDerived:public CBase
{
    int v3;
};
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651715.png" alt="image-20221208165140659"></p>
<h2 id="类继承的覆盖"><a href="#类继承的覆盖" class="headerlink" title="类继承的覆盖"></a>类继承的覆盖</h2><p>类内的同名非同参的函数叫函数重载，那么基类与派生类的同名函数呢？<br>派生类可以定义和基类成员同名的成员，这叫<strong>覆盖</strong>。在派生类中访问这类成员时，默认访问派生类中定义的成员，基类的成员函数或变量被“覆盖”掉了。如果要在派生类中访问基类定义的同名成员时，要使用作用域符号::<br>一个例子：</p>
<pre><code>class base {    //基类
    int j;  //默认private
    public:
    int i;
    void func();
};
class derived : public base{    //派生类
    public:
    int i;  //覆盖基类i
    void access();
    void func(); //覆盖基类func()
};

void derived::access() { //访问派生类成员
    j = 5; //error
    i = 5; //引用的是派生类的 i
    base::i = 5; //引用的是基类的 i
    func(); //派生类的
    base::func(); //基类的
}
</code></pre>
<p>调用函数:</p>
<pre><code>derived obj;
obj.i = 1;  //访问派生类成员i
obj.base::i = 1; //访问基类成员i
</code></pre>
<p>内存分布:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081651894.png" alt="image-20221208165150851"><br>以上只是示例，一般来说，基类和派生类不定义同名成员变量，但经常有同名成员函数，所以覆盖通常用于成员函数覆盖。</p>
<h2 id="类继承的成员访问控制"><a href="#类继承的成员访问控制" class="headerlink" title="类继承的成员访问控制"></a>类继承的成员访问控制</h2><ul>
<li>基类的private成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数</li>
<li>基类的public成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数<br>– 派生类的友元函数<br>– 其他的函数</li>
<li>基类的protected成员：可以被下列函数访问<br>– 基类的成员函数<br>– 基类的友元函数<br>– 派生类的成员函数可以访问当前对象的基类的保护成员</li>
</ul>
<p>一个示例：</p>
<pre><code>class Father {
    private: int nPrivate; //私有成员
    public: int nPublic; //公有成员
    protected: int nProtected; // 保护成员
};
class Son :public Father{
    void AccessFather () {
        nPublic = 1; // ok;
        nPrivate = 1; // wrong
        nProtected = 1; // OK，访问从基类继承的protected成员
        Son f;
        f.nProtected = 1; //wrong ， f不是当前对象
    }
};

int main()
{
    Father f;
    Son s;
    f.nPublic = 1; // Ok
    s.nPublic = 1; // Ok
    f.nProtected = 1; // error
    f.nPrivate = 1; // error
    s.nProtected = 1; //error
    s.nPrivate = 1; // error
    return 0;
}
</code></pre>
<h2 id="类继承的构造函数"><a href="#类继承的构造函数" class="headerlink" title="类继承的构造函数"></a>类继承的构造函数</h2><p>类似于嵌套类（封闭类）的构造函数，使用初始化列表来实现层层构造，基类和派生类只初始化他们能访问的成员</p>
<pre><code>class Bug {
private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug (){ };
};

class FlyBug: public Bug // FlyBug是Bug的派生类
{
    int nWings;
    public:
    FlyBug( int legs,int color, int wings);
};

Bug::Bug( int legs, int color) //Bug类的构造函数
{
    nLegs = legs;
    nColor = color;
}

//错误的FlyBug构造函数！
FlyBug::FlyBug ( int legs,int color, int wings)
{
    nLegs = legs; // 不能访问
    nColor = color; // 不能访问
    nType = 1; // ok
    nWings = wings;
}

//正确的FlyBug构造函数：使用初始化列表
FlyBug::FlyBug ( int legs, int color, int wings):Bug( legs, color)
{
    nWings = wings;
}

int main() {
    FlyBug fb ( 2,3,4);
    fb.PrintBug();
    fb.nType = 1;
    fb.nLegs = 2 ; // error. nLegs is private
    return 0;
}
</code></pre>
<h2 id="类继承的构造析构时序"><a href="#类继承的构造析构时序" class="headerlink" title="类继承的构造析构时序"></a>类继承的构造析构时序</h2><p>在创建派生类的对象时，需要调用基类的构造函数：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。<br>调用基类构造函数的两种方式:</p>
<ul>
<li><p>显式方式：在派生类的构造函数中，为基类的构造函数提供参数.</p>
<p> derived::derived(arg_derived-list):base(arg_base-list)</p>
</li>
<li><p>隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数</p>
</li>
</ul>
<p>析构函数执行时序:<br>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。<br>一个例子：</p>
<pre><code>class Base {
    public:
    int n;
    Base(int i):n(i)
    { cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;}
    ~Base()
    { cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; destructed&quot; &lt;&lt; endl; }
};
    
class Derived:public Base {
    public:
    Derived(int i):Base(i)
    { cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl; }
    ~Derived()
    { cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;}
};
int main() { Derived Obj(3); return 0; }
</code></pre>
<p>输出结果:</p>
<pre><code>Base 3 constructed
Derived constructed
Derived destructed
Base 3 destructed
</code></pre>
<p>##封闭派生类的构造函数<br>封闭类的构造用初始化列表，派生类也用初始化列表，那么封闭派生类呢？<br>还是初始化列表</p>
<pre><code>class Bug {
    private :
    int nLegs; int nColor;
    public:
    int nType;
    Bug ( int legs, int color);
    void PrintBug (){ };
};

class Skill {
    public:
    Skill(int n) { }
};
class FlyBug: public Bug {
    int nWings;
    Skill sk1, sk2;
    public:
    FlyBug( int legs, int color, int wings);
};
FlyBug::FlyBug( int legs, int color, int wings):
    Bug(legs,color),sk1(5),sk2(color) ,nWings(wings) { //初始化列表，不能访问的通通交给下层构造函数
}
</code></pre>
<h2 id="封闭派生类的构造析构时序"><a href="#封闭派生类的构造析构时序" class="headerlink" title="封闭派生类的构造析构时序"></a>封闭派生类的构造析构时序</h2><p>在创建派生类的对象时:</p>
<ol>
<li>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员</li>
<li>再执行成员对象类的构造函数，用以初始化派生类对象中成员对象</li>
<li>最后执行派生类自己的构造函数<br>在派生类对象消亡时：</li>
<li>先执行派生类自己的析构函数</li>
<li>再依次执行各成员对象类的析构函数</li>
<li>最后执行基类的析构函数<br>析构函数的调用顺序与构造函数的调用顺序相反</li>
</ol>
<h1 id="类的复合"><a href="#类的复合" class="headerlink" title="类的复合"></a>类的复合</h1><p>在数学上，两个集合有无关、相交和包含的关系。对于多个类来说，也应该有以上三种关系。无关类&#x3D;两个成员不相关的类；继承类&#x3D;类成员间有继承关系的类；那么相交的类呢？</p>
<h2 id="复合关系的概念"><a href="#复合关系的概念" class="headerlink" title="复合关系的概念"></a>复合关系的概念</h2><p>C++用“复合”表示类的相交关系。<br>1)继承：“是”的关系<br>基类是A， B是基类A的派生类，逻辑上要求：“一个B对象也是一个A对象”<br>2)复合：“有”的关系<br>类C中“有” 成员变量k，k是类D的对象，则C和D是复合关系，逻辑上要求：“D对象是C对象的固有属性或组成部分</p>
<p>下面比较一下继承和复合在具体设计的实例：<br>继承关系顶层设计例子:</p>
<ul>
<li>写了一个 CMan 类代表男人</li>
<li>后来又发现需要一个CWoman类来代表女人</li>
<li>CWoman类和CMan类有共同之处,让CWoman类从CMan类派生而来，是否合适？</li>
<li>错！从一开始就应该设计CHuman类，代表“人” ,然后CMan和CWoman都从<br>CHuman派生</li>
</ul>
<p>继承逻辑关系：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652246.png" alt="image-20221208165210195"></p>
<p>复合关系顶层设计例子：</p>
<ul>
<li>几何形体程序中，需要写“点”类，也需要写“圆”类</li>
<li>每个圆都有圆心，那么点类应该从圆类派生出来吗？</li>
<li>错！”点“不仅在圆内有，在其他图形也有，不是圆独有，非继承关系</li>
<li>实际上，圆和点是复合关系，每一个“圆”对象里都包含(<strong>有</strong>)一个“点”对象</li>
<li>逻辑上，复合关系就是，我的一部分可以看成是你的，但是我的全部东西不都属于你</li>
</ul>
<p>复合关系的类通常用友元实现：</p>
<pre><code>class CPoint
{
    double x,y;
    friend class CCircle;
    //便于Ccirle类操作其圆心
};

class CCircle
{
    double r;
    CPoint center;
};
</code></pre>
<h2 id="复合关系的典型示例"><a href="#复合关系的典型示例" class="headerlink" title="复合关系的典型示例"></a>复合关系的典型示例</h2><p>如果要写一个小区养狗管理程序，需要写一个“业主”类，还需要写一个“狗” 类<br>狗是归宿于业主的，一个业主可以有多条狗，狗也可以随时脱离业主<br>考虑以下设计方法：<br>设计人和狗两个类，相互包含对方类</p>
<pre><code>class CDog;
class CMaster
{
    CDog dogs[10];
};
class CDog
{
    CMaster m;
};
</code></pre>
<p> 这样有循环定义错误！且逻辑上，狗和人并非相互包含关系<br> 这种关系上相互相关，对象本身又完全独立的情况，用对象指针表示</p>
<pre><code>class CMaster; //CMaster必须提前声明，不能先写CMaster类后写Cdog类
class CDog {
    CMaster * pm;
};
class CMaster {
    CDog * dogs[10];
};
</code></pre>
<p>逻辑关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652390.png" alt="image-20221208165220338"></p>
<h1 id="继承的不足"><a href="#继承的不足" class="headerlink" title="继承的不足"></a>继承的不足</h1><h2 id="继承方式的访问限制"><a href="#继承方式的访问限制" class="headerlink" title="继承方式的访问限制"></a>继承方式的访问限制</h2><p>基类和派生类是包含的关系，那么基类对象和派生类对象是什么关系？<br>对于类的public派生方式:</p>
<pre><code>class base { };
class derived : public base { };
base b;
derived d;
</code></pre>
<p>1）派生类的对象可以赋值给基类对象<br>b &#x3D; d;<br>2）派生类对象可以初始化基类引用<br>base &amp; br &#x3D; d;<br>3）派生类对象的地址可以赋值给基类指针<br>base * pb &#x3D; &amp; d;<br>如果派生方式是 private或protected，则上述三条不可行</p>
<p>对于类的protected和private派生方式:</p>
<pre><code>class base {};
class derived : protected base {};
base b;
derived d;
</code></pre>
<p>• protected继承时，基类的public成员和protected成员成为派生类的protected成员。<br>• private继承时，基类的public成员成为派生类的private成员，基类的protected成员成为派生类的不可访问成员。<br>• protected和private继承不是“是”的关系</p>
<h2 id="派生类的对象指针转换"><a href="#派生类的对象指针转换" class="headerlink" title="派生类的对象指针转换"></a>派生类的对象指针转换</h2><p>public派生的情况下,派生类对象的指针可以直接赋值给基类指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
//ptrBase指向的是一个Derived类的对象；
</code></pre>
<p>*ptrBase可以看作一个Base类的对象，访问它的public成员直接通过ptrBase即可，但不能通过ptrBase访问objDerived对象中属于Derived类而不属于Base类的成员<br>过强制指针类型转换，可以把ptrBase转换成Derived类的指针</p>
<pre><code>Base * ptrBase = &amp;objDerived;
Derived *ptrDerived = (Derived * ) ptrBase;
</code></pre>
<p>程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会错</p>
<p>派生类的指针赋值给基类后，基类指针也不能访问派生类的特有成员</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Base {
    protected:
    int n;
    public:
    Base(int i):n(i){cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; constructed&quot; &lt;&lt; endl; }
    ~Base() {cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt;&quot; destructed&quot; &lt;&lt; endl;}
    void Print() { cout &lt;&lt; &quot;Base:n=&quot; &lt;&lt; n &lt;&lt; endl;}
};

class Derived:public Base {
    public:
    int v;
    Derived(int i):Base(i),v(2 * i) {
    cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl;
}

~Derived() {
    cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;
}

void Func() { } ;
    void Print() {
        cout &lt;&lt; &quot;Derived:v=&quot; &lt;&lt; v &lt;&lt; endl;
        cout &lt;&lt; &quot;Derived:n=&quot; &lt;&lt; n &lt;&lt; endl;
    }
};

int main() {
    Base objBase(5);
    Derived objDerived(3);
    Base * pBase = &amp; objDerived ;
    //pBase-&gt;Func(); //err;Base类没有Func()成员函数
    //pBase-&gt;v = 5; //err; Base类没有v成员变量
    pBase-&gt;Print();
    //Derived * pDerived = &amp; objBase; //error
    Derived * pDerived = (Derived *)(&amp; objBase);
    pDerived-&gt;Print(); //慎用，可能出现不可预期的错误
    pDerived-&gt;v = 128; //往别人的空间里写入数据，会有问题
    objDerived.Print();
    return 0;
}
</code></pre>
<p>输出：</p>
<pre><code>Base 5 constructed
Base 3 constructed
Derived constructed
Base:n=3
Derived:v=1245104 //pDerived-&gt;n 位于别人的空间里
Derived:n=5
Derived:v=6
Derived:n=3
Derived destructed
Base 3 destructed
Base 5 destructed
</code></pre>
<p>从逻辑上来说，派生类指针既然能被赋值给基类指针，那么通过基类指针，应该能调用派生类的成员函数，获取派生类的成员变量。在下一章，继承类的多态将实现这个目的。</p>
<h2 id="多级继承"><a href="#多级继承" class="headerlink" title="多级继承"></a>多级继承</h2><p>类A派生类B，类B派生类C，类C派生类D……<br>– 类A是类B的直接基类<br>– 类B是类C的直接基类，类A是类C的间接基类<br>– 类C是类D的直接基类，类A、 B是类D的间接基类<br>在声明派生类时， 只需要列出它的直接基类<br>– 派生类沿着类的层次自动向上继承它的间接基类<br>– 派生类的成员包括<br>• 派生类自己定义的成员<br>• 直接基类中的所有成员<br>• 所有间接基类的全部成员</p>
<h1 id="多态：在继承上更进一步"><a href="#多态：在继承上更进一步" class="headerlink" title="多态：在继承上更进一步"></a>多态：在继承上更进一步</h1><p>前面派生类的对象指针转换一节，基类指针强转后也不能访问派生类私有对象。考虑一下本文开始讲的交通工具顶层设计思路，在顶层设计时就要设计类的成员函数，在派生类也要设计成员函数，这些函数会有重合的情况吗？如果有重合，基类指针也不能访问派生类成员，这样基类和派生类不就失去联系了吗？多级继承这种情况不是更加严重？<br>为了解决这种问题，本节引入继承类的“多态”<br>多态能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少</p>
<h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><p>在类的定义中，前面有 virtual 关键字的成员函数就是虚函数</p>
<pre><code>class base {
    virtual int get() ;
};
int base::get(){ }
</code></pre>
<p>virtual关键字只用在类定义里的函数声明中使用，定义函数体时不用。<br>使用虚函数，来实现“多态”效果。多态有通过指针和引用两种表现形式:</p>
<ul>
<li>能通过基类的指针调用派生类虚函数，访问其特有成员变量</li>
</ul>
<p>派生类的指针可以赋给基类指针<br>通过基类指针调用基类和派生类中的同名虚函数时:<br>（1）若该指针指向一个基类的对象，那么被调用是<br>基类的虚函数；<br>（2）若该指针指向一个派生类的对象，那么被调用<br>的是派生类的虚函数</p>
<pre><code>class CBase {
public:
    virtual void SomeVirtualFunction() { }
};
class CDerived:public CBase {
public :
    virtual void SomeVirtualFunction() { }
};
int main() {
    CDerived ODerived;
    CBase * p = &amp; ODerived;
    p -&gt; SomeVirtualFunction(); //调用哪个虚函数取决于p指向哪种类型的对象
    return 0;
} 
</code></pre>
<ul>
<li>能通过基类的引用调用派生类虚函数</li>
</ul>
<p>派生类的对象可以赋给基类引用<br>通过基类引用调用基类和派生类中的同名虚函数时:<br>（1）若该引用引用的是一个基类的对象，那么被调<br>用是基类的虚函数；<br>（2）若该引用引用的是一个派生类的对象，那么被<br>调用的是派生类的虚函数。</p>
<pre><code>class CBase {
public:
    virtual void SomeVirtualFunction() { }
};
class CDerived:public CBase {
public :
    virtual void SomeVirtualFunction() { }
};
int main() {
    CDerived ODerived;
    CBase &amp; r = ODerived;
    r.SomeVirtualFunction(); //调用哪个虚函数取决于r引用哪种类型的对象
    return 0;
} 
</code></pre>
<p>是不是所有成员函数加virtual都是多态？不是！</p>
<ul>
<li>在非构造或析构函数的成员函数中调用虚函数，是多态。在运行时才确定到底调用哪一层派生类函数</li>
<li>在构造函数和析构函数中调用虚函数，不是多态。调用的函数是当前类的函数，编译时即确定</li>
</ul>
<p>多层继承实现多态，每一层都要加virtual关键字吗？</p>
<ul>
<li>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</li>
</ul>
<h2 id="多态与对象指针"><a href="#多态与对象指针" class="headerlink" title="多态与对象指针"></a>多态与对象指针</h2><p>一个变量有两方面属性：类型、值<br>那么多态把derived类的地址值，赋值给base类的指针，访问对象成员时是什么效果？<br>以下例子的this指针指向什么？</p>
<pre><code>class Base {
public:
    void fun1() { this-&gt;fun2(); } //this是基类指针， fun2是虚函数，所以是多态
    virtual void fun2() { cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; }
};
class Derived:public Base {
public:
    virtual void fun2() { cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; }
};
int main() {
    Derived d;
    Base * pBase = &amp; d;
    pBase-&gt;fun1();
    return 0;
}
</code></pre>
<p>pBase被Derived对象的地址赋值后，其值为Derived对象的地址，但类型还是Base的指针（多态指针赋值不会强转）。pBase-&gt;fun1()会先在Base类访问其fun1()，传入this指针（指向fun2）,而this-&gt;fun2()会调用Derived类的fun2()<br>输出： </p>
<pre><code>Derived:fun2()
</code></pre>
<p>虚函数也可以定义为private：</p>
<pre><code>class Base {
private:
    virtual void fun2() { cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; }
};
class Derived:public Base {
public:
    virtual void fun2() { cout &lt;&lt; &quot;Derived:fun2()&quot; &lt;&lt; endl; }
};
Derived d;
Base * pBase = &amp; d;
pBase -&gt; fun2(); // 编译出错
</code></pre>
<p>pBase已经被赋值为指向derived d的指针，不能调用base类的private函数。</p>
<h2 id="多态的实例-游戏开发"><a href="#多态的实例-游戏开发" class="headerlink" title="多态的实例:游戏开发"></a>多态的实例:游戏开发</h2><p>游戏中有很多种怪物，每种怪物都有一个类与之对应。某个玩家创建的具体怪物就是对象<br>怪物的主要动作（成员函数）有：</p>
<ul>
<li>攻击（Attack），针对不同的被攻击者有不同的函数</li>
<li>反击（FightBack），被某个怪物攻击时做出的相应动作</li>
<li>掉血（Hurted），被攻击时会掉血，血量值不同有不同处理，如死亡</li>
</ul>
<p>现在的需求是：已经有CWolf、CGhost两种怪物，需要设计新的怪物CThunderBird，并能满足和其他怪物的交互<br>顶层设计:<br>设置基类 CCreature，并且使CDragon, CWolf等其他类都从CCreature派生而来<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652097.png" alt="image-20221208165241029"><br>非多态的派生类设计：<br>由于每个怪物对于其他怪物的攻击和反击都是不同的，每个怪物类都要设计一组Attack和FightBack：</p>
<pre><code>class class CCreature {
    protected: int nPower ; //代表攻击力
    int nLifeValue ; //代表生命值
};
class CThunderBird : public CCreature {
    public:
    void Attack(CWolf * pWolf) {
        ．．．表现攻击动作的代码
        pWolf-&gt;Hurted( nPower);
        pWolf-&gt;FightBack( this);
    }
    void Attack( CDragon * pDragon) {
        ．．．表现攻击动作的代码
        pDragon-&gt;Hurted( nPower);
        pDragon-&gt;FightBack( this);
    }
    void FightBack( CWolf * pWolf) {
        ．．．．表现反击动作的代码
        pWolf -&gt;Hurted( nPower / 2);
    }
    void FightBack( CDragon * pDragon) {
        ．．．．表现反击动作的代码
        pDragon-&gt;Hurted( nPower / 2 );
    }
    void Hurted ( int nPower) {
        ．．．．表现受伤动作的代码
        nLifeValue -= nPower;
    }
}
</code></pre>
<p>现有n种怪物，CThunderBird类中就得有n个Attack 和n个FightBack成员函数，对于其他类也得新增针对CThunderBird的Attack和FightBack。这种设计工作量过于巨大。原因就在于要区分传入的对象指针。<br>那么能否传入基类的指针呢，这样就不存在为各种类型写几个函数。基类指针要访问派生类的成员，得用虚函数形成多态。多态实现如下：</p>
<pre><code>//基类 CCreature：
class CCreature {
protected :
    int m_nLifeValue, m_nPower;
    public:
    virtual void Attack( CCreature * pCreature) {}
    virtual void Hurted( int nPower) { }
    virtual void FightBack( CCreature * pCreature) {}
};
//派生类 CDragon:
class CDragon : public CCreature {
public:
    virtual void Attack( CCreature * pCreature);
    virtual void Hurted( int nPower);
    virtual void FightBack( CCreature * pCreature);
};

//派生类的成员函数实现具体操作
void CDragon::Attack(CCreature * p) //传入基类指针
{ …表现攻击动作的代码
    p-&gt;Hurted(m_nPower); //多态
    p-&gt;FightBack(this); //多态
}
void CDragon::Hurted( int nPower)
{ …表现受伤动作的代码
    m_nLifeValue -= nPower;
}
void CDragon::FightBack(CCreature * p)
{ …表现反击动作的代码
    p-&gt;Hurted(m_nPower/2); //多态
}

//多态的调用
CDragon Dragon; CWolf Wolf; CGhost Ghost;
CThunderBird Bird；
Dragon.Attack( &amp; Wolf); //调用CWolf::Hurted
Dragon.Attack( &amp; Ghost); //调用CGhost::Hurted
Dragon.Attack( &amp; Bird); //调用CBird::Hurted
</code></pre>
<p>使用多态，新增某个派生类时，已有的类可以原封不动，因为传入基类指针，会“自动”调用正确的派生类函数，开发者只需要设计新增的派生类和其成员函数即可</p>
<h2 id="多态的原理：虚函数表指针"><a href="#多态的原理：虚函数表指针" class="headerlink" title="多态的原理：虚函数表指针"></a>多态的原理：虚函数表指针</h2><p>多态” 的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定，这叫“动态联编”<br>首先分析包含虚函数的类对象的内存分布：</p>
<pre><code>class Base {
public:
int i;
    virtual void Print() { cout &lt;&lt; &quot;Base:Print&quot; ; }
};

class Derived : public Base{
public:
int n;
    virtual void Print() { cout &lt;&lt;&quot;Drived:Print&quot; &lt;&lt; endl; }
};

int main() {
    Derived d;
    cout &lt;&lt; sizeof( Base) &lt;&lt; &quot;,&quot;&lt;&lt; sizeof( Derived ) ;
    return 0;
}
</code></pre>
<p>输出：8, 12<br>为什么类对象的size比成员变量int（4字节）还多4字节？<br>因为包含虚函数的基类，实例化的对象除了成员变量，还包含一个指针（一般4字节），指向虚函数的入口地址，如果有多个虚函数，这些地址连续排列形成虚函数表，指针指向首个虚函数地址。如果这个指针指向基类，就能找到基类的所有虚函数入口，如果指针指向派生类，就能找到派生类的的所有虚函数入口。基类和派生类对象的指针赋值，实际会导致虚函数表指针指向的虚函数入口地址不同，从而调用时不同。<br>如果当前指针指向基类，则调用基类自己的虚函数：</p>
<pre><code>Base b;
pBase = &amp;b;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081652980.png" alt="image-20221208165259927"><br>如果当前指针指向派生类，则调用派生类的虚函数：</p>
<pre><code>Derived d;
pDerived = &amp;d;
pBase = pDerived;
pBase-&gt;Print();
</code></pre>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081653211.png" alt="image-20221208165311145"><br>动态联编的实现：<br>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令<br>而普通函数是编译过程中确定了成员函数的入口地址，不存在运行时根据对象来改变某个函数的入口地址。</p>
<h2 id="虚函数与抽象类"><a href="#虚函数与抽象类" class="headerlink" title="虚函数与抽象类"></a>虚函数与抽象类</h2><p>可以想象得到，前文的游戏使用虚函数的例子是通用的，先设计基类，提炼对象属性，定义虚函数；再派生子类，在子类实现局函数的具体操作。那么问题来了，基类的虚函数有必要实现函数体吗？<br>很多情况，基类只是一个抽象，定义了函数的名称和参数，不需要在基类实现虚函数，全部交给派生类实现。</p>
<ul>
<li>纯虚函数：没有函数体的虚函数</li>
<li>抽象类：包含纯虚函数的类</li>
</ul>
<p>纯虚函数写法：没函数体{}，直接&#x3D;0</p>
<pre><code>class A {
private: int a;
public:
    virtual void Print( ) = 0 ; //纯虚函数
    void fun() { cout &lt;&lt; &quot;fun&quot;; }
};
</code></pre>
<p>抽象类特点：</p>
<ul>
<li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li>
<li>可以创建抽象类的指针和引用，它们可以指向派生类的对象</li>
</ul>
<p>抽象类的指针：</p>
<pre><code>A a ; // 错， A 是抽象类，不能创建对象
A * pa ; // ok,可以定义抽象类的指针和引用
pa = new A ; //错误, A 是抽象类，不能创建对象
</code></pre>
<p>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类<br>抽象类的成员函数可以调用纯虚函数，但是构造函数或析构函数内不能调用纯虚函数</p>
<pre><code>class A {
public:
    virtual void f() = 0; //纯虚函数
    void g( ) { 
        this-&gt;f( ) ; //ok
    }
    A( ){ 
        f( ); // 错误
    }
};
class B:public A{
public:
    void f(){cout&lt;&lt;&quot;B:f()&quot;&lt;&lt;endl; }
};
</code></pre>
<h2 id="虚函数与构造析构函数"><a href="#虚函数与构造析构函数" class="headerlink" title="虚函数与构造析构函数"></a>虚函数与构造析构函数</h2><p>前面考虑了普通成员函数加virtual，可以形成虚函数达到继承类的多态效果。那么构造函数和析构函数呢？</p>
<ul>
<li>不允许以虚函数作为构造函数</li>
<li>类继承需要把基类的析构函数设为虚函数</li>
</ul>
<p>对于常规析构函数，通过基类指针删除派生类对象时，只能调用基类的析构函数。但是合理的做法是，应该先调用派生类的析构函数，然后调用基类的析构函数。解决的方法：把析构函数定义为virtual，由于基类析构函数是虚函数，派生类的同名析构函数自然也是虚函数。<br>什么时候定义虚析构函数</p>
<ul>
<li>一个类只要定义了虚函数，则应该将析构函数也定义成虚函数</li>
<li>一个类打算作为基类使用，则应该将析构函数定义成虚函数</li>
</ul>
<p>虚析构函数用法：通过基类的指针删除派生类对象，会首先调用派生类的析构函数，然后调用基类的析构函数</p>
<pre><code>class son{
public:
    virtual ~son() {cout&lt;&lt;&quot;bye from son&quot;&lt;&lt;endl;};
};
class grandson:public son{
public:
    ~grandson(){cout&lt;&lt;&quot;bye from grandson&quot;&lt;&lt;endl;};
};
int main() {
    son *pson;
    pson= new grandson(); //pson指向派生类grandson
    delete pson;
    return 0;
}
</code></pre>
<p>输出： </p>
<pre><code>bye from grandson
bye from son
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/18/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/18/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">C++面向对象笔记：类和对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-18 16:44:59" itemprop="dateCreated datePublished" datetime="2020-03-18T16:44:59+08:00">2020-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>C++，加的到底是什么？<br>除了基础语法的补充和优化，C++另外几个核心特点是：</p>
<ul>
<li><p>面向对象设计的支持：</p>
<p> 类和对象对变量和函数的封装<br> 类和类之间的继承<br> 继承关系的类之间的函数调用的多态</p>
</li>
<li><p>数据结构和算法的支持<br> STL和各种常用数据类型</p>
</li>
<li><p>高可复用、可拓展的支持<br> 类模板，函数模板<br> 函数、运算符的重载</p>
</li>
</ul>
<p>本文内容：</p>
<ul>
<li>面向对象设计的概念</li>
<li>类和对象的概念及使用</li>
<li>类的几种构造函数</li>
<li>类的析构函数</li>
<li>类对象的this指针</li>
<li>类的嵌套：封闭类</li>
<li>成员的属性：友元和常量成员</li>
</ul>
<h1 id="面向对象设计的概念"><a href="#面向对象设计的概念" class="headerlink" title="面向对象设计的概念"></a>面向对象设计的概念</h1><h2 id="面向过程设计的不足"><a href="#面向过程设计的不足" class="headerlink" title="面向过程设计的不足"></a>面向过程设计的不足</h2><p>程序 &#x3D; 数据结构 + 算法<br>程序由全局变量以及众多相互调用的函数组成，算法以函数的形式实现，用于对数据结构进行操作。<br>结构化程序设计风格中，变量和函数的关系:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081646566.png" alt="image-20221208164648489"><br>其缺陷在于：</p>
<ul>
<li>结构化程序设计中，函数和其所操作的数据结构，没有直观的联系</li>
<li>随着程序规模的增加，程序逐渐难以理解:<br> 某个数据结构到底有哪些函数可以对它进行操作?<br> 某个函数到底是用来操作哪些数据结构的?<br> 任何两个函数之间存在怎样的调用关系?</li>
<li>结构化程序设计难以维护:<br>由于没有“封装”和“隐藏”的概念，要访问某个数据结构中的某个变量，就可以直接访问，那么当该变量的定义有改动的时候，就要把所有访问该变量的语句找出来修改，不利于程序的维护、扩充。</li>
<li>结构化程序设计难以查错:<br>当某个数据结构的值不正确时，难以找出到底是那个函数导致的。</li>
<li>结构化程序设计难以重用：<br>在编写某个程序时，发现其需要的某项功能，在现有的某个程序里已经有了相同或类似的实现，那么自然希望能够将那部分代码抽取出来，在新程序中使用。在结构化程序设计中，随着程序规模的增大，由于程序大量函数、变量之间的关系错综复杂，要抽取这部分代码，会变得十分困难。</li>
</ul>
<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><p>面向对象的程序设计方法，能够较好解决上述问题<br>面向对象的程序 &#x3D; 类 + 类 + …+ 类<br>设计程序的过程，就是设计类（class）的过程<br>面向对象的程序设计方法:</p>
<ul>
<li>将某类客观事物共同特点（<strong>属性</strong>）归纳出来，形成一个数据结构（可以用多个变量描述事物的属性）</li>
<li>将这类事物所能进行的<strong>行为</strong>也归纳出来，形成一个个函数，这些函数可以用来操作数据结构(这一步叫“ <strong>抽象</strong>”）</li>
<li>然后，通过某种语法形式，将数据结构和操作该数据结构的函数“捆绑”在一起，形成一个“ 类”，从而使得数据结构和操作该数据结构的算法呈现出显而易见的紧密关系，这就是“<strong>封装</strong>”</li>
<li>类与类直接又形成<strong>继承、多态</strong>等关系</li>
<li>面向对象的程序设计具有“抽象”，“封装”“继承”“多态”四个基本特点。</li>
</ul>
<p>面向对象设计风格中，变量和函数的关系;<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081647726.png" alt="image-20221208164703654"></p>
<h2 id="语言和风格的无关性"><a href="#语言和风格的无关性" class="headerlink" title="语言和风格的无关性"></a>语言和风格的无关性</h2><p>注意面向过程、面向对象以及其他的风格（如函数式编程等），只是编程风格，其本质都是组织数据结构（事物属性）和算法（对事物的操作）。<br>C++有原生的类的概念，更方便写出面向对象风格的程序<br>Q. C语言没有类，能不能写出面向对象？<br>可以，C的结构体就是对数据的封装，配合函数指针，也能包含函数成员。利用带函数指针的结构体能实现属性和方法的封装，在Linux内核和设备驱动程序中充满了这种面向对象设计风格。事实上，C++的class在编译器处理后就是类似于C的结构体。<br>Q. 什么时候应该面向对象？<br>面向对象对于人的抽象概括的能力要求较高，需要花较多精力在top-down的顶层设计中，通常用于大型的长期维护的程序设计。<br>面向对象的优势在于数据结构组织化，程序时间和空间的开销可能不如面向过程。例如一个对象里的各个数据的生命周期都是捆绑分配和释放的，而面向过程可以更精细管理。在极端资源紧缺的情况，如部分嵌入式开发，面向过程不论代码设计速度和性能都比面向对象好。</p>
<h1 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a>类和对象的概念</h1><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>设计一个程序，接受输入矩形的长和宽，输出面积和周长<br>如何用类来封装？</p>
<ul>
<li>矩形的属性就是长和宽。因此需要两个变量，分别代表长和宽</li>
<li>矩形的操作方法可以有设置长和宽，算面积，算周长。每个操作各用一个函数来实现，且函数都需要用到长和宽这两个属性</li>
<li>将以上属性和方法组合就能形成一个“矩形类”。长、宽变量成为该“矩形类”的“成员变量”，三个函数成为该类的“成员函数”。成员变量和成员函数统称为类的成员。“类”看上去就像“带函数的结构”</li>
</ul>
<p>类的声明：</p>
<pre><code>class CRectangle
&#123;
    public:
        int w, h;
        int Area() &#123;
        return w * h;
    &#125;
    int Perimeter()&#123;
        return 2 * ( w + h);
    &#125;
    void Init( int w_,int h_ ) &#123;
        w = w_; h = h_;
    &#125;
&#125;; //必须有分号
</code></pre>
<p>类的实例化：</p>
<pre><code>int main( )
&#123;
    int w,h;
    CRectangle r; //r是一个对象
    cin &gt;&gt; w &gt;&gt; h;
    r.Init( w,h);
    cout &lt;&lt; r.Area() &lt;&lt; endl &lt;&lt;
    r.Perimeter();
    return 0;
&#125;
</code></pre>
<p>通过类，可以定义变量。类定义出来的变量，也称为类的实例，就是“<strong>对象</strong>”，对象的本质是在内存中分配了一个存放类这个结构的空间。<br>C++中，类的名字就是用户自定义的类型的名字。可以像使用基本类型那样来使用。 CRectangle就是一种用户自定义的类型。</p>
<h2 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h2><ul>
<li><p>和结构变量一样，对象所占用的内存空间的大小，等于所有成员变量的大小之和（考虑内存对齐可能更大）。对于上面的CRectangle类，sizeof(CRectangle)<br>&#x3D; 8</p>
</li>
<li><p>每个对象各有自己的存储空间。一个对象的某个成员变量被改变了，不会影响到另一个对象</p>
</li>
<li><p>和结构变量一样，对象之间可以用 “&#x3D;”进行赋值，但是不能用 “&#x3D;&#x3D;”“!&#x3D;”“&gt;”“&lt;”“&gt;&#x3D;”“&lt;&#x3D;”进行比较，除非这些运算符经过了“重载”。</p>
</li>
</ul>
<p>Q.类分配内存产生对象后，成员变量占用空间，成员函数占不占用空间?<br>普通成员函数不在对象生成时分配函数空间，因为函数是静态绑定的，即函数体指令只占用代码段的一处空间，对象调用该函数之间跳到该空间入口地址，在对象分配时不会在堆或栈再开辟空间存放函数体。<br>但是当类中定义了虚函数，分配对象时要分配4字节（多个虚函数也是4个字节）的指针指向虚函数表。函数跳转地址依赖于运行时才产生的对象里的虚函数表，称为动态绑定，对象调用虚函数时不知道准确的跳转地址，只跳转到虚函数表查找跳转地址，再根据查找结果跳转。</p>
<h2 id="对象访问其成员"><a href="#对象访问其成员" class="headerlink" title="对象访问其成员"></a>对象访问其成员</h2><p>类似于C结构体实例访问其成员的方法，用实例.成员，实例指针-&gt;成员，除此之外C++特有的通过引用访问：实例引用.成员<br>用法1：对象名.成员名</p>
<pre><code>CRectangle r1,r2;
r1.w = 5;
r2.Init(5,4);
</code></pre>
<p>Init函数作用在 r2 上，即Init函数执行期间访问的w 和 h是属于r2 这个对象的, 执行r2.Init 不会影响到r1<br>用法2. 指针-&gt;成员名</p>
<pre><code>CRectangle r1,r2;
CRectangle * p1 = &amp; r1;
CRectangle * p2 = &amp; r2;
p1-&gt;w = 5;
p2-&gt;Init(5,4); //Init作用在p2指向的对象上
</code></pre>
<p>用法3：引用名.成员名</p>
<pre><code>CRectangle r2;
CRectangle &amp; rr = r2;
rr.w = 5;
rr.Init(5,4); //rr的值变了， r2的值也变
</code></pre>
<h1 id="类成员的访问方式"><a href="#类成员的访问方式" class="headerlink" title="类成员的访问方式"></a>类成员的访问方式</h1><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><p>Q. C++将数据和函数封装成类的成员，那么类内成员、内间成员的访问权限如何控制？<br>用下列访问范围关键字来说明类成员可被访问的范围：</p>
<ul>
<li>private: 私有成员，只能在成员函数内访问</li>
<li>public : 公有成员，可以在任何地方访问</li>
<li>protected: 保护成员，用于继承关系的类的成员访问控制</li>
</ul>
<p>定义一个带访问控制的类：</p>
<pre><code>class className &#123;
    private:
    私有属性和函数
    public:
    公有属性和函数
    protected:
    保护属性和函数
&#125;;
</code></pre>
<p>如过某个成员前面没有上述关键字，则缺省地被认为是private私有成员:</p>
<pre><code>class Man &#123;
    int nAge;       //私有成员
    char szName[20]; // 私有成员
public:
    void SetName(char * szName)&#123;
    strcpy( Man::szName,szName);
    &#125;
&#125;;
</code></pre>
<p>在类的成员函数内部，能够访问：</p>
<ul>
<li>当前对象的全部属性、 函数；</li>
<li>同类其它对象的全部属性、函数。</li>
</ul>
<p>在类的成员函数以外的地方，只能够访问该类对象的公有成员<br>注意：<br>通过对象的成员函数，可以访问同类其他对象的任意成员（即使是private）。private、public、protected真正的作用是限制成员变量的直接访问，而通过成员函数来访问成员变量是不受影响的。</p>
<h2 id="访问控制与隐藏"><a href="#访问控制与隐藏" class="headerlink" title="访问控制与隐藏"></a>访问控制与隐藏</h2><p>成员访问控制可以定义类的成员变量能否被任意访问、或通过成员函数访问、能否被继承的子类访问等。这种机制称为对成员变量的<strong>隐藏</strong><br>隐藏的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则所有直接访问成员变量的语句都需要修改<br>一个类成员变量隐藏的例子：</p>
<pre><code> //类定义
    class CEmployee &#123;
    private:
        char szName[30]; //名字
    public :
        int salary; //工资
        void setName(char * name);
        void getName(char * name);
        void averageSalary(CEmployee e1,CEmployee e2);
    &#125;;
    
    //成员函数定义
    void CEmployee::setName( char * name) &#123;
        strcpy( szName, name); //ok
    &#125;
    void CEmployee::getName( char * name) &#123;
        strcpy( name,szName); //ok
    &#125;
    void CEmployee::averageSalary(CEmployee e1,CEmployee e2)&#123;
        cout &lt;&lt; e1.szName; //ok，访问同类其他对象私有成员
        salary = (e1.salary + e2.salary )/2;
    &#125;
    
    //使用类和对象
    int main()
    &#123;
        CEmployee e;
        strcpy(e.szName,&quot;Tom1234567889&quot;); //编译错，不能访问私有成员
        e.setName( &quot;Tom&quot;);  // ok
        e.salary = 5000;    //ok
        return 0;
    &#125;
</code></pre>
<p>如果将上面的程序移植到内存空间紧张的设备上，希望将szName改为char szName[5]，若szName不是私有，就要找出所有类似strcpy(e.szName,”Tom1234567889”);这样的语句进行修改，以防止数组越界。如果将szName变为私有，那么程序中就不可能出现（除非在类的内部）strcpy(e.szName,”Tom1234567889”);这样的语句，所有对szName的访问都是通过成员函数来进行，比如：e.setName( “Tom12345678909887”);如果szName改短了，上面的语句也不需要找出来修改，只要改setName成员函数，在里面确保不越界就可以了<br>除了使用类和隐藏机制，C++兼容C的struct结构体，也称为类。和用”class”的唯一区别是未说明是公有还是私有的成员，struct类的所有成员都是公有的。</p>
<pre><code>struct CEmployee &#123;
    char szName[30]; //公有!!
    public :
    int salary; //工资
    void setName(char * name);
    void getName(char * name);
    void averageSalary(CEmployee
    e1,CEmployee e2);
&#125;;
</code></pre>
<h2 id="类成员函数的重载和缺省参数"><a href="#类成员函数的重载和缺省参数" class="headerlink" title="类成员函数的重载和缺省参数"></a>类成员函数的重载和缺省参数</h2><p>同普通函数一样，类封装后的成员函数可以重载，可以有缺省参数</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x=0 , int y = 0 );
    void valueX( int val ) &#123; x = val ;&#125;
    int valueX() &#123; return x; &#125;
&#125;;

void Location::init( int X, int Y)
&#123;
    x = X;
    y = Y;
&#125;

int main() &#123;
    Location A,B;
    A.init(5);  //使用init缺省y=0
    A.valueX(5);    //重载，使用valueX(int)
    cout &lt;&lt; A.valueX();     //重载，使用valueX()
    return 0;
&#125;
</code></pre>
<p>输出：5<br>注意：重载和缺省的函数在调用时可能冲突，存在二义性：</p>
<pre><code>class Location &#123;
    private :
    int x, y;
    public:
    void init( int x =0, int y = 0 );
    void valueX( int val = 0) &#123; x = val; &#125;
    int valueX() &#123; return x; &#125;
&#125;;

Location A;
A.valueX(); //错误，编译器无法判断调用哪个valueX
</code></pre>
<h1 id="类对象的创建与释放"><a href="#类对象的创建与释放" class="headerlink" title="类对象的创建与释放"></a>类对象的创建与释放</h1><h2 id="普通构造函数"><a href="#普通构造函数" class="headerlink" title="普通构造函数"></a>普通构造函数</h2><p>定义一个类只是定义一种数据结构类型，类实例化后在内存中才存在改类的对象。类实例化成对象可以在函数的栈中，或者动态分配在堆中</p>
<pre><code>ClassA a;   //该语句在函数内（如main）时，在main的堆栈中分配内存
ClassA *pa = new ClassA;    //在堆中分配，需要delete手动释放
</code></pre>
<p>那么问题来了，分配的内存里的内容是什么？<br>不知道是什么值，只知道这块内存是被其他进程释放过，当前程序可以读写，释放时不会把值清零。<br>在C语言创建一个结构体变量，可以顺便初始化为全0</p>
<pre><code>StructA a = &#123;0&#125;; //单层结构体
StructB b = &#123;&#123;0&#125;&#125;； //嵌套的结构体
</code></pre>
<p>C++也支持创建类时自动初始化，采用与类同名的成员函数的方法。这就是<strong>构造函数（constructor）</strong><br>构造函数：</p>
<ul>
<li>成员函数的一种，名字与类名相同，可以有参数，不能有返回值(void也不行)</li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作</li>
<li>如果定义了构造函数，则编译器不生成默认的无参数构造函数</li>
<li>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</li>
<li>一个类可以有多个构造函数，即构造函数也可以重载</li>
</ul>
<p>注意：构造函数不负责对象的内存分配，其关键作用是对象成员的值初始化。真正做对象分配的语句通常是new，new做两件事：给类分配内存形成对象，调用对象的构造函数。考虑一下也可知道，连对象都没有的情况，怎么能调用对象的构造函数分配内存呢？注意构造函数不给自身对象分配内存，但是构造函数可以做分配内存操作，比如对指针成员指向的空间分配内存。<br>使用默认构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i);
&#125;; //编译器自动生成默认构造函数
Complex c1; //默认构造函数被调用
Complex * pc = new Complex; //默认构造函数被调用
</code></pre>
<p>使用自定义的带参构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    Complex( double r, double i = 0);
&#125;;
    Complex::Complex( double r, double i) &#123;
    real = r; imag = i;
&#125;

Complex c1; // error, 缺少构造函数的参数
Complex * pc = new Complex; // error, 没有参数
Complex c1(2); // OK
Complex c1(2,4), c2(3,5);
Complex * pc = new Complex(3,4);
</code></pre>
<p>使用重载的构造函数：</p>
<pre><code>class Complex &#123;
    private :
    double real, imag;
    public:
    void Set( double r, double i );
    Complex(double r, double i );
    Complex (double r );
    Complex (Complex c1, Complex c2);
&#125;;

Complex::Complex(double r, double i)
&#123;
    real = r; imag = i;
&#125;
Complex::Complex(double r)
&#123;
    real = r; imag = 0;
&#125;
Complex::Complex (Complex c1, Complex c2);
&#123;
    real = c1.real+c2.real;
    imag = c1.imag+c2.imag;
&#125;

Complex c1(3) , c2 (1,0), c3(c1,c2);
// c1 = &#123;3, 0&#125;, c2 = &#123;1, 0&#125;, c3 = &#123;4, 0&#125;;
</code></pre>
<p>构造函数应该是public的， private构造函数不能直接用来初始化对象</p>
<pre><code>class CSample&#123;
private:
    CSample() &#123;&#125;
&#125;;

int main()&#123;
    CSample Obj; //err. 唯一构造函数是private
    return 0;
&#125;
</code></pre>
<p>对于多个对象的实例化，可以用对象数组,构造函数的调用次数&#x3D;对象个数，重载哪一个构造函数取决于每个对象的初始化方式。</p>
<pre><code>class CSample &#123;
    int x;
    public:
    CSample() &#123;
        cout &lt;&lt; &quot;Constructor 1 Called&quot; &lt;&lt; endl;
    &#125;
    CSample(int n) &#123;
        x = n;
        cout &lt;&lt; &quot;Constructor 2 Called&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main()&#123;
    CSample array1[2];  //两次默认构造函数
    cout &lt;&lt; &quot;step1&quot;&lt;&lt;endl;
    CSample array2[2] = &#123;4,5&#125;;  //两次带参构造函数
    cout &lt;&lt; &quot;step2&quot;&lt;&lt;endl;
    CSample array3[2] = &#123;3&#125;;    //第一个带参构造，第二个默认构造
    cout &lt;&lt; &quot;step3&quot;&lt;&lt;endl;
    CSample * array4 = new CSample[2];  //两次默认构造
    delete []array4;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Constructor 1 Called
Constructor 1 Called
step1
Constructor 2 Called
Constructor 2 Called
step2
Constructor 2 Called
Constructor 1 Called
step3
Constructor 1 Called
Constructor 1 Called
</code></pre>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>定义：拷贝构造函数(copy constructor)是构造函数的一种，特点是：</p>
<ul>
<li>只有一个参数:对同类对象的引用</li>
<li>入参必须是对象的引用，形如 X::X( X&amp; ) 或 X::X(const X &amp;), 后者以常量对象作为参数</li>
<li>如果用户没有定义拷贝构造函数，编译器生成默认的拷贝构造函数，且它完成复制对象的功能。</li>
</ul>
<p>拷贝构造函数也称为复制构造函数<br>调用形式如下。默认（普通）构造函数和默认拷贝构造函数都是编译生成，且并存的</p>
<pre><code>class Complex &#123;
private :
    double real,imag;
&#125;;
Complex c1; //调用缺省无参构造函数
Complex c2(c1);//调用缺省的复制构造函数,将 c2 初始化成和c1一样
</code></pre>
<p>如果定义的自己的拷贝构造函数，则默认的拷贝构造函数不会生成<br>也就是说，自定义的带参拷贝构造函数和编译器生成的默认拷贝构造函数，不存在重载关系；而一个类有多个自定义的带参拷贝构造函数是允许的，可以重载。这一特点对于普通构造函数一样。</p>
<pre><code>class Complex &#123;
public :
    double real,imag;
    Complex()&#123; &#125;
    Complex( const Complex &amp; c ) &#123;
        real = c.real;
        imag = c.imag;
        cout &lt;&lt; “Copy Constructor called”;
    &#125;
&#125;;
Complex c1;
Complex c2(c1); //调用自己定义的复制构造函数，输出 Copy Constructor called
</code></pre>
<p>注意：拷贝构造函数传入的是同类的引用，而不是同类的对象<br>不允许有形如 X::X( X)的构造函数。因为成员函数入参由实参复制到形参实际会调用拷贝构造函数，拷贝构造函数作为成员函数也是一样，因此会有循环定义，即拷贝构造函数的执行需要调用拷贝构造函数的无限循环，用引用作为入参可以解决此问题。这点类似于C结构体允许有结构体指针成员，指向该结构体类型的实例，而不允许结构体有自身结构体的自接实例，这样会照成分配内存空间上的无限循环。</p>
<pre><code>class CSample &#123;
    CSample( CSample c ) &#123;&#125; //错，不允许这样的构造函数
&#125;
</code></pre>
<h3 id="拷贝构造函数的调用"><a href="#拷贝构造函数的调用" class="headerlink" title="拷贝构造函数的调用"></a>拷贝构造函数的调用</h3><p>以下三种情况会调用类对象的拷贝构造函数<br>1)用一个对象去初始化同类的另一个对象：</p>
<pre><code>Complex c2(c1);
Complex c2 = c1; //初始化语句，非赋值语句
</code></pre>
<p>2)类的对象作为函数入参：如果某函数有参数是类A的对象，那么该函数被调用时，类A的拷贝构造函数将被调用：</p>
<pre><code>class A
&#123;
public:
    A() &#123; &#125;;
    A( A &amp; a) &#123;
        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;
    &#125;
&#125;;

void Func(A a1)&#123; &#125;;
int main()&#123;
    A a2;
    Func(a2);  //传参是类A的对象
    return 0;
&#125;
</code></pre>
<p>输出: Copy constructor called<br>3) 类的对象作为函数返回值：如果函数的返回值是类A的对象，函数返回时，A的拷贝构造函数被调用：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int v;</span><br><span class="line">    A(int n) &#123; v = n; &#125;;</span><br><span class="line">    A( const A &amp; a) &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A Func() &#123;</span><br><span class="line">    A a(4);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; Func().v &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>输出：</p>
<pre><code>Copy constructor called
4
</code></pre>
<p>小结：对象作为入参和返回值会调用拷贝构造函数，对象初始化新对象也会调用。</p>
<h3 id="禁用拷贝构造函数"><a href="#禁用拷贝构造函数" class="headerlink" title="禁用拷贝构造函数"></a>禁用拷贝构造函数</h3><p>Q. 调用拷贝构造函数会形成对象的复制品，开销较大，如何禁用拷贝构造函数？<br>使用对象的引用，不自接把对象作为函数的入参出参。<br>Q.对象的引用会导致新问题：函数内修改了引用怎么办，原对象也会改<br>使用const引用，对象实参就不存在被函数修改的可能<br>使用对象的常引用，应用于对象作为函数入参出参，又不希望调用拷贝构造函数的情况</p>
<pre><code>void fun(const CMyclass &amp; obj) &#123;
//函数中任何试图改变 obj值的语句都将是变成非法
&#125;
</code></pre>
<h3 id="对象的赋值和复制"><a href="#对象的赋值和复制" class="headerlink" title="对象的赋值和复制"></a>对象的赋值和复制</h3><p>注意区分对象的赋值和复制：</p>
<ul>
<li><p>对象赋值是类的所有数据成员的一一对应赋值，其本质是对已分配内存的对象，进行数据成员的初始化</p>
</li>
<li><p>对象复制 &#x3D; 分配新对象对象空间 + 对新对象成员的赋值初始化。对象复制是要包含空间分配操作的</p>
</li>
</ul>
<p>两个已分配内存的对象间的赋值并不会导致拷贝构造函数被调用</p>
<pre><code>//声明及初始化，调用拷贝构造函数
Complex c2 = c1; 
//先声明对象，再赋值,不调用拷贝构造函数，调用默认构造函数然后赋值
Complex c2；
c2 = c1;    
</code></pre>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>当类对象有指针成员时，拷贝构造函数遇到一个问题，是只拷贝指针，还是连同指针指向的空间一起拷贝？</p>
<ul>
<li>浅拷贝：只拷贝指针成员</li>
<li>深拷贝：拷贝指针成员，并拷贝其指向的内存空间数据<br> 由于深拷贝的实现用到“&#x3D;”运算符重载，在运算符重载一节详述</li>
</ul>
<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>构造函数是能创建对象并初始化值的函数，将普通变量转换从类对象并分配内存空间的构造函数是转换构造函数。</p>
<ul>
<li>定义转换构造函数的目的是实现类型的自动转换（变量-&gt;对象）</li>
<li>只有一个参数，且不是拷贝构造函数的构造函数，就是转换构造函数</li>
<li>变量被赋值给对象时，编译器会自动调用转换构造函数，建立一个无名的临时对象</li>
</ul>
<p>隐式的转换构造函数：</p>
<pre><code>    class Complex &#123;
    public:
        double real, imag;
        Complex( int i) &#123;//类型转换构造函数
            cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
            real = i; imag = 0;
        &#125;
        Complex(double r,double i) &#123;real = r; imag = i; &#125;
    &#125;;
    
    int main ()
    &#123;
        Complex c1(7,8);
        Complex c2 = 12;
        c1 = 9;     // 9被自动转换成一个临时Complex对象
        cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
        return 0;
    &#125;
</code></pre>
<p>显式的转换构造函数：</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    explicit Complex( int i) &#123;  //显式类型转换构造函数
        cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl;
        real = i; imag = 0;
    &#125;
    Complex(double r,double i) &#123;real = r; imag = i; &#125;
&#125;;
int main () &#123;
    Complex c1(7,8);
    Complex c2 = Complex(12);
    c1 = 9;         // error, 9不能被自动转换成一个临时Complex对象
    c1 = Complex(9) //ok
    cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><h3 id="析构函数的概念"><a href="#析构函数的概念" class="headerlink" title="析构函数的概念"></a>析构函数的概念</h3><p>**析构函数(destructors)**用于对象生命周期结束前（如函数中的对象在函数返回时消失），释放对象的内存占用，以及其他的准备工作。<br>构造函数和析构函数在对象生命周期的角色从逻辑上讲是开始和结束的关系，但具体操作不一样：构造函数不为对象分配内存，只给成员赋初值；而析构函数一般要释放对象的内存<br>析构函数的特点：</p>
<ul>
<li>名字与类名相同，在前面加‘~’，没有参数和返回值，一个类最多只能有一个析构函数</li>
<li>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。</li>
<li>如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做</li>
<li>如果定义了析构函数，则编译器不生成缺省析构函数</li>
</ul>
<p>析构函数例子：</p>
<pre><code>class String&#123;
private :
    char * p;
    public:
    String () &#123;
        p = new char[10];
    &#125;
    ~ String () ;
&#125;;

String ::~ String()
&#123;
    delete [] p;
&#125;
</code></pre>
<p>对象数组的生命期结束时，每个对象的析构函数都会被调用。</p>
<pre><code>class Ctest &#123;
public:
    ~Ctest() &#123; cout&lt;&lt; &quot;destructor called&quot; &lt;&lt; endl; &#125;
&#125;;

int main () &#123;
    Ctest array[2];
    cout &lt;&lt; &quot;End Main&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>End Main
destructor called
destructor called
</code></pre>
<h3 id="析构函数的调用"><a href="#析构函数的调用" class="headerlink" title="析构函数的调用"></a>析构函数的调用</h3><p>析构函数被调用有以下几种情况<br>1)delete运算导致析构函数调用：</p>
<pre><code>Ctest * pTest;
pTest = new Ctest;  //构造函数调用
delete pTest;       //析构函数调用
---------------------------------------------------------
pTest = new Ctest[3];   //构造函数调用3次
delete [] pTest;        //析构函数调用3次
</code></pre>
<p>若new一个对象数组，那么用delete释放时应该写 []。否则只delete一个对<br>象(调用一次析构函数)<br>2)析构函数在对象作为函数返回值返回后被调用。其原理是，对象作为函数的入参，出参时，都是临时生成的对象，传完就调用析构函数销毁。</p>
<pre><code>class CMyclass &#123;
public:
    ~CMyclass() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125;
&#125;;
CMyclass obj;
CMyclass fun(CMyclass sobj ) &#123; //参数对象消亡也会导致析
                                //构函数被调用
    return sobj;                //函数调用返回时生成临时对象返回
&#125;
int main()&#123;
    obj = fun(obj); //函数调用的返回值（临时对象）被
    return 0;       //用过后，该临时对象析构函数被调用
&#125;
</code></pre>
<p>输出：</p>
<pre><code>destructor
destructor
destructor
</code></pre>
<h2 id="构造与析构的时序"><a href="#构造与析构的时序" class="headerlink" title="构造与析构的时序"></a>构造与析构的时序</h2><p>总体原则：类似堆栈的先入后出原则：先构造的后析构<br>几个关键分类：<br>临时对象：赋值时创建，赋完值就消亡，生命周期似乎就一条指令<br>局部对象：在{}范围内存在，{}结束时消亡<br>全局、静态对象：从创建开始，在程序整个运行期间存在，程序结束时消亡。<br>一个例子：</p>
<pre><code>class Demo &#123;
        int id;
    public:
        Demo(int i) &#123;
            id = i;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;
        &#125;
        ~Demo() &#123;
            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; &quot; destructed&quot; &lt;&lt; endl;
        &#125;
&#125;;

Demo d1(1);
void Func()
&#123;
    static Demo d2(2);
    Demo d3(3);
    cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;
&#125;

int main () &#123;
    Demo d4(4);
    d4 = 6;
    cout &lt;&lt; &quot;main&quot; &lt;&lt; endl;
    &#123; 
        Demo d5(5);
    &#125;
    Func();
    cout &lt;&lt; &quot;main ends&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出结果:</p>
<pre><code>id=1 constructed    //全局对象d1
id=4 constructed    //构造函数d4
id=6 constructed    //转换构造函数d4
id=6 destructed     //临时对象赋值完毕，消亡
main
id=5 constructed    //构造函数d5
id=5 destructed     //d5作用域结束，消亡
id=2 constructed    //Fun构造静态对象d2(等同全局对象)
id=3 constructed    //构造局部对象d3
func
id=3 destructed     //Fun返回，d3消亡
main ends       
id=6 destructed     //Main的局部对象d4消亡（id=6）
id=2 destructed     //整个程序结束，全局对象d2消亡
id=1 destructed     //整个程序结束，全局对象d1消亡
</code></pre>
<h1 id="类对象的指针：this指针"><a href="#类对象的指针：this指针" class="headerlink" title="类对象的指针：this指针"></a>类对象的指针：this指针</h1><p>this指针是在类成员函数内，指向当前类对象的指针。<br>注意：</p>
<ul>
<li>this指针是指向当前对象的，所谓当前，是指调用成员函数时，是通过所在的对象的指针来调用</li>
<li>this指针体现的是成员函数和对象的关系，如果是静态成员函数，没有this指针，因为静态成员函数不从属于对象</li>
</ul>
<p>为什么this指针如此特殊，需要单独命名？这涉及到C++的类的实现原理。</p>
<h2 id="C-的类与C的结构体"><a href="#C-的类与C的结构体" class="headerlink" title="C++的类与C的结构体"></a>C++的类与C的结构体</h2><p>在C++早期，C++代码被编译器翻译成C代码，再由C编译器编译<br>类的实现原理和C的结构体有密切关系，下面是类和结构体的转换：<br>1)C++的类：</p>
<pre><code>class CCar &#123;
    public:
        int price;
        void SetPrice(int p);
&#125;;

void CCar::SetPrice(int p)
&#123; price = p; &#125;

int main()
&#123;
    CCar car;
    car.SetPrice(20000);
    return 0;
&#125;
</code></pre>
<p>2)C的结构体实现类的功能</p>
<pre><code>struct CCar &#123;
    int price;
&#125;;

void SetPrice(struct CCar * this, int p)
&#123; this-&gt;price = p; &#125;

int main() &#123;
    struct CCar car;
    SetPrice( &amp; car,
    20000);
    return 0;
&#125;
</code></pre>
<p>用C实现面向对象(CCar结构体)，方法(SetPrice)传入的参数是结构体对象的指针(struct CCar * this)</p>
<h2 id="C-的this指针"><a href="#C-的this指针" class="headerlink" title="C++的this指针"></a>C++的this指针</h2><p>成员函数（非static）可以直接使用this来代表指向该函数作用的对象的指针</p>
<pre><code>class Complex &#123;
public:
    double real, imag;
    void Print() &#123; cout &lt;&lt; real &lt;&lt; &quot;,&quot; &lt;&lt; imag ; &#125;
    Complex(double r,double i):real(r),imag(i)&#123; &#125;   //初始化列表
    Complex AddOne() &#123;
        this-&gt;real ++;  //等价于 real++
        this-&gt;Print();  //等价于 Print()
        return * this;
    &#125;
&#125;;

int main() &#123;
    Complex c1(1,1),c2(0,0);
    c2 = c1.AddOne();
    return 0;
&#125; //输出 2,1
</code></pre>
<p>对象的this指针通常隐式存在：</p>
<ul>
<li>成员函数（非static）的入参实际隐式地有一个this指针参数</li>
<li>成员函数访问成员变量，也是隐式的通过this指针访问</li>
<li>通过对象的指针调用成员函数，本质也是传入this指针</li>
</ul>
<p>如果成员函数不访问成员变量，可以传入NULL的对象指针：</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  //等价于 void Hello(A * this ) &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p)
&#125; // 输出： hello
</code></pre>
<p>如果成员函数访问了成员变量，实际是通过成员函数传入的this指针来访问，此时指针不可为NULL</p>
<pre><code>class A
&#123;
    int i;
    public:
    void Hello() &#123; cout &lt;&lt; i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
&#125;;  
//等价于void Hello(A * this ) &#123; cout &lt;&lt; this-&gt;i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;
//this若为NULL，则出错！！
int main()
&#123;
    A * p = NULL;
    p-&gt;Hello(); //等价于Hello(p);
&#125; //出错
</code></pre>
<h2 id="静态成员的概念"><a href="#静态成员的概念" class="headerlink" title="静态成员的概念"></a>静态成员的概念</h2><p>静态成员：在定义前面加了static关键字的成员、</p>
<pre><code>class CRectangle
&#123;
    private:
    int w, h;
    static int nTotalArea; //静态成员变量
    static int nTotalNumber;
    public:
    CRectangle(int w_,int h_);
    ~CRectangle();
    static void PrintTotal(); //静态成员函数
&#125;;
</code></pre>
<ul>
<li>普通成员变量每个对象有各自的一份；而静态成员变量是全局共有的一份，为所有对象共享</li>
<li>同一个类的成员函数，不论静不静态都是一份代码段</li>
<li>普通成员函数必须具体作用于某个对象（也可以理解为绑定），而静态成员函数并不具体作用于某个对象</li>
<li>因此静态成员（变量或者函数），不需要通过对象就能访问</li>
</ul>
<p>sizeof求类大小，不会计算静态成员变量，因为不属于类的一部分（从空间占用上讲）。</p>
<pre><code>class CMyclass &#123;
int n;
static int s;
&#125;;  // sizeof(CMyclass) 等于 4
</code></pre>
<h2 id="访问静态成员"><a href="#访问静态成员" class="headerlink" title="访问静态成员"></a>访问静态成员</h2><p>一下几种方法访问,可以归纳为两种：通过类名访问，通过对象访问<br>1)类名::成员名</p>
<pre><code>CRectangle::PrintTotal();
</code></pre>
<p>2)对象名.成员名</p>
<pre><code>CRectangle r; 
r.PrintTotal();
</code></pre>
<p>3)指针-&gt;成员名</p>
<pre><code>CRectangle * p = &amp;r; 
p-&gt;PrintTotal();
</code></pre>
<p>4)引用.成员名</p>
<pre><code>CRectangle &amp; ref = r; 
int n = ref.nTotalNumber;
</code></pre>
<h2 id="静态成员函数与this指针"><a href="#静态成员函数与this指针" class="headerlink" title="静态成员函数与this指针"></a>静态成员函数与this指针</h2><ul>
<li>静态成员函数中不能使用 this 指针！</li>
<li>因为静态成员函数并不具体作用与某个对象!</li>
<li>因此静态成员函数的真实的参数的个数，就是程序中写出的参数个数！</li>
</ul>
<p>前面讲，C++的作用是封装数据，静态成员似乎破坏这一目的，那么静态成员有什么作用？<br>为了兼容C的全局变量与函数</p>
<ul>
<li>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在</li>
<li>静态成员函数本质上是全局函数</li>
<li>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解</li>
</ul>
<h2 id="静态成员函数的使用场景"><a href="#静态成员函数的使用场景" class="headerlink" title="静态成员函数的使用场景"></a>静态成员函数的使用场景</h2><p>对于需要全局维护的数据，可以使用静态成员变量，并通过静态成员函数访问。<br>考虑一个图形处理程序，需要随时知道矩形的总数和总面积</p>
<ul>
<li>每个矩形封装成类的对象</li>
<li>总数和总面积是类的静态成员（等价于全局变量）</li>
</ul>
<p>类定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CRectangle</span><br><span class="line">    &#123;</span><br><span class="line">    private:</span><br><span class="line">        int w, h;</span><br><span class="line">        static int nTotalArea;</span><br><span class="line">        static int nTotalNumber;</span><br><span class="line">    public:</span><br><span class="line">        CRectangle(int w_,int h_);</span><br><span class="line">        ~CRectangle();</span><br><span class="line">        static void PrintTotal();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数定义：</p>
<pre><code>CRectangle::CRectangle(int w_,int h_)
&#123;
    w = w_;
    h = h_;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
CRectangle::~CRectangle()
&#123;
    nTotalNumber --;
    nTotalArea -= w * h;
&#125;
void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl;
&#125;
</code></pre>
<p>类对象的调用：</p>
<pre><code>int CRectangle::nTotalNumber = 0;
int CRectangle::nTotalArea = 0;
// 必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。
int main()
&#123;
    CRectangle r1(3,3), r2(2,2);
    //cout &lt;&lt; CRectangle::nTotalNumber; 
    //错误 , 静态的私有变量也只能通过成员函数访问，静态不等于全局可访问
    CRectangle::PrintTotal();
    r1.PrintTotal();
    return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>2,13
2,13
</code></pre>
<p>注意两点：</p>
<ul>
<li>静态成员变量是全局共有的一份存储，但private的静态成员只能通过类的成员函数访问。注意区分全局存储和全局访问，静态成员只有全局存储特性，没有全局可访问特性。</li>
<li>静态成员函数，不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
<p>以下静态成员函数访问错误：</p>
<pre><code>void CRectangle::PrintTotal()
&#123;
    cout &lt;&lt; w &lt;&lt; &quot;,&quot; &lt;&lt; nTotalNumber &lt;&lt; &quot;,&quot; &lt;&lt; nTotalArea &lt;&lt; endl; //错误
&#125;
CRetangle::PrintTotal(); //解释不通 w 到底是属于那个对象的
</code></pre>
<p> 以上例子还有缺陷：<br> 在使用静态成员时，特别是类的构造和析构会修改该静态成员，如前文的CRectangle类的构造函数有nTotalNumber++操作，析构有nTotalNumber–。这个时候要考虑构造和析构函数是否覆盖到所有类型（普通构造，拷贝构造，转换构造）<br> 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象：</p>
<ul>
<li>调用一个以CRectangle类对象作为参数的函数时</li>
<li>调用一个以CRectangle类对象作为返回值的函数时</li>
</ul>
<p>临时对象在消亡时会调用析构函数，减少nTotalNumber和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber和nTotalArea的值，因为设计类时漏掉了拷贝构造的情况<br>解决办法：为CRectangle类写一个拷贝构造函数：</p>
<pre><code>CRectangle :: CRectangle(CRectangle &amp; r )
&#123;
    w = r.w; h = r.h;
    nTotalNumber ++;
    nTotalArea += w * h;
&#125;
</code></pre>
<p>这样nTotalNumber和nTotalArea全局计数就是准确的</p>
<h1 id="类的嵌套：封闭类"><a href="#类的嵌套：封闭类" class="headerlink" title="类的嵌套：封闭类"></a>类的嵌套：封闭类</h1><h2 id="封闭类的基本概念"><a href="#封闭类的基本概念" class="headerlink" title="封闭类的基本概念"></a>封闭类的基本概念</h2><p>再来把C++的类和C结构体对比下：</p>
<ul>
<li>C：结构体的成员可以是基础变量，基础变量的指针，结构体的指针，其他复合类型的指针</li>
<li>C++：类的成员变量可以是基础变量，及其指针、引用，可不可以是类对象？类对象的引用和指针？</li>
</ul>
<p>于是引入类嵌套类对象的情况：有成员对象的类叫封闭类（enclosing class)<br>一个示例：写一个汽车类，包含轮胎和引擎类对象<br>轮胎和引擎类：</p>
<pre><code>class CTyre //轮胎类
    &#123;
    private:
        int radius; //半径
        int width; //宽度
    public:
        CTyre(int r,int w):radius(r),width(w) &#123; &#125;   //用初始化列表构造
    &#125;;
    
class CEngine //引擎类
&#123;
&#125;;
</code></pre>
<p>汽车类：</p>
<pre><code>class CCar &#123; //汽车类
private:
    int price; //价格
    CTyre tyre;
    CEngine engine;
public:
    CCar(int p,int tr,int tw );
&#125;;
CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw) //用初始化列表构造
&#123;
&#125;;
</code></pre>
<p>汽车类的使用：</p>
<pre><code>int main()
&#123;
    CCar car(20000,17,225); //传入初始化列表
    return 0;
&#125;
</code></pre>
<h2 id="初始化列表构造封闭类"><a href="#初始化列表构造封闭类" class="headerlink" title="初始化列表构造封闭类"></a>初始化列表构造封闭类</h2><p>对于封闭类，有几个问题就凸显出来：</p>
<ul>
<li>构造一个封闭类，还要构造其嵌套的类</li>
<li>构造时序是怎样的</li>
<li>析构时序是怎样的</li>
</ul>
<p>上例中，如果 CCar类不定义构造函数，下面的语句会编译出错：CCar car;<br>因为CCar不传初始化值给嵌套类CTyre，编译器不知道该如何初始化car.tyre的成员变量<br>而car.engine的初始化没问题，因为不用初始化成员变量，用默认构造函数即可<br>为了解决封闭类的嵌套类成员的初始化问题，构造函数引入新的初始化方法：</p>
<ul>
<li>初始化列表：将成员初始化从构造函数体，移到函数名后面，只是换了形式，但是方便了封闭类各嵌套类的初始化，不用开发者自己到函数体写构造函数内容</li>
<li>成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。</li>
</ul>
<p>封闭类都是通过构造函数的初始化列表，层层传入嵌套类的构造函数：</p>
<pre><code>CCar::CCar(int p,int tr,int tw):price(p),tyre(tr, tw)&#123;&#125;;
//p, tr, tw是传入的初始化值; price,tyre是CCar对象的两个成员
CCar car(20000,17,225);
//Car的price = 20000, Car的tyre的radius = 17，width = 225
</code></pre>
<p> 上例是普通构造函数，对于封闭类的拷贝构造函数：</p>
<ul>
<li>封闭类对象是用拷贝构造函数初始化的，其成员对象也用拷贝构造函数初始化</li>
</ul>
<p>测试用例：</p>
<pre><code>class A
&#123;
public:
    A() &#123; cout &lt;&lt; &quot;default&quot; &lt;&lt; endl; &#125;
    A(A &amp; a) &#123; cout &lt;&lt; &quot;copy&quot; &lt;&lt; endl;&#125;
&#125;;
class B &#123; A a; &#125;;

int main()
&#123;
    B b1,b2(b1);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>default
Copy
</code></pre>
<p>下面考虑封闭类构造和析构的时序</p>
<ul>
<li>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数、</li>
<li>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关</li>
<li>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反</li>
</ul>
<p>一个测试示例</p>
<pre><code>class CTyre &#123;
    public:
        CTyre() &#123; cout &lt;&lt; &quot;CTyre contructor&quot; &lt;&lt; endl; &#125;
        ~CTyre() &#123; cout &lt;&lt; &quot;CTyre destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CEngine &#123;
    public:
        CEngine() &#123; cout &lt;&lt; &quot;CEngine contructor&quot; &lt;&lt; endl; &#125;
        ~CEngine() &#123; cout &lt;&lt; &quot;CEngine destructor&quot; &lt;&lt; endl; &#125;
&#125;;
class CCar &#123;
    private:
        CEngine engine;
        CTyre tyre;
    public:
        CCar( ) &#123; cout &lt;&lt; “CCar contructor” &lt;&lt; endl; &#125;
        ~CCar() &#123; cout &lt;&lt; &quot;CCar destructor&quot; &lt;&lt; endl; &#125;
&#125;;

int main()&#123;
CCar car;
return 0;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code>CEngine contructor
CTyre contructor
CCar contructor
CCar destructor
CTyre destructor
CEngine destructor
</code></pre>
<h1 id="类的成员属性：友元和常量成员"><a href="#类的成员属性：友元和常量成员" class="headerlink" title="类的成员属性：友元和常量成员"></a>类的成员属性：友元和常量成员</h1><h2 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h2><p>友元(friend)分为友元函数和友元类两种<br>一个类的private成员，只能通过类自己的成员函数访问，那么其他类的成员函数想访问这个类的private成员怎么办？友元可以解决这种需求</p>
<ol>
<li><p>友元函数: 一个类的友元函数可以访问该类的私有成员<br>即类A内可以声明其他类B的成员函数或者全局函数，加前缀friend，这些以friends开头的函数就可访问类A的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class CCar ; //提前声明 CCar类，以便后面的CDriver类使用</span><br><span class="line"> class CDriver</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">         void ModifyCar( CCar * pCar) ; //改装汽车</span><br><span class="line"> &#125;;</span><br><span class="line"> class CCar</span><br><span class="line"> &#123;</span><br><span class="line">     private:</span><br><span class="line">         int price;</span><br><span class="line">         friend int MostExpensiveCar( CCar cars[], int total); //声明友元</span><br><span class="line">         friend void CDriver::ModifyCar(CCar * pCar); //声明友元</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> void CDriver::ModifyCar( CCar * pCar)</span><br><span class="line"> &#123;</span><br><span class="line">     pCar-&gt;price += 1000; //访问CCar成员，汽车改装后加价</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int MostExpensiveCar( CCar cars[],int total)//求最贵汽车的价格</span><br><span class="line"> &#123;</span><br><span class="line">     int tmpMax = -1;</span><br><span class="line">     for( int i = 0;i &lt; total; ++i )</span><br><span class="line">     if( cars[i].price &gt; tmpMax) //访问CCar成员</span><br><span class="line">     tmpMax = cars[i].price;</span><br><span class="line">     return tmpMax;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了普通成员函数，也可以将类构造、析构函数说明为另一个类的友元</p>
<p>2)友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员<br>如果是类的嵌套（封闭类），声明为friend的类A可以调用自己的成员函数访问与它为friend关系的类B的私有成员，而不必调用类B的成员函数。</p>
<pre><code>class CCar
&#123;
private:
    int price;
    friend class CDriver; //声明CDriver为友元类
&#125;;
class CDriver
&#123;
public:
    CCar myCar;
    void ModifyCar() &#123;  //改装汽车
    myCar.price += 1000;   //因CDriver是CCar的友元类，故此处可以访问其私有成员
    &#125;
&#125;;

int main()&#123; return 0; &#125;
</code></pre>
<p>友元类之间的关系不能传递，不能继承。就是说A和B是friend,B和C是friend,但A和C不一定是friend。父类之间的friend关系，子类不一定能传承。</p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>如果不希望某个对象的值被改变，定义该对象的时候可以在前面加 const关键字<br>在类的成员函数说明后面加const关键字，则该成员函数成为常量<br>成员函数。<br>常量成员函数内部不能改变属性的值，也不能调用非常量成员函数<br>在定义常量成员函数和声明常量成员函数时都应该使用const 关键字。</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void PrintValue() const;
&#125;;
void Sample::PrintValue() const &#123;             //此处不使用const会导致编译出错
    cout &lt;&lt; value;
&#125;
void Print(const Sample &amp; o) &#123;
    o.PrintValue(); 
&#125;//若 PrintValue非const则编译错
</code></pre>
<p>以下是错误示例：</p>
<pre><code>class Sample &#123;
private :
    int value;
    public:
    void func() &#123; &#125;;
    Sample() &#123; &#125;
    void SetValue() const &#123;
        value = 0; // wrong
        func(); //wrong
    &#125;
&#125;;
const Sample Obj;
Obj.SetValue (); //常量对象上可以使用常量成员函数
</code></pre>
<p>什么场景定义成常量成员函数？<br>如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，最好将其写成常量成员函数</p>
<p>常量成员函数的重载：<br>两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载关系，而非重定义。</p>
<h1 id="类的运算：运算符重载"><a href="#类的运算：运算符重载" class="headerlink" title="类的运算：运算符重载"></a>类的运算：运算符重载</h1><p>C++定义了类，可以像基本类型那样创建、销毁、初始化。那么类和类之间的运算呢？<br>+、 -、 *、 &#x2F;、 %、 ^、 &amp;、 ~、 !、 |、 &#x3D;、 &lt;&lt; 、&gt;&gt;、 !&#x3D;、<br>考虑以下方法实现类的运算：</p>
<ul>
<li>设计类的成员函数，支持类运算操作</li>
<li>设计某种机制，把运算符关联成函数操作，在函数内定义具体类运算方法。进行类的运算时，形式上可以像基本类型的运算一样</li>
</ul>
<p>例如complex_a和complex_b是两个复数对象；求两个复数的和, 希望能直接写：complex_a + complex_b<br>运算符重载将解决类和对象的运算需求</p>
<h2 id="运算符重载的概念"><a href="#运算符重载的概念" class="headerlink" title="运算符重载的概念"></a>运算符重载的概念</h2><p>运算符重载，就是对已有的运算符(C++中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为<br>运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象<br>期望效果:同一个运算符，对不同类型的操作数，所发生的行为不同</p>
<pre><code>complex_a + complex_b //生成新的复数对象
5 + 4 = 9 //基本运算符操作
</code></pre>
<p>从行为上看，运算符重载类似于把运算符进行了重定义成函数操作（类似C的typedef）<br>运算符重载写法：</p>
<pre><code>返回值类型 operator 运算符（形参表）
&#123;
……  //定义该运算符的运算规则
&#125;
</code></pre>
<p>示例：</p>
<pre><code>class Complex
&#123;
public:
    double real,imag;
    Complex( double r = 0.0, double i= 0.0):real(r),imag(i) &#123; &#125;
    Complex operator-(const Complex &amp; c);
&#125;;
Complex operator+( const Complex &amp; a, const Complex &amp; b)
&#123;
    return Complex( a.real+b.real,a.imag+b.imag); //返回一个临时对象
&#125;
Complex Complex::operator-(const Complex &amp; c)
&#123;
    return Complex(real - c.real, imag - c.imag); //返回一个临时对象
&#125;

int main()
&#123;
    Complex a(4,4),b(1,1),c;
    c = a + b; //等价于c=operator+(a,b);
    cout &lt;&lt; c.real &lt;&lt; &quot;,&quot; &lt;&lt; c.imag &lt;&lt; endl;
    cout &lt;&lt; (a-b).real &lt;&lt; &quot;,&quot; &lt;&lt; (a-b).imag &lt;&lt; endl;
    //a-b等价于a.operator-(b)
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>5,5
3,3
</code></pre>
<p>c &#x3D; a + b; 等价于c&#x3D;operator+(a,b);<br>a-b 等价于a.operator-(b)<br>运算符重载的实现还是成员函数，所以是依赖于对象的。也就是说，运算符重载看上去和类、对象没啥关系，但本质上，重载的运算符是归属于某个类的，因为a-b只是表象现象，真正定义对象运算的，是a.operator-(b)成员函数。<br>因为运算符重载依赖对象的，因此双目运算，如+，-，在运算符重载时只需要传入另一个对象，而不需要传运算符的当前对象。<br>重载为成员函数时， 参数个数为运算符目数减一。<br>重载为普通函数时， 参数个数为运算符目数</p>
<p>运算符重载概念小结：</p>
<ul>
<li>运算符重载的实质是函数重载</li>
<li>可以重载为普通函数，也可以重载为成员函数</li>
<li>把含运算符的表达式转换成对运算符函数的调用</li>
<li>把运算符的操作数转换成运算符函数的参数</li>
<li>运算符被多次重载时，根据实参的类型决定调用哪个运算符函数</li>
</ul>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><p>接下来的几节讲几个代表性的运算符重载。本节讲赋值运算符“&#x3D;”有时候希望赋值运算符两边的类型可以不匹配，比如，把一个int类型变量赋值给一个Complex对象，或把一个 char *类型的字符串赋值给一个字符串对象,此时就需要重载赋值运算符“&#x3D;”。<br>赋值运算符“ &#x3D;”只能重载为成员函数</p>
<p>示例：</p>
<pre><code>class String &#123;
private:
    char * str;
    public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s);
    String::~String( ) &#123; delete [] str; &#125;
&#125;;
String &amp; String::operator = (const char * s)
&#123; //重载“=”以使得 obj = “hello”能够成立
    delete [] str;
    str = new char[strlen(s)+1];
    strcpy( str, s);
    return * this;
&#125;

int main()
&#123;
    String s;
    s = &quot;Good Luck,&quot; ; //等价于 s.operator=(&quot;Good Luck,&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    // String s2 = &quot;hello!&quot;; //这条语句要是不注释掉就会出错
    s = &quot;Shenzhou 8!&quot;; //等价于 s.operator=(&quot;Shenzhou 8!&quot;);
    cout &lt;&lt; s.c_str() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>Good Luck,
Shenzhou 8!
</code></pre>
<h2 id="赋值运算符与深拷贝"><a href="#赋值运算符与深拷贝" class="headerlink" title="赋值运算符与深拷贝"></a>赋值运算符与深拷贝</h2><p>在类与对象的拷贝构造函数一节讲了拷贝构造函数的作用：用一个已经初始化的对象，去初始化另一个对象，具体操作是讲成员变量一一赋值。<br>那么更深入考虑一下:对于各种类型的成员变量，能不能达到目的？</p>
<ul>
<li>对于基础类型的成员变量，如int,char，直接赋值即可</li>
<li>对于指针类型的成员变量，给指针赋值就Ok?需不需要给指针指向的空间也赋值？</li>
<li>对于引用类型的成员变量，直接赋值OK?</li>
<li>对于类对象类型的成员变量，怎么赋值？嵌套调用拷贝构造函数？</li>
</ul>
<p>引用只是标签，可以直接拷贝，等同变量拷贝。封闭类的构造函数会嵌套调用基础类型的拷贝，直到所有成员赋值完为止。<br>唯一需要考虑的是包含指针类型成员的类如何拷贝<br>如果直接赋值指针而不分配并初始化其指向空间，效果如下:<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081648147.png" alt="image-20221208164831061"><br>如不定义自己的赋值运算符，那么S1&#x3D;S2实际上导致 S1.str和 S2.str<br>指向同一地方。<br>如果S1对象消亡，析构函数将释放 S1.str指向的空间，则S2消亡时还<br>要释放一次，就形成两次delete错误!<br>如果执行 S1 &#x3D; “other”；会导致S2.str指向的地方被delete</p>
<p>为了解决以上问题，类的拷贝构造不仅要拷贝指针，还有拷贝指针指向的空间（分配新内存+拷贝）。这种带内存分配的拷贝称为深拷贝</p>
<ul>
<li>浅拷贝：只拷贝成员，对于指针成员，也只拷贝指针变量</li>
<li>深拷贝：拷贝成员，对于指针成员，拷贝指针变量，且拷贝指针指向的内存空间</li>
</ul>
<p>为了实现深拷贝，需要重载“&#x3D;”运算符：</p>
<pre><code>String &amp; operator = (const String &amp; s) &#123;
    delete [] str;  //先释放指针原本指向的空间,因为新空间和原空间大小可能不一样
    str = new char[strlen( s.str)+1];   //分配指针指向的新空间
    strcpy( str,s.str); //新空间赋值初始化
    return * this;  //返回当前对象的指针
&#125;
</code></pre>
<p>还有可优化的，如果传入对象就是当前对象，没必要释放又分配，直接返回即可</p>
<pre><code>String &amp; operator = (const String &amp; s)&#123;
    if( this == &amp; s)
        return * this;
    delete [] str;
    str = new char[strlen(s.str)+1];
    strcpy( str,s.str);
    return * this;
&#125;
</code></pre>
<p>整个类设计如下：</p>
<pre><code>class String &#123;
private:
    char * str;
public:
    String ():str(new char[1]) &#123; str[0] = 0;&#125;
    const char * c_str() &#123; return str; &#125;;
    String &amp; operator = (const char * s)&#123;
        delete [] str;
        str = new char[strlen(s)+1];
        strcpy( str, s);
        return * this;
&#125;;
    ~String( ) &#123; delete [] str; &#125;
&#125;;
</code></pre>
<p>再考虑一下运算符重载函数的返回值<br>为什么返回String &amp;<br>原因：对运算符进行重载的时候，好的风格是尽量保留运算符原本的特性<br>例如运算符是可以多个连续运算的</p>
<pre><code>a = b = c;
(a=b)=c; //会修改a的值
</code></pre>
<p>分别等价于：</p>
<pre><code>a.operator=(b.operator=(c));
(a.operator=(b)).operator=(c);
</code></pre>
<p>对于拷贝构造函数，原指针未初始化，不指向任何空间，直接分配空间在拷贝即可，写法如下：</p>
<pre><code>String( String &amp; s)
&#123;
    str = new char[strlen(s.str)+1];
    strcpy(str,s.str);
&#125;
</code></pre>
<h2 id="流运算符的重载"><a href="#流运算符的重载" class="headerlink" title="流运算符的重载"></a>流运算符的重载</h2><p>C++常用的输入输出是怎么实现的？</p>
<pre><code>cout &lt;&lt; 5 &lt;&lt; “this”;
</code></pre>
<ul>
<li>cout是什么?</li>
<li>“&lt;&lt;”原本是位偏移运算，为什么能作用于cout?</li>
<li>“&lt;&lt;”怎么支持连续运算，且支持多种类型</li>
</ul>
<p>原因就是&lt;&lt;被流运算类重载了。</p>
<ul>
<li>cout是在iostream中定义的，ostream类的对象</li>
<li>“&lt;&lt;” 能用在cout上是因为，在iostream里对“ &lt;&lt;” 进行了重载</li>
<li>运算符重载函数返回对象的引用，实现连续运算；多个运算符重载函数的重载，支持多种类型</li>
</ul>
<p>实现方法：</p>
<pre><code>ostream &amp; ostream::operator&lt;&lt;(int n)
&#123;
    …… //输出n的代码
    return * this;
&#125;
ostream &amp; ostream::operator&lt;&lt;(const char * s )
&#123;
    …… //输出s的代码
    return * this;
&#125;
</code></pre>
<p>cout &lt;&lt; 5 &lt;&lt; “this”;<br>等价于： cout.operator&lt;&lt;(5).operator&lt;&lt;(“this”);<br>一个流运算符重载的示例：<br>假定c是Complex复数类的对象，现在希望写“ cout &lt;&lt; c;”，就能以“ a+bi”的形式输出c的值，写“ cin&gt;&gt;c;”，就能从键盘接受“ a+bi”形式的输入，并且使得c.real &#x3D; a,c.imag &#x3D; b</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
using namespace std;
class Complex &#123;
    double real,imag;
    public:
    Complex( double r=0, double i=0):real(r),imag(i)&#123; &#125;;
    friend ostream &amp; operator&lt;&lt;( ostream &amp; os, const Complex &amp; c);
    friend istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c);
&#125;;
ostream &amp; operator&lt;&lt;( ostream &amp; os,const Complex &amp; c)
&#123;
    os &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; //以&quot;a+bi&quot;的形式输出
    return os;
&#125;
   
istream &amp; operator&gt;&gt;( istream &amp; is,Complex &amp; c)
&#123;
    string s;
    is &gt;&gt; s; //将&quot;a+bi&quot;作为字符串读入, “a+bi”中间不能有空格
    int pos = s.find(&quot;+&quot;,0);
    string sTmp = s.substr(0,pos); //分离出代表实部的字符串
    c.real = atof(sTmp.c_str()); //atof库函数能将const char*指针指向的内容转换成 float
    sTmp = s.substr(pos+1, s.length()-pos-2); //分离出代表虚部的字符串
    c.imag = atof(sTmp.c_str());
    return is;
&#125;

int main()
&#123;
    Complex c;
    int n;
    cin &gt;&gt; c &gt;&gt; n;
    cout &lt;&lt; c &lt;&lt; &quot;,&quot; &lt;&lt; n;
    return 0;
&#125;
</code></pre>
<p>运行结果可以如下：</p>
<pre><code>13.2+133i 87    //输入
13.2+133i, 87   //输出
</code></pre>
<h2 id="其他运算符重载"><a href="#其他运算符重载" class="headerlink" title="其他运算符重载"></a>其他运算符重载</h2><p>类型转换运算符”()”重载：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
    double real,imag;
    public:
    Complex(double r=0,double i=0):real(r),imag(i) &#123; &#125;;
    operator double () &#123; return real; &#125;
    //重载强制类型转换运算符 double
&#125;;
int main()
&#123;
    Complex c(1.2,3.4);
    cout &lt;&lt; (double)c &lt;&lt; endl; //输出 1.2
    double n = 2 + c; //等价于 double n=2+c.operator double()
    cout &lt;&lt; n; //输出 3.2
&#125;
</code></pre>
<p>自增自减运算符”++,–”的重载：<br>自增运算符++、自减运算符–有前置&#x2F;后置之分，为了区分所重载的是前置运算符还是后置运算符， C++规定：</p>
<ul>
<li>前置运算符作为一元运算符重载</li>
<li>后置运算符作为二元运算符重载，多写一个没用的参数</li>
</ul>
<p>前置运算符重载形式：</p>
<pre><code>重载为成员函数：
T &amp; operator++();   //不用写入参，当前对象的成员++
T &amp; operator--();
重载为全局函数：
T1 &amp; operator++(T2);
T1 &amp; operator—(T2);
</code></pre>
<p>后置运算符重载形式：    </p>
<pre><code>重载为成员函数：
T operator++(int);  //多写一个入参，用于和前置重载区分
T operator--(int);
重载为全局函数：
T1 operator++(T2,int );
T1 operator—( T2,int);
</code></pre>
<p>调用示例：</p>
<pre><code>int main()
&#123;
    CDemo d(5);
    cout &lt;&lt; (d++ ) &lt;&lt; &quot;,&quot;; //等价于 d.operator++(0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (++d) &lt;&lt; &quot;,&quot;; //等价于 d.operator++();
    cout &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; (d-- ) &lt;&lt; &quot;,&quot;; //等价于 operator--(d,0);
    cout &lt;&lt; d &lt;&lt; &quot;,&quot;;
    cout &lt;&lt; (--d) &lt;&lt; &quot;,&quot;; //等价于 operator--(d);
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
&#125;

class CDemo &#123;
private :
    int n;
    public:
    CDemo(int i=0):n(i) &#123; &#125;
    CDemo &amp; operator++(); //用于前置形式
    CDemo operator++( int ); //用于后置形式
    operator int ( ) &#123; return n; &#125;
    friend CDemo &amp; operator--(CDemo &amp; );
    friend CDemo operator--(CDemo &amp; ,int);
&#125;;
CDemo &amp; CDemo::operator++()
&#123; //前置 ++
    n ++;
    return * this;
&#125; // ++s即为: s.operator++();

CDemo CDemo::operator++( int k )
&#123; //后置 ++
    CDemo tmp(*this); //记录修改前的对象
    n ++;
    return tmp; //返回修改前的对象
&#125; // s++即为: s.operator++(0);
CDemo &amp; operator--(CDemo &amp; d)
&#123;//前置--
    d.n--;
    return d;
&#125; //--s即为: operator--(s);
CDemo operator--(CDemo &amp; d,int)
&#123;//后置--
    CDemo tmp(d);
    d.n --;
    return tmp;
&#125; //s--即为: operator--(s, 0);
</code></pre>
<h2 id="运算符重载注意事项"><a href="#运算符重载注意事项" class="headerlink" title="运算符重载注意事项"></a>运算符重载注意事项</h2><ul>
<li>C++不允许定义新的运算符</li>
<li>重载后运算符的含义应该符合日常习惯，即保留原运算符的使用风格</li>
<li>运算符重载不改变运算符的优先级</li>
<li>以下运算符不能被重载：“ .” “ .*” “ ::” “ ?:” “sizeof”</li>
<li>重载运算符()、[]、-&gt;、&#x3D;，运算符重载函数必须声明为<br>类的成员函数</li>
</ul>
<h2 id="运算符重载的综合示例"><a href="#运算符重载的综合示例" class="headerlink" title="运算符重载的综合示例"></a>运算符重载的综合示例</h2><p>实现一个可变长数组类型CArray，实现如下用例：</p>
<pre><code>int main() &#123; 
    CArray a; //开始里的数组是空的
    for( int i = 0;i &lt; 5;++i)
        a.push_back(i); //要用动态分配的内存来存放数组元素，需要一个指针成员变量
    CArray a2,a3;
    a2 = a; //要重载“=”
    for( int i = 0; i &lt; a.length(); ++i )
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot; ;  //要重载[]
    a2 = a3; //a2是空的
    for( int i = 0; i &lt; a2.length(); ++i )//a2.length()返回0
        cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    a[3] = 100;
    CArray a4(a);   //要自己写拷贝构造函数
    for( int i = 0; i &lt; a4.length(); ++i )
        cout &lt;&lt; a4[i] &lt;&lt; &quot; &quot;;
    return 0;
&#125;
</code></pre>
<p>CArray类的设计：</p>
<pre><code>class CArray &#123;
    int size; //数组元素的个数
    int *ptr; //指向动态分配的数组
    public:
    CArray(int s = 0); //s代表数组元素的个数
    CArray(CArray &amp; a);
    ~CArray();
    void push_back(int v); //用于在数组尾部添加一个元素v
    CArray &amp; operator=( const CArray &amp; a);
    //用于数组对象间的赋值
    int length() &#123; return size; &#125; //返回数组元素个数
    int &amp; CArray::operator[](int i) //返回值为 int 不行!不支持 a[i] = 4
    &#123;//用以支持根据下标访问数组元素，如n = a[i] 和a[i] = 4; 这样的语句
        return ptr[i];
    &#125;
&#125;;
</code></pre>
<p>成员函数的实现：</p>
<pre><code>CArray::CArray(int s):size(s)
&#123;
    if( s == 0)
    ptr = NULL;
    else
    ptr = new int[s];
&#125;
CArray::CArray(CArray &amp; a) &#123;
    if( !a.ptr) &#123;
    ptr = NULL;
    size = 0;
    return;
    &#125;
    ptr = new int[a.size];
    memcpy( ptr, a.ptr, sizeof(int ) * a.size);
    size = a.size;
&#125;

CArray::~CArray()
&#123;
    if( ptr) delete [] ptr;
&#125;
CArray &amp; CArray::operator=( const CArray &amp; a)
&#123; //赋值号的作用是使“=”左边对象里存放的数组，大小和内容都和右边的对象一样
    if( ptr == a.ptr) //防止a=a这样的赋值导致出错
    return * this;
    if( a.ptr == NULL) &#123; //如果a里面的数组是空的
    if( ptr ) delete [] ptr;
    ptr = NULL;
    size = 0;
    return * this;
    &#125;
    if( size &lt; a.size) &#123;         //如果原有空间够大，就不用分配新的空间
        if(ptr)
        delete [] ptr;
        ptr = new int[a.size];
    &#125;
    memcpy( ptr,a.ptr,sizeof(int)*a.size);
    size = a.size;
    return * this;
&#125; // CArray &amp; CArray::operator=( const CArray &amp; a)

void CArray::push_back(int v)
&#123; //在数组尾部添加一个元素
    if( ptr) &#123;
        int * tmpPtr = new int[size+1]; //重新分配空间
        memcpy(tmpPtr,ptr,sizeof(int)*size); //拷贝原数组
        内容
        delete [] ptr;
        ptr = tmpPtr;
    &#125;
    else //数组本来是空的
    ptr = new int[1];
    ptr[size++] = v; //加入新的数组元素
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/03/14/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%8EC%E5%88%B0C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%8EC%E5%88%B0C/" class="post-title-link" itemprop="url">C++面向对象笔记：从C到C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 16:41:50" itemprop="dateCreated datePublished" datetime="2020-03-14T16:41:50+08:00">2020-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>本章介绍C++语言和C语言相近的部分基础用法，包括</p>
<ul>
<li>引用: &amp;</li>
<li>常关键字: const</li>
<li>动态内存分配: new delete</li>
<li>函数内联: inline</li>
<li>函数重载</li>
</ul>
<h1 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h1><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。</p>
<pre><code>类型名 &amp; 引用名 = 某变量名;
</code></pre>
<p>某个变量的引用，等价于这个变量，相当于该变量起了一个别名。别名类似于操作系统的文件链接或快捷方式的概念，访问它变量本身的存储空间。</p>
<pre><code>int n = 4;
int &amp; r = n; // r引用了 n, r的类型是int &amp;
r = 4;
cout &lt;&lt; r; //输出 4
cout &lt;&lt; n; //输出 4
n = 5;
cout &lt;&lt; r; //输出5
</code></pre>
<p>注意：<br>1.定义引用时一定要将其初始化成引用某个变量。<br>2.初始化后，它就一直引用该变量，不会再引用别<br>的变量了。<br>3.引用只能引用变量，不能引用常量和表达式。</p>
<h2 id="引用的示例"><a href="#引用的示例" class="headerlink" title="引用的示例"></a>引用的示例</h2><p>引用常用于函数传参和返回值<br>1.引用作为函数入参<br>C语言写一个swap函数，交换两个变量的值，要传指针而不能传值，因为直接传值实际修改的是函数局部作用域的一份拷贝。</p>
<pre><code>void swap( int * a, int * b)
{
    int tmp;
    tmp = * a; * a = * b; * b = tmp;
}
int n1, n2;
swap(&amp; n1,&amp; n2) ; // n1,n2的值被交换
</code></pre>
<p>C++中，除了传指针，也可以传引用</p>
<pre><code>void swap( int &amp; a, int &amp; b)
{
    int tmp;
    tmp = a; a = b; b = tmp;
}
int n1, n2;
swap(n1,n2) ; // n1,n2的值被交换
</code></pre>
<p>2.引用作为函数返回值</p>
<pre><code>int n = 4;
int &amp; SetValue() { return n; }
int main()
{
SetValue() = 40;
cout &lt;&lt; n;
return 0;
} //输出： 40
</code></pre>
<h2 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h2><p>看上去引用和指针的功能相同，那区别在哪？<br>1.存储类型不同</p>
<ul>
<li>指针是一种变量，存储指向变量的地址值，通常占内存4字节（64位系统8字节）</li>
<li>引用只是变量的别名，它本身不另外占存储空间，对其求大小（sizeof）就是变量本身的大小</li>
</ul>
<p>指针是变量，因此可以为空（0x0）,而引用是标签（别名），不可为空，先有变量才能有其引用。<br>2.作用方式不同</p>
<ul>
<li>指针作为函数入参本质上还是是值传递，只不过传递的是变量的地址值，函数局部拷贝的也是地址。</li>
<li>引用作为函数入参，被调函数的形参作为局部变量在栈中开辟了内存空间，但存放的是主调函数的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。</li>
</ul>
<p>对于函数传参，形参都是用地址值达成对实参的修改，但传指针是显式的，而传引用是编译器隐式处理的。<br>指针和引用在内存中的示意图：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081643838.png" alt="image-20221208164349783"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212081644997.png"></p>
<p>指针和引用的应用比较：<br>引用比指针使用起来形式上更为美观，使用引用指向的内容时可以之间用引用变量名，而不像指针一样要使用*；定义引用的时候也不用像指针一样使用&amp;取址。<br>引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针)。</p>
<h1 id="常量关键字const"><a href="#常量关键字const" class="headerlink" title="常量关键字const"></a>常量关键字const</h1><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>常量：不可被修改的内存单元<br>    const int MAX_VAL &#x3D; 23；<br>    const string SCHOOL_NAME &#x3D; “Peking University”；</p>
<h2 id="定义常引用"><a href="#定义常引用" class="headerlink" title="定义常引用"></a>定义常引用</h2><p>定义引用时，前面加const关键字，即为“常引用”。不能<strong>通过常引用修改</strong>其引用的变量，但可直接修改变量的值，引用本身也不能改变</p>
<pre><code>int n;
const int &amp; r = n;
r = 5; //error
n = 4; //ok
</code></pre>
<p><strong>const T &amp; 和T &amp; 是不同的数据类型!!!</strong><br>T &amp; 类型的引用或T类型的变量可以用来初始化const T &amp; 类型的引用，const T 类型的常变量和const T &amp; 类型的引用则不能用来初始化T &amp;类型的引用，除非进行强制类型转换<br>一句话，常指针和常引用不能出现在“&#x3D;”左边</p>
<h2 id="定义常指针"><a href="#定义常指针" class="headerlink" title="定义常指针"></a>定义常指针</h2><p>常指针也叫常量指针。但指针不是常量，指向的也不是常量，只是限制了改写方式：不可<strong>通过常量指针修改</strong>其指向变量的值，但可直接修改变量的值，也可以改变常量指针的指向地址值。</p>
<pre><code>int n,m;
const int * p = &amp; n;
* p = 5; //编译出错
n = 4; //ok
p = &amp;m; //ok, 常量指针的指向可以变化
</code></pre>
<p>不能把常量指针赋值给非常量指针，反过来可以</p>
<pre><code>const int * p1; int * p2;
p1 = p2; //ok
p2 = p1; //error
p2 = (int * ) p1; //ok,强制类型转换
</code></pre>
<p>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容</p>
<pre><code>void MyPrintf( const char * p )
{
strcpy( p,&quot;this&quot;); //编译出错
printf(&quot;%s&quot;,p); //ok
}
</code></pre>
<h2 id="定义指针常量"><a href="#定义指针常量" class="headerlink" title="定义指针常量"></a>定义指针常量</h2><p>定义：本质是一个不可修改指向地址的指针 </p>
<pre><code>int* const p;
</code></pre>
<h2 id="定义指向常量的常指针"><a href="#定义指向常量的常指针" class="headerlink" title="定义指向常量的常指针"></a>定义指向常量的常指针</h2><p>定义：指针指向的地址值不可修改，且该地址中的值也不可修改</p>
<pre><code>const int* const p;
</code></pre>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>动态内存分配是分配内存空间中堆（heap）的内存，实际上是程序内手动的内存分配与释放。并非堆栈中局部变量的入栈出栈，由操作系统控制的动态分配。</p>
<h2 id="new分配内存"><a href="#new分配内存" class="headerlink" title="new分配内存"></a>new分配内存</h2><p>分配一个变量:</p>
<pre><code>P = new T;
</code></pre>
<p>T是任意类型名， P是类型为T * 的指针。<br>动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P：</p>
<pre><code>int * pn = new int;
* pn = 5;
</code></pre>
<p>分配一个数组：</p>
<pre><code>P = new T[N];
</code></pre>
<p>T :任意类型名<br>P :类型为T * 的指针<br>N :要分配的数组元素的个数，可以是整型表达式<br>动态分配出一片大小为 sizeof(T)*N字节的内存空间，并且将该内存空间的起始地址赋值给P</p>
<pre><code>int * pn;
int i = 5;
pn = new int[i * 20];
pn[0] = 20;
pn[100] = 30; //编译没问题。运行时导致数组越界
</code></pre>
<h2 id="delete释放内存"><a href="#delete释放内存" class="headerlink" title="delete释放内存"></a>delete释放内存</h2><p>用“new”动态分配的内存空间用完后，一定要用“delete”运算符进行释放，否则操作系统无法再次使用这块内存，造成内存泄露<br>注意：不能对内存空间delete两次！</p>
<pre><code>#delete 指针； //该指针必须指向new出来的空间
int * p = new int;
* p = 5;
delete p;
delete p; //导致异常， 一片空间不能被delete多次
</code></pre>
<p>用“delete”释放动态分配的数组，要加“[]”</p>
<pre><code>#delete [] 指针； //该指针必须指向new出来的数组
int * p = new int[20];
p[0] = 1;
delete [] p;
</code></pre>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>普通函数：编译出来的可执行程序加载到内存后，代码段只有一份函数的指令序列，函数的调用处就用一个类似jump的语句跳转到函数指令序列的入口地址<br>内联函数：函数的每个调用处都存在整个函数指令序列的拷贝<br>简单讲就是增加编译出来的代码占用空间，换取运行时频繁入栈出栈的时间开销<br>使用场景：简单函数体且多次调用可以定义为内联<br>函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</p>
<pre><code>inline int Max(int a,int b)
{
if( a &gt; b) return a;
return b;
}
</code></pre>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="函数重载概念"><a href="#函数重载概念" class="headerlink" title="函数重载概念"></a>函数重载概念</h2><p>重载不是重新载入，更贴切的含义是重复定义，因为重定义是种错误，重载可以理解为编译器能理解的“重定义”，因此能正常加载。<br>C++重载主要有：</p>
<ul>
<li>函数重载</li>
<li>运算符重载</li>
</ul>
<p>C++的类没有重载一说，本节讲函数重载<br>函数重载：一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。</p>
<pre><code>int Max(double f1,double f2) { }
int Max(int n1,int n2) { }
int Max(int n1,int n2,int n3) { }
</code></pre>
<p>Q1.重载有什么用？<br>C语言定义以上几个函数，不能用同名，但是其功能都是相同的，仅参数类型和值不同。如果用MaxDouble(),MaxInt2(),MaxInt3()过于麻烦。<br>因此函数重载使得函数命名变得简单。<br>Q2.编译器怎么知道调用的是哪个？<br>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数，注意重载函数不会把入参自动类型转换，调用二义性会报错。</p>
<pre><code>Max(3.4,2.5); //调用 (1)
Max(2,4); //调用 (2)
Max(1,2,3); //调用 (3)
Max(3,2.4); //error,二义性
</code></pre>
<p>Q3.函数仅返回值类型不同是不是重载？<br>不是，函数重载的区分在于入参。但是有个例外，返回const T和非const T的两个函数是是重载的，其他情况的入参相同，返回类型不同的函数，视为重定义。</p>
<h2 id="缺省参数与可拓展性"><a href="#缺省参数与可拓展性" class="headerlink" title="缺省参数与可拓展性"></a>缺省参数与可拓展性</h2><p>C++函数支持缺省参数（默认参数值）。定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。</p>
<pre><code>void func( int x1, int x2 = 2, int x3 = 3)
{ }
func(10 ) ; //等效于 func(10,2,3)
func(10,8) ; //等效于 func(10,8,3)
func(10, , 8) ; //不行,只能最右边的连续若干个参数缺省
</code></pre>
<p>函数参数可缺省的目的在于提高程序的可扩充性。<br>如果某个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，那么为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。<br>在C语言中，如果函数新增一个入参，所有调用该函数的地方都要传入该入参值；C++支持缺省参数，只需要改函数定义即可，调用处不需要动。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2020/02/29/%E6%B5%85%E8%B0%88C%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%E6%B5%85%E8%B0%88C%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">浅谈C的结构体与面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-29 15:13:18" itemprop="dateCreated datePublished" datetime="2020-02-29T15:13:18+08:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 11:43:03" itemprop="dateModified" datetime="2024-11-04T11:43:03+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>结构体（Struct）：存放一组不同类型的数据的数据结构。<br>数组（Array）：存放一组相同类型的数据的数据结构。<br>结构体和int,char，指针等基础数据类型一样，也是一种数据类型。格式定义如下：</p>
<pre><code>struct 结构体名&#123;
    成员类型1 成员名1;
    成员类型2 成员名2；
&#125;实例1，实例2;
</code></pre>
<p>结构体的成员（Member）可以为任意类型，如int,char，指针，甚至结构体类型。<br>结构体可以配合结构体数组、普通指针、函数指针、以及自身嵌套的使用方法，实现复杂数据结构，以及面向对象的代码风格。</p>
<h1 id="1-结构体声明"><a href="#1-结构体声明" class="headerlink" title="1.结构体声明"></a>1.结构体声明</h1><p>声明是告诉编译器某个数据结构的定义。一般在头文件对结构体、函数等类型声明。声明过程不分配内存。<br>一个结构体类型的声明：</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125;;
</code></pre>
<p>注意：<br>1.结构体声明类似于函数声明，是一个语句，末尾加；<br>2.结构体声明只声明了类型，不实例化变量，因此不分配内存。<br>3.结构体成员的变量只在实例结构体才分配内存。</p>
<h1 id="2-结构体实例"><a href="#2-结构体实例" class="headerlink" title="2.结构体实例"></a>2.结构体实例</h1><h2 id="2-1基础方法"><a href="#2-1基础方法" class="headerlink" title="2.1基础方法"></a>2.1基础方法</h2><p>结构体变量是结构体类型的实例，实例化就是在内存分配一个结构体类型的变量空间。<br>方法一：先声明结构体类型stu，再实例变量stu1,stu2。<br>该方法结构体类型声明和实例化分离。声明一次，到处实例化。注意实例变量要带struct关键字。</p>
<pre><code>struct stu stu1, stu2;
</code></pre>
<p>方法二：声明的时候也实例变量stu1,stu2。</p>
<pre><code>struct stu&#123;
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<p>方法三：不声明接头体名，直接实例变量。<br>适用于只需要 stu1、stu2两个变量，后面不需要再使用结构体名定义其他变量的情况</p>
<pre><code>struct&#123;             //没有写stu
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;
</code></pre>
<h2 id="2-2重定义方法"><a href="#2-2重定义方法" class="headerlink" title="2.2重定义方法"></a>2.2重定义方法</h2><p>结构体类型通常配合typedef重定义后声明。<br>声明一次，到处实例化。不需要带struct关键字。</p>
<pre><code>    typedef struct stu&#123; //stu可省略
        char *name;     //姓名
        int num;        //学号
        int age;        //年龄
        char group;     //所在小组
        float score;    //成绩
    &#125;stu_t, *stu_p;    //声明stu_t为stu类型，stu_p为stu类型的指针
</code></pre>
<p>实例变量：</p>
<pre><code>stu_t stu1,stu2;    //实例两个stu结构体变量
stu_p *stu1_p, *stu2_p; //实例两个指向stu结构体指针
stu1_p = &amp;stu1; //指向实例stu1
stu2_p = &amp;stu2; //指向实例stu2
</code></pre>
<h1 id="3-结构体初始化"><a href="#3-结构体初始化" class="headerlink" title="3.结构体初始化"></a>3.结构体初始化</h1><p>初始化&#x3D;赋初始值。<br>结构体的实例只分配了内存，其成员的值要手动赋值后才能确定。否则直接拿来用会得到不确定的值（取决于分配到的内存原本的值）。<br>以重定义的结构体类型stu_t为例，实例变量时顺便初始化所有成员为0：</p>
<pre><code>stu_t stu1,stu2 = &#123;0&#125;;
</code></pre>
<p>有的编译器可能要求这种写法：</p>
<pre><code>stu_t stu1,stu2 = &#123;&#123;0&#125;&#125;;
</code></pre>
<p>如果各成员有默认初始值，初始化如下：</p>
<pre><code>stu_t stu1, stu2 = &#123; &quot;Tom&quot;, 9527, 18, &#39;A&#39;, 136.5 &#125;;
</code></pre>
<h1 id="4-结构体的赋值"><a href="#4-结构体的赋值" class="headerlink" title="4.结构体的赋值"></a>4.结构体的赋值</h1><p>结构体赋值是对结构体变量内的成员赋值。<br>两种方式访问成员：</p>
<pre><code>结构体变量.成员名;
stu1.name = &#39;Tom&#39;;
结构体指针-&gt;成员名
stu1_p-&gt;name = &#39;Tom&#39;;
</code></pre>
<p>这两种方法的选择取决于使用情况。如果结构体作为参数在函数之间频繁传递和赋值，建议使用传指针，而不是传结构体变量，这样减少函数为结构体频繁分配局部内存，但要注意结构体已被释放，形成空指针的判断。<br>注意是对实例的成员赋值（已分配内存），而不能对结构体类型的成员赋值（只是个标签）。例如如下操作是错误的：</p>
<pre><code>stu_t.name = &quot;Tom&quot;  //错，stu_t是类型
stu1_p = &amp;stu_t     //错，stu_t没地址
</code></pre>
<p>可以对结构体类型进行sizeof操作，而不需要分配内存。</p>
<pre><code>sizeof(stu_t);      //获取结构体（将）占用的内存空间
</code></pre>
<h1 id="5-结构体的内存分配"><a href="#5-结构体的内存分配" class="headerlink" title="5.结构体的内存分配"></a>5.结构体的内存分配</h1><p><strong>理论上</strong>结构体的内存占用是成员占用的和。各成员在内存中连续存储的，和数组非常类似，例如结构体变量 stu1、stu2的内存分布如下，共占用 4+4+4+1+4&#x3D;17字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061515193.jpeg" alt="1"><br>但实际上，编译器会遵循<strong>内存对齐</strong>规则。实际内存占用大于各成员占用的和。如下图，stu1、stu2 其实占用了 17+3&#x3D;20 字节<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516336.jpeg" alt="2"></p>
<h2 id="5-1内存对齐概述"><a href="#5-1内存对齐概述" class="headerlink" title="5.1内存对齐概述"></a>5.1内存对齐概述</h2><p>1.CPU怎么访问内存中的数据最高效？<br>答：用最少的访问次数，获取该数据所在的内存空间的值。<br>2.怎么做到对某类型数据的最少访问？<br>答：编译器设置数据的存放地址的单位为数据占用空间的长度，CPU以数据长度为单位查询偏移地址，找到数据空间首地址后，根据数据类型取出其占用空间大小的数据。<br>如int数据，就存放在以4字节为单位的偏移地址，如0，4，8…,CPU取数据就按0，4，8…的地址查询，找到该数据地址后取4字节。这样做到一次性访问获取int数据。如果CPU按单字节访问int,就要查询4次，如int首字节地址为0x00001024, CPU要分4次查询0x00001024~0x00001027才能得到一个int。<br>3.对于结构体，包含多种数据类型，怎么对齐？<br>答：各成员按各自的类型对齐，即对于成员来说不存在结构体的概念，它认为它就是基本的数据类型int、char、指针等。</p>
<h2 id="5-2结构体与内存对齐"><a href="#5-2结构体与内存对齐" class="headerlink" title="5.2结构体与内存对齐"></a>5.2结构体与内存对齐</h2><p>结构体是不同类型数据的集合，因此内存对齐问题就特别突出。一个例子：</p>
<pre><code>#include &quot;stdio.h&quot;
typedef struct &#123;
    int a;
    double b;
    char c;
&#125;A; 

typedef struct &#123;
    int a;
    char b;
    double c;
&#125;B;

int main()
&#123;
	printf(&quot;sizeof A: %d, sizeof B: %d\n&quot;, sizeof(A), sizeof(B));
&#125;
</code></pre>
<p>A和B的内存占用：A&#x3D;24字节，B&#x3D;16字节。<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061516111.png" alt="3"><br>结构体内存对齐的计算规则：<br>1.默认首地址已对齐（或认为是0地址)<br>2.各成员按自己的类型对齐<br>3.整个结构体分配的空间是期中最大成员占用空间的整数倍<br>对于A：<br>int a占用4字节，地址byte[0<del>3]<br>double b占8字节，起始地址必须是8的倍数，占用byte[7</del>15]<br>char c占1字节，因此占byte[16]<br>目前共占用17字节。编译器会按照规则3，将byte[17~13]也分配给结构体，因此最终结构体占用3<em>8&#x3D;24字节。<br>对于B, int a和char b加起来都不够8字节，double c再占用8字节，共占用2</em>8&#x3D;16字节。<br>因此<strong>结构体的内存分配&#x3D;各成员按类型对齐+总空间是最大成员空间的倍数</strong><br>注意，结构体不仅成员间要对齐，最后一个成员后面的空余空间可能也分配给结构体。<br>查看下面的测试程序：</p>
<pre><code>typedef struct &#123;
    int a;
    double b;
    char c;
    char d;         //d作为成员
&#125;C;

typedef struct &#123;
    int a;
    double b;
    char c;
    struct &#123;        //d作为嵌套结构体的成员
    	char d; 
    &#125;;
&#125;D;

printf(&quot;sizeof C: %d, sizeof D: %d\n&quot;, sizeof(C), sizeof(D));
</code></pre>
<p>C和D的内存占用：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517211.png" alt="4"><br>新增的char d作为C的成员被分配在第三个8byte区域的第二个字节（byte[17])，嵌套的结构体并不从第四个8byte开始分配，它占用空间还是byte[17]。可见编译器对结构体内存分配不区分成员类型，只根据成员大小来处理。</p>
<h1 id="6-联合、位域、枚举"><a href="#6-联合、位域、枚举" class="headerlink" title="6.联合、位域、枚举"></a>6.联合、位域、枚举</h1><p>这几种数据结构体和结构体相关联，通常混合使用。</p>
<h2 id="6-1联合"><a href="#6-1联合" class="headerlink" title="6.1联合"></a>6.1联合</h2><p>联合(Union)也称共用体，和结构体的区别：<br>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。<br>声明格式：</p>
<pre><code>union 共用体名&#123;
    成员列表
&#125;;
</code></pre>
<p>共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>联合的一个示例：</p>
<pre><code>#include &lt;stdio.h&gt;
union data&#123;
    int n;
    char ch;
    short m;
&#125;;
int main()&#123;
    union data a;
    printf(&quot;%d, %d\n&quot;, sizeof(a), sizeof(union data) );
    a.n = 0x40;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.ch = &#39;9&#39;;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.m = 0x2059;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    a.n = 0x3E25AD54;
    printf(&quot;%X, %c, %hX\n&quot;, a.n, a.ch, a.m);
    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>4, 4
40, @, 40
39, 9, 39
2059, Y, 2059
3E25AD54, T, AD54
</code></pre>
<p>在内存中数据分布如下（以大端，低字节存高位为例）<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517262.jpeg" alt="5"><br>可见数据会相互覆盖，联合可以理解为分时复用的结构体，其空间占用定长，为最大的成员长度，在不同时间，值的含义不同。</p>
<h2 id="6-2位域"><a href="#6-2位域" class="headerlink" title="6.2位域"></a>6.2位域</h2><p>有的结构体成员在存储时并不占用一个完整的字节，只需要按二进制位为单位分配空间即可。可以指定该成员所占用的二进制位数（Bit），这就是位域。</p>
<pre><code>#include &quot;stdio.h&quot;
struct &#123;
        unsigned char a;    //a占完整的8bit
        unsigned char b: 2; //b占2bit
        unsigned char c: 6; //C占6bit
&#125;bs;

int main()
&#123;
	printf(&quot;sizeof bs: %d\n&quot;, sizeof(bs));
&#125;
</code></pre>
<p>输出2字节，可见b和c刚好拼成一个unsigned char(8 bit)：<br><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202212061517807.png" alt="6"><br>位域将结构体成员占用的空间从基本数据类型为单位，变成了以二进制位为单位，是更精细的结构体内存分配。<br>位域不能超过对应基本类型的二进制位数。</p>
<h2 id="6-3枚举"><a href="#6-3枚举" class="headerlink" title="6.3枚举"></a>6.3枚举</h2><p>枚举可以理解为计数宏的结构体。</p>
<pre><code>#include &lt;stdio.h&gt;
int main()&#123;
    enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125; day;
    scanf(&quot;%d&quot;, &amp;day);
    switch(day)&#123;
        case Mon: puts(&quot;Monday&quot;); break;
        case Tues: puts(&quot;Tuesday&quot;); break;
        case Wed: puts(&quot;Wednesday&quot;); break;
        case Thurs: puts(&quot;Thursday&quot;); break;
        case Fri: puts(&quot;Friday&quot;); break;
        case Sat: puts(&quot;Saturday&quot;); break;
        case Sun: puts(&quot;Sunday&quot;); break;
        default: puts(&quot;Error!&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
<p>枚举值默认从0开始，往后逐个加 1（递增）；如果第一个成员赋值，从那个成员值往后递增。也就是说，week中的 Mon、Tues …… Sun 对应的值分别为 1、2… 7。<br>宏在编译的预处理阶段将名字替换成对应的值，而枚举在编译阶段将名字替换成对应的值。在编译过程中，Mon、Tues、Wed 名字都被替换成了对应的数字。这意味着Mon、Tues、Wed 等都不是变量，不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是被编译到指令里面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。<br>枚举类型实例的内存占用通常&#x3D;int类型占用&#x3D;4字节。</p>
<h1 id="7-结构体常见用法"><a href="#7-结构体常见用法" class="headerlink" title="7.结构体常见用法"></a>7.结构体常见用法</h1><h2 id="7-1结构体数组"><a href="#7-1结构体数组" class="headerlink" title="7.1结构体数组"></a>7.1结构体数组</h2><p>结构体数组是将多个同类型结构体按数组的方式存储，其成员访问方式为：先访问数组元素，再访问结构体成员。<br>结构体数组本质还是数组，但数组成员是结构体，结构体内可以包含各种类型的成员。<br>一个Linux NandFlash驱动的结构体数组如下：</p>
<pre><code>    static struct mtd_partition s3c_nand_parts[] = &#123;
	[0] = &#123;
        .name   = &quot;bootloader&quot;,
        .size   = 0x00040000,
		.offset	= 0,
	&#125;,
	[1] = &#123;
        .name   = &quot;params&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00020000,
	&#125;,
	[2] = &#123;
        .name   = &quot;kernel&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = 0x00200000,
	&#125;,
	[3] = &#123;
        .name   = &quot;root&quot;,
        .offset = MTDPART_OFS_APPEND,
        .size   = MTDPART_SIZ_FULL,
	&#125;
&#125;;
</code></pre>
<p> 该数组名为s3c_nand_parts，成员为mtd_partition结构体，包含分区名，分区大小和分区偏移地址。每个结构体成员分别初始化赋值。注意结构体数组实例没写结构体名，只有数组下标[]，结构体成员没写结构体名,只有.符号。这是Linux kernel常见的精简写法。<br> 访问一个结构体数组的成员：</p>
<pre><code>s3c_nand_parts[0].name = &quot;bootloader_2&quot;
</code></pre>
<p>结构体数组的内存占用&#x3D;数组成员数*单个结构体内存占用。</p>
<h2 id="7-2结构体指针"><a href="#7-2结构体指针" class="headerlink" title="7.2结构体指针"></a>7.2结构体指针</h2><p>结构体指针本质是指针变量，其值是结构体的地址。<br>前面结构体重定义一节已经定义和初始化过结构体指针，需要注意的是，结构体指针的初始化值来源于结构体实例，结构体类型名只是标签，不代表结构体地址，注意和”数组名&#x3D;数组地址“区分。</p>
<pre><code>struct stu&#123;         
    char *name;     //姓名
    int num;        //学号
    int age;        //年龄
    char group;     //所在小组
    float score;    //成绩
&#125; stu1, stu2;

struct stu *stu_p = stu;    //错，stu只是符号，不占内存
struct stu *stu_p = &amp;stu1;  //对，stu1是结构体实例，占内存  //对，stu1是stu实例变量，有内存占用
</code></pre>
<p>结构体指针的常见用途：malloc分配结构体空间</p>
<pre><code>stu_p =(stu_t *)malloc(sizeof(stu_t));  //分配结构体空间，返回地址给结构体指针
</code></pre>
<p>结构体指针最重要的用途：函数传参<br>结构体变量作为函数参数时传递的是整个结构体内存空间，也就是所有成员空间，而不是像数组一样被编译器转换成一个指针。如果结构体成员较多，传送的时间和空间开销会很大，影响程序的运行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。</p>
<h2 id="7-2结构体嵌套"><a href="#7-2结构体嵌套" class="headerlink" title="7.2结构体嵌套"></a>7.2结构体嵌套</h2><p>结构体嵌套是结构体的成员也是结构体。有两种情况：<br>1.成员是其他类型的结构体<br>2.成员是同类型的结构体</p>
<h3 id="7-2-1-嵌套其他类型"><a href="#7-2-1-嵌套其他类型" class="headerlink" title="7.2.1.嵌套其他类型"></a>7.2.1.嵌套其他类型</h3><p>在协议开发中，一个命令的数据可以用结构体来表达，在命令的内部又分为很多个数据域，每个数据域又用结构体来表达，因此需要结构体嵌套。对于同一块数据，根据命令的不同，解析为不同的结构体,因此存在多类命令公用一块数据域的情况，因此需要联合（Union）。以NVMe协议为例，结构体嵌套和联合一起使用的例子：</p>
<pre><code>typedef struct  //nvme命令结构体
&#123;
     union      //命令中dword10空间的联合
    &#123;
        u32 command_dw10;
        struct
        &#123;
            u32 cntid:16;   //16 bit位域
            u32 resv1:8;    //8 bit位域
            u32 cns:8;      //8 bit位域
        &#125;identify;          //当命令为identify时
        struct
        &#123;
            u32 save:1;
            u32 resv1:20;
            u32 select:3;
            u32 feature_identifier:8;
        &#125;get_features;      //当命令为get_featuresy时
        struct
        &#123;
            u32 queue_size:16;
            u32 queue_identifier:16;
        &#125;io_queue_create_delete_dw10;
        ...
    &#125;;
    
    union   //命令中dword11空间的联合
    &#123;
        u32 command_dw11;
        struct
        &#123;
            u32 completion:16;
            u32 submission:16;
        &#125;number_of_queues;
        struct
        &#123;
            u32 interrupt_vector:16;
            u32 resv1:14;
            u32 interrupt_enabled:1;
            u32 physically_contiguous:1;
        &#125;create_io_completion_queue_dw11;
        ...
    &#125;;
    
&#125;command_t, *command_p;
</code></pre>
<p>该例子结合了结构体、联合、位域。对每个nvme命令，多个联合并存在结构体command_t实例里，每个联合长度为一个dword(4字节)，分别表示dword0~15中的一个。对于dword内部，根据解析到命令的不同，作为不同含义处理，如解析为identify就按identify的结构体读写成员，如解析为get_features则按get_features的结构体读写成员。在结构体内部，用位域更精细控制这个dword内各bit的含义。</p>
<h3 id="7-2-2嵌套自身类型"><a href="#7-2-2嵌套自身类型" class="headerlink" title="7.2.2嵌套自身类型"></a>7.2.2嵌套自身类型</h3><p>结构体嵌套自身类型的典型应用：链表数据结构体</p>
<pre><code>typedef struct ListNode &#123;
	DataType data;          // 节点数据 
	struct ListNode *next;  // 指向下一个结点的指针 
&#125; ListNode_t;
</code></pre>
<p>这个结构体有两个成员：DataType类型的数据，和指向 struct ListNode类型(&#x3D;ListNode_t类型)的实例的指针。有多个ListNode_t类型的结构体被实例化且依次指向后续节点后，可以依次node1-&gt;next-&gt;next…-&gt;data访问链表中的节点数据。<br>注意：结构体体能嵌套自身类型的指针，而不能嵌套自身类型的实例。因为指针分配内存是定长（通常4字节），而循环嵌套结构体变量是无穷的。以下写法是错的</p>
<pre><code>typedef struct ListNode &#123;
	DataType data;           
	struct ListNode next;  // 错，嵌套的是实例 
&#125; ListNode_t;
</code></pre>
<h1 id="8-结构体高级用法：面向对象"><a href="#8-结构体高级用法：面向对象" class="headerlink" title="8.结构体高级用法：面向对象"></a>8.结构体高级用法：面向对象</h1><h2 id="8-1函数指针"><a href="#8-1函数指针" class="headerlink" title="8.1函数指针"></a>8.1函数指针</h2><p>程序中定义的函数，在编译时会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的入口地址。函数名表示的就是这个地址的值。可以定义一个指针变量来存放函数的入口地址，这个指针变量就叫作函数指针变量，简称函数指针。<br>这段话什么意思？<br>1.函数名&#x3D;函数入口地址<br>2.可以用指针变量的值取代函数名，函数的调用和该指针变量的调用等价<br>3.可以把这个指针变量当参数传递给别的函数，也可以把这个指针变量作为结构体的成员，总之，一切指针能做的，函数指针都能做。<br>函数指针的定义：</p>
<pre><code>返回值 函数入口地址(入参1的类型，入参2的类型，...)
int (*p)(int, int);     //p为函数指针，*p为入口地址
</code></pre>
<p>定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数。p 的类型为 int(*)(int，int)<br>函数指针的初始化：</p>
<pre><code>int Func(int x);   /*声明一个函数，包含入参名*/
int (*p) (int);  /*声明一个函数指针，只有入参类型*/
p = Func;         /*将Func函数的入口地址赋给指针变量p*/
</code></pre>
<p>函数指针作为结构体成员的调用如下</p>
<pre><code>struct&#123;
    int (* func)(int);
&#125;stu1, *stu1_p; //分配两个结构体实例：stu1结构体和指针stu1_p

stu1.func(10);  //通过结构体调用函数指针
stu1_p-&gt;func(10);   //通过结构体指针调用函数指针
</code></pre>
<h2 id="8-2回调函数"><a href="#8-2回调函数" class="headerlink" title="8.2回调函数"></a>8.2回调函数</h2><p>回调函数(Callback)就是一个通过函数指针调用的函数。把函数指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由函数的实现方直接调用，而是在特定的事件或条件发生时，由把它当参数的那个函数调用的，用于对该事件或条件进行响应。<br>回调的两个特点：<br>1.函数&#x3D;参数。函数A指针当参数传递B<br>2.异步。特定时间发生时，B才调用A指针指向的函数</p>
<h2 id="8-3结构体与面向对象"><a href="#8-3结构体与面向对象" class="headerlink" title="8.3结构体与面向对象"></a>8.3结构体与面向对象</h2><p>当函数指针作为结构体的成员，可以通过结构体实例调用成员函数，此时可以实现类似其他语言中“类”或“接口”的概念：<br>结构体声明&#x3D;类声明&#x3D;接口声明<br>结构体的函数指针成员&#x3D;类方法&#x3D;接口函数<br>结构体实例调用函数指针成员&#x3D;类实例调用方法&#x3D;接口的实现<br>这种设计思想在Linux内核和驱动框架中很常用。以字符设备驱动为例：<br>字符设备驱动顶层框架将所有字符操作函数作为接口在结构体file_operations中定义，在底层具体的设备驱动中实现file_operations的方法。底层驱动实例化file_operations结构体（分配内存），将各种操作的具体实现函数赋值给接口定义的函数，然后上报（注册）该file_operations实例给顶层驱动框架，顶层驱动框架接收到应用层的系统调用请求时，回调已注册的file_operations实例的函数。<br>上层驱动框架定义的字符文件操作接口如下，这些open、read、write作为文件操作的方法供应用层调用。</p>
<pre><code> struct file_operations &#123;   //字符文件操作的接口定义
　　struct module *owner;   //结构体指针
　　ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);      //函数指针read
　　ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);    //函数指针write
　　int (*open) (struct inode *, struct file *);    //函数指针open
　　int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);   //函数指针ioctl
　　...
&#125;;
</code></pre>
<p>而这些方法具体实现（内部做什么）是由底层驱动代码实现：</p>
<pre><code>static int my_drv_open(struct inode *inode, struct file *file)
&#123;
	//硬件寄存器操作A...
	return 0;
&#125;

static ssize_t my_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)
&#123;
	//硬件寄存器操作B...
	return 0;
&#125;
</code></pre>
<p>那么这些实现怎么关联接口：在底层驱动分配结构体实例，初始化函数指针为实现函数</p>
<pre><code>static struct file_operations my_drv_fops = &#123;
    .owner  =   THIS_MODULE,   
    .open   =   my_drv_open,   //open接口由my_drv_open函数实现  
	.write	=	my_drv_write,	 //write接口由my_drv_write函数实现  
&#125;;
</code></pre>
<p>关联完了，上层驱动怎么调用：结构体指针传参+回调<br>my_drv_fops是file_operations的实例，上报给上层驱动，上层驱动有它自己的字符设备结构体cdev，取出my_drv_fops实例的.结构体指针fops的值，赋给cdev实例内的ops指针。之后它就能用ops调用my_drv_open、my_drv_write函数。</p>
<pre><code>//注册结构体
cdev-&gt;owner = fops-&gt;owner;
cdev-&gt;ops = fops;
//回调.open方法
cdev-&gt;ops-&gt;open(inode,file);
</code></pre>
<p>由于my_drv_write是值，open才是结构体成员，因此调用的时候看上去调用的是open函数，本质上执行的还是my_drv_write的流程。函数指针的回调能将接口名暴露，方法名隐藏。因此底层实现的函数名和上层驱动的调用函数名不相关，上层永远都可以用.open .read .write这些接口调用底层驱动，而底层函数可以随便改名（不能改入参出参类型，否则函数指针类型变了），这种特性都是函数指针决定的。<br>对于应用程序，是调用上层驱动提供的系统调用接口，还是如.open .read .write等接口。Linux驱动将设备抽象成了文件，驱动程序实现了文件的各种方法，所以对应用程序，打开文件&#x3D;打开设备，调用文件对应的接口&#x3D;调用设备驱动提供的接口。</p>
<pre><code>fd = open(&quot;/dev/xyz&quot;, O_RDWR);  //打开文件（设备）
read(fd, &amp;val, 1);  //读fd文件（设备）的值到val变量
</code></pre>
<p>除了C语言，在golang中也有类似的结构体+函数指针实现的面向对象方法。<br>NOTE:关于结构体中的函数指针写法易错点：<br>不包含变量名，只能使用基本类型</p>
<pre><code>   #一个结构体
   typedef stru&#123;    //定义结构体名
        int a;
        char b;
   &#125;stru_t, *stru_p; //重定义结构体变量和指针
    
    #普通函数声明
    int func(int a, stru_p p); //参数写类型且写值，可以使用typedef后的结构体指针类型
    
    #函数指针声明
    int (*func)(int, struct stru *);    //参数只写类型不写参数，只能使用C基本类型，不能使用typedef后的类型，只能写struct stru *类型
</code></pre>
<p>函数指针声明使用typedef后的类型名，编译器不认识，产生syntax error。    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cursorhu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cursorhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cursorhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2449055512@qq.com" title="E-Mail → mailto:2449055512@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cursorhu</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
