<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/my_icon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/my_icon/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/my_icon/manifest.json">
  <meta name="msapplication-config" content="/images/my_icon/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cursorhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="STM32–Firmware Architecture part1：开发环境和HAL API应用STM32–开发环境当前主流的几种方案：(软件免费，无法律风险)： 1.STM32CubeMX + Keil（社区版）+ VSCode：使用CubeMX快速创建工程并导出为MDK-ARM项目文件，使用Keil编译调试MDK-ARM项目包，使用VSCode编辑代码和版本管理。 优势：兼容老项目，资料最多；">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32--Firmware Architecture part1：开发环境和HAL API应用">
<meta property="og:url" content="https://cursorhu.github.io/2024/10/30/STM32--Firmware%20Architecture%20part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL%20API%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="ThinkNotes">
<meta property="og:description" content="STM32–Firmware Architecture part1：开发环境和HAL API应用STM32–开发环境当前主流的几种方案：(软件免费，无法律风险)： 1.STM32CubeMX + Keil（社区版）+ VSCode：使用CubeMX快速创建工程并导出为MDK-ARM项目文件，使用Keil编译调试MDK-ARM项目包，使用VSCode编辑代码和版本管理。 优势：兼容老项目，资料最多；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101741846.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101708801.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131502283.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102037591.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039243.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039879.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102040886.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102042899.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102043211.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102047297.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405170952108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102059394.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d8d908434dad4d18b654fdbefa5778b9.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/fa87d75e57db492e8a86582baf8971be.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4ccfeec4537a4a40ad5a8102707c2705.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102056555.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131142491.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131603031.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131605456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131606693.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131542062.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557835.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557727.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131633379.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131647697.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131708364.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737151.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737965.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131747355.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132023514.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171539178.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541038.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541688.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132036579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132055783.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132106226.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132127552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132125954.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141625450.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141148488.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141206215.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141407505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141409488.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141701291.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141715633.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141705044.png">
<meta property="article:published_time" content="2024-10-30T09:52:38.000Z">
<meta property="article:modified_time" content="2025-11-21T03:35:50.938Z">
<meta property="article:author" content="cursorhu">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101741846.png">

<link rel="canonical" href="https://cursorhu.github.io/2024/10/30/STM32--Firmware%20Architecture%20part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL%20API%E5%BA%94%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STM32--Firmware Architecture part1：开发环境和HAL API应用 | ThinkNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ThinkNotes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Simple is not easy | 化繁为简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cursorhu.github.io/2024/10/30/STM32--Firmware%20Architecture%20part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL%20API%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cursorhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ThinkNotes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STM32--Firmware Architecture part1：开发环境和HAL API应用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-30 17:52:38" itemprop="dateCreated datePublished" datetime="2024-10-30T17:52:38+08:00">2024-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-21 11:35:50" itemprop="dateModified" datetime="2025-11-21T11:35:50+08:00">2025-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32/" itemprop="url" rel="index"><span itemprop="name">STM32</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="STM32–Firmware-Architecture-part1：开发环境和HAL-API应用"><a href="#STM32–Firmware-Architecture-part1：开发环境和HAL-API应用" class="headerlink" title="STM32–Firmware Architecture part1：开发环境和HAL API应用"></a>STM32–Firmware Architecture part1：开发环境和HAL API应用</h1><h1 id="STM32–开发环境"><a href="#STM32–开发环境" class="headerlink" title="STM32–开发环境"></a>STM32–开发环境</h1><p>当前主流的几种方案：(软件免费，无法律风险)：</p>
<p>1.STM32CubeMX + Keil（社区版）+ VSCode：使用CubeMX快速创建工程并导出为MDK-ARM项目文件，使用Keil编译调试MDK-ARM项目包，使用VSCode编辑代码和版本管理。</p>
<p>优势：兼容老项目，资料最多；Keil的调试经验可以复用到其他非STM32 ARM芯片；</p>
<p><a target="_blank" rel="noopener" href="https://www.keil.arm.com/mdk-community/">https://www.keil.arm.com/mdk-community/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubemx.html">https://www.st.com/en/development-tools/stm32cubemx.html</a></p>
<p>2.STM32CubeIDE：ST主推的方式，专用于ST32芯片的IDE，本质是STM32CubeMX + Eclipse IDE + ST的编译调试工具链。</p>
<p>优势：集成度最高；缺陷：只用于STM32</p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/en/development-tools/stm32cubeide.html#overview">https://www.st.com/en/development-tools/stm32cubeide.html#overview</a></p>
<p>3.VSCode + ARM&#x2F;ST插件 + GDB + OpenOCD + + STM32CubeMX</p>
<p>优势：通用性最强，对各类ARM&#x2F;RISCV等SOC都适用此方案。</p>
<p>缺陷：资料少，GDB debug效率没有Keil高。</p>
<p><a target="_blank" rel="noopener" href="https://stm32world.com/wiki/STM32_development_and_debugging_using_VSCode">https://stm32world.com/wiki/STM32_development_and_debugging_using_VSCode</a></p>
<p>结论：对于生产环境的STM32开发还是首选方案1，Keil社区版的功能和付费版基本一致。</p>
<h1 id="STM32–必读手册和固件"><a href="#STM32–必读手册和固件" class="headerlink" title="STM32–必读手册和固件"></a>STM32–必读手册和固件</h1><h2 id="STM32开发手册"><a href="#STM32开发手册" class="headerlink" title="STM32开发手册"></a>STM32开发手册</h2><p>helps-&gt;docs &amp; resource, 下载F0系列的：</p>
<p>Data Sheet(DS), Reference Manual(RM), Programming Manual(PM). </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101741846.png" alt="image-20240510174102795"></p>
<p>此外还有F1系列才有的<strong>User Manual UM1850</strong>，里面详细介绍各外设Driver的设计标准和API如何使用，对F0的Firmware也是通用，去ST官网下载。</p>
<h2 id="STM32固件包"><a href="#STM32固件包" class="headerlink" title="STM32固件包"></a>STM32固件包</h2><p>CubeMX&#x2F;CubeMXIDE首次运行STM32工程会要求安装STM32FXX的固件包，路径：CubeMX工程管理页面 -&gt; Firmware Package Path</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405101708801.png" alt="image-20240510170810653"></p>
<p>原厂固件包的作用：</p>
<p>1.固件包是MCU厂商提供，学习任何一种MCU应该首先参考原厂固件包，不然容易被第三方教程误导。</p>
<p>2.对于STM32CubeMX, 其创建工程的原理是从固件包拷贝现成的模板代码，再根据用户在GUI界面配置的外设功能参数，自动输出项目代码。这个操作类似于VisualStudio开发MFC&#x2F;WinForm GUI应用，GUI模块被自动生成C#代码。</p>
<p>对于STM32F072xb的固件包，重点关注：</p>
<p>1.固件说明文档：STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Documentation\STM32CubeF0GettingStarted.pdf</p>
<p>2.模板代码和示例代码：STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Projects\STM32072B_EVAL\Examples</p>
<p>3.User Manual：整个固件库的代码文档，一般用HAL库关键词索引完整API定义</p>
<p>STM32Cube\Repository\STM32Cube_FW_F0_V1.11.4\Drivers\STM32F0xx_HAL_Driver\STM32F072xB_User_Manual.chm</p>
<h2 id="小结：STM32项目的代码架构"><a href="#小结：STM32项目的代码架构" class="headerlink" title="小结：STM32项目的代码架构"></a>小结：STM32项目的代码架构</h2><p>根据开发手册和固件包文档做个小结。</p>
<p>STM32固件的架构，这也是STM32 Firmware项目的基本架构：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131502283.png" alt="image-20240513150236222"></p>
<ol>
<li>HAL和LL APIs是ST提供的STM32 chipset API，目的是hide theMCU and peripheral complexity to end user</li>
</ol>
<p>区别：</p>
<p>HAL drivers offer high-level and function-oriented APIs, with a high level of portability. Product&#x2F;IPs complexity is hidden for end users.</p>
<p>LL drivers offer low-layer APIs at registers level, with a better optimization but less portability. They require a deep knowledge of product&#x2F;IPs specifications.</p>
<p>HAL可以理解为硬件协议层，不直接配置register level，只实现通信协议和硬件配置流程。</p>
<p>LL是register level，完全不涉及通信协议和设备流程性的配置。</p>
<p>SysTick interrupts 只能在HAL使用，LL API无法调用SysTick interrupts，因为SysTick实际上是Hardware Timer的应用，而不是操作timer本身。</p>
<ol start="2">
<li><p>CMSIS（Cortex Microcontroller Software Interface Standard)  ARM指定的Cortex-M 硬件抽象层标准</p>
</li>
<li><p>Middleware：相当于应用层的基础库。The middleware is a set of libraries covering USB Device Libraries, STMTouch touch sensing, STemWin, FreeRTOS and FatFS</p>
</li>
</ol>
<h1 id="STM32–编译过程"><a href="#STM32–编译过程" class="headerlink" title="STM32–编译过程"></a>STM32–编译过程</h1><p>对于嵌入式代码的分析，首先应该看Makefile，去总览项目结构和编译过程。</p>
<p>以下有两种编译生态：</p>
<ol>
<li><p>Keil style：在Keil中编译MDK-ARM工程，编译过程被Keil隐藏到项目配置中；</p>
</li>
<li><p>Makefile style：CubeMX将MDK-ARM工程输出为Makefile工程，能一次看清整个编译过程。</p>
</li>
</ol>
<h2 id="Keil-style"><a href="#Keil-style" class="headerlink" title="Keil style"></a>Keil style</h2><h3 id="Keil编译配置"><a href="#Keil编译配置" class="headerlink" title="Keil编译配置"></a>Keil编译配置</h3><p>指定ARM编译器，指定代码目标是RAM\Flash位置的基地址</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102037591.png" alt="image-20240510203738554"></p>
<p>指定输出文件</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039243.png" alt="image-20240510203910212"></p>
<p>链接输出的符号总览文件.map</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102039879.png" alt="image-20240510203928847"></p>
<p>编译的后处理过程，从hex生产bin</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102040886.png" alt="image-20240510204028853"></p>
<p>指定代码优化级别，警告级别，语言标准；指定头文件，组合成编译参数</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102042899.png" alt="image-20240510204213867"></p>
<p>指定汇编器，一些伪汇编符号语法(syntax)和汇编器类型相关，例如Arm syntax和GUN syntax有很大差异</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102043211.png" alt="image-20240510204344181"></p>
<p>指定链接文件(scatter file), 功能对应Makefile的.ld链接脚本文件，用于指定各段分布。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102047297.png" alt="image-20240510204720264"></p>
<p>Debug和JLink烧录的配置，这里勾选JLink烧录后自动reset启动新程序:</p>
<p>这里实际是Keil调用JFlash烧写，需要指定Flash地址和大小，一般和Keil项目配置的ROM区间一致</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405170952108.png" alt="image-20240517095249013"></p>
<p>项目的目录配置中指定哪些.c参与编译:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102059394.png" alt="image-20240510205959362"></p>
<h3 id="Keil链接配置"><a href="#Keil链接配置" class="headerlink" title="Keil链接配置"></a>Keil链接配置</h3><p>Keil的链接脚本是.sct文件，链接配置的主要作用是在对.o文件链接时，指定链接基础地址，指定排列顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LR_IROM1 0x08000000 0x00020000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x08000000 0x00020000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20000000 0x00004000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个比较重要的概念：</p>
<ol>
<li>加载域与执行域</li>
</ol>
<p>LR： Load Address，MCU从哪个空间加载代码</p>
<p>ER：Execute Address，MCU在哪个空间执行代码</p>
<p>以上STM32链接脚本，所有Flash的代码(IROM: *.o, RO, XO)的执行域和加载域都是Flash(0x08000000 ~ 0x00020000)，且指定bootloader entry：RESET为最开始执行的函数。</p>
<p>RAM的代码(IRAM: RW, ZI)加载域是SRAM，这部分是数据是运行时直接在RAM初始化，不需要从Flash取指令。</p>
<p><img src="https://img-blog.csdnimg.cn/d8d908434dad4d18b654fdbefa5778b9.png#pic_center" alt="img"></p>
<p>下图示例是执行Flash的RO data时，RW数据段（有初始值的数据）应该被bootloader拷贝到RAM。</p>
<p><img src="https://img-blog.csdnimg.cn/fa87d75e57db492e8a86582baf8971be.png#pic_center" alt="img"></p>
<ol start="2">
<li>代码段，数据段，BSS段…</li>
</ol>
<p>STM32的代码段分布如下表, 其中CODE（包括RO&#x2F;RW CODE和TEXT），DATA(RO&#x2F;RW DATA)，ZI(BSS) 即常规意义的可执行程序的三段。</p>
<p>在.sct链接脚本中对应：RO，RW和ZI(zero initialized )<br>      RO是程序中的指令和常量<br>      RW是程序中已初始化变量<br>      ZI是程序中未初始化或初始化为0的变量</p>
<p><img src="https://img-blog.csdnimg.cn/4ccfeec4537a4a40ad5a8102707c2705.png" alt="img"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/apythonlearner/article/details/133034055">【STM32】sct 分散加载文件的格式与应用</a></p>
<h2 id="Makefile-style"><a href="#Makefile-style" class="headerlink" title="Makefile style"></a>Makefile style</h2><h3 id="makefile编译配置"><a href="#makefile编译配置" class="headerlink" title="makefile编译配置"></a>makefile编译配置</h3><p>将已有的CubeMX+MDK工程输出为Makefile工程，产生Makefile和STM32F072C8Tx_FLASH.ld文件.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405102056555.png" alt="image-20240510205610521"></p>
<p>Makefile分析：</p>
<p>指定编译目标，debug和优化级别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># target</span><br><span class="line">TARGET = stm32f072c8t6</span><br><span class="line"># debug build?</span><br><span class="line">DEBUG = 1</span><br><span class="line"># optimization</span><br><span class="line">OPT = -Og</span><br></pre></td></tr></table></figure>

<p>指定参与编译的源码.c和.s  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># C sources</span><br><span class="line">C_SOURCES =  \</span><br><span class="line">Core/Src/main.c \</span><br><span class="line">Core/Src/gpio.c \</span><br><span class="line">Core/Src/can.c \</span><br><span class="line">Core/Src/i2c.c \</span><br><span class="line">Core/Src/spi.c \</span><br><span class="line">Core/Src/usart.c \</span><br><span class="line">Core/Src/stm32f0xx_it.c \</span><br><span class="line">Core/Src/stm32f0xx_hal_msp.c \</span><br><span class="line">....</span><br><span class="line">Core/Src/system_stm32f0xx.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_core.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_ctlreq.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Core/Src/usbd_ioreq.c \</span><br><span class="line">Middlewares/ST/STM32_USB_Device_Library/Class/CustomHID/Src/usbd_customhid.c \</span><br><span class="line">Core/Src/sysmem.c \</span><br><span class="line">Core/Src/syscalls.c </span><br><span class="line"></span><br><span class="line"># ASM sources</span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">startup_stm32f072xb.s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定目标平台的编译器和链接器，指定输出hex&#x2F;bin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PREFIX = arm-none-eabi-</span><br><span class="line"></span><br><span class="line">CC = $(PREFIX)gcc</span><br><span class="line">AS = $(PREFIX)gcc -x assembler-with-cpp</span><br><span class="line">CP = $(PREFIX)objcopy</span><br><span class="line">SZ = $(PREFIX)size</span><br><span class="line"></span><br><span class="line">HEX = $(CP) -O ihex</span><br><span class="line">BIN = $(CP) -O binary -S</span><br></pre></td></tr></table></figure>

<p>编译参数CFLAGS和ASFLAGS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU = -mcpu=cortex-m0</span><br><span class="line"># float-abi</span><br><span class="line">MCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)</span><br></pre></td></tr></table></figure>

<p>宏定义和头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># macros for gcc</span><br><span class="line"># AS defines</span><br><span class="line">AS_DEFS = </span><br><span class="line"></span><br><span class="line"># C defines</span><br><span class="line">C_DEFS =  \</span><br><span class="line">-DUSE_HAL_DRIVER \</span><br><span class="line">-DSTM32F072xB</span><br><span class="line"></span><br><span class="line"># AS includes</span><br><span class="line">AS_INCLUDES = </span><br><span class="line"></span><br><span class="line"># C includes</span><br><span class="line">C_INCLUDES =  \</span><br><span class="line">-ICore/Inc \</span><br><span class="line">-IUSB_DEVICE/App \</span><br><span class="line">-IUSB_DEVICE/Target \</span><br><span class="line">-IDrivers/STM32F0xx_HAL_Driver/Inc \</span><br><span class="line">-IDrivers/STM32F0xx_HAL_Driver/Inc/Legacy \</span><br><span class="line">-IMiddlewares/ST/STM32_USB_Device_Library/Core/Inc \</span><br><span class="line">-IMiddlewares/ST/STM32_USB_Device_Library/Class/CustomHID/Inc \</span><br><span class="line">-IDrivers/CMSIS/Device/ST/STM32F0xx/Include \</span><br><span class="line">-IDrivers/CMSIS/Include</span><br></pre></td></tr></table></figure>

<p>最终的完整GCC FLAGS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># compile gcc flags</span><br><span class="line">ASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br><span class="line"></span><br><span class="line">CFLAGS += $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections</span><br></pre></td></tr></table></figure>

<p>链接脚本与库路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># link script</span><br><span class="line">LDSCRIPT = STM32F072C8Tx_FLASH.ld</span><br><span class="line"></span><br><span class="line"># libraries</span><br><span class="line">LIBS = -lc -lm -lnosys </span><br><span class="line">LIBDIR = </span><br><span class="line">LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections</span><br></pre></td></tr></table></figure>

<p>输出文件：elf + hex + bin，参考：[elf,hex,bin,axf的区别](# elf,hex,bin,axf的区别)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># default action: build all</span><br><span class="line">all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin</span><br></pre></td></tr></table></figure>

<p>编译执行部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># list of objects</span><br><span class="line">OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))</span><br><span class="line">vpath %.c $(sort $(dir $(C_SOURCES)))</span><br><span class="line"># list of ASM program objects</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))</span><br><span class="line">vpath %.s $(sort $(dir $(ASM_SOURCES)))</span><br><span class="line">OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASMM_SOURCES:.S=.o)))</span><br><span class="line">vpath %.S $(sort $(dir $(ASMM_SOURCES)))</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) </span><br><span class="line">	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)</span><br><span class="line">	$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(BUILD_DIR)/%.o: %.S Makefile | $(BUILD_DIR)</span><br><span class="line">	$(AS) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile</span><br><span class="line">	$(CC) $(OBJECTS) $(LDFLAGS) -o $@</span><br><span class="line">	$(SZ) $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	$(HEX) $&lt; $@</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)</span><br><span class="line">	$(BIN) $&lt; $@	</span><br><span class="line">	</span><br><span class="line">$(BUILD_DIR):</span><br><span class="line">	mkdir $@</span><br></pre></td></tr></table></figure>

<p>清理编译输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	-rm -fR $(BUILD_DIR)</span><br></pre></td></tr></table></figure>

<h3 id="makefile链接配置"><a href="#makefile链接配置" class="headerlink" title="makefile链接配置"></a>makefile链接配置</h3><p>GNU linker（LD）的语法参考：<a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/index.html">GNU linker ld (GNU Binutils)</a></p>
<p>STM32F072C8Tx_FLASH.ld：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* Entry Point */</span><br><span class="line">ENTRY(Reset_Handler)</span><br><span class="line"></span><br><span class="line">/* Highest address of the user mode stack */</span><br><span class="line">_estack = ORIGIN(RAM) + LENGTH(RAM);    /* end of RAM */</span><br><span class="line">/* Generate a link error if heap and stack don&#x27;t fit into RAM */</span><br><span class="line">_Min_Heap_Size = 0x300;      /* required amount of heap  */</span><br><span class="line">_Min_Stack_Size = 0x500; /* required amount of stack */</span><br><span class="line"></span><br><span class="line">/* Specify the memory areas */</span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 16K</span><br><span class="line">FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 64K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Define output sections */</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* The startup code goes first into FLASH */</span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    KEEP(*(.isr_vector)) /* Startup code */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* The program code and other data goes into FLASH */</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.text)           /* .text sections (code) */</span><br><span class="line">    *(.text*)          /* .text* sections (code) */</span><br><span class="line">    *(.glue_7)         /* glue arm to thumb code */</span><br><span class="line">    *(.glue_7t)        /* glue thumb to arm code */</span><br><span class="line">    *(.eh_frame)</span><br><span class="line"></span><br><span class="line">    KEEP (*(.init))</span><br><span class="line">    KEEP (*(.fini))</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _etext = .;        /* define a global symbols at end of code */</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* Constant data goes into FLASH */</span><br><span class="line">  .rodata :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.rodata)         /* .rodata sections (constants, strings, etc.) */</span><br><span class="line">    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH</span><br><span class="line">  .ARM : &#123;</span><br><span class="line">    __exidx_start = .;</span><br><span class="line">    *(.ARM.exidx*)</span><br><span class="line">    __exidx_end = .;</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .preinit_array     :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_start = .);</span><br><span class="line">    KEEP (*(.preinit_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .init_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.init_array.*)))</span><br><span class="line">    KEEP (*(.init_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .fini_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.fini_array.*)))</span><br><span class="line">    KEEP (*(.fini_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  /* used by the startup to initialize data */</span><br><span class="line">  _sidata = LOADADDR(.data);</span><br><span class="line"></span><br><span class="line">  /* Initialized data sections goes into RAM, load LMA copy after code */</span><br><span class="line">  .data : </span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _sdata = .;        /* create a global symbol at data start */</span><br><span class="line">    *(.data)           /* .data sections */</span><br><span class="line">    *(.data*)          /* .data* sections */</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _edata = .;        /* define a global symbol at data end */</span><br><span class="line">  &#125; &gt;RAM AT&gt; FLASH</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  /* Uninitialized data section */</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  .bss :</span><br><span class="line">  &#123;</span><br><span class="line">    /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">    _sbss = .;         /* define a global symbol at bss start */</span><br><span class="line">    __bss_start__ = _sbss;</span><br><span class="line">    *(.bss)</span><br><span class="line">    *(.bss*)</span><br><span class="line">    *(COMMON)</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _ebss = .;         /* define a global symbol at bss end */</span><br><span class="line">    __bss_end__ = _ebss;</span><br><span class="line">  &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">  /* User_heap_stack section, used to check that there is enough RAM left */</span><br><span class="line">  ._user_heap_stack :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">    PROVIDE ( end = . );</span><br><span class="line">    PROVIDE ( _end = . );</span><br><span class="line">    . = . + _Min_Heap_Size;</span><br><span class="line">    . = . + _Min_Stack_Size;</span><br><span class="line">    . = ALIGN(8);</span><br><span class="line">  &#125; &gt;RAM</span><br></pre></td></tr></table></figure>

<h2 id="编译输出-elf-hex-bin-axf的区别"><a href="#编译输出-elf-hex-bin-axf的区别" class="headerlink" title="编译输出: elf,hex,bin,axf的区别"></a>编译输出: elf,hex,bin,axf的区别</h2><p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131142491.png" alt="image-20240513114246442"></p>
<h2 id="链接输出的-map符号表"><a href="#链接输出的-map符号表" class="headerlink" title="链接输出的.map符号表"></a>链接输出的.map符号表</h2><p>链接过程可以输出.map符号表，可用于分析代码和数据分布，再裁剪代码。</p>
<ol>
<li>ROM(Flash)的.hex&#x2F;bin文件的符号分布:</li>
</ol>
<p>可以看到，.sct指定的首个符号RESET在最开始位置，其他符号是链接器自动排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Memory Map of the image</span><br><span class="line"></span><br><span class="line">  Image Entry point : 0x080000c1</span><br><span class="line"></span><br><span class="line">  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x000082f0, Max: 0x00020000, ABSOLUTE, COMPRESSED[0x00008148])</span><br><span class="line"></span><br><span class="line">    Execution Region ER_IROM1 (Exec base: 0x08000000, Load base: 0x08000000, Size: 0x00007f84, Max: 0x00020000, ABSOLUTE)</span><br><span class="line"></span><br><span class="line">    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object</span><br><span class="line"></span><br><span class="line">    0x08000000   0x08000000   0x000000c0   Data   RO            3    RESET               startup_stm32f072xb.o</span><br><span class="line">    0x080000c0   0x080000c0   0x00000000   Code   RO         2440  * .ARM.Collect$$$$00000000  mc_p.l(entry.o)</span><br><span class="line">    0x080000c0   0x080000c0   0x00000004   Code   RO         2728    .ARM.Collect$$$$00000001  mc_p.l(entry2.o)</span><br><span class="line">    0x080000c4   0x080000c4   0x00000004   Code   RO         2731    .ARM.Collect$$$$00000004  </span><br><span class="line">    </span><br><span class="line">    ....         </span><br><span class="line"></span><br><span class="line">mc_p.l(init.o)</span><br><span class="line">    0x08000244   0x08000244   0x00000020   Code   RO         2768    .text               mc_p.l(llshl.o)</span><br><span class="line">    0x08000264   0x08000264   0x00000056   Code   RO         2784    .text               mc_p.l(__dczerorl2.o)</span><br><span class="line">    0x080002ba   0x080002ba   0x00000002   PAD</span><br><span class="line">    0x080002bc   0x080002bc   0x00000064   Code   RO          769    .text.CDC_Control_FS  usbd_cdc_if.o</span><br><span class="line">    0x08000320   0x08000320   0x00000004   Code   RO          767    .text.CDC_DeInit_FS  usbd_cdc_if.o</span><br><span class="line">    0x08000324   0x08000324   0x00000024   Code   RO          765    .text.CDC_Init_FS   usbd_cdc_if.o</span><br><span class="line">    0x08000348   0x08000348   0x00000034   Code   RO          771    .text.CDC_Receive_FS  usbd_cdc_if.o</span><br><span class="line">    0x0800037c   0x0800037c   0x00000044   Code   RO          773    .text.CDC_Transmit_FS  usbd_cdc_if.o</span><br><span class="line">    0x080003c0   0x080003c0   0x00000010   Code   RO          136    .text.CEC_CAN_IRQHandler  stm32f0xx_it.o</span><br><span class="line">    0x080003d0   0x080003d0   0x00000004   Code   RO          750    .text.CUSTOM_HID_DeInit_FS  usbd_custom_hid_if.o</span><br><span class="line">    0x080003d4   0x080003d4   0x00000004   Code   RO          748    .text.CUSTOM_HID_Init_FS  usbd_custom_hid_if.o</span><br><span class="line"></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>RAM中的数据段分布，包括.data段和.bss段：</p>
<p>可以看到，有初始值和无初始值的全局变量分布在.data和.bss区域。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Execution Region RW_IRAM1 (Exec base: 0x20000000, Load base: 0x08007f88, Size: 0x000021b8, Max: 0x00004000, ABSOLUTE, COMPRESSED[0x000001c0])</span><br><span class="line"></span><br><span class="line">    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object</span><br><span class="line"></span><br><span class="line">    0x20000000   COMPRESSED   0x00000004   Data   RW         2742    .data               mc_p.l(stdout.o)</span><br><span class="line">    0x20000004   COMPRESSED   0x00000008   Data   RW         1117    .data..L_MergedGlobals  stm32f0xx_hal.o</span><br><span class="line">    0x2000000c   COMPRESSED   0x00000022   Data   RW          754    .data.CUSTOM_HID_ReportDesc_FS  usbd_custom_hid_if.o</span><br><span class="line">    0x2000002e   COMPRESSED   0x00000002   PAD</span><br><span class="line">    0x20000030   COMPRESSED   0x0000001c   Data   RW          733    .data.FS_Desc       usbd_desc.o</span><br><span class="line">    0x2000004c   COMPRESSED   0x00000004   Data   RW         2228    .data.SystemCoreClock  system_stm32f0xx.o</span><br><span class="line">    0x20000050   COMPRESSED   0x00000038   Data   RW         2427    .data.USBD_CDC      usbd_cdc.o</span><br><span class="line">    0x20000088   COMPRESSED   0x00000043   Data   RW         2429    .data.USBD_CDC_CfgFSDesc  usbd_cdc.o</span><br><span class="line">    0x200000cb   COMPRESSED   0x00000001   PAD</span><br><span class="line">    0x200000cc   COMPRESSED   0x00000043   Data   RW         2428    .data.USBD_CDC_CfgHSDesc  usbd_cdc.o</span><br><span class="line">    0x2000010f   COMPRESSED   0x00000001   PAD</span><br><span class="line">    0x20000110   COMPRESSED   0x0000000a   Data   RW         2431    .data.USBD_CDC_DeviceQualifierDesc  usbd_cdc.o</span><br><span class="line">    0x2000011a   COMPRESSED   0x00000002   PAD</span><br><span class="line">    0x2000011c   COMPRESSED   0x00000010   Data   RW          775    .data.USBD_CDC_Interface_fops_FS  usbd_cdc_if.o</span><br><span class="line">    0x2000012c   COMPRESSED   0x00000008   Data   RW          776    .data.USBD_CDC_LineCoding  usbd_cdc_if.o</span><br><span class="line">    0x20000134   COMPRESSED   0x00000043   Data   RW         2430    .data.USBD_CDC_OtherSpeedCfgDesc  usbd_cdc.o</span><br><span class="line">  </span><br><span class="line">  ....</span><br><span class="line">  </span><br><span class="line">    0x20000368        -       0x0000002c   Zero   RW           29    .bss..L_MergedGlobals  main.o</span><br><span class="line">    0x20000394        -       0x00000030   Zero   RW          287    .bss..L_MergedGlobals  systime.o</span><br><span class="line">    0x200003c4        -       0x00000024   Zero   RW          569    .bss..L_MergedGlobals  can.o</span><br><span class="line">    0x200003e8        -       0x00000048   Zero   RW          756    .bss..L_MergedGlobals  usbd_custom_hid_if.o</span><br><span class="line">    0x20000430        -       0x00000008   Zero   RW         2388    .bss..L_MergedGlobals  usbd_composite.o</span><br><span class="line">    0x20000438        -       0x00000400   Zero   RW           25    .bss.UART2_RxBuffer  main.o</span><br><span class="line">    0x20000838        -       0x00000001   Zero   RW         2299    .bss.USBD_SetConfig.cfgidx  usbd_ctlreq.o</span><br><span class="line">    0x20000839   COMPRESSED   0x00000003   PAD</span><br><span class="line">    0x2000083c        -       0x00000200   Zero   RW          737    .bss.USBD_StrDesc   usbd_desc.o</span><br><span class="line">    0x20000a3c        -       0x00000040   Zero   RW          778    .bss.UserRxBufferFS  usbd_cdc_if.o</span><br><span class="line">    0x20000a7c        -       0x00000040   Zero   RW          779    .bss.UserTxBufferFS  usbd_cdc_if.o</span><br><span class="line">    0x20000abc        -       0x00000001   Zero   RW          777    .bss.cdc_receive_flag  usbd_cdc_if.o</span><br><span class="line">    0x20000abd   COMPRESSED   0x00000003   PAD</span><br><span class="line">    0x20000ac0        -       0x000002c4   Zero   RW          712    .bss.hUsbDeviceFS   usb_device.o</span><br><span class="line">    0x20000d84        -       0x00000028   Zero   RW          568    .bss.hcan           can.o</span><br><span class="line">    0x20000dac        -       0x00000044   Zero   RW          109    .bss.hdma_usart2_rx  usart.o</span><br><span class="line">    0x20000df0        -       0x0000004c   Zero   RW           59    .bss.hi2c1          i2c.o</span><br><span class="line">    0x20000e3c        -       0x000002f4   Zero   RW          850    .bss.hpcd_USB_FS    usbd_conf.o</span><br><span class="line">    0x20001130        -       0x00000064   Zero   RW           77    .bss.hspi1          spi.o</span><br><span class="line">    0x20001194        -       0x00000048   Zero   RW          419    .bss.htim6          tim.o</span><br><span class="line">    0x200011dc        -       0x00000084   Zero   RW          106    .bss.huart1         usart.o</span><br><span class="line">    0x20001260        -       0x00000084   Zero   RW          107    .bss.huart2         usart.o</span><br><span class="line">    0x200012e4        -       0x00000084   Zero   RW          108    .bss.huart3         usart.o</span><br><span class="line">    0x20001368        -       0x00000001   Zero   RW          227    .bss.i2c_error      usb_handle.o</span><br><span class="line">    0x20001369        -       0x00000400   Zero   RW          239    .bss.inter_buffer   uart_data_analysis.o</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>输出的hex&#x2F;bin中，各.obj对应的Code， Data， ZI段大小：</p>
<p>可快速定位哪些代码占用Flash&#x2F;RAM空间过大。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Image component sizes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line">        26          4          0          0         76       4060   can.o</span><br><span class="line">        48          4          0          0          0       1769   dma.o</span><br><span class="line">       348          0          0          0          0       9083   fifo.o</span><br><span class="line">        92         16          0          0          0       3240   flash.o</span><br><span class="line">       258          0          0          0          0       4158   general_function.o</span><br><span class="line">       252         16          0          0          0       2882   gpio.o</span><br><span class="line">       428         72          0          0         76       7196   i2c.o</span><br><span class="line">         2          0          0          0          0      23860   jaguar.o</span><br><span class="line">       788        128          0          0       2092       8846   main.o</span><br><span class="line">       872        206         25          0        152      10137   one_wire.o</span><br><span class="line">       268         28          0         32        100       5426   spi.o</span><br><span class="line">        28          8        192          0       1280        656   startup_stm32f072xb.o</span><br><span class="line">       168         24          0          8          4       5420   stm32f0xx_hal.o</span><br><span class="line">       958          6          0          0          0      14230   stm32f0xx_hal_can.o</span><br><span class="line">       164         28          0          0          0       5576   stm32f0xx_hal_cortex.o</span><br><span class="line">       678         12          0          0          0       8163   stm32f0xx_hal_dma.o</span><br><span class="line">       694         32          0          0          0       4994   stm32f0xx_hal_gpio.o</span><br><span class="line">      1786         60          0          0          0      63508   stm32f0xx_hal_i2c.o</span><br><span class="line">       132          0          0          0          0       5319   stm32f0xx_hal_i2c_ex.o</span><br><span class="line">        44          4          0          0          0       1058   stm32f0xx_hal_msp.o</span><br><span class="line">      3124        100          0          0          0      15820   stm32f0xx_hal_pcd.o</span><br><span class="line">        96          0          0          0          0       5855   stm32f0xx_hal_pcd_ex.o</span><br><span class="line">      1672         52         32          0          0       8371   stm32f0xx_hal_rcc.o</span><br><span class="line">       328         12          0          0          0       6715   stm32f0xx_hal_rcc_ex.o</span><br><span class="line">      1544          8          0          0          0      27530   stm32f0xx_hal_spi.o</span><br><span class="line">       736         44          0          0          0      63633   stm32f0xx_hal_tim.o</span><br><span class="line">        96          0          0          0          0      22483   stm32f0xx_hal_tim_ex.o</span><br><span class="line">      2884         92         16          0          0      41313   stm32f0xx_hal_uart.o</span><br><span class="line">       122          0          0          0          0       8856   stm32f0xx_hal_uart_ex.o</span><br><span class="line">       106         20          0          0          0       2835   stm32f0xx_it.o</span><br><span class="line">      3540        152          0          0          0      23016   stm32f0xx_ll_usb.o</span><br><span class="line">         2          0         24          4          0       1745   system_stm32f0xx.o</span><br><span class="line">       236         36          0          0         48       2973   systime.o</span><br><span class="line">       152         20          0          0         72       5392   tim.o</span><br><span class="line">       160         12          0          0       1024       1279   uart_data_analysis.o</span><br><span class="line">       828         84          0          0        464       7567   usart.o</span><br><span class="line">        64         12          0          0        708       2859   usb_device.o</span><br><span class="line">      1268        120          0          0          1       9115   usb_handle.o</span><br><span class="line">       722         20          0        267         92      10062   usbd_cdc.o</span><br><span class="line">       260         24          0         24        129       4611   usbd_cdc_if.o</span><br><span class="line">       452         64          0        181          8       5864   usbd_composite.o</span><br><span class="line">       758         32          0          0        756      15665   usbd_conf.o</span><br><span class="line">       718          0          0          0          0       8036   usbd_core.o</span><br><span class="line">      1252         28          0          0          1       8339   usbd_ctlreq.o</span><br><span class="line">       140         16          0         50         72       3641   usbd_custom_hid_if.o</span><br><span class="line">       594         46          0        198         84       7979   usbd_customhid.o</span><br><span class="line">       504        144          0         76        512       4167   usbd_desc.o</span><br><span class="line">       162          0          0          0          0       4514   usbd_ioreq.o</span><br></pre></td></tr></table></figure>

<h1 id="STM32–启动过程"><a href="#STM32–启动过程" class="headerlink" title="STM32–启动过程"></a>STM32–启动过程</h1><p>本部分介绍从上电到进入main函数的过程。</p>
<h2 id="启动位置"><a href="#启动位置" class="headerlink" title="启动位置"></a>启动位置</h2><p>STM32能从Flash&#x2F;SRAM或System memory(远程)启动。启动位置直接决定链接脚本的加载和运行的基地址配置。</p>
<p>如何确认：</p>
<ol>
<li>查固件包Reference Manual：对于F0系列，由BOOT0 pin和nBOOT1 register bit决定启动位置。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131603031.png" alt="image-20240513160303987"></p>
<ol start="2">
<li>查开发板BOOT0 pin：下拉接地，因此开发板是Boot from Flash。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131605456.png" alt="image-20240513160533426"></p>
<ol start="3">
<li>顺便查一下nBOOT1 register：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131606693.png" alt="image-20240513160652648"></p>
<h2 id="startup-s"><a href="#startup-s" class="headerlink" title="startup.s"></a>startup.s</h2><p>根据链接脚本指定的asm找到启动文件startup_stm32f072xb.s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ASM sources</span><br><span class="line">ASM_SOURCES =  \</span><br><span class="line">startup_stm32f072xb.s</span><br></pre></td></tr></table></figure>

<p>根据链接脚本的RESET符号，找到CPU复位时执行指令的入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp                   ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                  ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                    ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler              ; Hard Fault Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SVC_Handler                    ; SVCall Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     PendSV_Handler                 ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler                ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">                DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">                DCD     RCC_IRQHandler                 ; RCC</span><br><span class="line">                DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">                DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">                DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">                DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">                DCD     DMA1_Channel4_5_IRQHandler     ; DMA1 Channel 4 and Channel 5</span><br><span class="line">                DCD     ADC1_IRQHandler                ; ADC1 </span><br><span class="line">                DCD     TIM1_BRK_UP_TRG_COM_IRQHandler ; TIM1 Break, Update, Trigger and Commutation</span><br><span class="line">                DCD     TIM1_CC_IRQHandler             ; TIM1 Capture Compare</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM3_IRQHandler                ; TIM3</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM14_IRQHandler               ; TIM14</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM16_IRQHandler               ; TIM16</span><br><span class="line">                DCD     TIM17_IRQHandler               ; TIM17</span><br><span class="line">                DCD     I2C1_IRQHandler                ; I2C1</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SPI1_IRQHandler                ; SPI1</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     USART1_IRQHandler              ; USART1</span><br><span class="line">                DCD     USART2_IRQHandler              ; USART2</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     USB_IRQHandler                 ; USB</span><br><span class="line"></span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure>

<p>这里面的AREA&#x2F;DCD等伪汇编符号含义，参考[指令集与伪汇编](# 指令集与伪汇编)</p>
<p>以上代码声明了中断向量表，定义CPU中断、异常发生时的入口地址。</p>
<p>STM32 中断向量表的定义参考固件包Program Manual：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131542062.png" alt="image-20240513154213024"></p>
<p>MCU启动或者reset时：</p>
<p>PC指针从0x0: __initial_sp取指令，<del>此处没任何内容</del>  此处不是个指令，而是栈顶指针的值，由编译器根据代码量+StackSize自动生成；《STM32–Firmware Architecture part2》详细分析如何生成。</p>
<p>然后PC + 4，从0x4取指令，即执行Reset_Handler：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler routine</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler                 [WEAK]</span><br><span class="line">        IMPORT  __main</span><br><span class="line">        IMPORT  SystemInit  </span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>

<p>这里先后执行SystemInit和__main</p>
<ol>
<li>SystemInit的作用如下，o2link代码没有用此函数（空）</li>
</ol>
<p>This function is called at startup just after reset and before branch to main program. User can setups the default system clock (System clock source, PLL Multiplier and Divider factors, AHB&#x2F;APBx prescalers and Flash settings</p>
<ol start="2">
<li>__main符号即C的main函数 <em>int</em> main(<em>void</em>)，从此进入C代码执行。</li>
</ol>
<h2 id="指令集与伪汇编"><a href="#指令集与伪汇编" class="headerlink" title="指令集与伪汇编"></a>指令集与伪汇编</h2><p>指令集：MCU硬件决定的指令，例如STM32是Cortex M0指令集。 详见固件包Program Manual。</p>
<p>伪汇编指令：是编译器扩展的汇编语法，取决于编译器类型。根据汇编器找user guide，例如 armasm：</p>
<p><a target="_blank" rel="noopener" href="https://documentation-service.arm.com/static/63eb50c09567172d4e2aa777">https://documentation-service.arm.com/static/63eb50c09567172d4e2aa777</a></p>
<ol>
<li>Cortex M0指令集：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557835.png" alt="image-20240513155719763"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131557727.png" alt="image-20240513155736664"></p>
<ol start="2">
<li>armasm的一些伪汇编指令：</li>
</ol>
<blockquote>
<p>AREA:声明一块区域的属性，例如：AREA A64ex, CODE, READONLY;  Name this block of code A64ex</p>
<p>EXPORT：使符号对其他文件可见。Labels are local to the source file unless you make them global using the EXPORT directive  </p>
<p>DCD: Declares one or more words of store. 声明一块区域，如果区域是函数符号表示声明该函数所占用的区域。</p>
</blockquote>
<h1 id="STM32–main初始化流程"><a href="#STM32–main初始化流程" class="headerlink" title="STM32–main初始化流程"></a>STM32–main初始化流程</h1><h2 id="HAL-Init"><a href="#HAL-Init" class="headerlink" title="HAL_Init"></a>HAL_Init</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">	HAL_Init();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */</span><br><span class="line">HAL_InitTick(TICK_INT_PRIORITY);</span><br><span class="line">--&gt; HAL_SYSTICK_Config: Configure the SysTick to have interrupt in 1ms time basis</span><br><span class="line">--&gt; HAL_NVIC_SetPriority: Configure the SysTick IRQ priority</span><br></pre></td></tr></table></figure>

<ol>
<li>关于HAL_SYSTICK_Config的底层实现（参考HAL user manual.chm：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00043    (+) The HAL_SYSTICK_Config()function calls the SysTick_Config() function which</span><br><span class="line">00044        is a CMSIS function that:</span><br><span class="line">00045         (++) Configures the SysTick Reload register with value passed as function parameter.</span><br><span class="line">00046         (++) Configures the SysTick IRQ priority to the lowest value (0x03).</span><br><span class="line">00047         (++) Resets the SysTick Counter register.</span><br><span class="line">00048         (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).</span><br><span class="line">00049         (++) Enables the SysTick Interrupt.</span><br><span class="line">00050         (++) Starts the SysTick Counter.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关于systick的NVIC中断优先级：</li>
</ol>
<p> * <em>@note</em> In the default implementation, SysTick timer is the source of time base. </p>
<p> *    It is used to generate interrupts at regular time intervals. </p>
<p> *    Care must be taken if HAL_Delay() is called from a peripheral ISR process, </p>
<p> *    The SysTick interrupt must have higher priority (numerically lower) </p>
<p> *    than the peripheral interrupt. Otherwise the caller ISR process will be blocked.</p>
<ol start="3">
<li>STM32 所有的中断和异常的优先级总表，参考Reference Manual：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131633379.png" alt="image-20240513163316319"></p>
<h2 id="SystemClock-Config"><a href="#SystemClock-Config" class="headerlink" title="SystemClock_Config"></a>SystemClock_Config</h2><ol>
<li>整个时钟树配置参数可以在CubeMX初始化项目时配置，系统时钟SYSCLK有外部HSE（8M OSC）和内部HSI（内部RC）多个源，由下图当前配置生效的是HSI 48M RC作为源。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131647697.png" alt="image-20240513164731624"></p>
<p>不同外设模式对时钟树的要求：</p>
<blockquote>
<p>I2c input frequency should up to 48M to support 1M i2c clock.</p>
<p>UART input frequency should be changed to HIS 8M to support lower than 1K baud rate and changed to 48M to support 1M baud rate.</p>
<p>USB modules need 48M input frequency</p>
</blockquote>
<ol start="2">
<li>系统时钟配置过程：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Configure the system clock */</span><br><span class="line">	SystemClock_Config();</span><br></pre></td></tr></table></figure>

<p>主要分两步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Initializes the RCC Oscillators</span><br><span class="line">Initializes the CPU, AHB and APB buses clocks</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>具体配置过程，以HAL_RCC_OscConfig的HSI Configuration为例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">HAL_RCC_OscConfig：</span><br><span class="line"></span><br><span class="line">/*----------------------------- HSI Configuration --------------------------*/ </span><br><span class="line">  if(((RCC_OscInitStruct-&gt;OscillatorType) &amp; RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)</span><br><span class="line">  &#123;</span><br><span class="line">    /* Check the parameters */</span><br><span class="line">    assert_param(IS_RCC_HSI(RCC_OscInitStruct-&gt;HSIState));</span><br><span class="line">    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct-&gt;HSICalibrationValue));</span><br><span class="line">    </span><br><span class="line">    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ </span><br><span class="line">    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) </span><br><span class="line">       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) &amp;&amp; (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))</span><br><span class="line">    &#123;</span><br><span class="line">      /* When HSI is used as system clock it will not disabled */</span><br><span class="line">      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) &amp;&amp; (RCC_OscInitStruct-&gt;HSIState != RCC_HSI_ON))</span><br><span class="line">      &#123;</span><br><span class="line">        return HAL_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">      /* Otherwise, just the calibration is allowed */</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/</span><br><span class="line">        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct-&gt;HSICalibrationValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      /* Check the HSI State */</span><br><span class="line">      if(RCC_OscInitStruct-&gt;HSIState != RCC_HSI_OFF)</span><br><span class="line">      &#123;</span><br><span class="line">       /* Enable the Internal High Speed oscillator (HSI). */</span><br><span class="line">        __HAL_RCC_HSI_ENABLE();</span><br><span class="line">        </span><br><span class="line">        /* Get Start Tick */</span><br><span class="line">        tickstart = HAL_GetTick();</span><br><span class="line">        </span><br><span class="line">        /* Wait till HSI is ready */</span><br><span class="line">        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)</span><br><span class="line">        &#123;</span><br><span class="line">          if((HAL_GetTick() - tickstart ) &gt; HSI_TIMEOUT_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">            return HAL_TIMEOUT;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/</span><br><span class="line">        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct-&gt;HSICalibrationValue);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        /* Disable the Internal High Speed oscillator (HSI). */</span><br><span class="line">        __HAL_RCC_HSI_DISABLE();</span><br><span class="line">        </span><br><span class="line">        /* Get Start Tick */</span><br><span class="line">        tickstart = HAL_GetTick();</span><br><span class="line">        </span><br><span class="line">        /* Wait till HSI is disabled */</span><br><span class="line">        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)</span><br><span class="line">        &#123;</span><br><span class="line">          if((HAL_GetTick() - tickstart ) &gt; HSI_TIMEOUT_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">            return HAL_TIMEOUT;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里判断HSI时钟源Ready的代码逻辑：</p>
<ul>
<li><p>根据时钟类型，读对应的register的ready bit是否为0。</p>
</li>
<li><p>如果到超时没ready，即此时钟不可用，继续初始化其他时钟。</p>
</li>
</ul>
<p>这里有个问题：系统时钟源还没配置完，为什么可以用HAL_GetTick去判断Ready超时，systick从哪来？</p>
<p>原因：CPU Reset后默认使用HSI时钟，前面的HAL_Init利用HSI初始化了1ms systick功能，因此systick可用；SystemClock_Config只是再次配置时钟，并不是说此时没有时钟。</p>
<ol start="4">
<li>判断时钟源ready register相关的代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)：</span><br><span class="line"></span><br><span class="line">typedef enum </span><br><span class="line">&#123;</span><br><span class="line">  RESET = 0U, </span><br><span class="line">  SET = !RESET</span><br><span class="line">&#125; FlagStatus, ITStatus;</span><br><span class="line"></span><br><span class="line">#define RCC_FLAG_HSERDY                  ((uint8_t)((CR_REG_INDEX &lt;&lt; 5U) | RCC_CR_HSERDY_BitNumber))</span><br><span class="line">#define CR_REG_INDEX                     ((uint8_t)1U)</span><br><span class="line">#define RCC_CR_HSERDY_BitNumber           17</span><br><span class="line"></span><br><span class="line">#define __HAL_RCC_GET_FLAG(__FLAG__) (((((__FLAG__) &gt;&gt; 5U) == CR_REG_INDEX)? RCC-&gt;CR :      \</span><br><span class="line">                                       (((__FLAG__) &gt;&gt; 5U) == CR2_REG_INDEX)? RCC-&gt;CR2 :    \</span><br><span class="line">                                       (((__FLAG__) &gt;&gt; 5U) == BDCR_REG_INDEX) ? RCC-&gt;BDCR : \</span><br><span class="line">                                       RCC-&gt;CSR) &amp; (1U &lt;&lt; ((__FLAG__) &amp; RCC_FLAG_MASK)))</span><br></pre></td></tr></table></figure>

<p>RCC-&gt;CR的定义为例：bit17为HSE RDY bit.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131708364.png" alt="image-20240513170841325"></p>
<h2 id="MX-GPIO-Init"><a href="#MX-GPIO-Init" class="headerlink" title="MX_GPIO_Init"></a>MX_GPIO_Init</h2><p>GPIO初始化入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Initialize all configured peripherals */</span><br><span class="line">	MX_GPIO_Init();</span><br></pre></td></tr></table></figure>

<p>GPIO重点描述几个话题：</p>
<ol>
<li><p>GPIO分组与复用</p>
<p>GPIO有A~F多组，各组的pin独立；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737151.png" alt="image-20240513173750127"></p>
<p>每组GPIO pin都有复用不同的功能；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131737965.png" alt="image-20240513173701913"></p>
</li>
<li><p>GPIO的模式</p>
<p>参考Datasheet：Each of the GPIO pins can be configured by software as output (push-pull or open-drain), as input (with or without pull-up or pull-down) or as peripheral alternate function.   </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405131747355.png" alt="image-20240513174736319"></p>
<p>输出模式的开漏和推挽模式的主要特性：</p>
<p>（1）开漏输出的高电平不是MCU驱动的，MCU仅作为控制源；输出高电平是借助外部上拉电平；可以自定义输出电平，例如3.3V&#x2F;5V只需要调节上拉电平，不需受到MCU驱动能力限制。</p>
<p>（2）推挽输出的高电平是MCU驱动，即MCU通过内部P&#x2F;N MOS结构真正输出电压（一般3.3V），MCU驱动能力有限。</p>
</li>
</ol>
<p>GPIO代码示例（输出模式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//初始化配置模式：输出，推挽</span><br><span class="line">//恢复默认值（GPIO_PIN_RESET，0）</span><br><span class="line">/*Configure GPIO pin Output Level */</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_8 | GPIO_PIN_15, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">//配置模式</span><br><span class="line">/*Configure GPIO pin : PA */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_8 | GPIO_PIN_15;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">//使用：翻转PA15</span><br><span class="line">HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_15);</span><br><span class="line">//使用：设置高</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);</span><br></pre></td></tr></table></figure>

<p>GPIO中断模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//设置中断模式和优先级</span><br><span class="line">/*Configure GPIO pin : PB */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_4;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING; //中断模式</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">//GPIO_MODE_IT_RISING_FALLING实际是设置EXTI中断</span><br><span class="line">#define  GPIO_MODE_IT_RISING_FALLING            (MODE_INPUT | EXTI_IT | TRIGGER_RISING | TRIGGER_FALLING) </span><br><span class="line"></span><br><span class="line">/* EXTI interrupt init*/</span><br><span class="line">HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);</span><br><span class="line">HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);</span><br><span class="line"></span><br><span class="line">//中断回调</span><br><span class="line">//GPIO4实际是PB4，因为仅PB4设置为INT模式</span><br><span class="line">void EXTI4_15_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MX-DMA-Init"><a href="#MX-DMA-Init" class="headerlink" title="MX_DMA_Init"></a>MX_DMA_Init</h2><h3 id="DMA的常规操作"><a href="#DMA的常规操作" class="headerlink" title="DMA的常规操作"></a>DMA的常规操作</h3><p>参考UM1850：</p>
<p>How to use this driver</p>
<ol>
<li>Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM &#x2F;FLASH memories: no initialization is necessary). Please refer to the Reference manual for connectionbetween peripherals and DMA requests.</li>
<li>For a given Channel, program the required configuration through the following parameters: Channel request,Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level,Source and Destination Increment mode using HAL_DMA_Init() function.</li>
<li>Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of errordetection.4. Use HAL_DMA_Abort() function to abort the current transfer</li>
</ol>
<p>轮询和中断两种模式：</p>
<p>Polling mode IO operation</p>
<p>• Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred</p>
<p>• Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can beconfigured by User depending from his application</p>
<p>Interrupt mode IO operation</p>
<p>• Configure the DMA interrupt priority using HAL_NVIC_SetPriority()</p>
<p>• Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()</p>
<p>• Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred. In this case the DMA interrupt is configured</p>
<p>• Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine</p>
<p>• At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can add his own functionby customization of function pointer XferCpltCallback and XferErrorCallback (i.e. a member of DMA handlestructure).</p>
<h3 id="DMA-Init和IRQ-handler"><a href="#DMA-Init和IRQ-handler" class="headerlink" title="DMA_Init和IRQ handler"></a>DMA_Init和IRQ handler</h3><p>DMA用于UART RX传输中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void MX_DMA_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* DMA controller clock enable */</span><br><span class="line">  __HAL_RCC_DMA1_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  /* DMA interrupt init */</span><br><span class="line">  /* DMA1_Channel4_5_6_7_IRQn interrupt configuration */</span><br><span class="line">  HAL_NVIC_SetPriority(DMA1_Channel4_5_6_7_IRQn, 0, 0);</span><br><span class="line">  HAL_NVIC_EnableIRQ(DMA1_Channel4_5_6_7_IRQn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DMA1_Channel4_5_6_7_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">  HAL_DMA_IRQHandler(&amp;hdma_usart2_rx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Drivers\CMSIS\Device\ST\STM32F0xx\Include\stm32f072xb.h:</span><br><span class="line">DMA1_Channel4_5_6_7_IRQn    = 11,     /*!&lt; DMA1 Channel 4 to Channel 7 Interrupt </span><br><span class="line"></span><br><span class="line">Drivers\CMSIS\Device\ST\STM32F0xx\Source\Templates\arm\startup_stm32f072xb.s:</span><br><span class="line">IRQ 11的handler即DMA1_Channel4_5_6_7_IRQHandler</span><br><span class="line">; External Interrupts</span><br><span class="line">DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">DCD     PVD_VDDIO2_IRQHandler          ; PVD through EXTI Line detect</span><br><span class="line">DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">DCD     RCC_CRS_IRQHandler             ; RCC and CRS</span><br><span class="line">DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">DCD     TSC_IRQHandler                 ; TS</span><br><span class="line">DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">DCD     DMA1_Channel4_5_6_7_IRQHandler ; DMA1 Channel 4, Channel 5, Channel 6 and Channel 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UART RX 使用DMA channel 5 处理接收数据中断</span><br><span class="line">HAL_UART_MspInit()：</span><br><span class="line">/* USART2 DMA Init */</span><br><span class="line">    /* USART2_RX Init */</span><br><span class="line">    hdma_usart2_rx.Instance = DMA1_Channel5;</span><br><span class="line">    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;</span><br><span class="line">    if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HAL_DMA_IRQHandler的具体操作:</p>
<p>处理DMA传输完成中断：分为half transfer complete和Transfer Complete两种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Transfer Complete Interrupt management ***********************************/</span><br><span class="line">  else if ((RESET != (flag_it &amp; (DMA_FLAG_TC1 &lt;&lt; hdma-&gt;ChannelIndex))) &amp;&amp; (RESET != (source_it &amp; DMA_IT_TC)))</span><br><span class="line">  &#123;</span><br><span class="line">  	if((hdma-&gt;Instance-&gt;CCR &amp; DMA_CCR_CIRC) == 0U)</span><br><span class="line">  	&#123;</span><br><span class="line">  		/* Disable the transfer complete  &amp; transfer error interrupts */</span><br><span class="line">  		/* if the DMA mode is not CIRCULAR */</span><br><span class="line">  		hdma-&gt;Instance-&gt;CCR &amp;= ~(DMA_IT_TC | DMA_IT_TE);</span><br><span class="line">  		</span><br><span class="line">  		/* Change the DMA state */</span><br><span class="line">  		hdma-&gt;State = HAL_DMA_STATE_READY;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	/* Clear the transfer complete flag */</span><br><span class="line">  	hdma-&gt;DmaBaseAddress-&gt;IFCR = DMA_FLAG_TC1 &lt;&lt; hdma-&gt;ChannelIndex;</span><br></pre></td></tr></table></figure>

<p>DMA传输完成的回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(hdma-&gt;XferCpltCallback != NULL)</span><br><span class="line">  	&#123;</span><br><span class="line">  		/* Transfer complete callback */</span><br><span class="line">  		hdma-&gt;XferCpltCallback(hdma);</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<p>o2link的UART2处理1KB DMA buffer的自定义逻辑，就是在此中断回调中实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UART_Start_Receive_DMA():</span><br><span class="line">/* Set the UART DMA transfer complete callback */</span><br><span class="line">    huart-&gt;hdmarx-&gt;XferCpltCallback = UART_DMAReceiveCplt;</span><br></pre></td></tr></table></figure>

<p>DMA传输错误中断的判断和回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Transfer Error Interrupt management ***************************************/</span><br><span class="line">  else if (( RESET != (flag_it &amp; (DMA_FLAG_TE1 &lt;&lt; hdma-&gt;ChannelIndex))) &amp;&amp; (RESET != (source_it &amp; DMA_IT_TE)))</span><br><span class="line">  &#123;</span><br><span class="line">  	/* When a DMA transfer error occurs */</span><br><span class="line">    /* A hardware clear of its EN bits is performed */</span><br><span class="line">    /* Then, disable all DMA interrupts */</span><br><span class="line">    hdma-&gt;Instance-&gt;CCR &amp;= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);</span><br><span class="line">    </span><br><span class="line">    /* Clear all flags */</span><br><span class="line">    hdma-&gt;DmaBaseAddress-&gt;IFCR = DMA_FLAG_GL1 &lt;&lt; hdma-&gt;ChannelIndex;</span><br><span class="line">    </span><br><span class="line">    /* Update error code */</span><br><span class="line">    hdma-&gt;ErrorCode = HAL_DMA_ERROR_TE;</span><br><span class="line">    </span><br><span class="line">    /* Change the DMA state */</span><br><span class="line">    hdma-&gt;State = HAL_DMA_STATE_READY;    </span><br><span class="line">    </span><br><span class="line">    /* Process Unlocked */</span><br><span class="line">    __HAL_UNLOCK(hdma); </span><br><span class="line">    </span><br><span class="line">    if(hdma-&gt;XferErrorCallback != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    	/* Transfer error callback */</span><br><span class="line">    	hdma-&gt;XferErrorCallback(hdma);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="DMA-channel和外设的对应关系"><a href="#DMA-channel和外设的对应关系" class="headerlink" title="DMA channel和外设的对应关系"></a>DMA channel和外设的对应关系</h3><p>参考（RM0091）：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132023514.png" alt="image-20240513202302455"></p>
<h2 id="MX-I2C1-Init"><a href="#MX-I2C1-Init" class="headerlink" title="MX_I2C1_Init"></a>MX_I2C1_Init</h2><p>首先明确一个问题：是硬件实现的I2C还是软件GPIO模拟的I2C？</p>
<p>怎么确认：看电路图+Datasheet+底层数据传输代码</p>
<ul>
<li>硬件I2C：此GPIO应该支持I2C功能，Datasheet确认，软件查看是否配成了I2C功能，数据传输是否配置I2C register</li>
<li>软件I2C：此GPIO是普通的GPIO功能，用软件控制high、low和delay控制I2C数据传输，底层操作不是用I2C register实现。</li>
</ul>
<p>根据以下，本环境是硬件I2C功能。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171539178.png" alt="image-20240517153927141"><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541038.png" alt="image-20240517154143995"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405171541688.png" alt="image-20240517154158646"></p>
<p>下面看初始化代码。</p>
<p>I2C初始化包括两步：</p>
<ol>
<li>设置I2C通信参数</li>
</ol>
<p>速度：standard (up to 100 kHz), Fast-mode (up to 400 kHz) or Fast-mode Plus (up to 1 MHz)  </p>
<p>寻址：7-bit&#x2F;10 bit addressing mode，决定i2c slave设备寻址空间</p>
<p>其他能力见RM0091:</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132036579.png" alt="image-20240513203608542"></p>
<p>代码配置的速度和寻址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hi2c1.Init.Timing = SETTING_CLK_100K;</span><br><span class="line">hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置GPIO pin为I2C模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Init</span><br><span class="line"></span><br><span class="line">--&gt; HAL_I2C_MspInit:</span><br><span class="line"></span><br><span class="line">/**I2C1 GPIO Configuration</span><br><span class="line">PB6   ------&gt; I2C1_SCL</span><br><span class="line">PB7   ------&gt; I2C1_SDA</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_I2C1;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="MX-SPI1-Init"><a href="#MX-SPI1-Init" class="headerlink" title="MX_SPI1_Init"></a>MX_SPI1_Init</h2><p>和I2C初始化结构基本类似</p>
<ol>
<li><p>设置SPI通信参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hspi1.Init.Mode = SPI_MODE_MASTER;</span><br><span class="line">hspi1.Init.Direction = SPI_DIRECTION_2LINES; //双向</span><br><span class="line">hspi1.Init.DataSize = SPI_DATASIZE_8BIT; //数据是8bit模式</span><br><span class="line">hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH; //</span><br><span class="line">hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;</span><br></pre></td></tr></table></figure>

<p>关于SPI配置，主要关注数据模式是8bit还是16bit, 以及数据采样和传输的时间点(极性和相位)。</p>
<p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/689464409">SPI的四种传输模式及工作机制分析</a></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132055783.png" alt="image-20240513205538749"></p>
<p>黑线为数据采样点，与之相反为数据发送点</p>
</li>
<li><p>设置GPIO为SPI模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**SPI1 GPIO Configuration</span><br><span class="line">PA5     ------&gt; SPI1_SCK</span><br><span class="line">PA6     ------&gt; SPI1_MISO</span><br><span class="line">PA7     ------&gt; SPI1_MOSI</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MX-USART1-UART-Init"><a href="#MX-USART1-UART-Init" class="headerlink" title="MX_USART1_UART_Init"></a>MX_USART1_UART_Init</h2><p>对于o2link board, 使用三个UART：</p>
<p>(1) UART 1 PA9 PA10 is used as debug port.</p>
<p>(2) UART 2 PA2 PA3 is used as USB TO UART port</p>
<p>(3) UART 3 PB10 PB11 is used as system communication port.</p>
<p>本节讨论UART1</p>
<ol>
<li><p>设置UART通信参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">huart1.Instance = USART1;</span><br><span class="line">huart1.Init.BaudRate = 115200; //波特率</span><br><span class="line">huart1.Init.WordLength = UART_WORDLENGTH_8B; //8-bit long UART frame(可配7,8,9bit)</span><br><span class="line">huart1.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">huart1.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">huart1.Init.Mode = UART_MODE_TX_RX; //双向</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置GPIO为UART模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**USART1 GPIO Configuration</span><br><span class="line">PA9     ------&gt; USART1_TX</span><br><span class="line">PA10     ------&gt; USART1_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_USART1;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
</li>
<li><p>UART Idle frame和Break frame的概念</p>
<p>为什么UART pin默认拉高？</p>
<p>UART除了正常的数据传输情况，还有idle和break frame的特殊情况：</p>
<p>An Idle character is interpreted as an entire frame of “1”s (the number of “1”s includes the number of stop bits).</p>
<p>A Break character is interpreted on receiving “0”s for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132106226.png" alt="image-20240513210648197"></p>
<p>默认上拉, 如果MCU没有drive UART RX&#x2F;TX pin为低，则可以识别为idle frame；</p>
<p>默认上拉，UART start时MCU开始drive RX&#x2F;TX, 直接拉低pin形成Start信号。</p>
</li>
</ol>
<h2 id="MX-USART2-UART-Init"><a href="#MX-USART2-UART-Init" class="headerlink" title="MX_USART2_UART_Init"></a>MX_USART2_UART_Init</h2><p>o2link的UART 2 PA2 PA3 is used as USB TO UART port.</p>
<p>什么是USB to UART：涉及USB CDC虚拟串口的概念，参考： <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#Communications_Devices_Class_-CDC-_2">Communications Devices Class (CDC)</a>，即USB实现的虚拟串口协议；</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132127552.png" alt="image-20240513212722508"></p>
<p>MCU侧配置UART2参数是来自于USBD_CDC_LineCoding.</p>
<p>对于o2link的USB to UART2:</p>
<p>UART TX has no buffer, it will send data directly to the TX pin when it receives data from USB HID, the max data is 64 bytes one time. UART RX has 1K bytes buffer, it uses idle frame to receive data, when it sees this idle frame, it will generate interrupt to tell the app code, and the app code will split data into 64 bytes and transmit the data to the USB.  </p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405132125954.png" alt="image-20240513212534924"></p>
<h3 id="UART2初始化过程"><a href="#UART2初始化过程" class="headerlink" title="UART2初始化过程"></a>UART2初始化过程</h3><ol>
<li>根据USB CDC的配置，设置UART2参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void MX_USART2_UART_Init(uint32_t baurate)</span><br><span class="line">&#123;</span><br><span class="line">  USBD_CDC_LineCoding.bitrate = baurate; //1000 000</span><br><span class="line">  USBD_CDC_LineCoding.paritytype = UART_PARITY_NONE;</span><br><span class="line">  USBD_CDC_LineCoding.datatype = UART_WORDLENGTH_8B;</span><br><span class="line">  USBD_CDC_LineCoding.format = UART_STOPBITS_1;</span><br><span class="line">  UART2_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UART2_Init():</span><br><span class="line"></span><br><span class="line">huart2.Init.BaudRate = USBD_CDC_LineCoding.bitrate;</span><br><span class="line">switch (USBD_CDC_LineCoding.paritytype)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">    break;</span><br><span class="line">  case 1:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_ODD;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    huart2.Init.Parity = UART_PARITY_EVEN;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart3.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (USBD_CDC_LineCoding.datatype)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0x07:</span><br><span class="line">    huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    break;</span><br><span class="line">  case 0x08:</span><br><span class="line">    if (huart2.Init.Parity == UART_PARITY_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">      huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      huart2.Init.WordLength = UART_WORDLENGTH_9B;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart2.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (USBD_CDC_LineCoding.format)</span><br><span class="line">  &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_2;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    huart2.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>配置GPIO，配置UART使用DMA模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**USART2 GPIO Configuration</span><br><span class="line">PA2     ------&gt; USART2_TX</span><br><span class="line">PA3     ------&gt; USART2_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF1_USART2;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">/* USART2 DMA Init */</span><br><span class="line">/* USART2_RX Init */</span><br><span class="line">hdma_usart2_rx.Instance = DMA1_Channel5;</span><br><span class="line">hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">hdma_usart2_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;</span><br><span class="line">if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__HAL_LINKDMA(uartHandle, hdmarx, hdma_usart2_rx);</span><br><span class="line"></span><br><span class="line">/* USART2 interrupt Init */</span><br><span class="line">HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);</span><br><span class="line">HAL_NVIC_EnableIRQ(USART2_IRQn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动DMA，随时准备处理UART RX的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">reset_uart_buffer() </span><br><span class="line">--&gt;</span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2, UART2_RxBuffer, UART_PACKAGE_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">参数如下：</span><br><span class="line">* @param huart UART handle.</span><br><span class="line">* @param pData Pointer to data buffer (uint8_t or uint16_t data elements).</span><br><span class="line">* @param Size  Amount of data elements (uint8_t or uint16_t) to be received.</span><br><span class="line"></span><br><span class="line">其中UART2_RxBuffer是1KB buffer， UART_PACKAGE_MAX_SIZE = 1024</span><br><span class="line"></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA的内容：</span><br><span class="line">/* Set Reception type to reception till IDLE Event*/</span><br><span class="line">huart-&gt;ReceptionType = HAL_UART_RECEPTION_TOIDLE; //Reception till completion or IDLE event. 即UART有idle frame能产生DMA中断，不一定要传输完整个buffer的1KB数据。</span><br><span class="line">//启动DMA</span><br><span class="line">status = UART_Start_Receive_DMA(huart, pData, Size);</span><br></pre></td></tr></table></figure>

<p>启动DMA传输的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UART_Start_Receive_DMA():</span><br><span class="line"></span><br><span class="line">/* Set the UART DMA transfer complete callback */</span><br><span class="line">huart-&gt;hdmarx-&gt;XferCpltCallback = UART_DMAReceiveCplt;</span><br><span class="line">/* Enable the DMA channel */</span><br><span class="line">HAL_DMA_Start_IT()    </span><br></pre></td></tr></table></figure>

<p>UART_DMAReceiveCplt里面自定义了完成的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">UART_DMAReceiveCplt()</span><br><span class="line">--&gt; HAL_UARTEx_RxEventCallback():</span><br><span class="line"></span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">&#123;</span><br><span class="line">	/* Prevent unused argument(s) compilation warning */</span><br><span class="line">	UNUSED(huart);</span><br><span class="line">	UNUSED(Size);</span><br><span class="line"></span><br><span class="line">	if (huart-&gt;Instance == USART2)</span><br><span class="line">	&#123;</span><br><span class="line">	    //Size是DMA已传输完的总长度（DMA硬件自动计算）</span><br><span class="line">        //Rx_buf_pos是firmware自定义, 记录RX buffer的偏移。 </span><br><span class="line">		//Rx_length即当前DMA complete的传输数据长度（不包括历史总长度）</span><br><span class="line">		Rx_length = Size - Rx_buf_pos;</span><br><span class="line">		if ((Size &lt; Rx_buf_pos) || (Size &gt; UART_PACKAGE_MAX_SIZE))</span><br><span class="line">		&#123;</span><br><span class="line">			Rx_buf_pos = Size;</span><br><span class="line">			if (Rx_buf_pos &gt;= UART_PACKAGE_MAX_SIZE)</span><br><span class="line">				Rx_buf_pos = 0;</span><br><span class="line">			printf(&quot;dma buffer error\r\n &quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//这里uart_rx_fifo和UART2_RxBuffer都是1KB buffer，uart_rx_fifo用于每次DMA的buffer，每次数据都从0开始存；UART2_RxBuffer是存储多次DMA的总数据，按偏移组合；</span><br><span class="line">		fifo_s_puts(&amp;uart_rx_fifo, (char *)&amp;UART2_RxBuffer[Rx_buf_pos], Rx_length);</span><br><span class="line">		Rx_buf_pos += Rx_length;</span><br><span class="line">		if (Rx_buf_pos &gt;= UART_PACKAGE_MAX_SIZE) //1024</span><br><span class="line">			Rx_buf_pos = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解以上代码，就可以理解USB to UART2的RX机制，是将下位机的大量UART data(最多1024 bytes)，分多次DMA存到UART2_RxBuffer，再按64bytes&#x2F;USB buffer发给上位机。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141625450.png" alt="image-20240514162541398"></p>
</li>
</ol>
<h3 id="UART的DMA传输小结"><a href="#UART的DMA传输小结" class="headerlink" title="UART的DMA传输小结"></a>UART的DMA传输小结</h3><p>UART为什么使用DMA：</p>
<ol>
<li>常规的UART传输，不管是轮询还是中断，一般需要先指定好传输长度是多少个byte，即必须数据长度已知。</li>
</ol>
<p>常规的UART传输如何知道传输完成：</p>
<p>如果是轮询就预估超时时间，如果是中断就按传输完成多少byte作为标志。</p>
<ol start="2">
<li>使用DMA中断的UART传输，可以支持不定长度的数据。</li>
</ol>
<p>使用DMA的UART如何知道传输完成：</p>
<p>数据传输完成；或者有UART event如Idle event，RTO event…</p>
<h2 id="MX-USART3-UART-Init"><a href="#MX-USART3-UART-Init" class="headerlink" title="MX_USART3_UART_Init"></a>MX_USART3_UART_Init</h2><p>UART 3 PB10 PB11 is used as system communication port.</p>
<p>和UART1配置区别仅在波特率，uart3实例没实际使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huart3.Init.BaudRate = 1000000;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**USART3 GPIO Configuration</span><br><span class="line">PB10     ------&gt; USART3_TX</span><br><span class="line">PB11     ------&gt; USART3_RX</span><br><span class="line">*/</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_10 | GPIO_PIN_11;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF4_USART3;</span><br><span class="line">HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<h2 id="MX-USB-DEVICE-Init"><a href="#MX-USB-DEVICE-Init" class="headerlink" title="MX_USB_DEVICE_Init"></a>MX_USB_DEVICE_Init</h2><p>USB设备的功能实现从上到下分为几层API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Middleware层的USB API：usbd_core (.c, .h), 例如USBD_Init</span><br><span class="line">--&gt; Low level层的USB API：例如USBD_LL_Init</span><br><span class="line">--&gt; HAL的USB host或peripheral API：例如HAL_PCD_Init</span><br><span class="line"></span><br><span class="line">HCD：USB host controller driver</span><br><span class="line">PCD：USB peripheral controller driver</span><br></pre></td></tr></table></figure>

<p>参考： <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#USB_device_library_overview">USB device library overview</a></p>
<p>下面具体分析USB初始化各层负责什么工作：</p>
<p>USBD_Init：Initializes the device stack and load the class driver. 负责USB协议范畴的设备class，设备descriptor等信息的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Unlink previous class*/</span><br><span class="line">  if (pdev-&gt;pClass != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    pdev-&gt;pClass = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Assign USBD Descriptors */</span><br><span class="line">  if (pdesc != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    pdev-&gt;pDesc = pdesc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Set Device initial State */</span><br><span class="line">  pdev-&gt;dev_state = USBD_STATE_DEFAULT;</span><br><span class="line">  pdev-&gt;id = id;</span><br></pre></td></tr></table></figure>

<p>USBD_LL_Init：Initializes the low level portion of the device driver. 负责PCD设备对象的初始化，包括设备属性，设备初始化，DMA配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PCD_HandleTypeDef hpcd_USB_FS;</span><br><span class="line"></span><br><span class="line">/* Link the driver to the stack. */</span><br><span class="line">hpcd_USB_FS.pData = pdev;</span><br><span class="line">pdev-&gt;pData = &amp;hpcd_USB_FS;</span><br><span class="line">//设备属性</span><br><span class="line">hpcd_USB_FS.Instance = USB;</span><br><span class="line">hpcd_USB_FS.Init.dev_endpoints = 8;</span><br><span class="line">hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;</span><br><span class="line">hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;</span><br><span class="line">hpcd_USB_FS.Init.low_power_enable = DISABLE;</span><br><span class="line">hpcd_USB_FS.Init.lpm_enable = DISABLE;</span><br><span class="line">hpcd_USB_FS.Init.battery_charging_enable = DISABLE;</span><br><span class="line"></span><br><span class="line">//设备初始化</span><br><span class="line">if (HAL_PCD_Init(&amp;hpcd_USB_FS) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//DMA配置</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , 0x00 , PCD_SNG_BUF, 0x28);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , 0x80 , PCD_SNG_BUF, 0x80);</span><br><span class="line"></span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CUSTOM_HID_EPIN_ADDR , PCD_SNG_BUF, 0xc0);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CUSTOM_HID_EPOUT_ADDR , PCD_SNG_BUF, 0x100);</span><br><span class="line"></span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_IN_EP , PCD_SNG_BUF, 0x140);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_OUT_EP , PCD_SNG_BUF, 0x180);</span><br><span class="line">HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev-&gt;pData , CDC_CMD_EP , PCD_SNG_BUF, 0x1c0);</span><br></pre></td></tr></table></figure>

<p>USB设备对象PCD_HandleTypeDef的定义：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141148488.png" alt="image-20240514114808440"></p>
<p>初始化完成后是USBD_RegisterClass和USBD_Start，结构类似不细讲。</p>
<p>最终通过HAL_PCD_Start返回的USBD_OK status确认初始化OK。</p>
<h2 id="MX-CAN-Init"><a href="#MX-CAN-Init" class="headerlink" title="MX_CAN_Init"></a>MX_CAN_Init</h2><p>目前o2link没使用MX_CAN_Init，代码为空</p>
<h2 id="MX-TIM6-Init"><a href="#MX-TIM6-Init" class="headerlink" title="MX_TIM6_Init"></a>MX_TIM6_Init</h2><p>关于timer有两点背景：</p>
<ol>
<li>hardware timer和systick(Cortex System Timer)的区别：</li>
</ol>
<p>从大概功能上看，都是计时器计数产生中断；</p>
<p>主要是应用上的区别：</p>
<p>a. systick精度一般是1ms，属于系统运行时就一直产生中断，生命周期不停的计时器；常用于应用层的ms_delay延时。</p>
<p>b. hardware timer精度可以达到us, ns，属于即用即停，单次运行的计时器；常用于硬件操作相关的，比如时序要求的us_delay延时。</p>
<ol start="2">
<li>STM32的hardware timer有几类：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141206215.png" alt="image-20240514120637192"></p>
<p>o2link只用到base timer 6. 以下讨论都是针对base timer 6</p>
<ol>
<li>timer的计时原理图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141407505.png" alt="image-20240514140729465"></p>
<ol start="2">
<li><p>timer的计时精度和最大时间</p>
<p>对timer模块时钟的分频决定精度：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TIME_BASE_1US 48</span><br><span class="line">#define TIME_BASE_100US 4800</span><br></pre></td></tr></table></figure>

<p> timer模块的时钟是48MHZ, 所以48分频为1us计时.</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141409488.png" alt="image-20240514140933458"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">htim6.Init.Prescaler = Prescaler - 1; //分频后的时钟，决定每个counter计数的时间间隔</span><br><span class="line">htim6.Init.CounterMode = TIM_COUNTERMODE_UP; //counter累加模式</span><br><span class="line">htim6.Init.Period = 0xffff; //最大counter数：65535</span><br><span class="line">htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE; //counter满后自动reload计数</span><br></pre></td></tr></table></figure>

<p>o2link设置timer6的Prescaler &#x3D; 4800, 即100us&#x2F;count，最大时间是100us*65535，约6.5s。</p>
<p>o2link对timer6的应用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim6);</span><br><span class="line">while (one_wire_timer_counter_100US &lt; one_wire_parameter.sync_high_time)&#123;&#125;;</span><br><span class="line">HAL_TIM_Base_Stop_IT(&amp;htim6);</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">#define one_wire_timer_counter_100US (htim6.Instance-&gt;CNT * 100) // 转化成微秒</span><br></pre></td></tr></table></figure>

<h2 id="使能irq和systick"><a href="#使能irq和systick" class="headerlink" title="使能irq和systick"></a>使能irq和systick</h2><p>全部外设配置完毕，启动系统：</p>
<p>enable irq：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  \brief   Enable IRQ Interrupts</span><br><span class="line">  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.</span><br><span class="line">           Can only be executed in Privileged modes.</span><br><span class="line"> */</span><br><span class="line">__STATIC_FORCEINLINE void __enable_irq(void)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM volatile (&quot;cpsie i&quot; : : : &quot;memory&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enable systick：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void systime_init()</span><br><span class="line">&#123;</span><br><span class="line">  systime_tick.tick_ms = 0;</span><br><span class="line">  systime_tick.tick_10ms = 0;</span><br><span class="line">  systime_tick.tick_100ms = 0;</span><br><span class="line">  systime_tick.tick_sec = 0;</span><br><span class="line">  systime_tick.tick_min = 0;</span><br><span class="line">  systime_tick.tick_hour = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  @brief:    Start systick, including IRQ (TBD)</span><br><span class="line"> *        Used when system is powered on</span><br><span class="line"> *  @param:    None</span><br><span class="line"> *  @return:  None</span><br><span class="line"> */</span><br><span class="line">void systime_start(void)</span><br><span class="line">&#123;</span><br><span class="line">  SysTick-&gt;CTRL |= (SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="STM32–while-loop业务流程"><a href="#STM32–while-loop业务流程" class="headerlink" title="STM32–while loop业务流程"></a>STM32–while loop业务流程</h1><p>以下分析基于o2link firmware</p>
<p>while(1)的处理主要分为几大类：</p>
<ol>
<li>用systick更新应用时间</li>
<li>处理UART DMA的RX buffer的数据</li>
<li>处理USB下发的控制信号</li>
</ol>
<h2 id="systick管理时间"><a href="#systick管理时间" class="headerlink" title="systick管理时间"></a>systick管理时间</h2><p>这个目前没什么应用，仅用于LED闪烁；真实用户场景可能用到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">systime_update()：</span><br><span class="line">void systime_update(void)</span><br><span class="line">&#123;</span><br><span class="line">  if (systime_tick.tick_ms != HAL_GetTick())</span><br><span class="line">  &#123;</span><br><span class="line">    systime_tick.tick_ms = HAL_GetTick();</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_10MS) == (TICKRATE_10MS - 1))</span><br><span class="line">      systime_tick.tick_10ms++;</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_100MS) == (TICKRATE_100MS - 1))</span><br><span class="line">      systime_tick.tick_100ms++;</span><br><span class="line">    if ((systime_tick.tick_ms % TICKRATE_HZ) == (TICKRATE_HZ - 1))</span><br><span class="line">    &#123;</span><br><span class="line">      systime_tick.tick_sec++;</span><br><span class="line">      systime_tick.tick_min = (systime_tick.tick_sec / MIN_UNIT);</span><br><span class="line">      systime_tick.tick_hour = (systime_tick.tick_sec / HOUR_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理UART-RX的DMA数据"><a href="#处理UART-RX的DMA数据" class="headerlink" title="处理UART RX的DMA数据"></a>处理UART RX的DMA数据</h2><p>UART从RX的DMA buffer中返回给USB接口，有USB-HID和USB-CDC两种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">uart_data_analysis():</span><br><span class="line">void uart_data_analysis(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t len;</span><br><span class="line">	uint8_t usb_back_buf[64] = &#123;0&#125;; //USB的buffer</span><br><span class="line">	uint8_t *buffer = inter_buffer;</span><br><span class="line">	len = fifo_s_used(&amp;uart_rx_fifo); // 待发送数据长度</span><br><span class="line">	if (len &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fifo_s_gets(&amp;uart_rx_fifo, (char *)inter_buffer, len); //从FIFO取数据</span><br><span class="line">		if (cdc_receive_flag == 0) //no CDC,即HID模式</span><br><span class="line">		&#123;</span><br><span class="line">			while (len &gt; 0) //fifo取到数据？</span><br><span class="line">			&#123;</span><br><span class="line">				usb_back_buf[0] = 0x01; //见o2link spec, 0101 for UART</span><br><span class="line">				usb_back_buf[1] = 0x01;</span><br><span class="line">				//fifo取了60bytes是否还有多的？4bytes是USB加的header</span><br><span class="line">				if (len &gt; MAX_USB_UART_PACKET_NUM)</span><br><span class="line">				&#123;</span><br><span class="line">					usb_back_buf[2] = (MAX_USB_UART_PACKET_NUM &amp; 0xff00) &gt;&gt; 8;</span><br><span class="line">					usb_back_buf[3] = (MAX_USB_UART_PACKET_NUM &amp; 0x00ff);</span><br><span class="line">					memcpy(&amp;usb_back_buf[4], buffer, MAX_USB_UART_PACKET_NUM);</span><br><span class="line">					usb_send(usb_back_buf, USB_TIMEOUT_TIME);</span><br><span class="line">					len -= MAX_USB_UART_PACKET_NUM;</span><br><span class="line">					buffer += MAX_USB_UART_PACKET_NUM;</span><br><span class="line">				&#125;</span><br><span class="line">				else //fifo数据小于60bytes</span><br><span class="line">				&#123;</span><br><span class="line">					usb_back_buf[2] = (len &amp; 0xff00) &gt;&gt; 8;</span><br><span class="line">					usb_back_buf[3] = (len &amp; 0x00ff);</span><br><span class="line">					memcpy(&amp;usb_back_buf[4], buffer, len);</span><br><span class="line">					usb_send(usb_back_buf, USB_TIMEOUT_TIME);</span><br><span class="line">					len = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else //USB-CDC模式</span><br><span class="line">			CDC_Transmit_FS(inter_buffer, len, USB_TIMEOUT_TIME);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>USB-HID发送数据的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint8_t usb_send(uint8_t *send_data,uint32_t time_out)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t tickstart = 0U;</span><br><span class="line">	tickstart = HAL_GetTick();</span><br><span class="line">	</span><br><span class="line">	 while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(USBD_OK == USBD_CUSTOM_HID_SendReport(&amp;hUsbDeviceFS, send_data, USBD_CUSTOMHID_OUTREPORT_BUF_SIZE))</span><br><span class="line">			return USBD_OK;</span><br><span class="line">		if((HAL_GetTick() - tickstart) &gt; time_out)</span><br><span class="line">			return USB_SEND_TIMEOUT;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>USB Custom HID的实现在此不详细分析，参考固件库Sample code和 <a target="_blank" rel="noopener" href="https://wiki.st.com/stm32mcu/wiki/Introduction_to_USB_with_STM32#CustomHID_Class">5.3.2.2 CustomHID Class</a></p>
<h3 id="USB-COMPOSITE设计"><a href="#USB-COMPOSITE设计" class="headerlink" title="USB COMPOSITE设计"></a>USB COMPOSITE设计</h3><p>为什么这里USB能同时支持HID和CDC两种方式？这里有USBD_COMPOSITE的概念：</p>
<p>USB设备初始化时，注册class是USBD_COMPOSITE类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USBD_RegisterClass(&amp;hUsbDeviceFS, &amp;USBD_COMPOSITE) != USBD_OK</span><br></pre></td></tr></table></figure>

<p>compisite指USB可以工作为不同设备类型，其描述符包含HID&#x2F;CDC多种模式：Middlewares\ST\STM32_USB_Device_Library\Class\usbd_composite.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">/* USB composite device Configuration Descriptor */</span><br><span class="line">/*   All Descriptors (Configuration, Interface, Endpoint, Class, Vendor */</span><br><span class="line">__ALIGN_BEGIN uint8_t USBD_Composite_CfgFSDesc[USBD_COMPOSITE_DESC_SIZE] __ALIGN_END =</span><br><span class="line">    &#123;</span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        /************** Descriptor of Custom HID interface ****************/</span><br><span class="line">        /* 09 */</span><br><span class="line">        0x09,                    /*bLength: Interface Descriptor size*/</span><br><span class="line">        USB_DESC_TYPE_INTERFACE, /*bDescriptorType: Interface descriptor type*/</span><br><span class="line">        USBD_HID_INTERFACE,      /*bInterfaceNumber: Number of Interface 接口编号 0 */</span><br><span class="line">        0x00,                    /*bAlternateSetting: Alternate setting  备用接口 */</span><br><span class="line">        0x02,                    /*bNumEndpoints 使用的端点数 1 */</span><br><span class="line">        0x03,                    /*bInterfaceClass: HID*/</span><br><span class="line">        0x00,                    /*bInterfaceSubClass : 1=BOOT, 0=no boot*/</span><br><span class="line">        0x00,                    /*nInterfaceProtocol : 0=none, 1=keyboard, 2=mouse*/</span><br><span class="line">        0,                       /*iInterface: Index of string descriptor*/</span><br><span class="line">        /******************** Descriptor of Custom HID ********************/</span><br><span class="line">        /* 18 */</span><br><span class="line">        0x09,                       /*bLength: HID Descriptor size*/</span><br><span class="line">        CUSTOM_HID_DESCRIPTOR_TYPE, /*bDescriptorType: HID*/</span><br><span class="line">        0x11,                       /*bcdHID: HID Class Spec release number*/</span><br><span class="line">        0x01,</span><br><span class="line">        0x00,                             /*bCountryCode: Hardware target country*/</span><br><span class="line">        0x01,                             /*bNumDescriptors: Number of HID class descriptors to follow*/</span><br><span class="line">        0x22,                             /*bDescriptorType*/</span><br><span class="line">        USBD_CUSTOM_HID_REPORT_DESC_SIZE, /*wItemLength: Total length of Report descriptor*/</span><br><span class="line">        0x00,</span><br><span class="line">        </span><br><span class="line">        /* 27 */</span><br><span class="line">        0x07,                   /*bLength: Endpoint Descriptor size*/</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT, /*bDescriptorType:*/</span><br><span class="line"></span><br><span class="line">        CUSTOM_HID_EPIN_ADDR, /*bEndpointAddress: Endpoint Address (IN)*/</span><br><span class="line">        0x03,                 /*bmAttributes: Interrupt endpoint*/</span><br><span class="line">        CUSTOM_HID_EPIN_SIZE, /*wMaxPacketSize: 16 Byte max */</span><br><span class="line">        0x00,</span><br><span class="line">        CUSTOM_HID_FS_BINTERVAL, /*bInterval: Polling Interval */</span><br><span class="line">        /* 34 */</span><br><span class="line"></span><br><span class="line">        0x07,                   /* bLength: Endpoint Descriptor size */</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT, /* bDescriptorType: */</span><br><span class="line">        CUSTOM_HID_EPOUT_ADDR,  /*bEndpointAddress: Endpoint Address (OUT)*/</span><br><span class="line">        0x03,                   /* bmAttributes: Interrupt endpoint */</span><br><span class="line">        CUSTOM_HID_EPOUT_SIZE,  /* wMaxPacketSize: 2 Bytes max  */</span><br><span class="line">        0x00,</span><br><span class="line">        CUSTOM_HID_FS_BINTERVAL, /* bInterval: Polling Interval */</span><br><span class="line">        /* 41 */</span><br><span class="line"></span><br><span class="line">        /****************************CDC************************************/</span><br><span class="line">        /* IAD描述符 */</span><br><span class="line">        /* Interface Association Descriptor */</span><br><span class="line">        USBD_IAD_DESC_SIZE,       // bLength</span><br><span class="line">        USBD_IAD_DESCRIPTOR_TYPE, // bDescriptorType</span><br><span class="line">        0x01,                     // bFirstInterface 接口描述符是在总的配置描述符中的第几个从0开始数 1</span><br><span class="line">        0x02,                     // bInterfaceCount 接口描述符数量 2</span><br><span class="line">        0x02,                     // bFunctionClass     CDC Control</span><br><span class="line">        0x02,                     // bFunctionSubClass  Abstract Control Model</span><br><span class="line">        0x01,                     // bInterfaceProtocol  AT Commands: V.250 etc</span><br><span class="line">        0x00,                     // iFunction</span><br><span class="line"></span><br><span class="line">        /* CDC命令接口描述符 */</span><br><span class="line">        /*Interface Descriptor */</span><br><span class="line">        0x09,                    /* bLength: Interface Descriptor size 长度 */</span><br><span class="line">        USB_DESC_TYPE_INTERFACE, /* bDescriptorType: Interface 接口编号0x04 */</span><br><span class="line">        /* Interface descriptor type */</span><br><span class="line">        USBD_CDC_CMD_INTERFACE, /* bInterfaceNumber: Number of Interface 接口编号，第一个接口编号为1 */</span><br><span class="line">        0x00,                   /* bAlternateSetting: Alternate setting 接口备用编号 0 */</span><br><span class="line">        0x01,                   /* bNumEndpoints: One endpoints used 非0端点的数目 1 cdc接口只使用了一个中断输入端点 */</span><br><span class="line">        0x02,                   /* bInterfaceClass: Communication Interface Class 接口所使用的类0x02 */</span><br><span class="line">        0x02,                   /* bInterfaceSubClass: Abstract Control Model 接口所使用的子类0x02 */</span><br><span class="line">        0x01,                   /* bInterfaceProtocol: Common AT commands 使用AT命令协议 */</span><br><span class="line">        0x00,                   /* iInterface: 接口字符串索引值 0表示没有 */</span><br><span class="line"></span><br><span class="line">        /* 类特殊接口描述符--功能描述符 用来描述接口的功能 */</span><br><span class="line">        /*Header Functional Descriptor*/</span><br><span class="line">        0x05, /* bLength: Endpoint Descriptor size 描述符长度为5字节 */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x00, /* bDescriptorSubtype: Header Func Desc 子类为 Header Func Desc，编号0x00 */</span><br><span class="line">        0x10, /* bcdCDC: spec release number CDC版本 */</span><br><span class="line">        0x01,</span><br><span class="line"></span><br><span class="line">        /*Call Management Functional Descriptor*/</span><br><span class="line">        0x05, /* bFunctionLength */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x01, /* bDescriptorSubtype: Call Management Func Desc 子类为Call Management Func Desc 编号0x01*/</span><br><span class="line">        0x00, /* bmCapabilities: D0+D1 设备自己不管理call management */</span><br><span class="line">        0x01, /* bDataInterface: 1 有一个数据类接口用作call management */</span><br><span class="line"></span><br><span class="line">        /*ACM Functional Descriptor*/</span><br><span class="line">        0x04, /* bFunctionLength */</span><br><span class="line">        0x24, /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE*/</span><br><span class="line">        0x02, /* bDescriptorSubtype: Abstract Control Management desc 子类为Abstract Control Management desc编号0x02*/</span><br><span class="line">        0x02, /* bmCapabilities 支持Set_Control_Line_State、Get_Line_Coding请求和Serial_State通知*/</span><br><span class="line"></span><br><span class="line">        /*Union Functional Descriptor*/</span><br><span class="line">        0x05,                    /* bFunctionLength */</span><br><span class="line">        0x24,                    /* bDescriptorType: CS_INTERFACE 描述符类型为类特殊接口CS_INTERFACE */</span><br><span class="line">        0x06,                    /* bDescriptorSubtype: Union func desc 子类为Union func desc 编号0x06*/</span><br><span class="line">        USBD_CDC_CMD_INTERFACE,  /* bMasterInterface: Communication class interface 编号为1的CDC接口 */</span><br><span class="line">        USBD_CDC_DATA_INTERFACE, /* bSlaveInterface0: Data Class Interface 编号为2的数据类接口 */</span><br><span class="line"></span><br><span class="line">        /*Endpoint 2 Descriptor*/</span><br><span class="line">        0x07,                        /* bLength: Endpoint Descriptor size */</span><br><span class="line">        USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */</span><br><span class="line">        CDC_CMD_EP,                  /* bEndpointAddress */</span><br><span class="line">        0x03,                        /* bmAttributes: Interrupt */</span><br><span class="line">        LOBYTE(CDC_CMD_PACKET_SIZE), /* wMaxPacketSize: */</span><br><span class="line">        HIBYTE(CDC_CMD_PACKET_SIZE),</span><br><span class="line">        CDC_FS_BINTERVAL, /* bInterval: */</span><br><span class="line">        /*---------------------------------------------------------------------------*/</span><br><span class="line">        .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如何选择工作模式：取决于上位机</p>
<p>如果上位机发送CDC数据，就使能CDC处理；否则默认是USB-HID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">USBD_CDC_ItfTypeDef USBD_CDC_Interface_fops_FS =</span><br><span class="line">&#123;</span><br><span class="line">  CDC_Init_FS,</span><br><span class="line">  CDC_DeInit_FS,</span><br><span class="line">  CDC_Control_FS,</span><br><span class="line">  CDC_Receive_FS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8_t cdc_receive_flag = 0;</span><br><span class="line">static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 6 */</span><br><span class="line">  USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[0]);</span><br><span class="line">  USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);</span><br><span class="line">  cdc_receive_flag = 1;</span><br><span class="line">  // 注意这里是中断回调，串口函数有锁</span><br><span class="line">  HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;Buf[0],*Len,UART_TIMEOUT_TIME);</span><br><span class="line">  return (USBD_OK);</span><br><span class="line">  /* USER CODE END 6 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理USB下发的控制信号"><a href="#处理USB下发的控制信号" class="headerlink" title="处理USB下发的控制信号"></a>处理USB下发的控制信号</h2><p>USB HID下发信号的处理函数是CUSTOM_HID_OutEvent_FS：</p>
<p>USB中断传输方式中，每次PC机发送数据后USB设备都会产生中断，设备每完成一次从PC机的Out data的接收都会响应一次OutEvent，因此可以通过修改usbd_custom_hid_if.c中的static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)来实现对接收到数据做处理。实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">USBD_CUSTOM_HID_ItfTypeDef USBD_CustomHID_fops_FS =</span><br><span class="line">&#123;</span><br><span class="line">  CUSTOM_HID_ReportDesc_FS,</span><br><span class="line">  CUSTOM_HID_Init_FS,</span><br><span class="line">  CUSTOM_HID_DeInit_FS,</span><br><span class="line">  CUSTOM_HID_OutEvent_FS //接收数据回调</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int8_t CUSTOM_HID_OutEvent_FS(uint8_t event_idx, uint8_t state)</span><br><span class="line">&#123;</span><br><span class="line">	uint16_t command ;</span><br><span class="line"></span><br><span class="line">    USB_Received_Count = USBD_GetRxCount( &amp;hUsbDeviceFS,CUSTOM_HID_EPOUT_ADDR );</span><br><span class="line">    </span><br><span class="line">    USBD_CUSTOM_HID_HandleTypeDef   *hhid; </span><br><span class="line">    hhid = pHIDData;</span><br><span class="line">    </span><br><span class="line">    //copy和解析</span><br><span class="line">	memcpy(usb_send_buf, hhid-&gt;Report_buf, USB_Received_Count);</span><br><span class="line">	command = usb_send_buf[0] &lt;&lt; 8 | usb_send_buf[1];</span><br><span class="line">	//这里做了个流程区分：如果是USB to UART则调用uart write流程；其他控制信号仅设置计数+1.</span><br><span class="line">	if(command ==WRITE_UART_FUNCITON)</span><br><span class="line">		write_uart_function();</span><br><span class="line">	else</span><br><span class="line">		usb_flag++;</span><br><span class="line">			</span><br><span class="line">  return (USBD_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MCU的while(1)处理usb_flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(1):</span><br><span class="line">	if (usb_flag)</span><br><span class="line">		&#123;</span><br><span class="line">			usb_flag--;</span><br><span class="line">			usb_handle_process();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>usb_handle_process就是对USB buffer的64byte解析并分发到各处理函数，基本实现IO control的机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void usb_handle_process(void)</span><br><span class="line">&#123;</span><br><span class="line">	command = usb_send_buf[0] &lt;&lt; 8 | usb_send_buf[1];</span><br><span class="line">	length = usb_send_buf[2] &lt;&lt; 8 | usb_send_buf[3];</span><br><span class="line"></span><br><span class="line">	switch (command)</span><br><span class="line">	&#123;</span><br><span class="line">	case UART_PARAMETER_SET:</span><br><span class="line">		uart_parameter_setting();</span><br><span class="line">		break;</span><br><span class="line">	case UART_PIN_LOW_SET:</span><br><span class="line">		uart_pin_low_set();</span><br><span class="line">		break;</span><br><span class="line">	case USB_TO_SPI_FUNCTION:</span><br><span class="line">		usb_to_spi_convert();</span><br><span class="line">		break;</span><br><span class="line">	case USB_TO_SPI_PARAMETER_SET:</span><br><span class="line">		spi_parameter_setting();</span><br><span class="line">		break;</span><br><span class="line">	....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不详细分析各switch case的内容，基本操作都是将usb_send_buf数据，通过SPI&#x2F;UART&#x2F;I2C….透传到MCU下游的芯片. </p>
<p>TODO：为什么UART write需要特殊处理，而不用usb_handle_process分发处理？</p>
<p>因为UART TX没有buffer，如果MCU收到UART write而不立即启动TX传输，上位机的USB 64bytes buffer可能被新的TX data覆盖掉？或者上位机有超时机制？</p>
<p>usb_handle_process只挑几个典型流程分析：</p>
<h3 id="jump-to-boot"><a href="#jump-to-boot" class="headerlink" title="jump_to_boot"></a>jump_to_boot</h3><p>这个用于MCU上直接升级Firmware（IAP）用到，目前开发阶段还没应用，以后用户升级可能用到。</p>
<p>使用函数指针，用调用函数的形式跳转到JumpAddress（0x08000004），即中断向量表的RESET入口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define BOOT_ADDR 0x08000000</span><br><span class="line">typedef void (*pFunction)(void);</span><br><span class="line"></span><br><span class="line">void jump_to_boot(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	uint32_t JumpAddress;</span><br><span class="line">	pFunction Jump_To_Application;</span><br><span class="line"></span><br><span class="line">	usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">	HAL_Delay(10);</span><br><span class="line">	__disable_irq();</span><br><span class="line"></span><br><span class="line">	JumpAddress = *(__IO uint32_t *)(BOOT_ADDR + 4);</span><br><span class="line">	Jump_To_Application = (pFunction)JumpAddress;</span><br><span class="line"></span><br><span class="line">	__HAL_RCC_SYSCFG_CLK_ENABLE();</span><br><span class="line">	__HAL_REMAPMEMORY_FLASH();</span><br><span class="line">	/* Initialize user application&#x27;s Stack Pointer */</span><br><span class="line">	__set_MSP(*(__IO uint32_t *)BOOT_ADDR);</span><br><span class="line">	*(uint32_t *)RAM_FROM_APP_FLAG_ADDR = RAM_FROM_APP_FLAG_DATA; // jump</span><br><span class="line">	Jump_To_Application();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uart-pin-low"><a href="#uart-pin-low" class="headerlink" title="uart_pin_low"></a>uart_pin_low</h3><p>此功能是BMS业务的流程，BMS chip的wakeup操作使用RX pin，拉低UART TX为低并保持一段时间，再拉高TX，形成BMS chip的wakeup。</p>
<p>注意这里不是为了形成UART break frame（也是RX拉低，保持一个byte的周期，再拉高），所以UART RX pin需要先析构，在GPIO模式下才能无UART协议干扰的产生BMS wakeup信号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void jaguar_uart_pin_low_fun(uint32_t ustimer)</span><br><span class="line">&#123;</span><br><span class="line">	MX_TIM6_Init(TIME_BASE_1US); //timer 1us精度</span><br><span class="line">	UART2_DeInit(); //uart2析构</span><br><span class="line">	jaguar_uart_gpio_fun(); //设置PA2,PA3为高，即UART的RX/TX pin</span><br><span class="line"></span><br><span class="line">	HAL_TIM_Base_Start_IT(&amp;htim6); //开始计时</span><br><span class="line">	jaguar_wire_pin_low(); //设置PA2（TX）为低</span><br><span class="line">	while (one_wire_timer_counter_1US &lt; ustimer) //ustimer来自USB-HID数据</span><br><span class="line">	&#123;</span><br><span class="line">		// printf(&quot;sync low tim:%d \r\n&quot;,one_wire_timer_counter100US);</span><br><span class="line">	&#125;;</span><br><span class="line">	jaguar_wire_pin_high(); //设置PA2（TX）为高</span><br><span class="line">	HAL_TIM_Base_Stop_IT(&amp;htim6); //结束计时</span><br><span class="line">	//设置波特率，这里如果UART之前设置过，就保持原值；否则默认值1M波特率</span><br><span class="line">	if (saved_baudrate != 0)</span><br><span class="line">		MX_USART2_UART_Init(saved_baudrate); // keep the baudrate(set by USB-HID uart-config command).</span><br><span class="line">	else</span><br><span class="line">		MX_USART2_UART_Init(1000000); // reset baud rate.</span><br><span class="line">	Rx_buf_pos = 0;</span><br><span class="line">	MX_TIM6_Init(TIME_BASE_100US);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usb-to-spi"><a href="#usb-to-spi" class="headerlink" title="usb_to_spi"></a>usb_to_spi</h3><p>前面没有详细分析SPI的传输，此处分析。</p>
<p>o2link spec定义的USB to SPI数据包格式：</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141701291.png" alt="image-20240514170141237"></p>
<p>SPI数据通信的原理：</p>
<p>SPI一般设置为全双工双向通信，利用移位register交换master&#x2F;slave两端的数据register(FIFO)里的数据。</p>
<p>全双工时，SPI不存在单向的发送或单向的接收，数据一定是“交换”的。firmware的关注点是用RX register发数据，还是从Tx register拿数据。</p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141715633.png" alt="image-20240514171557572"></p>
<p><img src="https://raw.githubusercontent.com/cursorhu/blog-images-on-picgo/master/images/202405141705044.png" alt="image-20240514170528006"></p>
<p>代码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void usb_to_spi_convert(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t recive_buf[SPI_MAX_DATA_NUM] = &#123;0&#125;;</span><br><span class="line">	uint8_t ret = 0;</span><br><span class="line"></span><br><span class="line">	if (usb_send_buf[SPI_LENGTH_SITE] &gt; 60)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = SPI_INVALID_PARAMETER;</span><br><span class="line">		usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//按o2link spec解析为SPI命令参数和数据，数据内容决定对下层DFE芯片register是读还是写</span><br><span class="line">	ret = usb_spi_convert_data(usb_send_buf[SPI_CHIPID_SITE], usb_send_buf[SPI_LENGTH_SITE], &amp;usb_send_buf[SPI_DATA_SITE], recive_buf);</span><br><span class="line">	if (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		usb_send_buf[0] |= 0x80;</span><br><span class="line">		usb_send_buf[2] = ret;</span><br><span class="line">	&#125;</span><br><span class="line">	//按o2link spec解析出返回数据</span><br><span class="line">	memcpy(&amp;usb_send_buf[SPI_DATA_SITE], recive_buf, usb_send_buf[SPI_LENGTH_SITE]);</span><br><span class="line">	usb_send(usb_send_buf, USB_TIMEOUT_TIME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint8_t usb_spi_convert_data(uint8_t dev_id,uint8_t data_num,uint8_t * write_buf,uint8_t *read_buf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    uint8_t ret = 0;</span><br><span class="line">    </span><br><span class="line">    //拉低CS片选</span><br><span class="line">    HAL_GPIO_WritePin(spi_gpio_cs_pins[dev_id].gpio_base,spi_gpio_cs_pins[dev_id].gpio_pin,GPIO_PIN_RESET);</span><br><span class="line">	//启动SPI传输</span><br><span class="line">    ret = HAL_SPI_TransmitReceive(&amp;hspi1, write_buf, read_buf, data_num ,SPI_TIMEOUT_TIME);</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_WritePin(spi_gpio_cs_pins[dev_id].gpio_base,spi_gpio_cs_pins[dev_id].gpio_pin,GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPI传输的8bit模式具体内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_TransmitReceive():</span><br><span class="line"></span><br><span class="line">hspi-&gt;pRxBuffPtr  = (uint8_t *)pRxData; //RX buffer的指针</span><br><span class="line">hspi-&gt;RxXferCount = Size;</span><br><span class="line">hspi-&gt;RxXferSize  = Size;</span><br><span class="line">hspi-&gt;pTxBuffPtr  = (uint8_t *)pTxData; //TX buffer的指针</span><br><span class="line">hspi-&gt;TxXferCount = Size;</span><br><span class="line">hspi-&gt;TxXferSize  = Size;</span><br><span class="line"></span><br><span class="line">/* Enable SPI peripheral */</span><br><span class="line">__HAL_SPI_ENABLE(hspi);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">/* Transmit and Receive data in 8 Bit mode */</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    while ((hspi-&gt;TxXferCount &gt; 0U) || (hspi-&gt;RxXferCount &gt; 0U))</span><br><span class="line">    &#123;</span><br><span class="line">      /* Check TXE flag */</span><br><span class="line">      //SPI_FLAG_TXE: SPI status flag: Tx buffer empty flag, 表示当前TX FIFO数据为空，可能是首次启动还没填数据或上次已传完</span><br><span class="line">      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) &amp;&amp; (hspi-&gt;TxXferCount &gt; 0U) &amp;&amp; (txallowed == 1U))</span><br><span class="line">      &#123;</span><br><span class="line">       // DR: SPI data register, 按uint8（byte）填数据</span><br><span class="line">        *(__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR = (*hspi-&gt;pTxBuffPtr);</span><br><span class="line">        //更新数据指针(准备下次传输)</span><br><span class="line">        hspi-&gt;pTxBuffPtr++;</span><br><span class="line">        hspi-&gt;TxXferCount--;</span><br><span class="line">        /* Next Data is a reception (Rx). Tx not allowed */</span><br><span class="line">        //处理完TX，下面必须处理RX</span><br><span class="line">        txallowed = 0U;</span><br><span class="line">        </span><br><span class="line">        /* Wait until RXNE flag is reset */</span><br><span class="line">        //SPI_FLAG_RXNE: Rx buffer not empty flag, 有收到数据待处理</span><br><span class="line">          if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) &amp;&amp; (hspi-&gt;RxXferCount &gt; 0U))</span><br><span class="line">          &#123;</span><br><span class="line">          	//从DR register取数据到RX buffer</span><br><span class="line">            (*(uint8_t *)hspi-&gt;pRxBuffPtr) = *(__IO uint8_t *)&amp;hspi-&gt;Instance-&gt;DR;</span><br><span class="line">            hspi-&gt;pRxBuffPtr++;</span><br><span class="line">            hspi-&gt;RxXferCount--;</span><br><span class="line">            /* Next Data is a Transmission (Tx). Tx is allowed */</span><br><span class="line">            //处理完RX，下一轮必须处理TX</span><br><span class="line">            txallowed = 1U;</span><br><span class="line">          &#125;</span><br><span class="line">          //超时判断</span><br><span class="line">          if ((((HAL_GetTick() - tickstart) &gt;=  Timeout) &amp;&amp; ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))</span><br><span class="line">          &#123;</span><br><span class="line">            errorcode = HAL_TIMEOUT;</span><br><span class="line">            goto error;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TX RX处理的判断标准是读SR register状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** @brief  Check whether the specified SPI flag is set or not.</span><br><span class="line">  * @param  __HANDLE__ specifies the SPI Handle.</span><br><span class="line">  *         This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral.</span><br><span class="line">  * @param  __FLAG__ specifies the flag to check.</span><br><span class="line">  *         This parameter can be one of the following values:</span><br><span class="line">  *            @arg SPI_FLAG_RXNE: Receive buffer not empty flag</span><br><span class="line">  *            @arg SPI_FLAG_TXE: Transmit buffer empty flag</span><br><span class="line">  *            @arg SPI_FLAG_CRCERR: CRC error flag</span><br><span class="line">  *            @arg SPI_FLAG_MODF: Mode fault flag</span><br><span class="line">  *            @arg SPI_FLAG_OVR: Overrun flag</span><br><span class="line">  *            @arg SPI_FLAG_BSY: Busy flag</span><br><span class="line">  *            @arg SPI_FLAG_FRE: Frame format error flag</span><br><span class="line">  *            @arg SPI_FLAG_FTLVL: SPI fifo transmission level</span><br><span class="line">  *            @arg SPI_FLAG_FRLVL: SPI fifo reception level</span><br><span class="line">  * @retval The new state of __FLAG__ (TRUE or FALSE).</span><br><span class="line">  */</span><br><span class="line">#define __HAL_SPI_GET_FLAG(__HANDLE__, __FLAG__) ((((__HANDLE__)-&gt;Instance-&gt;SR) &amp; (__FLAG__)) == (__FLAG__))</span><br></pre></td></tr></table></figure>

<p>为什么SPI传输TX，RX是同时又交替的处理数据：</p>
<p>SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</p>
<p>因此HAL_SPI_TransmitReceive()同时处理RX和TX，和UART的RX&#x2F;TX单向传输不同。</p>
<p>​	</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/STM32/" rel="tag"># STM32</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/30/UEFI%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="prev" title="UEFI开发（二）">
      <i class="fa fa-chevron-left"></i> UEFI开发（二）
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/30/STM32--%E6%90%AD%E5%BB%BAVSCode+STMCubeIDE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" rel="next" title="STM32--搭建VSCode+STMCubeIDE开发环境">
      STM32--搭建VSCode+STMCubeIDE开发环境 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32%E2%80%93Firmware-Architecture-part1%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8CHAL-API%E5%BA%94%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">STM32–Firmware Architecture part1：开发环境和HAL API应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32%E2%80%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-number">2.</span> <span class="nav-text">STM32–开发环境</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32%E2%80%93%E5%BF%85%E8%AF%BB%E6%89%8B%E5%86%8C%E5%92%8C%E5%9B%BA%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">STM32–必读手册和固件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C"><span class="nav-number">3.1.</span> <span class="nav-text">STM32开发手册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32%E5%9B%BA%E4%BB%B6%E5%8C%85"><span class="nav-number">3.2.</span> <span class="nav-text">STM32固件包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9ASTM32%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">小结：STM32项目的代码架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32%E2%80%93%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">STM32–编译过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Keil-style"><span class="nav-number">4.1.</span> <span class="nav-text">Keil style</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Keil%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE"><span class="nav-number">4.1.1.</span> <span class="nav-text">Keil编译配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keil%E9%93%BE%E6%8E%A5%E9%85%8D%E7%BD%AE"><span class="nav-number">4.1.2.</span> <span class="nav-text">Keil链接配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Makefile-style"><span class="nav-number">4.2.</span> <span class="nav-text">Makefile style</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#makefile%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE"><span class="nav-number">4.2.1.</span> <span class="nav-text">makefile编译配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#makefile%E9%93%BE%E6%8E%A5%E9%85%8D%E7%BD%AE"><span class="nav-number">4.2.2.</span> <span class="nav-text">makefile链接配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BE%93%E5%87%BA-elf-hex-bin-axf%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text">编译输出: elf,hex,bin,axf的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E8%BE%93%E5%87%BA%E7%9A%84-map%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="nav-number">4.4.</span> <span class="nav-text">链接输出的.map符号表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32%E2%80%93%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">STM32–启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%BD%8D%E7%BD%AE"><span class="nav-number">5.1.</span> <span class="nav-text">启动位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#startup-s"><span class="nav-number">5.2.</span> <span class="nav-text">startup.s</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E4%BC%AA%E6%B1%87%E7%BC%96"><span class="nav-number">5.3.</span> <span class="nav-text">指令集与伪汇编</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32%E2%80%93main%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">STM32–main初始化流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HAL-Init"><span class="nav-number">6.1.</span> <span class="nav-text">HAL_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SystemClock-Config"><span class="nav-number">6.2.</span> <span class="nav-text">SystemClock_Config</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-GPIO-Init"><span class="nav-number">6.3.</span> <span class="nav-text">MX_GPIO_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-DMA-Init"><span class="nav-number">6.4.</span> <span class="nav-text">MX_DMA_Init</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%E7%9A%84%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C"><span class="nav-number">6.4.1.</span> <span class="nav-text">DMA的常规操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA-Init%E5%92%8CIRQ-handler"><span class="nav-number">6.4.2.</span> <span class="nav-text">DMA_Init和IRQ handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA-channel%E5%92%8C%E5%A4%96%E8%AE%BE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-number">6.4.3.</span> <span class="nav-text">DMA channel和外设的对应关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-I2C1-Init"><span class="nav-number">6.5.</span> <span class="nav-text">MX_I2C1_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-SPI1-Init"><span class="nav-number">6.6.</span> <span class="nav-text">MX_SPI1_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-USART1-UART-Init"><span class="nav-number">6.7.</span> <span class="nav-text">MX_USART1_UART_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-USART2-UART-Init"><span class="nav-number">6.8.</span> <span class="nav-text">MX_USART2_UART_Init</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UART2%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">6.8.1.</span> <span class="nav-text">UART2初始化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UART%E7%9A%84DMA%E4%BC%A0%E8%BE%93%E5%B0%8F%E7%BB%93"><span class="nav-number">6.8.2.</span> <span class="nav-text">UART的DMA传输小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-USART3-UART-Init"><span class="nav-number">6.9.</span> <span class="nav-text">MX_USART3_UART_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-USB-DEVICE-Init"><span class="nav-number">6.10.</span> <span class="nav-text">MX_USB_DEVICE_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-CAN-Init"><span class="nav-number">6.11.</span> <span class="nav-text">MX_CAN_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MX-TIM6-Init"><span class="nav-number">6.12.</span> <span class="nav-text">MX_TIM6_Init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E8%83%BDirq%E5%92%8Csystick"><span class="nav-number">6.13.</span> <span class="nav-text">使能irq和systick</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32%E2%80%93while-loop%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">STM32–while loop业务流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#systick%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4"><span class="nav-number">7.1.</span> <span class="nav-text">systick管理时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86UART-RX%E7%9A%84DMA%E6%95%B0%E6%8D%AE"><span class="nav-number">7.2.</span> <span class="nav-text">处理UART RX的DMA数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#USB-COMPOSITE%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.2.1.</span> <span class="nav-text">USB COMPOSITE设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86USB%E4%B8%8B%E5%8F%91%E7%9A%84%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="nav-number">7.3.</span> <span class="nav-text">处理USB下发的控制信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jump-to-boot"><span class="nav-number">7.3.1.</span> <span class="nav-text">jump_to_boot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uart-pin-low"><span class="nav-number">7.3.2.</span> <span class="nav-text">uart_pin_low</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usb-to-spi"><span class="nav-number">7.3.3.</span> <span class="nav-text">usb_to_spi</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cursorhu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">cursorhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cursorhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cursorhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cursorhu@outlook.com" title="E-Mail → mailto:cursorhu@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cursorhu</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
</body>
</html>
